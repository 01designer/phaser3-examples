(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 345);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ },
/* 1 */
/***/ function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,

    IMAGE: 20

};

module.exports = CONST;


/***/ },
/* 2 */
/***/ function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ },
/* 3 */
/***/ function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(344)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ },
/* 6 */
/***/ function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ },
/* 7 */
/***/ function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Rectangle;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(219);
var CONST = __webpack_require__(3);
var XHRLoader = __webpack_require__(220);
var XHRSettings = __webpack_require__(27);
var MergeXHRSettings = __webpack_require__(48);

var File = function (type, key, url, responseType, xhrSettings)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ },
/* 9 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    // console.log('FactoryContainer is alive');

    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            // console.log('Already registered', factory.KEY);

            return this.getType(factory.KEY);
        }

        // console.log('registering', factory.KEY);

        factories[factory.KEY] = {
            add: factory.add,
            make: factory.make
        };

        return factory;
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                // console.log('Loading', factory);

                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ },
/* 10 */
/***/ function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    if (range <= 0)
    {
        return 0;
    }

    var result = (value - min) % range;

    if (result < 0)
    {
        result += range;
    }

    return result + min;
};

module.exports = Wrap;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(10);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ },
/* 12 */
/***/ function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ },
/* 13 */
/***/ function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetObjectValue = function (source, key, defaultValue)
{
    if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                break;
            }
        }

        return value;
    }
    else
    {
        return (source.hasOwnProperty(key)) ? source[key] : defaultValue;
    }
};

module.exports = GetObjectValue;


/***/ },
/* 14 */
/***/ function(module, exports) {

var Event = function (type)
{
    this.type = type;

    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(100);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var ImageFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(72);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Children: __webpack_require__(29),
    Color: __webpack_require__(88),
    Data: __webpack_require__(89),
    Transform: __webpack_require__(90)

};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    * 
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    * 
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    return {
        create: create,
        create2D: create2D,
        createWebGL: createWebGL,
        first: first,
        remove: remove,
        total: total,
        free: free,
        pool: pool
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ },
/* 20 */
/***/ function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ },
/* 21 */
/***/ function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ },
/* 22 */
/***/ function(module, exports) {

/**
* Convert a distance along this curve into a `time` value which will be between 0 and 1.
* 
* For example if this curve has a length of 100 pixels then `findT(50)` would return `0.5`.
*
* @method Phaser.Hermite#findT
* @param {integer} distance - The distance into the curve in pixels. Should be a positive integer.
* @return {number} The time (`t`) value, a float between 0 and 1.
*/
var FindT = function (curve, distance)
{
    if (distance <= 0)
    {
        return 0;
    }

    //  Find the _points which bracket the distance value
    var ti = Math.floor(distance / curve.length * curve._accuracy);

    while (ti > 0 && curve._points[ti] > distance)
    {
        ti--;
    }

    while (ti < curve._accuracy && curve._points[ti] < distance)
    {
        ti++;
    }

    //  Linear interpolation to get a more accurate fix
    var dt = curve._points[ti] - curve._points[ti - 1];
    var d = distance - curve._points[ti - 1];

    return ((ti - 1) / curve._accuracy) + d / (dt * curve._accuracy);
};

module.exports = FindT;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Get a point on the curve using the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getPoint
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} An Object with the x, y coordinate of the curve at the specified `t` value set in its `x` and `y` properties.
*/
var GetPoint = function (curve, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    if (t < 0)
    {
        t = 0;
    }

    if (t > 1)
    {
        t = 1;
    }

    var t2 = t * t;
    var t3 = t * t2;

    out.x = t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x;
    out.y = t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y;

    return out;
};

module.exports = GetPoint;


/***/ },
/* 24 */
/***/ function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ },
/* 25 */
/***/ function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ },
/* 26 */
/***/ function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ },
/* 27 */
/***/ function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ },
/* 28 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 29 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child, skipTransform)
    {
        if (skipTransform === undefined) { skipTransform = false; }

        // console.log('--->', this.gameObject.name, 'adds new child:', child.name);

        if (child.parent === this)
        {
            // console.log('Children.add 1');
            return child;
        }
        else if (child.parent)
        {
            // console.log('Children.add 2');
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            // console.log(this.gameObject.name, 'adds transform from', child.name);
            this.gameObject.transform.add(child.transform);
        }

        // console.log('<--- end');

        return child;
    },

    addAt: function (child, index, skipTransform)
    {
        if (index === undefined) { index = 0; }
        if (skipTransform === undefined) { skipTransform = false; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            this.gameObject.transform.add(child.transform);
        }

        return child;

    },

    addMultiple: function (children, skipTransform)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i], skipTransform);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child, skipTransform)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }
        
        return child;
    },

    removeAt: function (index, skipTransform)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild, skipTransform)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild, skipTransform);
            }

            this.remove(oldChild, skipTransform);

            this.addAt(newChild, index, skipTransform);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2, skipTransform)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1, skipTransform);

        parentChildren.remove(child2, skipTransform);

        this.addAt(child2, index1, skipTransform);

        parentChildren.addAt(child1, index2, skipTransform);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(19);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();
    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    var yellow = new Image();
    yellow.src = pngHead + '/wCKxvRF' + pngEnd;

    var canvas = CanvasPool.create(this, 6, 1);
    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    if (!context.getImageData(2, 0, 1, 1))
    {
        return false;
    }

    var data = context.getImageData(2, 0, 1, 1).data;

    CanvasPool.remove(this);

    return (data[0] === 255 && data[1] === 0 && data[2] === 0);
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var CanvasPool = __webpack_require__(19);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ },
/* 32 */
/***/ function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var MATH_CONST = __webpack_require__(2);
var ScaleModes = __webpack_require__(12);
var Component = __webpack_require__(18);
var WrapAngle = __webpack_require__(11);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
* It hides away the 'private' stuff and exposes only the useful getters, setters and properties.
*
* @class
*/

//  Phaser.Texture and Phaser.Frame objects passed in here, instead of looked-up.
//  Allows override from non-standard GO types

var GameObject = function (state, x, y, texture, frame, parent)
{
    this.state = state;

    this.game = state.game;

    this.name = '';

    this.type = 0;

    this.parent = parent;

    //  Texture is globally shared between GameObjects, not specific to this one
    this.texture = texture;

    //  Frame is globally shared between GameObjects, not specific to this one
    this.frame = frame;

    //  All GameObjects have the following components, always:
    this.transform = new Component.Transform(this, x, y);

    //  Optional? Maybe set on a per GO basis?
    this.data = new Component.Data(this);

    this.color = new Component.Color(this);

    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------
    //  The following properties are debatable to have in this class
    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------

    this.scaleMode = ScaleModes.DEFAULT;

    //  Allows you to turn off a GameObject from rendering, but still render its children (if it has any)
    //  Maybe this should move?
    // this.skipRender = (key === undefined);
    this.skipRender = false;

    this.visible = true;

    //  Either null, or the Children component
    this.children = null;

    this.exists = true;
};

GameObject.prototype.constructor = GameObject;

GameObject.prototype = {

    preUpdate: function ()
    {
        //  NOOP
    },

    update: function ()
    {
        //  NOOP
    },

    postUpdate: function ()
    {
        //  NOOP
    },

    render: function ()
    {
        //  NOOP
    },

    destroy: function ()
    {
        //  NOOP
    }

};

Object.defineProperties(GameObject.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform._anchorX = value;
            this.transform.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorY;
        },

        set: function (value)
        {
            this.transform._anchorY = value;
            this.transform.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

    //  Color getters / setters

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.color._alpha;
        },

        set: function (value)
        {
            this.color.alpha = value;
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this.color._blendMode;
        },

        set: function (value)
        {
            this.color.blendMode = value;
        }

    }

});

module.exports = GameObject;


/***/ },
/* 34 */
/***/ function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ },
/* 35 */
/***/ function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

var GetPoint = __webpack_require__(23);

/**
* Calculate and return the angle, in radians, of the curves tangent based on time.
*
* @method Phaser.Hermite#getAngle
* @param {number} [t=0] - The `t` (time) value at which to find the angle. Must be between 0 and 1.
* @return {number} The angle of the line at the specified `t` time value along the curve. The value is in radians.
*/
var GetAngle = function (curve, t)
{
    if (t === undefined) { t = 0; }

    GetPoint(curve, t - 0.01, curve._temp1);
    GetPoint(curve, t + 0.01, curve._temp2);

    return Math.atan2(curve._temp2.y - curve._temp1.y, curve._temp2.x - curve._temp1.x);
};

module.exports = GetAngle;


/***/ },
/* 37 */
/***/ function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ },
/* 38 */
/***/ function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ },
/* 39 */
/***/ function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    if (x1 === undefined) { x1 = 0; }
    if (y1 === undefined) { y1 = 0; }
    if (x2 === undefined) { x2 = 0; }
    if (y2 === undefined) { y2 = 0; }

    this.x1 = x1;

    this.y1 = y1;

    this.x2 = x2;

    this.y2 = y2;
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Wrap = __webpack_require__(10);
var Angle = __webpack_require__(6);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ },
/* 41 */
/***/ function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ },
/* 42 */
/***/ function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ },
/* 43 */
/***/ function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(41);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ },
/* 45 */
/***/ function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ },
/* 46 */
/***/ function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ },
/* 47 */
/***/ function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(27);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;

};

module.exports = MergeXHRSettings;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(53);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ },
/* 51 */
/***/ function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ },
/* 52 */
/***/ function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ },
/* 53 */
/***/ function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ },
/* 54 */
/***/ function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ },
/* 55 */
/***/ function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ },
/* 56 */
/***/ function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ },
/* 57 */
/***/ function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ },
/* 58 */
/***/ function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ },
/* 59 */
/***/ function(module, exports) {

var CreateBuffer = function (gl, bufferType, usage, bufferData, bufferSize)
{
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    if (bufferData && ArrayBuffer.isView(bufferData))
    {
        gl.bufferData(bufferType, bufferData, usage);
    }
    else
    {
        gl.bufferData(bufferType, bufferSize, usage);
    }
    return buffer;
};

module.exports = CreateBuffer;


/***/ },
/* 60 */
/***/ function(module, exports) {

var IndexBuffer = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.shortView = new Int16Array(this.buffer);
    this.wordView = new Uint16Array(this.buffer);
};

IndexBuffer.prototype.clear = function ()
{
    this.wordLength = 0;
};

IndexBuffer.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

IndexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

IndexBuffer.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

IndexBuffer.prototype.getUsedBufferAsShort = function ()
{
    return this.shortView.subarray(0, this.dwordLength);
};

IndexBuffer.prototype.getUsedBufferAsWord = function ()
{
    return this.wordView.subarray(0, this.dwordLength);
};

module.exports = IndexBuffer;


/***/ },
/* 61 */
/***/ function(module, exports) {

var VertexBuffer = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

VertexBuffer.prototype.clear = function ()
{
    this.dwordLength = 0;
};

VertexBuffer.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

VertexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

VertexBuffer.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

VertexBuffer.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = VertexBuffer;


/***/ },
/* 62 */
/***/ function(module, exports) {

var CreateProgram = function (gl, vertexShader, fragmentShader)
{
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Failed to link program. Error: \n' + gl.getProgramInfoLog(program));
        return null;
    }
    return program;
};

module.exports = CreateProgram;


/***/ },
/* 63 */
/***/ function(module, exports) {

var CreateShader = function (gl, shaderSource, shaderType)
{
    var shader = null;
    shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.error('Failed ' + (shaderType === gl.VERTEX_SHADER ? 'vertex' : shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'invalid') + ' shader compilation. Error: \n' + gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
};

module.exports = CreateShader;


/***/ },
/* 64 */
/***/ function(module, exports) {

var BindVertexArray = function (gl, vao)
{
    var attributes = vao.attributes;
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.buffer);
    for (var index = 0, length = attributes.length; index < length; ++index)
    {
        var attrib = attributes[index];
        var location = attrib.location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(
            location,
            attrib.size,
            attrib.type,
            attrib.normalized,
            attrib.stride,
            attrib.offset
        );
    }
};

module.exports = BindVertexArray;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

var Attribute = __webpack_require__(314);

var CreateAttribDesc = function (gl, program, name, size, type, normalized, stride, offset)
{
    return new Attribute(
        gl.getAttribLocation(program, name),
        size,
        type,
        normalized,
        stride,
        offset
    );
};

module.exports = CreateAttribDesc;


/***/ },
/* 66 */
/***/ function(module, exports) {

var VertexArray = function (vbo, attributes)
{
    this.buffer = vbo;
    this.attributes = attributes;
};

module.exports = VertexArray;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(319);
var ScaleModes = __webpack_require__(12);
var GetObjectValue = __webpack_require__(13);

var Settings = function (state, config)
{
    if (typeof config === 'string')
    {
        config = { key: config };
    }
    else if (config === undefined)
    {
        //  Pass the 'hasOwnProperty' checks
        config = {};
    }

    this.state = state; //  Do we actually need this reference? This could just be a property bucket

    this.status = CONST.PENDING;

    //  Which part of this State is currently being processed?
    //  preload, create, update, shutdown, etc
    this.op = CONST.BOOT;

    this.key = GetObjectValue(config, 'key', '');
    this.active = GetObjectValue(config, 'active', false);
    this.visible = GetObjectValue(config, 'visible', true);
    this.scaleMode = GetObjectValue(config, 'scaleMode', ScaleModes.DEFAULT);
    this.fps = GetObjectValue(config, 'fps', 60);
    this.x = GetObjectValue(config, 'x', 0);
    this.y = GetObjectValue(config, 'y', 0);

    //  -1 means the State Manager will set it to be the Game dimensions
    this.width = GetObjectValue(config, 'width', -1);
    this.height = GetObjectValue(config, 'height', -1);

    //  Renderer Settings

    this.clearBeforeRender = GetObjectValue(config, 'clearBeforeRender', true);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.autoResize = GetObjectValue(config, 'autoResize', false);
    this.roundPixels = GetObjectValue(config, 'roundPixels', false);
    this.drawToPrimaryCanvas = GetObjectValue(config, 'drawToPrimaryCanvas', false);

};

//  Unless we add some actual functions in here, we'll make this just return an Object instead of an instance
Settings.prototype.constructor = Settings;

module.exports = Settings;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var EventDispatcher = __webpack_require__(15);
var GameObjectFactory = __webpack_require__(320);
// var GameObjectCreator = require('./systems/GameObjectCreator');
var Loader = __webpack_require__(321);
var MainLoop = __webpack_require__(322);
var UpdateManager = __webpack_require__(323);
var Component = __webpack_require__(18);
var Camera = __webpack_require__(86);

var Systems = function (state, config)
{
    this.state = state;

    this.config = config;

    this.events;

    //  Reference to the global Game level TextureManager.
    this.textures;

    //  State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.make;
    this.input;
    this.load;
    this.tweens;
    this.mainloop;
    this.updates;

    //  State specific properties (transform, data, children, etc)
    this.camera;
    this.children;
    this.color;
    this.data;
    this.fbo;
    this.time;
    this.transform;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function ()
    {
        console.log('State.Systems.init');

        this.textures = this.state.game.textures;

        //  All of the systems can use the State level EventDispatcher, or their own
        this.events = new EventDispatcher();

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)
        //  All these to be set by a State Config package

        this.add = new GameObjectFactory(this.state);
        // this.make = GameObjectCreator(this.state);
        this.mainloop = new MainLoop(this.state, this.state.settings.fps);
        this.updates = new UpdateManager(this.state);
        this.load = new Loader(this.state);

        // this.tweens = new Phaser.TweenManager(this.state);
        // this.input = new Phaser.State.Input(this.state);
        // this.physics = new Phaser.Physics.Arcade(this.state, 800, 600);

        //  State specific properties (transform, data, children, etc)
        this.camera = new Camera(this.state, 0, 0, 800, 600);
        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);
        this.transform = this.camera.transform;

        //  Boot

        // this.input.init();

        //  Defaults

        this.state.events = this.events;
        this.state.add = this.add;
        this.state.load = this.load;
        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
        this.state.camera = this.camera;
        this.state.transform = this.camera.transform;
        this.state.textures = this.textures;



        // this.state.input = this.input;
        // this.state.state = this.state.game.state;

        //  Here we can check which Systems to install as properties into the State object
        //  (default systems always exist in here, regardless)
    },

    begin: function (timestamp, frameDelta)
    {
    },

    update: function (timestep, physicsStep)
    {
    },

    preRender: function ()
    {
    },

    end: function (fps, panic)
    {
        if (panic)
        {
            // This pattern introduces non-deterministic behavior, but in this case
            // it's better than the alternative (the application would look like it
            // was running very quickly until the simulation caught up to real
            // time).
            var discardedTime = Math.round(this.mainloop.resetFrameDelta());

            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
};

module.exports = Systems;


/***/ },
/* 69 */
/***/ function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ },
/* 70 */
/***/ function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ },
/* 71 */
/***/ function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ },
/* 72 */
/***/ function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf"))
        {
            return false;
        }
    } catch (e) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Config = __webpack_require__(83);
var DebugHeader = __webpack_require__(85);
var Device = __webpack_require__(95);

var AddToDOM = __webpack_require__(96);
var RequestAnimationFrame = __webpack_require__(99);
var DOMContentLoaded = __webpack_require__(97);

var CreateRenderer = __webpack_require__(84);
var RandomDataGenerator = __webpack_require__(285);
var StateManager = __webpack_require__(318);
var TextureManager = __webpack_require__(327);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
    * @protected
    */
    this.raf = new RequestAnimationFrame(this);

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager(this);

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    // this.cache = new Cache();

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = null;

    /**
    * @property {Phaser.StateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new StateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    //  Move this somewhere else? Math perhaps? Doesn't need to be a Game level system.
    this.rnd;

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        //  Probably move within Math
        this.rnd = new RandomDataGenerator(this.config.seed);

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.state.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.raf.start();
    },

    //  timestamp = DOMHighResTimeStamp
    update: function (timestamp)
    {
        this.state.step(timestamp);
    }

};

module.exports = Game;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Container = __webpack_require__(102);
var FactoryContainer = __webpack_require__(9);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Image = __webpack_require__(104);
var FactoryContainer = __webpack_require__(9);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Image(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(119),
    Ellipse: __webpack_require__(130),
    Hermite: __webpack_require__(137),
    Intersects: __webpack_require__(145),
    Line: __webpack_require__(165),
    Point: __webpack_require__(185),
    Polygon: __webpack_require__(190),
    Rectangle: __webpack_require__(217)

};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(256),
    Distance: __webpack_require__(259),
    Easing: __webpack_require__(271),
    Fuzzy: __webpack_require__(277),
    Interpolation: __webpack_require__(281),
    Pow2: __webpack_require__(284),
    Snap: __webpack_require__(289),

    //  Single functions
    Average: __webpack_require__(229),
    Bernstein: __webpack_require__(50),
    Between: __webpack_require__(51),
    CatmullRom: __webpack_require__(52),
    CeilTo: __webpack_require__(230),
    Clamp: __webpack_require__(231),
    DegToRad: __webpack_require__(232),
    Difference: __webpack_require__(233),
    Factorial: __webpack_require__(53),
    FloatBetween: __webpack_require__(234),
    FloorTo: __webpack_require__(235),
    Linear: __webpack_require__(54),
    MaxAdd: __webpack_require__(236),
    MinSub: __webpack_require__(237),
    Percent: __webpack_require__(238),
    RadToDeg: __webpack_require__(239),
    Rotate: __webpack_require__(240),
    RotateAround: __webpack_require__(241),
    RotateAroundDistance: __webpack_require__(242),
    RoundAwayFromZero: __webpack_require__(55),
    RoundTo: __webpack_require__(243),
    SinCosTableGenerator: __webpack_require__(244),
    SmootherStep: __webpack_require__(246),
    SmoothStep: __webpack_require__(245),
    Within: __webpack_require__(247),
    Wrap: __webpack_require__(10)

};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(296);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(295);


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(316)

};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(337),
    GetRandomElement: __webpack_require__(338),
    NumberArray: __webpack_require__(70),
    NumberArrayStep: __webpack_require__(339),
    RemoveRandomElement: __webpack_require__(340),
    RotateLeft: __webpack_require__(341),
    RotateRight: __webpack_require__(342),
    Shuffle: __webpack_require__(343),
    SpliceOne: __webpack_require__(71)

};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Extend: __webpack_require__(17),
    IsPlainObject: __webpack_require__(72)

};


/***/ },
/* 82 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(69);
var GetObjectValue = __webpack_require__(13);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetObjectValue(config, 'width', 1024);
    this.height = GetObjectValue(config, 'height', 768);

    this.resolution = GetObjectValue(config, 'resolution', 1);

    this.renderType = GetObjectValue(config, 'type', CONST.AUTO);

    this.parent = GetObjectValue(config, 'parent', null);
    this.canvas = GetObjectValue(config, 'canvas', null);
    this.canvasStyle = GetObjectValue(config, 'canvasStyle', null);

    this.stateConfig = GetObjectValue(config, 'state', null);

    this.seed = GetObjectValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    this.gameTitle = GetObjectValue(config, 'title', '');
    this.gameURL = GetObjectValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetObjectValue(config, 'version', '');

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetObjectValue(config, 'banner', null) === false);

    this.hidePhaser = GetObjectValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetObjectValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetObjectValue(config, 'banner.background', defaultBannerColor);
   
    this.forceSetTimeOut = GetObjectValue(config, 'forceSetTimeOut', false);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.pixelArt = GetObjectValue(config, 'pixelArt', false);

    //  Callbacks
    this.preBoot = GetObjectValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetObjectValue(config, 'callbacks.postBoot', NOOP);
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CanvasPool = __webpack_require__(19);
var Features = __webpack_require__(31);
var CanvasRenderer = __webpack_require__(300);
var WebGLRenderer = __webpack_require__(303);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        console.log('Creating WEBGL Renderer');
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        console.log('Creating Canvas Renderer');
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.context;
    }
};

module.exports = CreateRenderer;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CHECKSUM = __webpack_require__(87);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Component = __webpack_require__(18);
var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(11);

/**
* A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
* The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
*
* @class Phaser.Camera
* @constructor
* @param {Phaser.Game} game - Game reference to the currently running game.
* @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera
* @param {number} x - Position of the camera on the X axis
* @param {number} y - Position of the camera on the Y axis
* @param {number} width - The width of the view rectangle
* @param {number} height - The height of the view rectangle
*/
var Camera = function (state, x, y, viewportWidth, viewportHeight)
{
    /**
     * The State that this Camera belongs to. A Camera can only belong to one State, and a State only
     * has one Camera.
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    this.viewportWidth = viewportWidth;

    this.viewportHeight = viewportHeight;

    this.transform = new Component.Transform(this, x, y);

    /**
    * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
    * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
    * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
    *
    * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
    */
    // this.bounds = new Phaser.Rectangle(x, y, width, height);

    // this.bounds = new Phaser.Circle(x, y)

    /**
    * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.
    */
    this.atLimit = { x: false, y: false };
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    /**
    * Method called to ensure the camera doesn't venture outside of the game world.
    * Called automatically by Camera.update.
    *
    * @method Phaser.Camera#checkBounds
    * @protected
    */
    checkBounds: function ()
    {
        this.atLimit.x = false;
        this.atLimit.y = false;

        // var vx = this.view.x + this._shake.x;
        // var vw = this.view.right + this._shake.x;
        // var vy = this.view.y + this._shake.y;
        // var vh = this.view.bottom + this._shake.y;

        var vx = this.x;
        var vw = this.x + this.viewportWidth;
        var vy = this.y;
        var vh = this.y + this.viewportHeight;

        //  Make sure we didn't go outside the cameras bounds
        if (vx <= this.bounds.x * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = this.bounds.x * this.scale.x;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vw >= this.bounds.right * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = (this.bounds.right * this.scale.x) - this.width;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vy <= this.bounds.top * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = this.bounds.top * this.scale.y;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

        if (vh >= this.bounds.bottom * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = (this.bounds.bottom * this.scale.y) - this.height;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

    }

};

Object.defineProperties(Camera.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX + (this.viewportWidth * this.transform._scaleX);
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY + (this.viewportHeight * this.transform._scaleY);
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

});

module.exports = Camera;


/***/ },
/* 87 */
/***/ function(module, exports) {

var CHECKSUM = {
build: '8e926790-de9d-11e6-bab6-b1cd883c1600'
};
module.exports = CHECKSUM;

/***/ },
/* 88 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ },
/* 89 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(11);

/**
* 2D Transformation Component.
*
* @class
*/
var Transform = function (gameObject, x, y, scaleX, scaleY)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }

    this.gameObject = gameObject;

    this.state = (gameObject.state) ? gameObject.state : gameObject.parent.state;

    this.game = this.state.game;

    //  a = scale X
    //  b = shear Y
    //  c = shear X
    //  d = scale Y
    //  tx / ty = translation

    //  World Transform
    this.world = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Previous Transform (used for interpolation)
    this.old = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Cached Transform Calculations
    this.cache = { a: 1, b: 0, c: 0, d: 1, sr: 0, cr: 0 };

    //  GL Vertex Data
    this.glVertextData = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };

    //  Canvas SetTransform data
    this.canvasData = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0, dx: 0, dy: 0 };

    this.immediate = false;

    this.interpolate = false;

    this.hasLocalRotation = false;

    //  Private value holders, accessed via the getters and setters
    this._posX = x;
    this._posY = y;
    this._scaleX = scaleX;
    this._scaleY = scaleY;
    this._rotation = 0;
    this._pivotX = 0;
    this._pivotY = 0;
    this._anchorX = 0;
    this._anchorY = 0;

    this._worldRotation = 0;
    this._worldScaleX = scaleX;
    this._worldScaleY = scaleY;

    this._dirty = true;
    this._dirtyVertex = true;

    this.state.sys.updates.add(this);

    //  The parent Transform (NOT the parent GameObject, although very often they are related)
    this.parent = null;

    //  Any child Transforms of this one - note that they don't have to belong to Game Objects
    //  that are children of the owner of this Transform
    this.children = [];
};

Transform.prototype.constructor = Transform;

Transform.prototype = {

    add: function (child)
    {
        return this.addAt(child, this.children.length);
    },

    addAt: function (child, index)
    {
        //  Invalid child?
        if (child === this || child.parent === this || index < 0 || index > this.children.length)
        {
            console.log('Invalid child');
            return child;
        }

        //  Child already parented? Remove it
        if (child.parent)
        {
            child.parent.remove(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        this.dirty = true;

        this.updateAncestors();

        return child;
    },

    remove: function (child)
    {
        //  Invalid child?
        if (child === this || child.parent !== this)
        {
            return child;
        }

        var index = this.children.indexOf(child);

        if (index !== -1)
        {
            return this.removeAt(index);
        }
    },

    removeAt: function (index)
    {
        //  Valid index?
        if (index >= 0 && index < this.children.length)
        {
            var child = this.children.splice(index, 1);

            if (child[0])
            {
                child[0].parent = null;

                return child[0];
            }
        }
    },

    enableInterpolation: function ()
    {
        this.interpolate = true;

        this.syncInterpolation();
    },

    syncInterpolation: function ()
    {
        this._dirty = true;

        this.update();

        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;
    },

    disableInterpolation: function ()
    {
        this.interpolate = false;
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._posX = x;
        this._posY = y;

        return this.update();
    },

    setScale: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._scaleX = x;
        this._scaleY = y;
        this.updateCache();

        return this.update();
    },

    setPivot: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._pivotX = x;
        this._pivotY = y;

        return this.update();
    },

    setAnchor: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._anchorX = x;
        this._anchorY = y;

        this.dirty = true;
    },

    setRotation: function (rotation)
    {
        this.rotation = rotation;

        return this.update();
    },

    //  Updates the Transform.world object, ready for rendering
    //  Assuming this Transform is a root node (i.e. no transform parent)
    updateFromRoot: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromRoot');

            world.a = this.cache.a;
            world.b = this.cache.b;
            world.c = this.cache.c;
            world.d = this.cache.d;
            world.tx = this._posX - ((this._pivotX * this.cache.a) + (this._pivotY * this.cache.c));
            world.ty = this._posY - ((this._pivotX * this.cache.b) + (this._pivotY * this.cache.d));

            this._worldRotation = Math.atan2(-this.cache.c, this.cache.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromRoot FAST');

            world.a = this._scaleX;
            world.b = 0;
            world.c = 0;
            world.d = this._scaleY;
            world.tx = this._posX - (this._pivotX * this._scaleX);
            world.ty = this._posY - (this._pivotY * this._scaleY);

            this._worldRotation = 0;
        }

        this._worldScaleX = this._scaleX;
        this._worldScaleY = this._scaleY;

        return this;
    },

    updateFromParent: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        var parent = this.parent.world;
        var tx = 0;
        var ty = 0;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromParent', this.parent.name);

            var a = this.cache.a;
            var b = this.cache.b;
            var c = this.cache.c;
            var d = this.cache.d;

            tx = this._posX - ((this._pivotX * a) + (this._pivotY * c));
            ty = this._posY - ((this._pivotX * b) + (this._pivotY * d));

            world.a = (a * parent.a) + (b * parent.c);
            world.b = (a * parent.b) + (b * parent.d);
            world.c = (c * parent.a) + (d * parent.c);
            world.d = (c * parent.b) + (d * parent.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromParent FAST', this.parent.name);

            tx = this._posX - (this._pivotX * this._scaleX);
            ty = this._posY - (this._pivotY * this._scaleY);

            world.a = this._scaleX * parent.a;
            world.b = this._scaleX * parent.b;
            world.c = this._scaleY * parent.c;
            world.d = this._scaleY * parent.d;
        }

        this._worldRotation = Math.atan2(-this.world.c, this.world.d);

        world.tx = (tx * parent.a) + (ty * parent.c) + parent.tx;
        world.ty = (tx * parent.b) + (ty * parent.d) + parent.ty;

        this._worldScaleX = this._scaleX * Math.sqrt((world.a * world.a) + (world.c * world.c));
        this._worldScaleY = this._scaleY * Math.sqrt((world.b * world.b) + (world.d * world.d));

        return this;
    },

    updateAncestors: function ()
    {
        // console.log(this.name, 'Transform.updateAncestors');

        //  No parent? Then just update the children and leave, our job is done
        if (!this.parent)
        {
            // console.log(this.name, 'updateAncestors has no parent Transform');

            this.updateFromRoot();

            this.updateChildren();

            this.dirty = false;

            return this;
        }

        // console.log(this.name, 'start updateAncestors while');

        //  Gets all parent nodes, starting from this Transform.
        //  Then updates from the top, down, but only on the ancestors,
        //  not any other children - will give us accurate worldX etc properties

        var node = this.parent;
        var nodes = [];

        do
        {
            nodes.push(node);
            node = node.parent;
        }
        while (node);

        //  We've got all the ancestors in the 'nodes' array, let's loop it

        while (nodes.length)
        {
            node = nodes.pop();

            if (node.parent)
            {
                node.updateFromParent();
            }
            else
            {
                node.updateFromRoot();
            }
        }

        //  By this point all of this Transforms ancestors have been
        //  updated, in the correct order, so we can now do this one
        //  and any of its children too

        this.update();
    },

    updateChildren: function ()
    {
        // console.log(this.name, 'Transform.updateChildren');

        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i].update();
        }
    },

    updateFromDirtyParent: function ()
    {
        // console.log(this.name, 'is updateFromDirtyParent', this.parent.name);

        this.updateFromParent();

        if (this.children.length)
        {
            for (var i = 0; i < this.children.length; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    update: function ()
    {
        if (!this._dirty)
        {
            return;
        }

        //  If we got this far then this Transform is dirty
        //  so we need to update it from its parent
        //  and then force the update to all children

        if (this.parent)
        {
            this.updateFromParent();
        }
        else
        {
            this.updateFromRoot();
        }

        var len = this.children.length;

        if (len)
        {
            for (var i = 0; i < len; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    updateCache: function ()
    {
        this.cache.a = this.cache.cr * this._scaleX;
        this.cache.b = this.cache.sr * this._scaleX;
        this.cache.c = -this.cache.sr * this._scaleY;
        this.cache.d = this.cache.cr * this._scaleY;
    },

    updateVertexData: function (interpolationPercentage, renderer)
    {
        if (!this.gameObject.frame || (!this._dirtyVertex && !this.interpolate))
        {
            return;
        }

        var frame = this.gameObject.frame;

        var w0;
        var h0;
        var w1;
        var h1;

        if (frame.data.trim)
        {
            //  If the sprite is trimmed, add the extra space before transforming
            w1 = frame.x - (this._anchorX * frame.width);
            w0 = w1 + frame.cutWidth;

            h1 = frame.y - (this._anchorY * frame.height);
            h0 = h1 + frame.cutHeight;
        }
        else
        {
            w0 = frame.cutWidth * (1 - this._anchorX);
            w1 = frame.cutWidth * -this._anchorX;

            h0 = frame.cutHeight * (1 - this._anchorY);
            h1 = frame.cutHeight * -this._anchorY;
        }

        var resolution = frame.source.resolution;

        var wt = this.world;

        var a = wt.a / resolution;
        var b = wt.b / resolution;
        var c = wt.c / resolution;
        var d = wt.d / resolution;
        var tx = wt.tx;
        var ty = wt.ty;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            a = old.a + ((a - old.a) * interpolationPercentage);
            b = old.b + ((b - old.b) * interpolationPercentage);
            c = old.c + ((c - old.c) * interpolationPercentage);
            d = old.d + ((d - old.d) * interpolationPercentage);
            tx = old.tx + ((tx - old.tx) * interpolationPercentage);
            ty = old.ty + ((ty - old.ty) * interpolationPercentage);
        }

        if (frame.rotated)
        {
            // var cw = frame.cutWidth;
            var ch = frame.height;
            var a0 = a;
            var b0 = b;
            var c0 = c;
            var d0 = d;
            var _w1 = w1;
            var _w0 = w0;

            //  Offset before rotating
            tx = (wt.c * ch) + tx;
            ty = (wt.d * ch) + ty;
            
            //  Rotate matrix by 90 degrees with precalc values for sine and cosine of rad(90)
            a = (a0 * 6.123233995736766e-17) + -c0;
            b = (b0 * 6.123233995736766e-17) + -d0;
            c = a0 + (c0 * 6.123233995736766e-17);
            d = b0 + (d0 * 6.123233995736766e-17);

            // Update UV coordinates
            frame.updateUVsInverted();

            // Rotate dimensions
            w0 = h0;
            w1 = h1;
            h0 = _w0;
            h1 = _w1;
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            tx |= 0;
            ty |= 0;
        }

        var vert = this.glVertextData;

        //  Top Left Vert
        vert.x0 = (a * w1) + (c * h1) + tx;
        vert.y0 = (d * h1) + (b * w1) + ty;

        //  Top Right Vert
        vert.x1 = (a * w0) + (c * h1) + tx;
        vert.y1 = (d * h1) + (b * w0) + ty;

        //  Bottom Right Vert
        vert.x2 = (a * w0) + (c * h0) + tx;
        vert.y2 = (d * h0) + (b * w0) + ty;

        //  Bottom Left Vert
        vert.x3 = (a * w1) + (c * h0) + tx;
        vert.y3 = (d * h0) + (b * w1) + ty;
        
        return vert;
    },

    getVertexData: function (interpolationPercentage, renderer)
    {
        if (this.interpolate || this._dirtyVertex)
        {
            this.updateVertexData(interpolationPercentage, renderer);

            this._dirtyVertex = false;
        }

        return this.glVertextData;
    },

    cloneVertexData: function ()
    {
        var src = this.glVertextData;

        return {
            x0: src.x0,
            y0: src.y0,
            x1: src.x1,
            y1: src.y1,
            x2: src.x2,
            y2: src.y2,
            x3: src.x3,
            y3: src.y3
        };
    },

    getCanvasTransformData: function (interpolationPercentage, renderer)
    {
        var frame = this.gameObject.frame;

        var world = this.world;
        var data = this.canvasData;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            data.a = old.a + ((world.a - old.a) * interpolationPercentage);
            data.b = old.b + ((world.b - old.b) * interpolationPercentage);
            data.c = old.c + ((world.c - old.c) * interpolationPercentage);
            data.d = old.d + ((world.d - old.d) * interpolationPercentage);
            data.tx = old.tx + ((world.tx - old.tx) * interpolationPercentage);
            data.ty = old.ty + ((world.ty - old.ty) * interpolationPercentage);
            data.dx = old.dx + ((frame.x - (this.anchorX * frame.width)) * interpolationPercentage);
            data.dy = old.dy + ((frame.y - (this.anchorY * frame.height)) * interpolationPercentage);
        }
        else
        {
            //  Copy over the values to the canvasData object, in case the renderer needs to adjust them
            data.a = world.a;
            data.b = world.b;
            data.c = world.c;
            data.d = world.d;
            data.tx = world.tx;
            data.ty = world.ty;
            data.dx = frame.x - (this.anchorX * frame.width);
            data.dy = frame.y - (this.anchorY * frame.height);
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            data.tx |= 0;
            data.ty |= 0;
            data.dx |= 0;
            data.dy |= 0;
        }

        return data;
    }

};

Object.defineProperties(Transform.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this._posX;
        },

        set: function (value)
        {
            this._posX = value;
            this.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this._posY;
        },

        set: function (value)
        {
            this._posY = value;
            this.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this._anchorX = value;
            this.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this._anchorY;
        },

        set: function (value)
        {
            this._anchorY = value;
            this.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this._pivotX;
        },

        set: function (value)
        {
            this._pivotX = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this._pivotY;
        },

        set: function (value)
        {
            this._pivotY = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            if (this._rotation === value)
            {
                return;
            }

            this._rotation = value;
            this.dirty = true;

            if (this._rotation % MATH_CONST.PI2)
            {
                this.cache.sr = Math.sin(this._rotation);
                this.cache.cr = Math.cos(this._rotation);
                this.updateCache();
                this.hasLocalRotation = true;
            }
            else
            {
                this.hasLocalRotation = false;
            }
        }

    },

    //  Sets this *component* as being dirty
    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    if (this.immediate)
                    {
                        this.update();
                    }
                    else
                    {
                        this._dirtyVertex = true;
                        this.state.sys.updates.add(this);
                    }
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    //  GLOBAL read-only properties from here on
    //  Need *all* parents taken into account to get the correct values

    name: {

        enumerable: true,

        get: function ()
        {
            return (this.gameObject) ? this.gameObject.name : '';
        }

    },

    worldRotation: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldRotation;
        }

    },

    worldScaleX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleX;
        }

    },

    worldScaleY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleY;
        }

    },

    worldX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.tx;
        }

    },

    worldY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.ty;
        }

    }

});

module.exports = Transform;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var Features = __webpack_require__(31);
var Input = __webpack_require__(93);
var Audio = __webpack_require__(91);
var Video = __webpack_require__(94);
var Fullscreen = __webpack_require__(92);
var CanvasFeatures = __webpack_require__(30);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ },
/* 96 */
/***/ function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(4);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ },
/* 98 */
/***/ function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ },
/* 99 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
function RequestAnimationFrame (game)
{
    /**
    * @property {Phaser.Game} game - The currently running game.
    */
    this.game = game;

    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.timeOutID = window.requestAnimationFrame(step);

        _this.game.update(timestamp);
    };

    var stepTimeout = function ()
    {
        _this.tick = Date.now();

        // _this.game.update(_this.tick);

        // _this.timeOutID = window.setTimeout(stepTimeout, _this.game.time.timeToCall);
    };

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    this.start = function ()
    {
        this.isRunning = true;

        if (this.game.config.forceSetTimeOut)
        {
            this.isSetTimeOut = true;

            this.timeOutID = window.setTimeout(stepTimeout, 0);
        }
        else
        {
            this.isSetTimeOut = false;

            this.timeOutID = window.requestAnimationFrame(step);
        }
    };

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    this.stop = function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    };

    this.destroy = function ()
    {
        this.stop();

        this.game = undefined;
    };

}

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

module.exports = RequestAnimationFrame;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(32);
var EventListener = __webpack_require__(101);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(32);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(33);
var ContainerWebGLRenderer = __webpack_require__(103);
var Children = __webpack_require__(29);

var Container = function (state, parent, x, y)
{
    GameObject.call(this, state, x, y, null, null, parent);

    this.type = CONST.CONTAINER;

    this.render = ContainerWebGLRenderer;

    this.children = new Children(this);
};

Container.prototype = Object.create(GameObject.prototype);
Container.prototype.constructor = Container;

Container.prototype.preUpdate = function ()
{
    this.children.preUpdate();
};

module.exports = Container;


/***/ },
/* 103 */
/***/ function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || src.children.list.length === 0)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.render(renderer, child);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(33);

/**
* An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
* It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
*
* @class Phaser.GameObject.Image
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/
var Image = function (state, x, y, key, frame)
{
    var _texture = state.game.textures.get(key);
    var _frame = _texture.get(frame);

    GameObject.call(this, state, x, y, _texture, _frame);

    this.type = CONST.IMAGE;
};

Image.prototype = Object.create(GameObject.prototype);
Image.prototype.constructor = Image;

Image.prototype.renderCanvas = __webpack_require__(105);
Image.prototype.renderWebGL = __webpack_require__(106);

Object.defineProperties(Image.prototype, {

    width: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    height: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    }

});

module.exports = Image;


/***/ },
/* 105 */
/***/ function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    var data = src.transform.getCanvasTransformData(interpolationPercentage, renderer);
    var tint = src.color._glTint;
    var bg = src.color._glBg;

    renderer.drawImage(frame, src.blendMode, data, alpha, tint, bg);
};

module.exports = ImageCanvasRenderer;


/***/ },
/* 106 */
/***/ function(module, exports) {


var ImageWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    // var verts = src.transform.getVertexData(interpolationPercentage, renderer);
    // var index = src.frame.source.glTextureIndex;
    // var tint = src.color._glTint;
    // var bg = src.color._glBg;
    // renderer.batch.add(frame.source, src.blendMode, verts, frame.uvs, index, alpha, tint, bg);

    var transform = src.transform;

    renderer.spriteBatch.add(
        0, 0,
        frame.cutWidth, frame.cutHeight,
        0, 0, 1, 1,
        transform.world.tx, transform.world.ty,
        transform._worldScaleX, transform._worldScaleY,
        transform._worldRotation
    );
};

module.exports = ImageWebGLRenderer;


/***/ },
/* 107 */
/***/ function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ },
/* 108 */
/***/ function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ },
/* 109 */
/***/ function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(34);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(20);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(20);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 113 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ },
/* 114 */
/***/ function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 116 */
/***/ function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ },
/* 117 */
/***/ function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(34);

Circle.Area = __webpack_require__(107);
Circle.Circumference = __webpack_require__(108);
Circle.CircumferencePoint = __webpack_require__(109);
Circle.Clone = __webpack_require__(110);
Circle.Contains = __webpack_require__(20);
Circle.ContainsPoint = __webpack_require__(111);
Circle.ContainsRect = __webpack_require__(112);
Circle.CopyFrom = __webpack_require__(113);
Circle.Equals = __webpack_require__(114);
Circle.GetBounds = __webpack_require__(115);
Circle.Offset = __webpack_require__(116);
Circle.OffsetPoint = __webpack_require__(117);
Circle.Random = __webpack_require__(118);

module.exports = Circle;


/***/ },
/* 120 */
/***/ function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(35);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(21);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(21);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 124 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 125 */
/***/ function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 127 */
/***/ function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ },
/* 128 */
/***/ function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(35);

Ellipse.Area = __webpack_require__(120);
Ellipse.Clone = __webpack_require__(121);
Ellipse.Contains = __webpack_require__(21);
Ellipse.ContainsPoint = __webpack_require__(122);
Ellipse.ContainsRect = __webpack_require__(123);
Ellipse.CopyFrom = __webpack_require__(124);
Ellipse.Equals = __webpack_require__(125);
Ellipse.GetBounds = __webpack_require__(126);
Ellipse.Offset = __webpack_require__(127);
Ellipse.OffsetPoint = __webpack_require__(128);
Ellipse.Random = __webpack_require__(129);

module.exports = Ellipse;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

var GetAngle = __webpack_require__(36);
var FindT = __webpack_require__(22);

/**
* Calculate and return the angle, in radians, of the curves tangent at the given pixel distance along the curves length.
*
* @method Phaser.Hermite#getAngleWithDistance
* @param {number} [distance=0] - The distance along the curve to get the angle from, in pixels.
* @return {number} The angle of the line at the specified distance along the curve. The value is in radians.
*/
var GetAngleWithDistance = function (curve, distance)
{
    if (distance === undefined) { distance = 0; }

    if (distance <= 0)
    {
        return Math.atan2(this._v1y, this._v1x);
    }
    else
    {
        return GetAngle(curve, FindT(curve, distance));
    }
};

module.exports = GetAngleWithDistance;


/***/ },
/* 132 */
/***/ function(module, exports) {

/**
* Get the angle of the curves entry point.
*
* @method Phaser.Hermite#getEntryTangent
* @param {Phaser.Point|Object} point - The Phaser.Point object, or an Object with public `x` and `y` properties, in which the tangent vector values will be stored.
* @return {Phaser.Point} A Point object containing the tangent vector of this Hermite curve.
*/
var GetEntryTangent = function (curve, point)
{
    point.x = curve._v1x;
    point.y = curve._v1y;

    return point;
};

module.exports = GetEntryTangent;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);
var GetPoint = __webpack_require__(23);
var FindT = __webpack_require__(22);

/**
* Get a point on the curve using the distance, in pixels, along the curve.
*
* @method Phaser.Hermite#getPointWithDistance
* @param {integer} [distance=0] - The distance along the curve to get the point from, given in pixels.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} The point on the line at the specified 'distance' along the curve.
*/
var GetPointWithDistance = function (curve, distance, out)
{
    if (distance === undefined) { distance = 0; }
    if (out === undefined) { out = new Point(); }

    if (distance <= 0)
    {
        out.x = this._p1x;
        out.y = this._p1y;
    }
    else
    {
        GetPoint(curve, FindT(curve, distance), out);
    }
    
    return out;
};

module.exports = GetPointWithDistance;


/***/ },
/* 134 */
/***/ function(module, exports) {

/**
* Get the X component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getX
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The X component of a point on the curve based on the `t` (time) value.
*/
var GetX = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x);
};

module.exports = GetX;


/***/ },
/* 135 */
/***/ function(module, exports) {

/**
* Get the Y component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getY
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The Y component of a point on the curve based on the `t` (time) value.
*/
var GetY = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y);
};

module.exports = GetY;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Pete Baron <pete@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A data representation of a Hermite Curve (see http://en.wikipedia.org/wiki/Cubic_Hermite_spline)
* 
* A Hermite curve has a start and end point and tangent vectors for both of them.
* The curve will always pass through the two control points and the shape of it is controlled
* by the length and direction of the tangent vectors.  At the control points the curve will
* be facing exactly in the vector direction.
* 
* As these curves change speed (speed = distance between points separated by an equal change in
* 't' value - see Hermite.getPoint) this class attempts to reduce the variation by pre-calculating
* the `accuracy` number of points on the curve. The straight-line distances to these points are stored
* in the private 'points' array, and this information is used by Hermite.findT() to convert a pixel
* distance along the curve into a 'time' value.
* 
* Higher `accuracy` values will result in more even movement, but require more memory for the points
* list. 5 works, but 10 seems to be an ideal value for the length of curves found in most games on
* a desktop screen. If you use very long curves (more than 400 pixels) you may need to increase
* this value further.
*
* @class Phaser.Hermite
* @constructor
* @param {number} p1x - The x coordinate of the start of the curve.
* @param {number} p1y - The y coordinate of the start of the curve.
* @param {number} p2x - The x coordinate of the end of the curve.
* @param {number} p2y - The y coordinate of the end of the curve.
* @param {number} v1x - The x component of the tangent vector for the start of the curve.
* @param {number} v1y - The y component of the tangent vector for the start of the curve.
* @param {number} v2x - The x component of the tangent vector for the end of the curve.
* @param {number} v2y - The y component of the tangent vector for the end of the curve.
* @param {number} [accuracy=10] The amount of points to pre-calculate on the curve.
*/
var Hermite = function (p1x, p1y, p2x, p2y, v1x, v1y, v2x, v2y, accuracy)
{
    if (accuracy === undefined) { accuracy = 10; }

    /**
    * @property {number} _accuracy - The amount of points to pre-calculate on the curve.
    * @private
    */
    this._accuracy = accuracy;

    /**
    * @property {number} _p1x - The x coordinate of the start of the curve.
    * @private
    */
    this._p1x = p1x;

    /**
    * @property {number} _p1y - The y coordinate of the start of the curve.
    * @private
    */
    this._p1y = p1y;

    /**
    * @property {number} _p2x - The x coordinate of the end of the curve.
    * @private
    */
    this._p2x = p2x;

    /**
    * @property {number} _p2y - The y coordinate of the end of the curve.
    * @private
    */
    this._p2y = p2y;

    /**
    * @property {number} _v1x - The x component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1x = v1x;

    /**
    * @property {number} _v1y - The y component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1y = v1y;

    /**
    * @property {number} _v2x - The x component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2x = v2x;

    /**
    * @property {number} _v2y - The y component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2y = v2y;
    
    /**
    * @property {array} _points - A local array of cached points.
    * @private
    */
    this._points = [];

    /**
    * @property {Phaser.Point} _temp1 - A local cached Point object.
    * @private
    */
    this._temp1 = new Point();

    /**
    * @property {Phaser.Point} _temp2 - A local cached Point object.
    * @private
    */
    this._temp2 = new Point();

    this.recalculate();
};

Hermite.prototype.constructor = Hermite;

Hermite.prototype = {

    /**
    * Performs the curve calculations.
    *
    * This is called automatically if you change any of the curves public properties, such as `Hermite.p1x` or `Hermite.v2y`.
    *
    * If you adjust any of the internal private values, then call this to update the points.
    *
    * @method Phaser.Hermite#recalculate
    * @return {Phaser.Hermite} This object.
    */
    recalculate: function () {

        this._ax = (2 * this._p1x - 2 * this._p2x + this._v1x + this._v2x);
        this._ay = (2 * this._p1y - 2 * this._p2y + this._v1y + this._v2y);
        this._bx = (-3 * this._p1x + 3 * this._p2x - 2 * this._v1x - this._v2x);
        this._by = (-3 * this._p1y + 3 * this._p2y - 2 * this._v1y - this._v2y);

        this.length = this.calculateEvenPoints();

        return this;

    },

    /**
    * Calculate a number of points along the curve, based on `Hermite.accuracy`, and stores them in the private `_points` array.
    *
    * @method Phaser.Hermite#calculateEvenPoints
    * @return {number} The total length of the curve approximated as straight line distances between the points.
    */
    calculateEvenPoints: function () {

        var totalLength = 0;

        this._temp1.setTo(0, 0);                    //  pnt
        this._temp2.setTo(this._p1x, this._p1y);    //  lastPnt

        this._points[0] = 0;

        for (var i = 1; i <= this._accuracy; i++)
        {
            this.getPoint(i / this._accuracy, this._temp1);
            totalLength += this._temp1.distance(this._temp2);
            this._points[i] = totalLength;
            this._temp2.copyFrom(this._temp1);
        }

        return totalLength;

    }

};

Object.defineProperties(Hermite.prototype, {

    /**
    * @name Phaser.Hermite#accuracy
    * @property {number} accuracy - The amount of points to pre-calculate on the curve.
    */
    accuracy: {

        enumerable: true,

        get: function ()
        {
            return this._accuracy;
        },

        set: function (value)
        {
            if (value !== this._accuracy)
            {
                this._accuracy = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1x
    * @property {number} p1x - The x coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1x: {

        enumerable: true,

        get: function () {

            return this._p1x;

        },

        set: function (value) {

            if (value !== this._p1x)
            {
                this._p1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p1y
    * @property {number} p1y - The y coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1y: {

        enumerable: true,

        get: function () {

            return this._p1y;

        },

        set: function (value) {

            if (value !== this._p1y)
            {
                this._p1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2x
    * @property {number} p2x - The x coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2x: {

        enumerable: true,

        get: function () {

            return this._p2x;

        },

        set: function (value) {

            if (value !== this._p2x)
            {
                this._p2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2y
    * @property {number} p2y - The y coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2y: {

        enumerable: true,

        get: function () {

            return this._p2y;

        },

        set: function (value) {

            if (value !== this._p2y)
            {
                this._p2y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1x
    * @property {number} v1x - The x component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1x: {

        enumerable: true,

        get: function () {

            return this._v1x;

        },

        set: function (value) {

            if (value !== this._v1x)
            {
                this._v1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1y
    * @property {number} v1y - The y component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1y: {

        enumerable: true,

        get: function () {

            return this._v1y;

        },

        set: function (value) {

            if (value !== this._v1y)
            {
                this._v1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2x
    * @property {number} v2x - The x component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2x: {

        enumerable: true,

        get: function () {

            return this._v2x;

        },

        set: function (value) {

            if (value !== this._v2x)
            {
                this._v2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2y
    * @property {number} v2y - The y component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2y: {

        enumerable: true,

        get: function () {

            return this._v2y;

        },

        set: function (value) {

            if (value !== this._v2y)
            {
                this._v2y = value;
                this.recalculate();
            }

        }

    }

});

module.exports = Hermite;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Hermite

var Hermite = __webpack_require__(136);

Hermite.FindT = __webpack_require__(22);
Hermite.GetAngle = __webpack_require__(36);
Hermite.GetAngleWithDistance = __webpack_require__(131);
Hermite.GetEntryTangent = __webpack_require__(132);
Hermite.GetPoint = __webpack_require__(23);
Hermite.GetPointWithDistance = __webpack_require__(133);
Hermite.GetX = __webpack_require__(134);
Hermite.GetY = __webpack_require__(135);

module.exports = Hermite;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(57);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ },
/* 139 */
/***/ function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);
var RectangleToRectangle = __webpack_require__(38);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var LineToLine = function (line1, line2, asSegment, out)
{
    if (asSegment === undefined) { asSegment = true; }
    if (out === undefined) { out = new Point(); }

    var a = line1.x1;
    var b = line1.y1;

    var e = line1.x2;
    var f = line1.y2;

    var a1 = b.y - a.y;
    var a2 = f.y - e.y;
    var b1 = a.x - b.x;
    var b2 = e.x - f.x;
    var c1 = (b.x * a.y) - (a.x * b.y);
    var c2 = (f.x * e.y) - (e.x * f.y);
    var denom = (a1 * b2) - (a2 * b1);

    if (denom === 0)
    {
        return null;
    }

    out.x = ((b1 * c2) - (b2 * c1)) / denom;
    out.y = ((a2 * c1) - (a1 * c2)) / denom;

    if (asSegment)
    {
        var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y));
        var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc;
        var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc;

        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)
        {
            return out;
        }
        else
        {
            return null;
        }
    }

    return out;
};

module.exports = LineToLine;


/***/ },
/* 142 */
/***/ function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(37);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ },
/* 144 */
/***/ function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {

    CircleToCircle: __webpack_require__(138),
    CircleToRectangle: __webpack_require__(139),
    GetRectangleIntersection: __webpack_require__(140),
    LineToLine: __webpack_require__(141),
    LineToRectangle: __webpack_require__(142),
    PointToLine: __webpack_require__(37),
    PointToLineSegment: __webpack_require__(143),
    RectangleToRectangle: __webpack_require__(38),
    RectangleToValues: __webpack_require__(144)

};


/***/ },
/* 146 */
/***/ function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

var Line = __webpack_require__(39);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ },
/* 148 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ },
/* 149 */
/***/ function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);
var Point = __webpack_require__(0);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ },
/* 152 */
/***/ function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ },
/* 153 */
/***/ function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ },
/* 154 */
/***/ function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ },
/* 157 */
/***/ function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(6);
var NormalAngle = __webpack_require__(40);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(24);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(24);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 162 */
/***/ function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ },
/* 163 */
/***/ function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ },
/* 164 */
/***/ function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(39);

Line.Angle = __webpack_require__(6);
Line.CenterOn = __webpack_require__(146);
Line.Clone = __webpack_require__(147);
Line.CopyFrom = __webpack_require__(148);
Line.Equals = __webpack_require__(149);
Line.GetMidPoint = __webpack_require__(150);
Line.GetNormal = __webpack_require__(151);
Line.GetPointsOnLine = __webpack_require__(152);
Line.Height = __webpack_require__(153);
Line.Length = __webpack_require__(154);
Line.NormalAngle = __webpack_require__(40);
Line.NormalX = __webpack_require__(155);
Line.NormalY = __webpack_require__(156);
Line.PerpSlope = __webpack_require__(157);
Line.Random = __webpack_require__(158);
Line.ReflectAngle = __webpack_require__(159);
Line.Rotate = __webpack_require__(160);
Line.RotateAroundPoint = __webpack_require__(161);
Line.RotateAroundXY = __webpack_require__(24);
Line.SetToAngle = __webpack_require__(162);
Line.Slope = __webpack_require__(163);
Line.Width = __webpack_require__(164);

module.exports = Line;


/***/ },
/* 166 */
/***/ function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ },
/* 167 */
/***/ function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ },
/* 169 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ },
/* 170 */
/***/ function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ },
/* 171 */
/***/ function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ },
/* 172 */
/***/ function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ },
/* 173 */
/***/ function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ },
/* 176 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ },
/* 178 */
/***/ function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ },
/* 179 */
/***/ function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(25);
var Point = __webpack_require__(0);
var GetMagnitudeSq = __webpack_require__(42);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(25);
var Point = __webpack_require__(0);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ },
/* 182 */
/***/ function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(44);
var Multiply = __webpack_require__(43);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ },
/* 184 */
/***/ function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(0);

Point.Add = __webpack_require__(166);
Point.Ceil = __webpack_require__(167);
Point.Clone = __webpack_require__(168);
Point.CopyFrom = __webpack_require__(169);
Point.Cross = __webpack_require__(170);
Point.Divide = __webpack_require__(171);
Point.Dot = __webpack_require__(25);
Point.Equals = __webpack_require__(172);
Point.Floor = __webpack_require__(173);
Point.GetCentroid = __webpack_require__(174);
Point.GetMagnitude = __webpack_require__(41);
Point.GetMagnitudeSq = __webpack_require__(42);
Point.Interpolate = __webpack_require__(175);
Point.Invert = __webpack_require__(176);
Point.Multiply = __webpack_require__(43);
Point.Negative = __webpack_require__(177);
Point.Normalize = __webpack_require__(44);
Point.NormalizeRightHand = __webpack_require__(178);
Point.Perp = __webpack_require__(179);
Point.Project = __webpack_require__(180);
Point.ProjectUnit = __webpack_require__(181);
Point.RPerp = __webpack_require__(182);
Point.SetMagnitude = __webpack_require__(183);
Point.Subtract = __webpack_require__(184);

module.exports = Point;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(46);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(45);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 188 */
/***/ function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ },
/* 189 */
/***/ function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(46);

Polygon.Clone = __webpack_require__(186);
Polygon.Contains = __webpack_require__(45);
Polygon.ContainsPoint = __webpack_require__(187);
Polygon.GetAABB = __webpack_require__(188);
Polygon.GetNumberArray = __webpack_require__(189);

module.exports = Polygon;


/***/ },
/* 191 */
/***/ function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ },
/* 192 */
/***/ function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ },
/* 193 */
/***/ function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ },
/* 194 */
/***/ function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(47);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 197 */
/***/ function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return
        (
            (rectB.x > rectA.x && rectB.x < rectA.right) && 
            (rectB.right > rectA.x && rectB.right < rectA.right)
        ) && (
            (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
            (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
        );
    
};

module.exports = ContainsRect;


/***/ },
/* 198 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 199 */
/***/ function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(26);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(26);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ },
/* 202 */
/***/ function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ },
/* 203 */
/***/ function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ },
/* 204 */
/***/ function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ },
/* 205 */
/***/ function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ },
/* 206 */
/***/ function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ },
/* 207 */
/***/ function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ },
/* 208 */
/***/ function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ },
/* 209 */
/***/ function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ },
/* 210 */
/***/ function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ },
/* 211 */
/***/ function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ },
/* 212 */
/***/ function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ },
/* 213 */
/***/ function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ },
/* 215 */
/***/ function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(7);

Rectangle.Area = __webpack_require__(191);
Rectangle.Ceil = __webpack_require__(192);
Rectangle.CeilAll = __webpack_require__(193);
Rectangle.CenterOn = __webpack_require__(194);
Rectangle.Clone = __webpack_require__(195);
Rectangle.Contains = __webpack_require__(47);
Rectangle.ContainsPoint = __webpack_require__(196);
Rectangle.ContainsRect = __webpack_require__(197);
Rectangle.CopyFrom = __webpack_require__(198);
Rectangle.Equals = __webpack_require__(199);
Rectangle.FitInside = __webpack_require__(200);
Rectangle.FitOutside = __webpack_require__(201);
Rectangle.Floor = __webpack_require__(202);
Rectangle.FloorAll = __webpack_require__(203);
Rectangle.GetAspectRatio = __webpack_require__(26);
Rectangle.GetCenter = __webpack_require__(204);
Rectangle.GetSize = __webpack_require__(205);
Rectangle.Inflate = __webpack_require__(206);
Rectangle.MergePoints = __webpack_require__(207);
Rectangle.MergeRect = __webpack_require__(208);
Rectangle.MergeXY = __webpack_require__(209);
Rectangle.Offset = __webpack_require__(210);
Rectangle.OffsetPoint = __webpack_require__(211);
Rectangle.Overlaps = __webpack_require__(212);
Rectangle.Perimeter = __webpack_require__(213);
Rectangle.Random = __webpack_require__(214);
Rectangle.Scale = __webpack_require__(215);
Rectangle.Union = __webpack_require__(216);

module.exports = Rectangle;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var Set = __webpack_require__(324);
var XHRSettings = __webpack_require__(27);
var Event = __webpack_require__(223);
var EventDispatcher = __webpack_require__(15);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update
    //  4) JSON loader
    //  5) XML Loader
    //  6) Multi File support (atlas + data)
    //  7) Atlas Loader

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log('BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log('Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ },
/* 219 */
/***/ function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(48);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(14);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(14);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(222),
    LOADER_COMPLETE_EVENT: __webpack_require__(221)

};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(16);
var JSONFile = __webpack_require__(49);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);
var ParseXML = __webpack_require__(98);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ },
/* 229 */
/***/ function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ },
/* 230 */
/***/ function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ },
/* 231 */
/***/ function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ },
/* 233 */
/***/ function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 234 */
/***/ function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ },
/* 235 */
/***/ function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ },
/* 236 */
/***/ function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ },
/* 237 */
/***/ function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ },
/* 238 */
/***/ function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ },
/* 240 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ },
/* 241 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ },
/* 242 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ },
/* 243 */
/***/ function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ },
/* 244 */
/***/ function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ },
/* 245 */
/***/ function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ },
/* 246 */
/***/ function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ },
/* 247 */
/***/ function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ },
/* 248 */
/***/ function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ },
/* 249 */
/***/ function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ },
/* 250 */
/***/ function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ },
/* 251 */
/***/ function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(56);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ },
/* 254 */
/***/ function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(10);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(248),
    BetweenY: __webpack_require__(251),
    BetweenPoints: __webpack_require__(249),
    BetweenPointsY: __webpack_require__(250),
    Reverse: __webpack_require__(252),
    RotateTo: __webpack_require__(253),
    ShortestBetween: __webpack_require__(254),
    Normalize: __webpack_require__(56),
    Wrap: __webpack_require__(11),
    WrapDegrees: __webpack_require__(255)

};


/***/ },
/* 257 */
/***/ function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ },
/* 258 */
/***/ function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(57),
    Power: __webpack_require__(257),
    Squared: __webpack_require__(258)

};


/***/ },
/* 260 */
/***/ function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 261 */
/***/ function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 262 */
/***/ function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 263 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 264 */
/***/ function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 265 */
/***/ function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 266 */
/***/ function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ },
/* 267 */
/***/ function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 268 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 269 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 270 */
/***/ function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(260),
    Bounce: __webpack_require__(261),
    Circular: __webpack_require__(262),
    Cubic: __webpack_require__(263),
    Elastic: __webpack_require__(264),
    Expo: __webpack_require__(265),
    Linear: __webpack_require__(266),
    Quadratic: __webpack_require__(267),
    Quartic: __webpack_require__(268),
    Quintic: __webpack_require__(269),
    Sine: __webpack_require__(270)

};


/***/ },
/* 272 */
/***/ function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ },
/* 273 */
/***/ function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ },
/* 274 */
/***/ function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ },
/* 275 */
/***/ function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ },
/* 276 */
/***/ function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(272),
    Equal: __webpack_require__(273),
    Floor: __webpack_require__(274),
    GreaterThan: __webpack_require__(275),
    LessThan: __webpack_require__(276)

};


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(50);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(52);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(54);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(278),
    CatmullRom: __webpack_require__(279),
    Linear: __webpack_require__(280)

};


/***/ },
/* 282 */
/***/ function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ },
/* 283 */
/***/ function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {module.export = {

    GetNext: __webpack_require__(282),
    IsSize: __webpack_require__(58),
    IsValue: __webpack_require__(283)

};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82)(module)))

/***/ },
/* 285 */
/***/ function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (typeof seeds === 'string')
    {
        this.state(seeds);
    }
    else
    {
        this.sow(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ },
/* 286 */
/***/ function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ },
/* 287 */
/***/ function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ },
/* 288 */
/***/ function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(286),
    Floor: __webpack_require__(287),
    To: __webpack_require__(288)

};


/***/ },
/* 290 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ },
/* 291 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ },
/* 292 */
/***/ function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ },
/* 293 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 294 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ },
/* 295 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ },
/* 296 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ },
/* 297 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28)))

/***/ },
/* 299 */
/***/ function(module, exports) {

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(1);
var DrawImage = __webpack_require__(301);
var GetBlendModes = __webpack_require__(302);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    //  Needed?
    this.game = game;

    //  Needed?
    this.type = CONST.CANVAS;

    //  Read all the following from game config (or State config?)
    this.clearBeforeRender = true;

    this.transparent = false;

    this.autoResize = false;

    // this.smoothProperty = Phaser.Canvas.getSmoothingPrefix(this.context);

    this.roundPixels = false;

    this.width = game.config.width * game.config.resolution;

    this.height = game.config.height * game.config.resolution;

    this.resolution = game.config.resolution;

    this.view = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.context = this.view.getContext('2d', { alpha: true });

    //  Map to the required function
    this.drawImage = DrawImage;

    this.blendModes = GetBlendModes();

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        // if (this.smoothProperty)
        // {
        //     this.context[this.smoothProperty] = (this.scaleMode === ScaleModes.LINEAR);
        // }
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, interpolationPercentage)
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.context;

        //  Add Pre-render hook

        //  TODO: A State should have the option of having its own canvas to draw to

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        if (this.clearBeforeRender)
        {
            ctx.clearRect(0, 0, this.width, this.height);
        }

        for (var c = 0; c < state.sys.children.list.length; c++)
        {
            var child = state.sys.children.list[c];

            child.renderCanvas(this, child, interpolationPercentage);
        }

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        //  Add Post-render hook
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.view = null;
        this.context = null;
    }

};

module.exports = CanvasRenderer;


/***/ },
/* 301 */
/***/ function(module, exports) {


var DrawImage = function (frame, blendMode, transform, alpha, tint, bg)
{
    var ctx = this.context;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== blendMode)
    {
        this.currentBlendMode = blendMode;
        ctx.globalCompositeOperation = this.blendModes[blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== alpha)
    {
        this.currentAlpha = alpha;
        ctx.globalAlpha = alpha;
    }

    //  Smoothing (should this be a Game Object, or Frame / Texture level property?)

    if (this.currentScaleMode !== frame.source.scaleMode)
    {
        // this.currentScaleMode = source.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, transform.dx, transform.dy, cd.dWidth, cd.dHeight);

};

module.exports = DrawImage;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

var modes = __webpack_require__(299);
var CanvasFeatures = __webpack_require__(30);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Mat Groves (@Doormat23)
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CreateEmptyTexture = __webpack_require__(312);
var CreateTexture2DImage = __webpack_require__(313);
var BlitterBatch = __webpack_require__(304);
var SpriteBatch = __webpack_require__(309);

var WebGLRenderer = function (game)
{
    this.game = game;

    this.type = CONST.WEBGL;

    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;

    this.view = game.canvas;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.contextLost = false;
    this.maxTextures = 1;
    this.multiTexture = false;
    this.blendModes = [];

    this.gl = null;

    this.init();

    this.blitterBatch = new BlitterBatch(game, this.gl, this);
    this.spriteBatch = new SpriteBatch(game, this.gl, this);

    this.batch = null;
    this.currentTexture2D = null;
};

WebGLRenderer.prototype.constructor = WebGLRenderer;

WebGLRenderer.prototype = {

    init: function ()
    {
        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }

        var gl = this.gl;

        /*
        //  Will need supporting

        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        if (this.maxTextures === 1)
        {
            this.multiTexture = false;
        }
        else
        {
            this.createMultiEmptyTextures();
        }

        this.emptyTexture = CreateEmptyTexture(this.gl, 1, 1, 0, 0);
        */

        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);

        gl.clearColor(1, 0, 0, 1);

        this.resize(this.width, this.height);

        /*
        //  Will need supporting

        this.extensions.compression = {};

        var etc1 = gl.getExtension('WEBGL_compressed_texture_etc1') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');
        var pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        var s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');

        if (etc1)
        {
            this.extensions.compression.ETC1 = etc1;
        }

        if (pvrtc)
        {
            this.extensions.compression.PVRTC = pvrtc;
        }

        if (s3tc)
        {
            this.extensions.compression.S3TC = s3tc;
        }
        */

        //  Map Blend Modes

        var add = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
        var normal = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        var multiply = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
        var screen = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendModes = [
            normal, add, multiply, screen, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal
        ];
    },

    createTexture2D: function (source)
    {
        var gl = this.gl;

        if (!source.glTexture)
        {
            source.glTexture = CreateTexture2DImage(gl, source.image, gl.NEAREST, 0);
        }

        this.currentTexture2D = source.glTexture;
    },

    setTexture2D: function (texture2D)
    {
        this.currentTexture = texture2D;
        this.batch.dirty = true;
    },

    setBatch: function (batch)
    {
        if (this.batch != batch)
        {
            if (this.batch)
            {
                this.batch.flush();
            }
            batch.bind();
            batch.setTexture2D(this.currentTexture2D, true);
            this.batch = batch;
        }
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);

        //  Needed?
        // this.clipUnitX = 2 / this.width;
        // this.clipUnitY = 2 / this.height;

        //  Needed?
        // this.projection.x = (this.width / 2) / res;
        // this.projection.y = -(this.height / 2) / res;
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, interpolationPercentage)
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        //  Add Pre-render hook

        var gl = this.gl;

        

        //  This is the old render loop - add what you need here to replace it,
        //  but please allow each State to render to its own Quad FBO

        //var fbo = state.sys.fbo;

        //fbo.activate();

        //  clear is needed for the FBO, otherwise corruption ...
        gl.clear(gl.COLOR_BUFFER_BIT);

        //this.setBlendMode(CONST.blendModes.NORMAL);

        //this.batch.start();

        //  Could move to the State Systems or MainLoop
        for (var c = 0; c < state.sys.children.list.length; c++)
        {
            var child = state.sys.children.list[c];

            child.renderWebGL(this, child, interpolationPercentage);
        }
        this.batch.flush();

        //this.batch.stop();

        //  Call state.render here, so we can do some extra shizzle on the top
        //  Maybe pass in the FBO texture too?

        //fbo.render(null);

        //  Unbind the fbo texture and replace it with an empty texture.
        //  If we forget this we corrupt the main context texture!
        //  or get `RENDER WARNING: there is no texture bound to the unit 0` spam in the console
        //gl.bindTexture(gl.TEXTURE_2D, this.emptyTexture);

        

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        //  Add Post-render hook
    },

    destroy: function ()
    {
        this.gl = null;
    },
    createFBO: function () {}
};

module.exports = WebGLRenderer;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

//  Could you move these into sub-folders please, i.e. 'vao', 'shader' etc?

var BindVertexArray = __webpack_require__(64);
var CreateProgram = __webpack_require__(62);
var CreateShader = __webpack_require__(63);
var CreateBuffer = __webpack_require__(59);
var CreateAttribDesc = __webpack_require__(65);
var VertexBuffer = __webpack_require__(61);
var IndexBuffer = __webpack_require__(60);
var VertexArray = __webpack_require__(66);

var PHASER_CONST = __webpack_require__(1);
var CONST = __webpack_require__(307);

var BlitterBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;

    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    this.glContext = gl;

    this.maxParticles = null;

    this.vertShader = null;
    this.fragShader = null;

    this.program = null;

    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;

    this.elementCount = 0;

    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

BlitterBatch.prototype.constructor = BlitterBatch;

BlitterBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new VertexBuffer(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);

        var indexDataBuffer = new IndexBuffer(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);

        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);

        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());

        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8)
        ];

        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);

        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;

        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;

        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;


        this.viewMatrixLocation = viewMatrixLocation;
           
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);

        var indexBuffer = indexDataBuffer.wordView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

            // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
            {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexDataBuffer.getUsedBufferAsWord());

        this.bind();

        this.resize(this.width, this.height);

        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, umin, vmin, umax, vmax)
    {
        this.manager.setBatch(this);

        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.PARTICLE_VERTEX_COMPONENT_COUNT * CONST.PARTICLE_VERTEX_COUNT);

        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        
        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;

        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;

        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;

        this.elementCount += CONST.PARTICLE_INDEX_COUNT;
    },

    setTexture2D: function (texture2D, force)
    {
        var gl = this.glContext;

        if (this.currentTexture2D !== texture2D || force)
        {
            this.flush();

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture2D);

            this.currentTexture2D = texture2D;
        }
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);

        gl.clearColor(0, 0, 0, 1);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);

        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);

        gl.disable(gl.BLEND);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height)
    {
        var gl = this.glContext;
        var res = this.game.config.resolution;
        
        this.width = width * res;
        this.height = height * res;
        
        this.view.width = this.width;
        this.view.height = this.height;
        
        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        gl.viewport(0, 0, this.width, this.height);

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.view.width, 0, 0, 0,
                0, -2 / this.view.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }

};

module.exports = BlitterBatch;


/***/ },
/* 305 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord);',
    '}'
].join('\n');


/***/ },
/* 306 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'varying vec2 v_tex_coord;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '}'
].join('\n');


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(305);
var VertexShader = __webpack_require__(306);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2)
    VERTEX_SIZE: 16,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 4,

    // Can't be bigger since index are 16-bit
    MAX_PARTICLES: 10000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 308 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord);',
    '}'
].join('\n');


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(64);
var CreateProgram = __webpack_require__(62);
var CreateShader = __webpack_require__(63);
var CreateBuffer = __webpack_require__(59);
var CreateAttribDesc = __webpack_require__(65);
var VertexBuffer = __webpack_require__(61);
var IndexBuffer = __webpack_require__(60);
var VertexArray = __webpack_require__(66);

var PHASER_CONST = __webpack_require__(1);
var CONST = __webpack_require__(311);

var SpriteBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;

    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    this.glContext = gl;

    this.maxSprites = null;

    this.vertShader = null;
    this.fragShader = null;

    this.program = null;

    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;

    this.elementCount = 0;

    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

SpriteBatch.prototype.constructor = SpriteBatch;

SpriteBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new VertexBuffer(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);

        var indexDataBuffer = new IndexBuffer(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);

        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);

        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());

        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_translate', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 16),
            CreateAttribDesc(gl, program, 'a_scale', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 24),
            CreateAttribDesc(gl, program, 'a_rotation', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 32)
        ];

        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);

        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;

        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;

        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;


        this.viewMatrixLocation = viewMatrixLocation;
           
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);

        var indexBuffer = indexDataBuffer.wordView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

            // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
            {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexDataBuffer.getUsedBufferAsWord());

        this.bind();

        this.resize(this.width, this.height);

        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, umin, vmin, umax, vmax, translateX, translateY, scaleX, scaleY, rotation)
    {
        this.manager.setBatch(this);

        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.SPRITE_VERTEX_COMPONENT_COUNT * CONST.SPRITE_VERTEX_COUNT);

        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = translateX;
        vertexBuffer[vertexOffset++] = translateY;
        vertexBuffer[vertexOffset++] = scaleX;
        vertexBuffer[vertexOffset++] = scaleY;
        vertexBuffer[vertexOffset++] = rotation;

        vertexBuffer[vertexOffset++] = x;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = translateX;
        vertexBuffer[vertexOffset++] = translateY;
        vertexBuffer[vertexOffset++] = scaleX;
        vertexBuffer[vertexOffset++] = scaleY;
        vertexBuffer[vertexOffset++] = rotation;
    
        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y + height;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = translateX;
        vertexBuffer[vertexOffset++] = translateY;
        vertexBuffer[vertexOffset++] = scaleX;
        vertexBuffer[vertexOffset++] = scaleY;
        vertexBuffer[vertexOffset++] = rotation;

        vertexBuffer[vertexOffset++] = x + width;
        vertexBuffer[vertexOffset++] = y;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = translateX;
        vertexBuffer[vertexOffset++] = translateY;
        vertexBuffer[vertexOffset++] = scaleX;
        vertexBuffer[vertexOffset++] = scaleY;
        vertexBuffer[vertexOffset++] = rotation;

        this.elementCount += CONST.SPRITE_INDEX_COUNT;
    },

    setTexture2D: function (texture2D, force)
    {
        var gl = this.glContext;

        if (this.currentTexture2D !== texture2D || force)
        {
            this.flush();

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture2D);

            this.currentTexture2D = texture2D;
        }
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);

        gl.clearColor(0, 0, 0, 1);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);

        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);

        gl.disable(gl.BLEND);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);

        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height)
    {
        var gl = this.glContext;
        var res = this.game.config.resolution;
        
        this.width = width * res;
        this.height = height * res;
        
        this.view.width = this.width;
        this.view.height = this.height;
        
        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        gl.viewport(0, 0, this.width, this.height);

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.view.width, 0, 0, 0,
                0, -2 / this.view.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }

};

module.exports = SpriteBatch;


/***/ },
/* 310 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute vec2 a_translate;',
    'attribute vec2 a_scale;',
    'attribute float a_rotation;',
    'varying vec2 v_tex_coord;',
    'void main () {',
    '   float t_cos = cos(a_rotation);',
    '   float t_sin = sin(a_rotation);',
    '   vec2 t_position = a_position * a_scale;',
    '   t_position = vec2(t_position.x * t_cos - t_position.y * t_sin, t_position.x * t_sin + t_position.y * t_cos);',
    '   t_position += a_translate;',
    '   gl_Position = u_view_matrix * vec4(t_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '}'
].join('\n');


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(308);
var VertexShader = __webpack_require__(310);

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float))
    VERTEX_SIZE: 36,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 9,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 10000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(12);

var CreateEmptyTexture = function (gl, width, height, scaleMode, textureIndex)
{
    var texture = gl.createTexture();
    var glScaleMode = (scaleMode === ScaleModes.LINEAR) ? gl.LINEAR : gl.NEAREST;

    gl.activeTexture(gl.TEXTURE0 + textureIndex);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    //  We'll read from this texture, but it won't have mipmaps, so turn them off:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glScaleMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glScaleMode);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    return texture;
};

module.exports = CreateEmptyTexture;


/***/ },
/* 313 */
/***/ function(module, exports) {

var CreateTexture2DImage = function (gl, pixels, filter, mipLevels)
{
    var texture = gl.createTexture();
    mipLevels = mipLevels || 0;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texImage2D(
        gl.TEXTURE_2D,
        mipLevels,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        pixels
    );
    return texture;
};

module.exports = CreateTexture2DImage;


/***/ },
/* 314 */
/***/ function(module, exports) {

var Attribute = function (location, size, type, normalize, stride, offset)
{
    this.location = location;
    this.size = size;
    this.type = type;
    this.normalize = normalize;
    this.stride = stride;
    this.offset = offset;
};

module.exports = Attribute;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {


var Between = __webpack_require__(51);
var GetObjectValue = __webpack_require__(13);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetObjectValue(config, 'frequency', 200);
    this.attack = GetObjectValue(config, 'attack', 0);
    this.decay = GetObjectValue(config, 'decay', 1);
    this.type = GetObjectValue(config, 'type', 'sine');
    this.volumeValue = GetObjectValue(config, 'volume', 1);
    this.panValue = GetObjectValue(config, 'pan', 0);
    this.wait = GetObjectValue(config, 'wait', 0);
    this.pitchBendAmount = GetObjectValue(config, 'pitchBend', 0);
    this.reverse = GetObjectValue(config, 'reverse', false);
    this.randomValue = GetObjectValue(config, 'random', 0);
    this.dissonance = GetObjectValue(config, 'dissonance', 0);
    this.echo = GetObjectValue(config, 'echo', false);
    this.echoDelay = GetObjectValue(config, 'echo.delay', 0);
    this.echoFeedback = GetObjectValue(config, 'echo.feedback', 0);
    this.echoFilter = GetObjectValue(config, 'echo.filter', 0);
    this.reverb = GetObjectValue(config, 'reverb', false);
    this.reverbDuration = GetObjectValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetObjectValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetObjectValue(config, 'reverb.reverse', false);
    this.timeout = GetObjectValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        console.log('onended');
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(315)

};


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Settings = __webpack_require__(67);
var Systems = __webpack_require__(68);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The properties a State *must* have, that cannot be changed without breaking it:

    this.game = null;

    //  Maybe just an object? Doesn't have to instantiate I don't think ...
    this.settings = new Settings(this, config);

    this.sys = new Systems(this, config);

    //  Reference to sys.children, set during sys.init only
    this.children;
};

State.prototype.constructor = State;

State.prototype = {

    //  Can be overridden by your own States
    preUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    update: function ()
    {
    },

    //  Can be overridden by your own States
    postUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(69);
var State = __webpack_require__(317);
var Settings = __webpack_require__(67);
var Systems = __webpack_require__(68);
var GetObjectValue = __webpack_require__(13);
// var LoaderEvent = require('../loader/events/');

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.StateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var StateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0)
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true
            });
        }
    }
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.StateManager#boot
    * @private
    */
    boot: function ()
    {
        // this.game.onPause.add(this.pause, this);
        // this.game.onResume.add(this.resume, this);

        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.StateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            // console.log('StateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('StateManager.add from instance', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('StateManager.add from object', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('StateManager.add from function', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.game = this.game;

        newState.settings.key = key;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.game = this.game;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.game = this.game;

            newState.settings = new Settings(newState, key);
            newState.sys = new Systems(newState);

            newState.sys.init();

            if (this.game.config.renderType === CONST.WEBGL)
            {
                this.createStateFrameBuffer(newState);
            }

            //  Default required functions
            return this.setupCallbacks(newState);
        }
    },

    setupCallbacks: function (newState, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = newState; }

        //  Extract callbacks or set NOOP

        newState.init = GetObjectValue(stateConfig, 'init', NOOP);
        newState.preload = GetObjectValue(stateConfig, 'preload', NOOP);
        newState.create = GetObjectValue(stateConfig, 'create', NOOP);
        newState.shutdown = GetObjectValue(stateConfig, 'shutdown', NOOP);

        newState.preUpdate = GetObjectValue(stateConfig, 'preUpdate', NOOP);
        newState.update = GetObjectValue(stateConfig, 'update', NOOP);
        newState.postUpdate = GetObjectValue(stateConfig, 'postUpdate', NOOP);
        newState.render = GetObjectValue(stateConfig, 'render', NOOP);

        return newState;
    },

    createStateFrameBuffer: function (newState)
    {
        var x = newState.settings.x;
        var y = newState.settings.y;

        if (newState.settings.width === -1)
        {
            newState.settings.width = this.game.config.width;
        }

        if (newState.settings.height === -1)
        {
            newState.settings.height = this.game.config.height;
        }

        var width = newState.settings.width;
        var height = newState.settings.height;

        newState.sys.fbo = this.game.renderer.createFBO(newState, x, y, width, height);
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                return this.active[i].index;
            }
        }

        return -1;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key)
    {
        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('StateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            //  + arguments
            if (state.init)
            {
                state.init.call(state);
            }

            if (state.preload && state.sys.load)
            {
                state.sys.load.reset();

                state.preload.call(state, this.game);

                //  Is the loader empty?
                if (state.sys.load.list.size === 0)
                {
                    this.startCreate(state);
                }
                else
                {
                    //  Start the loader going as we have something in the queue

                    state.sys.load.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                    state.sys.load.start();
                }
            }
            else
            {
                //  No preload? Then there was nothing to load either
                this.startCreate(state);
            }

        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        //  Make sure to do load-update one last time before state is set to _created

        //  Stop doing this ...
        if (state.hasOwnProperty('loadUpdate'))
        {
            state.loadUpdate.call(state);
        }

        this.startCreate(state);
    },

    startCreate: function (state)
    {
        if (state.create)
        {
            state.create.call(state);
        }

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates.bind(this));

        state.sys.updates.running = true;

        state.sys.mainloop.start();
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(key);

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates.bind(this));
        }
    },

    sortStates: function (stateA, stateB)
    {
        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    //  See if we can reduce this down to just update and render

    step: function (timestamp)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            if (state.sys.mainloop.running)
            {
                state.sys.mainloop.step(timestamp);
            }
        }
    },

    /*
    preUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].preUpdate();
            }

            state.preUpdate();
        }
    },

    update: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Invoke State Main Loop here - updating all of its systems (tweens, physics, etc)

            //  This shouldn't be called if the State is still loading
            //  Have a State.STATUS const in the Settings, dictating what is going on

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                var child = state.sys.children.list[c];

                if (child.exists)
                {
                    child.update();
                }
            }

            state.update();
        }
    },

    postUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].postUpdate();
            }

            state.postUpdate();
        }
    },

    render: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Can put all kinds of other checks in here, like MainLoop, FPS, etc.
            if (!state.settings.visible || state.sys.color.alpha === 0 || state.sys.children.list.length === 0)
            {
                continue;
            }

            this.game.renderer.render(state);
        }
    },
    */

};

module.exports = StateManager;


/***/ },
/* 319 */
/***/ function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(9);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var GameObjectFactory = {

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    state: null

};

function init (state)
{
    console.log('Creating GameObjectFactory instance for State');

    GameObjectFactory.state = state;

    //   Load the factories into this Object

    return FactoryContainer.load(GameObjectFactory, true);

    // return GameObjectFactory;
}

module.exports = init;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(3);
var BaseLoader = __webpack_require__(218);
var NumberArray = __webpack_require__(70);

var ImageFile = __webpack_require__(16);
var JSONFile = __webpack_require__(49);
var XMLFile = __webpack_require__(228);
var BinaryFile = __webpack_require__(225);
var GLSLFile = __webpack_require__(226);
var TextFile = __webpack_require__(227);
var AtlasJSONFile = __webpack_require__(224);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;

        textureURLs = NumberArray(0, total, key + '-', '.png');
        atlasURLs = NumberArray(0, total, key + '-', '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var textures = this.state.sys.textures;

    //  Process multiatlas groups first

    var file;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    this.storage.each(function (file)
    {
        if (file.type === 'image')
        {
            textures.addImage(file.key, file.data);
        }
        else if (file.type === 'atlasjson')
        {
            var fileA = file.fileA;
            var fileB = file.fileB;

            if (fileA.type === 'image')
            {
                textures.addAtlas(fileA.key, fileA.data, fileB.data);
            }
            else
            {
                textures.addAtlas(fileB.key, fileB.data, fileA.data);
            }
        }
        else if (file.type === 'json')
        {
            // console.dir(file.data);
        }
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ },
/* 322 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// My thanks to Isaac Sukin for creating MainLoop.js, on which lots of this is based.

var MainLoop = function (state, framerate)
{
    /**
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    // The amount of time (in milliseconds) to simulate each time update() runs.
    this.timestep = 1000 / framerate;

    this.physicsStep = 1 / framerate;

    // The cumulative amount of in-app time that hasn't been simulated yet.
    // See the comments inside animate() for details.
    this.frameDelta = 0;

    // The timestamp in milliseconds of the last time the main loop was run.
    // Used to compute the time elapsed between frames.
    this.lastFrameTimeMs = 0;

    // An exponential moving average of the frames per second.
    this.fps = 60;

    // The timestamp (in milliseconds) of the last time the `fps` moving
    // average was updated.
    this.lastFpsUpdate = 0;

    // The number of frames delivered in the current second.
    this.framesThisSecond = 0;

    // The number of times update() is called in a given frame. This is only
    // relevant inside of animate(), but a reference is held externally so that
    // this variable is not marked for garbage collection every time the main
    // loop runs.
    this.numUpdateSteps = 0;

    // The minimum amount of time in milliseconds that must pass since the last
    // frame was executed before another frame can be executed. The
    // multiplicative inverse caps the FPS (the default of zero means there is
    // no cap).
    this.minFrameDelay = 0;

    // Whether the main loop is running.
    this.running = false;

    // `true` if `MainLoop.start()` has been called and the most recent time it
    // was called has not been followed by a call to `MainLoop.stop()`. This is
    // different than `running` because there is a delay of a few milliseconds
    // after `MainLoop.start()` is called before the application is considered
    // "running." This delay is due to waiting for the next frame.
    this.started = false;

    // Whether the simulation has fallen too far behind real time.
    // Specifically, `panic` will be set to `true` if too many updates occur in
    // one frame. This is only relevant inside of animate(), but a reference is
    // held externally so that this variable is not marked for garbage
    // collection every time the main loop runs.
    this.panic = false;
};

MainLoop.prototype.constructor = MainLoop;

MainLoop.prototype = {

    setMaxFPS: function (fps)
    {
        if (fps === 0)
        {
            this.stop();
        }
        else
        {
            this.minFrameDelay = 1000 / fps;
        }
    },

    getMaxFPS: function ()
    {
        return 1000 / this.minFrameDelay;
    },

    resetFrameDelta: function ()
    {
        var oldFrameDelta = this.frameDelta;

        this.frameDelta = 0;

        return oldFrameDelta;
    },

    start: function ()
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.lastFrameTimeMs = window.performance.now();
        this.lastFpsUpdate = window.performance.now();
        this.framesThisSecond = 0;
    },

    //  timestamp = DOMHighResTimeStamp
    step: function (timestamp)
    {
        // Throttle the frame rate (if minFrameDelay is set to a non-zero value by
        // `MainLoop.setMaxAllowedFPS()`).
        if (timestamp < this.lastFrameTimeMs + this.minFrameDelay)
        {
            return;
        }

        // frameDelta is the cumulative amount of in-app time that hasn't been
        // simulated yet. Add the time since the last frame. We need to track total
        // not-yet-simulated time (as opposed to just the time elapsed since the
        // last frame) because not all actually elapsed time is guaranteed to be
        // simulated each frame. See the comments below for details.
        this.frameDelta += timestamp - this.lastFrameTimeMs;
        this.lastFrameTimeMs = timestamp;

        // Run any updates that are not dependent on time in the simulation.

        //  Here we'll need to run things like tween.update, input.update, etc.
        this.state.sys.begin(timestamp, this.frameDelta);

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        if (timestamp > this.lastFpsUpdate + 1000)
        {
            // Compute the new exponential moving average with an alpha of 0.25.
            // Using constants inline is okay here.
            this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;

            this.lastFpsUpdate = timestamp;
            this.framesThisSecond = 0;
        }

        this.framesThisSecond++;

        this.numUpdateSteps = 0;

        var step = this.timestep;

        while (this.frameDelta >= step)
        {
            // this.update(this.timestep);

            this.state.sys.update(step, this.physicsStep);

            for (var c = 0; c < this.state.sys.children.list.length; c++)
            {
                var child = this.state.sys.children.list[c];

                if (child.exists)
                {
                    child.update(step);
                }
            }

            //  Dev level callback
            this.state.update(step);

            this.frameDelta -= this.timestep;

            if (++this.numUpdateSteps >= 240)
            {
                this.panic = true;
                break;
            }
        }

        this.state.sys.preRender();

        this.state.sys.updates.start();

        if (this.state.settings.visible && this.state.sys.color.alpha !== 0)
        {
            this.game.renderer.render(this.state, this.frameDelta / this.timestep);
        }

        this.state.sys.updates.stop();

        // Run any updates that are not dependent on time in the simulation.
        this.state.sys.end(this.fps, this.panic);

        this.panic = false;
    },

    /*
    update: function (timestep)
    {
        this.state.sys.update(timestep);

        var c;
        var child;

        for (var c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }

        //  Dev level callback
        this.state.update(timestep);

        for (c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }
    },
    */

    stop: function ()
    {
        this.running = false;
        this.started = false;

        return this;
    }

};

module.exports = MainLoop;


/***/ },
/* 323 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.game = state.game;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ },
/* 324 */
/***/ function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.add(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(17);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;
        var di = data.drawImage;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;
        this.width = destWidth;
        this.height = destHeight;

        //  drawImage data
        di.sx = destX;
        di.sy = destY;
        di.sWidth = destWidth;
        di.sHeight = destHeight;
        di.dWidth = destWidth;
        di.dHeight = destHeight;

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = (this.cutX + this.cutWidth) / tw;
        uvs.y1 = this.cutY / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = this.cutX / tw;
        uvs.y3 = (this.cutY + this.cutHeight) / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = (this.cutX + this.cutHeight) / tw;
        uvs.y1 = this.cutY / th;

        uvs.x2 = (this.cutX + this.cutHeight) / tw;
        uvs.y2 = (this.cutY + this.cutWidth) / th;

        uvs.x3 = this.cutX / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;
        clone.width = this.width;
        clone.height = this.height;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(325);
var TextureSource = __webpack_require__(328);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i]));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        this.frameTotal++;

        return frame;
    },

    get: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  Need to iterate though the TextureSources, and unload each one
        //  then clear out the frames

        /*
        if (this.source)
        {
            Phaser.CanvasPool.removeByCanvas(this.source);
        }

        this.source = null;
        */
    }

};

/**
* Helper function that creates a base texture from the given canvas element.
*
* @static
* @method fromCanvas
* @param canvas {Canvas} The canvas element source of the texture
* @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}Phaser.scaleModes{{/crossLink}} for possible values
* @return {BaseTexture}
Phaser.Texture.fromCanvas = function (canvas, scaleMode)
{
    if (canvas.width === 0)
    {
        canvas.width = 1;
    }

    if (canvas.height === 0)
    {
        canvas.height = 1;
    }

    return new Phaser.Texture(canvas, scaleMode);
};
*/

module.exports = Texture;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(336);
var Texture = __webpack_require__(326);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function (game)
{
    this.game = game;

    this.list = {};
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    addSpriteSheet: function (key, source, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, atlasKey, atlasFrame, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source)
    {
        var texture = new Texture(this, key, source);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var ScaleModes = __webpack_require__(12);
var IsSizePowerOfTwo = __webpack_require__(58);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = ScaleModes.DEFAULT;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmap
    * @type {Boolean}
    */
    this.mipmap = false;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;
};

module.exports = TextureSource;


/***/ },
/* 329 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var CanvasTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = CanvasTextureParser;


/***/ },
/* 330 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var ImageTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = ImageTextureParser;


/***/ },
/* 331 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArrayTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
        }
    }

    return texture;
};

module.exports = JSONArrayTextureParser;


/***/ },
/* 332 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHashTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
        }
    }

    return texture;
};

module.exports = JSONHashTextureParser;


/***/ },
/* 333 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var PyxelTextureParser = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = PyxelTextureParser;


/***/ },
/* 334 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetTextureParser = function (texture, sourceIndex, x, y, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
{
    if (startFrame === undefined) { startFrame = 0; }
    if (endFrame === undefined) { endFrame = -1; }
    if (margin === undefined) { margin = 0; }
    if (spacing === undefined) { spacing = 0; }

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetTextureParser;


/***/ },
/* 335 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXMLTextureParser = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXMLTextureParser;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(329),
    Image: __webpack_require__(330),
    SpriteSheet: __webpack_require__(334),
    JSONArray: __webpack_require__(331),
    JSONHash: __webpack_require__(332),
    StarlingXML: __webpack_require__(335),
    Pyxel: __webpack_require__(333)
};


/***/ },
/* 337 */
/***/ function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ },
/* 338 */
/***/ function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(55);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(71);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ },
/* 341 */
/***/ function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ },
/* 342 */
/***/ function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ },
/* 343 */
/***/ function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ },
/* 344 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(78);

var CONST = __webpack_require__(1);
var Extend = __webpack_require__(17);

//  This object is exported globally

var Phaser = {

    Game: __webpack_require__(73),

    Event: __webpack_require__(14),
    EventDispatcher: __webpack_require__(15),

    Math: __webpack_require__(77),

    Geom: __webpack_require__(76),

    GameObjects: {

        Factory: __webpack_require__(9)

    },

    Loader: {

        ImageFile: __webpack_require__(16)

    },

    Sound: __webpack_require__(79),

    Utils: {

        Array: __webpack_require__(80),
        Objects: __webpack_require__(81)

    }

};

//  Required, but don't need Phaser level exports

__webpack_require__(75);
__webpack_require__(74);

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * “Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function.”
 * - John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjN2ZiOGVhMGVjOTgzNmEwMGY1MSIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9PUy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL09TLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9Ccm93c2VyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0ZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9XcmFwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL0dldE9iamVjdFZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9DYW52YXNQb29sLmpzIiwid2VicGFjazovLy9zcmMvZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9GaW5kVC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRG90LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9HZXRBc3BlY3RSYXRpby5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9DYW52YXNGZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0ZlYXR1cmVzLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0ZlYXR1cmVzLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9FbGxpcHNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbEFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbEFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9HZXRNYWduaXR1ZGVTcS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9NdWx0aXBseS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Jlcm5zdGVpbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvQmVybnN0ZWluLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2F0bXVsbFJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9GYWN0b3JpYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvTGluZWFyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvSW5kZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9WZXJ0ZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9zaGFkZXIvQ3JlYXRlU2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQmluZFZlcnRleEFycmF5LmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9DcmVhdGVBdHRyaWJEZXNjLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vVmVydGV4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1NldHRpbmdzLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N5c3RlbXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TeXN0ZW1zLmpzIiwid2VicGFjazovLy8uLi91dGlscy9OT09QLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvU3BsaWNlT25lLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvSXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BvbHlmaWxscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9Db25maWcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9DcmVhdGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvRGVidWdIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0RlYnVnSGVhZGVyLmpzIiwid2VicGFjazovLy8uLi9jYW1lcmEvQ2FtZXJhLmpzIiwid2VicGFjazovLy9zcmMvY2FtZXJhL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi4vY2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9kb20vQWRkVG9ET00uanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9ET01Db250ZW50TG9hZGVkLmpzIiwid2VicGFjazovLy9zcmMvZG9tL0RPTUNvbnRlbnRMb2FkZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9QYXJzZVhNTC5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vc3JjL2V2ZW50cy9FdmVudEJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGVXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRFbnRyeVRhbmdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRZLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQ2VudGVyT24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvSGVpZ2h0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTGVuZ3RoLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTm9ybWFsWC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Ob3JtYWxYLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvTm9ybWFsWS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Ob3JtYWxZLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUGVycFNsb3BlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUmFuZG9tLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUm90YXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9TZXRUb0FuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvU2xvcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9XaWR0aC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0FkZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9DZWlsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Dcm9zcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9EaXZpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Zsb29yLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvSW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvSW52ZXJ0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9OZWdhdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUGVycC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9SUGVycC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0dldEFBQkIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9HZXROdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZWlsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yQWxsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9HZXRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0dldFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUG9pbnRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL092ZXJsYXBzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvU2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL0Jhc2VMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9HZXRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvWEhSTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvWE1MRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvWE1MRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9BdmVyYWdlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0NlaWxUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9DbGFtcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9EZWdUb1JhZC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvRGVnVG9SYWQuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9GbG9hdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmxvb3JUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9NYXhBZGQuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvTWluU3ViLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1BlcmNlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUmFkVG9EZWcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL1JhZFRvRGVnLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3RhdGVBcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm91bmRUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9TaW5Db3NUYWJsZUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9TbW9vdGhTdGVwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1Ntb290aGVyU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9XaXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHNZLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW5ZLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1Nob3J0ZXN0QmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQmFjay5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQm91bmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9DaXJjdWxhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQ3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0V4cG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9RdWFydGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9RdWludGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9TaW5lLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvZWFzaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvTGVzc1RoYW4uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2Z1enp5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL0dldFBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9Jc1ZhbHVlUG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvcG93Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcENlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9TbmFwRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9TbmFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvc25hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0FycmF5LmZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL3BlcmZvcm1hbmNlLm5vdy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL0JsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2guanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvRnJhZ21lbnRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9WZXJ0ZXhTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvRnJhZ21lbnRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1ZlcnRleFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlRW1wdHlUZXh0dXJlLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlRW1wdHlUZXh0dXJlLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREltYWdlLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uLi9zb3VuZC9keW5hbWljL0ZYLmpzIiwid2VicGFjazovLy9zcmMvc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvZHluYW1pYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N0YXRlLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL1N0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL3N5c3RlbXMvTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL01haW5Mb29wLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL1VwZGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0cnVjdHMvU2V0LmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9GcmFtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL0ZyYW1lLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9JbWFnZVRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkFycmF5VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OSGFzaFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvUHl4ZWxUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9TdGFybGluZ1hNTFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9HZXRSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9Sb3RhdGVSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvU2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vZDovd2FtcC93d3cvcGhhc2VyL3YzL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy9zcmMvcGhhc2VyLmpzIiwid2VicGFjazovLy8uLi9waGFzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPOztBQUVqQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDM0JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDdkJBLCtDQ0FBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxHQUFHLHVCQUF1QixPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNyUUEsU0NBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTyxzR0FBc0c7QUFDOUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFNUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ0pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPO0FBQ2pDLDhCQUE4QixXQUFXO0FBQ3pDLCtCQUErQixZQUFZOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCOztBQUVuRDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDcktBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYzs7QUFFbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUU3SUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDM0JBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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OUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELHFDQUFxQyw2QkFBNkI7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxJ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Q0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUMxdEJBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUvRUEsU0NBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUU3V0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPO0FBQ2pDLCtCQUErQixZQUFZOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeEpBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQyw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDN0tBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkMsMkJBQTJCLFFBQVE7QUFDbkMsMkJBQTJCLFFBQVE7QUFDbkMsMkJBQTJCLFFBQVE7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFRO0FBQ3ZDLCtCQUErQixRQUFROztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3hJQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixNQUFNLDZFQUE2RSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDdEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakUsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkEsa0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBRXpCQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUV2Q0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVqREE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FB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QUUzQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyx3RUFBd0U7QUFDdEYsY0FBYyxjQUFjO0FBQzVCLGNBQWMsYUFBYTtBQUMzQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVoREE7O0FBRUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUViQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFOUNBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7O0FBRUEseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixhQUFhOztBQUU1QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFN0RBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFekVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFM0ZBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7O0FBRUQ7Ozs7Ozs7QUV0VkE7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNVlBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVyUUEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUViQTtBQUNB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QTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFF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QUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXJDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFYkE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTs7Ozs7OztBRVRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxVQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuQkEsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTdCQSxjQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7O0FBRTVDLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkEscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTNCQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWxCQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7OztBRWhDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnRkFBZ0YscUJBQXFCOztBQUVyRztBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MseURBQXlEOztBQUUzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXBTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBLHVCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFckNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkE7O0FBRUEsd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTEEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7O0FFbEJBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixXQUFXOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUV0Q0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBRXRDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFdENBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztB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QTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdERBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVSQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVmQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVqQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFckJBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUEseURBQXlELHFCQUFxQjs7QUFFOUU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBRTNKQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbkNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEseURBQXlELHFCQUFxQjs7QUFFOUU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7Ozs7O0FFL1FBOztBQUVBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTlRQTtBQUNBLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQiwyREFBMkQ7QUFDM0QsTUFBTTtBQUNOOzs7Ozs7O0FDUEE7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLGlFQUFpRTtBQUNqRSxrQ0FBa0M7QUFDbEMsTUFBTTtBQUNOOzs7Ozs7O0FDVEEscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0QkE7QUFDQSwwQkFBMEI7QUFDMUIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsMkRBQTJEO0FBQzNELE1BQU07QUFDTjs7Ozs7OztBQ1BBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxtQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVuU0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsK0NBQStDO0FBQy9DLG9IQUFvSDtBQUNwSCxrQ0FBa0M7QUFDbEMsaUVBQWlFO0FBQ2pFLGtDQUFrQztBQUNsQyxNQUFNO0FBQ047Ozs7Ozs7QUNqQkEscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0QkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDVEEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTFVQTs7QUFFQTs7QUFFQSxRQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRU5BO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxlQ0FBLG1CREFBLENDQUEsRURBQTtB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RUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIseUJBQXlCOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUEsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUEsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FFM2hCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFdkNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOzs7Ozs7O0FFMU5BO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLHlDQUF5QztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFeFBBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFekhBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs4Q0NuTHRDLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxZREFBLG1CQ0FBLENEQUEsQ0NBQTtBQUNBLGFEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFdEQUEsbUJDQUEsQ0RBQSxFQ0FBO0FBQ0EscUJEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBLGlCREFBLG1CQ0FBLENEQUEsQ0NBQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLG1CREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxLQUFLOztBQUVMLFdEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBLGVEQUEsbUJDQUEsQ0RBQSxFQ0FBO0FBQ0EsaUJEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBOztBQUVBOztBREVBLG1CQ0FBLENEQUEsRUNBQTtBRENBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InBoYXNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiUGhhc2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlBoYXNlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQaGFzZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vcnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9yeSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0fSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM0NSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzdmYjhlYTBlYzk4MzZhMDBmNTEiLCJ2YXIgUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSlcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIFZFUlNJT046ICczLjAuMCcsXHJcblxyXG4gICAgQVVUTzogMCxcclxuICAgIENBTlZBUzogMSxcclxuICAgIFdFQkdMOiAyLFxyXG5cclxuICAgIElNQUdFOiAyMFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0ge1xyXG5cclxuICAgIFBJMjogTWF0aC5QSSAqIDIsXHJcbiAgICBUQVU6IE1hdGguUEkgKiAwLjUsXHJcbiAgICBFUFNJTE9OOiAxLjBlLTYsXHJcbiAgICBERUdfVE9fUkFEOiBNYXRoLlBJIC8gMTgwLFxyXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTUFUSF9DT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRklMRV9DT05TVCA9IHtcclxuXHJcbiAgICBMT0FERVJfSURMRTogMCxcclxuICAgIExPQURFUl9MT0FESU5HOiAxLFxyXG4gICAgTE9BREVSX1BST0NFU1NJTkc6IDIsXHJcbiAgICBMT0FERVJfQ09NUExFVEU6IDMsXHJcbiAgICBMT0FERVJfREVTVFJPWUVEOiA0LFxyXG5cclxuICAgIEZJTEVfUEVORElORzogNSwgICAgICAvLyBmaWxlIGlzIGluIHRoZSBsb2FkIHF1ZXVlIGJ1dCBub3QgeWV0IHN0YXJ0ZWRcclxuICAgIEZJTEVfTE9BRElORzogNiwgICAgICAvLyBmaWxlIGhhcyBiZWVuIHN0YXJ0ZWQgdG8gbG9hZCBieSB0aGUgbG9hZGVyIChvbkxvYWQgY2FsbGVkKVxyXG4gICAgRklMRV9MT0FERUQ6IDcsICAgICAgIC8vIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGF3YWl0aW5nIHByb2Nlc3NpbmdcclxuICAgIEZJTEVfRkFJTEVEOiA4LCAgICAgICAvLyBmaWxlIGZhaWxlZCB0byBsb2FkXHJcbiAgICBGSUxFX1BST0NFU1NJTkc6IDksICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfV0FJVElOR19MSU5LRklMRTogMTAsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfRVJST1JFRDogMTEsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfQ09NUExFVEU6IDEyLCAgICAgLy8gZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZ1xyXG4gICAgRklMRV9ERVNUUk9ZRUQ6IDEzLCAgICAgLy8gZmlsZSBoYXMgYmVlbiBkZXN0cm95ZWRcclxuXHJcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fQVJSQVk6IDIwLFxyXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0hBU0g6IDIxXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGSUxFX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL09TLmpzIiwidmFyIE9TID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRlc2t0b3AgLSBJcyBydW5uaW5nIG9uIGEgZGVza3RvcD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBkZXNrdG9wOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJBcHAgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGFzIGEgV2ViQXBwLCBpLmUuIHdpdGhpbiBhIFdlYlZpZXdcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJBcHA6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlPUyAtIElzIHJ1bm5pbmcgb24gaU9TP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlPUzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpT1NWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBpT1MgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlPU1ZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaVBob25lIC0gSXMgcnVubmluZyBvbiBpUGhvbmU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgaVBob25lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpUGFkIC0gSXMgcnVubmluZyBvbiBpUGFkP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlQYWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvY29vbkpTIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBDb2Nvb25KUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjb2Nvb25KUzogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvY29vbkpTQXBwIC0gSXMgdGhpcyBnYW1lIHJ1bm5pbmcgd2l0aCBDb2Nvb25KUy5BcHA/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY29jb29uSlNBcHA6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb3Jkb3ZhIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBBcGFjaGUgQ29yZG92YT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjb3Jkb3ZhOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9kZSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgTm9kZS5qcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBub2RlOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9kZVdlYmtpdCAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgTm9kZS1XZWJraXQ/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbm9kZVdlYmtpdDogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVsZWN0cm9uIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBHaXRIdWIgRWxlY3Ryb24/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWxlY3Ryb246IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlamVjdGEgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEVqZWN0YT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBlamVjdGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNyb3Nzd2FsayAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgdGhlIEludGVsIENyb3Nzd2FsayBYREs/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY3Jvc3N3YWxrOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbmRyb2lkIC0gSXMgcnVubmluZyBvbiBhbmRyb2lkP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGFuZHJvaWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZU9TIC0gSXMgcnVubmluZyBvbiBjaHJvbWVPUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjaHJvbWVPUzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGludXggLSBJcyBydW5uaW5nIG9uIGxpbnV4P1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGxpbnV4OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtYWNPUyAtIElzIHJ1bm5pbmcgb24gbWFjT1M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbWFjT1M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdpbmRvd3MgLSBJcyBydW5uaW5nIG9uIHdpbmRvd3M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2luZG93czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2luZG93c1Bob25lIC0gSXMgcnVubmluZyBvbiBhIFdpbmRvd3MgUGhvbmU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2luZG93c1Bob25lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB2aXRhIC0gSXMgcnVubmluZyBvbiBhIFBsYXlTdGF0aW9uIFZpdGE/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdml0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2luZGxlIC0gSXMgcnVubmluZyBvbiBhbiBBbWF6b24gS2luZGxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGtpbmRsZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIC0gUGl4ZWxSYXRpbyBvZiB0aGUgaG9zdCBkZXZpY2U/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgcGl4ZWxSYXRpbzogMVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoL1dpbmRvd3MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLndpbmRvd3MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL01hYyBPUy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MubWFjT1MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5saW51eCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuYW5kcm9pZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvaVBbYW9dZHxpUGhvbmUvaS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5pT1MgPSB0cnVlO1xyXG4gICAgICAgIChuYXZpZ2F0b3IuYXBwVmVyc2lvbikubWF0Y2goL09TIChcXGQrKS8pO1xyXG4gICAgICAgIE9TLmlPU1ZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9LaW5kbGUvLnRlc3QodWEpIHx8ICgvXFxiS0ZbQS1aXVtBLVpdKy8pLnRlc3QodWEpIHx8ICgvU2lsay4qTW9iaWxlIFNhZmFyaS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmtpbmRsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBOT1QgZGV0ZWN0IGVhcmx5IGdlbmVyYXRpb25zIG9mIEtpbmRsZSBGaXJlLCBJIHRoaW5rIHRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheS4uLlxyXG4gICAgICAgIC8vIEUuZy4gXCJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBVOyBJbnRlbCBNYWMgT1MgWCAxMF82XzM7IGVuLXVzOyBTaWxrLzEuMS4wLTgwKSBBcHBsZVdlYktpdC81MzMuMTYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzUuMCBTYWZhcmkvNTMzLjE2IFNpbGstQWNjZWxlcmF0ZWQ9dHJ1ZVwiXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvQ3JPUy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY2hyb21lT1MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9QbGF5c3RhdGlvbiBWaXRhLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mudml0YSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1YSkgfHwgKC9JRU1vYmlsZS9pKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5hbmRyb2lkID0gZmFsc2U7XHJcbiAgICAgICAgT1MuaU9TID0gZmFsc2U7XHJcbiAgICAgICAgT1MubWFjT1MgPSBmYWxzZTtcclxuICAgICAgICBPUy53aW5kb3dzID0gdHJ1ZTtcclxuICAgICAgICBPUy53aW5kb3dzUGhvbmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaWxrID0gKC9TaWxrLykudGVzdCh1YSk7XHJcblxyXG4gICAgaWYgKE9TLndpbmRvd3MgfHwgT1MubWFjT1MgfHwgKE9TLmxpbnV4ICYmICFzaWxrKSB8fCBPUy5jaHJvbWVPUylcclxuICAgIHtcclxuICAgICAgICBPUy5kZXNrdG9wID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgV2luZG93cyBQaG9uZSAvIFRhYmxlIHJlc2V0XHJcbiAgICBpZiAoT1Mud2luZG93c1Bob25lIHx8ICgoL1dpbmRvd3MgTlQvaS50ZXN0KHVhKSkgJiYgKC9Ub3VjaC9pLnRlc3QodWEpKSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuZGVza3RvcCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBXZWJBcHAgbW9kZSBpbiBpT1NcclxuICAgIGlmIChuYXZpZ2F0b3Iuc3RhbmRhbG9uZSlcclxuICAgIHtcclxuICAgICAgICBPUy53ZWJBcHAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBPUy5jb3Jkb3ZhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJykpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mubm9kZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChPUy5ub2RlICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBPUy5ub2RlV2Via2l0ID0gISFwcm9jZXNzLnZlcnNpb25zWydub2RlLXdlYmtpdCddO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE9TLmVsZWN0cm9uID0gISFwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY29jb29uSlMgPSB0cnVlO1xyXG5cclxuICAgICAgICB0cnlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE9TLmNvY29vbkpTQXBwID0gKHR5cGVvZiBDb2Nvb25KUyAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBPUy5jb2Nvb25KU0FwcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAod2luZG93LmVqZWN0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmVqZWN0YSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCgvQ3Jvc3N3YWxrLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY3Jvc3N3YWxrID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBPUy5pUGhvbmUgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwaG9uZScpICE9PSAtMTtcclxuICAgIE9TLmlQYWQgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwYWQnKSAhPT0gLTE7XHJcblxyXG4gICAgT1MucGl4ZWxSYXRpbyA9IHdpbmRvd1snZGV2aWNlUGl4ZWxSYXRpbyddIHx8IDE7XHJcblxyXG4gICAgcmV0dXJuIE9TO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL09TLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxuXHJcbnZhciBCcm93c2VyID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFyb3JhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBBcm9yYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBhcm9yYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2hyb21lIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBDaHJvbWUuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNocm9tZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIENocm9tZSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlcGlwaGFueSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gRXBpcGhhbnkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZXBpcGhhbnk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpcmVmb3ggLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEZpcmVmb3guXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJlZm94VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gRmlyZWZveCB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveFZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW9iaWxlU2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNb2JpbGUgU2FmYXJpLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1vYmlsZVNhZmFyaTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWUgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGllVmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBCZXlvbmQgSUUxMCB5b3Ugc2hvdWxkIHVzZSBEZXZpY2UudHJpZGVudCBhbmQgRGV2aWNlLnRyaWRlbnRWZXJzaW9uLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtaWRvcmkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pZG9yaS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtaWRvcmk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wZXJhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBPcGVyYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBvcGVyYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBTYWZhcmkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNhZmFyaVZlcnNpb24gLSBJZiBydW5uaW5nIGluIFNhZmFyaSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB0cmlkZW50IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBhIFRyaWRlbnQgdmVyc2lvbiBvZiBJbnRlcm5ldCBFeHBsb3JlciAoSUUxMSspXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdHJpZGVudDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmlkZW50VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBTZWUge0BsaW5rIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNzUwMyh2PXZzLjg1KS5hc3B4fVxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRyaWRlbnRWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVkZ2UgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWRnZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2lsayAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gdGhlIFNpbGsgYnJvd3NlciAoYXMgdXNlZCBvbiB0aGUgQW1hem9uIEtpbmRsZSlcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBzaWxrOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoKC9Bcm9yYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuYXJvcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0VkZ2VcXC9cXGQrLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVkZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9DaHJvbWVcXC8oXFxkKykvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuY2hyb21lID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLmNocm9tZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRXBpcGhhbnkvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVwaXBoYW55ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRmlyZWZveFxcRCsoXFxkKykvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmZpcmVmb3ggPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvQXBwbGVXZWJLaXQvKS50ZXN0KHVhKSAmJiBPUy5pT1MpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5tb2JpbGVTYWZhcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9NU0lFIChcXGQrXFwuXFxkKyk7LykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5pZSA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci5pZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvTWlkb3JpLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5taWRvcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9PcGVyYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIub3BlcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9TYWZhcmkvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvVHJpZGVudFxcLyhcXGQrXFwuXFxkKykoLiopcnY6KFxcZCtcXC5cXGQrKS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIudHJpZGVudCA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci50cmlkZW50VmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xyXG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQzLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNpbGsgZ2V0cyBpdHMgb3duIGlmIGNsYXVzZSBiZWNhdXNlIGl0cyB1YSBhbHNvIGNvbnRhaW5zICdTYWZhcmknXHJcbiAgICBpZiAoKC9TaWxrLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5zaWxrID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQnJvd3NlcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9Ccm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9Ccm93c2VyLmpzIiwidmFyIEFuZ2xlID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKGxpbmUueTIgLSBsaW5lLnkxLCBsaW5lLngyIC0gbGluZS54MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBFbmNhcHN1bGF0ZXMgYSAyRCByZWN0YW5nbGUgZGVmaW5lZCBieSBpdHMgY29ybmVyIHBvaW50IGluIHRoZSB0b3AtbGVmdFxyXG4vLyAgYW5kIGl0cyBleHRlbmRzIGluIHggKHdpZHRoKSBhbmQgeSAoaGVpZ2h0KVxyXG5cclxudmFyIFJlY3RhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSAwOyB9XHJcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDA7IH1cclxuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAwOyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxufTtcclxuXHJcblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XHJcblxyXG5SZWN0YW5nbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB3aWR0aDsgfVxyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlY3RhbmdsZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5yaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5ib3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5ib3R0b20gLSB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFVSTCA9IHJlcXVpcmUoJy4vR2V0VVJMJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFhIUkxvYWRlciA9IHJlcXVpcmUoJy4vWEhSTG9hZGVyJyk7XHJcbnZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL01lcmdlWEhSU2V0dGluZ3MnKTtcclxuXHJcbnZhciBGaWxlID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgdXJsLCByZXNwb25zZVR5cGUsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICAvLyAgZmlsZSB0eXBlIChpbWFnZSwganNvbiwgZXRjKSBmb3Igc29ydGluZyB3aXRoaW4gdGhlIExvYWRlclxyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAvLyAgdW5pcXVlIGNhY2hlIGtleSAodW5pcXVlIHdpdGhpbiBpdHMgZmlsZSB0eXBlKVxyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgLy8gIFRoZSBVUkwgb2YgdGhlIGZpbGUsIG5vdCBpbmNsdWRpbmcgYmFzZVVSTFxyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcblxyXG4gICAgLy8gIFNldCB3aGVuIHRoZSBMb2FkZXIgY2FsbHMgJ2xvYWQnIG9uIHRoaXMgZmlsZVxyXG4gICAgdGhpcy5zcmMgPSAnJztcclxuXHJcbiAgICB0aGlzLnhoclNldHRpbmdzID0gWEhSU2V0dGluZ3MocmVzcG9uc2VUeXBlKTtcclxuXHJcbiAgICBpZiAoeGhyU2V0dGluZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54aHJTZXR0aW5ncyA9IE1lcmdlWEhSU2V0dGluZ3ModGhpcy54aHJTZXR0aW5ncywgeGhyU2V0dGluZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMueGhyTG9hZGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QRU5ESU5HO1xyXG5cclxuICAgIC8vICBTZXQgYnkgb25Qcm9ncmVzcyAob25seSBpZiBsb2FkaW5nIHZpYSBYSFIpXHJcbiAgICB0aGlzLmJ5dGVzVG90YWwgPSAwO1xyXG4gICAgdGhpcy5ieXRlc0xvYWRlZCA9IC0xO1xyXG4gICAgdGhpcy5wZXJjZW50Q29tcGxldGUgPSAtMTtcclxuXHJcbiAgICAvLyAgRm9yIENPUnMgYmFzZWQgbG9hZGluZy5cclxuICAgIC8vICBJZiB0aGlzIGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBGaWxlIHdpbGwgY2hlY2sgQmFzZUxvYWRlci5jcm9zc09yaWdpbiBhbmQgdXNlIHRoYXQgKGlmIHNldClcclxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gIFRoZSBhY3R1YWwgcHJvY2Vzc2VkIGZpbGUgZGF0YVxyXG4gICAgdGhpcy5kYXRhID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vICBNdWx0aXBhcnQgZmlsZT8gKGkuZS4gYW4gYXRsYXMgYW5kIGl0cyBqc29uIHRvZ2V0aGVyKVxyXG4gICAgdGhpcy5saW5rRmlsZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGlua1R5cGUgPSAnJztcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcclxufTtcclxuXHJcbkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsZTtcclxuXHJcbkZpbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHJlc2V0WEhSOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ubG9hZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbmVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ucHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgd2hlbiB0aGUgSW1hZ2UgbG9hZHNcclxuICAgIC8vICBQcm9ncmVzc0V2ZW50XHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzTG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzVG90YWwgPSBldmVudC50b3RhbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGVyY2VudENvbXBsZXRlID0gTWF0aC5taW4oKHRoaXMuYnl0ZXNMb2FkZWQgLyB0aGlzLmJ5dGVzVG90YWwpLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGVyY2VudENvbXBsZXRlICsgJyUgKCcgKyB0aGlzLmJ5dGVzTG9hZGVkICsgJyBieXRlcyknKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9jZXNzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmtGaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfV0FJVElOR19MSU5LRklMRSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgYW5kIGlzIHdhaXRpbmcgZm9yIHRoaXMgZmlsZSwgc28gbGV0J3MgZG8gdGhlbSBib3RoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlua0ZpbGUuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBzdGlsbCBoYXNuJ3QgZmluaXNoZWQgbG9hZGluZyBhbmQvb3IgcHJvY2Vzc2luZyB5ZXRcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfQ09NUExFVEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBMb2FkZXIsIHN0YXJ0cyB0aGUgYWN0dWFsIGZpbGUgZG93bmxvYWRpbmdcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzZVVSTCwgZ2xvYmFsWEhSKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiYXNlVVJMID09PSB1bmRlZmluZWQpIHsgYmFzZVVSTCA9ICcnOyB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5zcmMgPSBHZXRVUkwodGhpcywgYmFzZVVSTCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNyYy5pbmRleE9mKCdkYXRhOicpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvY2FsIGRhdGEgVVJJJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueGhyTG9hZGVyID0gWEhSTG9hZGVyKHRoaXMsIGdsb2JhbFhIUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvRmlsZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBHYW1lT2JqZWN0IEZhY3RvcnkgaXMgYSBnbG9iYWwgbGV2ZWwgY29udGFpbmVyIG9mIEZhY3RvcnkgaW5zdGFuY2VzLlxyXG4qIEZhY3RvcmllcyByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggdGhpcyBjb250YWluZXIgKHdoZW4gcmVxdWlyZWQpXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxuXHJcbnZhciBmYWN0b3JpZXMgPSB7fTtcclxuXHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLy8gY29uc29sZS5sb2coJ0ZhY3RvcnlDb250YWluZXIgaXMgYWxpdmUnKTtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZhY3RvcnkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZhY3Rvcmllcy5oYXNPd25Qcm9wZXJ0eShmYWN0b3J5LktFWSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQWxyZWFkeSByZWdpc3RlcmVkJywgZmFjdG9yeS5LRVkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShmYWN0b3J5LktFWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcnLCBmYWN0b3J5LktFWSk7XHJcblxyXG4gICAgICAgIGZhY3Rvcmllc1tmYWN0b3J5LktFWV0gPSB7XHJcbiAgICAgICAgICAgIGFkZDogZmFjdG9yeS5hZGQsXHJcbiAgICAgICAgICAgIG1ha2U6IGZhY3RvcnkubWFrZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFR5cGUgPSBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3JpZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24gKGRlc3QsIGlzRmFjdG9yeSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBmYWN0b3J5IGluIGZhY3RvcmllcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3JpZXMuaGFzT3duUHJvcGVydHkoZmFjdG9yeSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2FkaW5nJywgZmFjdG9yeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVzdFtmYWN0b3J5XSA9IChpc0ZhY3RvcnkpID8gZmFjdG9yaWVzW2ZhY3RvcnldLmFkZCA6IGZhY3Rvcmllc1tmYWN0b3J5XS5tYWtlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpXHJcbntcclxuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbjtcclxuXHJcbiAgICBpZiAocmFuZ2UgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlIC0gbWluKSAlIHJhbmdlO1xyXG5cclxuICAgIGlmIChyZXN1bHQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHJlc3VsdCArPSByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0ICsgbWluO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXRoV3JhcCA9IHJlcXVpcmUoJy4uL1dyYXAnKTtcclxuXHJcbnZhciBXcmFwID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aFdyYXAoYW5nbGUsIC1NYXRoLlBJLCBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV3JhcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9XcmFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1dyYXAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBERUZBVUxUOiAwLFxyXG4gICAgTElORUFSOiAwLFxyXG4gICAgTkVBUkVTVDogMVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvU2NhbGVNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNvdXJjZSBvYmplY3RcclxuLy8gIFRoZSBrZXkgYXMgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIGtleXMsIGkuZS4gJ2Jhbm5lcicsIG9yICdiYW5uZXIuaGlkZUJhbm5lcidcclxuLy8gIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RcclxuXHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKVxyXG57XHJcbiAgICBpZiAoa2V5LmluZGV4T2YoJy4nKSlcclxuICAgIHtcclxuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBzb3VyY2U7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgVXNlIGZvciBsb29wIGhlcmUgc28gd2UgY2FuIGJyZWFrIGVhcmx5XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFllcyBpdCBoYXMgYSBrZXkgcHJvcGVydHksIGxldCdzIGNhcnJ5IG9uIGRvd25cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyZW50W2tleXNbaV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrZXlzW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkgPyBzb3VyY2Vba2V5XSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0T2JqZWN0VmFsdWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL0dldE9iamVjdFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSBmdW5jdGlvbiAodHlwZSlcclxue1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICB0aGlzLnRhcmdldDtcclxuXHJcbiAgICB0aGlzLl9wcm9wYWdhdGUgPSB0cnVlO1xyXG59O1xyXG5cclxuRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXZlbnQ7XHJcblxyXG5FdmVudC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICh0YXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudEJpbmRpbmcgPSByZXF1aXJlKCcuL0V2ZW50QmluZGluZycpO1xyXG5cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcclxuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xyXG4gICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XHJcbn07XHJcblxyXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXZlbnREaXNwYXRjaGVyO1xyXG5cclxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBnZXRCaW5kaW5nOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5iaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW3R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlQmluZGluZzogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldEJpbmRpbmcodHlwZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVdID0gbmV3IEV2ZW50QmluZGluZyh0aGlzLCB0eXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW3R5cGVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCBwcmlvcml0eSlcclxuICAgIHtcclxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkgeyBwcmlvcml0eSA9IDA7IH1cclxuXHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmNyZWF0ZUJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5hZGQobGlzdGVuZXIsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgb25jZTogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCBwcmlvcml0eSlcclxuICAgIHtcclxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkgeyBwcmlvcml0eSA9IDA7IH1cclxuXHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmNyZWF0ZUJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5hZGQobGlzdGVuZXIsIHByaW9yaXR5LCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQWRkIGEgY2FsbGJhY2sgdGhhdCBpcyBub3RpZmllZCBldmVyeSB0aW1lIHRoaXMgRXZlbnREaXNwYXRjaGVyIGRpc3BhdGNoZXMgYW4gZXZlbnRcclxuICAgIC8vICBubyBtYXR0ZXIgd2hhdCB0aGUgZXZlbnQgdHlwZSBpcy4gRmlsdGVycyBhcmUgaW52b2tlZCBmaXJzdCwgYmVmb3JlIGFueSBiaW5kaW5ncyxcclxuICAgIC8vICBhbmQgY2FuIHN0b3AgZXZlbnRzIGlmIHRoZXkgd2lzaCAoaW4gd2hpY2ggY2FzZSB0aGV5J2xsIG5ldmVyIHJlYWNoIHRoZSBiaW5kaW5ncylcclxuICAgIGZpbHRlcjogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5maWx0ZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICBpZiAoaSA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWRkIHRoZSBmaWx0ZXJcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIHRoZSBmaWx0ZXJcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gKHRoaXMuZmlsdGVycy5sZW5ndGggPiAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nLmhhcyhsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdGFsOiBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy50b3RhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAvLyAgSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIHRoZSBFdmVudERpc3BhdGNoZXIsIGEgY2FsbCB0byB0aGlzIG1ldGhvZCBoYXMgbm8gZWZmZWN0LlxyXG4gICAgb2ZmOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5yZW1vdmUobGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIF9kaXNwYXRjaEhhbmRsZXI6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICBldmVudC5yZXNldCh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gIFBhc3MgdGhlIGV2ZW50IHRocm91Z2ggdGhlIGZpbHRlcnMgZmlyc3RcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzRmlsdGVycylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnNbaV0uY2FsbCh0aGlzLCBldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIERpZCB0aGUgZmlsdGVyIGtpbGwgdGhlIGV2ZW50PyBJZiBzbywgd2UgY2FuIGFib3J0IG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFldmVudC5fcHJvcGFnYXRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcoZXZlbnQudHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5kaXNwYXRjaChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSGFuZGxlcihldmVudFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hIYW5kbGVyKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMsIGJ1dCByZXRhaW5zIHRoZSBldmVudCB0eXBlIGVudHJpZXNcclxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5yZW1vdmVBbGwoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVBbGxGaWx0ZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmlsdGVycy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1t0eXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGVBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgYmluZGluZyBpbiB0aGlzLmJpbmRpbmdzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVBbGwoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbEZpbHRlcnMoKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBJbWFnZUZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuaW1hZ2VcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcucG5nJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnaW1hZ2UnLCBrZXksIHVybCwgJ2Jsb2InLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5JbWFnZUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcbkltYWdlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZUZpbGU7XHJcblxyXG5JbWFnZUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIF90aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEub25lcnJvciA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGF0YS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUuanMiLCJ2YXIgSXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpO1xyXG5cclxuLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5leHRlbmQvXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMuZXh0ZW5kXHJcbiogQHBhcmFtIHtib29sZWFufSBkZWVwIC0gUGVyZm9ybSBhIGRlZXAgY29weT9cclxuKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cclxuKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXHJcbiovXHJcbnZhciBFeHRlbmQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXHJcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIilcclxuICAgIHtcclxuICAgICAgICBkZWVwID0gdGFyZ2V0O1xyXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgaSA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0ZW5kIFBoYXNlciBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgIGlmIChsZW5ndGggPT09IGkpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAtLWk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKElzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBJc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IEV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0V4dGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENoaWxkcmVuOiByZXF1aXJlKCcuL0NoaWxkcmVuJyksXHJcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxyXG4gICAgRGF0YTogcmVxdWlyZSgnLi9EYXRhJyksXHJcbiAgICBUcmFuc2Zvcm06IHJlcXVpcmUoJy4vVHJhbnNmb3JtJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwb29sIGludG8gd2hpY2ggdGhlIGNhbnZhcyBlbGVtZW50cyBhcmUgcGxhY2VkLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkgcG9vbFxyXG4gKiBAdHlwZSBBcnJheVxyXG4gKi9cclxudmFyIHBvb2wgPSBbXTtcclxuXHJcbi8vICBUaGlzIHNpbmdsZXRvbiBpcyBpbnN0YW50aWF0ZWQgYXMgc29vbiBhcyBQaGFzZXIgbG9hZHMsXHJcbi8vICBiZWZvcmUgYSBQaGFzZXIuR2FtZSBpbnN0YW5jZSBoYXMgZXZlbiBiZWVuIGNyZWF0ZWQuXHJcbi8vICBXaGljaCBtZWFucyBhbGwgaW5zdGFuY2VzIG9mIFBoYXNlciBHYW1lcyBvbiB0aGUgc2FtZSBwYWdlXHJcbi8vICBjYW4gc2hhcmUgdGhlIG9uZSBzaW5nbGUgcG9vbFxyXG5cclxuLyoqXHJcbiogVGhlIENhbnZhc1Bvb2wgaXMgYSBnbG9iYWwgc3RhdGljIG9iamVjdCwgdGhhdCBhbGxvd3MgUGhhc2VyIHRvIHJlY3ljbGUgYW5kIHBvb2wgQ2FudmFzIERPTSBlbGVtZW50cy5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuQ2FudmFzUG9vbFxyXG4qIEBzdGF0aWNcclxuKi9cclxudmFyIENhbnZhc1Bvb2wgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlcyBhIG5ldyBDYW52YXMgRE9NIGVsZW1lbnQsIG9yIHB1bGxzIG9uZSBmcm9tIHRoZSBwb29sIGlmIGZyZWUuXHJcbiAgICAqIFxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmNyZWF0ZVxyXG4gICAgKiBAc3RhdGljXHJcbiAgICAqIEBwYXJhbSB7YW55fSBwYXJlbnQgLSBUaGUgcGFyZW50IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgKi9cclxuICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCB0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMTsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAxOyB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XHJcblxyXG4gICAgICAgIHZhciBjYW52YXM7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZpcnN0KHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhc1Bvb2wuY3JlYXRlIG5ldycpO1xyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyID0ge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICBjYW52YXM6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcG9vbC5wdXNoKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICBjYW52YXMgPSBjb250YWluZXIuY2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5jcmVhdGUgZXhpc3RpbmcnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICBjYW52YXMgPSBjb250YWluZXIuY2FudmFzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlMkQgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5DQU5WQVMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlV2ViR0wgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5XRUJHTCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBmcmVlIGNhbnZhcyBpbmRleCBmcm9tIHRoZSBwb29sLlxyXG4gICAgKiBcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldEZpcnN0XHJcbiAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICovXHJcbiAgICB2YXIgZmlyc3QgPSBmdW5jdGlvbiAodHlwZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7IHR5cGUgPSBDT05TVC5DQU5WQVM7IH1cclxuXHJcbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5wYXJlbnQgJiYgY29udGFpbmVyLnR5cGUgPT09IHR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBMb29rcyB1cCBhIGNhbnZhcyBiYXNlZCBvbiBpdHMgcGFyZW50LCBhbmQgaWYgZm91bmQgcHV0cyBpdCBiYWNrIGluIHRoZSBwb29sLCBmcmVlaW5nIGl0IHVwIGZvciByZS11c2UuXHJcbiAgICAqIFRoZSBjYW52YXMgaGFzIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IHNldCB0byAxLCBhbmQgaXRzIHBhcmVudCBhdHRyaWJ1dGUgbnVsbGVkLlxyXG4gICAgKiBcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLnJlbW92ZVxyXG4gICAgKiBAcGFyYW0ge2FueXxIVE1MQ2FudmFzRWxlbWVudH0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqL1xyXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgcGFyZW50IGlzIGEgY2FudmFzIG9iamVjdFxyXG4gICAgICAgIHZhciBpc0NhbnZhcyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cclxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgoaXNDYW52YXMgJiYgY29udGFpbmVyLmNhbnZhcyA9PT0gcGFyZW50KSB8fCAoIWlzQ2FudmFzICYmIGNvbnRhaW5lci5wYXJlbnQgPT09IHBhcmVudCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLnJlbW92ZSBmb3VuZCBhbmQgcmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLndpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuaGVpZ2h0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHVzZWQgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgKiBcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldFRvdGFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBpbi11c2UgKHBhcmVudGVkKSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXHJcbiAgICAqL1xyXG4gICAgdmFyIHRvdGFsID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYyA9IDA7XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmVlIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICogXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRGcmVlXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmcmVlICh1bi1wYXJlbnRlZCkgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxyXG4gICAgKi9cclxuICAgIHZhciBmcmVlID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcG9vbC5sZW5ndGggLSB0b3RhbCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxyXG4gICAgICAgIGNyZWF0ZTJEOiBjcmVhdGUyRCxcclxuICAgICAgICBjcmVhdGVXZWJHTDogY3JlYXRlV2ViR0wsXHJcbiAgICAgICAgZmlyc3Q6IGZpcnN0LFxyXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxyXG4gICAgICAgIHRvdGFsOiB0b3RhbCxcclxuICAgICAgICBmcmVlOiBmcmVlLFxyXG4gICAgICAgIHBvb2w6IHBvb2xcclxuICAgIH07XHJcbn07XHJcblxyXG4vLyAgSWYgd2UgZXhwb3J0IHRoZSBjYWxsZWQgZnVuY3Rpb24gaGVyZSwgaXQnbGwgb25seSBiZSBpbnZva2VkIG9uY2UgKG5vdCBldmVyeSB0aW1lIGl0J3MgcmVxdWlyZWQpLlxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1Bvb2woKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0NhbnZhc1Bvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvbS9DYW52YXNQb29sLmpzIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKGNpcmNsZSwgeCwgeSlcclxue1xyXG4gICAgLy8gIENoZWNrIGlmIHgveSBhcmUgd2l0aGluIHRoZSBib3VuZHMgZmlyc3RcclxuICAgIGlmIChjaXJjbGUucmFkaXVzID4gMCAmJiB4ID49IGNpcmNsZS5sZWZ0ICYmIHggPD0gY2lyY2xlLnJpZ2h0ICYmIHkgPj0gY2lyY2xlLnRvcCAmJiB5IDw9IGNpcmNsZS5ib3R0b20pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGR4ID0gKGNpcmNsZS54IC0geCkgKiAoY2lyY2xlLnggLSB4KTtcclxuICAgICAgICB2YXIgZHkgPSAoY2lyY2xlLnkgLSB5KSAqIChjaXJjbGUueSAtIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gKGR4ICsgZHkpIDw9IChjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB4LCB5KVxyXG57XHJcbiAgICBpZiAoZWxsaXBzZS53aWR0aCA8PSAwIHx8IGVsbGlwc2UuaGVpZ2h0IDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gXHJcbiAgICAvLyAgTm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDAgYW5kIGEgcmFkaXVzIG9mIDAuNVxyXG4gICAgdmFyIG5vcm14ID0gKCh4IC0gZWxsaXBzZS54KSAvIGVsbGlwc2Uud2lkdGgpIC0gMC41O1xyXG4gICAgdmFyIG5vcm15ID0gKCh5IC0gZWxsaXBzZS55KSAvIGVsbGlwc2UuaGVpZ2h0KSAtIDAuNTtcclxuIFxyXG4gICAgbm9ybXggKj0gbm9ybXg7XHJcbiAgICBub3JteSAqPSBub3JteTtcclxuIFxyXG4gICAgcmV0dXJuIChub3JteCArIG5vcm15IDwgMC4yNSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvbnZlcnQgYSBkaXN0YW5jZSBhbG9uZyB0aGlzIGN1cnZlIGludG8gYSBgdGltZWAgdmFsdWUgd2hpY2ggd2lsbCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbiogXHJcbiogRm9yIGV4YW1wbGUgaWYgdGhpcyBjdXJ2ZSBoYXMgYSBsZW5ndGggb2YgMTAwIHBpeGVscyB0aGVuIGBmaW5kVCg1MClgIHdvdWxkIHJldHVybiBgMC41YC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZmluZFRcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGRpc3RhbmNlIC0gVGhlIGRpc3RhbmNlIGludG8gdGhlIGN1cnZlIGluIHBpeGVscy4gU2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0aW1lIChgdGApIHZhbHVlLCBhIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cclxuKi9cclxudmFyIEZpbmRUID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZpbmQgdGhlIF9wb2ludHMgd2hpY2ggYnJhY2tldCB0aGUgZGlzdGFuY2UgdmFsdWVcclxuICAgIHZhciB0aSA9IE1hdGguZmxvb3IoZGlzdGFuY2UgLyBjdXJ2ZS5sZW5ndGggKiBjdXJ2ZS5fYWNjdXJhY3kpO1xyXG5cclxuICAgIHdoaWxlICh0aSA+IDAgJiYgY3VydmUuX3BvaW50c1t0aV0gPiBkaXN0YW5jZSlcclxuICAgIHtcclxuICAgICAgICB0aS0tO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlICh0aSA8IGN1cnZlLl9hY2N1cmFjeSAmJiBjdXJ2ZS5fcG9pbnRzW3RpXSA8IGRpc3RhbmNlKVxyXG4gICAge1xyXG4gICAgICAgIHRpKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIExpbmVhciBpbnRlcnBvbGF0aW9uIHRvIGdldCBhIG1vcmUgYWNjdXJhdGUgZml4XHJcbiAgICB2YXIgZHQgPSBjdXJ2ZS5fcG9pbnRzW3RpXSAtIGN1cnZlLl9wb2ludHNbdGkgLSAxXTtcclxuICAgIHZhciBkID0gZGlzdGFuY2UgLSBjdXJ2ZS5fcG9pbnRzW3RpIC0gMV07XHJcblxyXG4gICAgcmV0dXJuICgodGkgLSAxKSAvIGN1cnZlLl9hY2N1cmFjeSkgKyBkIC8gKGR0ICogY3VydmUuX2FjY3VyYWN5KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmluZFQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9GaW5kVC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIEdldCBhIHBvaW50IG9uIHRoZSBjdXJ2ZSB1c2luZyB0aGUgYHRgICh0aW1lKSB2YWx1ZSwgd2hpY2ggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50XHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCBhIHBvaW50LiBUaGlzIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSBhbmQgMSB0aGUgZW5kLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gW3BvaW50XSAtIEFuIG9wdGlvbmFsIFBoYXNlci5Qb2ludCwgb3IgT2JqZWN0IGNvbnRhaW5pbmcgcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIGdpdmVuIHRoZSByZXN1bHRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBPYmplY3RzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIG9taXR0ZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCBpcyBjcmVhdGVkLlxyXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQW4gT2JqZWN0IHdpdGggdGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgYXQgdGhlIHNwZWNpZmllZCBgdGAgdmFsdWUgc2V0IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgR2V0UG9pbnQgPSBmdW5jdGlvbiAoY3VydmUsIHQsIG91dClcclxue1xyXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgaWYgKHQgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0ID4gMSlcclxuICAgIHtcclxuICAgICAgICB0ID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgIHZhciB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICBvdXQueCA9IHQzICogY3VydmUuX2F4ICsgdDIgKiBjdXJ2ZS5fYnggKyB0ICogY3VydmUuX3YxeCArIGN1cnZlLl9wMXg7XHJcbiAgICBvdXQueSA9IHQzICogY3VydmUuX2F5ICsgdDIgKiBjdXJ2ZS5fYnkgKyB0ICogY3VydmUuX3YxeSArIGN1cnZlLl9wMXk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwiXHJcbnZhciBSb3RhdGVBcm91bmRYWSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBsaW5lLngxIC0geDtcclxuICAgIHZhciB0eSA9IGxpbmUueTEgLSB5O1xyXG5cclxuICAgIGxpbmUueDEgPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgbGluZS55MSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgdHggPSBsaW5lLngyIC0geDtcclxuICAgIHR5ID0gbGluZS55MiAtIHk7XHJcblxyXG4gICAgbGluZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICBsaW5lLnkyID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRYWS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qilcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueCkgKyAocG9pbnRBLnkgKiBwb2ludEIueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRG90LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIChyZWN0LmhlaWdodCA9PT0gMCkgPyBOYU4gOiByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEFzcGVjdFJhdGlvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRBc3BlY3RSYXRpby5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIENyZWF0ZXMgYW4gWEhSU2V0dGluZ3MgT2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuXHJcbnZhciBYSFJTZXR0aW5ncyA9IGZ1bmN0aW9uIChyZXNwb25zZVR5cGUsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCwgdGltZW91dClcclxue1xyXG4gICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gdW5kZWZpbmVkKSB7IHJlc3BvbnNlVHlwZSA9ICcnOyB9XHJcbiAgICBpZiAoYXN5bmMgPT09IHVuZGVmaW5lZCkgeyBhc3luYyA9IHRydWU7IH1cclxuICAgIGlmICh1c2VyID09PSB1bmRlZmluZWQpIHsgdXNlciA9ICcnOyB9XHJcbiAgICBpZiAocGFzc3dvcmQgPT09IHVuZGVmaW5lZCkgeyBwYXNzd29yZCA9ICcnOyB9XHJcbiAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7IHRpbWVvdXQgPSAwOyB9XHJcblxyXG4gICAgLy8gQmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0LCBzZXQgdGhlIHhoci5yZXNwb25zZVR5cGUgdG8gXCJ0ZXh0XCIsIFxyXG4gICAgLy8gXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgb3IgXCJkb2N1bWVudFwiLCBkZXBlbmRpbmcgb24geW91ciBkYXRhIG5lZWRzLiBcclxuICAgIC8vIE5vdGUsIHNldHRpbmcgeGhyLnJlc3BvbnNlVHlwZSA9ICcnIChvciBvbWl0dGluZykgd2lsbCBkZWZhdWx0IHRoZSByZXNwb25zZSB0byBcInRleHRcIi5cclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAvLyAgSWdub3JlZCBieSB0aGUgTG9hZGVyLCBvbmx5IHVzZWQgYnkgRmlsZS5cclxuICAgICAgICByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZSxcclxuXHJcbiAgICAgICAgYXN5bmM6IGFzeW5jLFxyXG5cclxuICAgICAgICAvLyAgY3JlZGVudGlhbHNcclxuICAgICAgICB1c2VyOiB1c2VyLFxyXG4gICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcclxuXHJcbiAgICAgICAgLy8gIHRpbWVvdXQgaW4gbXMgKDAgPSBubyB0aW1lb3V0KVxyXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXHJcblxyXG4gICAgICAgIC8vICBzZXRSZXF1ZXN0SGVhZGVyXHJcbiAgICAgICAgaGVhZGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaGVhZGVyVmFsdWU6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAgICAgLy8gIG92ZXJyaWRlTWltZVR5cGVcclxuICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiB1bmRlZmluZWRcclxuXHJcbiAgICB9O1xyXG4gICAgXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvWEhSU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBDaGlsZHJlbiBDb21wb25lbnQgZmVhdHVyZXMgcXVpY2sgYWNjZXNzIHRvIEdyb3VwIHNvcnRpbmcgcmVsYXRlZCBtZXRob2RzLlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBDaGlsZHJlbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgIC8vICBUaGUgb2JqZWN0cyB0aGF0IGJlbG9uZyB0byB0aGlzIGNvbGxlY3Rpb24uXHJcbiAgICAvLyAgVGhlIGVxdWl2YWxlbnQgb2YgdGhlIG9sZCBgU3ByaXRlLmNoaWxkcmVuYCBhcnJheS5cclxuICAgIHRoaXMubGlzdCA9IFtdO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG59O1xyXG5cclxuQ2hpbGRyZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpbGRyZW47XHJcblxyXG5DaGlsZHJlbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQsIHNraXBUcmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNraXBUcmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgeyBza2lwVHJhbnNmb3JtID0gZmFsc2U7IH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4nLCB0aGlzLmdhbWVPYmplY3QubmFtZSwgJ2FkZHMgbmV3IGNoaWxkOicsIGNoaWxkLm5hbWUpO1xyXG5cclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NoaWxkcmVuLmFkZCAxJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NoaWxkcmVuLmFkZCAyJyk7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcy5nYW1lT2JqZWN0O1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QucHVzaChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSAmJiB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtICYmIGNoaWxkLnRyYW5zZm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2FtZU9iamVjdC5uYW1lLCAnYWRkcyB0cmFuc2Zvcm0gZnJvbScsIGNoaWxkLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtLmFkZChjaGlsZC50cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJzwtLS0gZW5kJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXQ6IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgsIHNraXBUcmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKHNraXBUcmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgeyBza2lwVHJhbnNmb3JtID0gZmFsc2U7IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtICYmIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0gJiYgY2hpbGQudHJhbnNmb3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybS5hZGQoY2hpbGQudHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbiAoY2hpbGRyZW4sIHNraXBUcmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY2hpbGRyZW5baV0sIHNraXBUcmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEF0OiBmdW5jdGlvbiAoaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpbmRleF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJldHVybiAtMSBpZiBnaXZlbiBjaGlsZCBpc24ndCBhIGNoaWxkIG9mIHRoaXMgcGFyZW50XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgc2V0IGJhc2VkIG9uIHRoZSBwcm9wZXJ0eSBzdHJpY3RseSBlcXVhbGluZyB0aGUgdmFsdWUgZ2l2ZW4uXHJcbiAgICAqIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I2dldEJ5S2V5XHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byBjaGVjayBhZ2FpbnN0IHRoZSB2YWx1ZS5cclxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBzdHJpY3RseSBlcXVhbHMuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGl0ZW0gdGhhdCB3YXMgZm91bmQsIG9yIG51bGwgaWYgbm90aGluZyBtYXRjaGVkLlxyXG4gICAgKi9cclxuICAgIGdldEJ5S2V5OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNlYXJjaGVzIHRoZSBHcm91cCBmb3IgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY2hpbGQgd2l0aCB0aGUgYG5hbWVgXHJcbiAgICAqIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBnaXZlbiBhcmd1bWVudC4gU2hvdWxkIG1vcmUgdGhhbiBvbmUgY2hpbGQgaGF2ZVxyXG4gICAgKiB0aGUgc2FtZSBuYW1lIG9ubHkgdGhlIGZpcnN0IGluc3RhbmNlIGlzIHJldHVybmVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRCeU5hbWVcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSB0byBzZWFyY2ggZm9yLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBmaXJzdCBjaGlsZCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgb3IgbnVsbCBpZiBub25lIHdlcmUgZm91bmQuXHJcbiAgICAqL1xyXG4gICAgZ2V0QnlOYW1lOiBmdW5jdGlvbiAobmFtZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCeUtleSgnbmFtZScsIG5hbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBjaGlsZCBmcm9tIHRoZSBncm91cC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0UmFuZG9tXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0SW5kZXg9MF0gLSBPZmZzZXQgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGdyb3VwIChsb3dlc3QgY2hpbGQpLlxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9KHRvIHRvcCldIC0gUmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gY2hpbGQgb2YgdGhpcyBHcm91cC5cclxuICAgICovXHJcbiAgICBnZXRSYW5kb206IGZ1bmN0aW9uIChzdGFydEluZGV4LCBsZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkgeyBzdGFydEluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDAgfHwgbGVuZ3RoID4gdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnRJbmRleCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbcmFuZG9tSW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gaW4gdGhpcyBHcm91cC5cclxuICAgICpcclxuICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBtYXRjaGluZyBjcml0ZXJpYSB1c2luZyB0aGUgYHByb3BlcnR5YCBhbmQgYHZhbHVlYCBhcmd1bWVudHMuXHJcbiAgICAqXHJcbiAgICAqIEZvciBleGFtcGxlOiBgZ2V0QWxsKCdleGlzdHMnLCB0cnVlKWAgd291bGQgcmV0dXJuIG9ubHkgY2hpbGRyZW4gdGhhdCBoYXZlIHRoZWlyIGV4aXN0cyBwcm9wZXJ0eSBzZXQuXHJcbiAgICAqXHJcbiAgICAqIE9wdGlvbmFsbHkgeW91IGNhbiBzcGVjaWZ5IGEgc3RhcnQgYW5kIGVuZCBpbmRleC4gRm9yIGV4YW1wbGUgaWYgdGhpcyBHcm91cCBoYWQgMTAwIGNoaWxkcmVuLFxyXG4gICAgKiBhbmQgeW91IHNldCBgc3RhcnRJbmRleGAgdG8gMCBhbmQgYGVuZEluZGV4YCB0byA1MCwgaXQgd291bGQgcmV0dXJuIG1hdGNoZXMgZnJvbSBvbmx5XHJcbiAgICAqIHRoZSBmaXJzdCA1MCBjaGlsZHJlbiBpbiB0aGUgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldEFsbFxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEFuIG9wdGlvbmFsIHByb3BlcnR5IHRvIHRlc3QgYWdhaW5zdCB0aGUgdmFsdWUgYXJndW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSBbdmFsdWVdIC0gSWYgcHJvcGVydHkgaXMgc2V0IHRoZW4gQ2hpbGQucHJvcGVydHkgbXVzdCBzdHJpY3RseSBlcXVhbCB0aGlzIHZhbHVlIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLlxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydEluZGV4PTBdIC0gVGhlIGZpcnN0IGNoaWxkIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbS5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kSW5kZXhdIC0gVGhlIGxhc3QgY2hpbGQgaW5kZXggdG8gc2VhcmNoIHVwIHVudGlsLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIGV4aXN0aW5nIGNoaWxkIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqL1xyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHN3YXA6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMilcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQxID09PSBjaGlsZDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xyXG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmdldEluZGV4KGNoaWxkMik7XHJcblxyXG4gICAgICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgc2FtZSBwYXJlbnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDFdID0gY2hpbGQyO1xyXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDJdID0gY2hpbGQxO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgIHdhcyBzZXRJbmRleFxyXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLm1vdmVUbzogVGhlIHN1cHBsaWVkIGluZGV4IGlzIG91dCBvZiBib3VuZHMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZW1vdmVcclxuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XHJcblxyXG4gICAgICAgIC8vICBBZGQgaW4gbmV3IGxvY2F0aW9uXHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkLCBza2lwVHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtICYmIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0gJiYgY2hpbGQudHJhbnNmb3JtKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtLnJlbW92ZShjaGlsZC50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChpbmRleCwgc2tpcFRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmxpc3RbaW5kZXhdO1xyXG5cclxuICAgICAgICBpZiAoY2hpbGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0gJiYgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybSAmJiBjaGlsZC50cmFuc2Zvcm0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0ucmVtb3ZlKGNoaWxkLnRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQmV0d2VlbjogZnVuY3Rpb24gKGJlZ2luSW5kZXgsIGVuZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB1bmRlZmluZWQpIHsgYmVnaW5JbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAoZW5kSW5kZXggPT09IHVuZGVmaW5lZCkgeyBlbmRJbmRleCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cclxuXHJcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kSW5kZXggLSBiZWdpbkluZGV4O1xyXG5cclxuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmxpc3Quc3BsaWNlKGJlZ2luSW5kZXgsIHJhbmdlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnJlbW92ZUJldHdlZW46IFJhbmdlIEVycm9yLCBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgYWxsIHRoZSBpdGVtcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjcmVtb3ZlQWxsXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2hpbGQgaXMgYSBjaGlsZCBvZiB0aGlzIG9iamVjdCwgYXQgYW55IGRlcHRoIChyZWN1cnNpdmVseSBzY2FucyB1cCB0aGUgdHJlZSlcclxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFjaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKGNoaWxkLnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQnJpbmdzIHRoZSBnaXZlbiBjaGlsZCB0byB0aGUgdG9wIG9mIHRoaXMgZ3JvdXAgc28gaXQgcmVuZGVycyBhYm92ZSBhbGwgb3RoZXIgY2hpbGRyZW4uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2JyaW5nVG9Ub3BcclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGJyaW5nIHRvIHRoZSB0b3Agb2YgdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgYnJpbmdUb1RvcDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPCB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZW5kcyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYmVsb3cgYWxsIG90aGVyIGNoaWxkcmVuLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNzZW5kVG9CYWNrXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBzZW5kIHRvIHRoZSBib3R0b20gb2YgdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KGNoaWxkLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmVzIHRoZSBnaXZlbiBjaGlsZCB1cCBvbmUgcGxhY2UgaW4gdGhpcyBncm91cCB1bmxlc3MgaXQncyBhbHJlYWR5IGF0IHRoZSB0b3AuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVVcFxyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gbW92ZSB1cCBpbiB0aGUgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIG1vdmVVcDogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XHJcblxyXG4gICAgICAgIGlmIChhICE9PSAtMSAmJiBhIDwgdGhpcy5saXN0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0QXQoYSArIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmVzIHRoZSBnaXZlbiBjaGlsZCBkb3duIG9uZSBwbGFjZSBpbiB0aGlzIGdyb3VwIHVubGVzcyBpdCdzIGFscmVhZHkgYXQgdGhlIGJvdHRvbS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZURvd25cclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIG1vdmUgZG93biBpbiB0aGUgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxyXG4gICAgKi9cclxuICAgIG1vdmVEb3duOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGEgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmdldEF0KGEgLSAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXAoY2hpbGQsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXZlcnNlcyBhbGwgY2hpbGRyZW4gaW4gdGhpcyBncm91cC5cclxuICAgICpcclxuICAgICogVGhpcyBvcGVyYXRpb24gYXBwbGllcyBvbmx5IHRvIGltbWVkaWF0ZSBjaGlsZHJlbiBhbmQgZG9lcyBub3QgcHJvcGFnYXRlIHRvIHN1Ymdyb3Vwcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjcmV2ZXJzZVxyXG4gICAgKi9cclxuICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNodWZmbGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmxpc3RbaV07XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtpXSA9IHRoaXMubGlzdFtqXTtcclxuICAgICAgICAgICAgdGhpcy5saXN0W2pdID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVwbGFjZXMgYSBjaGlsZCBvZiB0aGlzIEdyb3VwIHdpdGggdGhlIGdpdmVuIG5ld0NoaWxkLiBUaGUgbmV3Q2hpbGQgY2Fubm90IGJlIGEgbWVtYmVyIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIElmIGBHcm91cC5lbmFibGVCb2R5YCBpcyBzZXQsIHRoZW4gYSBwaHlzaWNzIGJvZHkgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZSBvYmplY3QsIHNvIGxvbmcgYXMgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXHJcbiAgICAqXHJcbiAgICAqIElmIGBHcm91cC5pbnB1dEVuYWJsZUNoaWxkcmVuYCBpcyBzZXQsIHRoZW4gYW4gSW5wdXQgSGFuZGxlciB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgc28gbG9uZyBhcyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjcmVwbGFjZVxyXG4gICAgKiBAcGFyYW0ge2FueX0gb2xkQ2hpbGQgLSBUaGUgY2hpbGQgaW4gdGhpcyBncm91cCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSBuZXdDaGlsZCAtIFRoZSBjaGlsZCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoaXMgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gUmV0dXJucyB0aGUgb2xkQ2hpbGQgdGhhdCB3YXMgcmVwbGFjZWQgd2l0aGluIHRoaXMgZ3JvdXAuXHJcbiAgICAqL1xyXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9sZENoaWxkLCBuZXdDaGlsZCwgc2tpcFRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KG9sZENoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudC5yZW1vdmUobmV3Q2hpbGQsIHNraXBUcmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShvbGRDaGlsZCwgc2tpcFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KG5ld0NoaWxkLCBpbmRleCwgc2tpcFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU3dhcHMgYSBjaGlsZCBmcm9tIGFub3RoZXIgcGFyZW50LCB3aXRoIG9uZSBmcm9tIHRoaXMgcGFyZW50LlxyXG4gICAgLy8gIGNoaWxkMSA9IHRoZSBjaGlsZCBvZiBUSElTIHBhcmVudFxyXG4gICAgLy8gIGNoaWxkMiA9IHRoZSBjaGlsZCBvZiB0aGUgT1RIRVIgcGFyZW50XHJcbiAgICBleGNoYW5nZTogZnVuY3Rpb24gKGNoaWxkMSwgY2hpbGQyLCBza2lwVHJhbnNmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMiB8fCBjaGlsZDEucGFyZW50ID09PSBjaGlsZDIucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhcmVudENoaWxkcmVuID0gY2hpbGQyLnBhcmVudC5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcclxuICAgICAgICB2YXIgaW5kZXgyID0gcGFyZW50Q2hpbGRyZW4uZ2V0SW5kZXgoY2hpbGQyKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4MSA8IDAgfHwgaW5kZXgyIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4uc3dhcDogU3VwcGxpZWQgb2JqZWN0cyBtdXN0IGJlIGNoaWxkcmVuIG9mIHBhcmVudHMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkMSwgc2tpcFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgIHBhcmVudENoaWxkcmVuLnJlbW92ZShjaGlsZDIsIHNraXBUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEF0KGNoaWxkMiwgaW5kZXgxLCBza2lwVHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgcGFyZW50Q2hpbGRyZW4uYWRkQXQoY2hpbGQxLCBpbmRleDIsIHNraXBUcmFuc2Zvcm0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2hlY2tzIGZvciB0aGUgaXRlbSB3aXRoaW4gdGhpcyBsaXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNleGlzdHNcclxuICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIGxpc3QgaW5kZXggZm9yLlxyXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBsaXN0LCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAqL1xyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCkgPiAtMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBga2V5YCB0byB0aGUgZ2l2ZW4gdmFsdWUgb24gYWxsIG1lbWJlcnMgb2YgdGhpcyBsaXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNzZXRBbGxcclxuICAgICogQHBhcmFtIHthbnl9IGtleSAtIFRoZSBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB0byBzZXQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvLlxyXG4gICAgKi9cclxuICAgIHNldEFsbDogZnVuY3Rpb24gKGtleSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RbaV1ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUGFzc2VzIGFsbCBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1swXSA9IHRoaXMubGlzdFtpXTtcclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBHcm91cCB0byB0aGUgR3JvdXAgZ2l2ZW4uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVBbGxcclxuICAgICogQHBhcmFtIHtQaGFzZXIuR3JvdXB9IGdyb3VwIC0gVGhlIG5ldyBHcm91cCB0byB3aGljaCB0aGUgY2hpbGRyZW4gd2lsbCBiZSBtb3ZlZCB0by5cclxuICAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIElmIHRydWUgdGhlIGNoaWxkcmVuIHdpbGwgbm90IGRpc3BhdGNoIHRoZSBgb25BZGRlZFRvR3JvdXBgIGV2ZW50IGZvciB0aGUgbmV3IEdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuR3JvdXB9IFRoZSBHcm91cCB0byB3aGljaCBhbGwgdGhlIGNoaWxkcmVuIHdlcmUgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgcmVwYXJlbnQ6IGZ1bmN0aW9uIChuZXdQYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5ld1BhcmVudCAhPT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnJlbW92ZSh0aGlzLmxpc3RbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5hZGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3UGFyZW50O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoaWxkcmVuLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNmaXJzdFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gZmlyc3RcclxuICAgICovXHJcbiAgICBsZW5ndGg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2ZpcnN0XHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaXJzdFxyXG4gICAgKi9cclxuICAgIGZpcnN0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0WzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgZW5kLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjbGFzdFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gbGFzdFxyXG4gICAgKi9cclxuICAgIGxhc3Q6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIHRoZSBuZXh0IGl0ZW0gKGJhc2VkIG9uIHRoZSBjdXJzb3IpIGFuZCBhZHZhbmNlcyB0aGUgY3Vyc29yLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjbmV4dFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gbmV4dFxyXG4gICAgKi9cclxuICAgIG5leHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPCB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uKys7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIHRoZSBwcmV2aW91cyBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgcmV0cmVhdHMgdGhlIGN1cnNvci5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I3ByZXZpb3VzXHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcmV2aW91c1xyXG4gICAgKi9cclxuICAgIHByZXZpb3VzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hpbGRyZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQ2hpbGRyZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHtcclxuXHJcbiAgICBzdXBwb3J0TmV3QmxlbmRNb2RlczogZmFsc2UsXHJcblxyXG4gICAgc3VwcG9ydEludmVyc2VBbHBoYTogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjaGVja0JsZW5kTW9kZSAoKVxyXG57XHJcbiAgICB2YXIgcG5nSGVhZCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUJBUU1BQUFERDhwMk9BQUFBQTFCTVZFWC8nO1xyXG4gICAgdmFyIHBuZ0VuZCA9ICdBQUFBQ2tsRVFWUUkxMk5nQUFBQUFnQUI0aUc4TXdBQUFBQkpSVTVFcmtKZ2dnPT0nO1xyXG5cclxuICAgIHZhciBtYWdlbnRhID0gbmV3IEltYWdlKCk7XHJcbiAgICBtYWdlbnRhLnNyYyA9IHBuZ0hlYWQgKyAnQVA4MDRPYTYnICsgcG5nRW5kO1xyXG5cclxuICAgIHZhciB5ZWxsb3cgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHllbGxvdy5zcmMgPSBwbmdIZWFkICsgJy93Q0t4dlJGJyArIHBuZ0VuZDtcclxuXHJcbiAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcywgNiwgMSk7XHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hZ2VudGEsIDAsIDApO1xyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcclxuXHJcbiAgICBpZiAoIWNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsIDAsIDEsIDEpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsIDAsIDEsIDEpLmRhdGE7XHJcblxyXG4gICAgQ2FudmFzUG9vbC5yZW1vdmUodGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIChkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbnZlcnNlQWxwaGEgKClcclxue1xyXG4gICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIDIsIDEpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDEwLCAyMCwgMzAsIDAuNSknO1xyXG5cclxuICAgIC8vICBEcmF3IGEgc2luZ2xlIHBpeGVsXHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBHZXQgdGhlIGNvbG9yIHZhbHVlc1xyXG4gICAgdmFyIHMxID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XHJcblxyXG4gICAgaWYgKHMxID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgUGxvdCB0aGVtIHRvIHgyXHJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShzMSwgMSwgMCk7XHJcblxyXG4gICAgLy8gIEdldCB0aG9zZSB2YWx1ZXNcclxuICAgIHZhciBzMiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDEsIDAsIDEsIDEpO1xyXG5cclxuICAgIC8vICBDb21wYXJlIGFuZCByZXR1cm5cclxuICAgIHJldHVybiAoczIuZGF0YVswXSA9PT0gczEuZGF0YVswXSAmJiBzMi5kYXRhWzFdID09PSBzMS5kYXRhWzFdICYmIHMyLmRhdGFbMl0gPT09IHMxLmRhdGFbMl0gJiYgczIuZGF0YVszXSA9PT0gczEuZGF0YVszXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgaWYgKGRvY3VtZW50ICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydE5ld0JsZW5kTW9kZXMgPSBjaGVja0JsZW5kTW9kZSgpO1xyXG4gICAgICAgIENhbnZhc0ZlYXR1cmVzLnN1cHBvcnRJbnZlcnNlQWxwaGEgPSBjaGVja0ludmVyc2VBbHBoYSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDYW52YXNGZWF0dXJlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0NhbnZhc0ZlYXR1cmVzLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG52YXIgRmVhdHVyZXMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FudmFzIC0gSXMgY2FudmFzIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjYW52YXM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgez9ib29sZWFufSBjYW52YXNCaXRCbHRTaGlmdCAtIFRydWUgaWYgY2FudmFzIHN1cHBvcnRzIGEgJ2NvcHknIGJpdGJsdCBvbnRvIGl0c2VsZiB3aGVuIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHJlZ2lvbnMgb3ZlcmxhcC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjYW52YXNCaXRCbHRTaGlmdDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJHTCAtIElzIHdlYkdMIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJHTDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZSAtIElzIGZpbGUgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGZpbGU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGVTeXN0ZW0gLSBJcyBmaWxlU3lzdGVtIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBmaWxlU3lzdGVtOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsb2NhbFN0b3JhZ2UgLSBJcyBsb2NhbFN0b3JhZ2UgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGxvY2FsU3RvcmFnZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd29ya2VyIC0gSXMgd29ya2VyIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3b3JrZXI6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHBvaW50ZXJMb2NrIC0gSXMgUG9pbnRlciBMb2NrIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBwb2ludGVyTG9jazogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlicmF0aW9uIC0gRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgdGhlIFZpYnJhdGlvbiBBUEk/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdmlicmF0aW9uOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBnZXRVc2VyTWVkaWEgLSBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0aGUgZ2V0VXNlck1lZGlhIEFQST9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBnZXRVc2VyTWVkaWE6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIC0gSXMgdGhlIGRldmljZSBiaWcgb3IgbGl0dGxlIGVuZGlhbj8gKG9ubHkgZGV0ZWN0ZWQgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWRBcnJheXMpXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbGl0dGxlRW5kaWFuOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBzdXBwb3J0MzJiaXQgLSBEb2VzIHRoZSBkZXZpY2UgY29udGV4dCBzdXBwb3J0IDMyYml0IHBpeGVsIG1hbmlwdWxhdGlvbiB1c2luZyBhcnJheSBidWZmZXIgdmlld3M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc3VwcG9ydDMyYml0OiBmYWxzZVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4qIENoZWNrIExpdHRsZSBvciBCaWcgRW5kaWFuIHN5c3RlbS5cclxuKlxyXG4qIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAoQG1hdHRkZXNsKVxyXG4qL1xyXG5mdW5jdGlvbiBjaGVja0lzTGl0dGxlRW5kaWFuICgpXHJcbntcclxuICAgIHZhciBhID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShhKTtcclxuICAgIHZhciBjID0gbmV3IFVpbnQzMkFycmF5KGEpO1xyXG5cclxuICAgIGJbMF0gPSAweGExO1xyXG4gICAgYlsxXSA9IDB4YjI7XHJcbiAgICBiWzJdID0gMHhjMztcclxuICAgIGJbM10gPSAweGQ0O1xyXG5cclxuICAgIGlmIChjWzBdID09PSAweGQ0YzNiMmExKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjWzBdID09PSAweGExYjJjM2Q0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgQ291bGQgbm90IGRldGVybWluZSBlbmRpYW5uZXNzXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgRmVhdHVyZXMuY2FudmFzID0gISF3aW5kb3dbJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCddIHx8IE9TLmNvY29vbkpTO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIEZlYXR1cmVzLmxvY2FsU3RvcmFnZSA9ICEhbG9jYWxTdG9yYWdlLmdldEl0ZW07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMubG9jYWxTdG9yYWdlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuZmlsZSA9ICEhd2luZG93WydGaWxlJ10gJiYgISF3aW5kb3dbJ0ZpbGVSZWFkZXInXSAmJiAhIXdpbmRvd1snRmlsZUxpc3QnXSAmJiAhIXdpbmRvd1snQmxvYiddO1xyXG4gICAgRmVhdHVyZXMuZmlsZVN5c3RlbSA9ICEhd2luZG93WydyZXF1ZXN0RmlsZVN5c3RlbSddO1xyXG5cclxuICAgIHZhciBpc1VpbnQ4ID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIHRlc3RXZWJHTCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHdpbmRvd1snV2ViR0xSZW5kZXJpbmdDb250ZXh0J10pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0cnlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlV2ViR0wodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE9TLmNvY29vbkpTKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zY3JlZW5jYW52YXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjYW52YXMyRCA9IENhbnZhc1Bvb2wuY3JlYXRlMkQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGN0eDJEID0gY2FudmFzMkQuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgQ2FuJ3QgYmUgZG9uZSBvbiBhIHdlYmdsIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGN0eDJELmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAqIFRlc3QgdG8gc2VlIGlmIEltYWdlRGF0YSB1c2VzIENhbnZhc1BpeGVsQXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXkuXHJcbiAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAoQG1hdHRkZXNsKVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlzVWludDggPSBpbWFnZS5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIENhbnZhc1Bvb2wucmVtb3ZlKGNhbnZhczJEKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN0eCAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEZlYXR1cmVzLndlYkdMID0gdGVzdFdlYkdMKCk7XHJcblxyXG4gICAgRmVhdHVyZXMud29ya2VyID0gISF3aW5kb3dbJ1dvcmtlciddO1xyXG5cclxuICAgIEZlYXR1cmVzLnBvaW50ZXJMb2NrID0gJ3BvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ21velBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ3dlYmtpdFBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQ7XHJcblxyXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iub0dldFVzZXJNZWRpYTtcclxuXHJcbiAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xyXG5cclxuICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IEZlYXR1cmVzLmdldFVzZXJNZWRpYSAmJiAhIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgISF3aW5kb3cuVVJMO1xyXG5cclxuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGZpcmVmb3ggKDwgMjEpIGFwcGFyZW50bHkgY2xhaW0gc3VwcG9ydCBidXQgdXNlciBtZWRpYSBkb2VzIG5vdCBhY3R1YWxseSB3b3JrXHJcbiAgICBpZiAoQnJvd3Nlci5maXJlZm94ICYmIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPCAyMSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGNsdWRlcyBpT1MgdmVyc2lvbnMgYXMgdGhleSBnZW5lcmFsbHkgd3JhcCBVSVdlYlZpZXcgKGVnLiBTYWZhcmkgV2ViS2l0KSBhbmQgaXRcclxuICAgIC8vIGlzIHNhZmVyIHRvIG5vdCB0cnkgYW5kIHVzZSB0aGUgZmFzdCBjb3B5LW92ZXIgbWV0aG9kLlxyXG4gICAgaWYgKCFPUy5pT1MgJiYgKEJyb3dzZXIuaWUgfHwgQnJvd3Nlci5maXJlZm94IHx8IEJyb3dzZXIuY2hyb21lKSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS25vd24gbm90IHRvIHdvcmtcclxuICAgIGlmIChCcm93c2VyLnNhZmFyaSB8fCBCcm93c2VyLm1vYmlsZVNhZmFyaSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHwgbmF2aWdhdG9yLndlYmtpdFZpYnJhdGUgfHwgbmF2aWdhdG9yLm1velZpYnJhdGUgfHwgbmF2aWdhdG9yLm1zVmlicmF0ZTtcclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLnZpYnJhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMudmlicmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJylcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gPSBjaGVja0lzTGl0dGxlRW5kaWFuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuc3VwcG9ydDMyYml0ID0gKFxyXG4gICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgRmVhdHVyZXMubGl0dGxlRW5kaWFuICE9PSBudWxsICYmXHJcbiAgICAgICAgaXNVaW50OFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvRmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsInZhciBFVkVOVF9DT05TVCA9IHtcclxuXHJcbiAgICBESVNQQVRDSEVSX0lETEU6IDAsXHJcbiAgICBESVNQQVRDSEVSX0RJU1BBVENISU5HOiAxLFxyXG4gICAgRElTUEFUQ0hFUl9SRU1PVklORzogMixcclxuICAgIERJU1BBVENIRVJfREVTVFJPWUVEOiAzLFxyXG5cclxuICAgIExJU1RFTkVSX1BFTkRJTkc6IDQsXHJcbiAgICBMSVNURU5FUl9BQ1RJVkU6IDUsXHJcbiAgICBMSVNURU5FUl9SRU1PVklORzogNlxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRVZFTlRfQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgV3JhcEFuZ2xlID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwJyk7XHJcblxyXG4vKipcclxuKiBUaGlzIGlzIHRoZSBiYXNlIEdhbWUgT2JqZWN0IGNsYXNzIHRoYXQgeW91IGNhbiB1c2Ugd2hlbiBjcmVhdGluZyB5b3VyIG93biBleHRlbmRlZCBHYW1lIE9iamVjdHMuXHJcbiogSXQgaGlkZXMgYXdheSB0aGUgJ3ByaXZhdGUnIHN0dWZmIGFuZCBleHBvc2VzIG9ubHkgdGhlIHVzZWZ1bCBnZXR0ZXJzLCBzZXR0ZXJzIGFuZCBwcm9wZXJ0aWVzLlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcblxyXG4vLyAgUGhhc2VyLlRleHR1cmUgYW5kIFBoYXNlci5GcmFtZSBvYmplY3RzIHBhc3NlZCBpbiBoZXJlLCBpbnN0ZWFkIG9mIGxvb2tlZC11cC5cclxuLy8gIEFsbG93cyBvdmVycmlkZSBmcm9tIG5vbi1zdGFuZGFyZCBHTyB0eXBlc1xyXG5cclxudmFyIEdhbWVPYmplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHgsIHksIHRleHR1cmUsIGZyYW1lLCBwYXJlbnQpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICB0aGlzLmdhbWUgPSBzdGF0ZS5nYW1lO1xyXG5cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG5cclxuICAgIHRoaXMudHlwZSA9IDA7XHJcblxyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgLy8gIFRleHR1cmUgaXMgZ2xvYmFsbHkgc2hhcmVkIGJldHdlZW4gR2FtZU9iamVjdHMsIG5vdCBzcGVjaWZpYyB0byB0aGlzIG9uZVxyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICAvLyAgRnJhbWUgaXMgZ2xvYmFsbHkgc2hhcmVkIGJldHdlZW4gR2FtZU9iamVjdHMsIG5vdCBzcGVjaWZpYyB0byB0aGlzIG9uZVxyXG4gICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG5cclxuICAgIC8vICBBbGwgR2FtZU9iamVjdHMgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMsIGFsd2F5czpcclxuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IENvbXBvbmVudC5UcmFuc2Zvcm0odGhpcywgeCwgeSk7XHJcblxyXG4gICAgLy8gIE9wdGlvbmFsPyBNYXliZSBzZXQgb24gYSBwZXIgR08gYmFzaXM/XHJcbiAgICB0aGlzLmRhdGEgPSBuZXcgQ29tcG9uZW50LkRhdGEodGhpcyk7XHJcblxyXG4gICAgdGhpcy5jb2xvciA9IG5ldyBDb21wb25lbnQuQ29sb3IodGhpcyk7XHJcblxyXG4gICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBkZWJhdGFibGUgdG8gaGF2ZSBpbiB0aGlzIGNsYXNzXHJcbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB0aGlzLnNjYWxlTW9kZSA9IFNjYWxlTW9kZXMuREVGQVVMVDtcclxuXHJcbiAgICAvLyAgQWxsb3dzIHlvdSB0byB0dXJuIG9mZiBhIEdhbWVPYmplY3QgZnJvbSByZW5kZXJpbmcsIGJ1dCBzdGlsbCByZW5kZXIgaXRzIGNoaWxkcmVuIChpZiBpdCBoYXMgYW55KVxyXG4gICAgLy8gIE1heWJlIHRoaXMgc2hvdWxkIG1vdmU/XHJcbiAgICAvLyB0aGlzLnNraXBSZW5kZXIgPSAoa2V5ID09PSB1bmRlZmluZWQpO1xyXG4gICAgdGhpcy5za2lwUmVuZGVyID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvLyAgRWl0aGVyIG51bGwsIG9yIHRoZSBDaGlsZHJlbiBjb21wb25lbnRcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZXhpc3RzID0gdHJ1ZTtcclxufTtcclxuXHJcbkdhbWVPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2FtZU9iamVjdDtcclxuXHJcbkdhbWVPYmplY3QucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgTk9PUFxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5PT1BcclxuICAgIH0sXHJcblxyXG4gICAgcG9zdFVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgTk9PUFxyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5PT1BcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgTk9PUFxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEdhbWVPYmplY3QucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xyXG5cclxuICAgIHg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1kgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3I6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9hbmNob3JYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2V0QW5jaG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9hbmNob3JYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9hbmNob3JZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGl2b3RYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGl2b3RZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmdsZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKiBNQVRIX0NPTlNULlJBRF9UT19ERUcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IFdyYXBBbmdsZSh2YWx1ZSkgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRpb246IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uICUgTUFUSF9DT05TVC5QSTIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmNhY2hlLnNyID0gTWF0aC5zaW4odGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmNhY2hlLmNyID0gTWF0aC5jb3ModGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5oYXNMb2NhbFJvdGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmhhc0xvY2FsUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDb2xvciBnZXR0ZXJzIC8gc2V0dGVyc1xyXG5cclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yLl9hbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IuYWxwaGEgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBibGVuZE1vZGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuX2JsZW5kTW9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IuYmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwidmFyIENpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgeyByYWRpdXMgPSAwOyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcclxuICAgIHRoaXMuX2RpYW1ldGVyID0gcmFkaXVzICogMjtcclxufTtcclxuXHJcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XHJcblxyXG5DaXJjbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpdXMgPD0gMCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2lyY2xlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIHJhZGl1czoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWUgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGRpYW1ldGVyOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFtZXRlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYW1ldGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlICogMC41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUgLSB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAwOyB9XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn07XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2U7XHJcblxyXG5FbGxpcHNlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFLQSBTZW1pIE1pbm9yIEF4aXNcclxuICAgIGdldE1pbm9yUmFkaXVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQUtBIFNlbWkgTWFqb3IgQXhpc1xyXG4gICAgZ2V0TWFqb3JSYWRpdXM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDI7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5yaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5ib3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5ib3R0b20gLSB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBhbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIGN1cnZlcyB0YW5nZW50IGJhc2VkIG9uIHRpbWUuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldEFuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIGB0YCAodGltZSkgdmFsdWUgYXQgd2hpY2ggdG8gZmluZCB0aGUgYW5nbGUuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgYHRgIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIEdldEFuZ2xlID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcblxyXG4gICAgR2V0UG9pbnQoY3VydmUsIHQgLSAwLjAxLCBjdXJ2ZS5fdGVtcDEpO1xyXG4gICAgR2V0UG9pbnQoY3VydmUsIHQgKyAwLjAxLCBjdXJ2ZS5fdGVtcDIpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmF0YW4yKGN1cnZlLl90ZW1wMi55IC0gY3VydmUuX3RlbXAxLnksIGN1cnZlLl90ZW1wMi54IC0gY3VydmUuX3RlbXAxLngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ2YXIgUG9pbnRUb0xpbmUgPSBmdW5jdGlvbiAocG9pbnQsIGxpbmUpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50LnggLSBsaW5lLngxKSAqIChsaW5lLnkyIC0gbGluZS55MSkgPT09IChsaW5lLngyIC0gbGluZS54MSkgKiAocG9pbnQueSAtIGxpbmUueTEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgaWYgKHJlY3RBLndpZHRoIDw9IDAgfHwgcmVjdEEuaGVpZ2h0IDw9IDAgfHwgcmVjdEIud2lkdGggPD0gMCB8fCByZWN0Qi5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEocmVjdEEucmlnaHQgPCByZWN0Qi54IHx8IHJlY3RBLmJvdHRvbSA8IHJlY3RCLnkgfHwgcmVjdEEueCA+IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLnkgPiByZWN0Qi5ib3R0b20pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgRGVmaW5lcyBhIExpbmUgc2VnbWVudCwgYSBwYXJ0IG9mIGEgbGluZSBiZXR3ZWVuIHR3byBlbmRwb2ludHNcclxuXHJcbnZhciBMaW5lID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cclxuICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxyXG4gICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHsgeDIgPSAwOyB9XHJcbiAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cclxuXHJcbiAgICB0aGlzLngxID0geDE7XHJcblxyXG4gICAgdGhpcy55MSA9IHkxO1xyXG5cclxuICAgIHRoaXMueDIgPSB4MjtcclxuXHJcbiAgICB0aGlzLnkyID0geTI7XHJcbn07XHJcblxyXG5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmU7XHJcblxyXG5MaW5lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7IHgxID0gMDsgfVxyXG4gICAgICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxyXG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxyXG4gICAgICAgIGlmICh5MiA9PT0gdW5kZWZpbmVkKSB7IHkyID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLngxID0geDE7XHJcbiAgICAgICAgdGhpcy55MSA9IHkxO1xyXG5cclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMaW5lLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPD0gdGhpcy54MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPiB0aGlzLngyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPD0gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnkxLCB0aGlzLnkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnkxID4gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9XcmFwJyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuXHJcbnZhciBOb3JtYWxBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xyXG5cclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsInZhciBHZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoKHBvaW50LnggKiBwb2ludC54KSArIChwb2ludC55ICogcG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlU3EgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIHJldHVybiAocG9pbnQueCAqIHBvaW50LngpICsgKHBvaW50LnkgKiBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWFnbml0dWRlU3E7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAqPSB4O1xyXG4gICAgcG9pbnQueSAqPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbHk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZScpO1xyXG5cclxudmFyIE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgaWYgKHBvaW50LnggIT09IDAgJiYgcG9pbnQueSAhPT0gMClcclxuICAgIHtcclxuICAgICAgICB2YXIgbSA9IEdldE1hZ25pdHVkZShwb2ludCk7XHJcblxyXG4gICAgICAgIHBvaW50LnggLz0gbTtcclxuICAgICAgICBwb2ludC55IC89IG07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIi8qKlxyXG4qIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvbi5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBDb250YWlucyA9IGZ1bmN0aW9uIChwb2x5Z29uLCB4LCB5KVxyXG57XHJcbiAgICAvLyAgQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWwgYnkgSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhXHJcblxyXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAtMSwgaiA9IHBvbHlnb24ucG9pbnRzLmxlbmd0aCAtIDE7ICsraSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaiA9IGkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl4ID0gcG9seWdvbi5wb2ludHNbaV0ueDtcclxuICAgICAgICB2YXIgaXkgPSBwb2x5Z29uLnBvaW50c1tpXS55O1xyXG5cclxuICAgICAgICB2YXIganggPSBwb2x5Z29uLnBvaW50c1tqXS54O1xyXG4gICAgICAgIHZhciBqeSA9IHBvbHlnb24ucG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgIGlmICgoKGl5IDw9IHkgJiYgeSA8IGp5KSB8fCAoankgPD0geSAmJiB5IDwgaXkpKSAmJiAoeCA8IChqeCAtIGl4KSAqICh5IC0gaXkpIC8gKGp5IC0gaXkpICsgaXgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc2lkZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyZWEgLSBUaGUgYXJlYSBvZiB0aGlzIFBvbHlnb24uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5hcmVhID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHthcnJheX0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVyIHBhaXIgb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhpcyBwb2x5Z29uLiBJLmUuIFsge3gseX0sIHt4LHl9LCB7eCx5fSBdXHJcbiAgICAqL1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICBpZiAocG9pbnRzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VG8ocG9pbnRzKTtcclxuICAgIH1cclxufTtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcclxuXHJcblBvbHlnb24ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIFBvbHlnb24gdG8gdGhlIGdpdmVuIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcG9pbnRzIGNhbiBiZSBzZXQgZnJvbSBhIHZhcmlldHkgb2YgZm9ybWF0czpcclxuICAgICAqXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHM6IGBbbmV3IFBoYXNlci5Qb2ludCh4MSwgeTEpLCAuLi5dYFxyXG4gICAgICogLSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzOiBgW29iajEsIG9iajIsIC4uLl1gXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIHBhaXJlZCBudW1iZXJzIHRoYXQgcmVwcmVzZW50IHBvaW50IGNvb3JkaW5hdGVzOiBgW3gxLHkxLCB4Mix5MiwgLi4uXWBcclxuICAgICAqIC0gQW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdHdvIGVsZW1lbnRzIHJlcHJlc2VudGluZyB4L3kgY29vcmRpbmF0ZXM6IGBbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dYFxyXG4gICAgICpcclxuICAgICAqIGBzZXRUb2AgbWF5IGFsc28gYmUgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50cyB0byByZW1vdmUgYWxsIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI3NldFRvXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5Qb2ludFtdfG51bWJlcltdfC4uLlBoYXNlci5Qb2ludHwuLi5udW1iZXJ9IHBvaW50cyAtIFRoZSBwb2ludHMgdG8gc2V0LlxyXG4gICAgICogQHJldHVybiB7UGhhc2VyLlBvbHlnb259IFRoaXMgUG9seWdvbiBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChwb2ludHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hcmVhID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIHZhciB5MCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIHA7XHJcblxyXG4gICAgICAgIC8vICBUaGUgcG9pbnRzIGFyZ3VtZW50IGlzIGFuIGFycmF5LCBzbyBpdGVyYXRlIHRocm91Z2ggaXRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHAgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzW2ldID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEFuIGFycmF5IG9mIGFycmF5cz9cclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBvaW50c1tpXVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgTG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIGlmIChwLnkgPCB5MClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeTAgPSBwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQXJlYSh5MCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uIFRoaXMgaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9wZXJ0eSBQb2x5Z29uLmFyZWFcclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI2NhbGN1bGF0ZUFyZWFcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgbG93ZXN0IGJvdW5kYXJ5XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhcmVhIG9mIHRoZSBQb2x5Z29uLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVBcmVhOiBmdW5jdGlvbiAoeTApXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIHZhciBwMTtcclxuICAgICAgICB2YXIgcDI7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuICAgICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICBzdW0gKz0gKHAyLnggLSBwMS54KSAqIChwMS55ICsgcDIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwMSA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgIHN1bSArPSAocDEueCAtIHAyLngpICogKHAyLnkgKyBwMS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhID0gLXN1bSAqIDAuNTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHAxO1xyXG4gICAgICAgIC8vIHZhciBwMjtcclxuICAgICAgICAvLyB2YXIgYXZnSGVpZ2h0O1xyXG4gICAgICAgIC8vIHZhciB3aWR0aDtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgLy8gICAgIGlmIChpID09PSBsZW4gLSAxKVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzWzBdO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGVsc2VcclxuICAgICAgICAvLyAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcbiAgICAgICAgLy8gICAgIGF2Z0hlaWdodCA9ICgocDEueSAtIHkwKSArIChwMi55IC0geTApKSAvIDI7XHJcbiAgICAgICAgLy8gICAgIHdpZHRoID0gcDEueCAtIHAyLng7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYXJlYSArPSBhdmdIZWlnaHQgKiB3aWR0aDtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChyZWN0LnggPD0geCAmJiByZWN0LnggKyByZWN0LndpZHRoID49IHggJiYgcmVjdC55IDw9IHkgJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0geSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xyXG5cclxuLy8gIFRha2VzIHR3byBYSFIgT2JqZWN0cyBhbmQgY3JlYXRlcyBhIG5ldyBvYmplY3RcclxuXHJcbi8vICBUaGUgbmV3IG9iamVjdCBpcyBiYXNlZCBvbiBnbG9iYWwgaW5pdGlhbGx5LCBidXQgYW55IHNldHRpbmcgaW5cclxuLy8gIGxvY2FsIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIHZhbHVlLlxyXG5cclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAoZ2xvYmFsLCBsb2NhbClcclxue1xyXG4gICAgdmFyIG91dHB1dCA9IChnbG9iYWwgPT09IHVuZGVmaW5lZCkgPyBYSFJTZXR0aW5ncygpIDogT2JqZWN0LmFzc2lnbihnbG9iYWwpO1xyXG5cclxuICAgIGlmIChsb2NhbClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBzZXR0aW5nIGluIGxvY2FsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsW3NldHRpbmddICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dFtzZXR0aW5nXSA9IGxvY2FsW3NldHRpbmddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuanNvblxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5qc29uJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnanNvbicsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcbkpTT05GaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5KU09ORmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKU09ORmlsZTtcclxuXHJcbkpTT05GaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xyXG5cclxuICAgIGNhbGxiYWNrKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09ORmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsInZhciBGYWN0b3JpYWwgPSByZXF1aXJlKCcuL0ZhY3RvcmlhbCcpO1xyXG5cclxudmFyIEJlcm5zdGVpbiA9IGZ1bmN0aW9uIChuLCBpKVxyXG57XHJcbiAgICByZXR1cm4gRmFjdG9yaWFsKG4pIC8gRmFjdG9yaWFsKGkpIC8gRmFjdG9yaWFsKG4gLSBpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmVybnN0ZWluO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0Jlcm5zdGVpbi5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9CZXJuc3RlaW4uanMiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhdG11bGxSb20gPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHQpXHJcbntcclxuICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNSwgdjEgPSAocDMgLSBwMSkgKiAwLjUsIHQyID0gdCAqIHQsIHQzID0gdCAqIHQyO1xyXG5cclxuICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9DYXRtdWxsUm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlcyA9IHZhbHVlO1xyXG5cclxuICAgIHdoaWxlICgtLXZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJlcyAqPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3JpYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmFjdG9yaWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZWFyID0gZnVuY3Rpb24gKHAwLCBwMSwgdClcclxue1xyXG4gICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0xpbmVhci5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdW5kQXdheUZyb21aZXJvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICAvLyBcIk9wcG9zaXRlXCIgb2YgdHJ1bmNhdGUuXHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCkgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kQXdheUZyb21aZXJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICBhbmdsZSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPj0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZUJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciBkeCA9IHgxIC0geDI7XHJcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgbWFrZSBhIHBvd2VyIG9mIHR3byB0ZXh0dXJlLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjaXNQb3dlck9mVHdvXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIGNoZWNrLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIGNoZWNrLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgcG93ZXIgb2YgdHdvLlxyXG4qL1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzU2l6ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKGdsLCBidWZmZXJUeXBlLCB1c2FnZSwgYnVmZmVyRGF0YSwgYnVmZmVyU2l6ZSlcclxue1xyXG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xyXG4gICAgaWYgKGJ1ZmZlckRhdGEgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlckRhdGEpKVxyXG4gICAge1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyRGF0YSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyU2l6ZSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlQnVmZmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5kZXhCdWZmZXIgPSBmdW5jdGlvbiAoYnl0ZVNpemUpXHJcbntcclxuICAgIHRoaXMud29yZExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLndvcmRDYXBhY2l0eSA9IGJ5dGVTaXplIC8gMjtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgIHRoaXMuc2hvcnRWaWV3ID0gbmV3IEludDE2QXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy53b3JkVmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLndvcmRMZW5ndGggPSAwO1xyXG59O1xyXG5cclxuSW5kZXhCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy53b3JkTGVuZ3RoICogMjtcclxufTtcclxuXHJcbkluZGV4QnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiAod29yZFNpemUpXHJcbntcclxuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy53b3JkTGVuZ3RoO1xyXG4gICAgdGhpcy53b3JkTGVuZ3RoICs9IHdvcmRTaXplO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzU2hvcnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5zaG9ydFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzV29yZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLndvcmRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmRleEJ1ZmZlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0luZGV4QnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKGJ5dGVTaXplKVxyXG57XHJcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuZHdvcmRDYXBhY2l0eSA9IGJ5dGVTaXplIC8gNDtcclxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcclxuICAgIHRoaXMuZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLmludFZpZXcgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmR3b3JkTGVuZ3RoICogNDtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkgXHJcbntcclxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIChkd29yZFNpemUpXHJcbntcclxuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy5kd29yZExlbmd0aDtcclxuICAgIHRoaXMuZHdvcmRMZW5ndGggKz0gZHdvcmRTaXplO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XHJcbn07XHJcblxyXG5WZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc0Zsb2F0ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNJbnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5pbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xyXG59O1xyXG5cclxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNVaW50ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMudWludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEJ1ZmZlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL1ZlcnRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXHJcbntcclxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW0uIEVycm9yOiBcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2dyYW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVByb2dyYW07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUpXHJcbntcclxuICAgIHZhciBzaGFkZXIgPSBudWxsO1xyXG4gICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCAnICsgKHNoYWRlclR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6IHNoYWRlclR5cGUgPT09IGdsLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAnaW52YWxpZCcpICsgJyBzaGFkZXIgY29tcGlsYXRpb24uIEVycm9yOiBcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNoYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uIChnbCwgdmFvKVxyXG57XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZhby5idWZmZXIpO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGF0dHJpYiA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGF0dHJpYi5sb2NhdGlvbjtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIGF0dHJpYi5zaXplLFxyXG4gICAgICAgICAgICBhdHRyaWIudHlwZSxcclxuICAgICAgICAgICAgYXR0cmliLm5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgIGF0dHJpYi5zdHJpZGUsXHJcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaW5kVmVydGV4QXJyYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpO1xyXG5cclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSBmdW5jdGlvbiAoZ2wsIHByb2dyYW0sIG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShcclxuICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcclxuICAgICAgICBzaXplLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICBzdHJpZGUsXHJcbiAgICAgICAgb2Zmc2V0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVBdHRyaWJEZXNjO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ2YXIgVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodmJvLCBhdHRyaWJ1dGVzKVxyXG57XHJcbiAgICB0aGlzLmJ1ZmZlciA9IHZibztcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL0dldE9iamVjdFZhbHVlJyk7XHJcblxyXG52YXIgU2V0dGluZ3MgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIGNvbmZpZyA9IHsga2V5OiBjb25maWcgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBQYXNzIHRoZSAnaGFzT3duUHJvcGVydHknIGNoZWNrc1xyXG4gICAgICAgIGNvbmZpZyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTsgLy8gIERvIHdlIGFjdHVhbGx5IG5lZWQgdGhpcyByZWZlcmVuY2U/IFRoaXMgY291bGQganVzdCBiZSBhIHByb3BlcnR5IGJ1Y2tldFxyXG5cclxuICAgIHRoaXMuc3RhdHVzID0gQ09OU1QuUEVORElORztcclxuXHJcbiAgICAvLyAgV2hpY2ggcGFydCBvZiB0aGlzIFN0YXRlIGlzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQ/XHJcbiAgICAvLyAgcHJlbG9hZCwgY3JlYXRlLCB1cGRhdGUsIHNodXRkb3duLCBldGNcclxuICAgIHRoaXMub3AgPSBDT05TVC5CT09UO1xyXG5cclxuICAgIHRoaXMua2V5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAna2V5JywgJycpO1xyXG4gICAgdGhpcy5hY3RpdmUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhY3RpdmUnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnZpc2libGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2aXNpYmxlJywgdHJ1ZSk7XHJcbiAgICB0aGlzLnNjYWxlTW9kZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3NjYWxlTW9kZScsIFNjYWxlTW9kZXMuREVGQVVMVCk7XHJcbiAgICB0aGlzLmZwcyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZwcycsIDYwKTtcclxuICAgIHRoaXMueCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3gnLCAwKTtcclxuICAgIHRoaXMueSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuXHJcbiAgICAvLyAgLTEgbWVhbnMgdGhlIFN0YXRlIE1hbmFnZXIgd2lsbCBzZXQgaXQgdG8gYmUgdGhlIEdhbWUgZGltZW5zaW9uc1xyXG4gICAgdGhpcy53aWR0aCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgLTEpO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdoZWlnaHQnLCAtMSk7XHJcblxyXG4gICAgLy8gIFJlbmRlcmVyIFNldHRpbmdzXHJcblxyXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NsZWFyQmVmb3JlUmVuZGVyJywgdHJ1ZSk7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLmF1dG9SZXNpemUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhdXRvUmVzaXplJywgZmFsc2UpO1xyXG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JvdW5kUGl4ZWxzJywgZmFsc2UpO1xyXG4gICAgdGhpcy5kcmF3VG9QcmltYXJ5Q2FudmFzID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZHJhd1RvUHJpbWFyeUNhbnZhcycsIGZhbHNlKTtcclxuXHJcbn07XHJcblxyXG4vLyAgVW5sZXNzIHdlIGFkZCBzb21lIGFjdHVhbCBmdW5jdGlvbnMgaW4gaGVyZSwgd2UnbGwgbWFrZSB0aGlzIGp1c3QgcmV0dXJuIGFuIE9iamVjdCBpbnN0ZWFkIG9mIGFuIGluc3RhbmNlXHJcblNldHRpbmdzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldHRpbmdzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1NldHRpbmdzLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEdhbWVPYmplY3RGYWN0b3J5ID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5Jyk7XHJcbi8vIHZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9zeXN0ZW1zL0xvYWRlcicpO1xyXG52YXIgTWFpbkxvb3AgPSByZXF1aXJlKCcuL3N5c3RlbXMvTWFpbkxvb3AnKTtcclxudmFyIFVwZGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvVXBkYXRlTWFuYWdlcicpO1xyXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xyXG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vY2FtZXJhL0NhbWVyYScpO1xyXG5cclxudmFyIFN5c3RlbXMgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cclxuICAgIHRoaXMuZXZlbnRzO1xyXG5cclxuICAgIC8vICBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBHYW1lIGxldmVsIFRleHR1cmVNYW5hZ2VyLlxyXG4gICAgdGhpcy50ZXh0dXJlcztcclxuXHJcbiAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXHJcbiAgICB0aGlzLmFkZDtcclxuICAgIHRoaXMubWFrZTtcclxuICAgIHRoaXMuaW5wdXQ7XHJcbiAgICB0aGlzLmxvYWQ7XHJcbiAgICB0aGlzLnR3ZWVucztcclxuICAgIHRoaXMubWFpbmxvb3A7XHJcbiAgICB0aGlzLnVwZGF0ZXM7XHJcblxyXG4gICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcclxuICAgIHRoaXMuY2FtZXJhO1xyXG4gICAgdGhpcy5jaGlsZHJlbjtcclxuICAgIHRoaXMuY29sb3I7XHJcbiAgICB0aGlzLmRhdGE7XHJcbiAgICB0aGlzLmZibztcclxuICAgIHRoaXMudGltZTtcclxuICAgIHRoaXMudHJhbnNmb3JtO1xyXG59O1xyXG5cclxuU3lzdGVtcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeXN0ZW1zO1xyXG5cclxuU3lzdGVtcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU3RhdGUuU3lzdGVtcy5pbml0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLnN0YXRlLmdhbWUudGV4dHVyZXM7XHJcblxyXG4gICAgICAgIC8vICBBbGwgb2YgdGhlIHN5c3RlbXMgY2FuIHVzZSB0aGUgU3RhdGUgbGV2ZWwgRXZlbnREaXNwYXRjaGVyLCBvciB0aGVpciBvd25cclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIG1hbmFnZXJzIChGYWN0b3J5LCBUd2VlbnMsIExvYWRlciwgUGh5c2ljcywgZXRjKVxyXG4gICAgICAgIC8vICBBbGwgdGhlc2UgdG8gYmUgc2V0IGJ5IGEgU3RhdGUgQ29uZmlnIHBhY2thZ2VcclxuXHJcbiAgICAgICAgdGhpcy5hZGQgPSBuZXcgR2FtZU9iamVjdEZhY3RvcnkodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgLy8gdGhpcy5tYWtlID0gR2FtZU9iamVjdENyZWF0b3IodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5tYWlubG9vcCA9IG5ldyBNYWluTG9vcCh0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLnNldHRpbmdzLmZwcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVzID0gbmV3IFVwZGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5sb2FkID0gbmV3IExvYWRlcih0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy50d2VlbnMgPSBuZXcgUGhhc2VyLlR3ZWVuTWFuYWdlcih0aGlzLnN0YXRlKTtcclxuICAgICAgICAvLyB0aGlzLmlucHV0ID0gbmV3IFBoYXNlci5TdGF0ZS5JbnB1dCh0aGlzLnN0YXRlKTtcclxuICAgICAgICAvLyB0aGlzLnBoeXNpY3MgPSBuZXcgUGhhc2VyLlBoeXNpY3MuQXJjYWRlKHRoaXMuc3RhdGUsIDgwMCwgNjAwKTtcclxuXHJcbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEodGhpcy5zdGF0ZSwgMCwgMCwgODAwLCA2MDApO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ29tcG9uZW50LkNoaWxkcmVuKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuY2FtZXJhLnRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgLy8gIEJvb3RcclxuXHJcbiAgICAgICAgLy8gdGhpcy5pbnB1dC5pbml0KCk7XHJcblxyXG4gICAgICAgIC8vICBEZWZhdWx0c1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuYWRkID0gdGhpcy5hZGQ7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5sb2FkID0gdGhpcy5sb2FkO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuY29sb3IgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuc3RhdGUudHJhbnNmb3JtID0gdGhpcy5jYW1lcmEudHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuc3RhdGUudGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIHRoaXMuc3RhdGUuaW5wdXQgPSB0aGlzLmlucHV0O1xyXG4gICAgICAgIC8vIHRoaXMuc3RhdGUuc3RhdGUgPSB0aGlzLnN0YXRlLmdhbWUuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vICBIZXJlIHdlIGNhbiBjaGVjayB3aGljaCBTeXN0ZW1zIHRvIGluc3RhbGwgYXMgcHJvcGVydGllcyBpbnRvIHRoZSBTdGF0ZSBvYmplY3RcclxuICAgICAgICAvLyAgKGRlZmF1bHQgc3lzdGVtcyBhbHdheXMgZXhpc3QgaW4gaGVyZSwgcmVnYXJkbGVzcylcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGZyYW1lRGVsdGEpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwLCBwaHlzaWNzU3RlcClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uIChmcHMsIHBhbmljKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwYW5pYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0dGVybiBpbnRyb2R1Y2VzIG5vbi1kZXRlcm1pbmlzdGljIGJlaGF2aW9yLCBidXQgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgIC8vIGl0J3MgYmV0dGVyIHRoYW4gdGhlIGFsdGVybmF0aXZlICh0aGUgYXBwbGljYXRpb24gd291bGQgbG9vayBsaWtlIGl0XHJcbiAgICAgICAgICAgIC8vIHdhcyBydW5uaW5nIHZlcnkgcXVpY2tseSB1bnRpbCB0aGUgc2ltdWxhdGlvbiBjYXVnaHQgdXAgdG8gcmVhbFxyXG4gICAgICAgICAgICAvLyB0aW1lKS5cclxuICAgICAgICAgICAgdmFyIGRpc2NhcmRlZFRpbWUgPSBNYXRoLnJvdW5kKHRoaXMubWFpbmxvb3AucmVzZXRGcmFtZURlbHRhKCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWluIGxvb3AgcGFuaWNrZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIHdhcyBwdXQgaW4gdGhlIGJhY2tncm91bmQuIERpc2NhcmRpbmcgJyArIGRpc2NhcmRlZFRpbWUgKyAnbXMnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N5c3RlbXMuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N5c3RlbXMuanMiLCJcclxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgTk9PUCAoTm8gT3BlcmF0aW9uKSBDYWxsYmFja1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOT09QO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9OT09QLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDcmVhdGUgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBvZiBudW1iZXJzICh1c3VhbGx5IGludGVnZXJzKSwgYmV0d2VlbiwgYW5kIGluY2x1c2l2ZSBvZixcclxuKiB0aGUgZ2l2ZW4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJndW1lbnRzLiBGb3IgZXhhbXBsZTpcclxuKlxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgyLCA0KTsgLy8gYXJyYXkgPSBbMiwgMywgNF1gXHJcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDAsIDkpOyAvLyBhcnJheSA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XWBcclxuKiBcclxuKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYG51bWJlckFycmF5U3RlcChzdGFydCwgZW5kLCAxKWAuXHJcbiogXHJcbiogWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBwcmVmaXggYW5kIC8gb3Igc3VmZml4IHN0cmluZy4gSWYgZ2l2ZW4gdGhlIGFycmF5IHdpbGwgY29udGFpblxyXG4qIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy4gRm9yIGV4YW1wbGU6XHJcbiogXHJcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDEsIDQsICdMZXZlbCAnKTsgLy8gYXJyYXkgPSBbXCJMZXZlbCAxXCIsIFwiTGV2ZWwgMlwiLCBcIkxldmVsIDNcIiwgXCJMZXZlbCA0XCJdYFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSg1LCA3LCAnSEQtJywgJy5wbmcnKTsgLy8gYXJyYXkgPSBbXCJIRC01LnBuZ1wiLCBcIkhELTYucG5nXCIsIFwiSEQtNy5wbmdcIl1gXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5BcnJheVV0aWxzI251bWJlckFycmF5XHJcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGFycmF5IHN0YXJ0cyB3aXRoLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgYXJyYXkgY29udGFpbnMuXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIC0gT3B0aW9uYWwgcHJlZml4IHRvIHBsYWNlIGJlZm9yZSB0aGUgbnVtYmVyLiBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBjb250YWluIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy5cclxuKiBAcGFyYW0ge3N0cmluZ30gW3N1ZmZpeF0gLSBPcHRpb25hbCBzdWZmaXggdG8gcGxhY2UgYWZ0ZXIgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXHJcbiogQHJldHVybiB7bnVtYmVyW118c3RyaW5nW119IFRoZSBhcnJheSBvZiBudW1iZXIgdmFsdWVzLCBvciBzdHJpbmdzIGlmIGEgcHJlZml4IG9yIHN1ZmZpeCB3YXMgcHJvdmlkZWQuXHJcbiovXHJcbnZhciBOdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmVmaXgsIHN1ZmZpeClcclxue1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSAocHJlZml4KSA/IHByZWZpeCArIGkudG9TdHJpbmcoKSA6IGkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdWZmaXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleS5jb25jYXQoc3VmZml4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJlbW92ZXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIGl0XHJcbi8vICB3aXRob3V0IGNyZWF0aW5nIGdjIChsaWtlIHRoZSBuYXRpdmUgc3BsaWNlIGRvZXMpXHJcbi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1pa2UgUmVpbnN0ZWluXHJcblxyXG52YXIgU3BsaWNlT25lID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleClcclxue1xyXG4gICAgaWYgKGluZGV4ID49IGFycmF5Lmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgdmFyIGl0ZW0gPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGVuOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgYXJyYXkubGVuZ3RoID0gbGVuO1xyXG5cclxuICAgIHJldHVybiBpdGVtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGxpY2VPbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1NwbGljZU9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgalF1ZXJ5LmlzUGxhaW5PYmplY3QuXHJcbiogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdob3NlIGludGVybmFsIGNsYXNzIHByb3BlcnR5IGlzIFtvYmplY3QgT2JqZWN0XS5cclxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5pc1BsYWluT2JqZWN0XHJcbiogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cclxuKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCBpcyBwbGFpbiwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4qL1xyXG52YXIgSXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuICAgIC8vIE5vdCBwbGFpbiBvYmplY3RzOlxyXG4gICAgLy8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxyXG4gICAgLy8gLSBET00gbm9kZXNcclxuICAgIC8vIC0gd2luZG93XHJcbiAgICBpZiAodHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IG9iaiA9PT0gb2JqLndpbmRvdylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8MjBcclxuICAgIC8vIFRoZSB0cnkvY2F0Y2ggc3VwcHJlc3NlcyBleGNlcHRpb25zIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzXHJcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxNDYyMlxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICEoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxyXG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNQbGFpbk9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDb25maWcgPSByZXF1aXJlKCcuL0NvbmZpZycpO1xyXG52YXIgRGVidWdIZWFkZXIgPSByZXF1aXJlKCcuL0RlYnVnSGVhZGVyJyk7XHJcbnZhciBEZXZpY2UgPSByZXF1aXJlKCcuLi9kZXZpY2UnKTtcclxuXHJcbnZhciBBZGRUb0RPTSA9IHJlcXVpcmUoJy4uL2RvbS9BZGRUb0RPTScpO1xyXG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG52YXIgRE9NQ29udGVudExvYWRlZCA9IHJlcXVpcmUoJy4uL2RvbS9ET01Db250ZW50TG9hZGVkJyk7XHJcblxyXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NyZWF0ZVJlbmRlcmVyJyk7XHJcbnZhciBSYW5kb21EYXRhR2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvcicpO1xyXG52YXIgU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vc3RhdGUvU3RhdGVNYW5hZ2VyJyk7XHJcbnZhciBUZXh0dXJlTWFuYWdlciA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyJyk7XHJcblxyXG52YXIgR2FtZSA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyhjb25maWcpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmlzQm9vdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5SZXF1ZXN0QW5pbWF0aW9uRnJhbWV9IHJhZiAtIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyB0aGUgY29yZSBnYW1lIGxvb3AgdmlhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBvciBzZXRUaW1lb3V0XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnJhZiA9IG5ldyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmVNYW5hZ2VyfSB0ZXh0dXJlcyAtIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIFRleHR1cmUgTWFuYWdlci5cclxuICAgICovXHJcbiAgICB0aGlzLnRleHR1cmVzID0gbmV3IFRleHR1cmVNYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5DYWNoZX0gY2FjaGUgLSBSZWZlcmVuY2UgdG8gdGhlIGFzc2V0cyBjYWNoZS5cclxuICAgICovXHJcbiAgICAvLyB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLklucHV0fSBpbnB1dCAtIFJlZmVyZW5jZSB0byB0aGUgaW5wdXQgbWFuYWdlclxyXG4gICAgKi9cclxuICAgIHRoaXMuaW5wdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5TdGF0ZU1hbmFnZXJ9IHN0YXRlIC0gVGhlIFN0YXRlTWFuYWdlci4gUGhhc2VyIGluc3RhbmNlIHNwZWNpZmljLlxyXG4gICAgKi9cclxuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVNYW5hZ2VyKHRoaXMsIHRoaXMuY29uZmlnLnN0YXRlQ29uZmlnKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuRGV2aWNlfSBkZXZpY2UgLSBDb250YWlucyBkZXZpY2UgaW5mb3JtYXRpb24gYW5kIGNhcGFiaWxpdGllcyAoc2luZ2xldG9uKVxyXG4gICAgKi9cclxuICAgIHRoaXMuZGV2aWNlID0gRGV2aWNlO1xyXG5cclxuICAgIC8vICBNb3ZlIHRoaXMgc29tZXdoZXJlIGVsc2U/IE1hdGggcGVyaGFwcz8gRG9lc24ndCBuZWVkIHRvIGJlIGEgR2FtZSBsZXZlbCBzeXN0ZW0uXHJcbiAgICB0aGlzLnJuZDtcclxuXHJcbiAgICAvLyAgV2FpdCBmb3IgdGhlIERPTSBSZWFkeSBldmVudCwgdGhlbiBjYWxsIGJvb3QuXHJcbiAgICBET01Db250ZW50TG9hZGVkKHRoaXMuYm9vdC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAvLyAgRm9yIGRlYnVnZ2luZyBvbmx5XHJcbiAgICB3aW5kb3cuZ2FtZSA9IHRoaXM7XHJcbn07XHJcblxyXG5HYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWU7XHJcblxyXG5HYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBib290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZy5wcmVCb290KCk7XHJcblxyXG4gICAgICAgIC8vICBQcm9iYWJseSBtb3ZlIHdpdGhpbiBNYXRoXHJcbiAgICAgICAgdGhpcy5ybmQgPSBuZXcgUmFuZG9tRGF0YUdlbmVyYXRvcih0aGlzLmNvbmZpZy5zZWVkKTtcclxuXHJcbiAgICAgICAgRGVidWdIZWFkZXIodGhpcyk7XHJcblxyXG4gICAgICAgIENyZWF0ZVJlbmRlcmVyKHRoaXMpO1xyXG5cclxuICAgICAgICBBZGRUb0RPTSh0aGlzLmNhbnZhcywgdGhpcy5jb25maWcucGFyZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ib290KCk7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucG9zdEJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlLnN0ZXAodGltZXN0YW1wKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvR2FtZS5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9HYW1lLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIENvbnRhaW5lckZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnY29udGFpbmVyJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChwYXJlbnQsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7IHBhcmVudCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihDb250YWluZXJGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEltYWdlID0gcmVxdWlyZSgnLi9JbWFnZScpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBJbWFnZUZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnaW1hZ2UnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGUgYSBuZXcgYEltYWdlYCBvYmplY3QuXHJcbiAgICAqXHJcbiAgICAqIEFuIEltYWdlIGlzIGEgbGlnaHQtd2VpZ2h0IG9iamVjdCB5b3UgY2FuIHVzZSB0byBkaXNwbGF5IGFueXRoaW5nIHRoYXQgZG9lc24ndCBuZWVkIHBoeXNpY3Mgb3IgYW5pbWF0aW9uLlxyXG4gICAgKlxyXG4gICAgKiBJdCBjYW4gc3RpbGwgcm90YXRlLCBzY2FsZSwgY3JvcCBhbmQgcmVjZWl2ZSBpbnB1dCBldmVudHMuXHJcbiAgICAqIFRoaXMgbWFrZXMgaXQgcGVyZmVjdCBmb3IgbG9nb3MsIGJhY2tncm91bmRzLCBzaW1wbGUgYnV0dG9ucyBhbmQgb3RoZXIgbm9uLVNwcml0ZSBncmFwaGljcy5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR2FtZU9iamVjdC5GYWN0b3J5I2ltYWdlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xQaGFzZXIuUmVuZGVyVGV4dHVyZXxQaGFzZXIuQml0bWFwRGF0YXxQaGFzZXIuVmlkZW98UElYSS5UZXh0dXJlfSBba2V5XSAtIFRoZSBpbWFnZSB1c2VkIGFzIGEgdGV4dHVyZSBieSB0aGlzIGRpc3BsYXkgb2JqZWN0IGR1cmluZyByZW5kZXJpbmcuIElmIGEgc3RyaW5nIFBoYXNlciB3aWxsIGdldCBmb3IgYW4gZW50cnkgaW4gdGhlIEltYWdlIENhY2hlLiBPciBpdCBjYW4gYmUgYW4gaW5zdGFuY2Ugb2YgYSBSZW5kZXJUZXh0dXJlLCBCaXRtYXBEYXRhLCBWaWRlbyBvciBQSVhJLlRleHR1cmUuXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIGEgVGV4dHVyZSBBdGxhcyBvciBTcHJpdGUgU2hlZXQgaXMgdXNlZCB0aGlzIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZnJhbWUgdG8gYmUgdXNlZC4gVXNlIGVpdGhlciBhbiBpbnRlZ2VyIGZvciBhIEZyYW1lIElEIG9yIGEgc3RyaW5nIGZvciBhIGZyYW1lIG5hbWUuXHJcbiAgICAqIEBwYXJhbSB7UGhhc2VyLkdyb3VwfSBbZ3JvdXBdIC0gT3B0aW9uYWwgR3JvdXAgdG8gYWRkIHRoZSBvYmplY3QgdG8uIElmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgV29ybGQgZ3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5JbWFnZX0gVGhlIG5ld2x5IGNyZWF0ZWQgSW1hZ2Ugb2JqZWN0LlxyXG4gICAgKi9cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUsIGdyb3VwKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkKSB7IGdyb3VwID0gdGhpcy5zdGF0ZTsgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnSW1hZ2VGYWN0b3J5LmFkZCcsIGtleSwgeCwgeSwgZnJhbWUsIGdyb3VwKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50byBTdGF0ZScsIHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXAuY2hpbGRyZW4uYWRkKG5ldyBJbWFnZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkubWFrZScsIGtleSwgeCwgeSwgZnJhbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihJbWFnZUZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeS5qcyIsIi8vICBQaGFzZXIuR2VvbVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcclxuICAgIENpcmNsZTogcmVxdWlyZSgnLi9jaXJjbGUnKSxcclxuICAgIEVsbGlwc2U6IHJlcXVpcmUoJy4vZWxsaXBzZScpLFxyXG4gICAgSGVybWl0ZTogcmVxdWlyZSgnLi9oZXJtaXRlJyksXHJcbiAgICBJbnRlcnNlY3RzOiByZXF1aXJlKCcuL2ludGVyc2VjdHMnKSxcclxuICAgIExpbmU6IHJlcXVpcmUoJy4vbGluZScpLFxyXG4gICAgUG9pbnQ6IHJlcXVpcmUoJy4vcG9pbnQnKSxcclxuICAgIFBvbHlnb246IHJlcXVpcmUoJy4vcG9seWdvbicpLFxyXG4gICAgUmVjdGFuZ2xlOiByZXF1aXJlKCcuL3JlY3RhbmdsZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLy8gIENPTlNUcyAobWFrZXMgdGhlbSB2aXNpYmxlIHVuZGVyIFBoYXNlci5NYXRoKVxyXG4gICAgUEkyOiBNYXRoLlBJICogMixcclxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcclxuICAgIEVQU0lMT046IDEuMGUtNixcclxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXHJcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cclxuICAgIC8vICBDb2xsZWN0aW9ucyBvZiBmdW5jdGlvbnNcclxuICAgIEFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlLycpLFxyXG4gICAgRGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UvJyksXHJcbiAgICBFYXNpbmc6IHJlcXVpcmUoJy4vZWFzaW5nLycpLFxyXG4gICAgRnV6enk6IHJlcXVpcmUoJy4vZnV6enkvJyksXHJcbiAgICBJbnRlcnBvbGF0aW9uOiByZXF1aXJlKCcuL2ludGVycG9sYXRpb24vJyksXHJcbiAgICBQb3cyOiByZXF1aXJlKCcuL3BvdzIvJyksXHJcbiAgICBTbmFwOiByZXF1aXJlKCcuL3NuYXAvJyksXHJcblxyXG4gICAgLy8gIFNpbmdsZSBmdW5jdGlvbnNcclxuICAgIEF2ZXJhZ2U6IHJlcXVpcmUoJy4vQXZlcmFnZScpLFxyXG4gICAgQmVybnN0ZWluOiByZXF1aXJlKCcuL0Jlcm5zdGVpbicpLFxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXHJcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb20nKSxcclxuICAgIENlaWxUbzogcmVxdWlyZSgnLi9DZWlsVG8nKSxcclxuICAgIENsYW1wOiByZXF1aXJlKCcuL0NsYW1wJyksXHJcbiAgICBEZWdUb1JhZDogcmVxdWlyZSgnLi9EZWdUb1JhZCcpLFxyXG4gICAgRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9EaWZmZXJlbmNlJyksXHJcbiAgICBGYWN0b3JpYWw6IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyksXHJcbiAgICBGbG9hdEJldHdlZW46IHJlcXVpcmUoJy4vRmxvYXRCZXR3ZWVuJyksXHJcbiAgICBGbG9vclRvOiByZXF1aXJlKCcuL0Zsb29yVG8nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcclxuICAgIE1heEFkZDogcmVxdWlyZSgnLi9NYXhBZGQnKSxcclxuICAgIE1pblN1YjogcmVxdWlyZSgnLi9NaW5TdWInKSxcclxuICAgIFBlcmNlbnQ6IHJlcXVpcmUoJy4vUGVyY2VudCcpLFxyXG4gICAgUmFkVG9EZWc6IHJlcXVpcmUoJy4vUmFkVG9EZWcnKSxcclxuICAgIFJvdGF0ZTogcmVxdWlyZSgnLi9Sb3RhdGUnKSxcclxuICAgIFJvdGF0ZUFyb3VuZDogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmQnKSxcclxuICAgIFJvdGF0ZUFyb3VuZERpc3RhbmNlOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZERpc3RhbmNlJyksXHJcbiAgICBSb3VuZEF3YXlGcm9tWmVybzogcmVxdWlyZSgnLi9Sb3VuZEF3YXlGcm9tWmVybycpLFxyXG4gICAgUm91bmRUbzogcmVxdWlyZSgnLi9Sb3VuZFRvJyksXHJcbiAgICBTaW5Db3NUYWJsZUdlbmVyYXRvcjogcmVxdWlyZSgnLi9TaW5Db3NUYWJsZUdlbmVyYXRvcicpLFxyXG4gICAgU21vb3RoZXJTdGVwOiByZXF1aXJlKCcuL1Ntb290aGVyU3RlcCcpLFxyXG4gICAgU21vb3RoU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhTdGVwJyksXHJcbiAgICBXaXRoaW46IHJlcXVpcmUoJy4vV2l0aGluJyksXHJcbiAgICBXcmFwOiByZXF1aXJlKCcuL1dyYXAnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbmRleC5qcyIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BvbHlmaWxscy9pbmRleC5qcyIsInJlcXVpcmUoJy4vQXJyYXkuZm9yRWFjaCcpO1xyXG5yZXF1aXJlKCcuL0FycmF5LmlzQXJyYXknKTtcclxucmVxdWlyZSgnLi9BdWRpb0NvbnRleHRNb25rZXlQYXRjaCcpO1xyXG5yZXF1aXJlKCcuL2NvbnNvbGUnKTtcclxucmVxdWlyZSgnLi9GdW5jdGlvbi5iaW5kJyk7XHJcbnJlcXVpcmUoJy4vTWF0aC50cnVuYycpO1xyXG5yZXF1aXJlKCcuL3BlcmZvcm1hbmNlLm5vdycpO1xyXG5yZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG5yZXF1aXJlKCcuL1VpbnQzMkFycmF5Jyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5Tb3VuZFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRHluYW1pYzogcmVxdWlyZSgnLi9keW5hbWljJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NvdW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zb3VuZC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEZpbmRDbG9zZXN0SW5Tb3J0ZWQ6IHJlcXVpcmUoJy4vRmluZENsb3Nlc3RJblNvcnRlZCcpLFxyXG4gICAgR2V0UmFuZG9tRWxlbWVudDogcmVxdWlyZSgnLi9HZXRSYW5kb21FbGVtZW50JyksXHJcbiAgICBOdW1iZXJBcnJheTogcmVxdWlyZSgnLi9OdW1iZXJBcnJheScpLFxyXG4gICAgTnVtYmVyQXJyYXlTdGVwOiByZXF1aXJlKCcuL051bWJlckFycmF5U3RlcCcpLFxyXG4gICAgUmVtb3ZlUmFuZG9tRWxlbWVudDogcmVxdWlyZSgnLi9SZW1vdmVSYW5kb21FbGVtZW50JyksXHJcbiAgICBSb3RhdGVMZWZ0OiByZXF1aXJlKCcuL1JvdGF0ZUxlZnQnKSxcclxuICAgIFJvdGF0ZVJpZ2h0OiByZXF1aXJlKCcuL1JvdGF0ZVJpZ2h0JyksXHJcbiAgICBTaHVmZmxlOiByZXF1aXJlKCcuL1NodWZmbGUnKSxcclxuICAgIFNwbGljZU9uZTogcmVxdWlyZSgnLi9TcGxpY2VPbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRXh0ZW5kOiByZXF1aXJlKCcuL0V4dGVuZCcpLFxyXG4gICAgSXNQbGFpbk9iamVjdDogcmVxdWlyZSgnLi9Jc1BsYWluT2JqZWN0JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL29iamVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvb2JqZWN0L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUubDsgfVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZS5pOyB9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL0dldE9iamVjdFZhbHVlJyk7XHJcblxyXG52YXIgZGVmYXVsdEJhbm5lckNvbG9yID0gW1xyXG4gICAgJyNmZjAwMDAnLFxyXG4gICAgJyNmZmZmMDAnLFxyXG4gICAgJyMwMGZmMDAnLFxyXG4gICAgJyMwMGZmZmYnLFxyXG4gICAgJyMwMDAwMDAnXHJcbl07XHJcblxyXG52YXIgZGVmYXVsdEJhbm5lclRleHRDb2xvciA9ICcjZmZmZmZmJztcclxuXHJcbnZhciBDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHsgY29uZmlnID0ge307IH1cclxuXHJcbiAgICB0aGlzLndpZHRoID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2lkdGgnLCAxMDI0KTtcclxuICAgIHRoaXMuaGVpZ2h0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnaGVpZ2h0JywgNzY4KTtcclxuXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXNvbHV0aW9uJywgMSk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJUeXBlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHlwZScsIENPTlNULkFVVE8pO1xyXG5cclxuICAgIHRoaXMucGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGFyZW50JywgbnVsbCk7XHJcbiAgICB0aGlzLmNhbnZhcyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NhbnZhcycsIG51bGwpO1xyXG4gICAgdGhpcy5jYW52YXNTdHlsZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NhbnZhc1N0eWxlJywgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZUNvbmZpZyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3N0YXRlJywgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5zZWVkID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc2VlZCcsIFsgKERhdGUubm93KCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpIF0pO1xyXG5cclxuICAgIHRoaXMuZ2FtZVRpdGxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndGl0bGUnLCAnJyk7XHJcbiAgICB0aGlzLmdhbWVVUkwgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd1cmwnLCAnaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgdGhpcy5nYW1lVmVyc2lvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ZlcnNpb24nLCAnJyk7XHJcblxyXG4gICAgLy8gIElmIHlvdSBkbzogeyBiYW5uZXI6IGZhbHNlIH0gaXQgd29uJ3QgZGlzcGxheSBhbnkgYmFubmVyIGF0IGFsbFxyXG4gICAgdGhpcy5oaWRlQmFubmVyID0gKEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lcicsIG51bGwpID09PSBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5oaWRlUGhhc2VyID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYmFubmVyLmhpZGVQaGFzZXInLCBmYWxzZSk7XHJcbiAgICB0aGlzLmJhbm5lclRleHRDb2xvciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci50ZXh0JywgZGVmYXVsdEJhbm5lclRleHRDb2xvcik7XHJcbiAgICB0aGlzLmJhbm5lckJhY2tncm91bmRDb2xvciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5iYWNrZ3JvdW5kJywgZGVmYXVsdEJhbm5lckNvbG9yKTtcclxuICAgXHJcbiAgICB0aGlzLmZvcmNlU2V0VGltZU91dCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZvcmNlU2V0VGltZU91dCcsIGZhbHNlKTtcclxuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0cmFuc3BhcmVudCcsIGZhbHNlKTtcclxuICAgIHRoaXMucGl4ZWxBcnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdwaXhlbEFydCcsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgQ2FsbGJhY2tzXHJcbiAgICB0aGlzLnByZUJvb3QgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYWxsYmFja3MucHJlQm9vdCcsIE5PT1ApO1xyXG4gICAgdGhpcy5wb3N0Qm9vdCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NhbGxiYWNrcy5wb3N0Qm9vdCcsIE5PT1ApO1xyXG59O1xyXG5cclxuQ29uZmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmZpZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29uZmlnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9Db25maWcuanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2RldmljZS9GZWF0dXJlcycpO1xyXG52YXIgQ2FudmFzUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcclxudmFyIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XHJcblxyXG4vKipcclxuKiBDaGVja3MgaWYgdGhlIGRldmljZSBpcyBjYXBhYmxlIG9mIHVzaW5nIHRoZSByZXF1ZXN0ZWQgcmVuZGVyZXIgYW5kIHNldHMgaXQgdXAgb3IgYW4gYWx0ZXJuYXRpdmUgaWYgbm90LlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuR2FtZSNzZXRVcFJlbmRlcmVyXHJcbiogQHByb3RlY3RlZFxyXG4qL1xyXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IGdhbWUuY29uZmlnO1xyXG5cclxuICAgIC8vICBHYW1lIGVpdGhlciByZXF1ZXN0ZWQgQ2FudmFzLFxyXG4gICAgLy8gIG9yIHJlcXVlc3RlZCBBVVRPIG9yIFdFQkdMIGJ1dCB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXQsIHNvIGZhbGwgYmFjayB0byBDYW52YXNcclxuICAgIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTIHx8IChjb25maWcucmVuZGVyVHlwZSAhPT0gQ09OU1QuQ0FOVkFTICYmICFGZWF0dXJlcy53ZWJHTCkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEZlYXR1cmVzLmNhbnZhcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGV5IHJlcXVlc3RlZCBDYW52YXMgYW5kIHRoZWlyIGJyb3dzZXIgc3VwcG9ydHMgaXRcclxuICAgICAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5DQU5WQVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBDYW52YXMgb3IgV2ViR0wgY29udGV4dCwgYWJvcnRpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBHYW1lIHJlcXVlc3RlZCBXZWJHTCBhbmQgYnJvd3NlciBzYXlzIGl0IHN1cHBvcnRzIGl0XHJcbiAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5XRUJHTDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBpdHMgb3duIGNhbnZhcyBlbGVtZW50IHRvIHVzZT9cclxuICAgIGlmIChjb25maWcuY2FudmFzKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUuY2FudmFzID0gY29uZmlnLmNhbnZhcztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKGdhbWUsIGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCwgY29uZmlnLnJlbmRlclR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBEb2VzIHRoZSBnYW1lIGNvbmZpZyBwcm92aWRlIHNvbWUgY2FudmFzIGNzcyBzdHlsZXMgdG8gdXNlP1xyXG4gICAgaWYgKGNvbmZpZy5jYW52YXNTdHlsZSlcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcy5zdHlsZSA9IGNvbmZpZy5jYW52YXNTdHlsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIHRoZSByZW5kZXJlclxyXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgV0VCR0wgUmVuZGVyZXInKTtcclxuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgQ2FudmFzIFJlbmRlcmVyJyk7XHJcbiAgICAgICAgZ2FtZS5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcihnYW1lKTtcclxuICAgICAgICBnYW1lLmNvbnRleHQgPSBnYW1lLnJlbmRlcmVyLmNvbnRleHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIENIRUNLU1VNID0gcmVxdWlyZSgnLi4vY2hlY2tzdW0nKTtcclxuXHJcbnZhciBEZWJ1Z0hlYWRlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB2YXIgY29uZmlnID0gZ2FtZS5jb25maWc7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5oaWRlQmFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVuZGVyVHlwZSA9IChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTKSA/ICdDYW52YXMnIDogJ1dlYkdMJztcclxuXHJcbiAgICB2YXIgaWUgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIWllKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjID0gJyc7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbY107XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RDb2xvcjtcclxuXHJcbiAgICAgICAgICAgIGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IuZm9yRWFjaChmdW5jdGlvbihjb2xvcikge1xyXG5cclxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnJWMgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdiYWNrZ3JvdW5kOiAnICsgY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RDb2xvciA9IGNvbG9yO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyAgaW5qZWN0IHRoZSB0ZXh0IGNvbG9yXHJcbiAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9ICdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgbGFzdENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjID0gYy5jb25jYXQoJyVjICcpO1xyXG5cclxuICAgICAgICAgICAgYXJncy5wdXNoKCdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgVVJMIGxpbmsgYmFja2dyb3VuZCBjb2xvciAoYWx3YXlzIHdoaXRlKVxyXG4gICAgICAgIGFyZ3MucHVzaCgnYmFja2dyb3VuZDogI2ZmZicpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmdhbWVUaXRsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdChjb25maWcuZ2FtZVRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuZ2FtZVZlcnNpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnIHYnICsgY29uZmlnLmdhbWVWZXJzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCcgLyAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnUGhhc2VyIHYnICsgQ09OU1QuVkVSU0lPTiArICcgKCcgKyByZW5kZXJUeXBlICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMgPSBjLmNvbmNhdCgnICVjICcgKyBjb25maWcuZ2FtZVVSTCk7XHJcblxyXG4gICAgICAgIC8vICBJbmplY3QgdGhlIG5ldyBzdHJpbmcgYmFjayBpbnRvIHRoZSBhcmdzIGFycmF5XHJcbiAgICAgICAgYXJnc1swXSA9IGM7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2luZG93Wydjb25zb2xlJ10pXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1BoYXNlciB2JyArIENPTlNULlZFUlNJT04gKyAnIC8gaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEtlZXAgdGhpcyBkdXJpbmcgZGV2IGJ1aWxkIG9ubHlcclxuICAgIGNvbnNvbGUubG9nKENIRUNLU1VNLmJ1aWxkKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnSGVhZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0RlYnVnSGVhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0RlYnVnSGVhZGVyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwQW5nbGUgPSByZXF1aXJlKCcuLi9tYXRoL2FuZ2xlL1dyYXAnKTtcclxuXHJcbi8qKlxyXG4qIEEgQ2FtZXJhIGlzIHlvdXIgdmlldyBpbnRvIHRoZSBnYW1lIHdvcmxkLiBJdCBoYXMgYSBwb3NpdGlvbiBhbmQgc2l6ZSBhbmQgcmVuZGVycyBvbmx5IHRob3NlIG9iamVjdHMgd2l0aGluIGl0cyBmaWVsZCBvZiB2aWV3LlxyXG4qIFRoZSBnYW1lIGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBhIHNpbmdsZSBTdGFnZSBzaXplZCBjYW1lcmEgb24gYm9vdC4gTW92ZSB0aGUgY2FtZXJhIGFyb3VuZCB0aGUgd29ybGQgd2l0aCBQaGFzZXIuQ2FtZXJhLngveVxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5DYW1lcmFcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gR2FtZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGlkIC0gTm90IGJlaW5nIHVzZWQgYXQgdGhlIG1vbWVudCwgd2lsbCBiZSB3aGVuIFBoYXNlciBzdXBwb3J0cyBtdWx0aXBsZSBjYW1lcmFcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFBvc2l0aW9uIG9mIHRoZSBjYW1lcmEgb24gdGhlIFggYXhpc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gb2YgdGhlIGNhbWVyYSBvbiB0aGUgWSBheGlzXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB2aWV3IHJlY3RhbmdsZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB2aWV3IHJlY3RhbmdsZVxyXG4qL1xyXG52YXIgQ2FtZXJhID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodClcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgU3RhdGUgdGhhdCB0aGlzIENhbWVyYSBiZWxvbmdzIHRvLiBBIENhbWVyYSBjYW4gb25seSBiZWxvbmcgdG8gb25lIFN0YXRlLCBhbmQgYSBTdGF0ZSBvbmx5XHJcbiAgICAgKiBoYXMgb25lIENhbWVyYS5cclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuU3RhdGV9IHN0YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nYW1lID0gc3RhdGUuZ2FtZTtcclxuXHJcbiAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoO1xyXG5cclxuICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBDb21wb25lbnQuVHJhbnNmb3JtKHRoaXMsIHgsIHkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQ2FtZXJhIGlzIGJvdW5kIHRvIHRoaXMgUmVjdGFuZ2xlIGFuZCBjYW5ub3QgbW92ZSBvdXRzaWRlIG9mIGl0LiBCeSBkZWZhdWx0IGl0IGlzIGVuYWJsZWQgYW5kIHNldCB0byB0aGUgc2l6ZSBvZiB0aGUgV29ybGQuXHJcbiAgICAqIFRoZSBSZWN0YW5nbGUgY2FuIGJlIGxvY2F0ZWQgYW55d2hlcmUgaW4gdGhlIHdvcmxkIGFuZCB1cGRhdGVkIGFzIG9mdGVuIGFzIHlvdSBsaWtlLiBJZiB5b3UgZG9uJ3Qgd2lzaCB0aGUgQ2FtZXJhIHRvIGJlIGJvdW5kXHJcbiAgICAqIGF0IGFsbCB0aGVuIHNldCB0aGlzIHRvIG51bGwuIFRoZSB2YWx1ZXMgY2FuIGJlIGFueXRoaW5nIGFuZCBhcmUgaW4gV29ybGQgY29vcmRpbmF0ZXMsIHdpdGggMCwwIGJlaW5nIHRoZSB0b3AtbGVmdCBvZiB0aGUgd29ybGQuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlJlY3RhbmdsZX0gYm91bmRzIC0gVGhlIFJlY3RhbmdsZSBpbiB3aGljaCB0aGUgQ2FtZXJhIGlzIGJvdW5kZWQuIFNldCB0byBudWxsIHRvIGFsbG93IGZvciBtb3ZlbWVudCBhbnl3aGVyZS5cclxuICAgICovXHJcbiAgICAvLyB0aGlzLmJvdW5kcyA9IG5ldyBQaGFzZXIuUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIC8vIHRoaXMuYm91bmRzID0gbmV3IFBoYXNlci5DaXJjbGUoeCwgeSlcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdExpbWl0IC0gV2hldGhlciB0aGlzIGNhbWVyYSBpcyBmbHVzaCB3aXRoIHRoZSBXb3JsZCBCb3VuZHMgb3Igbm90LlxyXG4gICAgKi9cclxuICAgIHRoaXMuYXRMaW1pdCA9IHsgeDogZmFsc2UsIHk6IGZhbHNlIH07XHJcbn07XHJcblxyXG5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FtZXJhO1xyXG5cclxuQ2FtZXJhLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogTWV0aG9kIGNhbGxlZCB0byBlbnN1cmUgdGhlIGNhbWVyYSBkb2Vzbid0IHZlbnR1cmUgb3V0c2lkZSBvZiB0aGUgZ2FtZSB3b3JsZC5cclxuICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQ2FtZXJhLnVwZGF0ZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FtZXJhI2NoZWNrQm91bmRzXHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICBjaGVja0JvdW5kczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmF0TGltaXQueCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXRMaW1pdC55ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIHZhciB2eCA9IHRoaXMudmlldy54ICsgdGhpcy5fc2hha2UueDtcclxuICAgICAgICAvLyB2YXIgdncgPSB0aGlzLnZpZXcucmlnaHQgKyB0aGlzLl9zaGFrZS54O1xyXG4gICAgICAgIC8vIHZhciB2eSA9IHRoaXMudmlldy55ICsgdGhpcy5fc2hha2UueTtcclxuICAgICAgICAvLyB2YXIgdmggPSB0aGlzLnZpZXcuYm90dG9tICsgdGhpcy5fc2hha2UueTtcclxuXHJcbiAgICAgICAgdmFyIHZ4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB2dyA9IHRoaXMueCArIHRoaXMudmlld3BvcnRXaWR0aDtcclxuICAgICAgICB2YXIgdnkgPSB0aGlzLnk7XHJcbiAgICAgICAgdmFyIHZoID0gdGhpcy55ICsgdGhpcy52aWV3cG9ydEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgZ28gb3V0c2lkZSB0aGUgY2FtZXJhcyBib3VuZHNcclxuICAgICAgICBpZiAodnggPD0gdGhpcy5ib3VuZHMueCAqIHRoaXMuc2NhbGUueClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYXRMaW1pdC54ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnggPSB0aGlzLmJvdW5kcy54ICogdGhpcy5zY2FsZS54O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBjYW1lcmEgaXMgdXAgYWdhaW5zdCB0aGUgYm91bmRzLCBzbyByZXNldCB0aGUgc2hha2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodncgPj0gdGhpcy5ib3VuZHMucmlnaHQgKiB0aGlzLnNjYWxlLngpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmF0TGltaXQueCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy54ID0gKHRoaXMuYm91bmRzLnJpZ2h0ICogdGhpcy5zY2FsZS54KSAtIHRoaXMud2lkdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWtlLnNoYWtlQm91bmRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGNhbWVyYSBpcyB1cCBhZ2FpbnN0IHRoZSBib3VuZHMsIHNvIHJlc2V0IHRoZSBzaGFrZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2UueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2eSA8PSB0aGlzLmJvdW5kcy50b3AgKiB0aGlzLnNjYWxlLnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmF0TGltaXQueSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy55ID0gdGhpcy5ib3VuZHMudG9wICogdGhpcy5zY2FsZS55O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBjYW1lcmEgaXMgdXAgYWdhaW5zdCB0aGUgYm91bmRzLCBzbyByZXNldCB0aGUgc2hha2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmggPj0gdGhpcy5ib3VuZHMuYm90dG9tICogdGhpcy5zY2FsZS55KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hdExpbWl0LnkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcueSA9ICh0aGlzLmJvdW5kcy5ib3R0b20gKiB0aGlzLnNjYWxlLnkpIC0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWtlLnNoYWtlQm91bmRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGNhbWVyYSBpcyB1cCBhZ2FpbnN0IHRoZSBib3VuZHMsIHNvIHJlc2V0IHRoZSBzaGFrZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2UueSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhbWVyYS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvLyAgVHJhbnNmb3JtIGdldHRlcnMgLyBzZXR0ZXJzXHJcblxyXG4gICAgeDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcG9zWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1k7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcG9zWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9wb3NYICsgKHRoaXMudmlld3BvcnRXaWR0aCAqIHRoaXMudHJhbnNmb3JtLl9zY2FsZVgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1kgKyAodGhpcy52aWV3cG9ydEhlaWdodCAqIHRoaXMudHJhbnNmb3JtLl9zY2FsZVkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3NjYWxlWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGl2b3RYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGl2b3RZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmdsZToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKiBNQVRIX0NPTlNULlJBRF9UT19ERUcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IFdyYXBBbmdsZSh2YWx1ZSkgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcm90YXRpb246IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uICUgTUFUSF9DT05TVC5QSTIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmNhY2hlLnNyID0gTWF0aC5zaW4odGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmNhY2hlLmNyID0gTWF0aC5jb3ModGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5oYXNMb2NhbFJvdGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmhhc0xvY2FsUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FtZXJhL0NhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2FtZXJhL0NhbWVyYS5qcyIsInZhciBDSEVDS1NVTSA9IHtcclxuYnVpbGQ6ICc4ZTkyNjc5MC1kZTlkLTExZTYtYmFiNi1iMWNkODgzYzE2MDAnXHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gQ0hFQ0tTVU07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2hlY2tzdW0uanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBDb2xvciBDb21wb25lbnQgYWxsb3dzIHlvdSB0byBjb250cm9sIHRoZSBhbHBoYSwgYmxlbmQgbW9kZSwgdGludCBhbmQgYmFja2dyb3VuZCBjb2xvclxyXG4qIG9mIGEgR2FtZSBPYmplY3QuXHJcbipcclxuKiBAY2xhc3NcclxuKi9cclxudmFyIENvbG9yID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IGdhbWVPYmplY3Quc3RhdGU7XHJcblxyXG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9hbHBoYSA9IDE7XHJcbiAgICB0aGlzLl93b3JsZEFscGhhID0gMTtcclxuXHJcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSAwO1xyXG5cclxuICAgIHRoaXMuX3RpbnQgPSB7IHRvcExlZnQ6IDB4ZmZmZmZmLCB0b3BSaWdodDogMHhmZmZmZmYsIGJvdHRvbUxlZnQ6IDB4ZmZmZmZmLCBib3R0b21SaWdodDogMHhmZmZmZmYgfTtcclxuICAgIHRoaXMuX2dsVGludCA9IHsgdG9wTGVmdDogMTY3NzcyMTUsIHRvcFJpZ2h0OiAxNjc3NzIxNSwgYm90dG9tTGVmdDogMTY3NzcyMTUsIGJvdHRvbVJpZ2h0OiAxNjc3NzIxNSB9O1xyXG4gICAgdGhpcy5faGFzVGludCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDI1NVxyXG4gICAgdGhpcy5fciA9IDA7XHJcbiAgICB0aGlzLl9nID0gMDtcclxuICAgIHRoaXMuX2IgPSAwO1xyXG5cclxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDFcclxuICAgIHRoaXMuX2EgPSAxO1xyXG5cclxuICAgIC8vICBTdHJpbmcgdmVyc2lvbiBvZiBSR0JBXHJcbiAgICB0aGlzLl9yZ2JhID0gJyc7XHJcblxyXG4gICAgLy8gIDMyLWJpdCB2ZXJzaW9uIG9mIEFSR0JcclxuICAgIHRoaXMuX2dsQmcgPSAwO1xyXG5cclxuICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSBmYWxzZTtcclxufTtcclxuXHJcbkNvbG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yO1xyXG5cclxuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldEJhY2tncm91bmQ6IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fciA9IHJlZDtcclxuICAgICAgICAgICAgdGhpcy5fZyA9IChncmVlbikgPyBncmVlbiA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2IgPSAoYmx1ZSkgPyBibHVlIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fYSA9IChhbHBoYSkgPyBhbHBoYSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJUaW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VGludCgweGZmZmZmZik7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhc1RpbnQgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGludDogZnVuY3Rpb24gKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAodG9wUmlnaHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gdG9wTGVmdDtcclxuICAgICAgICAgICAgYm90dG9tTGVmdCA9IHRvcExlZnQ7XHJcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gdG9wTGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGludFRvcExlZnQgPSB0b3BMZWZ0O1xyXG4gICAgICAgIHRoaXMudGludFRvcFJpZ2h0ID0gdG9wUmlnaHQ7XHJcbiAgICAgICAgdGhpcy50aW50Qm90dG9tTGVmdCA9IGJvdHRvbUxlZnQ7XHJcbiAgICAgICAgdGhpcy50aW50Qm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5faGFzVGludCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBEaXJ0eSBNYW5hZ2VyXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc0JhY2tncm91bmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9yZ2JhID0gJ3JnYmEoJyArIHRoaXMuX3IgKyAnLCcgKyB0aGlzLl9nICsgJywnICsgdGhpcy5fYiArICcsJyArIHRoaXMuX2EgKyAnKSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSB0aGlzLmdldENvbG9yMzIodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgVGludCBtdWx0cz9cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbG9yOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29sb3IzMjogZnVuY3Rpb24gKHIsIGcsIGIsIGEpXHJcbiAgICB7XHJcbiAgICAgICAgYSAqPSAyNTU7XHJcblxyXG4gICAgICAgIHJldHVybiAoKGEgPDwgMjQpIHwgKGIgPDwgMTYpIHwgKGcgPDwgOCkgfCByKSA+Pj4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RpbnQgPSBbXTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBkaXJ0eToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlydHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLmFkZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50VG9wTGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BMZWZ0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC50b3BMZWZ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC50b3BMZWZ0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRUb3BSaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BSaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnQudG9wUmlnaHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LnRvcFJpZ2h0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRCb3R0b21MZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbUxlZnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl90aW50LmJvdHRvbUxlZnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LmJvdHRvbUxlZnQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludEJvdHRvbVJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC5ib3R0b21SaWdodCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQuYm90dG9tUmlnaHQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGludCh2YWx1ZSwgdmFsdWUsIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hbHBoYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmxlbmRNb2RlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2JsZW5kTW9kZSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd29ybGRBbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lT2JqZWN0LnBhcmVudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRBbHBoYSA9IHRoaXMuX2FscGhhICogdGhpcy5nYW1lT2JqZWN0LnBhcmVudC5jb2xvci53b3JsZEFscGhhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRBbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkQWxwaGEgPSB0aGlzLl9hbHBoYSAqIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJhY2tncm91bmRBbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlZDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fciA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZyA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBibHVlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9iKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iID0gdmFsdWUgfCAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBEYXRhIENvbXBvbmVudCBmZWF0dXJlcyBhIG1lYW5zIHRvIHN0b3JlIHBpZWNlcyBvZiBkYXRhIHNwZWNpZmljIHRvIGEgR2FtZSBPYmplY3QsXHJcbiogc2VhcmNoIGl0LCBxdWVyeSBpdCwgYW5kIHJldHJpZXZlIGl0LlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBEYXRhID0gZnVuY3Rpb24gKHBhcmVudClcclxue1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgdGhpcy5saXN0ID0ge307XHJcblxyXG4gICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzID0ge307XHJcbiAgICB0aGlzLl9hZnRlckNhbGxiYWNrcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG59O1xyXG5cclxuRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhO1xyXG5cclxuRGF0YS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy8gIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBxdWVyeTogZnVuY3Rpb24gKHNlYXJjaClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGtleS5tYXRjaChzZWFyY2gpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZnJvemVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXI7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gIElmIHRoZXJlIGlzIGEgJ2JlZm9yZScgY2FsbGJhY2ssIHRoZW4gY2hlY2sgaXQgZm9yIGEgcmVzdWx0XHJcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwobGlzdGVuZXIuc2NvcGUsIHRoaXMucGFyZW50LCBrZXksIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGVyZSBpcyBhICdhZnRlcicgY2FsbGJhY2ssIHRoZW4gY2hlY2sgaXQgZm9yIGEgcmVzdWx0XHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZW1vdmUgZW50cnlcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHNjb3BlOiBzY29wZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBhc3NlcyBhbGwgZGF0YSBlbnRyaWVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay4gU3RvcmVzIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGVhY2hcclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICogQHBhcmFtIHtvYmplY3R9IFtzY29wZV0gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBnYW1lIG9iamVjdCwga2V5LCBhbmQgZGF0YS5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyB0aGlzLnBhcmVudCwgbnVsbCwgdW5kZWZpbmVkIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1sxXSA9IGtleTtcclxuICAgICAgICAgICAgYXJnc1syXSA9IHRoaXMubGlzdFtrZXldO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIChkYXRhLCBvdmVyd3JpdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJ3cml0ZSA9IHRydWU7IH1cclxuXHJcbiAgICAgICAgLy8gIE1lcmdlIGRhdGEgZnJvbSBhbm90aGVyIGNvbXBvbmVudCBpbnRvIHRoaXMgb25lXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlIHx8ICghb3ZlcndyaXRlICYmICF0aGlzLmhhcyhrZXkpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gJ2tleScsIGRlbGV0ZXMgaXQgZnJvbSB0aGlzIERhdGEgc3RvcmUsIHRoZW4gcmV0dXJucyBpdC5cclxuICAgIHBvcDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2JlZm9yZUNhbGxiYWNrcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2FmdGVyQ2FsbGJhY2tzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEYXRhLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGcmVlemUgdGhpcyBEYXRhIGNvbXBvbmVudCwgc28gbm8gY2hhbmdlcyBjYW4gYmUgd3JpdHRlbiB0byBpdC5cclxuICAgICpcclxuICAgICogQG5hbWUgZnJlZXplXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZnJlZXplXHJcbiAgICAqL1xyXG4gICAgZnJlZXplOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm96ZW47XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9mcm96ZW4gPSAodmFsdWUpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvdW50OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgV3JhcEFuZ2xlID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwJyk7XHJcblxyXG4vKipcclxuKiAyRCBUcmFuc2Zvcm1hdGlvbiBDb21wb25lbnQuXHJcbipcclxuKiBAY2xhc3NcclxuKi9cclxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5LCBzY2FsZVgsIHNjYWxlWSlcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHNjYWxlWCA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlWCA9IDE7IH1cclxuICAgIGlmIChzY2FsZVkgPT09IHVuZGVmaW5lZCkgeyBzY2FsZVkgPSAxOyB9XHJcblxyXG4gICAgdGhpcy5nYW1lT2JqZWN0ID0gZ2FtZU9iamVjdDtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gKGdhbWVPYmplY3Quc3RhdGUpID8gZ2FtZU9iamVjdC5zdGF0ZSA6IGdhbWVPYmplY3QucGFyZW50LnN0YXRlO1xyXG5cclxuICAgIHRoaXMuZ2FtZSA9IHRoaXMuc3RhdGUuZ2FtZTtcclxuXHJcbiAgICAvLyAgYSA9IHNjYWxlIFhcclxuICAgIC8vICBiID0gc2hlYXIgWVxyXG4gICAgLy8gIGMgPSBzaGVhciBYXHJcbiAgICAvLyAgZCA9IHNjYWxlIFlcclxuICAgIC8vICB0eCAvIHR5ID0gdHJhbnNsYXRpb25cclxuXHJcbiAgICAvLyAgV29ybGQgVHJhbnNmb3JtXHJcbiAgICB0aGlzLndvcmxkID0geyBhOiBzY2FsZVgsIGI6IDAsIGM6IDAsIGQ6IHNjYWxlWSwgdHg6IHgsIHR5OiB5IH07XHJcblxyXG4gICAgLy8gIFByZXZpb3VzIFRyYW5zZm9ybSAodXNlZCBmb3IgaW50ZXJwb2xhdGlvbilcclxuICAgIHRoaXMub2xkID0geyBhOiBzY2FsZVgsIGI6IDAsIGM6IDAsIGQ6IHNjYWxlWSwgdHg6IHgsIHR5OiB5IH07XHJcblxyXG4gICAgLy8gIENhY2hlZCBUcmFuc2Zvcm0gQ2FsY3VsYXRpb25zXHJcbiAgICB0aGlzLmNhY2hlID0geyBhOiAxLCBiOiAwLCBjOiAwLCBkOiAxLCBzcjogMCwgY3I6IDAgfTtcclxuXHJcbiAgICAvLyAgR0wgVmVydGV4IERhdGFcclxuICAgIHRoaXMuZ2xWZXJ0ZXh0RGF0YSA9IHsgeDA6IDAsIHkwOiAwLCB4MTogMCwgeTE6IDAsIHgyOiAwLCB5MjogMCwgeDM6IDAsIHkzOiAwIH07XHJcblxyXG4gICAgLy8gIENhbnZhcyBTZXRUcmFuc2Zvcm0gZGF0YVxyXG4gICAgdGhpcy5jYW52YXNEYXRhID0geyBhOiAxLCBiOiAwLCBjOiAwLCBkOiAxLCB0eDogMCwgdHk6IDAsIGR4OiAwLCBkeTogMCB9O1xyXG5cclxuICAgIHRoaXMuaW1tZWRpYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaGFzTG9jYWxSb3RhdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBQcml2YXRlIHZhbHVlIGhvbGRlcnMsIGFjY2Vzc2VkIHZpYSB0aGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xyXG4gICAgdGhpcy5fcG9zWCA9IHg7XHJcbiAgICB0aGlzLl9wb3NZID0geTtcclxuICAgIHRoaXMuX3NjYWxlWCA9IHNjYWxlWDtcclxuICAgIHRoaXMuX3NjYWxlWSA9IHNjYWxlWTtcclxuICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcclxuICAgIHRoaXMuX3Bpdm90WCA9IDA7XHJcbiAgICB0aGlzLl9waXZvdFkgPSAwO1xyXG4gICAgdGhpcy5fYW5jaG9yWCA9IDA7XHJcbiAgICB0aGlzLl9hbmNob3JZID0gMDtcclxuXHJcbiAgICB0aGlzLl93b3JsZFJvdGF0aW9uID0gMDtcclxuICAgIHRoaXMuX3dvcmxkU2NhbGVYID0gc2NhbGVYO1xyXG4gICAgdGhpcy5fd29ybGRTY2FsZVkgPSBzY2FsZVk7XHJcblxyXG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgdGhpcy5fZGlydHlWZXJ0ZXggPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuYWRkKHRoaXMpO1xyXG5cclxuICAgIC8vICBUaGUgcGFyZW50IFRyYW5zZm9ybSAoTk9UIHRoZSBwYXJlbnQgR2FtZU9iamVjdCwgYWx0aG91Z2ggdmVyeSBvZnRlbiB0aGV5IGFyZSByZWxhdGVkKVxyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8vICBBbnkgY2hpbGQgVHJhbnNmb3JtcyBvZiB0aGlzIG9uZSAtIG5vdGUgdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gYmVsb25nIHRvIEdhbWUgT2JqZWN0c1xyXG4gICAgLy8gIHRoYXQgYXJlIGNoaWxkcmVuIG9mIHRoZSBvd25lciBvZiB0aGlzIFRyYW5zZm9ybVxyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybTtcclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQXQoY2hpbGQsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXQ6IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEludmFsaWQgY2hpbGQ/XHJcbiAgICAgICAgaWYgKGNoaWxkID09PSB0aGlzIHx8IGNoaWxkLnBhcmVudCA9PT0gdGhpcyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIGNoaWxkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDaGlsZCBhbHJlYWR5IHBhcmVudGVkPyBSZW1vdmUgaXRcclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVBbmNlc3RvcnMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICAvLyAgSW52YWxpZCBjaGlsZD9cclxuICAgICAgICBpZiAoY2hpbGQgPT09IHRoaXMgfHwgY2hpbGQucGFyZW50ICE9PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0OiBmdW5jdGlvbiAoaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFZhbGlkIGluZGV4P1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hpbGRbMF0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkWzBdLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBlbmFibGVJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLnN5bmNJbnRlcnBvbGF0aW9uKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN5bmNJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMub2xkO1xyXG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XHJcblxyXG4gICAgICAgIG9sZC5hID0gd29ybGQuYTtcclxuICAgICAgICBvbGQuYiA9IHdvcmxkLmI7XHJcbiAgICAgICAgb2xkLmMgPSB3b3JsZC5jO1xyXG4gICAgICAgIG9sZC5kID0gd29ybGQuZDtcclxuICAgICAgICBvbGQudHggPSB3b3JsZC50eDtcclxuICAgICAgICBvbGQudHkgPSB3b3JsZC50eTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzYWJsZUludGVycG9sYXRpb246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLl9wb3NYID0geDtcclxuICAgICAgICB0aGlzLl9wb3NZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NjYWxlWCA9IHg7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVZID0geTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQaXZvdDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLl9waXZvdFggPSB4O1xyXG4gICAgICAgIHRoaXMuX3Bpdm90WSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbmNob3I6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fYW5jaG9yWCA9IHg7XHJcbiAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBVcGRhdGVzIHRoZSBUcmFuc2Zvcm0ud29ybGQgb2JqZWN0LCByZWFkeSBmb3IgcmVuZGVyaW5nXHJcbiAgICAvLyAgQXNzdW1pbmcgdGhpcyBUcmFuc2Zvcm0gaXMgYSByb290IG5vZGUgKGkuZS4gbm8gdHJhbnNmb3JtIHBhcmVudClcclxuICAgIHVwZGF0ZUZyb21Sb290OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG5cclxuICAgICAgICBvbGQuYSA9IHdvcmxkLmE7XHJcbiAgICAgICAgb2xkLmIgPSB3b3JsZC5iO1xyXG4gICAgICAgIG9sZC5jID0gd29ybGQuYztcclxuICAgICAgICBvbGQuZCA9IHdvcmxkLmQ7XHJcbiAgICAgICAgb2xkLnR4ID0gd29ybGQudHg7XHJcbiAgICAgICAgb2xkLnR5ID0gd29ybGQudHk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc0xvY2FsUm90YXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVJvb3QnKTtcclxuXHJcbiAgICAgICAgICAgIHdvcmxkLmEgPSB0aGlzLmNhY2hlLmE7XHJcbiAgICAgICAgICAgIHdvcmxkLmIgPSB0aGlzLmNhY2hlLmI7XHJcbiAgICAgICAgICAgIHdvcmxkLmMgPSB0aGlzLmNhY2hlLmM7XHJcbiAgICAgICAgICAgIHdvcmxkLmQgPSB0aGlzLmNhY2hlLmQ7XHJcbiAgICAgICAgICAgIHdvcmxkLnR4ID0gdGhpcy5fcG9zWCAtICgodGhpcy5fcGl2b3RYICogdGhpcy5jYWNoZS5hKSArICh0aGlzLl9waXZvdFkgKiB0aGlzLmNhY2hlLmMpKTtcclxuICAgICAgICAgICAgd29ybGQudHkgPSB0aGlzLl9wb3NZIC0gKCh0aGlzLl9waXZvdFggKiB0aGlzLmNhY2hlLmIpICsgKHRoaXMuX3Bpdm90WSAqIHRoaXMuY2FjaGUuZCkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fd29ybGRSb3RhdGlvbiA9IE1hdGguYXRhbjIoLXRoaXMuY2FjaGUuYywgdGhpcy5jYWNoZS5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLCAnVHJhbnNmb3JtLnVwZGF0ZUZyb21Sb290IEZBU1QnKTtcclxuXHJcbiAgICAgICAgICAgIHdvcmxkLmEgPSB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgICAgIHdvcmxkLmIgPSAwO1xyXG4gICAgICAgICAgICB3b3JsZC5jID0gMDtcclxuICAgICAgICAgICAgd29ybGQuZCA9IHRoaXMuX3NjYWxlWTtcclxuICAgICAgICAgICAgd29ybGQudHggPSB0aGlzLl9wb3NYIC0gKHRoaXMuX3Bpdm90WCAqIHRoaXMuX3NjYWxlWCk7XHJcbiAgICAgICAgICAgIHdvcmxkLnR5ID0gdGhpcy5fcG9zWSAtICh0aGlzLl9waXZvdFkgKiB0aGlzLl9zY2FsZVkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fd29ybGRSb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl93b3JsZFNjYWxlWCA9IHRoaXMuX3NjYWxlWDtcclxuICAgICAgICB0aGlzLl93b3JsZFNjYWxlWSA9IHRoaXMuX3NjYWxlWTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUZyb21QYXJlbnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMub2xkO1xyXG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XHJcblxyXG4gICAgICAgIG9sZC5hID0gd29ybGQuYTtcclxuICAgICAgICBvbGQuYiA9IHdvcmxkLmI7XHJcbiAgICAgICAgb2xkLmMgPSB3b3JsZC5jO1xyXG4gICAgICAgIG9sZC5kID0gd29ybGQuZDtcclxuICAgICAgICBvbGQudHggPSB3b3JsZC50eDtcclxuICAgICAgICBvbGQudHkgPSB3b3JsZC50eTtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LndvcmxkO1xyXG4gICAgICAgIHZhciB0eCA9IDA7XHJcbiAgICAgICAgdmFyIHR5ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9jYWxSb3RhdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVGcm9tUGFyZW50JywgdGhpcy5wYXJlbnQubmFtZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2FjaGUuYTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmNhY2hlLmI7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jYWNoZS5jO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY2FjaGUuZDtcclxuXHJcbiAgICAgICAgICAgIHR4ID0gdGhpcy5fcG9zWCAtICgodGhpcy5fcGl2b3RYICogYSkgKyAodGhpcy5fcGl2b3RZICogYykpO1xyXG4gICAgICAgICAgICB0eSA9IHRoaXMuX3Bvc1kgLSAoKHRoaXMuX3Bpdm90WCAqIGIpICsgKHRoaXMuX3Bpdm90WSAqIGQpKTtcclxuXHJcbiAgICAgICAgICAgIHdvcmxkLmEgPSAoYSAqIHBhcmVudC5hKSArIChiICogcGFyZW50LmMpO1xyXG4gICAgICAgICAgICB3b3JsZC5iID0gKGEgKiBwYXJlbnQuYikgKyAoYiAqIHBhcmVudC5kKTtcclxuICAgICAgICAgICAgd29ybGQuYyA9IChjICogcGFyZW50LmEpICsgKGQgKiBwYXJlbnQuYyk7XHJcbiAgICAgICAgICAgIHdvcmxkLmQgPSAoYyAqIHBhcmVudC5iKSArIChkICogcGFyZW50LmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVBhcmVudCBGQVNUJywgdGhpcy5wYXJlbnQubmFtZSk7XHJcblxyXG4gICAgICAgICAgICB0eCA9IHRoaXMuX3Bvc1ggLSAodGhpcy5fcGl2b3RYICogdGhpcy5fc2NhbGVYKTtcclxuICAgICAgICAgICAgdHkgPSB0aGlzLl9wb3NZIC0gKHRoaXMuX3Bpdm90WSAqIHRoaXMuX3NjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICB3b3JsZC5hID0gdGhpcy5fc2NhbGVYICogcGFyZW50LmE7XHJcbiAgICAgICAgICAgIHdvcmxkLmIgPSB0aGlzLl9zY2FsZVggKiBwYXJlbnQuYjtcclxuICAgICAgICAgICAgd29ybGQuYyA9IHRoaXMuX3NjYWxlWSAqIHBhcmVudC5jO1xyXG4gICAgICAgICAgICB3b3JsZC5kID0gdGhpcy5fc2NhbGVZICogcGFyZW50LmQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl93b3JsZFJvdGF0aW9uID0gTWF0aC5hdGFuMigtdGhpcy53b3JsZC5jLCB0aGlzLndvcmxkLmQpO1xyXG5cclxuICAgICAgICB3b3JsZC50eCA9ICh0eCAqIHBhcmVudC5hKSArICh0eSAqIHBhcmVudC5jKSArIHBhcmVudC50eDtcclxuICAgICAgICB3b3JsZC50eSA9ICh0eCAqIHBhcmVudC5iKSArICh0eSAqIHBhcmVudC5kKSArIHBhcmVudC50eTtcclxuXHJcbiAgICAgICAgdGhpcy5fd29ybGRTY2FsZVggPSB0aGlzLl9zY2FsZVggKiBNYXRoLnNxcnQoKHdvcmxkLmEgKiB3b3JsZC5hKSArICh3b3JsZC5jICogd29ybGQuYykpO1xyXG4gICAgICAgIHRoaXMuX3dvcmxkU2NhbGVZID0gdGhpcy5fc2NhbGVZICogTWF0aC5zcXJ0KCh3b3JsZC5iICogd29ybGQuYikgKyAod29ybGQuZCAqIHdvcmxkLmQpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUFuY2VzdG9yczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlQW5jZXN0b3JzJyk7XHJcblxyXG4gICAgICAgIC8vICBObyBwYXJlbnQ/IFRoZW4ganVzdCB1cGRhdGUgdGhlIGNoaWxkcmVuIGFuZCBsZWF2ZSwgb3VyIGpvYiBpcyBkb25lXHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ3VwZGF0ZUFuY2VzdG9ycyBoYXMgbm8gcGFyZW50IFRyYW5zZm9ybScpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUm9vdCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdzdGFydCB1cGRhdGVBbmNlc3RvcnMgd2hpbGUnKTtcclxuXHJcbiAgICAgICAgLy8gIEdldHMgYWxsIHBhcmVudCBub2Rlcywgc3RhcnRpbmcgZnJvbSB0aGlzIFRyYW5zZm9ybS5cclxuICAgICAgICAvLyAgVGhlbiB1cGRhdGVzIGZyb20gdGhlIHRvcCwgZG93biwgYnV0IG9ubHkgb24gdGhlIGFuY2VzdG9ycyxcclxuICAgICAgICAvLyAgbm90IGFueSBvdGhlciBjaGlsZHJlbiAtIHdpbGwgZ2l2ZSB1cyBhY2N1cmF0ZSB3b3JsZFggZXRjIHByb3BlcnRpZXNcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZG9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpO1xyXG5cclxuICAgICAgICAvLyAgV2UndmUgZ290IGFsbCB0aGUgYW5jZXN0b3JzIGluIHRoZSAnbm9kZXMnIGFycmF5LCBsZXQncyBsb29wIGl0XHJcblxyXG4gICAgICAgIHdoaWxlIChub2Rlcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZXMucG9wKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVGcm9tUm9vdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQnkgdGhpcyBwb2ludCBhbGwgb2YgdGhpcyBUcmFuc2Zvcm1zIGFuY2VzdG9ycyBoYXZlIGJlZW5cclxuICAgICAgICAvLyAgdXBkYXRlZCwgaW4gdGhlIGNvcnJlY3Qgb3JkZXIsIHNvIHdlIGNhbiBub3cgZG8gdGhpcyBvbmVcclxuICAgICAgICAvLyAgYW5kIGFueSBvZiBpdHMgY2hpbGRyZW4gdG9vXHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVDaGlsZHJlbicpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlRnJvbURpcnR5UGFyZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ2lzIHVwZGF0ZUZyb21EaXJ0eVBhcmVudCcsIHRoaXMucGFyZW50Lm5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUZyb21QYXJlbnQoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZUZyb21EaXJ0eVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gdGhpcyBUcmFuc2Zvcm0gaXMgZGlydHlcclxuICAgICAgICAvLyAgc28gd2UgbmVlZCB0byB1cGRhdGUgaXQgZnJvbSBpdHMgcGFyZW50XHJcbiAgICAgICAgLy8gIGFuZCB0aGVuIGZvcmNlIHRoZSB1cGRhdGUgdG8gYWxsIGNoaWxkcmVuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21Sb290KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChsZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZUZyb21EaXJ0eVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jYWNoZS5hID0gdGhpcy5jYWNoZS5jciAqIHRoaXMuX3NjYWxlWDtcclxuICAgICAgICB0aGlzLmNhY2hlLmIgPSB0aGlzLmNhY2hlLnNyICogdGhpcy5fc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuYyA9IC10aGlzLmNhY2hlLnNyICogdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuZCA9IHRoaXMuY2FjaGUuY3IgKiB0aGlzLl9zY2FsZVk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZlcnRleERhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWVPYmplY3QuZnJhbWUgfHwgKCF0aGlzLl9kaXJ0eVZlcnRleCAmJiAhdGhpcy5pbnRlcnBvbGF0ZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmdhbWVPYmplY3QuZnJhbWU7XHJcblxyXG4gICAgICAgIHZhciB3MDtcclxuICAgICAgICB2YXIgaDA7XHJcbiAgICAgICAgdmFyIHcxO1xyXG4gICAgICAgIHZhciBoMTtcclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmRhdGEudHJpbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQsIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZ1xyXG4gICAgICAgICAgICB3MSA9IGZyYW1lLnggLSAodGhpcy5fYW5jaG9yWCAqIGZyYW1lLndpZHRoKTtcclxuICAgICAgICAgICAgdzAgPSB3MSArIGZyYW1lLmN1dFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaDEgPSBmcmFtZS55IC0gKHRoaXMuX2FuY2hvclkgKiBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBoMCA9IGgxICsgZnJhbWUuY3V0SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3MCA9IGZyYW1lLmN1dFdpZHRoICogKDEgLSB0aGlzLl9hbmNob3JYKTtcclxuICAgICAgICAgICAgdzEgPSBmcmFtZS5jdXRXaWR0aCAqIC10aGlzLl9hbmNob3JYO1xyXG5cclxuICAgICAgICAgICAgaDAgPSBmcmFtZS5jdXRIZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvclkpO1xyXG4gICAgICAgICAgICBoMSA9IGZyYW1lLmN1dEhlaWdodCAqIC10aGlzLl9hbmNob3JZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBmcmFtZS5zb3VyY2UucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZDtcclxuXHJcbiAgICAgICAgdmFyIGEgPSB3dC5hIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgYiA9IHd0LmIgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBjID0gd3QuYyAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIGQgPSB3dC5kIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgdHggPSB3dC50eDtcclxuICAgICAgICB2YXIgdHkgPSB3dC50eTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5vbGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSB3aXRoIHRoZSBsYXN0IHBvc2l0aW9uIHRvIHJlZHVjZSBzdHV0dGVyaW5nLlxyXG4gICAgICAgICAgICBhID0gb2xkLmEgKyAoKGEgLSBvbGQuYSkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGIgPSBvbGQuYiArICgoYiAtIG9sZC5iKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgYyA9IG9sZC5jICsgKChjIC0gb2xkLmMpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkID0gb2xkLmQgKyAoKGQgLSBvbGQuZCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIHR4ID0gb2xkLnR4ICsgKCh0eCAtIG9sZC50eCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIHR5ID0gb2xkLnR5ICsgKCh0eSAtIG9sZC50eSkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZnJhbWUucm90YXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHZhciBjdyA9IGZyYW1lLmN1dFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2ggPSBmcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBhMCA9IGE7XHJcbiAgICAgICAgICAgIHZhciBiMCA9IGI7XHJcbiAgICAgICAgICAgIHZhciBjMCA9IGM7XHJcbiAgICAgICAgICAgIHZhciBkMCA9IGQ7XHJcbiAgICAgICAgICAgIHZhciBfdzEgPSB3MTtcclxuICAgICAgICAgICAgdmFyIF93MCA9IHcwO1xyXG5cclxuICAgICAgICAgICAgLy8gIE9mZnNldCBiZWZvcmUgcm90YXRpbmdcclxuICAgICAgICAgICAgdHggPSAod3QuYyAqIGNoKSArIHR4O1xyXG4gICAgICAgICAgICB0eSA9ICh3dC5kICogY2gpICsgdHk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyAgUm90YXRlIG1hdHJpeCBieSA5MCBkZWdyZWVzIHdpdGggcHJlY2FsYyB2YWx1ZXMgZm9yIHNpbmUgYW5kIGNvc2luZSBvZiByYWQoOTApXHJcbiAgICAgICAgICAgIGEgPSAoYTAgKiA2LjEyMzIzMzk5NTczNjc2NmUtMTcpICsgLWMwO1xyXG4gICAgICAgICAgICBiID0gKGIwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KSArIC1kMDtcclxuICAgICAgICAgICAgYyA9IGEwICsgKGMwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KTtcclxuICAgICAgICAgICAgZCA9IGIwICsgKGQwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBVViBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBmcmFtZS51cGRhdGVVVnNJbnZlcnRlZCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUm90YXRlIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdzAgPSBoMDtcclxuICAgICAgICAgICAgdzEgPSBoMTtcclxuICAgICAgICAgICAgaDAgPSBfdzA7XHJcbiAgICAgICAgICAgIGgxID0gX3cxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmF1dG9Sb3VuZCA9PT0gMSB8fCAoZnJhbWUuYXV0b1JvdW5kID09PSAtMSAmJiByZW5kZXJlci5yb3VuZFBpeGVscykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eCB8PSAwO1xyXG4gICAgICAgICAgICB0eSB8PSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZlcnQgPSB0aGlzLmdsVmVydGV4dERhdGE7XHJcblxyXG4gICAgICAgIC8vICBUb3AgTGVmdCBWZXJ0XHJcbiAgICAgICAgdmVydC54MCA9IChhICogdzEpICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICB2ZXJ0LnkwID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xyXG5cclxuICAgICAgICAvLyAgVG9wIFJpZ2h0IFZlcnRcclxuICAgICAgICB2ZXJ0LngxID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIHZlcnQueTEgPSAoZCAqIGgxKSArIChiICogdzApICsgdHk7XHJcblxyXG4gICAgICAgIC8vICBCb3R0b20gUmlnaHQgVmVydFxyXG4gICAgICAgIHZlcnQueDIgPSAoYSAqIHcwKSArIChjICogaDApICsgdHg7XHJcbiAgICAgICAgdmVydC55MiA9IChkICogaDApICsgKGIgKiB3MCkgKyB0eTtcclxuXHJcbiAgICAgICAgLy8gIEJvdHRvbSBMZWZ0IFZlcnRcclxuICAgICAgICB2ZXJ0LngzID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIHZlcnQueTMgPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHZlcnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZlcnRleERhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUgfHwgdGhpcy5fZGlydHlWZXJ0ZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZlcnRleERhdGEoaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIHJlbmRlcmVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nbFZlcnRleHREYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZVZlcnRleERhdGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMuZ2xWZXJ0ZXh0RGF0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDA6IHNyYy54MCxcclxuICAgICAgICAgICAgeTA6IHNyYy55MCxcclxuICAgICAgICAgICAgeDE6IHNyYy54MSxcclxuICAgICAgICAgICAgeTE6IHNyYy55MSxcclxuICAgICAgICAgICAgeDI6IHNyYy54MixcclxuICAgICAgICAgICAgeTI6IHNyYy55MixcclxuICAgICAgICAgICAgeDM6IHNyYy54MyxcclxuICAgICAgICAgICAgeTM6IHNyYy55M1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENhbnZhc1RyYW5zZm9ybURhdGE6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5nYW1lT2JqZWN0LmZyYW1lO1xyXG5cclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jYW52YXNEYXRhO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbnRlcnBvbGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHdpdGggdGhlIGxhc3QgcG9zaXRpb24gdG8gcmVkdWNlIHN0dXR0ZXJpbmcuXHJcbiAgICAgICAgICAgIGRhdGEuYSA9IG9sZC5hICsgKCh3b3JsZC5hIC0gb2xkLmEpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLmIgPSBvbGQuYiArICgod29ybGQuYiAtIG9sZC5iKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgZGF0YS5jID0gb2xkLmMgKyAoKHdvcmxkLmMgLSBvbGQuYykgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGRhdGEuZCA9IG9sZC5kICsgKCh3b3JsZC5kIC0gb2xkLmQpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLnR4ID0gb2xkLnR4ICsgKCh3b3JsZC50eCAtIG9sZC50eCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgIGRhdGEudHkgPSBvbGQudHkgKyAoKHdvcmxkLnR5IC0gb2xkLnR5KSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgZGF0YS5keCA9IG9sZC5keCArICgoZnJhbWUueCAtICh0aGlzLmFuY2hvclggKiBmcmFtZS53aWR0aCkpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICBkYXRhLmR5ID0gb2xkLmR5ICsgKChmcmFtZS55IC0gKHRoaXMuYW5jaG9yWSAqIGZyYW1lLmhlaWdodCkpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQ29weSBvdmVyIHRoZSB2YWx1ZXMgdG8gdGhlIGNhbnZhc0RhdGEgb2JqZWN0LCBpbiBjYXNlIHRoZSByZW5kZXJlciBuZWVkcyB0byBhZGp1c3QgdGhlbVxyXG4gICAgICAgICAgICBkYXRhLmEgPSB3b3JsZC5hO1xyXG4gICAgICAgICAgICBkYXRhLmIgPSB3b3JsZC5iO1xyXG4gICAgICAgICAgICBkYXRhLmMgPSB3b3JsZC5jO1xyXG4gICAgICAgICAgICBkYXRhLmQgPSB3b3JsZC5kO1xyXG4gICAgICAgICAgICBkYXRhLnR4ID0gd29ybGQudHg7XHJcbiAgICAgICAgICAgIGRhdGEudHkgPSB3b3JsZC50eTtcclxuICAgICAgICAgICAgZGF0YS5keCA9IGZyYW1lLnggLSAodGhpcy5hbmNob3JYICogZnJhbWUud2lkdGgpO1xyXG4gICAgICAgICAgICBkYXRhLmR5ID0gZnJhbWUueSAtICh0aGlzLmFuY2hvclkgKiBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZyYW1lLmF1dG9Sb3VuZCA9PT0gMSB8fCAoZnJhbWUuYXV0b1JvdW5kID09PSAtMSAmJiByZW5kZXJlci5yb3VuZFBpeGVscykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkYXRhLnR4IHw9IDA7XHJcbiAgICAgICAgICAgIGRhdGEudHkgfD0gMDtcclxuICAgICAgICAgICAgZGF0YS5keCB8PSAwO1xyXG4gICAgICAgICAgICBkYXRhLmR5IHw9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm0ucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xyXG5cclxuICAgIHg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NYID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1k7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFuY2hvcjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yWDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5jaG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JYO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmNob3JZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBwaXZvdFg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHBpdm90WToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcGl2b3RZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYW5nbGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFdyYXBBbmdsZSh0aGlzLnJvdGF0aW9uICogTUFUSF9DT05TVC5SQURfVE9fREVHKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBXcmFwQW5nbGUodmFsdWUpICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gJSBNQVRIX0NPTlNULlBJMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuY3IgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0xvY2FsUm90YXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNMb2NhbFJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2V0cyB0aGlzICpjb21wb25lbnQqIGFzIGJlaW5nIGRpcnR5XHJcbiAgICBkaXJ0eToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlydHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbW1lZGlhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eVZlcnRleCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuYWRkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgR0xPQkFMIHJlYWQtb25seSBwcm9wZXJ0aWVzIGZyb20gaGVyZSBvblxyXG4gICAgLy8gIE5lZWQgKmFsbCogcGFyZW50cyB0YWtlbiBpbnRvIGFjY291bnQgdG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlc1xyXG5cclxuICAgIG5hbWU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdhbWVPYmplY3QpID8gdGhpcy5nYW1lT2JqZWN0Lm5hbWUgOiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFJvdGF0aW9uOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRSb3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFNjYWxlWDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkU2NhbGVYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHdvcmxkU2NhbGVZOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRTY2FsZVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd29ybGRYOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3JsZC50eDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB3b3JsZFk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmNlc3RvcnMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndvcmxkLnR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgQXVkaW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXVkaW9EYXRhIC0gQXJlIEF1ZGlvIHRhZ3MgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGF1ZGlvRGF0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXVkaW8gLSBJcyB0aGUgV2ViQXVkaW8gQVBJIGF2YWlsYWJsZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJBdWRpbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG9nZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B1cyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9wdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb3B1czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXAzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbXAzIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1wMzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2F2IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2F2IGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdhdjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbiB0aGlzIGRldmljZSBwbGF5IG00YSBmaWxlcz9cclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtNGEgLSBUcnVlIGlmIHRoaXMgZGV2aWNlIGNhbiBwbGF5IG00YSBmaWxlcy5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtNGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm0gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYm06IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRvbGJ5IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgRUMtMyBEb2xieSBEaWdpdGFsIFBsdXMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZG9sYnk6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBBdWRpby5hdWRpb0RhdGEgPSAhISh3aW5kb3dbJ0F1ZGlvJ10pO1xyXG4gICAgQXVkaW8ud2ViQXVkaW8gPSAhISh3aW5kb3dbJ0F1ZGlvQ29udGV4dCddIHx8IHdpbmRvd1snd2Via2l0QXVkaW9Db250ZXh0J10pO1xyXG5cclxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAhIWF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZTtcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLm9nZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL29wdXM7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ub3B1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ubXAzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIE1pbWV0eXBlcyBhY2NlcHRlZDpcclxuICAgICAgICAgICAgLy8gIGRldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9NZWRpYV9mb3JtYXRzX3N1cHBvcnRlZF9ieV90aGVfYXVkaW9fYW5kX3ZpZGVvX2VsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vICBiaXQubHkvaXBob25lb3Njb2RlY3NcclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby53YXYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5tNGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLndlYm0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7Y29kZWNzPVwiZWMtM1wiJykgIT09ICcnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQnJvd3Nlci5lZGdlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIuc2FmYXJpVmVyc2lvbiA+PSA5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoL01hYyBPUyBYIChcXGQrKV8oXFxkKykvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5vciA9IHBhcnNlSW50KFJlZ0V4cC4kMiwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYWpvciA9PT0gMTAgJiYgbWlub3IgPj0gMTEpIHx8IG1ham9yID4gMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQXVkaW87XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQXVkaW8uanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9BdWRpby5qcyIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxuXHJcbnZhciBGdWxsc2NyZWVuID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGF2YWlsYWJsZSAtIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCB0aGUgRnVsbCBTY3JlZW4gQVBJP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGF2YWlsYWJsZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXF1ZXN0IC0gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEZ1bGwgU2NyZWVuIEFQSSB0aGlzIGhvbGRzIHRoZSBjYWxsIHlvdSBuZWVkIHRvIHVzZSB0byBhY3RpdmF0ZSBpdC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICByZXF1ZXN0OiAnJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhbmNlbCAtIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBGdWxsIFNjcmVlbiBBUEkgdGhpcyBob2xkcyB0aGUgY2FsbCB5b3UgbmVlZCB0byB1c2UgdG8gY2FuY2VsIGl0LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNhbmNlbDogJycsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2V5Ym9hcmQgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgYWNjZXNzIHRvIHRoZSBLZXlib2FyZCBkdXJpbmcgRnVsbCBTY3JlZW4gbW9kZT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBrZXlib2FyZDogZmFsc2VcclxuXHJcbn07XHJcblxyXG4vKipcclxuKiBDaGVja3MgZm9yIHN1cHBvcnQgb2YgdGhlIEZ1bGwgU2NyZWVuIEFQSS5cclxuKi9cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICB2YXIgZnMgPSBbXHJcbiAgICAgICAgJ3JlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAncmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ21zUmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21velJlcXVlc3RGdWxsc2NyZWVuJ1xyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRbZnNbaV1dKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRnVsbHNjcmVlbi5hdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBGdWxsc2NyZWVuLnJlcXVlc3QgPSBmc1tpXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjZnMgPSBbXHJcbiAgICAgICAgJ2NhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdleGl0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ21zQ2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbW96RXhpdEZ1bGxzY3JlZW4nXHJcbiAgICBdO1xyXG5cclxuICAgIGlmIChGdWxsc2NyZWVuLmF2YWlsYWJsZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNmcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtjZnNbaV1dKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGdWxsc2NyZWVuLmNhbmNlbCA9IGNmc1tpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBLZXlib2FyZCBJbnB1dD9cclxuICAgIGlmICh3aW5kb3dbJ0VsZW1lbnQnXSAmJiBFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKVxyXG4gICAge1xyXG4gICAgICAgIEZ1bGxzY3JlZW4ua2V5Ym9hcmQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBGdWxsc2NyZWVuO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0Z1bGxzY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG5cclxudmFyIElucHV0ID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRvdWNoIC0gSXMgdG91Y2ggYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRvdWNoOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtc3BvaW50ZXIgLSBJcyBtc3BvaW50ZXIgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1zcG9pbnRlcjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gd2hlZWxUeXBlIC0gVGhlIG5ld2VzdCB0eXBlIG9mIFdoZWVsL1Njcm9sbCBldmVudCBzdXBwb3J0ZWQ6ICd3aGVlbCcsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJ1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgd2hlZWxFdmVudDogbnVsbFxyXG4gICAgXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgKHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+PSAxKSlcclxuICAgIHtcclxuICAgICAgICBJbnB1dC50b3VjaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCB8fCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIElucHV0Lm1zcG9pbnRlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFPUy5jb2Nvb25KUylcclxuICAgIHtcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXHJcbiAgICAgICAgaWYgKCdvbndoZWVsJyBpbiB3aW5kb3cgfHwgKEJyb3dzZXIuaWUgJiYgJ1doZWVsRXZlbnQnIGluIHdpbmRvdykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBET00zIFdoZWVsIEV2ZW50OiBGRiAxNyssIElFIDkrLCBDaHJvbWUgMzErLCBTYWZhcmkgNytcclxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICd3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdvbm1vdXNld2hlZWwnIGluIHdpbmRvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIE5vbi1GRiBsZWdhY3k6IElFIDYtOSwgQ2hyb21lIDEtMzEsIFNhZmFyaSA1LTcuXHJcbiAgICAgICAgICAgIElucHV0LndoZWVsRXZlbnQgPSAnbW91c2V3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuZmlyZWZveCAmJiAnTW91c2VTY3JvbGxFdmVudCcgaW4gd2luZG93KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRkYgcHJpb3IgdG8gMTcuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHNjcnViYmVkLlxyXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ0RPTU1vdXNlU2Nyb2xsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIElucHV0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0lucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvSW5wdXQuanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgVmlkZW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgdmlkZW8gZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb2dnVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGgyNjRWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGgyNjQgbXA0IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGgyNjRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXA0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtcDRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2VibVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2VibSB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJtVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZwOVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgdnA5IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZwOVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBobHNWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGhscyB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBobHNWaWRlbzogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgdmFyIHJlc3VsdCA9ICEhdmlkZW9FbGVtZW50LmNhblBsYXlUeXBlO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ub2dnVmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IFF1aWNrVGltZSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgLiBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzU0NlxyXG4gICAgICAgICAgICAgICAgVmlkZW8uaDI2NFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFZpZGVvLm1wNFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZpZGVvLndlYm1WaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8udnA5VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi94LW1wZWdVUkw7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby5obHNWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgTm90aGluZyB0byBkb1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWaWRlbztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9WaWRlby5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL1ZpZGVvLmpzIiwiLy8gIFRoaXMgc2luZ2xldG9uIGlzIGluc3RhbnRpYXRlZCBhcyBzb29uIGFzIFBoYXNlciBsb2FkcyxcclxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cclxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIGNhbiBzaGFyZSBpdCxcclxuLy8gIHdpdGhvdXQgaGF2aW5nIHRvIHJlLXBvbGwgdGhlIGRldmljZSBhbGwgb3ZlciBhZ2FpblxyXG5cclxudmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgRmVhdHVyZXMgPSByZXF1aXJlKCcuL0ZlYXR1cmVzJyk7XHJcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vSW5wdXQnKTtcclxudmFyIEF1ZGlvID0gcmVxdWlyZSgnLi9BdWRpbycpO1xyXG52YXIgVmlkZW8gPSByZXF1aXJlKCcuL1ZpZGVvJyk7XHJcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9GdWxsc2NyZWVuJyk7XHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHJlcXVpcmUoJy4vQ2FudmFzRmVhdHVyZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE9TOiBPUyxcclxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXHJcbiAgICBGZWF0dXJlczogRmVhdHVyZXMsXHJcbiAgICBJbnB1dDogSW5wdXQsXHJcbiAgICBBdWRpbzogQXVkaW8sXHJcbiAgICBWaWRlbzogVmlkZW8sXHJcbiAgICBGdWxsc2NyZWVuOiBGdWxsc2NyZWVuLFxyXG4gICAgQ2FudmFzRmVhdHVyZXM6IENhbnZhc0ZlYXR1cmVzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9pbmRleC5qcyIsInZhciBBZGRUb0RPTSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQsIG92ZXJmbG93SGlkZGVuKVxyXG57XHJcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gPT09IHVuZGVmaW5lZCkgeyBvdmVyZmxvd0hpZGRlbiA9IHRydWU7IH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0O1xyXG5cclxuICAgIGlmIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEhvcGVmdWxseSBhbiBlbGVtZW50IElEXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayB0ZXN0IGZvciBhIEhUTUxlbGVtZW50XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZhbGxiYWNrLCBjb3ZlcnMgYW4gaW52YWxpZCBJRCBhbmQgYSBub24gSFRNTGVsZW1lbnQgb2JqZWN0XHJcbiAgICBpZiAoIXRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiAmJiB0YXJnZXQuc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRUb0RPTTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0FkZFRvRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgT1MgPSByZXF1aXJlKCcuLi9kZXZpY2UvT1MnKTtcclxuXHJcbnZhciBpc0Jvb3RlZCA9IGZhbHNlO1xyXG5cclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIGlmIChpc0Jvb3RlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJylcclxuICAgIHtcclxuICAgICAgICBpc0Jvb3RlZCA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCB0cnVlKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG5cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkpXHJcbiAgICB7XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2ssIDIwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKE9TLmNvcmRvdmEgJiYgIU9TLmNvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZWYuIGh0dHA6Ly9kb2NzLnBob25lZ2FwLmNvbS9lbi8zLjUuMC9jb3Jkb3ZhX2V2ZW50c19ldmVudHMubWQuaHRtbCNkZXZpY2VyZWFkeVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgY2hlY2ssIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01Db250ZW50TG9hZGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vRE9NQ29udGVudExvYWRlZC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9tL0RPTUNvbnRlbnRMb2FkZWQuanMiLCJ2YXIgUGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSlcclxue1xyXG4gICAgdmFyIHhtbCA9ICcnO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmICh3aW5kb3dbJ0RPTVBhcnNlciddKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcclxuICAgICAgICAgICAgeG1sID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhLCAndGV4dC94bWwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcclxuICAgICAgICAgICAgeG1sLmxvYWRYTUwoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpXHJcbiAgICB7XHJcbiAgICAgICAgeG1sID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB4bWw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlWE1MO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vUGFyc2VYTUwuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEFic3RyYWN0cyBhd2F5IHRoZSB1c2Ugb2YgUkFGIG9yIHNldFRpbWVPdXQgZm9yIHRoZSBjb3JlIGdhbWUgdXBkYXRlIGxvb3AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVNldFRpbWVPdXQ9ZmFsc2VdIC0gVGVsbCBQaGFzZXIgdG8gdXNlIHNldFRpbWVPdXQgZXZlbiBpZiByYWYgaXMgYXZhaWxhYmxlLlxyXG4qL1xyXG5mdW5jdGlvbiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKGdhbWUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gVGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1J1bm5pbmcgLSB0cnVlIGlmIFJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBydW5uaW5nLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnRpY2sgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU2V0VGltZU91dCAgLSBUcnVlIGlmIHRoZSBicm93c2VyIGlzIHVzaW5nIHNldFRpbWVvdXQgaW5zdGVhZCBvZiByQWYuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1NldFRpbWVPdXQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVPdXRJRCAtIFRoZSBjYWxsYmFjayBzZXRUaW1lb3V0IG9yIHJBZiBjYWxsYmFjayBJRCB1c2VkIHdoZW4gY2FsbGluZyBjYW5jZWwuXHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lT3V0SUQgPSBudWxsO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICBfdGhpcy50aWNrID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG5cclxuICAgICAgICBfdGhpcy5nYW1lLnVwZGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RlcFRpbWVvdXQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIF90aGlzLnRpY2sgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICAvLyBfdGhpcy5nYW1lLnVwZGF0ZShfdGhpcy50aWNrKTtcclxuXHJcbiAgICAgICAgLy8gX3RoaXMudGltZU91dElEID0gd2luZG93LnNldFRpbWVvdXQoc3RlcFRpbWVvdXQsIF90aGlzLmdhbWUudGltZS50aW1lVG9DYWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFN0YXJ0cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJ1bm5pbmcgb3Igc2V0VGltZW91dCBpZiB1bmF2YWlsYWJsZSBpbiBicm93c2VyXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdGFydFxyXG4gICAgKi9cclxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5jb25maWcuZm9yY2VTZXRUaW1lT3V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NldFRpbWVPdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpbWVPdXRJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU3RvcHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHJ1bm5pbmcuXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdG9wXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcblJlcXVlc3RBbmltYXRpb25GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vRXZlbnRMaXN0ZW5lcicpO1xyXG5cclxudmFyIEV2ZW50QmluZGluZyA9IGZ1bmN0aW9uIChkaXNwYXRjaGVyLCB0eXBlKVxyXG57XHJcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IFtdO1xyXG59O1xyXG5cclxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50QmluZGluZztcclxuXHJcbkV2ZW50QmluZGluZy5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgdG90YWw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0b3RhbDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0KGNhbGxiYWNrKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmdldChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgIGlmICghbGlzdGVuZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIGxpc3RlbmVyIGRvZXNuJ3QgZXhpc3QsIHNvIGNyZWF0ZSBvbmVcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSBFdmVudExpc3RlbmVyKHRoaXMudHlwZSwgY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIExpc3RlbmVyIGFscmVhZHkgZXhpc3RzLCBhYm9ydFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzbid0IGRvaW5nIGFueXRoaW5nLCBzbyB3ZSBkb24ndCBuZWVkIGEgcGVuZGluZyBzdGF0ZVxyXG4gICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX0FDVElWRTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBZGQgaXQgdG8gdGhlIGxpc3QsIGJ1dCBrZWVwIHRoZSBzdGF0ZSBhcyBwZW5kaW5nLlxyXG4gICAgICAgICAgICAvLyAgVGhlIGNhbGwgdG8gJ3RpZHknIHdpbGwgc29ydCBpdCBvdXQgYXQgdGhlIGVuZCBvZiB0aGUgZGlzcGF0Y2guXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc29ydEhhbmRsZXI6IGZ1bmN0aW9uIChsaXN0ZW5lckEsIGxpc3RlbmVyQilcclxuICAgIHtcclxuICAgICAgICBpZiAobGlzdGVuZXJCLnByaW9yaXR5IDwgbGlzdGVuZXJBLnByaW9yaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsaXN0ZW5lckIucHJpb3JpdHkgPiBsaXN0ZW5lckEucHJpb3JpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzbid0IGRvaW5nIGFueXRoaW5nLCBzbyB3ZSBjYW4gcmVtb3ZlIHJpZ2h0IGF3YXlcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEluZGV4KGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpICE9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpcyB3b3JraW5nLCBzbyB3ZSBmbGFnIHRoZSBsaXN0ZW5lciBmb3IgcmVtb3ZhbCBhdCB0aGUgZW5kXHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9SRU1PVklORztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvcjogRmFpbGVkIHRvIGV4ZWN1dGUgXFwnRXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoXFwnIG9uIFxcJycgKyB0aGlzLnR5cGUgKyAnXFwnOiBUaGUgZXZlbnQgaXMgYWxyZWFkeSBiZWluZyBkaXNwYXRjaGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhpcyB3YXMgYSB2YWxpZCBkaXNwYXRjaCBjYWxsLCB3ZSBqdXN0IGhhZCBub3RoaW5nIHRvIGRvIC4uLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORztcclxuXHJcbiAgICAgICAgdmFyIGxpc3RlbmVyO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLmFjdGl2ZVtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfQUNUSVZFKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suY2FsbCh0aGlzLmRpc3BhdGNoZXIsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vICBIYXMgdGhlIGNhbGxiYWNrIGNoYW5nZWQgdGhlIHN0YXRlIG9mIHRoaXMgYmluZGluZz9cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBZdXAhIExldCdzIGJyZWFrIG91dFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBXYXMgaXQgYSAnb25jZScgbGlzdGVuZXI/XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vbmNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgSGFzIHRoZSBldmVudCBiZWVuIGhhbHRlZCBieSB0aGUgY2FsbGJhY2s/XHJcbiAgICAgICAgICAgIGlmICghZXZlbnQuX3Byb3BhZ2F0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEJyZWFrIG91dCwgYSBsaXN0ZW5lciBoYXMgY2FsbGVkIEV2ZW50LnN0b3BQcm9wYWdhdGlvblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBEaXNwYXRjaCBvdmVyLCBvciBhYm9ydGVkXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfUkVNT1ZJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsbCBkb25lLCB0aWR5IHRoZSBsaXN0IGluIGNhc2UgdGhlcmUgd2VyZSBhbnkgcGVuZGluZyBldmVudHMgYWRkZWRcclxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfREVTVFJPWUVEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmRlbGV0ZSh0aGlzLnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWxsIGRvbmUsIGp1c3QgcHVyZ2UgdGhlIGxpc3RcclxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9JRExFO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xyXG4gICAgLy8gIElmIHRoaXMgaXMgY3VycmVudGx5IGJlaW5nIGRpc3BhdGNoZWQgdGhlbiBkb24ndCByZW1vdmUgJ3BlbmRpbmcnIGxpc3RlbmVyc1xyXG4gICAgLy8gIChpLmUuIG9uZXMgdGhhdCB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgZGlzcGF0Y2gpLCBvbmx5IGFjdGl2ZSBvbmVzXHJcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9QRU5ESU5HKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9JRExFO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdGlkeTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYWRkZWQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIGRvXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9BQ1RJVkU7XHJcbiAgICAgICAgICAgICAgICBhZGRlZCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpID49IDApO1xyXG5cclxuICAgICAgICBpZiAoYWRkZWQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJyc7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfREVTVFJPWUVEO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRCaW5kaW5nO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcclxue1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICBzdGF0ZTogQ09OU1QuTElTVEVORVJfUEVORElOR1xyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29udGFpbmVyV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyV2ViR0xSZW5kZXJlcicpO1xyXG52YXIgQ2hpbGRyZW4gPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL0NoaWxkcmVuJyk7XHJcblxyXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJlbnQsIHgsIHkpXHJcbntcclxuICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgeCwgeSwgbnVsbCwgbnVsbCwgcGFyZW50KTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5DT05UQUlORVI7XHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSBDb250YWluZXJXZWJHTFJlbmRlcmVyO1xyXG5cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ2hpbGRyZW4odGhpcyk7XHJcbn07XHJcblxyXG5Db250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHYW1lT2JqZWN0LnByb3RvdHlwZSk7XHJcbkNvbnRhaW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWluZXI7XHJcblxyXG5Db250YWluZXIucHJvdG90eXBlLnByZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuY2hpbGRyZW4ucHJlVXBkYXRlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJcclxudmFyIENvbnRhaW5lcldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXHJcbntcclxuICAgIHZhciBhbHBoYSA9IHNyYy5jb2xvci53b3JsZEFscGhhICogMjU1IDw8IDI0O1xyXG5cclxuICAgIC8vICBTa2lwIHJlbmRlcmluZz9cclxuXHJcbiAgICBpZiAoc3JjLnNraXBSZW5kZXIgfHwgIXNyYy52aXNpYmxlIHx8IGFscGhhID09PSAwIHx8IHNyYy5jaGlsZHJlbi5saXN0Lmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJlbmRlciBjaGlsZHJlblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBzcmMuY2hpbGRyZW4ubGlzdFtpXTtcclxuXHJcbiAgICAgICAgY2hpbGQucmVuZGVyKHJlbmRlcmVyLCBjaGlsZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lcldlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcblxyXG4vKipcclxuKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cclxuKiBJdCBjYW4gc3RpbGwgcm90YXRlLCBzY2FsZSwgY3JvcCBhbmQgcmVjZWl2ZSBpbnB1dCBldmVudHMuIFRoaXMgbWFrZXMgaXQgcGVyZmVjdCBmb3IgbG9nb3MsIGJhY2tncm91bmRzLCBzaW1wbGUgYnV0dG9ucyBhbmQgb3RoZXIgbm9uLVNwcml0ZSBncmFwaGljcy5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5JbWFnZVxyXG4qIEBleHRlbmRzIFBoYXNlci5HYW1lT2JqZWN0XHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtrZXldIC0gVGhlIHRleHR1cmUgdXNlZCBieSB0aGUgSW1hZ2UgZHVyaW5nIHJlbmRlcmluZy4gSXQgY2FuIGJlIGEgc3RyaW5nIHdoaWNoIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBDYWNoZSBlbnRyeSwgb3IgYW4gaW5zdGFuY2Ugb2YgYSBSZW5kZXJUZXh0dXJlLCBCaXRtYXBEYXRhIG9yIFBJWEkuVGV4dHVyZS5cclxuKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiB0aGlzIEltYWdlIGlzIHVzaW5nIHBhcnQgb2YgYSBzcHJpdGUgc2hlZXQgb3IgdGV4dHVyZSBhdGxhcyB5b3UgY2FuIHNwZWNpZnkgdGhlIGV4YWN0IGZyYW1lIHRvIHVzZSBieSBnaXZpbmcgYSBzdHJpbmcgb3IgbnVtZXJpYyBpbmRleC5cclxuKi9cclxudmFyIEltYWdlID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKVxyXG57XHJcbiAgICB2YXIgX3RleHR1cmUgPSBzdGF0ZS5nYW1lLnRleHR1cmVzLmdldChrZXkpO1xyXG4gICAgdmFyIF9mcmFtZSA9IF90ZXh0dXJlLmdldChmcmFtZSk7XHJcblxyXG4gICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlLCB4LCB5LCBfdGV4dHVyZSwgX2ZyYW1lKTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5JTUFHRTtcclxufTtcclxuXHJcbkltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR2FtZU9iamVjdC5wcm90b3R5cGUpO1xyXG5JbWFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZTtcclxuXHJcbkltYWdlLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSByZXF1aXJlKCcuL0ltYWdlQ2FudmFzUmVuZGVyZXInKTtcclxuSW1hZ2UucHJvdG90eXBlLnJlbmRlcldlYkdMID0gcmVxdWlyZSgnLi9JbWFnZVdlYkdMUmVuZGVyZXInKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEltYWdlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIHdpZHRoOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYICogdGhpcy5mcmFtZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHZhbHVlIC8gdGhpcy5mcmFtZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgaGVpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZICogdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbEhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwiXHJcbnZhciBJbWFnZUNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlKVxyXG57XHJcbiAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICB2YXIgYWxwaGEgPSBzcmMuY29sb3Iud29ybGRBbHBoYSAqIDI1NSA8PCAyNDtcclxuXHJcbiAgICAvLyAgU2tpcCByZW5kZXJpbmc/XHJcblxyXG4gICAgaWYgKHNyYy5za2lwUmVuZGVyIHx8ICFzcmMudmlzaWJsZSB8fCBhbHBoYSA9PT0gMCB8fCAhZnJhbWUuY3V0V2lkdGggfHwgIWZyYW1lLmN1dEhlaWdodClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGEgPSBzcmMudHJhbnNmb3JtLmdldENhbnZhc1RyYW5zZm9ybURhdGEoaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIHJlbmRlcmVyKTtcclxuICAgIHZhciB0aW50ID0gc3JjLmNvbG9yLl9nbFRpbnQ7XHJcbiAgICB2YXIgYmcgPSBzcmMuY29sb3IuX2dsQmc7XHJcblxyXG4gICAgcmVuZGVyZXIuZHJhd0ltYWdlKGZyYW1lLCBzcmMuYmxlbmRNb2RlLCBkYXRhLCBhbHBoYSwgdGludCwgYmcpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBJbWFnZVdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IHNyYy5mcmFtZTtcclxuICAgIHZhciBhbHBoYSA9IHNyYy5jb2xvci53b3JsZEFscGhhICogMjU1IDw8IDI0O1xyXG5cclxuICAgIC8vICBTa2lwIHJlbmRlcmluZz9cclxuXHJcbiAgICBpZiAoc3JjLnNraXBSZW5kZXIgfHwgIXNyYy52aXNpYmxlIHx8IGFscGhhID09PSAwIHx8ICFmcmFtZS5jdXRXaWR0aCB8fCAhZnJhbWUuY3V0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB2YXIgdmVydHMgPSBzcmMudHJhbnNmb3JtLmdldFZlcnRleERhdGEoaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIHJlbmRlcmVyKTtcclxuICAgIC8vIHZhciBpbmRleCA9IHNyYy5mcmFtZS5zb3VyY2UuZ2xUZXh0dXJlSW5kZXg7XHJcbiAgICAvLyB2YXIgdGludCA9IHNyYy5jb2xvci5fZ2xUaW50O1xyXG4gICAgLy8gdmFyIGJnID0gc3JjLmNvbG9yLl9nbEJnO1xyXG4gICAgLy8gcmVuZGVyZXIuYmF0Y2guYWRkKGZyYW1lLnNvdXJjZSwgc3JjLmJsZW5kTW9kZSwgdmVydHMsIGZyYW1lLnV2cywgaW5kZXgsIGFscGhhLCB0aW50LCBiZyk7XHJcblxyXG4gICAgdmFyIHRyYW5zZm9ybSA9IHNyYy50cmFuc2Zvcm07XHJcblxyXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkKFxyXG4gICAgICAgIDAsIDAsXHJcbiAgICAgICAgZnJhbWUuY3V0V2lkdGgsIGZyYW1lLmN1dEhlaWdodCxcclxuICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgIHRyYW5zZm9ybS53b3JsZC50eCwgdHJhbnNmb3JtLndvcmxkLnR5LFxyXG4gICAgICAgIHRyYW5zZm9ybS5fd29ybGRTY2FsZVgsIHRyYW5zZm9ybS5fd29ybGRTY2FsZVksXHJcbiAgICAgICAgdHJhbnNmb3JtLl93b3JsZFJvdGF0aW9uXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGNpcmNsZSlcclxue1xyXG4gICAgcmV0dXJuIChjaXJjbGUucmFkaXVzID4gMCkgPyBNYXRoLlBJICogY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMgOiAwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENpcmN1bWZlcmVuY2UgPSBmdW5jdGlvbiAoY2lyY2xlKVxyXG57XHJcbiAgICByZXR1cm4gMiAqIChNYXRoLlBJICogY2lyY2xlLnJhZGl1cyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmN1bWZlcmVuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBSZXR1cm5zIGEgUG9pbnQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgb24gdGhlIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIENpcmNsZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gYW5nbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlLmNpcmN1bWZlcmVuY2VQb2ludFxyXG4qIEBwYXJhbSB7UGhhc2VyLkNpcmNsZX0gYSAtIFRoZSBmaXJzdCBDaXJjbGUgb2JqZWN0LlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zICh1bmxlc3MgYXNEZWdyZWVzIGlzIHRydWUpIHRvIHJldHVybiB0aGUgcG9pbnQgZnJvbS5cclxuKiBAcGFyYW0ge1BoYXNlci5Qb2ludH0gW291dF0gLSBBbiBvcHRpb25hbCBQb2ludCBvYmplY3QgdG8gcHV0IHRoZSByZXN1bHQgaW4gdG8uIElmIG5vbmUgc3BlY2lmaWVkIGEgbmV3IFBvaW50IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBUaGUgUG9pbnQgb2JqZWN0IGhvbGRpbmcgdGhlIHJlc3VsdC5cclxuKi9cclxudmFyIENpcmN1bWZlcmVuY2VQb2ludCA9IGZ1bmN0aW9uIChjaXJjbGUsIGFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XHJcbiAgICBvdXQueSA9IGNpcmNsZS55ICsgKGNpcmNsZS5yYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmN1bWZlcmVuY2VQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZVBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY2xlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IENpcmNsZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS5yYWRpdXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhjaXJjbGUsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNQb2ludC5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1JlY3QgPSBmdW5jdGlvbiAoY2lyY2xlLCByZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIENvbnRhaW5zKGNpcmNsZSwgcmVjdC54LCByZWN0LnkpICYmXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LnJpZ2h0LCByZWN0LnkpICYmXHJcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGNpcmNsZSwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1JlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS5yYWRpdXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGNpcmNsZSwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGNpcmNsZS54ID09PSB0b0NvbXBhcmUueCAmJlxyXG4gICAgICAgIGNpcmNsZS55ID09PSB0b0NvbXBhcmUueSAmJlxyXG4gICAgICAgIGNpcmNsZS5yYWRpdXMgPT09IHRvQ29tcGFyZS5yYWRpdXNcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxuXHJcbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICBvdXQueCA9IGNpcmNsZS5sZWZ0O1xyXG4gICAgb3V0LnkgPSBjaXJjbGUudG9wO1xyXG4gICAgb3V0LndpZHRoID0gY2lyY2xlLmRpYW1ldGVyO1xyXG4gICAgb3V0LmhlaWdodCA9IGNpcmNsZS5kaWFtZXRlcjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRCb3VuZHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qcyIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoY2lyY2xlLCB4LCB5KVxyXG57XHJcbiAgICBjaXJjbGUueCArPSB4O1xyXG4gICAgY2lyY2xlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gY2lyY2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChjaXJjbGUsIHBvaW50KVxyXG57XHJcbiAgICBjaXJjbGUueCArPSBwb2ludC54O1xyXG4gICAgY2lyY2xlLnkgKz0gcG9pbnQueTtcclxuXHJcbiAgICByZXR1cm4gY2lyY2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyBhIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gcG9pbnQgZnJvbSBhbnl3aGVyZSB3aXRoaW4gdGhpcyBDaXJjbGUuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI3JhbmRvbVxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fG9iamVjdH0gW291dF0gLSBBIFBoYXNlci5Qb2ludCwgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllcywgdGhhdCB0aGUgdmFsdWVzIHdpbGwgYmUgc2V0IGluLlxyXG4qICAgICBJZiBubyBvYmplY3QgaXMgcHJvdmlkZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuIEluIGhpZ2ggcGVyZm9ybWFuY2UgYXJlYXMgYXZvaWQgdGhpcyBieSByZS11c2luZyBhbiBleGlzdGluZyBvYmplY3QuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmFuZG9tIHBvaW50IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciB1ID0gTWF0aC5yYW5kb20oKSArIE1hdGgucmFuZG9tKCk7XHJcbiAgICB2YXIgciA9ICh1ID4gMSkgPyAyIC0gdSA6IHU7XHJcbiAgICB2YXIgeCA9IHIgKiBNYXRoLmNvcyh0KTtcclxuICAgIHZhciB5ID0gciAqIE1hdGguc2luKHQpO1xyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoeCAqIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgb3V0LnkgPSBjaXJjbGUueSArICh5ICogY2lyY2xlLnJhZGl1cyk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9SYW5kb20uanMiLCIvLyAgUGhhc2VyLkdlb20uQ2lyY2xlXHJcblxyXG52YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcclxuXHJcbkNpcmNsZS5BcmVhID0gcmVxdWlyZSgnLi9BcmVhJyk7XHJcbkNpcmNsZS5DaXJjdW1mZXJlbmNlID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlJyk7XHJcbkNpcmNsZS5DaXJjdW1mZXJlbmNlUG9pbnQgPSByZXF1aXJlKCcuL0NpcmN1bWZlcmVuY2VQb2ludCcpO1xyXG5DaXJjbGUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcbkNpcmNsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuQ2lyY2xlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuQ2lyY2xlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XHJcbkNpcmNsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuQ2lyY2xlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XHJcbkNpcmNsZS5HZXRCb3VuZHMgPSByZXF1aXJlKCcuL0dldEJvdW5kcycpO1xyXG5DaXJjbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuQ2lyY2xlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xyXG5DaXJjbGUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL2luZGV4LmpzIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAoZWxsaXBzZSlcclxue1xyXG4gICAgaWYgKGVsbGlwc2UuaXNFbXB0eSgpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICB1bml0cyBzcXVhcmVkXHJcbiAgICByZXR1cm4gKGVsbGlwc2UuZ2V0TWFqb3JSYWRpdXMoKSAqIGVsbGlwc2UuZ2V0TWlub3JSYWRpdXMoKSAqIE1hdGguUEkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEVsbGlwc2Uoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhlbGxpcHNlLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1JlY3QgPSBmdW5jdGlvbiAoZWxsaXBzZSwgcmVjdClcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LngsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LnJpZ2h0LCByZWN0LnkpICYmXHJcbiAgICAgICAgQ29udGFpbnMoZWxsaXBzZSwgcmVjdC54LCByZWN0LmJvdHRvbSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanMiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtFbGxpcHNlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGVsbGlwc2UueCA9PT0gdG9Db21wYXJlLnggJiZcclxuICAgICAgICBlbGxpcHNlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgZWxsaXBzZS53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXHJcbiAgICAgICAgZWxsaXBzZS5oZWlnaHQgPT09IHRvQ29tcGFyZS5oZWlnaHRcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0Qm91bmRzID0gZnVuY3Rpb24gKGVsbGlwc2UsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxyXG5cclxuICAgIG91dC54ID0gZWxsaXBzZS54IC0gZWxsaXBzZS53aWR0aDtcclxuICAgIG91dC55ID0gZWxsaXBzZS55IC0gZWxsaXBzZS5oZWlnaHQ7XHJcbiAgICBvdXQud2lkdGggPSBlbGxpcHNlLndpZHRoO1xyXG4gICAgb3V0LmhlaWdodCA9IGVsbGlwc2UuaGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHgsIHkpXHJcbntcclxuICAgIGVsbGlwc2UueCArPSB4O1xyXG4gICAgZWxsaXBzZS55ICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIGVsbGlwc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcclxue1xyXG4gICAgZWxsaXBzZS54ICs9IHBvaW50Lng7XHJcbiAgICBlbGxpcHNlLnkgKz0gcG9pbnQueTtcclxuXHJcbiAgICByZXR1cm4gZWxsaXBzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0UG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGVsbGlwc2UsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICB2YXIgcyA9IE1hdGguc3FydChNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICBvdXQueCA9IGVsbGlwc2UueCArICgocyAqIE1hdGguY29zKHApKSAqIGVsbGlwc2Uud2lkdGggLyAyKTtcclxuICAgIG91dC55ID0gZWxsaXBzZS55ICsgKChzICogTWF0aC5zaW4ocCkpICogZWxsaXBzZS5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwiLy8gIFBoYXNlci5HZW9tLkVsbGlwc2VcclxuXHJcbnZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XHJcblxyXG5FbGxpcHNlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuRWxsaXBzZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuRWxsaXBzZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuRWxsaXBzZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XHJcbkVsbGlwc2UuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcclxuRWxsaXBzZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuRWxsaXBzZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5FbGxpcHNlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XHJcbkVsbGlwc2UuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuRWxsaXBzZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcclxuRWxsaXBzZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbGxpcHNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ2YXIgR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XHJcbnZhciBGaW5kVCA9IHJlcXVpcmUoJy4vRmluZFQnKTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBhbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIGN1cnZlcyB0YW5nZW50IGF0IHRoZSBnaXZlbiBwaXhlbCBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmVzIGxlbmd0aC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0QW5nbGVXaXRoRGlzdGFuY2VcclxuKiBAcGFyYW0ge251bWJlcn0gW2Rpc3RhbmNlPTBdIC0gVGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0byBnZXQgdGhlIGFuZ2xlIGZyb20sIGluIHBpeGVscy5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB0aGUgbGluZSBhdCB0aGUgc3BlY2lmaWVkIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZS4gVGhlIHZhbHVlIGlzIGluIHJhZGlhbnMuXHJcbiovXHJcbnZhciBHZXRBbmdsZVdpdGhEaXN0YW5jZSA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGlzdGFuY2UpXHJcbntcclxuICAgIGlmIChkaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7IGRpc3RhbmNlID0gMDsgfVxyXG5cclxuICAgIGlmIChkaXN0YW5jZSA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuX3YxeSwgdGhpcy5fdjF4KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gR2V0QW5nbGUoY3VydmUsIEZpbmRUKGN1cnZlLCBkaXN0YW5jZSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZVdpdGhEaXN0YW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzIiwiLyoqXHJcbiogR2V0IHRoZSBhbmdsZSBvZiB0aGUgY3VydmVzIGVudHJ5IHBvaW50LlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRFbnRyeVRhbmdlbnRcclxuKiBAcGFyYW0ge1BoYXNlci5Qb2ludHxPYmplY3R9IHBvaW50IC0gVGhlIFBoYXNlci5Qb2ludCBvYmplY3QsIG9yIGFuIE9iamVjdCB3aXRoIHB1YmxpYyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLCBpbiB3aGljaCB0aGUgdGFuZ2VudCB2ZWN0b3IgdmFsdWVzIHdpbGwgYmUgc3RvcmVkLlxyXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgdGFuZ2VudCB2ZWN0b3Igb2YgdGhpcyBIZXJtaXRlIGN1cnZlLlxyXG4qL1xyXG52YXIgR2V0RW50cnlUYW5nZW50ID0gZnVuY3Rpb24gKGN1cnZlLCBwb2ludClcclxue1xyXG4gICAgcG9pbnQueCA9IGN1cnZlLl92MXg7XHJcbiAgICBwb2ludC55ID0gY3VydmUuX3YxeTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEVudHJ5VGFuZ2VudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0dldEVudHJ5VGFuZ2VudC5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcbnZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcclxudmFyIEZpbmRUID0gcmVxdWlyZSgnLi9GaW5kVCcpO1xyXG5cclxuLyoqXHJcbiogR2V0IGEgcG9pbnQgb24gdGhlIGN1cnZlIHVzaW5nIHRoZSBkaXN0YW5jZSwgaW4gcGl4ZWxzLCBhbG9uZyB0aGUgY3VydmUuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50V2l0aERpc3RhbmNlXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbZGlzdGFuY2U9MF0gLSBUaGUgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIHRvIGdldCB0aGUgcG9pbnQgZnJvbSwgZ2l2ZW4gaW4gcGl4ZWxzLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gW3BvaW50XSAtIEFuIG9wdGlvbmFsIFBoYXNlci5Qb2ludCwgb3IgT2JqZWN0IGNvbnRhaW5pbmcgcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIGdpdmVuIHRoZSByZXN1bHRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBPYmplY3RzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIG9taXR0ZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCBpcyBjcmVhdGVkLlxyXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gVGhlIHBvaW50IG9uIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgY3VydmUuXHJcbiovXHJcbnZhciBHZXRQb2ludFdpdGhEaXN0YW5jZSA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGlzdGFuY2UsIG91dClcclxue1xyXG4gICAgaWYgKGRpc3RhbmNlID09PSB1bmRlZmluZWQpIHsgZGlzdGFuY2UgPSAwOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBpZiAoZGlzdGFuY2UgPD0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHRoaXMuX3AxeDtcclxuICAgICAgICBvdXQueSA9IHRoaXMuX3AxeTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBHZXRQb2ludChjdXJ2ZSwgRmluZFQoY3VydmUsIGRpc3RhbmNlKSwgb3V0KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnRXaXRoRGlzdGFuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qcyIsIi8qKlxyXG4qIEdldCB0aGUgWCBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUsIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRYXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCBhIHBvaW50LiBUaGlzIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSBhbmQgMSB0aGUgZW5kLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIFggY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLlxyXG4qL1xyXG52YXIgR2V0WCA9IGZ1bmN0aW9uIChjdXJ2ZSwgdClcclxue1xyXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICB0ID0gMDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAodCA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0ID4gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgIHZhciB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICByZXR1cm4gKHQzICogY3VydmUuX2F4ICsgdDIgKiBjdXJ2ZS5fYnggKyB0ICogY3VydmUuX3YxeCArIGN1cnZlLl9wMXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEdldCB0aGUgWSBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUsIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRZXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCBhIHBvaW50LiBUaGlzIGlzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZSBhbmQgMSB0aGUgZW5kLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIFkgY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLlxyXG4qL1xyXG52YXIgR2V0WSA9IGZ1bmN0aW9uIChjdXJ2ZSwgdClcclxue1xyXG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICB0ID0gMDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAodCA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0ID4gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdDIgPSB0ICogdDtcclxuICAgIHZhciB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICByZXR1cm4gKHQzICogY3VydmUuX2F5ICsgdDIgKiBjdXJ2ZS5fYnkgKyB0ICogY3VydmUuX3YxeSArIGN1cnZlLl9wMXkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WS5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG4vKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBhdXRob3IgICAgICAgUGV0ZSBCYXJvbiA8cGV0ZUBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIEhlcm1pdGUgQ3VydmUgKHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lKVxyXG4qIFxyXG4qIEEgSGVybWl0ZSBjdXJ2ZSBoYXMgYSBzdGFydCBhbmQgZW5kIHBvaW50IGFuZCB0YW5nZW50IHZlY3RvcnMgZm9yIGJvdGggb2YgdGhlbS5cclxuKiBUaGUgY3VydmUgd2lsbCBhbHdheXMgcGFzcyB0aHJvdWdoIHRoZSB0d28gY29udHJvbCBwb2ludHMgYW5kIHRoZSBzaGFwZSBvZiBpdCBpcyBjb250cm9sbGVkXHJcbiogYnkgdGhlIGxlbmd0aCBhbmQgZGlyZWN0aW9uIG9mIHRoZSB0YW5nZW50IHZlY3RvcnMuICBBdCB0aGUgY29udHJvbCBwb2ludHMgdGhlIGN1cnZlIHdpbGxcclxuKiBiZSBmYWNpbmcgZXhhY3RseSBpbiB0aGUgdmVjdG9yIGRpcmVjdGlvbi5cclxuKiBcclxuKiBBcyB0aGVzZSBjdXJ2ZXMgY2hhbmdlIHNwZWVkIChzcGVlZCA9IGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIHNlcGFyYXRlZCBieSBhbiBlcXVhbCBjaGFuZ2UgaW5cclxuKiAndCcgdmFsdWUgLSBzZWUgSGVybWl0ZS5nZXRQb2ludCkgdGhpcyBjbGFzcyBhdHRlbXB0cyB0byByZWR1Y2UgdGhlIHZhcmlhdGlvbiBieSBwcmUtY2FsY3VsYXRpbmdcclxuKiB0aGUgYGFjY3VyYWN5YCBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZS4gVGhlIHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2VzIHRvIHRoZXNlIHBvaW50cyBhcmUgc3RvcmVkXHJcbiogaW4gdGhlIHByaXZhdGUgJ3BvaW50cycgYXJyYXksIGFuZCB0aGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgYnkgSGVybWl0ZS5maW5kVCgpIHRvIGNvbnZlcnQgYSBwaXhlbFxyXG4qIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSBpbnRvIGEgJ3RpbWUnIHZhbHVlLlxyXG4qIFxyXG4qIEhpZ2hlciBgYWNjdXJhY3lgIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBtb3JlIGV2ZW4gbW92ZW1lbnQsIGJ1dCByZXF1aXJlIG1vcmUgbWVtb3J5IGZvciB0aGUgcG9pbnRzXHJcbiogbGlzdC4gNSB3b3JrcywgYnV0IDEwIHNlZW1zIHRvIGJlIGFuIGlkZWFsIHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIGN1cnZlcyBmb3VuZCBpbiBtb3N0IGdhbWVzIG9uXHJcbiogYSBkZXNrdG9wIHNjcmVlbi4gSWYgeW91IHVzZSB2ZXJ5IGxvbmcgY3VydmVzIChtb3JlIHRoYW4gNDAwIHBpeGVscykgeW91IG1heSBuZWVkIHRvIGluY3JlYXNlXHJcbiogdGhpcyB2YWx1ZSBmdXJ0aGVyLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5IZXJtaXRlXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtudW1iZXJ9IHAxeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuKiBAcGFyYW0ge251bWJlcn0gcDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBwMnggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBwMnkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2MXggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2MXkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2MnggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuKiBAcGFyYW0ge251bWJlcn0gdjJ5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFthY2N1cmFjeT0xMF0gVGhlIGFtb3VudCBvZiBwb2ludHMgdG8gcHJlLWNhbGN1bGF0ZSBvbiB0aGUgY3VydmUuXHJcbiovXHJcbnZhciBIZXJtaXRlID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBwMngsIHAyeSwgdjF4LCB2MXksIHYyeCwgdjJ5LCBhY2N1cmFjeSlcclxue1xyXG4gICAgaWYgKGFjY3VyYWN5ID09PSB1bmRlZmluZWQpIHsgYWNjdXJhY3kgPSAxMDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX2FjY3VyYWN5IC0gVGhlIGFtb3VudCBvZiBwb2ludHMgdG8gcHJlLWNhbGN1bGF0ZSBvbiB0aGUgY3VydmUuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fYWNjdXJhY3kgPSBhY2N1cmFjeTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fcDF4ID0gcDF4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3AxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wMXkgPSBwMXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wMnggPSBwMng7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wMnkgPSBwMnk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl92MXggPSB2MXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl92MXkgPSB2MXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdjJ4ID0gdjJ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3YyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3YyeSA9IHYyeTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IF9wb2ludHMgLSBBIGxvY2FsIGFycmF5IG9mIGNhY2hlZCBwb2ludHMuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fcG9pbnRzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlBvaW50fSBfdGVtcDEgLSBBIGxvY2FsIGNhY2hlZCBQb2ludCBvYmplY3QuXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdGVtcDEgPSBuZXcgUG9pbnQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IF90ZW1wMiAtIEEgbG9jYWwgY2FjaGVkIFBvaW50IG9iamVjdC5cclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl90ZW1wMiA9IG5ldyBQb2ludCgpO1xyXG5cclxuICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxufTtcclxuXHJcbkhlcm1pdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVybWl0ZTtcclxuXHJcbkhlcm1pdGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQZXJmb3JtcyB0aGUgY3VydmUgY2FsY3VsYXRpb25zLlxyXG4gICAgKlxyXG4gICAgKiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIHlvdSBjaGFuZ2UgYW55IG9mIHRoZSBjdXJ2ZXMgcHVibGljIHByb3BlcnRpZXMsIHN1Y2ggYXMgYEhlcm1pdGUucDF4YCBvciBgSGVybWl0ZS52MnlgLlxyXG4gICAgKlxyXG4gICAgKiBJZiB5b3UgYWRqdXN0IGFueSBvZiB0aGUgaW50ZXJuYWwgcHJpdmF0ZSB2YWx1ZXMsIHRoZW4gY2FsbCB0aGlzIHRvIHVwZGF0ZSB0aGUgcG9pbnRzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI3JlY2FsY3VsYXRlXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5IZXJtaXRlfSBUaGlzIG9iamVjdC5cclxuICAgICovXHJcbiAgICByZWNhbGN1bGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLl9heCA9ICgyICogdGhpcy5fcDF4IC0gMiAqIHRoaXMuX3AyeCArIHRoaXMuX3YxeCArIHRoaXMuX3YyeCk7XHJcbiAgICAgICAgdGhpcy5fYXkgPSAoMiAqIHRoaXMuX3AxeSAtIDIgKiB0aGlzLl9wMnkgKyB0aGlzLl92MXkgKyB0aGlzLl92MnkpO1xyXG4gICAgICAgIHRoaXMuX2J4ID0gKC0zICogdGhpcy5fcDF4ICsgMyAqIHRoaXMuX3AyeCAtIDIgKiB0aGlzLl92MXggLSB0aGlzLl92MngpO1xyXG4gICAgICAgIHRoaXMuX2J5ID0gKC0zICogdGhpcy5fcDF5ICsgMyAqIHRoaXMuX3AyeSAtIDIgKiB0aGlzLl92MXkgLSB0aGlzLl92MnkpO1xyXG5cclxuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuY2FsY3VsYXRlRXZlblBvaW50cygpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYWxjdWxhdGUgYSBudW1iZXIgb2YgcG9pbnRzIGFsb25nIHRoZSBjdXJ2ZSwgYmFzZWQgb24gYEhlcm1pdGUuYWNjdXJhY3lgLCBhbmQgc3RvcmVzIHRoZW0gaW4gdGhlIHByaXZhdGUgYF9wb2ludHNgIGFycmF5LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2NhbGN1bGF0ZUV2ZW5Qb2ludHNcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBjdXJ2ZSBhcHByb3hpbWF0ZWQgYXMgc3RyYWlnaHQgbGluZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgcG9pbnRzLlxyXG4gICAgKi9cclxuICAgIGNhbGN1bGF0ZUV2ZW5Qb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5fdGVtcDEuc2V0VG8oMCwgMCk7ICAgICAgICAgICAgICAgICAgICAvLyAgcG50XHJcbiAgICAgICAgdGhpcy5fdGVtcDIuc2V0VG8odGhpcy5fcDF4LCB0aGlzLl9wMXkpOyAgICAvLyAgbGFzdFBudFxyXG5cclxuICAgICAgICB0aGlzLl9wb2ludHNbMF0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLl9hY2N1cmFjeTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRQb2ludChpIC8gdGhpcy5fYWNjdXJhY3ksIHRoaXMuX3RlbXAxKTtcclxuICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gdGhpcy5fdGVtcDEuZGlzdGFuY2UodGhpcy5fdGVtcDIpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0b3RhbExlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcDIuY29weUZyb20odGhpcy5fdGVtcDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZXJtaXRlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNhY2N1cmFjeVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gYWNjdXJhY3kgLSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBhY2N1cmFjeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWNjdXJhY3k7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FjY3VyYWN5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2N1cmFjeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AxeFxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDF4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXHJcbiAgICAqL1xyXG4gICAgcDF4OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3AxeDtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDF4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wMXggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDF5XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwMXkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBwMXk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDF5O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AxeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMnhcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBwMng6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDJ4O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AyeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMnlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAyeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICBwMnk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDJ5O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3AyeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MXhcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYxeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICB2MXg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjF4O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3YxeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MXlcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cclxuICAgICovXHJcbiAgICB2MXk6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjF5O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3YxeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MnhcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYyeCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXHJcbiAgICAqL1xyXG4gICAgdjJ4OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyeDtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdjJ4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92MnggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjJ5XHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2MnkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxyXG4gICAgKi9cclxuICAgIHYyeToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92Mnk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YyeSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdjJ5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZXJtaXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzIiwiLy8gIFBoYXNlci5HZW9tLkhlcm1pdGVcclxuXHJcbnZhciBIZXJtaXRlID0gcmVxdWlyZSgnLi9IZXJtaXRlJyk7XHJcblxyXG5IZXJtaXRlLkZpbmRUID0gcmVxdWlyZSgnLi9GaW5kVCcpO1xyXG5IZXJtaXRlLkdldEFuZ2xlID0gcmVxdWlyZSgnLi9HZXRBbmdsZScpO1xyXG5IZXJtaXRlLkdldEFuZ2xlV2l0aERpc3RhbmNlID0gcmVxdWlyZSgnLi9HZXRBbmdsZVdpdGhEaXN0YW5jZScpO1xyXG5IZXJtaXRlLkdldEVudHJ5VGFuZ2VudCA9IHJlcXVpcmUoJy4vR2V0RW50cnlUYW5nZW50Jyk7XHJcbkhlcm1pdGUuR2V0UG9pbnQgPSByZXF1aXJlKCcuL0dldFBvaW50Jyk7XHJcbkhlcm1pdGUuR2V0UG9pbnRXaXRoRGlzdGFuY2UgPSByZXF1aXJlKCcuL0dldFBvaW50V2l0aERpc3RhbmNlJyk7XHJcbkhlcm1pdGUuR2V0WCA9IHJlcXVpcmUoJy4vR2V0WCcpO1xyXG5IZXJtaXRlLkdldFkgPSByZXF1aXJlKCcuL0dldFknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGVybWl0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwidmFyIERpc3RhbmNlQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuJyk7XHJcblxyXG52YXIgQ2lyY2xlVG9DaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlQSwgY2lyY2xlQilcclxue1xyXG4gICAgcmV0dXJuIChEaXN0YW5jZUJldHdlZW4oY2lyY2xlQS54LCBjaXJjbGVBLnksIGNpcmNsZUIueCwgY2lyY2xlQi55KSA8PSAoY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cykpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVUb0NpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzIiwidmFyIENpcmNsZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGNpcmNsZSwgcmVjdClcclxue1xyXG4gICAgdmFyIGhhbGZXaWR0aCA9IHJlY3Qud2lkdGggLyAyO1xyXG4gICAgdmFyIGhhbGZIZWlnaHQgPSByZWN0LmhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIGN4ID0gTWF0aC5hYnMoY2lyY2xlLnggLSByZWN0LnggLSBoYWxmV2lkdGgpO1xyXG4gICAgdmFyIHhEaXN0ID0gaGFsZldpZHRoICsgY2lyY2xlLnJhZGl1cztcclxuXHJcbiAgICBpZiAoY3ggPD0gaGFsZldpZHRoIHx8IGN4ID4geERpc3QpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjeSA9IE1hdGguYWJzKGNpcmNsZS55IC0gcmVjdC55IC0gaGFsZkhlaWdodCk7XHJcbiAgICB2YXIgeURpc3QgPSBoYWxmSGVpZ2h0ICsgY2lyY2xlLnJhZGl1cztcclxuXHJcbiAgICBpZiAoY3kgPD0gaGFsZkhlaWdodCB8fCBjeSA+IHlEaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeENvcm5lckRpc3QgPSBjeCAtIGhhbGZXaWR0aDtcclxuICAgIHZhciB5Q29ybmVyRGlzdCA9IGN5IC0gaGFsZkhlaWdodDtcclxuICAgIHZhciB4Q29ybmVyRGlzdFNxID0geENvcm5lckRpc3QgKiB4Q29ybmVyRGlzdDtcclxuICAgIHZhciB5Q29ybmVyRGlzdFNxID0geUNvcm5lckRpc3QgKiB5Q29ybmVyRGlzdDtcclxuICAgIHZhciBtYXhDb3JuZXJEaXN0U3EgPSBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cztcclxuXHJcbiAgICByZXR1cm4gKHhDb3JuZXJEaXN0U3EgKyB5Q29ybmVyRGlzdFNxIDw9IG1heENvcm5lckRpc3RTcSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZVRvUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG52YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZVRvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgaWYgKFJlY3RhbmdsZVRvUmVjdGFuZ2xlKHJlY3RBLCByZWN0QikpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnggPSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcclxuICAgICAgICBvdXRwdXQueSA9IE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xyXG4gICAgICAgIG91dHB1dC53aWR0aCA9IE1hdGgubWluKHJlY3RBLnJpZ2h0LCByZWN0Qi5yaWdodCkgLSBvdXRwdXQueDtcclxuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0gTWF0aC5taW4ocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0gb3V0cHV0Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgTGluZVRvTGluZSA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIsIGFzU2VnbWVudCwgb3V0KVxyXG57XHJcbiAgICBpZiAoYXNTZWdtZW50ID09PSB1bmRlZmluZWQpIHsgYXNTZWdtZW50ID0gdHJ1ZTsgfVxyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGEgPSBsaW5lMS54MTtcclxuICAgIHZhciBiID0gbGluZTEueTE7XHJcblxyXG4gICAgdmFyIGUgPSBsaW5lMS54MjtcclxuICAgIHZhciBmID0gbGluZTEueTI7XHJcblxyXG4gICAgdmFyIGExID0gYi55IC0gYS55O1xyXG4gICAgdmFyIGEyID0gZi55IC0gZS55O1xyXG4gICAgdmFyIGIxID0gYS54IC0gYi54O1xyXG4gICAgdmFyIGIyID0gZS54IC0gZi54O1xyXG4gICAgdmFyIGMxID0gKGIueCAqIGEueSkgLSAoYS54ICogYi55KTtcclxuICAgIHZhciBjMiA9IChmLnggKiBlLnkpIC0gKGUueCAqIGYueSk7XHJcbiAgICB2YXIgZGVub20gPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XHJcblxyXG4gICAgaWYgKGRlbm9tID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIG91dC54ID0gKChiMSAqIGMyKSAtIChiMiAqIGMxKSkgLyBkZW5vbTtcclxuICAgIG91dC55ID0gKChhMiAqIGMxKSAtIChhMSAqIGMyKSkgLyBkZW5vbTtcclxuXHJcbiAgICBpZiAoYXNTZWdtZW50KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB1YyA9ICgoZi55IC0gZS55KSAqIChiLnggLSBhLngpIC0gKGYueCAtIGUueCkgKiAoYi55IC0gYS55KSk7XHJcbiAgICAgICAgdmFyIHVhID0gKCgoZi54IC0gZS54KSAqIChhLnkgLSBlLnkpKSAtIChmLnkgLSBlLnkpICogKGEueCAtIGUueCkpIC8gdWM7XHJcbiAgICAgICAgdmFyIHViID0gKCgoYi54IC0gYS54KSAqIChhLnkgLSBlLnkpKSAtICgoYi55IC0gYS55KSAqIChhLnggLSBlLngpKSkgLyB1YztcclxuXHJcbiAgICAgICAgaWYgKHVhID49IDAgJiYgdWEgPD0gMSAmJiB1YiA+PSAwICYmIHViIDw9IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZVRvTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qcyIsIi8qKlxyXG4qIENoZWNrcyBmb3IgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIExpbmUgYW5kIGEgUmVjdGFuZ2xlIHNoYXBlLCBvciBhIHJlY3RhbmdsZS1saWtlXHJcbiogb2JqZWN0LCB3aXRoIHB1YmxpYyBgeGAsIGB5YCwgYHJpZ2h0YCBhbmQgYGJvdHRvbWAgcHJvcGVydGllcywgc3VjaCBhcyBhIFNwcml0ZSBvciBCb2R5LlxyXG4qXHJcbiogQW4gaW50ZXJzZWN0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQgaWY6XHJcbipcclxuKiBUaGUgbGluZSBzdGFydHMgd2l0aGluLCBvciBlbmRzIHdpdGhpbiwgdGhlIFJlY3RhbmdsZS5cclxuKiBUaGUgbGluZSBzZWdtZW50IGludGVyc2VjdHMgb25lIG9mIHRoZSA0IHJlY3RhbmdsZSBlZGdlcy5cclxuKlxyXG4qIFRoZSBmb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZnVuY3Rpb24gcmVjdGFuZ2xlcyBhcmUgY29uc2lkZXJlZCAnc29saWQnLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTGluZS5pbnRlcnNlY3RzUmVjdGFuZ2xlXHJcbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gbGluZSAtIFRoZSBsaW5lIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aC5cclxuKiBAcGFyYW0ge1BoYXNlci5SZWN0YW5nbGV8b2JqZWN0fSByZWN0IC0gVGhlIHJlY3RhbmdsZSwgb3IgcmVjdGFuZ2xlLWxpa2Ugb2JqZWN0LCB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGguXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbGluZSBpbnRlcnNlY3RzIHdpdGggdGhlIHJlY3RhbmdsZSBlZGdlcywgb3Igc3RhcnRzIG9yIGVuZHMgd2l0aGluIHRoZSByZWN0YW5nbGUuXHJcbiovXHJcbnZhciBMaW5lVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAobGluZSwgcmVjdClcclxue1xyXG4gICAgdmFyIHgxID0gbGluZS54MTtcclxuICAgIHZhciB5MSA9IGxpbmUueTI7XHJcblxyXG4gICAgdmFyIHgyID0gbGluZS54MjtcclxuICAgIHZhciB5MiA9IGxpbmUueTI7XHJcblxyXG4gICAgdmFyIGJ4MSA9IHJlY3QueDtcclxuICAgIHZhciBieTEgPSByZWN0Lnk7XHJcbiAgICB2YXIgYngyID0gcmVjdC5yaWdodDtcclxuICAgIHZhciBieTIgPSByZWN0LmJvdHRvbTtcclxuXHJcbiAgICB2YXIgdCA9IDA7XHJcblxyXG4gICAgLy8gIElmIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGxpbmUgaXMgaW5zaWRlIHRoZSByZWN0IHRoZW4gd2UgYXNzdW1lXHJcbiAgICAvLyAgY29sbGlzaW9uLCBhcyByZWN0cyBhcmUgc29saWQgZm9yIG91ciB1c2UtY2FzZS5cclxuXHJcbiAgICBpZiAoKHgxID49IGJ4MSAmJiB4MSA8PSBieDIgJiYgeTEgPj0gYnkxICYmIHkxIDw9IGJ5MikgfHxcclxuICAgICAgICAoeDIgPj0gYngxICYmIHgyIDw9IGJ4MiAmJiB5MiA+PSBieTEgJiYgeTIgPD0gYnkyKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeDEgPCBieDEgJiYgeDIgPj0gYngxKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBMZWZ0IGVkZ2VcclxuICAgICAgICB0ID0geTEgKyAoeTIgLSB5MSkgKiAoYngxIC0geDEpIC8gKHgyIC0geDEpO1xyXG5cclxuICAgICAgICBpZiAodCA+IGJ5MSAmJiB0IDw9IGJ5MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHgxID4gYngyICYmIHgyIDw9IGJ4MilcclxuICAgIHtcclxuICAgICAgICAvLyAgUmlnaHQgZWRnZVxyXG4gICAgICAgIHQgPSB5MSArICh5MiAtIHkxKSAqIChieDIgLSB4MSkgLyAoeDIgLSB4MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID49IGJ5MSAmJiB0IDw9IGJ5MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoeTEgPCBieTEgJiYgeTIgPj0gYnkxKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUb3AgZWRnZVxyXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTEgLSB5MSkgLyAoeTIgLSB5MSk7XHJcblxyXG4gICAgICAgIGlmICh0ID49IGJ4MSAmJiB0IDw9IGJ4MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHkxID4gYnkyICYmIHkyIDw9IGJ5MilcclxuICAgIHtcclxuICAgICAgICAvLyAgQm90dG9tIGVkZ2VcclxuICAgICAgICB0ID0geDEgKyAoeDIgLSB4MSkgKiAoYnkyIC0geTEpIC8gKHkyIC0geTEpO1xyXG5cclxuICAgICAgICBpZiAodCA+PSBieDEgJiYgdCA8PSBieDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnRUb0xpbmUgPSByZXF1aXJlKCcuL1BvaW50VG9MaW5lJyk7XHJcblxyXG52YXIgUG9pbnRUb0xpbmVTZWdtZW50ID0gZnVuY3Rpb24gKHBvaW50LCBsaW5lKVxyXG57XHJcbiAgICBpZiAoIVBvaW50VG9MaW5lKHBvaW50LCBsaW5lKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhNaW4gPSBNYXRoLm1pbihsaW5lLngxLCBsaW5lLngyKTtcclxuICAgIHZhciB4TWF4ID0gTWF0aC5tYXgobGluZS54MSwgbGluZS54Mik7XHJcbiAgICB2YXIgeU1pbiA9IE1hdGgubWluKGxpbmUueTEsIGxpbmUueTIpO1xyXG4gICAgdmFyIHlNYXggPSBNYXRoLm1heChsaW5lLnkxLCBsaW5lLnkyKTtcclxuXHJcbiAgICByZXR1cm4gKChwb2ludC54ID49IHhNaW4gJiYgcG9pbnQueCA8PSB4TWF4KSAmJiAocG9pbnQueSA+PSB5TWluICYmIHBvaW50LnkgPD0geU1heCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFRvTGluZVNlZ21lbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwidmFyIFJlY3RhbmdsZVRvVmFsdWVzID0gZnVuY3Rpb24gKHJlY3QsIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdG9sZXJhbmNlKVxyXG57XHJcbiAgICBpZiAodG9sZXJhbmNlID09PSB1bmRlZmluZWQpIHsgdG9sZXJhbmNlID0gMDsgfVxyXG5cclxuICAgIHJldHVybiAhKFxyXG4gICAgICAgIGxlZnQgPiByZWN0LnJpZ2h0ICsgdG9sZXJhbmNlIHx8XHJcbiAgICAgICAgcmlnaHQgPCByZWN0LmxlZnQgLSB0b2xlcmFuY2UgfHxcclxuICAgICAgICB0b3AgPiByZWN0LmJvdHRvbSArIHRvbGVyYW5jZSB8fFxyXG4gICAgICAgIGJvdHRvbSA8IHJlY3QudG9wIC0gdG9sZXJhbmNlXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1ZhbHVlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENpcmNsZVRvQ2lyY2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvQ2lyY2xlJyksXHJcbiAgICBDaXJjbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9DaXJjbGVUb1JlY3RhbmdsZScpLFxyXG4gICAgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uOiByZXF1aXJlKCcuL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbicpLFxyXG4gICAgTGluZVRvTGluZTogcmVxdWlyZSgnLi9MaW5lVG9MaW5lJyksXHJcbiAgICBMaW5lVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vTGluZVRvUmVjdGFuZ2xlJyksXHJcbiAgICBQb2ludFRvTGluZTogcmVxdWlyZSgnLi9Qb2ludFRvTGluZScpLFxyXG4gICAgUG9pbnRUb0xpbmVTZWdtZW50OiByZXF1aXJlKCcuL1BvaW50VG9MaW5lU2VnbWVudCcpLFxyXG4gICAgUmVjdGFuZ2xlVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9SZWN0YW5nbGUnKSxcclxuICAgIFJlY3RhbmdsZVRvVmFsdWVzOiByZXF1aXJlKCcuL1JlY3RhbmdsZVRvVmFsdWVzJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIlxyXG52YXIgQ2VudGVyT24gPSBmdW5jdGlvbiAobGluZSwgeCwgeSlcclxue1xyXG4gICAgdmFyIHR4ID0geCAtICgobGluZS54MSArIGxpbmUueDIpIC8gMik7XHJcbiAgICB2YXIgdHkgPSB5IC0gKChsaW5lLnkxICsgbGluZS55MikgLyAyKTtcclxuXHJcbiAgICBsaW5lLngxICs9IHR4O1xyXG4gICAgbGluZS55MSArPSB0eTtcclxuXHJcbiAgICBsaW5lLngyICs9IHR4O1xyXG4gICAgbGluZS55MiArPSB0eTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9DZW50ZXJPbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lID0gcmVxdWlyZSgnLi9MaW5lJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IExpbmUoc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9DbG9uZS5qcyIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChsaW5lLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgbGluZS54MSA9PT0gdG9Db21wYXJlLngxICYmXHJcbiAgICAgICAgbGluZS55MSA9PT0gdG9Db21wYXJlLnkxICYmXHJcbiAgICAgICAgbGluZS54MiA9PT0gdG9Db21wYXJlLngyICYmXHJcbiAgICAgICAgbGluZS55MiA9PT0gdG9Db21wYXJlLnkyXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIEdldE1pZFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgb3V0LnggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcclxuICAgIG91dC55ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWlkUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9HZXRNaWRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgR2V0Tm9ybWFsID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGEgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xyXG5cclxuICAgIG91dC54ID0gTWF0aC5jb3MoYSk7XHJcbiAgICBvdXQueSA9IE1hdGguc2luKGEpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE5vcm1hbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldE5vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCIvKipcclxuKiBVc2luZyBCcmVzZW5oYW0ncyBsaW5lIGFsZ29yaXRobSB0aGlzIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcyBvbiB0aGlzIGxpbmUuXHJcbiogVGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSByb3VuZGVkIGJlZm9yZSB0aGlzIHJ1bnMgYXMgdGhlIGFsZ29yaXRobSB3b3JrcyBvbiBpbnRlZ2Vycy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUjY29vcmRpbmF0ZXNPbkxpbmVcclxuKiBAcGFyYW0ge251bWJlcn0gW3N0ZXBSYXRlPTFdIC0gSG93IG1hbnkgc3RlcHMgd2lsbCB3ZSByZXR1cm4/IDEgPSBldmVyeSBjb29yZGluYXRlIG9uIHRoZSBsaW5lLCAyID0gZXZlcnkgb3RoZXIgY29vcmRpbmF0ZSwgZXRjLlxyXG4qIEBwYXJhbSB7YXJyYXl9IFtyZXN1bHRzXSAtIFRoZSBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9uZSB3aWxsIGJlIGdlbmVyYXRlZC5cclxuKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMuXHJcbiovXHJcbnZhciBHZXRQb2ludHNPbkxpbmUgPSBmdW5jdGlvbiAobGluZSwgc3RlcFJhdGUsIHJlc3VsdHMpXHJcbntcclxuICAgIGlmIChzdGVwUmF0ZSA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBSYXRlID0gMTsgfVxyXG4gICAgaWYgKHJlc3VsdHMgPT09IHVuZGVmaW5lZCkgeyByZXN1bHRzID0gW107IH1cclxuXHJcbiAgICB2YXIgeDEgPSBNYXRoLnJvdW5kKGxpbmUueDEpO1xyXG4gICAgdmFyIHkxID0gTWF0aC5yb3VuZChsaW5lLnkxKTtcclxuICAgIHZhciB4MiA9IE1hdGgucm91bmQobGluZS54Mik7XHJcbiAgICB2YXIgeTIgPSBNYXRoLnJvdW5kKGxpbmUueTIpO1xyXG5cclxuICAgIHZhciBkeCA9IE1hdGguYWJzKHgyIC0geDEpO1xyXG4gICAgdmFyIGR5ID0gTWF0aC5hYnMoeTIgLSB5MSk7XHJcbiAgICB2YXIgc3ggPSAoeDEgPCB4MikgPyAxIDogLTE7XHJcbiAgICB2YXIgc3kgPSAoeTEgPCB5MikgPyAxIDogLTE7XHJcbiAgICB2YXIgZXJyID0gZHggLSBkeTtcclxuXHJcbiAgICByZXN1bHRzLnB1c2goWyB4MSwgeTEgXSk7XHJcblxyXG4gICAgdmFyIGkgPSAxO1xyXG5cclxuICAgIHdoaWxlICghKCh4MSA9PT0geDIpICYmICh5MSA9PT0geTIpKSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZTIgPSBlcnIgPDwgMTtcclxuXHJcbiAgICAgICAgaWYgKGUyID4gLWR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXJyIC09IGR5O1xyXG4gICAgICAgICAgICB4MSArPSBzeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlMiA8IGR4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXJyICs9IGR4O1xyXG4gICAgICAgICAgICB5MSArPSBzeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpICUgc3RlcFJhdGUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goWyB4MSwgeTEgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvaW50c09uTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIZWlnaHQgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGxpbmUueTEgLSBsaW5lLnkyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGVpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvSGVpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlbmd0aCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChsaW5lLngyIC0gbGluZS54MSkgKiAobGluZS54MiAtIGxpbmUueDEpICsgKGxpbmUueTIgLSBsaW5lLnkxKSAqIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMZW5ndGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9MZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5cclxudmFyIE5vcm1hbFggPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguY29zKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsWC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxYLmpzIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuXHJcbnZhciBOb3JtYWxZID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNpbihBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL05vcm1hbFkuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvTm9ybWFsWS5qcyIsInZhciBQZXJwU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIC0oKGxpbmUueDIgLSBsaW5lLngxKSAvIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwU2xvcGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9QZXJwU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uIChsaW5lLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciB0ID0gTWF0aC5yYW5kb20oKTtcclxuXHJcbiAgICBvdXQueCA9IGxpbmUueDEgKyB0ICogKGxpbmUueDIgLSBsaW5lLngxKTtcclxuICAgIG91dC55ID0gbGluZS55MSArIHQgKiAobGluZS55MiAtIGxpbmUueTEpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9SYW5kb20uanMiLCJ2YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcbnZhciBOb3JtYWxBbmdsZSA9IHJlcXVpcmUoJy4vTm9ybWFsQW5nbGUnKTtcclxuXHJcbi8qKlxyXG4qIFJldHVybnMgdGhlIHJlZmxlY3RlZCBhbmdsZSBiZXR3ZWVuIHR3byBsaW5lcy5cclxuKiBUaGlzIGlzIHRoZSBvdXRnb2luZyBhbmdsZSBiYXNlZCBvbiB0aGUgYW5nbGUgb2YgTGluZSAxIGFuZCB0aGUgbm9ybWFsQW5nbGUgb2YgTGluZSAyLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTGluZS5yZWZsZWN0XHJcbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gYSAtIFRoZSBiYXNlIGxpbmUuXHJcbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gYiAtIFRoZSBsaW5lIHRvIGJlIHJlZmxlY3RlZCBmcm9tIHRoZSBiYXNlIGxpbmUuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVmbGVjdGVkIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiovXHJcbnZhciBSZWZsZWN0QW5nbGUgPSBmdW5jdGlvbiAobGluZUEsIGxpbmVCKVxyXG57XHJcbiAgICByZXR1cm4gKDIgKiBOb3JtYWxBbmdsZShsaW5lQikgLSBNYXRoLlBJIC0gQW5nbGUobGluZUEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGUgPSBmdW5jdGlvbiAobGluZSwgYW5nbGUpXHJcbntcclxuICAgIHZhciB4ID0gKGxpbmUueDEgKyBsaW5lLngyKSAvIDI7XHJcbiAgICB2YXIgeSA9IChsaW5lLnkxICsgbGluZS55MikgLyAyO1xyXG5cclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWShsaW5lLCB4LCB5LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Sb3RhdGUuanMiLCJ2YXIgUm90YXRlQXJvdW5kWFkgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFhZJyk7XHJcblxyXG52YXIgUm90YXRlQXJvdW5kUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgcG9pbnQsIGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgcG9pbnQueCwgcG9pbnQueSwgYW5nbGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFBvaW50LmpzIiwidmFyIFNldFRvQW5nbGUgPSBmdW5jdGlvbiAobGluZSwgeCwgeSwgYW5nbGUsIGxlbmd0aClcclxue1xyXG4gICAgbGluZS54MSA9IHg7XHJcbiAgICBsaW5lLnkxID0geTtcclxuXHJcbiAgICBsaW5lLngyID0geCArIChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgpO1xyXG4gICAgbGluZS55MiA9IHkgKyAoTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0VG9BbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIChsaW5lLnkyIC0gbGluZS55MSkgLyAobGluZS54MiAtIGxpbmUueDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbG9wZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1Nsb3BlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdpZHRoID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhsaW5lLngxIC0gbGluZS54Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdpZHRoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvV2lkdGguanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uTGluZVxyXG5cclxudmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcclxuXHJcbkxpbmUuQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcbkxpbmUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XHJcbkxpbmUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcbkxpbmUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkxpbmUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuTGluZS5HZXRNaWRQb2ludCA9IHJlcXVpcmUoJy4vR2V0TWlkUG9pbnQnKTtcclxuTGluZS5HZXROb3JtYWwgPSByZXF1aXJlKCcuL0dldE5vcm1hbCcpO1xyXG5MaW5lLkdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRzT25MaW5lJyk7XHJcbkxpbmUuSGVpZ2h0ID0gcmVxdWlyZSgnLi9IZWlnaHQnKTtcclxuTGluZS5MZW5ndGggPSByZXF1aXJlKCcuL0xlbmd0aCcpO1xyXG5MaW5lLk5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5MaW5lLk5vcm1hbFggPSByZXF1aXJlKCcuL05vcm1hbFgnKTtcclxuTGluZS5Ob3JtYWxZID0gcmVxdWlyZSgnLi9Ob3JtYWxZJyk7XHJcbkxpbmUuUGVycFNsb3BlID0gcmVxdWlyZSgnLi9QZXJwU2xvcGUnKTtcclxuTGluZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5MaW5lLlJlZmxlY3RBbmdsZSA9IHJlcXVpcmUoJy4vUmVmbGVjdEFuZ2xlJyk7XHJcbkxpbmUuUm90YXRlID0gcmVxdWlyZSgnLi9Sb3RhdGUnKTtcclxuTGluZS5Sb3RhdGVBcm91bmRQb2ludCA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kUG9pbnQnKTtcclxuTGluZS5Sb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuTGluZS5TZXRUb0FuZ2xlID0gcmVxdWlyZSgnLi9TZXRUb0FuZ2xlJyk7XHJcbkxpbmUuU2xvcGUgPSByZXF1aXJlKCcuL1Nsb3BlJyk7XHJcbkxpbmUuV2lkdGggPSByZXF1aXJlKCcuL1dpZHRoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9pbmRleC5qcyIsInZhciBBZGQgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHkpXHJcbntcclxuICAgIHBvaW50LnggKz0geDtcclxuICAgIHBvaW50LnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9BZGQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguY2VpbChwb2ludC54KSwgTWF0aC5jZWlsKHBvaW50LnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9DZWlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludChzb3VyY2UueCwgc291cmNlLnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvQ2xvbmUuanMiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3Jvc3MgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLnkpIC0gKHBvaW50QS55ICogcG9pbnRCLngpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvQ3Jvc3MuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGl2aWRlID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxyXG57XHJcbiAgICBwb2ludC54IC89IHg7XHJcbiAgICBwb2ludC55IC89IHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaXZpZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRGl2aWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChwb2ludCwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKHBvaW50LnggPT09IHRvQ29tcGFyZS54ICYmIHBvaW50LnkgPT09IHRvQ29tcGFyZS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguZmxvb3IocG9pbnQueCksIE1hdGguZmxvb3IocG9pbnQueSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9GbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbnZhciBHZXRDZW50cm9pZCA9IGZ1bmN0aW9uIChwb2ludHMsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheScpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0Q2VudHJvaWQgcG9pbnRzIGFycmF5IG11c3Qgbm90IGJlIGVtcHR5Jyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZW4gPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnggPSBwb2ludHNbMF0ueDtcclxuICAgICAgICBvdXQueSA9IHBvaW50c1swXS55O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXQueCArPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgb3V0LnkgKz0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXQueCAvPSBsZW47XHJcbiAgICAgICAgb3V0LnkgLz0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRyb2lkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcbnZhciBJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50QiwgdCwgb3V0KVxyXG57XHJcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IHBvaW50QS54ICsgKChwb2ludEIueCAtIHBvaW50QS54KSAqIHQpO1xyXG4gICAgb3V0LnkgPSBwb2ludEEueSArICgocG9pbnRCLnkgLSBwb2ludEEueSkgKiB0KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnBvbGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvSW50ZXJwb2xhdGUuanMiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIEludmVydCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnZlcnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvSW52ZXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIE5lZ2F0aXZlID0gZnVuY3Rpb24gKHBvaW50LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHJldHVybiBvdXQuc2V0VG8oLXBvaW50LngsIC1wb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmVnYXRpdmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTmVnYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwidmFyIE5vcm1hbGl6ZVJpZ2h0SGFuZCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnkgKiAtMSwgcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZVJpZ2h0SGFuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVycCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKC1wb2ludC55LCBwb2ludC54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVycDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9QZXJwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxudmFyIEdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xyXG5cclxudmFyIFByb2plY3QgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50QikgLyBHZXRNYWduaXR1ZGVTcShwb2ludEIpO1xyXG5cclxuICAgIGlmIChhbXQgIT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnggPSBhbXQgKiBwb2ludEIueDtcclxuICAgICAgICBvdXQueSA9IGFtdCAqIHBvaW50Qi55O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvUHJvamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvUHJvamVjdC5qcyIsInZhciBEb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgUHJvamVjdFVuaXQgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50Qik7XHJcblxyXG4gICAgaWYgKGFtdCAhPT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IGFtdCAqIHBvaW50Qi54O1xyXG4gICAgICAgIG91dC55ID0gYW10ICogcG9pbnRCLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdFVuaXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwidmFyIFJQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSwgLXBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSUGVycDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9SUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG52YXIgTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblxyXG52YXIgU2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50LCBtYWduaXR1ZGUpXHJcbntcclxuICAgIE5vcm1hbGl6ZShwb2ludCk7XHJcblxyXG4gICAgcmV0dXJuIE11bHRpcGx5KHBvaW50LCBtYWduaXR1ZGUsIG1hZ25pdHVkZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldE1hZ25pdHVkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qcyIsInZhciBTdWJ0cmFjdCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAtPSB4O1xyXG4gICAgcG9pbnQueSAtPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VidHJhY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvU3VidHJhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uUG9pbnRcclxuXHJcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcclxuXHJcblBvaW50LkFkZCA9IHJlcXVpcmUoJy4vQWRkJyk7XHJcblBvaW50LkNlaWwgPSByZXF1aXJlKCcuL0NlaWwnKTtcclxuUG9pbnQuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblBvaW50LkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5Qb2ludC5Dcm9zcyA9IHJlcXVpcmUoJy4vQ3Jvc3MnKTtcclxuUG9pbnQuRGl2aWRlID0gcmVxdWlyZSgnLi9EaXZpZGUnKTtcclxuUG9pbnQuRG90ID0gcmVxdWlyZSgnLi9Eb3QnKTtcclxuUG9pbnQuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuUG9pbnQuRmxvb3IgPSByZXF1aXJlKCcuL0Zsb29yJyk7XHJcblBvaW50LkdldENlbnRyb2lkID0gcmVxdWlyZSgnLi9HZXRDZW50cm9pZCcpO1xyXG5Qb2ludC5HZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZScpO1xyXG5Qb2ludC5HZXRNYWduaXR1ZGVTcSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlU3EnKTtcclxuUG9pbnQuSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL0ludGVycG9sYXRlJyk7XHJcblBvaW50LkludmVydCA9IHJlcXVpcmUoJy4vSW52ZXJ0Jyk7XHJcblBvaW50Lk11bHRpcGx5ID0gcmVxdWlyZSgnLi9NdWx0aXBseScpO1xyXG5Qb2ludC5OZWdhdGl2ZSA9IHJlcXVpcmUoJy4vTmVnYXRpdmUnKTtcclxuUG9pbnQuTm9ybWFsaXplID0gcmVxdWlyZSgnLi9Ob3JtYWxpemUnKTtcclxuUG9pbnQuTm9ybWFsaXplUmlnaHRIYW5kID0gcmVxdWlyZSgnLi9Ob3JtYWxpemVSaWdodEhhbmQnKTtcclxuUG9pbnQuUGVycCA9IHJlcXVpcmUoJy4vUGVycCcpO1xyXG5Qb2ludC5Qcm9qZWN0ID0gcmVxdWlyZSgnLi9Qcm9qZWN0Jyk7XHJcblBvaW50LlByb2plY3RVbml0ID0gcmVxdWlyZSgnLi9Qcm9qZWN0VW5pdCcpO1xyXG5Qb2ludC5SUGVycCA9IHJlcXVpcmUoJy4vUlBlcnAnKTtcclxuUG9pbnQuU2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9TZXRNYWduaXR1ZGUnKTtcclxuUG9pbnQuU3VidHJhY3QgPSByZXF1aXJlKCcuL1N1YnRyYWN0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9pbmRleC5qcyIsInZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAocG9seWdvbilcclxue1xyXG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvbHlnb24ucG9pbnRzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbi8qKlxyXG4qIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvbi5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHBvbHlnb24sIHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gQ29udGFpbnMocG9seWdvbiwgcG9pbnQueCwgcG9pbnQueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanMiLCJcclxudmFyIEdldEFBQkIgPSBmdW5jdGlvbiAocG9seWdvbilcclxue1xyXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcclxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4WCA9IC1taW5YO1xyXG4gICAgdmFyIG1heFkgPSAtbWluWTtcclxuICAgIHZhciBwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgcCA9IHBvbHlnb24ucG9pbnRzW2ldO1xyXG5cclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcC54KTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcC55KTtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcC54KTtcclxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcC55KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IG1pblgsXHJcbiAgICAgICAgeTogbWluWSxcclxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QUFCQjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldEFBQkIuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogRXhwb3J0IHRoZSBwb2ludHMgYXMgYW4gYXJyYXkgb2YgZmxhdCBudW1iZXJzLCBmb2xsb3dpbmcgdGhlIHNlcXVlbmNlIFsgeCx5LCB4LHksIHgseSBdXHJcbiAqXHJcbiAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jdG9OdW1iZXJBcnJheVxyXG4gKiBAcGFyYW0ge2FycmF5fSBbb3V0cHV0XSAtIFRoZSBhcnJheSB0byBhcHBlbmQgdGhlIHBvaW50cyB0by4gSWYgbm90IHNwZWNpZmllZCBhIG5ldyBhcnJheSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgZmxhdHRlbmVkIGFycmF5LlxyXG4gKi9cclxudmFyIEdldE51bWJlckFycmF5ID0gZnVuY3Rpb24gKHBvbHlnb24sIG91dHB1dClcclxue1xyXG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFtdOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQucHVzaChwb2x5Z29uLnBvaW50c1tpXS54KTtcclxuICAgICAgICBvdXRwdXQucHVzaChwb2x5Z29uLnBvaW50c1tpXS55KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXROdW1iZXJBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLlBvbHlnb25cclxuXHJcbnZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XHJcblxyXG5Qb2x5Z29uLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5Qb2x5Z29uLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5Qb2x5Z29uLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuUG9seWdvbi5HZXRBQUJCID0gcmVxdWlyZSgnLi9HZXRBQUJCJyk7XHJcblBvbHlnb24uR2V0TnVtYmVyQXJyYXkgPSByZXF1aXJlKCcuL0dldE51bWJlckFycmF5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9seWdvbi9pbmRleC5qcyIsInZhciBBcmVhID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJldHVybiByZWN0LndpZHRoICogcmVjdC5oZWlnaHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmNlaWwocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9DZWlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWxBbGwgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5jZWlsKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmNlaWwocmVjdC55KTtcclxuICAgIHJlY3Qud2lkdGggPSBNYXRoLmNlaWwocmVjdC53aWR0aCk7XHJcbiAgICByZWN0LmhlaWdodCA9IE1hdGguY2VpbChyZWN0LmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxBbGw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlaWxBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDZW50ZXJzIHRoaXMgUmVjdGFuZ2xlIHNvIHRoYXQgdGhlIGNlbnRlciBjb29yZGluYXRlcyBtYXRjaCB0aGUgZ2l2ZW4geCBhbmQgeSB2YWx1ZXMuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5SZWN0YW5nbGUjY2VudGVyT25cclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgdG8gcGxhY2UgdGhlIGNlbnRlciBvZiB0aGUgUmVjdGFuZ2xlIGF0LlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXHJcbiogQHJldHVybiB7UGhhc2VyLlJlY3RhbmdsZX0gVGhpcyBSZWN0YW5nbGUgb2JqZWN0XHJcbiovXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxyXG57XHJcbiAgICByZWN0LnggPSB4IC0gKHJlY3Qud2lkdGggLyAyKTtcclxuICAgIHJlY3QueSA9IHkgLSAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocmVjdCwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhyZWN0LCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanMiLCIvLyAgQ2hlY2tzIGlmIHJlY3RCIGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gcmVjdEFcclxuXHJcbnZhciBDb250YWluc1JlY3QgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxyXG57XHJcbiAgICAvLyAgVm9sdW1lIGNoZWNrIChpZiByZWN0QiB2b2x1bWUgPiByZWN0QSB0aGVuIHJlY3RBIGNhbm5vdCBjb250YWluIGl0KVxyXG4gICAgaWYgKChyZWN0Qi53aWR0aCAqIHJlY3RCLmhlaWdodCkgPiAocmVjdEEud2lkdGggKiByZWN0QS5oZWlnaHQpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm5cclxuICAgICAgICAoXHJcbiAgICAgICAgICAgIChyZWN0Qi54ID4gcmVjdEEueCAmJiByZWN0Qi54IDwgcmVjdEEucmlnaHQpICYmIFxyXG4gICAgICAgICAgICAocmVjdEIucmlnaHQgPiByZWN0QS54ICYmIHJlY3RCLnJpZ2h0IDwgcmVjdEEucmlnaHQpXHJcbiAgICAgICAgKSAmJiAoXHJcbiAgICAgICAgICAgIChyZWN0Qi55ID4gcmVjdEEueSAmJiByZWN0Qi55IDwgcmVjdEEuYm90dG9tKSAmJiBcclxuICAgICAgICAgICAgKHJlY3RCLmJvdHRvbSA+IHJlY3RBLnkgJiYgcmVjdEIuYm90dG9tIDwgcmVjdEEuYm90dG9tKVxyXG4gICAgICAgICk7XHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKHJlY3QsIHRvQ29tcGFyZSlcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICByZWN0LnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgcmVjdC55ID09PSB0b0NvbXBhcmUueSAmJlxyXG4gICAgICAgIHJlY3Qud2lkdGggPT09IHRvQ29tcGFyZS53aWR0aCAmJlxyXG4gICAgICAgIHJlY3QuaGVpZ2h0ID09PSB0b0NvbXBhcmUuaGVpZ2h0XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcclxuXHJcbi8vICBGaXRzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIGludG8gdGhlIHNvdXJjZSByZWN0YW5nbGUuXHJcbi8vICBQcmVzZXJ2ZXMgYXNwZWN0IHJhdGlvLlxyXG4vLyAgU2NhbGVzIGFuZCBjZW50ZXJzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIHRvIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXHJcblxyXG52YXIgRml0SW5zaWRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxyXG57XHJcbiAgICB2YXIgcmF0aW8gPSBHZXRBc3BlY3RSYXRpbyh0YXJnZXQpO1xyXG5cclxuICAgIGlmIChyYXRpbyA8IEdldEFzcGVjdFJhdGlvKHNvdXJjZSkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRhbGxlciB0aGFuIFdpZGVcclxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2UuaGVpZ2h0ICogcmF0aW8sIHNvdXJjZS5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXaWRlciB0aGFuIFRhbGxcclxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS53aWR0aCAqIHJhdGlvKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0LnNldFBvc2l0aW9uKFxyXG4gICAgICAgIChzb3VyY2UucmlnaHQgLyAyKSAtICh0YXJnZXQud2lkdGggLyAyKSxcclxuICAgICAgICAoc291cmNlLmJvdHRvbSAvIDIpIC0gKHRhcmdldC5oZWlnaHQgLyAyKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRml0SW5zaWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XHJcblxyXG4vLyAgRml0cyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSBhcm91bmQgdGhlIHNvdXJjZSByZWN0YW5nbGUuXHJcbi8vICBQcmVzZXJ2ZXMgYXNwZWN0IHJhdGlvbi5cclxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG5cclxudmFyIEZpdE91dHNpZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XHJcblxyXG4gICAgaWYgKHJhdGlvID4gR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcclxuICAgIHtcclxuICAgICAgICAvLyAgV2lkZXIgdGhhbiBUYWxsXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgVGFsbGVyIHRoYW4gV2lkZVxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS53aWR0aCwgc291cmNlLndpZHRoICogcmF0aW8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQuc2V0UG9zaXRpb24oXHJcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gdGFyZ2V0LndpZHRoIC8gMixcclxuICAgICAgICAoc291cmNlLmJvdHRvbSAvIDIpIC0gdGFyZ2V0LmhlaWdodCAvIDJcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpdE91dHNpZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJlY3QueCA9IE1hdGguZmxvb3IocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguZmxvb3IocmVjdC55KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yQWxsID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJlY3QueCA9IE1hdGguZmxvb3IocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguZmxvb3IocmVjdC55KTtcclxuICAgIHJlY3Qud2lkdGggPSBNYXRoLmZsb29yKHJlY3Qud2lkdGgpO1xyXG4gICAgcmVjdC5oZWlnaHQgPSBNYXRoLmZsb29yKHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3JBbGw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoZSBjZW50ZXIgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QsIGV4cHJlc3NlZCBhcyBhIFBvaW50IG9iamVjdCBcclxuXHJcbnZhciBHZXRDZW50ZXIgPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3QucmlnaHQgLyAyO1xyXG4gICAgb3V0LnkgPSByZWN0LmJvdHRvbSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIHNpemUgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QsIGV4cHJlc3NlZCBhcyBhIFBvaW50IG9iamVjdCBcclxuLy8gIHdpdGggdGhlIHZhbHVlcyBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzLlxyXG5cclxudmFyIEdldFNpemUgPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3Qud2lkdGg7XHJcbiAgICBvdXQueSA9IHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFNpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0dldFNpemUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0IGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cclxuLy8gIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3Qgc3RheXMgdGhlIHNhbWUsIGFuZCBpdHMgc2l6ZSBpbmNyZWFzZXMgXHJcbi8vICB0byB0aGUgbGVmdCBhbmQgcmlnaHQgYnkgdGhlIHggdmFsdWUsIGFuZCB0byB0aGUgdG9wIGFuZCB0aGUgYm90dG9tIGJ5IHRoZSB5IHZhbHVlLlxyXG5cclxudmFyIEluZmxhdGUgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgLy8gIEdldCB0aGUgY3VycmVudCBjZW50ZXJcclxuICAgIHZhciBjeCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICB2YXIgY3kgPSByZWN0LnkgKyAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyAgSW5mbGF0ZVxyXG4gICAgcmVjdC53aWR0aCA9IDIgKiB4O1xyXG4gICAgcmVjdC5oZWlnaHQgPSAyICogeTtcclxuXHJcbiAgICByZWN0LnggPSB4IC0gKHJlY3Qud2lkdGggLyAyKTtcclxuICAgIHJlY3QueSA9IHkgLSAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5mbGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvSW5mbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBNZXJnZXMgdGhlIHRhcmdldCBSZWN0YW5nbGUgd2l0aCBhIGxpc3Qgb2YgcG9pbnRzLlxyXG4vLyAgVGhlIHBvaW50cyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLlxyXG5cclxudmFyIE1lcmdlUG9pbnRzID0gZnVuY3Rpb24gKHRhcmdldCwgcG9pbnRzKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IHRhcmdldC54O1xyXG4gICAgdmFyIG1heFggPSB0YXJnZXQucmlnaHQ7XHJcbiAgICB2YXIgbWluWSA9IHRhcmdldC55O1xyXG4gICAgdmFyIG1heFkgPSB0YXJnZXQuYm90dG9tO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludHNbaV0ueCk7XHJcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHBvaW50c1tpXS54KTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcG9pbnRzW2ldLnkpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludHNbaV0ueSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICB0YXJnZXQuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VQb2ludHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE1lcmdlcyBzb3VyY2UgcmVjdGFuZ2xlIGludG8gdGFyZ2V0IHJlY3RhbmdsZSBhbmQgcmV0dXJucyB0YXJnZXRcclxuLy8gIE5laXRoZXIgcmVjdCBzaG91bGQgaGF2ZSBuZWdhdGl2ZSB3aWR0aHMgb3IgaGVpZ2h0c1xyXG5cclxudmFyIE1lcmdlUmVjdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcclxue1xyXG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih0YXJnZXQueCwgc291cmNlLngpO1xyXG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh0YXJnZXQucmlnaHQsIHNvdXJjZS5yaWdodCk7XHJcblxyXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xyXG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XHJcblxyXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih0YXJnZXQueSwgc291cmNlLnkpO1xyXG4gICAgdmFyIG1heFkgPSBNYXRoLm1heCh0YXJnZXQuYm90dG9tLCBzb3VyY2UuYm90dG9tKTtcclxuXHJcbiAgICB0YXJnZXQueSA9IG1pblk7XHJcbiAgICB0YXJnZXQuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE1lcmdlWFkgPSBmdW5jdGlvbiAodGFyZ2V0LCB4LCB5KVxyXG57XHJcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHRhcmdldC54LCB4KTtcclxuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCB4KTtcclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICB2YXIgbWluWSA9IE1hdGgubWluKHRhcmdldC55LCB5KTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgeSk7XHJcblxyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHJlY3QueCArPSB4O1xyXG4gICAgcmVjdC55ICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKHJlY3QsIHBvaW50KVxyXG57XHJcbiAgICByZWN0LnggKz0gcG9pbnQueDtcclxuICAgIHJlY3QueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHJlY3RBLnggPCByZWN0Qi5yaWdodCAmJiBcclxuICAgICAgICByZWN0QS5yaWdodCA+IHJlY3RCLnggJiYgXHJcbiAgICAgICAgcmVjdEEueSA8IHJlY3RCLmJvdHRvbSAmJiBcclxuICAgICAgICByZWN0QS5ib3R0b20gPiByZWN0Qi55XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGFwcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvT3ZlcmxhcHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyaW1ldGVyID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJldHVybiAyICogKHJlY3Qud2lkdGggKyByZWN0LmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmltZXRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3QueCArIChNYXRoLnJhbmRvbSgpICogcmVjdC53aWR0aCk7XHJcbiAgICBvdXQueSA9IHJlY3QueSArIChNYXRoLnJhbmRvbSgpICogcmVjdC5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwiLyoqXHJcbiogU2NhbGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoaXMgUmVjdGFuZ2xlIGJ5IHRoZSBnaXZlbiBhbW91bnRzLlxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLlJlY3RhbmdsZSNzY2FsZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZSBieS4gQSB2YWx1ZSBvZiAwLjUgd291bGQgcmVkdWNlIGJ5IGhhbGYsIGEgdmFsdWUgb2YgMiB3b3VsZCBkb3VibGUgdGhlIHdpZHRoLCBldGMuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlIGJ5LiBBIHZhbHVlIG9mIDAuNSB3b3VsZCByZWR1Y2UgYnkgaGFsZiwgYSB2YWx1ZSBvZiAyIHdvdWxkIGRvdWJsZSB0aGUgaGVpZ2h0LCBldGMuXHJcbiogQHJldHVybiB7UGhhc2VyLlJlY3RhbmdsZX0gVGhpcyBSZWN0YW5nbGUgb2JqZWN0XHJcbiovXHJcbnZhciBTY2FsZSA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxyXG57XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgcmVjdC53aWR0aCAqPSB4O1xyXG4gICAgcmVjdC5oZWlnaHQgKj0geTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1NjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgVW5pb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBSZWN0YW5nbGUoKTsgfVxyXG5cclxuICAgIHZhciB4ID0gTWF0aC5taW4ocmVjdEEueCwgcmVjdEIueCk7XHJcbiAgICB2YXIgeSA9IE1hdGgubWluKHJlY3RBLnksIHJlY3RCLnkpO1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQuc2V0KFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICBNYXRoLm1heChyZWN0QS5yaWdodCwgcmVjdEIucmlnaHQpIC0geCxcclxuICAgICAgICBNYXRoLm1heChyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSB5XHJcbiAgICApO1xyXG4gICAgXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzIiwiLy8gIFBoYXNlci5HZW9tLlJlY3RhbmdsZVxyXG5cclxudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XHJcblxyXG5SZWN0YW5nbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5SZWN0YW5nbGUuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5SZWN0YW5nbGUuQ2VpbEFsbCA9IHJlcXVpcmUoJy4vQ2VpbEFsbCcpO1xyXG5SZWN0YW5nbGUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XHJcblJlY3RhbmdsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5SZWN0YW5nbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5SZWN0YW5nbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcclxuUmVjdGFuZ2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5SZWN0YW5nbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuUmVjdGFuZ2xlLkZpdEluc2lkZSA9IHJlcXVpcmUoJy4vRml0SW5zaWRlJyk7XHJcblJlY3RhbmdsZS5GaXRPdXRzaWRlID0gcmVxdWlyZSgnLi9GaXRPdXRzaWRlJyk7XHJcblJlY3RhbmdsZS5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcclxuUmVjdGFuZ2xlLkZsb29yQWxsID0gcmVxdWlyZSgnLi9GbG9vckFsbCcpO1xyXG5SZWN0YW5nbGUuR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XHJcblJlY3RhbmdsZS5HZXRDZW50ZXIgPSByZXF1aXJlKCcuL0dldENlbnRlcicpO1xyXG5SZWN0YW5nbGUuR2V0U2l6ZSA9IHJlcXVpcmUoJy4vR2V0U2l6ZScpO1xyXG5SZWN0YW5nbGUuSW5mbGF0ZSA9IHJlcXVpcmUoJy4vSW5mbGF0ZScpO1xyXG5SZWN0YW5nbGUuTWVyZ2VQb2ludHMgPSByZXF1aXJlKCcuL01lcmdlUG9pbnRzJyk7XHJcblJlY3RhbmdsZS5NZXJnZVJlY3QgPSByZXF1aXJlKCcuL01lcmdlUmVjdCcpO1xyXG5SZWN0YW5nbGUuTWVyZ2VYWSA9IHJlcXVpcmUoJy4vTWVyZ2VYWScpO1xyXG5SZWN0YW5nbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuUmVjdGFuZ2xlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xyXG5SZWN0YW5nbGUuT3ZlcmxhcHMgPSByZXF1aXJlKCcuL092ZXJsYXBzJyk7XHJcblJlY3RhbmdsZS5QZXJpbWV0ZXIgPSByZXF1aXJlKCcuL1BlcmltZXRlcicpO1xyXG5SZWN0YW5nbGUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcclxuUmVjdGFuZ2xlLlNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xyXG5SZWN0YW5nbGUuVW5pb24gPSByZXF1aXJlKCcuL1VuaW9uJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9zdHJ1Y3RzL1NldCcpO1xyXG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzLycpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG5cclxudmFyIEJhc2VMb2FkZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgVG8gZmluaXNoIHRoZSBsb2FkZXIgLi4uXHJcbiAgICAvLyAgXHJcbiAgICAvLyAgMykgUHJvZ3Jlc3MgdXBkYXRlXHJcbiAgICAvLyAgNCkgSlNPTiBsb2FkZXJcclxuICAgIC8vICA1KSBYTUwgTG9hZGVyXHJcbiAgICAvLyAgNikgTXVsdGkgRmlsZSBzdXBwb3J0IChhdGxhcyArIGRhdGEpXHJcbiAgICAvLyAgNykgQXRsYXMgTG9hZGVyXHJcblxyXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gICAgLy8gIE1vdmUgdG8gYSAnc2V0VVJMJyBtZXRob2Q/XHJcbiAgICB0aGlzLmJhc2VVUkwgPSAnJztcclxuICAgIHRoaXMucGF0aCA9ICcnO1xyXG5cclxuICAgIC8vICBSZWFkIGZyb20gR2FtZSAvIFN0YXRlIENvbmZpZ1xyXG4gICAgdGhpcy5lbmFibGVQYXJhbGxlbCA9IHRydWU7XHJcbiAgICB0aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzID0gNDtcclxuXHJcbiAgICAvLyAgeGhyIHNwZWNpZmljIGdsb2JhbCBzZXR0aW5ncyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXItZmlsZSBiYXNpcylcclxuICAgIHRoaXMueGhyID0gWEhSU2V0dGluZ3MoKTtcclxuXHJcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMubGlzdCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMuaW5mbGlnaHQgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLmZhaWxlZCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMucXVldWUgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcclxufTtcclxuXHJcbkJhc2VMb2FkZXIucHJvdG90eXBlLmNvbnRydWN0b3IgPSBCYXNlTG9hZGVyO1xyXG5cclxuQmFzZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkRmlsZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpbGUucGF0aCA9IHRoaXMucGF0aDtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0LnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBJcyB0aGUgTG9hZGVyIGFjdGl2ZWx5IGxvYWRpbmcgKG9yIHByb2Nlc3NpbmcgbG9hZGVkIGZpbGVzKVxyXG4gICAgaXNMb2FkaW5nOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9MT0FESU5HIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBJcyB0aGUgTG9hZGVyIHJlYWR5IHRvIHN0YXJ0IGEgbmV3IGxvYWQ/XHJcbiAgICBpc1JlYWR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9JRExFIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfQ09NUExFVEUgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9GQUlMRUQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQmFzZUxvYWRlciBzdGFydC4gRmlsZXMgdG8gbG9hZDonLCB0aGlzLmxpc3Quc2l6ZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfTE9BRElORztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWJ1ZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2Vzc0xvYWRRdWV1ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnPT09PT09PT0gQmFzZUxvYWRlciBwcm9jZXNzTG9hZFF1ZXVlJyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xpc3Qgc2l6ZScsIHRoaXMubGlzdC5zaXplKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmluZmxpZ2h0LnNpemUsICdpdGVtcyBzdGlsbCBpbiBmbGlnaHQuIENhbiBsb2FkIGFub3RoZXInLCAodGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcyAtIHRoaXMuaW5mbGlnaHQuc2l6ZSkpO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX1BFTkRJTkcgJiYgX3RoaXMuaW5mbGlnaHQuc2l6ZSA8IF90aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmZsaWdodC5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMubGlzdC5kZWxldGUoZmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZEZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbmZsaWdodC5zaXplID09PSBfdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRlbGxzIHRoZSBTZXQgaXRlcmF0b3IgdG8gYWJvcnRcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHByaXZhdGVcclxuICAgIGxvYWRGaWxlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTE9BRElORycsIGZpbGUua2V5KTtcclxuXHJcbiAgICAgICAgLy8gIElmIHRoZSBmaWxlIGRvZXNuJ3QgaGF2ZSBpdHMgb3duIGNyb3NzT3JpZ2luIHNldCxcclxuICAgICAgICAvLyAgd2UnbGwgdXNlIHRoZSBMb2FkZXJzICh3aGljaCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdClcclxuICAgICAgICBpZiAoIWZpbGUuY3Jvc3NPcmlnaW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWxlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpbGUubG9hZCh0aGlzLm5leHRGaWxlLmJpbmQodGhpcyksIHRoaXMuYmFzZVVSTCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG5leHRGaWxlOiBmdW5jdGlvbiAocHJldmlvdXNGaWxlLCBzdWNjZXNzKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0FERUQ6JywgcHJldmlvdXNGaWxlLnNyYywgc3VjY2Vzcyk7XHJcblxyXG4gICAgICAgIC8vICBNb3ZlIHRoZSBmaWxlIHRoYXQganVzdCBsb2FkZWQgZnJvbSB0aGUgaW5mbGlnaHQgbGlzdCB0byB0aGUgcXVldWUgb3IgZmFpbGVkIFNldFxyXG5cclxuICAgICAgICBpZiAoc3VjY2VzcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuc2V0KHByZXZpb3VzRmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChwcmV2aW91c0ZpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbmZsaWdodC5kZWxldGUocHJldmlvdXNGaWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXh0RmlsZSAtIHN0aWxsIHNvbWV0aGluZyBpbiB0aGUgbGlzdCcpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmZsaWdodC5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIGNhbGxpbmcgZmluaXNoZWRMb2FkaW5nJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmaW5pc2hlZExvYWRpbmc6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4gQmFzZUxvYWRlci5maW5pc2hlZExvYWRpbmcgUFJPQ0VTU0lORycsIHRoaXMucXVldWUuc2l6ZSwgJ2ZpbGVzJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkc7XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnF1ZXVlLmVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgQ2FsbGluZyBwcm9jZXNzIG9uICcgKyBmaWxlLmtleSwgJ2NvbG9yOiAjMDAwMDAwOyBiYWNrZ3JvdW5kOiAjZmZmZjAwOycpO1xyXG5cclxuICAgICAgICAgICAgZmlsZS5vblByb2Nlc3MoX3RoaXMucHJvY2Vzc1VwZGF0ZS5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgRmlsZSB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nXHJcbiAgICBwcm9jZXNzVXBkYXRlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLT4gcHJvY2Vzc1VwZGF0ZScsIGZpbGUua2V5LCBmaWxlLnN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gIFRoaXMgZmlsZSBoYXMgZmFpbGVkIHRvIGxvYWQsIHNvIG1vdmUgaXQgdG8gdGhlIGZhaWxlZCBTZXRcclxuICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9FUlJPUkVEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWQuc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbGUubGlua0ZpbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUubGlua0ZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgSWYgd2UgZ290IGhlcmUsIHRoZW4gdGhlIGZpbGUgbG9hZGVkXHJcblxyXG4gICAgICAgIC8vICBTcGVjaWFsIGhhbmRsaW5nIGZvciBtdWx0aS1wYXJ0IGZpbGVzXHJcblxyXG4gICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfQ09NUExFVEUgJiYgZmlsZS5saW5rRmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9DT01QTEVURSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFBhcnRuZXIgaGFzIGxvYWRlZCwgc28gYWRkIHRoZW0gYm90aCB0byBTdG9yYWdlXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh7IHR5cGU6IGZpbGUubGlua1R5cGUsIGZpbGVBOiBmaWxlLCBmaWxlQjogZmlsZS5saW5rRmlsZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlLmxpbmtGaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVGcm9tUXVldWU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5zaXplID09PSAwICYmIHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBXZSd2ZSBwcm9jZXNzZWQgYWxsIHRoZSBmaWxlcyB3ZSBsb2FkZWRcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3NDb21wbGV0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVyIENvbXBsZXRlLiBMb2FkZWQ6JywgdGhpcy5zdG9yYWdlLnNpemUsICdGYWlsZWQ6JywgdGhpcy5mYWlsZWQuc2l6ZSk7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9DT01QTEVURTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LkxPQURFUl9DT01QTEVURV9FVkVOVCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubGlzdC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmZhaWxlZC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy50YWcgPSAnJztcclxuICAgICAgICB0aGlzLnBhdGggPSAnJztcclxuICAgICAgICB0aGlzLmJhc2VVUkwgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfREVTVFJPWUVEO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZUxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL0Jhc2VMb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvQmFzZUxvYWRlci5qcyIsInZhciBHZXRVUkwgPSBmdW5jdGlvbiAoZmlsZSwgYmFzZVVSTClcclxue1xyXG4gICAgaWYgKCFmaWxlLnVybClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbGUudXJsLm1hdGNoKC9eKD86YmxvYjp8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfFxcL1xcLykvKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmlsZS51cmw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBmaWxlLnVybDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VVJMO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvR2V0VVJMLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1lcmdlWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL01lcmdlWEhSU2V0dGluZ3MnKTtcclxuXHJcbnZhciBYSFJMb2FkZXIgPSBmdW5jdGlvbiAoZmlsZSwgZ2xvYmFsWEhSU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBjb25maWcgPSBNZXJnZVhIUlNldHRpbmdzKGdsb2JhbFhIUlNldHRpbmdzLCBmaWxlLnhoclNldHRpbmdzKTtcclxuXHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUuc3JjLCBjb25maWcuYXN5bmMsIGNvbmZpZy51c2VyLCBjb25maWcucGFzc3dvcmQpO1xyXG5cclxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmaWxlLnhoclNldHRpbmdzLnJlc3BvbnNlVHlwZTtcclxuICAgIHhoci50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5oZWFkZXIgJiYgY29uZmlnLmhlYWRlclZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGNvbmZpZy5oZWFkZXIsIGNvbmZpZy5oZWFkZXJWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZy5vdmVycmlkZU1pbWVUeXBlKVxyXG4gICAge1xyXG4gICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKGNvbmZpZy5vdmVycmlkZU1pbWVUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgcmVxdWVzdCwgdGhlIHhoci5yZXNwb25zZSBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gdGhlIHJlcXVlc3RlZCBkYXRhIGFzIGEgRE9NU3RyaW5nLCBBcnJheUJ1ZmZlciwgQmxvYiwgb3IgRG9jdW1lbnQgKGRlcGVuZGluZyBvbiB3aGF0IHdhcyBzZXQgZm9yIHJlc3BvbnNlVHlwZS4pXHJcblxyXG4gICAgeGhyLm9ubG9hZCA9IGZpbGUub25Mb2FkLmJpbmQoZmlsZSk7XHJcbiAgICB4aHIub25lcnJvciA9IGZpbGUub25FcnJvci5iaW5kKGZpbGUpO1xyXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmaWxlLm9uUHJvZ3Jlc3MuYmluZChmaWxlKTtcclxuXHJcbiAgICAvLyAgVGhpcyBpcyB0aGUgb25seSBzdGFuZGFyZCBtZXRob2QsIHRoZSBvbmVzIGFib3ZlIGFyZSBicm93c2VyIGFkZGl0aW9ucyAobWF5YmUgbm90IHVuaXZlcnNhbD8pXHJcbiAgICAvLyB4aHIub25yZWFkeXN0YXRlY2hhbmdlXHJcblxyXG4gICAgeGhyLnNlbmQoKTtcclxuXHJcbiAgICByZXR1cm4geGhyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2FkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9YSFJMb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvWEhSTG9hZGVyLmpzIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTG9hZGVyQ29tcGxldGVFdmVudCA9IGZ1bmN0aW9uIChsb2FkZXIpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ0xPQURFUl9DT01QTEVURV9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG59O1xyXG5cclxuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbkxvYWRlckNvbXBsZXRlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyQ29tcGxldGVFdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyQ29tcGxldGVFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJDb21wbGV0ZUV2ZW50LmpzIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTG9hZGVyU3RhcnRFdmVudCA9IGZ1bmN0aW9uIChsb2FkZXIpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ0xPQURFUl9TVEFSVF9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG59O1xyXG5cclxuTG9hZGVyU3RhcnRFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbkxvYWRlclN0YXJ0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyU3RhcnRFdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyU3RhcnRFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTE9BREVSX1NUQVJUX0VWRU5UOiByZXF1aXJlKCcuL0xvYWRlclN0YXJ0RXZlbnQnKSxcclxuICAgIExPQURFUl9DT01QTEVURV9FVkVOVDogcmVxdWlyZSgnLi9Mb2FkZXJDb21wbGV0ZUV2ZW50JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XHJcbnZhciBKU09ORmlsZSA9IHJlcXVpcmUoJy4vSlNPTkZpbGUuanMnKTtcclxuXHJcbnZhciBBdGxhc0pTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBKU09ORmlsZShrZXksIGF0bGFzVVJMLCBwYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICAvLyAgTGluayB0aGVtIHRvZ2V0aGVyXHJcbiAgICBpbWFnZS5saW5rRmlsZSA9IGRhdGE7XHJcbiAgICBkYXRhLmxpbmtGaWxlID0gaW1hZ2U7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdHlwZVxyXG4gICAgaW1hZ2UubGlua1R5cGUgPSAnYXRsYXNqc29uJztcclxuICAgIGRhdGEubGlua1R5cGUgPSAnYXRsYXNqc29uJztcclxuXHJcbiAgICByZXR1cm4geyB0ZXh0dXJlOiBpbWFnZSwgZGF0YTogZGF0YSB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdGxhc0pTT05GaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0F0bGFzSlNPTkZpbGUuanMiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgQmluYXJ5RmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5iaW5hcnlcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcuYmluJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIEZpbGUuY2FsbCh0aGlzLCAnYmluYXJ5Jywga2V5LCB1cmwsICdhcnJheWJ1ZmZlcicsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcbkJpbmFyeUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcbkJpbmFyeUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmluYXJ5RmlsZTtcclxuXHJcbkJpbmFyeUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZTtcclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5RmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIEdMU0xGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnRleHRcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcuZ2xzbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ2dsc2wnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5HTFNMRmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuR0xTTEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR0xTTEZpbGU7XHJcblxyXG5HTFNMRmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dDtcclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR0xTTEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIFRleHRGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnRleHRcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcudGV4dCc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ3RleHQnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5UZXh0RmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuVGV4dEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEZpbGU7XHJcblxyXG5UZXh0RmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dDtcclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgUGFyc2VYTUwgPSByZXF1aXJlKCcuLi8uLi9kb20vUGFyc2VYTUwnKTtcclxuXHJcbnZhciBYTUxGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnhtbFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy54bWwnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICd4bWwnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5YTUxGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhNTEZpbGU7XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gUGFyc2VYTUwodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwidmFyIEF2ZXJhZ2UgPSBmdW5jdGlvbiAodmFsdWVzKVxyXG57XHJcbiAgICB2YXIgc3VtID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBzdW0gKz0gKCt2YWx1ZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdW0gLyB2YWx1ZXMubGVuZ3RoO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdmVyYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0F2ZXJhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcclxue1xyXG4gICAgaWYgKHBsYWNlID09PSB1bmRlZmluZWQpIHsgcGxhY2UgPSAwOyB9XHJcbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxyXG5cclxuICAgIHZhciBwID0gTWF0aC5wb3coYmFzZSwgLXBsYWNlKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlICogcCkgLyBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2VpbFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRm9yY2UgYSB2YWx1ZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgYnkgY2xhbXBpbmcgaXQgdG8gdGhlIHJhbmdlIGBtaW5gLCBgbWF4YC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjY2xhbXBcclxuKiBAcGFyYW0ge2Zsb2F0fSB2IC0gVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWQuXHJcbiogQHBhcmFtIHtmbG9hdH0gbWluIC0gVGhlIG1pbmltdW0gYm91bmRzLlxyXG4qIEBwYXJhbSB7ZmxvYXR9IG1heCAtIFRoZSBtYXhpbXVtIGJvdW5kcy5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjbGFtcGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgQ2xhbXAgPSBmdW5jdGlvbiAodiwgbWluLCBtYXgpXHJcbntcclxuICAgIGlmICh2IDwgbWluKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBtaW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXggPCB2KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsYW1wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0NsYW1wLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIERlZ1RvUmFkID0gZnVuY3Rpb24gKGRlZ3JlZXMpXHJcbntcclxuICAgIHJldHVybiBkZWdyZWVzICogQ09OU1QuREVHX1RPX1JBRDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVnVG9SYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRGVnVG9SYWQuanNcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL0RlZ1RvUmFkLmpzIiwidmFyIERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9EaWZmZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb2F0QmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW47XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb2F0QmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9GbG9hdEJldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3JUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvb3JUby5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgTWF4QWRkID0gZnVuY3Rpb24gKHZhbHVlLCBhbW91bnQsIG1heClcclxue1xyXG4gICAgcmV0dXJuIE1hdGgubWluKHZhbHVlICsgYW1vdW50LCBtYXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXhBZGQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvTWF4QWRkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1pblN1YiA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtaW4pXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAtIGFtb3VudCwgbWluKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWluU3ViO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL01pblN1Yi5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJjZW50ID0gZnVuY3Rpb24gKGEsIGIsIGJhc2UpXHJcbntcclxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDA7IH1cclxuXHJcbiAgICBpZiAoYSA+IGIgfHwgYmFzZSA+IGIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhIDwgYmFzZSB8fCBiYXNlID4gYSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKGEgLSBiYXNlKSAvIGI7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmNlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUGVyY2VudC5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBSYWRUb0RlZyA9IGZ1bmN0aW9uIChyYWRpYW5zKVxyXG57XHJcbiAgICByZXR1cm4gcmFkaWFucyAqIENPTlNULlJBRF9UT19ERUc7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhZFRvRGVnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JhZFRvRGVnLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9SYWRUb0RlZy5qcyIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG5cclxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChwb2ludCwgYW5nbGUpXHJcbntcclxuICAgIHZhciB4ID0gcG9pbnQueDtcclxuICAgIHZhciB5ID0gcG9pbnQueTtcclxuXHJcbiAgICBwb2ludC54ID0gKHggKiBNYXRoLmNvcyhhbmdsZSkpIC0gKHkgKiBNYXRoLnNpbihhbmdsZSkpO1xyXG4gICAgcG9pbnQueSA9ICh4ICogTWF0aC5zaW4oYW5nbGUpKSArICh5ICogTWF0aC5jb3MoYW5nbGUpKTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcclxuXHJcbnZhciBSb3RhdGVBcm91bmQgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHksIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgIHZhciB0eCA9IHBvaW50LnggLSB4O1xyXG4gICAgdmFyIHR5ID0gcG9pbnQueSAtIHk7XHJcblxyXG4gICAgcG9pbnQueCA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICBwb2ludC55ID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGVBcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcclxuXHJcbnZhciBSb3RhdGVBcm91bmREaXN0YW5jZSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSwgYW5nbGUsIGRpc3RhbmNlKVxyXG57XHJcbiAgICB2YXIgdCA9IGFuZ2xlICsgTWF0aC5hdGFuMihwb2ludC55IC0geSwgcG9pbnQueCAtIHgpO1xyXG5cclxuICAgIHBvaW50LnggPSB4ICsgKGRpc3RhbmNlICogTWF0aC5jb3ModCkpO1xyXG4gICAgcG9pbnQueSA9IHkgKyAoZGlzdGFuY2UgKiBNYXRoLnNpbih0KSk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmREaXN0YW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcclxue1xyXG4gICAgaWYgKHBsYWNlID09PSB1bmRlZmluZWQpIHsgcGxhY2UgPSAwOyB9XHJcbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxyXG5cclxuICAgIHZhciBwID0gTWF0aC5wb3coYmFzZSwgLXBsYWNlKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHApIC8gcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm91bmRUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3VuZFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBTaW5Db3NUYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIChsZW5ndGgsIHNpbkFtcCwgY29zQW1wLCBmcmVxdWVuY3kpXHJcbntcclxuICAgIGlmIChzaW5BbXAgPT09IHVuZGVmaW5lZCkgeyBzaW5BbXAgPSAxOyB9XHJcbiAgICBpZiAoY29zQW1wID09PSB1bmRlZmluZWQpIHsgY29zQW1wID0gMTsgfVxyXG4gICAgaWYgKGZyZXF1ZW5jeSA9PT0gdW5kZWZpbmVkKSB7IGZyZXF1ZW5jeSA9IDE7IH1cclxuXHJcbiAgICBmcmVxdWVuY3kgKj0gTWF0aC5QSSAvIGxlbmd0aDtcclxuXHJcbiAgICB2YXIgY29zID0gW107XHJcbiAgICB2YXIgc2luID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBsZW5ndGg7IGMrKylcclxuICAgIHtcclxuICAgICAgICBjb3NBbXAgLT0gc2luQW1wICogZnJlcXVlbmN5O1xyXG4gICAgICAgIHNpbkFtcCArPSBjb3NBbXAgKiBmcmVxdWVuY3k7XHJcblxyXG4gICAgICAgIGNvc1tjXSA9IGNvc0FtcDtcclxuICAgICAgICBzaW5bY10gPSBzaW5BbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzaW46IHNpbixcclxuICAgICAgICBjb3M6IGNvcyxcclxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2luQ29zVGFibGVHZW5lcmF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU2luQ29zVGFibGVHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU21vb3RoU3RlcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heClcclxue1xyXG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XHJcblxyXG4gICAgcmV0dXJuIHggKiB4ICogKDMgLSAyICogeCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aFN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhlclN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXHJcbntcclxuICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIG1pbikgLyAobWF4IC0gbWluKSkpO1xyXG5cclxuICAgIHJldHVybiB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoZXJTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1Ntb290aGVyU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENoZWNrcyBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZSBvZiBlYWNoIG90aGVyLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCN3aXRoaW5cclxuKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gY2hlY2tcclxuKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGNoZWNrXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSAtIFRoZSB0b2xlcmFuY2UuIEFueXRoaW5nIGVxdWFsIHRvIG9yIGxlc3MgdGhhbiB0aGlzIGlzIGNvbnNpZGVyZWQgd2l0aGluIHRoZSByYW5nZS5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgaXMgPD0gdG9sZXJhbmNlIG9mIGIuXHJcbiogQHNlZSB7QGxpbmsgUGhhc2VyLk1hdGguZnV6enlFcXVhbH1cclxuKi9cclxudmFyIFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBiLCB0b2xlcmFuY2UpXHJcbntcclxuICAgIHJldHVybiAoTWF0aC5hYnMoYSAtIGIpIDw9IHRvbGVyYW5jZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdpdGhpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9XaXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludDIueSAtIHBvaW50MS55LCBwb2ludDIueCAtIHBvaW50MS54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlblBvaW50cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5Qb2ludHNZID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludDIueCAtIHBvaW50MS54LCBwb2ludDIueSAtIHBvaW50MS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlblBvaW50c1k7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50c1kuanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblkgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHgyIC0geDEsIHkyIC0geTEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5cclxudmFyIFJldmVyc2UgPSBmdW5jdGlvbiAoYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBOb3JtYWxpemUoYW5nbGUgKyBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmV2ZXJzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiogUm90YXRlcyBjdXJyZW50QW5nbGUgdG93YXJkcyB0YXJnZXRBbmdsZSwgdGFraW5nIHRoZSBzaG9ydGVzdCByb3RhdGlvbiBkaXN0YW5jZS5cclxuKiBUaGUgbGVycCBhcmd1bWVudCBpcyB0aGUgYW1vdW50IHRvIHJvdGF0ZSBieSBpbiB0aGlzIGNhbGwuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNyb3RhdGVUb0FuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRBbmdsZSAtIFRoZSBjdXJyZW50IGFuZ2xlLCBpbiByYWRpYW5zLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRBbmdsZSAtIFRoZSB0YXJnZXQgYW5nbGUgdG8gcm90YXRlIHRvLCBpbiByYWRpYW5zLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbGVycD0wLjA1XSAtIFRoZSBsZXJwIHZhbHVlIHRvIGFkZCB0byB0aGUgY3VycmVudCBhbmdsZS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhZGp1c3RlZCBhbmdsZS5cclxuKi9cclxudmFyIFJvdGF0ZVRvID0gZnVuY3Rpb24gKGN1cnJlbnRBbmdsZSwgdGFyZ2V0QW5nbGUsIGxlcnApXHJcbntcclxuICAgIGlmIChsZXJwID09PSB1bmRlZmluZWQpIHsgbGVycCA9IDAuMDU7IH1cclxuXHJcbiAgICBpZiAoY3VycmVudEFuZ2xlID09PSB0YXJnZXRBbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNYXRoLmFicyh0YXJnZXRBbmdsZSAtIGN1cnJlbnRBbmdsZSkgPD0gbGVycCB8fCBNYXRoLmFicyh0YXJnZXRBbmdsZSAtIGN1cnJlbnRBbmdsZSkgPj0gKE1BVEhfQ09OU1QuUEkyIC0gbGVycCkpXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVudEFuZ2xlID0gdGFyZ2V0QW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+IE1hdGguUEkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5nbGUgPCBjdXJyZW50QW5nbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlICs9IE1BVEhfQ09OU1QuUEkyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QW5nbGUgLT0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXRBbmdsZSA+IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBbmdsZSArPSBsZXJwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBbmdsZSAtPSBsZXJwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9Sb3RhdGVUby5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCIvKipcclxuKiBHZXRzIHRoZSBzaG9ydGVzdCBhbmdsZSBiZXR3ZWVuIGBhbmdsZTFgIGFuZCBgYW5nbGUyYC5cclxuKiBCb3RoIGFuZ2xlcyBtdXN0IGJlIGluIHRoZSByYW5nZSAtMTgwIHRvIDE4MCwgd2hpY2ggaXMgdGhlIHNhbWUgY2xhbXBlZFxyXG4qIHJhbmdlIHRoYXQgYHNwcml0ZS5hbmdsZWAgdXNlcywgc28geW91IGNhbiBwYXNzIGluIHR3byBzcHJpdGUgYW5nbGVzIHRvXHJcbiogdGhpcyBtZXRob2QsIGFuZCBnZXQgdGhlIHNob3J0ZXN0IGFuZ2xlIGJhY2sgYmV0d2VlbiB0aGUgdHdvIG9mIHRoZW0uXHJcbipcclxuKiBUaGUgYW5nbGUgcmV0dXJuZWQgd2lsbCBiZSBpbiB0aGUgc2FtZSByYW5nZS4gSWYgdGhlIHJldHVybmVkIGFuZ2xlIGlzXHJcbiogZ3JlYXRlciB0aGFuIDAgdGhlbiBpdCdzIGEgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24sIGlmIDwgMCB0aGVuIGl0J3NcclxuKiBhIGNsb2Nrd2lzZSByb3RhdGlvbi5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI2dldFNob3J0ZXN0QW5nbGVcclxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUxIC0gVGhlIGZpcnN0IGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlMiAtIFRoZSBzZWNvbmQgYW5nbGUuIEluIHRoZSByYW5nZSAtMTgwIHRvIDE4MC5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaG9ydGVzdCBhbmdsZSwgaW4gZGVncmVlcy4gSWYgZ3JlYXRlciB0aGFuIHplcm8gaXQncyBhIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxyXG4qL1xyXG52YXIgU2hvcnRlc3RCZXR3ZWVuID0gZnVuY3Rpb24gKGFuZ2xlMSwgYW5nbGUyKVxyXG57XHJcbiAgICB2YXIgZGlmZmVyZW5jZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcclxuXHJcbiAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGltZXMgPSBNYXRoLmZsb29yKChkaWZmZXJlbmNlIC0gKC0xODApKSAvIDM2MCk7XHJcblxyXG4gICAgcmV0dXJuIGRpZmZlcmVuY2UgLSAodGltZXMgKiAzNjApO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRlc3RCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1Nob3J0ZXN0QmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXcmFwID0gcmVxdWlyZSgnLi4vV3JhcCcpO1xyXG5cclxudmFyIFdyYXBEZWdyZWVzID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gV3JhcChhbmdsZSwgLTE4MCwgMTgwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV3JhcERlZ3JlZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXHJcbiAgICBCZXR3ZWVuWTogcmVxdWlyZSgnLi9CZXR3ZWVuWScpLFxyXG4gICAgQmV0d2VlblBvaW50czogcmVxdWlyZSgnLi9CZXR3ZWVuUG9pbnRzJyksXHJcbiAgICBCZXR3ZWVuUG9pbnRzWTogcmVxdWlyZSgnLi9CZXR3ZWVuUG9pbnRzWScpLFxyXG4gICAgUmV2ZXJzZTogcmVxdWlyZSgnLi9SZXZlcnNlJyksXHJcbiAgICBSb3RhdGVUbzogcmVxdWlyZSgnLi9Sb3RhdGVUbycpLFxyXG4gICAgU2hvcnRlc3RCZXR3ZWVuOiByZXF1aXJlKCcuL1Nob3J0ZXN0QmV0d2VlbicpLFxyXG4gICAgTm9ybWFsaXplOiByZXF1aXJlKCcuL05vcm1hbGl6ZScpLFxyXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJyksXHJcbiAgICBXcmFwRGVncmVlczogcmVxdWlyZSgnLi9XcmFwRGVncmVlcycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9hbmdsZS9pbmRleC5qcyIsInZhciBEaXN0YW5jZVBvd2VyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCBwb3cpXHJcbntcclxuICAgIGlmIChwb3cgPT09IHVuZGVmaW5lZCkgeyBwb3cgPSAyOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCBwb3cpICsgTWF0aC5wb3coeTIgLSB5MSwgcG93KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlUG93ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VQb3dlci5qc1xuLy8gbW9kdWxlIGlkID0gMjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbntcclxuICAgIHZhciBkeCA9IHgxIC0geDI7XHJcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VTcXVhcmVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlU3F1YXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vRGlzdGFuY2VCZXR3ZWVuJyksXHJcbiAgICBQb3dlcjogcmVxdWlyZSgnLi9EaXN0YW5jZVBvd2VyJyksXHJcbiAgICBTcXVhcmVkOiByZXF1aXJlKCcuL0Rpc3RhbmNlU3F1YXJlZCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsImZ1bmN0aW9uIEluICh2LCBvdmVyc2hvb3QpXHJcbntcclxuICAgIGlmIChvdmVyc2hvb3QgPT09IHVuZGVmaW5lZCkgeyBvdmVyc2hvb3QgPSAxLjcwMTU4OyB9XHJcblxyXG4gICAgcmV0dXJuIHYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgLSBvdmVyc2hvb3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICByZXR1cm4gLS12ICogdiAqICgob3ZlcnNob290ICsgMSkgKiB2ICsgb3ZlcnNob290KSArIDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2LCBvdmVyc2hvb3QpXHJcbntcclxuICAgIGlmIChvdmVyc2hvb3QgPT09IHVuZGVmaW5lZCkgeyBvdmVyc2hvb3QgPSAxLjcwMTU4OyB9XHJcblxyXG4gICAgdmFyIHMgPSBvdmVyc2hvb3QgKiAxLjUyNTtcclxuXHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAodiAqIHYgKiAoKHMgKyAxKSAqIHYgLSBzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiAoKHMgKyAxKSAqIHYgKyBzKSArIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvQmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICB2ID0gMSAtIHY7XHJcblxyXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiB2ICogdik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAodiA8IDAuNSlcclxuICAgIHtcclxuICAgICAgICB2ID0gMSAtICh2ICogMik7XHJcbiAgICAgICAgcmV2ZXJzZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdiA9ICh2ICogMikgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2IDwgMSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJldmVyc2UpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgxIC0gdikgKiAwLjU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHYgKiAwLjUgKyAwLjU7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9Cb3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHYgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS12ICogdikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHYgKiB2KSAtIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodiAtPSAyKSAqIHYpICsgMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9DaXJjdWxhci5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiAtLXYgKiB2ICogdiArIDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICsgMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9DdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcclxue1xyXG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxyXG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxyXG5cclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XHJcblxyXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLShhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXHJcbntcclxuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cclxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cclxuXHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xyXG5cclxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiB2KSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSArIDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXHJcbntcclxuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cclxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cclxuXHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xyXG5cclxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSAqIDAuNSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvRWxhc3RpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodiAtIDEpKSAtIDAuMDAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogdik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqICh2IC0gMSkpKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0V4cG8uanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBMaW5lYXIgRWFzaW5nIChubyB2YXJpYXRpb24pLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5FYXNpbmcuTGluZWFyI05vbmVcclxuKiBAcGFyYW0ge251bWJlcn0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0d2VlbmVkLlxyXG4qIEByZXR1cm5zIHtudW1iZXJ9IHYuXHJcbiovXHJcbnZhciBMaW5lYXIgPSBmdW5jdGlvbiAodilcclxue1xyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvTGluZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdjtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqICgyIC0gdik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqICgtLXYgKiAodiAtIDIpIC0gMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9RdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSAoLS12ICogdiAqIHYgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoKHYgLT0gMikgKiB2ICogdiAqIHYgLSAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1YXJ0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2ICogdiAqIHYgKiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiAtLXYgKiB2ICogdiAqIHYgKiB2ICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdiAqIHYgKiB2O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoKHYgLT0gMikgKiB2ICogdiAqIHYgKiB2ICsgMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9RdWludGljLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKHYgKiBNYXRoLlBJIC8gMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNpbih2ICogTWF0aC5QSSAvIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiB2KSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9TaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmFjazogcmVxdWlyZSgnLi9CYWNrJyksXHJcbiAgICBCb3VuY2U6IHJlcXVpcmUoJy4vQm91bmNlJyksXHJcbiAgICBDaXJjdWxhcjogcmVxdWlyZSgnLi9DaXJjdWxhcicpLFxyXG4gICAgQ3ViaWM6IHJlcXVpcmUoJy4vQ3ViaWMnKSxcclxuICAgIEVsYXN0aWM6IHJlcXVpcmUoJy4vRWxhc3RpYycpLFxyXG4gICAgRXhwbzogcmVxdWlyZSgnLi9FeHBvJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXHJcbiAgICBRdWFkcmF0aWM6IHJlcXVpcmUoJy4vUXVhZHJhdGljJyksXHJcbiAgICBRdWFydGljOiByZXF1aXJlKCcuL1F1YXJ0aWMnKSxcclxuICAgIFF1aW50aWM6IHJlcXVpcmUoJy4vUXVpbnRpYycpLFxyXG4gICAgU2luZTogcmVxdWlyZSgnLi9TaW5lJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9lYXNpbmcvaW5kZXguanMiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAtIGVwc2lsb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWwgPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IGVwc2lsb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXHJcbntcclxuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICsgZXBzaWxvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXHJcbntcclxuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxyXG5cclxuICAgIHJldHVybiBhID4gYiAtIGVwc2lsb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyZWF0ZXJUaGFuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0dyZWF0ZXJUaGFuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlc3NUaGFuID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXHJcbntcclxuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxyXG5cclxuICAgIHJldHVybiBhIDwgYiArIGVwc2lsb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExlc3NUaGFuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9DZWlsJyksXHJcbiAgICBFcXVhbDogcmVxdWlyZSgnLi9FcXVhbCcpLFxyXG4gICAgRmxvb3I6IHJlcXVpcmUoJy4vRmxvb3InKSxcclxuICAgIEdyZWF0ZXJUaGFuOiByZXF1aXJlKCcuL0dyZWF0ZXJUaGFuJyksXHJcbiAgICBMZXNzVGhhbjogcmVxdWlyZSgnLi9MZXNzVGhhbicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9mdXp6eS9pbmRleC5qcyIsInZhciBCZXJuc3RlaW4gPSByZXF1aXJlKCcuLi9CZXJuc3RlaW4nKTtcclxuXHJcbnZhciBCZXppZXJJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBiID0gMDtcclxuICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKylcclxuICAgIHtcclxuICAgICAgICBiICs9IE1hdGgucG93KDEgLSBrLCBuIC0gaSkgKiBNYXRoLnBvdyhrLCBpKSAqIHZbaV0gKiBCZXJuc3RlaW4obiwgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJlemllckludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ2YXIgQ2F0bXVsbFJvbSA9IHJlcXVpcmUoJy4uL0NhdG11bGxSb20nKTtcclxuXHJcbnZhciBDYXRtdWxsUm9tSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxyXG57XHJcbiAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XHJcblxyXG4gICAgaWYgKHZbMF0gPT09IHZbbV0pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGsgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoZiA9IG0gKiAoMSArIGspKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDYXRtdWxsUm9tKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGsgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZbMF0gLSAoQ2F0bXVsbFJvbSh2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrID4gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2W21dIC0gKENhdG11bGxSb20odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDYXRtdWxsUm9tKHZbaSA/IGkgLSAxIDogMF0sIHZbaV0sIHZbbSA8IGkgKyAxID8gbSA6IGkgKyAxXSwgdlttIDwgaSArIDIgPyBtIDogaSArIDJdLCBmIC0gaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhdG11bGxSb21JbnRlcnBvbGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vQ2F0bXVsbFJvbUludGVycG9sYXRpb24uanMiLCJ2YXIgTGluZWFyID0gcmVxdWlyZSgnLi4vTGluZWFyJyk7XHJcblxyXG52YXIgTGluZWFySW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxyXG57XHJcbiAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XHJcblxyXG4gICAgaWYgKGsgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlswXSwgdlsxXSwgZik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGsgPiAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBMaW5lYXIodlttXSwgdlttIC0gMV0sIG0gLSBmKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTGluZWFyKHZbaV0sIHZbKGkgKyAxID4gbSkgPyBtIDogaSArIDFdLCBmIC0gaSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBCZXppZXI6IHJlcXVpcmUoJy4vQmV6aWVySW50ZXJwb2xhdGlvbicpLFxyXG4gICAgQ2F0bXVsbFJvbTogcmVxdWlyZSgnLi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbicpLFxyXG4gICAgTGluZWFyOiByZXF1aXJlKCcuL0xpbmVhckludGVycG9sYXRpb24nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzIiwiLy8gIFRha2VzIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDJcclxuXHJcbnZhciBHZXRQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICAvLyAgTWF0aC5sb2coMilcclxuICAgIHZhciBpbmRleCA9IE1hdGgubG9nKHZhbHVlKSAvIDAuNjkzMTQ3MTgwNTU5OTQ1MztcclxuXHJcbiAgICByZXR1cm4gKDEgPDwgTWF0aC5jZWlsKGluZGV4KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9HZXRQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIElzIHZhbHVlIGEgcG93ZXIgb2YgMj9cclxuXHJcbnZhciBJc1ZhbHVlUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgcmV0dXJuICh2YWx1ZSA+IDAgJiYgKHZhbHVlICYgKHZhbHVlIC0gMSkpID09PSAwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXNWYWx1ZVBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1ZhbHVlUG93ZXJPZlR3by5qc1xuLy8gbW9kdWxlIGlkID0gMjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvcG93Mi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnQgPSB7XHJcblxyXG4gICAgR2V0TmV4dDogcmVxdWlyZSgnLi9HZXRQb3dlck9mVHdvJyksXHJcbiAgICBJc1NpemU6IHJlcXVpcmUoJy4vSXNTaXplUG93ZXJPZlR3bycpLFxyXG4gICAgSXNWYWx1ZTogcmVxdWlyZSgnLi9Jc1ZhbHVlUG93ZXJPZlR3bycpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3BvdzIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAcHJvcGVydHkge251bWJlcn0gYyAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgYyA9IDE7XHJcblxyXG4vKipcclxuKiBAcHJvcGVydHkge251bWJlcn0gczAgLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHMwID0gMDtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMSAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgczEgPSAwO1xyXG5cclxuLyoqXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMyIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBzMiA9IDA7XHJcblxyXG4vKipcclxuKiBAcHJvcGVydHkge0FycmF5fSBzaWduIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBzaWduID0gWyAtMSwgMSBdO1xyXG5cclxuLyoqXHJcbiogUHJpdmF0ZSByYW5kb20gaGVscGVyLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNybmRcclxuKiBAcHJpdmF0ZVxyXG4qIEByZXR1cm4ge251bWJlcn1cclxuKi9cclxudmFyIHJuZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXHJcblxyXG4gICAgYyA9IHQgfCAwO1xyXG4gICAgczAgPSBzMTtcclxuICAgIHMxID0gczI7XHJcbiAgICBzMiA9IHQgLSBjO1xyXG5cclxuICAgIHJldHVybiBzMjtcclxufTtcclxuXHJcbi8qKlxyXG4qIEludGVybmFsIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBzZWVkIGhhc2guXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2hhc2hcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7YW55fSBkYXRhXHJcbiogQHJldHVybiB7bnVtYmVyfSBoYXNoZWQgdmFsdWUuXHJcbiovXHJcbnZhciBoYXNoID0gZnVuY3Rpb24gKGRhdGEpXHJcbntcclxuICAgIHZhciBoLCBpLCBuO1xyXG4gICAgbiA9IDB4ZWZjODI0OWQ7XHJcbiAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgaCAqPSBuO1xyXG4gICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgIGggLT0gbjtcclxuICAgICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsvLyAyXjMyXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7Ly8gMl4tMzJcclxufTtcclxuXHJcblxyXG52YXIgUmFuZG9tRGF0YUdlbmVyYXRvciA9IGZ1bmN0aW9uIChzZWVkcylcclxue1xyXG4gICAgaWYgKHR5cGVvZiBzZWVkcyA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZShzZWVkcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zb3coc2VlZHMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xyXG5cclxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlc2V0IHRoZSBzZWVkIG9mIHRoZSByYW5kb20gZGF0YSBnZW5lcmF0b3IuXHJcbiAgICAqXHJcbiAgICAqIF9Ob3RlXzogdGhlIHNlZWQgYXJyYXkgaXMgb25seSBwcm9jZXNzZWQgdXAgdG8gdGhlIGZpcnN0IGB1bmRlZmluZWRgIChvciBgbnVsbGApIHZhbHVlLCBzaG91bGQgc3VjaCBiZSBwcmVzZW50LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3Nvd1xyXG4gICAgKiBAcGFyYW0ge2FueVtdfSBzZWVkcyAtIFRoZSBhcnJheSBvZiBzZWVkczogdGhlIGB0b1N0cmluZygpYCBvZiBlYWNoIHZhbHVlIGlzIHVzZWQuXHJcbiAgICAqL1xyXG4gICAgc293OiBmdW5jdGlvbiAoc2VlZHMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IHRvIGRlZmF1bHQgc2VlZFxyXG4gICAgICAgIHMwID0gaGFzaCgnICcpO1xyXG4gICAgICAgIHMxID0gaGFzaChzMCk7XHJcbiAgICAgICAgczIgPSBoYXNoKHMxKTtcclxuICAgICAgICBjID0gMTtcclxuXHJcbiAgICAgICAgaWYgKCFzZWVkcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGFueSBzZWVkc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VlZHMubGVuZ3RoICYmIChzZWVkc1tpXSAhPSBudWxsKTsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNlZWQgPSBzZWVkc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHMwIC09IGhhc2goc2VlZCk7XHJcbiAgICAgICAgICAgIHMwICs9IH5+KHMwIDwgMCk7XHJcbiAgICAgICAgICAgIHMxIC09IGhhc2goc2VlZCk7XHJcbiAgICAgICAgICAgIHMxICs9IH5+KHMxIDwgMCk7XHJcbiAgICAgICAgICAgIHMyIC09IGhhc2goc2VlZCk7XHJcbiAgICAgICAgICAgIHMyICs9IH5+KHMyIDwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaW50ZWdlclxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKi9cclxuICAgIGludGVnZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gMl4zMlxyXG4gICAgICAgIHJldHVybiBybmQoKSAqIDB4MTAwMDAwMDAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjZnJhY1xyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICovXHJcbiAgICBmcmFjOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIDJeLTUzXHJcbiAgICAgICAgcmV0dXJuIHJuZCgpICsgKHJuZCgpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyZWFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKi9cclxuICAgIHJlYWw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigpICsgdGhpcy5mcmFjKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIG1pbiBhbmQgbWF4LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2ludGVnZXJJblJhbmdlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgaW50ZWdlckluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnJlYWxJblJhbmdlKDAsIG1heCAtIG1pbiArIDEpICsgbWluKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXHJcbiAgICAqIFRoaXMgbWV0aG9kIGlzIGFuIGFsaWFzIGZvciBSYW5kb21EYXRhR2VuZXJhdG9yLmludGVnZXJJblJhbmdlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2JldHdlZW5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICovXHJcbiAgICBiZXR3ZWVuOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlckluUmFuZ2UobWluLCBtYXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JlYWxJblJhbmdlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgcmVhbEluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcmFjKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNub3JtYWxcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLlxyXG4gICAgKi9cclxuICAgIG5vcm1hbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMSAtICgyICogdGhpcy5mcmFjKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHZhbGlkIFJGQzQxMjIgdmVyc2lvbjQgSUQgaGV4IHN0cmluZyBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEzMDgzNjhcclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciN1dWlkXHJcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gQSB2YWxpZCBSRkM0MTIyIHZlcnNpb240IElEIGhleCBzdHJpbmdcclxuICAgICovXHJcbiAgICB1dWlkOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhID0gJyc7XHJcbiAgICAgICAgdmFyIGIgPSAnJztcclxuXHJcbiAgICAgICAgZm9yIChiID0gYSA9ICcnOyBhKysgPCAzNjsgYiArPX5hICUgNSB8IGEgKiAzJjQgPyAoYV4xNSA/IDhedGhpcy5mcmFjKCkgKiAoYV4yMCA/IDE2IDogNCkgOiA0KS50b1N0cmluZygxNikgOiAnLScpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIG1lbWJlciBvZiBgYXJyYXlgLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3BpY2tcclxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBbiBBcnJheSB0byBwaWNrIGEgcmFuZG9tIG1lbWJlciBvZi5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxyXG4gICAgKi9cclxuICAgIHBpY2s6IGZ1bmN0aW9uIChhcnJheSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlbdGhpcy5pbnRlZ2VySW5SYW5nZSgwLCBhcnJheS5sZW5ndGggLSAxKV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgc2lnbiB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGljYXRpb24gb3BlcmF0b3IuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijc2lnblxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0xIG9yICsxLlxyXG4gICAgKi9cclxuICAgIHNpZ246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayhzaWduKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAsIGZhdm9yaW5nIHRoZSBlYXJsaWVyIGVudHJpZXMuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijd2VpZ2h0ZWRQaWNrXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQW4gQXJyYXkgdG8gcGljayBhIHJhbmRvbSBtZW1iZXIgb2YuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gbWVtYmVyIG9mIHRoZSBhcnJheS5cclxuICAgICovXHJcbiAgICB3ZWlnaHRlZFBpY2s6IGZ1bmN0aW9uIChhcnJheSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlbfn4oTWF0aC5wb3codGhpcy5mcmFjKCksIDIpICogKGFycmF5Lmxlbmd0aCAtIDEpICsgMC41KV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHRpbWVzdGFtcCBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgb2YgMjAwMCBhbmQgdGhlIGVuZCBvZiAyMDIwIGlmIG1pbiBhbmQgbWF4IGFyZW4ndCBzcGVjaWZpZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdGltZXN0YW1wXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgdGltZXN0YW1wOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbEluUmFuZ2UobWluIHx8IDk0NjY4NDgwMDAwMCwgbWF4IHx8IDE1Nzc4NjIwMDAwMDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBhbmdsZSBiZXR3ZWVuIC0xODAgYW5kIDE4MC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNhbmdsZVxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0xODAgYW5kIDE4MC5cclxuICAgICovXHJcbiAgICBhbmdsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZSgtMTgwLCAxODApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByb3RhdGlvbiBpbiByYWRpYW5zLCBiZXR3ZWVuIC0zLjE0MSBhbmQgMy4xNDFcclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyb3RhdGlvblxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0zLjE0MSBhbmQgMy4xNDFcclxuICAgICovXHJcbiAgICByb3RhdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFsSW5SYW5nZSgtMy4xNDE1OTI2NTM1ODk3OTMsIDMuMTQxNTkyNjUzNTg5NzkzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgb3IgU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldGFpbiB0aGUgdmFsdWVzXHJcbiAgICAqIHRoYXQgdGhlIGdlbmVyYXRvciBpcyB1c2luZyBiZXR3ZWVuIGdhbWVzLCBpLmUuIGluIGEgZ2FtZSBzYXZlIGZpbGUuXHJcbiAgICAqXHJcbiAgICAqIFRvIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2l0aCBhIHByZXZpb3VzbHkgc2F2ZWQgc3RhdGUgeW91IGNhbiBwYXNzIGl0IGFzIHRoZVxyXG4gICAgKiBgc2VlZGAgdmFsdWUgaW4geW91ciBnYW1lIGNvbmZpZywgb3IgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSBhZnRlciBQaGFzZXIgaGFzIGJvb3RlZC5cclxuICAgICpcclxuICAgICogQ2FsbCB0aGlzIG1ldGhvZCB3aXRoIG5vIHBhcmFtZXRlcnMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgKlxyXG4gICAgKiBJZiBwcm92aWRpbmcgYSBzdGF0ZSBpdCBzaG91bGQgbWF0Y2ggdGhlIHNhbWUgZm9ybWF0IHRoYXQgdGhpcyBtZXRob2RcclxuICAgICogcmV0dXJucywgd2hpY2ggaXMgYSBzdHJpbmcgd2l0aCBhIGhlYWRlciBgIXJuZGAgZm9sbG93ZWQgYnkgdGhlIGBjYCxcclxuICAgICogYHMwYCwgYHMxYCBhbmQgYHMyYCB2YWx1ZXMgcmVzcGVjdGl2ZWx5LCBlYWNoIGNvbW1hLWRlbGltaXRlZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzdGF0ZVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXRlXSAtIEdlbmVyYXRvciBzdGF0ZSB0byBiZSBzZXQuXHJcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cclxuICAgICovXHJcbiAgICBzdGF0ZTogZnVuY3Rpb24gKHN0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIHN0YXRlLm1hdGNoKC9eIXJuZC8pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICAgICAgYyA9IHBhcnNlRmxvYXQoc3RhdGVbMV0pO1xyXG4gICAgICAgICAgICBzMCA9IHBhcnNlRmxvYXQoc3RhdGVbMl0pO1xyXG4gICAgICAgICAgICBzMSA9IHBhcnNlRmxvYXQoc3RhdGVbM10pO1xyXG4gICAgICAgICAgICBzMiA9IHBhcnNlRmxvYXQoc3RhdGVbNF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFsgJyFybmQnLCBjLCBzMCwgczEsIHMyIF0uam9pbignLCcpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tRGF0YUdlbmVyYXRvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2FwLCBzdGFydClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcblxyXG4gICAgaWYgKGdhcCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUgLT0gc3RhcnQ7XHJcbiAgICB2YWx1ZSA9IGdhcCAqIE1hdGguY2VpbCh2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvU25hcENlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDI4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU25hcEZsb29yID0gZnVuY3Rpb24gKHZhbHVlLCBnYXAsIHN0YXJ0KVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuXHJcbiAgICBpZiAoZ2FwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSAtPSBzdGFydDtcclxuICAgIHZhbHVlID0gZ2FwICogTWF0aC5mbG9vcih2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL1NuYXBGbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwVG8gPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG5cclxuICAgIGlmIChnYXAgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlIC09IHN0YXJ0O1xyXG4gICAgdmFsdWUgPSBnYXAgKiBNYXRoLnJvdW5kKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcFRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvU25hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9TbmFwQ2VpbCcpLFxyXG4gICAgRmxvb3I6IHJlcXVpcmUoJy4vU25hcEZsb29yJyksXHJcbiAgICBUbzogcmVxdWlyZSgnLi9TbmFwVG8nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9zbmFwL2luZGV4LmpzIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmZvckVhY2hcclxuKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXHJcbiovXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpXHJcbntcclxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc0FyZyAqLylcclxuICAgIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvQXJyYXkuZm9yRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5pc0FycmF5XHJcbiovXHJcbmlmICghQXJyYXkuaXNBcnJheSlcclxue1xyXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvQXJyYXkuaXNBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAyMDEzIENocmlzIFdpbHNvblxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qXG5cblRoaXMgbW9ua2V5cGF0Y2ggbGlicmFyeSBpcyBpbnRlbmRlZCB0byBiZSBpbmNsdWRlZCBpbiBwcm9qZWN0cyB0aGF0IGFyZVxud3JpdHRlbiB0byB0aGUgcHJvcGVyIEF1ZGlvQ29udGV4dCBzcGVjIChpbnN0ZWFkIG9mIHdlYmtpdEF1ZGlvQ29udGV4dCksXG5hbmQgdGhhdCB1c2UgdGhlIG5ldyBuYW1pbmcgYW5kIHByb3BlciBiaXRzIG9mIHRoZSBXZWIgQXVkaW8gQVBJIChlLmcuXG51c2luZyBCdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCkgaW5zdGVhZCBvZiBCdWZmZXJTb3VyY2VOb2RlLm5vdGVPbigpKSwgYnV0IG1heVxuaGF2ZSB0byBydW4gb24gc3lzdGVtcyB0aGF0IG9ubHkgc3VwcG9ydCB0aGUgZGVwcmVjYXRlZCBiaXRzLlxuXG5UaGlzIGxpYnJhcnkgc2hvdWxkIGJlIGhhcm1sZXNzIHRvIGluY2x1ZGUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHNcbnVucHJlZml4ZWQgXCJBdWRpb0NvbnRleHRcIiwgYW5kL29yIGlmIGl0IHN1cHBvcnRzIHRoZSBuZXcgbmFtZXMuXG5cblRoZSBwYXRjaGVzIHRoaXMgbGlicmFyeSBoYW5kbGVzOlxuaWYgd2luZG93LkF1ZGlvQ29udGV4dCBpcyB1bnN1cHBvcnRlZCwgaXQgd2lsbCBiZSBhbGlhc2VkIHRvIHdlYmtpdEF1ZGlvQ29udGV4dCgpLlxuaWYgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCkgaXMgdW5pbXBsZW1lbnRlZCwgaXQgd2lsbCBiZSByb3V0ZWQgdG8gbm90ZU9uKCkgb3Jcbm5vdGVHcmFpbk9uKCksIGRlcGVuZGluZyBvbiBwYXJhbWV0ZXJzLlxuXG5UaGUgZm9sbG93aW5nIGFsaWFzZXMgb25seSB0YWtlIGVmZmVjdCBpZiB0aGUgbmV3IG5hbWVzIGFyZSBub3QgYWxyZWFkeSBpbiBwbGFjZTpcblxuQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0b3AoKSBpcyBhbGlhc2VkIHRvIG5vdGVPZmYoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZUdhaW5Ob2RlKClcbkF1ZGlvQ29udGV4dC5jcmVhdGVEZWxheSgpIGlzIGFsaWFzZWQgdG8gY3JlYXRlRGVsYXlOb2RlKClcbkF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZUphdmFTY3JpcHROb2RlKClcbkF1ZGlvQ29udGV4dC5jcmVhdGVQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZVdhdmVUYWJsZSgpXG5Pc2NpbGxhdG9yTm9kZS5zdGFydCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9uKClcbk9zY2lsbGF0b3JOb2RlLnN0b3AoKSBpcyBhbGlhc2VkIHRvIG5vdGVPZmYoKVxuT3NjaWxsYXRvck5vZGUuc2V0UGVyaW9kaWNXYXZlKCkgaXMgYWxpYXNlZCB0byBzZXRXYXZlVGFibGUoKVxuQXVkaW9QYXJhbS5zZXRUYXJnZXRBdFRpbWUoKSBpcyBhbGlhc2VkIHRvIHNldFRhcmdldFZhbHVlQXRUaW1lKClcblxuVGhpcyBsaWJyYXJ5IGRvZXMgTk9UIHBhdGNoIHRoZSBlbnVtZXJhdGVkIHR5cGUgY2hhbmdlcywgYXMgaXQgaXNcbnJlY29tbWVuZGVkIGluIHRoZSBzcGVjaWZpY2F0aW9uIHRoYXQgaW1wbGVtZW50YXRpb25zIHN1cHBvcnQgYm90aCBpbnRlZ2VyXG5hbmQgc3RyaW5nIHR5cGVzIGZvciBBdWRpb1Bhbm5lck5vZGUucGFubmluZ01vZGVsLCBBdWRpb1Bhbm5lck5vZGUuZGlzdGFuY2VNb2RlbFxuQmlxdWFkRmlsdGVyTm9kZS50eXBlIGFuZCBPc2NpbGxhdG9yTm9kZS50eXBlLlxuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGV4cG9ydHMsIHBlcmYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGZpeFNldFRhcmdldChwYXJhbSkge1xuICAgIGlmICghcGFyYW0pXHQvLyBpZiBOWUksIGp1c3QgcmV0dXJuXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwYXJhbS5zZXRUYXJnZXRBdFRpbWUpXG4gICAgICBwYXJhbS5zZXRUYXJnZXRBdFRpbWUgPSBwYXJhbS5zZXRUYXJnZXRWYWx1ZUF0VGltZTtcbiAgfVxuXG4gIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpICYmXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSkge1xuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3ZWJraXRBdWRpb0NvbnRleHQ7XG5cbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZUdhaW4nKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2Fpbk5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVEZWxheScpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXlOb2RlO1xuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlU2NyaXB0UHJvY2Vzc29yJykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFByb2Nlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlSmF2YVNjcmlwdE5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVQZXJpb2RpY1dhdmUnKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVXYXZlVGFibGU7XG5cblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbjtcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVHYWluKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheTtcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gZnVuY3Rpb24obWF4RGVsYXlUaW1lKSB7XG4gICAgICB2YXIgbm9kZSA9IG1heERlbGF5VGltZSA/IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkobWF4RGVsYXlUaW1lKSA6IHRoaXMuaW50ZXJuYWxfY3JlYXRlRGVsYXkoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmRlbGF5VGltZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVCdWZmZXJTb3VyY2UgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZTtcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgaWYgKCFub2RlLnN0YXJ0KSB7XG4gICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoIHdoZW4sIG9mZnNldCwgZHVyYXRpb24gKSB7XG4gICAgICAgICAgaWYgKCBvZmZzZXQgfHwgZHVyYXRpb24gKVxuICAgICAgICAgICAgdGhpcy5ub3RlR3JhaW5Pbiggd2hlbiB8fCAwLCBvZmZzZXQsIGR1cmF0aW9uICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5ub3RlT24oIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiggd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbiApIHtcbiAgICAgICAgICBpZiggdHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJyApXG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0KCB3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24gKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0KCB3aGVuIHx8IDAsIG9mZnNldCB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuc3RvcCkge1xuICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XG4gICAgICAgICAgdGhpcy5ub3RlT2ZmKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCA9IG5vZGUuc3RvcDtcbiAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZpeFNldFRhcmdldChub2RlLnBsYXliYWNrUmF0ZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcjtcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUudGhyZXNob2xkKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmtuZWUpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucmF0aW8pO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucmVkdWN0aW9uKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmF0dGFjayk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yZWxlYXNlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJpcXVhZEZpbHRlciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQmlxdWFkRmlsdGVyO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQmlxdWFkRmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGV0dW5lKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLlEpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZ2Fpbik7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgaWYgKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoICdjcmVhdGVPc2NpbGxhdG9yJyApKSB7XG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZU9zY2lsbGF0b3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU9zY2lsbGF0b3I7XG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU9zY2lsbGF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgaWYgKCFub2RlLnN0YXJ0KSB7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9uKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQgPSBub2RlLnN0YXJ0O1xuICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0KCB3aGVuIHx8IDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnN0b3ApIHtcbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGVPZmYoIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uKCB3aGVuICkge1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5zZXRQZXJpb2RpY1dhdmUpXG4gICAgICAgICAgbm9kZS5zZXRQZXJpb2RpY1dhdmUgPSBub2RlLnNldFdhdmVUYWJsZTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZnJlcXVlbmN5KTtcbiAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGV0dW5lKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQnKSAmJlxuICAgICAgIXdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnT2ZmbGluZUF1ZGlvQ29udGV4dCcpKSB7XG4gICAgd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQgPSB3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0O1xuICB9XG5cbn0od2luZG93KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BdWRpb0NvbnRleHRNb25rZXlQYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vLyBFUzYgTWF0aC50cnVuYyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmNcclxuaWYgKCFNYXRoLnRydW5jKSB7XHJcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IE1hdGguY2VpbCh4KSA6IE1hdGguZmxvb3IoeCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxyXG4qL1xyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcblxyXG4gICAgLyoganNoaW50IGZyZWV6ZTogZmFsc2UgKi9cclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IHRoaXMgOiB0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gKGZ1bmN0aW9uIEYocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90bylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgc3VwZXJuZXc6IHRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKHRhcmdldC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5pc0FycmF5XHJcbiovXHJcbmlmICghQXJyYXkuaXNBcnJheSlcclxue1xyXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxyXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcclxue1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXHJcbiAgICB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBMb3ctYnVkZ2V0IEZsb2F0MzJBcnJheSBrbm9jay1vZmYsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBQMi5qcyBpbiBJRTlcclxuKiBTb3VyY2U6IGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvNTk4OC1waGFzZXItMTItaWU5L1xyXG4qIENhbWVyb24gRm9hbGUgKGh0dHA6Ly93d3cua2liaWJ1LmNvbSlcclxuKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcIm9iamVjdFwiKVxyXG57XHJcbiAgICB2YXIgQ2hlYXBBcnJheSA9IGZ1bmN0aW9uKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IEFycmF5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0gPSBmdW5jdGlvbihhcmcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYXJnKSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmc7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0ucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICAgICAgd2luZG93W3R5cGVdLmNvbnN0cnVjdG9yID0gd2luZG93W3R5cGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBDaGVhcEFycmF5KCdGbG9hdDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnSW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0FycmF5QnVmZmVyJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG59XHJcblxyXG4vKipcclxuICogQWxzbyBmaXggZm9yIHRoZSBhYnNlbnQgY29uc29sZSBpbiBJRTlcclxuICovXHJcbmlmICghd2luZG93LmNvbnNvbGUpXHJcbntcclxuICAgIHdpbmRvdy5jb25zb2xlID0ge307XHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2cgPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbiAgICB3aW5kb3cuY29uc29sZS53YXJuID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xyXG59XHJcblxyXG4vKipcclxuICogcGVyZm9ybWFuY2Uubm93XHJcbiAqL1xyXG4oZnVuY3Rpb24oKXtcclxuXHJcbiAgaWYgKFwicGVyZm9ybWFuY2VcIiBpbiB3aW5kb3cgPT0gZmFsc2UpIHtcclxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XHJcbiAgfVxyXG4gIFxyXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXHJcbiAge1xyXG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XHJcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XHJcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8vIEVTNiBNYXRoLnRydW5jIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuY1xyXG5pZiAoIU1hdGgudHJ1bmMpIHtcclxuICAgIE1hdGgudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwID8gTWF0aC5jZWlsKHgpIDogTWF0aC5mbG9vcih4KTtcclxuICAgIH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL01hdGgudHJ1bmMuanNcbi8vIG1vZHVsZSBpZCA9IDI5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuXHJcbi8qKlxyXG4qIExvdy1idWRnZXQgRmxvYXQzMkFycmF5IGtub2NrLW9mZiwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFAyLmpzIGluIElFOVxyXG4qIFNvdXJjZTogaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy81OTg4LXBoYXNlci0xMi1pZTkvXHJcbiogQ2FtZXJvbiBGb2FsZSAoaHR0cDovL3d3dy5raWJpYnUuY29tKVxyXG4qL1xyXG5pZiAodHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwib2JqZWN0XCIpXHJcbntcclxuICAgIHZhciBDaGVhcEFycmF5ID0gZnVuY3Rpb24odHlwZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSBuZXcgQXJyYXkoKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXSA9IGZ1bmN0aW9uKGFyZykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdpbmRvd1t0eXBlXS5wcm90b3R5cGUgPSBwcm90bztcclxuICAgICAgICB3aW5kb3dbdHlwZV0uY29uc3RydWN0b3IgPSB3aW5kb3dbdHlwZV07XHJcbiAgICB9O1xyXG5cclxuICAgIENoZWFwQXJyYXkoJ0Zsb2F0MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnVWludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdJbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnQXJyYXlCdWZmZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxyXG4gKi9cclxuaWYgKCF3aW5kb3cuY29uc29sZSlcclxue1xyXG4gICAgd2luZG93LmNvbnNvbGUgPSB7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL2NvbnNvbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIHBlcmZvcm1hbmNlLm5vd1xyXG4gKi9cclxuKGZ1bmN0aW9uKCl7XHJcblxyXG4gIGlmIChcInBlcmZvcm1hbmNlXCIgaW4gd2luZG93ID09IGZhbHNlKSB7XHJcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xyXG4gIH1cclxuICBcclxuICBEYXRlLm5vdyA9IChEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7ICAvLyB0aGFua3MgSUU4XHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICB9KTtcclxuXHJcbiAgaWYgKFwibm93XCIgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IGZhbHNlKVxyXG4gIHtcclxuICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xyXG4gICAgXHJcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xyXG4gICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdygpe1xyXG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcclxuICAgIH1cclxuICB9XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvcGVyZm9ybWFuY2Uubm93LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIi8vIFJlZmVyZW5jZXM6XHJcbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE1Nzk2NzFcclxuLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cclxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdGltaGFsbC80MDc4NjE0XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS90cmVlL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcblxyXG4vLyBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggQnJvd3NlcmZpeVxyXG4vLyBCcm93c2VyaWZ5IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgdXNlIG9mIGBnbG9iYWxgIGFuZCBwYXNzZXMgdGhlXHJcbi8vIGNvcnJlY3QgcmVmZXJlbmNlIG9mIGBnbG9iYWxgLCBgc2VsZmAsIGFuZCBmaW5hbGx5IGB3aW5kb3dgXHJcblxyXG4vLyBEYXRlLm5vd1xyXG5pZiAoIShEYXRlLm5vdyAmJiBEYXRlLnByb3RvdHlwZS5nZXRUaW1lKSkge1xyXG4gICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcGVyZm9ybWFuY2Uubm93XHJcbmlmICghKGdsb2JhbC5wZXJmb3JtYW5jZSAmJiBnbG9iYWwucGVyZm9ybWFuY2Uubm93KSkge1xyXG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICBpZiAoIWdsb2JhbC5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIGdsb2JhbC5wZXJmb3JtYW5jZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG52YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcblxyXG5mb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxyXG4gICAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG59XHJcblxyXG5pZiAoIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnaXMgbm90IGEgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGRlbGF5ID0gMTYgKyBsYXN0VGltZSAtIGN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxhc3RUaW1lID0gY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhwZXJmb3JtYW5jZS5ub3coKSk7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgIH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE5PUk1BTDogMCxcclxuICAgIEFERDogMSxcclxuICAgIE1VTFRJUExZOiAyLFxyXG4gICAgU0NSRUVOOiAzLFxyXG4gICAgT1ZFUkxBWTogNCxcclxuICAgIERBUktFTjogNSxcclxuICAgIExJR0hURU46IDYsXHJcbiAgICBDT0xPUl9ET0RHRTogNyxcclxuICAgIENPTE9SX0JVUk46IDgsXHJcbiAgICBIQVJEX0xJR0hUOiA5LFxyXG4gICAgU09GVF9MSUdIVDogMTAsXHJcbiAgICBESUZGRVJFTkNFOiAxMSxcclxuICAgIEVYQ0xVU0lPTjogMTIsXHJcbiAgICBIVUU6IDEzLFxyXG4gICAgU0FUVVJBVElPTjogMTQsXHJcbiAgICBDT0xPUjogMTUsXHJcbiAgICBMVU1JTk9TSVRZOiAxNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvQmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBEcmF3SW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL0RyYXdJbWFnZScpO1xyXG52YXIgR2V0QmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4vdXRpbHMvR2V0QmxlbmRNb2RlcycpO1xyXG5cclxudmFyIENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXHJcbiAgICAqL1xyXG4gICAgLy8gIE5lZWRlZD9cclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgLy8gIE5lZWRlZD9cclxuICAgIHRoaXMudHlwZSA9IENPTlNULkNBTlZBUztcclxuXHJcbiAgICAvLyAgUmVhZCBhbGwgdGhlIGZvbGxvd2luZyBmcm9tIGdhbWUgY29uZmlnIChvciBTdGF0ZSBjb25maWc/KVxyXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XHJcblxyXG4gICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHRoaXMuc21vb3RoUHJvcGVydHkgPSBQaGFzZXIuQ2FudmFzLmdldFNtb290aGluZ1ByZWZpeCh0aGlzLmNvbnRleHQpO1xyXG5cclxuICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxyXG4gICAgICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XHJcblxyXG4gICAgLy8gIE1hcCB0byB0aGUgcmVxdWlyZWQgZnVuY3Rpb25cclxuICAgIHRoaXMuZHJhd0ltYWdlID0gRHJhd0ltYWdlO1xyXG5cclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IEdldEJsZW5kTW9kZXMoKTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XHJcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gMDtcclxuXHJcbiAgICAvLyB0aGlzLnRpbnRNZXRob2QgPSB0aGlzLnRpbnRXaXRoUGVyUGl4ZWw7XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZW5kZXJlcjtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXM7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXM7XHJcblxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXMpICsgJ3B4JztcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuc21vb3RoUHJvcGVydHkpXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICB0aGlzLmNvbnRleHRbdGhpcy5zbW9vdGhQcm9wZXJ0eV0gPSAodGhpcy5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgU3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0byBiZSByZW5kZXJlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSAtIFRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzbid0IGJlZW4gc2ltdWxhdGVkIHlldCwgZGl2aWRlZFxyXG4gICAgICogICBieSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB3aWxsIGJlIHNpbXVsYXRlZCB0aGUgbmV4dCB0aW1lIHVwZGF0ZSgpXHJcbiAgICAgKiAgIHJ1bnMuIFVzZWZ1bCBmb3IgaW50ZXJwb2xhdGluZyBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKHN0YXRlLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIHN0YXJ0ICcsICdjb2xvcjogI2ZmZmZmZjsgYmFja2dyb3VuZDogIzAwZmYwMDsnKTtcclxuXHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gIEFkZCBQcmUtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgLy8gIFRPRE86IEEgU3RhdGUgc2hvdWxkIGhhdmUgdGhlIG9wdGlvbiBvZiBoYXZpbmcgaXRzIG93biBjYW52YXMgdG8gZHJhdyB0b1xyXG5cclxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlIGFscGhhIG9yIGJsZW5kIG1vZGUgZGlkbid0IGNoYW5nZSBzaW5jZSB0aGUgbGFzdCByZW5kZXIsIHRoZW4gZG9uJ3Qgc2V0IHRoZW0gYWdhaW4gKHNhdmVzIDIgb3BzKVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jbGVhckJlZm9yZVJlbmRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xyXG5cclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyQ2FudmFzKHRoaXMsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIGVuZCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICNmZjAwMDA7Jyk7XHJcblxyXG4gICAgICAgIC8vICBBZGQgUG9zdC1yZW5kZXIgaG9va1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0gW3JlbW92ZVZpZXc9dHJ1ZV0ge2Jvb2xlYW59IFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgQ2FudmFzUG9vbFxyXG5cclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwiXHJcbnZhciBEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoZnJhbWUsIGJsZW5kTW9kZSwgdHJhbnNmb3JtLCBhbHBoYSwgdGludCwgYmcpXHJcbntcclxuICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcclxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGVzW2JsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmcgKHNob3VsZCB0aGlzIGJlIGEgR2FtZSBPYmplY3QsIG9yIEZyYW1lIC8gVGV4dHVyZSBsZXZlbCBwcm9wZXJ0eT8pXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudFNjYWxlTW9kZSAhPT0gZnJhbWUuc291cmNlLnNjYWxlTW9kZSlcclxuICAgIHtcclxuICAgICAgICAvLyB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSBzb3VyY2Uuc2NhbGVNb2RlO1xyXG4gICAgICAgIC8vIGN0eFt0aGlzLnNtb290aFByb3BlcnR5XSA9IChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUik7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShmcmFtZS5zb3VyY2UuaW1hZ2UsIGNkLnN4LCBjZC5zeSwgY2Quc1dpZHRoLCBjZC5zSGVpZ2h0LCB0cmFuc2Zvcm0uZHgsIHRyYW5zZm9ybS5keSwgY2QuZFdpZHRoLCBjZC5kSGVpZ2h0KTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb2RlcyA9IHJlcXVpcmUoJy4uLy4uL0JsZW5kTW9kZXMnKTtcclxudmFyIENhbnZhc0ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzJyk7XHJcblxyXG52YXIgR2V0QmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHZhciB1c2VOZXcgPSBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcztcclxuXHJcbiAgICBvdXRwdXRbbW9kZXMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcclxuICAgIG91dHB1dFttb2Rlcy5NVUxUSVBMWV0gPSAodXNlTmV3KSA/ICdtdWx0aXBseScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNDUkVFTl0gPSAodXNlTmV3KSA/ICdzY3JlZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5EQVJLRU5dID0gKHVzZU5ldykgPyAnZGFya2VuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTElHSFRFTl0gPSAodXNlTmV3KSA/ICdsaWdodGVuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5DT0xPUl9CVVJOXSA9ICh1c2VOZXcpID8gJ2NvbG9yLWJ1cm4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5IQVJEX0xJR0hUXSA9ICh1c2VOZXcpID8gJ2hhcmQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5ESUZGRVJFTkNFXSA9ICh1c2VOZXcpID8gJ2RpZmZlcmVuY2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5FWENMVVNJT05dID0gKHVzZU5ldykgPyAnZXhjbHVzaW9uJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNBVFVSQVRJT05dID0gKHVzZU5ldykgPyAnc2F0dXJhdGlvbicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkNPTE9SXSA9ICh1c2VOZXcpID8gJ2NvbG9yJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QmxlbmRNb2RlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGF1dGhvciAgICAgICBNYXQgR3JvdmVzIChARG9vcm1hdDIzKVxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xyXG52YXIgQ3JlYXRlRW1wdHlUZXh0dXJlID0gcmVxdWlyZSgnLi91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUnKTtcclxudmFyIENyZWF0ZVRleHR1cmUyREltYWdlID0gcmVxdWlyZSgnLi91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREltYWdlJyk7XHJcbnZhciBCbGl0dGVyQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2gnKTtcclxudmFyIFNwcml0ZUJhdGNoID0gcmVxdWlyZSgnLi9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaCcpO1xyXG5cclxudmFyIFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5XRUJHTDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuXHJcbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcclxuICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xyXG4gICAgdGhpcy5tdWx0aVRleHR1cmUgPSBmYWxzZTtcclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuZ2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHRoaXMuYmxpdHRlckJhdGNoID0gbmV3IEJsaXR0ZXJCYXRjaChnYW1lLCB0aGlzLmdsLCB0aGlzKTtcclxuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBuZXcgU3ByaXRlQmF0Y2goZ2FtZSwgdGhpcy5nbCwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG59O1xyXG5cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlcmVyO1xyXG5cclxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgdGhpcy5jb25maWcuV2ViR0xDb250ZXh0T3B0aW9ucykgfHwgdGhpcy52aWV3LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRMb3N0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXIuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIC8vICBXaWxsIG5lZWQgc3VwcG9ydGluZ1xyXG5cclxuICAgICAgICB0aGlzLm1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWF4VGV4dHVyZXMgPT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpVGV4dHVyZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU11bHRpRW1wdHlUZXh0dXJlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbXB0eVRleHR1cmUgPSBDcmVhdGVFbXB0eVRleHR1cmUodGhpcy5nbCwgMSwgMSwgMCwgMCk7XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigxLCAwLCAwLCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIC8vICBXaWxsIG5lZWQgc3VwcG9ydGluZ1xyXG5cclxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMuY29tcHJlc3Npb24gPSB7fTtcclxuXHJcbiAgICAgICAgdmFyIGV0YzEgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKTtcclxuICAgICAgICB2YXIgcHZydGMgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpO1xyXG4gICAgICAgIHZhciBzM3RjID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XHJcblxyXG4gICAgICAgIGlmIChldGMxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmNvbXByZXNzaW9uLkVUQzEgPSBldGMxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHB2cnRjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmNvbXByZXNzaW9uLlBWUlRDID0gcHZydGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoczN0YylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbi5TM1RDID0gczN0YztcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gIE1hcCBCbGVuZCBNb2Rlc1xyXG5cclxuICAgICAgICB2YXIgYWRkID0gWyBnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQSBdO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBbIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdO1xyXG4gICAgICAgIHZhciBtdWx0aXBseSA9IFsgZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF07XHJcbiAgICAgICAgdmFyIHNjcmVlbiA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkUgXTtcclxuXHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gW1xyXG4gICAgICAgICAgICBub3JtYWwsIGFkZCwgbXVsdGlwbHksIHNjcmVlbiwgbm9ybWFsLFxyXG4gICAgICAgICAgICBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsXHJcbiAgICAgICAgICAgIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCxcclxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVGV4dHVyZTJEOiBmdW5jdGlvbiAoc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmICghc291cmNlLmdsVGV4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5nbFRleHR1cmUgPSBDcmVhdGVUZXh0dXJlMkRJbWFnZShnbCwgc291cmNlLmltYWdlLCBnbC5ORUFSRVNULCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IHNvdXJjZS5nbFRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmUyRDogZnVuY3Rpb24gKHRleHR1cmUyRClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlID0gdGV4dHVyZTJEO1xyXG4gICAgICAgIHRoaXMuYmF0Y2guZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCYXRjaDogZnVuY3Rpb24gKGJhdGNoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoICE9IGJhdGNoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXRjaC5iaW5kKCk7XHJcbiAgICAgICAgICAgIGJhdGNoLnNldFRleHR1cmUyRCh0aGlzLmN1cnJlbnRUZXh0dXJlMkQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlcztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcclxuXHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgLy8gIE5lZWRlZD9cclxuICAgICAgICAvLyB0aGlzLmNsaXBVbml0WCA9IDIgLyB0aGlzLndpZHRoO1xyXG4gICAgICAgIC8vIHRoaXMuY2xpcFVuaXRZID0gMiAvIHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyAgTmVlZGVkP1xyXG4gICAgICAgIC8vIHRoaXMucHJvamVjdGlvbi54ID0gKHRoaXMud2lkdGggLyAyKSAvIHJlcztcclxuICAgICAgICAvLyB0aGlzLnByb2plY3Rpb24ueSA9IC0odGhpcy5oZWlnaHQgLyAyKSAvIHJlcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBTdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVycG9sYXRpb25QZXJjZW50YWdlIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LCBkaXZpZGVkXHJcbiAgICAgKiAgIGJ5IHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHdpbGwgYmUgc2ltdWxhdGVkIHRoZSBuZXh0IHRpbWUgdXBkYXRlKClcclxuICAgICAqICAgcnVucy4gVXNlZnVsIGZvciBpbnRlcnBvbGF0aW5nIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc3RhdGUsIGludGVycG9sYXRpb25QZXJjZW50YWdlKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgc3RhcnQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjMDBmZjAwOycpO1xyXG5cclxuICAgICAgICAvLyAgTm8gcG9pbnQgcmVuZGVyaW5nIGlmIG91ciBjb250ZXh0IGhhcyBiZWVuIGJsb3duIHVwIVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRMb3N0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQcmUtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vICBUaGlzIGlzIHRoZSBvbGQgcmVuZGVyIGxvb3AgLSBhZGQgd2hhdCB5b3UgbmVlZCBoZXJlIHRvIHJlcGxhY2UgaXQsXHJcbiAgICAgICAgLy8gIGJ1dCBwbGVhc2UgYWxsb3cgZWFjaCBTdGF0ZSB0byByZW5kZXIgdG8gaXRzIG93biBRdWFkIEZCT1xyXG5cclxuICAgICAgICAvL3ZhciBmYm8gPSBzdGF0ZS5zeXMuZmJvO1xyXG5cclxuICAgICAgICAvL2Ziby5hY3RpdmF0ZSgpO1xyXG5cclxuICAgICAgICAvLyAgY2xlYXIgaXMgbmVlZGVkIGZvciB0aGUgRkJPLCBvdGhlcndpc2UgY29ycnVwdGlvbiAuLi5cclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgLy90aGlzLnNldEJsZW5kTW9kZShDT05TVC5ibGVuZE1vZGVzLk5PUk1BTCk7XHJcblxyXG4gICAgICAgIC8vdGhpcy5iYXRjaC5zdGFydCgpO1xyXG5cclxuICAgICAgICAvLyAgQ291bGQgbW92ZSB0byB0aGUgU3RhdGUgU3lzdGVtcyBvciBNYWluTG9vcFxyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcldlYkdMKHRoaXMsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcclxuXHJcbiAgICAgICAgLy90aGlzLmJhdGNoLnN0b3AoKTtcclxuXHJcbiAgICAgICAgLy8gIENhbGwgc3RhdGUucmVuZGVyIGhlcmUsIHNvIHdlIGNhbiBkbyBzb21lIGV4dHJhIHNoaXp6bGUgb24gdGhlIHRvcFxyXG4gICAgICAgIC8vICBNYXliZSBwYXNzIGluIHRoZSBGQk8gdGV4dHVyZSB0b28/XHJcblxyXG4gICAgICAgIC8vZmJvLnJlbmRlcihudWxsKTtcclxuXHJcbiAgICAgICAgLy8gIFVuYmluZCB0aGUgZmJvIHRleHR1cmUgYW5kIHJlcGxhY2UgaXQgd2l0aCBhbiBlbXB0eSB0ZXh0dXJlLlxyXG4gICAgICAgIC8vICBJZiB3ZSBmb3JnZXQgdGhpcyB3ZSBjb3JydXB0IHRoZSBtYWluIGNvbnRleHQgdGV4dHVyZSFcclxuICAgICAgICAvLyAgb3IgZ2V0IGBSRU5ERVIgV0FSTklORzogdGhlcmUgaXMgbm8gdGV4dHVyZSBib3VuZCB0byB0aGUgdW5pdCAwYCBzcGFtIGluIHRoZSBjb25zb2xlXHJcbiAgICAgICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZSk7XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIGVuZCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICNmZjAwMDA7Jyk7XHJcblxyXG4gICAgICAgIC8vICBBZGQgUG9zdC1yZW5kZXIgaG9va1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUZCTzogZnVuY3Rpb24gKCkge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCIvLyAgQ291bGQgeW91IG1vdmUgdGhlc2UgaW50byBzdWItZm9sZGVycyBwbGVhc2UsIGkuZS4gJ3ZhbycsICdzaGFkZXInIGV0Yz9cclxuXHJcbnZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XHJcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0nKTtcclxudmFyIENyZWF0ZVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVTaGFkZXInKTtcclxudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcclxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYycpO1xyXG52YXIgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL1ZlcnRleEJ1ZmZlcicpO1xyXG52YXIgSW5kZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvSW5kZXhCdWZmZXInKTtcclxudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL1ZlcnRleEFycmF5Jyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIEJsaXR0ZXJCYXRjaCA9IGZ1bmN0aW9uIChnYW1lLCBnbCwgbWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuXHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcblxyXG4gICAgdGhpcy5tYXhQYXJ0aWNsZXMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhBcnJheSA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbn07XHJcblxyXG5CbGl0dGVyQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxpdHRlckJhdGNoO1xyXG5cclxuQmxpdHRlckJhdGNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEluZGV4QnVmZmVyKENPTlNULklOREVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xyXG5cclxuICAgICAgICB2YXIgdmVydFNoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBmcmFnU2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gQ3JlYXRlUHJvZ3JhbShnbCwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcik7XHJcblxyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IENyZWF0ZUJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBudWxsLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG5cclxuICAgICAgICB2YXIgYXR0cmliQXJyYXkgPSBbXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RleF9jb29yZCcsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IFZlcnRleEFycmF5KENyZWF0ZUJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBnbC5TVFJFQU1fRFJBVywgbnVsbCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSksIGF0dHJpYkFycmF5KTtcclxuXHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV92aWV3X21hdHJpeCcpO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRTaGFkZXIgPSB2ZXJ0U2hhZGVyO1xyXG4gICAgICAgIHRoaXMuZnJhZ1NoYWRlciA9IGZyYWdTaGFkZXI7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXkgPSB2ZXJ0ZXhBcnJheTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4QnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLndvcmRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfUEFSVElDTEVTICogQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlBBUlRJQ0xFX0lOREVYX0NPVU5ULCBpbmRleEIgKz0gQ09OU1QuUEFSVElDTEVfVkVSVEVYX0NPVU5UKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMV0gPSBpbmRleEIgKyAxO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAyXSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNF0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA1XSA9IGluZGV4QiArIDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDAsIGluZGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNXb3JkKCkpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHVtaW4sIHZtaW4sIHVtYXgsIHZtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldEJhdGNoKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IGNoZWNrIGlmIHRoZSBidWZmZXJzIGFyZSBmdWxsIGJlZm9yZSBmbHVzaGluZ1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gZ2l2ZSBmcmVlZG9tIG9mIHdoZW4gc2hvdWxkIHRoZSByZW5kZXJlciBmbHVzaC4gdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQgKiBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQpO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcclxuICAgICAgICBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgKz0gQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmUyRDogZnVuY3Rpb24gKHRleHR1cmUyRCwgZm9yY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUZXh0dXJlMkQgIT09IHRleHR1cmUyRCB8fCBmb3JjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlMkQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gdGV4dHVyZTJEO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG5cclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgQmluZFZlcnRleEFycmF5KGdsLCB0aGlzLnZlcnRleEFycmF5KTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSAodGhpcy53aWR0aCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy52aWV3LndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLnZpZXcuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgaWYgKGdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QXJyYXkuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcclxuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxyXG4gICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0ZyYWdtZW50U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhfY29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2b2lkIG1haW4gKCkgeycsXHJcbiAgICAnICAgZ2xfUG9zaXRpb24gPSB1X3ZpZXdfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjAsIDEuMCk7JyxcclxuICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL1ZlcnRleFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vRnJhZ21lbnRTaGFkZXInKTtcclxudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XHJcblxyXG52YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjMilcclxuICAgIFZFUlRFWF9TSVpFOiAxNixcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBQQVJUSUNMRV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBQQVJUSUNMRV9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDQsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9QQVJUSUNMRVM6IDEwMDAwLFxyXG5cclxuICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWZXJ0ZXhTaGFkZXIsXHJcbiAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGcmFnbWVudFNoYWRlclxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKTsnLFxyXG4gICAgJ30nXHJcbl0uam9pbignXFxuJyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL0ZyYWdtZW50U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXknKTtcclxudmFyIENyZWF0ZVByb2dyYW0gPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlUHJvZ3JhbScpO1xyXG52YXIgQ3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlcicpO1xyXG52YXIgQ3JlYXRlQnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlcicpO1xyXG52YXIgQ3JlYXRlQXR0cmliRGVzYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9DcmVhdGVBdHRyaWJEZXNjJyk7XHJcbnZhciBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvVmVydGV4QnVmZmVyJyk7XHJcbnZhciBJbmRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9JbmRleEJ1ZmZlcicpO1xyXG52YXIgVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vVmVydGV4QXJyYXknKTtcclxuXHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgU3ByaXRlQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcblxyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG5cclxuICAgIHRoaXMubWF4U3ByaXRlcyA9IG51bGw7XHJcblxyXG4gICAgdGhpcy52ZXJ0U2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxufTtcclxuXHJcblNwcml0ZUJhdGNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZUJhdGNoO1xyXG5cclxuU3ByaXRlQmF0Y2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKENPTlNULlZFUlRFWF9TSVpFICogQ09OU1QuU1BSSVRFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9TUFJJVEVTKTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xyXG5cclxuICAgICAgICB2YXIgdmVydFNoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBmcmFnU2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gQ3JlYXRlUHJvZ3JhbShnbCwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcik7XHJcblxyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IENyZWF0ZUJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBudWxsLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xyXG5cclxuICAgICAgICB2YXIgYXR0cmliQXJyYXkgPSBbXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RleF9jb29yZCcsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV90cmFuc2xhdGUnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAxNiksXHJcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3NjYWxlJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMjQpLFxyXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9yb3RhdGlvbicsIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDMyKVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBWZXJ0ZXhBcnJheShDcmVhdGVCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RSRUFNX0RSQVcsIG51bGwsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpLCBhdHRyaWJBcnJheSk7XHJcblxyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfdmlld19tYXRyaXgnKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcclxuICAgICAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBpbmRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZlcnRleEFycmF5ID0gdmVydGV4QXJyYXk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICAgICBcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlci53b3JkVmlldztcclxuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX1NQUklURVMgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMF0gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgM10gPSBpbmRleEIgKyAwO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc1dvcmQoKSk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdW1pbiwgdm1pbiwgdW1heCwgdm1heCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRCYXRjaCh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcclxuICAgICAgICAvLyB0aGlzIGlzIHRvIGdpdmUgZnJlZWRvbSBvZiB3aGVuIHNob3VsZCB0aGUgcmVuZGVyZXIgZmx1c2guIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5TUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJvdGF0aW9uO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJvdGF0aW9uO1xyXG4gICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHJhbnNsYXRlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gc2NhbGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJvdGF0aW9uO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVYO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0cmFuc2xhdGVZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBzY2FsZVg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHNjYWxlWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcm90YXRpb247XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZTJEOiBmdW5jdGlvbiAodGV4dHVyZTJELCBmb3JjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmUyRCAhPT0gdGV4dHVyZTJEIHx8IGZvcmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG5cclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUyRCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSB0ZXh0dXJlMkQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XHJcblxyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXM7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLnZpZXcud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMudmlldy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhBcnJheS5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUJhdGNoO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL1Nwcml0ZUJhdGNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhfY29vcmQ7JyxcclxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RyYW5zbGF0ZTsnLFxyXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfc2NhbGU7JyxcclxuICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9yb3RhdGlvbjsnLFxyXG4gICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICcgICBmbG9hdCB0X2NvcyA9IGNvcyhhX3JvdGF0aW9uKTsnLFxyXG4gICAgJyAgIGZsb2F0IHRfc2luID0gc2luKGFfcm90YXRpb24pOycsXHJcbiAgICAnICAgdmVjMiB0X3Bvc2l0aW9uID0gYV9wb3NpdGlvbiAqIGFfc2NhbGU7JyxcclxuICAgICcgICB0X3Bvc2l0aW9uID0gdmVjMih0X3Bvc2l0aW9uLnggKiB0X2NvcyAtIHRfcG9zaXRpb24ueSAqIHRfc2luLCB0X3Bvc2l0aW9uLnggKiB0X3NpbiArIHRfcG9zaXRpb24ueSAqIHRfY29zKTsnLFxyXG4gICAgJyAgIHRfcG9zaXRpb24gKz0gYV90cmFuc2xhdGU7JyxcclxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KHRfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgJyAgIHZfdGV4X2Nvb3JkID0gYV90ZXhfY29vcmQ7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9WZXJ0ZXhTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL0ZyYWdtZW50U2hhZGVyJyk7XHJcbnZhciBWZXJ0ZXhTaGFkZXIgPSByZXF1aXJlKCcuL1ZlcnRleFNoYWRlcicpO1xyXG5cclxudmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8vIFZFUlRFWF9TSVpFID0gKHNpemVvZih2ZWMyKSAqIDQpICsgKHNpemVvZihmbG9hdCkpXHJcbiAgICBWRVJURVhfU0laRTogMzYsXHJcbiAgICBJTkRFWF9TSVpFOiAyLFxyXG4gICAgU1BSSVRFX1ZFUlRFWF9DT1VOVDogNCxcclxuICAgIFNQUklURV9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFNQUklURV9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA5LFxyXG5cclxuICAgIC8vIENhbid0IGJlIGJpZ2dlciBzaW5jZSBpbmRleCBhcmUgMTYtYml0XHJcbiAgICBNQVhfU1BSSVRFUzogMTAwMDAsXHJcblxyXG4gICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZlcnRleFNoYWRlcixcclxuICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZyYWdtZW50U2hhZGVyXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qcyIsInZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vLi4vU2NhbGVNb2RlcycpO1xyXG5cclxudmFyIENyZWF0ZUVtcHR5VGV4dHVyZSA9IGZ1bmN0aW9uIChnbCwgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCB0ZXh0dXJlSW5kZXgpXHJcbntcclxuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgdmFyIGdsU2NhbGVNb2RlID0gKHNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5MSU5FQVIpID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcclxuXHJcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZUluZGV4KTtcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgLy8gIFdlJ2xsIHJlYWQgZnJvbSB0aGlzIHRleHR1cmUsIGJ1dCBpdCB3b24ndCBoYXZlIG1pcG1hcHMsIHNvIHR1cm4gdGhlbSBvZmY6XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xTY2FsZU1vZGUpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsU2NhbGVNb2RlKTtcclxuXHJcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVFbXB0eVRleHR1cmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUVtcHR5VGV4dHVyZS5qcyIsInZhciBDcmVhdGVUZXh0dXJlMkRJbWFnZSA9IGZ1bmN0aW9uIChnbCwgcGl4ZWxzLCBmaWx0ZXIsIG1pcExldmVscylcclxue1xyXG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICBtaXBMZXZlbHMgPSBtaXBMZXZlbHMgfHwgMDtcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXIpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcik7XHJcbiAgICBnbC50ZXhJbWFnZTJEKFxyXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXHJcbiAgICAgICAgbWlwTGV2ZWxzLFxyXG4gICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgZ2wuUkdCQSxcclxuICAgICAgICBnbC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgIHBpeGVsc1xyXG4gICAgKTtcclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVUZXh0dXJlMkRJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobG9jYXRpb24sIHNpemUsIHR5cGUsIG5vcm1hbGl6ZSwgc3RyaWRlLCBvZmZzZXQpXHJcbntcclxuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemU7XHJcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9BdHRyaWJ1dGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEJldHdlZW4gPSByZXF1aXJlKCcuLi8uLi9tYXRoL0JldHdlZW4nKTtcclxudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvR2V0T2JqZWN0VmFsdWUnKTtcclxuXHJcbi8vICBQaGFzZXIuU291bmQuRHluYW1pYy5GWFxyXG5cclxuLy8gIEJhc2VkIG9uIFNvdW5kLmpzIGJ5IEtpdHR5S2F0QXR0YWNrXHJcbi8vICBodHRwczovL2dpdGh1Yi5jb20va2l0dHlrYXRhdHRhY2svc291bmQuanNcclxuXHJcbi8vIGZyZXF1ZW5jeSwgICAgICAvL1RoZSBzb3VuZCdzIGZlcXVlbmN5IHBpdGNoIGluIEhlcnR6XHJcbi8vIGF0dGFjaywgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIGZhZGUgdGhlIHNvdW5kIGluXHJcbi8vIGRlY2F5LCAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIGZhZGUgdGhlIHNvdW5kIG91dFxyXG4vLyB0eXBlLCAgICAgICAgICAgICAgICAvL3dhdmVmb3JtIHR5cGU6IFwic2luZVwiLCBcInRyaWFuZ2xlXCIsIFwic3F1YXJlXCIsIFwic2F3dG9vdGhcIlxyXG4vLyB2b2x1bWUsICAgICAgICAgLy9UaGUgc291bmQncyBtYXhpbXVtIHZvbHVtZVxyXG4vLyBwYW5WYWx1ZSwgICAgICAgICAgICAvL1RoZSBzcGVha2VyIHBhbi4gbGVmdDogLTEsIG1pZGRsZTogMCwgcmlnaHQ6IDFcclxuLy8gd2FpdCwgICAgICAgICAgICAgICAgLy9UaGUgdGltZSwgaW4gc2Vjb25kcywgdG8gd2FpdCBiZWZvcmUgcGxheWluZyB0aGUgc291bmRcclxuLy8gcGl0Y2hCZW5kLCAgICAgLy9UaGUgbnVtYmVyIG9mIEh6IGluIHdoaWNoIHRvIGJlbmQgdGhlIHNvdW5kJ3MgcGl0Y2ggZG93blxyXG4vLyByZXZlcnNlLCAgICAgICAgICAgICAvL0lmIGByZXZlcnNlYCBpcyB0cnVlIHRoZSBwaXRjaCB3aWxsIGJlbmQgdXBcclxuLy8gcmFuZG9tLCAgICAgICAgIC8vQSByYW5nZSwgaW4gSHosIHdpdGhpbiB3aGljaCB0byByYW5kb21pemUgdGhlIHBpdGNoXHJcbi8vIGRpc3NvbmFuY2UsICAgICAgICAgIC8vQSB2YWx1ZSBpbiBIei4gSXQgY3JlYXRlcyAyIGRpc3NvbmFudCBmcmVxdWVuY2llcyBhYm92ZSBhbmQgYmVsb3cgdGhlIHRhcmdldCBwaXRjaFxyXG4vLyBlY2hvLCAgICAgICAgICAgICAgICAvL0FuIGFycmF5OiBbZGVsYXlUaW1lSW5TZWNvbmRzLCBmZWVkYmFja1RpbWVJblNlY29uZHMsIGZpbHRlclZhbHVlSW5Iel1cclxuLy8gcmV2ZXJiLCAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2R1cmF0aW9uSW5TZWNvbmRzLCBkZWNheVJhdGVJblNlY29uZHMsIHJldmVyc2VdXHJcbi8vIHRpbWVvdXQgICAgICAgICAgICAgIC8vQSBudW1iZXIsIGluIHNlY29uZHMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGR1cmF0aW9uIGZvciBzb3VuZCBlZmZlY3RzXHJcblxyXG52YXIgRlggPSBmdW5jdGlvbiAoY3R4LCBjb25maWcpXHJcbntcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xyXG5cclxuICAgIHRoaXMuZnJlcXVlbmN5VmFsdWUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmcmVxdWVuY3knLCAyMDApO1xyXG4gICAgdGhpcy5hdHRhY2sgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhdHRhY2snLCAwKTtcclxuICAgIHRoaXMuZGVjYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdkZWNheScsIDEpO1xyXG4gICAgdGhpcy50eXBlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHlwZScsICdzaW5lJyk7XHJcbiAgICB0aGlzLnZvbHVtZVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndm9sdW1lJywgMSk7XHJcbiAgICB0aGlzLnBhblZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGFuJywgMCk7XHJcbiAgICB0aGlzLndhaXQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd3YWl0JywgMCk7XHJcbiAgICB0aGlzLnBpdGNoQmVuZEFtb3VudCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BpdGNoQmVuZCcsIDApO1xyXG4gICAgdGhpcy5yZXZlcnNlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmV2ZXJzZScsIGZhbHNlKTtcclxuICAgIHRoaXMucmFuZG9tVmFsdWUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyYW5kb20nLCAwKTtcclxuICAgIHRoaXMuZGlzc29uYW5jZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Rpc3NvbmFuY2UnLCAwKTtcclxuICAgIHRoaXMuZWNobyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8nLCBmYWxzZSk7XHJcbiAgICB0aGlzLmVjaG9EZWxheSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZGVsYXknLCAwKTtcclxuICAgIHRoaXMuZWNob0ZlZWRiYWNrID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZWNoby5mZWVkYmFjaycsIDApO1xyXG4gICAgdGhpcy5lY2hvRmlsdGVyID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZWNoby5maWx0ZXInLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmV2ZXJiJywgZmFsc2UpO1xyXG4gICAgdGhpcy5yZXZlcmJEdXJhdGlvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5kdXJhdGlvbicsIDApO1xyXG4gICAgdGhpcy5yZXZlcmJEZWNheSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5kZWNheScsIDApO1xyXG4gICAgdGhpcy5yZXZlcmJSZXZlcnNlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmV2ZXJiLnJldmVyc2UnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnRpbWVvdXQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0aW1lb3V0JywgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMudm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgIHRoaXMucGFuID0gKCFjdHguY3JlYXRlU3RlcmVvUGFubmVyKSA/IGN0eC5jcmVhdGVQYW5uZXIoKSA6IGN0eC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcclxuXHJcbiAgICB0aGlzLnZvbHVtZS5jb25uZWN0KHRoaXMucGFuKTtcclxuICAgIHRoaXMucGFuLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSB2YWx1ZXNcclxuXHJcbiAgICB0aGlzLnZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcclxuXHJcbiAgICBpZiAoIWN0eC5jcmVhdGVTdGVyZW9QYW5uZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYW4uc2V0UG9zaXRpb24odGhpcy5wYW5WYWx1ZSwgMCwgMSAtIE1hdGguYWJzKHRoaXMucGFuVmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhbi5wYW4udmFsdWUgPSB0aGlzLnBhblZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBDcmVhdGUgYW4gb3NjaWxsYXRvciwgZ2FpbiBhbmQgcGFuIG5vZGVzLCBhbmQgY29ubmVjdCB0aGVtIHRvZ2V0aGVyIHRvIHRoZSBkZXN0aW5hdGlvblxyXG5cclxuICAgIHZhciBvc2NpbGxhdG9yID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuXHJcbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QodGhpcy52b2x1bWUpO1xyXG4gICAgb3NjaWxsYXRvci50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuICAgIC8vICBPcHRpb25hbGx5IHJhbmRvbWl6ZSB0aGUgcGl0Y2ggaWYgYHJhbmRvbVZhbHVlYCA+IDAuXHJcbiAgICAvLyAgQSByYW5kb20gcGl0Y2ggaXMgc2VsZWN0ZWQgdGhhdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IGBmcmVxdWVuY3lWYWx1ZWAuXHJcbiAgICAvLyAgVGhlIHJhbmRvbSBwaXRjaCB3aWxsIGJlIGVpdGhlciBhYm92ZSBvciBiZWxvdyB0aGUgdGFyZ2V0IGZyZXF1ZW5jeS5cclxuXHJcbiAgICBpZiAodGhpcy5yYW5kb21WYWx1ZSA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSBCZXR3ZWVuKFxyXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlIC0gdGhpcy5yYW5kb21WYWx1ZSAvIDIsXHJcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5VmFsdWUgKyB0aGlzLnJhbmRvbVZhbHVlIC8gMlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBcHBseSBlZmZlY3RzXHJcblxyXG4gICAgaWYgKHRoaXMuYXR0YWNrID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZhZGVJbih0aGlzLnZvbHVtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5mYWRlT3V0KHRoaXMudm9sdW1lKTtcclxuXHJcbiAgICBpZiAodGhpcy5waXRjaEJlbmRBbW91bnQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGl0Y2hCZW5kKG9zY2lsbGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmVjaG8pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hZGRFY2hvKHRoaXMudm9sdW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZXZlcmIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hZGRSZXZlcmIodGhpcy52b2x1bWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRpc3NvbmFuY2UgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkRGlzc29uYW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGxheShvc2NpbGxhdG9yKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIG9zY2lsbGF0b3Iub25lbmRlZCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ29uZW5kZWQnKTtcclxuICAgICAgICBfdGhpcy5wYW4uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIF90aGlzLnZvbHVtZS5kaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuRlgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRlg7XHJcblxyXG5GWC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgcGxheTogZnVuY3Rpb24gKG9zY2lsbGF0b3IpXHJcbiAgICB7XHJcbiAgICAgICAgb3NjaWxsYXRvci5zdGFydCh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcblxyXG4gICAgICAgIC8vT3NjaWxsYXRvcnMgaGF2ZSB0byBiZSBzdG9wcGVkIG90aGVyd2lzZSB0aGV5IGFjY3VtdWxhdGUgaW4gXHJcbiAgICAgICAgLy9tZW1vcnkgYW5kIHRheCB0aGUgQ1BVLiBUaGV5J2xsIGJlIHN0b3BwZWQgYWZ0ZXIgYSBkZWZhdWx0XHJcbiAgICAgICAgLy90aW1lb3V0IG9mIDIgc2Vjb25kcywgd2hpY2ggc2hvdWxkIGJlIGVub3VnaCBmb3IgbW9zdCBzb3VuZCBcclxuICAgICAgICAvL2VmZmVjdHMuIE92ZXJyaWRlIHRoaXMgaW4gdGhlIGBzb3VuZEVmZmVjdGAgcGFyYW1ldGVycyBpZiB5b3VcclxuICAgICAgICAvL25lZWQgYSBsb25nZXIgc291bmRcclxuXHJcbiAgICAgICAgb3NjaWxsYXRvci5zdG9wKHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgMik7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVJbjogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2b2x1bWUuZ2Fpbi52YWx1ZSA9IDA7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuXHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy52b2x1bWVWYWx1ZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGVPdXQ6IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy52b2x1bWVWYWx1ZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayk7XHJcblxyXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkUmV2ZXJiOiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb252b2x2ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcclxuXHJcbiAgICAgICAgY29udm9sdmVyLmJ1ZmZlciA9IHRoaXMuaW1wdWxzZVJlc3BvbnNlKHRoaXMucmV2ZXJiRHVyYXRpb24sIHRoaXMucmV2ZXJiRGVjYXksIHRoaXMucmV2ZXJiUmV2ZXJzZSwgdGhpcy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgICAgICB2b2x1bWUuY29ubmVjdChjb252b2x2ZXIpO1xyXG5cclxuICAgICAgICBjb252b2x2ZXIuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEVjaG86IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZlZWRiYWNrID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xyXG5cclxuICAgICAgICAvLyAgU2V0IHRoZSBub2RlIHZhbHVlc1xyXG5cclxuICAgICAgICBmZWVkYmFjay5nYWluLnZhbHVlID0gdGhpcy5lY2hvRmVlZGJhY2s7XHJcbiAgICAgICAgZGVsYXkuZGVsYXlUaW1lLnZhbHVlID0gdGhpcy5lY2hvRGVsYXk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG9GaWx0ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWx0ZXIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5lY2hvRmlsdGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgZGVsYXkgZmVlZGJhY2sgbG9vcCAod2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcpXHJcblxyXG4gICAgICAgIGRlbGF5LmNvbm5lY3QoZmVlZGJhY2spO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lY2hvRmlsdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmVlZGJhY2suY29ubmVjdChmaWx0ZXIpO1xyXG4gICAgICAgICAgICBmaWx0ZXIuY29ubmVjdChkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZGVsYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG9zY2lsbGF0b3Igdm9sdW1lIG5vZGVcclxuXHJcbiAgICAgICAgdm9sdW1lLmNvbm5lY3QoZGVsYXkpO1xyXG5cclxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgZGVsYXkgbm9kZSB0byB0aGUgbWFpbiBzb3VuZCBjaGFpbnMgcGFuIG5vZGUsXHJcbiAgICAgICAgLy8gIHNvIHRoYXQgdGhlIGVjaG8gZWZmZWN0IGlzIGRpcmVjdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWFrZXJcclxuXHJcbiAgICAgICAgZGVsYXkuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHBpdGNoQmVuZDogZnVuY3Rpb24gKG9zY2lsbGF0b3IpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyZXF1ZW5jeSA9IG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMucmV2ZXJzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiByZXZlcnNlIGlzIGZhbHNlLCBtYWtlIHRoZSBzb3VuZCBkcm9wIGluIHBpdGNoXHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgLSB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyB0cnVlLCBtYWtlIHRoZSBzb3VuZCByaXNlIGluIHBpdGNoXHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgKyB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZERpc3NvbmFuY2U6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIENyZWF0ZSB0d28gbW9yZSBvc2NpbGxhdG9ycyBhbmQgZ2FpbiBub2Rlc1xyXG5cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgICAgIHZhciBkMSA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICAgICAgdmFyIGQyID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgICAgICB2YXIgZDFWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBkMlZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIHZvbHVtZSB0byB0aGUgYHZvbHVtZVZhbHVlYFxyXG4gICAgICAgIGQxVm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xyXG4gICAgICAgIGQyVm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xyXG5cclxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgb3NjaWxsYXRvcnMgdG8gdGhlIGdhaW4gYW5kIGRlc3RpbmF0aW9uIG5vZGVzXHJcbiAgICAgICAgZDEuY29ubmVjdChkMVZvbHVtZSk7XHJcbiAgICAgICAgZDIuY29ubmVjdChkMlZvbHVtZSk7XHJcblxyXG4gICAgICAgIGQxVm9sdW1lLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICBkMlZvbHVtZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIHdhdmVmb3JtIHRvIFwic2F3dG9vdGhcIiBmb3IgYSBoYXJzaCBlZmZlY3RcclxuICAgICAgICBkMS50eXBlID0gJ3Nhd3Rvb3RoJztcclxuICAgICAgICBkMi50eXBlID0gJ3Nhd3Rvb3RoJztcclxuXHJcbiAgICAgICAgLy8gIE1ha2UgdGhlIHR3byBvc2NpbGxhdG9ycyBwbGF5IGF0IGZyZXF1ZW5jaWVzIGFib3ZlIGFuZCBiZWxvdyB0aGUgbWFpbiBzb3VuZCdzIGZyZXF1ZW5jeS5cclxuICAgICAgICAvLyAgVXNlIHdoYXRldmVyIHZhbHVlIHdhcyBzdXBwbGllZCBieSB0aGUgYGRpc3NvbmFuY2VgIGFyZ3VtZW50XHJcbiAgICAgICAgZDEuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSArIHRoaXMuZGlzc29uYW5jZTtcclxuICAgICAgICBkMi5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlIC0gdGhpcy5kaXNzb25hbmNlO1xyXG5cclxuICAgICAgICAvLyAgRmFkZSBpbiAvIG91dCwgcGl0Y2ggYmVuZCBhbmQgcGxheSB0aGUgb3NjaWxsYXRvcnMgdG8gbWF0Y2ggdGhlIG1haW4gc291bmRcclxuICAgICAgICBpZiAodGhpcy5hdHRhY2sgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVJbihkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kZWNheSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDFWb2x1bWUpO1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQxKTtcclxuICAgICAgICAgICAgdGhpcy5waXRjaEJlbmQoZDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWNobylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5yZXZlcmIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmV2ZXJiKGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGxheShkMSk7XHJcbiAgICAgICAgdGhpcy5wbGF5KGQyKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW1wdWxzZVJlc3BvbnNlOiBmdW5jdGlvbiAoZHVyYXRpb24sIGRlY2F5LCByZXZlcnNlKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgKiBkdXJhdGlvbjtcclxuXHJcbiAgICAgICAgLy8gIENyZWF0ZSBhbiBhdWRpbyBidWZmZXIgKGFuIGVtcHR5IHNvdW5kIGNvbnRhaW5lcikgdG8gc3RvcmUgdGhlIHJldmVyYiBlZmZlY3QuXHJcbiAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMiwgbGVuZ3RoLCB0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcclxuXHJcbiAgICAgICAgLy8gIFVzZSBgZ2V0Q2hhbm5lbERhdGFgIHRvIGluaXRpYWxpemUgZW1wdHkgYXJyYXlzIHRvIHN0b3JlIHNvdW5kIGRhdGEgZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscy5cclxuICAgICAgICB2YXIgbGVmdCA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgxKTtcclxuXHJcbiAgICAgICAgLy8gIExvb3AgdGhyb3VnaCBlYWNoIHNhbXBsZS1mcmFtZSBhbmQgZmlsbCB0aGUgY2hhbm5lbCBkYXRhIHdpdGggcmFuZG9tIG5vaXNlLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQXBwbHkgdGhlIHJldmVyc2UgZWZmZWN0LCBpZiBgcmV2ZXJzZWAgaXMgYHRydWVgLlxyXG4gICAgICAgICAgICB2YXIgbiA9IChyZXZlcnNlKSA/IGxlbmd0aCAtIGkgOiBpO1xyXG5cclxuICAgICAgICAgICAgLy8gIEZpbGwgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzIHdpdGggcmFuZG9tIHdoaXRlIG5vaXNlIHdoaWNoIGRlY2F5cyBleHBvbmVudGlhbGx5LlxyXG4gICAgICAgICAgICBsZWZ0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xyXG4gICAgICAgICAgICByaWdodFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZXR1cm4gdGhlIGBpbXB1bHNlYC5cclxuICAgICAgICByZXR1cm4gaW1wdWxzZTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zb3VuZC9keW5hbWljL0ZYLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc291bmQvZHluYW1pYy9GWC5qcyIsIi8vICBQaGFzZXIuU291bmQuRHluYW1pY1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRlg6IHJlcXVpcmUoJy4vRlgnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvZHluYW1pYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL1NldHRpbmdzJyk7XHJcbnZhciBTeXN0ZW1zID0gcmVxdWlyZSgnLi9TeXN0ZW1zJyk7XHJcblxyXG4vKipcclxuKiBBIEJhc2UgU3RhdGUgQ2xhc3MuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlN0YXRlXHJcbiogQGNvbnN0cnVjdG9yXHJcbiovXHJcbnZhciBTdGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIC8vICBUaGUgcHJvcGVydGllcyBhIFN0YXRlICptdXN0KiBoYXZlLCB0aGF0IGNhbm5vdCBiZSBjaGFuZ2VkIHdpdGhvdXQgYnJlYWtpbmcgaXQ6XHJcblxyXG4gICAgdGhpcy5nYW1lID0gbnVsbDtcclxuXHJcbiAgICAvLyAgTWF5YmUganVzdCBhbiBvYmplY3Q/IERvZXNuJ3QgaGF2ZSB0byBpbnN0YW50aWF0ZSBJIGRvbid0IHRoaW5rIC4uLlxyXG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgIHRoaXMuc3lzID0gbmV3IFN5c3RlbXModGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAvLyAgUmVmZXJlbmNlIHRvIHN5cy5jaGlsZHJlbiwgc2V0IGR1cmluZyBzeXMuaW5pdCBvbmx5XHJcbiAgICB0aGlzLmNoaWxkcmVuO1xyXG59O1xyXG5cclxuU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGU7XHJcblxyXG5TdGF0ZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xyXG4gICAgcHJlVXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FuIGJlIG92ZXJyaWRkZW4gYnkgeW91ciBvd24gU3RhdGVzXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcclxuICAgIHBvc3RVcGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9TdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N0YXRlLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4vU3RhdGUnKTtcclxudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9TZXR0aW5ncycpO1xyXG52YXIgU3lzdGVtcyA9IHJlcXVpcmUoJy4vU3lzdGVtcycpO1xyXG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9HZXRPYmplY3RWYWx1ZScpO1xyXG4vLyB2YXIgTG9hZGVyRXZlbnQgPSByZXF1aXJlKCcuLi9sb2FkZXIvZXZlbnRzLycpO1xyXG5cclxuLyoqXHJcbiogVGhlIFN0YXRlIE1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcsIHNldHRpbmcgdXAgYW5kIHN3aXRjaGluZyBnYW1lIHN0YXRlcy5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuU3RhdGVNYW5hZ2VyXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgU3RhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKGdhbWUsIHN0YXRlQ29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgIC8vICBFdmVyeXRoaW5nIGtlcHQgaW4gaGVyZVxyXG4gICAgdGhpcy5rZXlzID0ge307XHJcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xyXG5cclxuICAgIC8vICBPbmx5IGFjdGl2ZSBzdGF0ZXMgYXJlIGtlcHQgaW4gaGVyZVxyXG4gICAgdGhpcy5hY3RpdmUgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9wZW5kaW5nID0gW107XHJcblxyXG4gICAgaWYgKHN0YXRlQ29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlQ29uZmlnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVDb25maWcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUaGUgaSA9PT0gMCBwYXJ0IGp1c3Qgc3RhcnRzIHRoZSBmaXJzdCBTdGF0ZSBnaXZlblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVDb25maWdbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiAoaSA9PT0gMClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogMCxcclxuICAgICAgICAgICAgICAgIGtleTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblN0YXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZU1hbmFnZXI7XHJcblxyXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cclxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlN0YXRlTWFuYWdlciNib290XHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyB0aGlzLmdhbWUub25QYXVzZS5hZGQodGhpcy5wYXVzZSwgdGhpcyk7XHJcbiAgICAgICAgLy8gdGhpcy5nYW1lLm9uUmVzdW1lLmFkZCh0aGlzLnJlc3VtZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX3BlbmRpbmdbaV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZChlbnRyeS5rZXksIGVudHJ5LnN0YXRlLCBlbnRyeS5hdXRvU3RhcnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENsZWFyIHRoZSBwZW5kaW5nIGxpc3RcclxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gW107XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEtleTogZnVuY3Rpb24gKGtleSwgc3RhdGVDb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFrZXkpIHsga2V5ID0gJ2RlZmF1bHQnOyB9XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZUNvbmZpZyBpbnN0YW5jZW9mIFN0YXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5ID0gc3RhdGVDb25maWcuc2V0dGluZ3Mua2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhdGVDb25maWcgPT09ICdvYmplY3QnICYmIHN0YXRlQ29uZmlnLmhhc093blByb3BlcnR5KCdrZXknKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleSA9IHN0YXRlQ29uZmlnLmtleTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBCeSB0aGlzIHBvaW50IGl0J3MgZWl0aGVyICdkZWZhdWx0JyBvciBleHRyYWN0ZWQgZnJvbSB0aGUgU3RhdGVcclxuXHJcbiAgICAgICAgaWYgKHRoaXMua2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGEgU3RhdGUgd2l0aCBkdXBsaWNhdGUga2V5OiAnICsga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBZGRzIGEgbmV3IFN0YXRlIGludG8gdGhlIFN0YXRlTWFuYWdlci4gWW91IG11c3QgZ2l2ZSBlYWNoIFN0YXRlIGEgdW5pcXVlIGtleSBieSB3aGljaCB5b3UnbGwgaWRlbnRpZnkgaXQuXHJcbiAgICAqIFRoZSBTdGF0ZSBjYW4gYmUgZWl0aGVyIGEgUGhhc2VyLlN0YXRlIG9iamVjdCAob3IgYW4gb2JqZWN0IHRoYXQgZXh0ZW5kcyBpdCksIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3Qgb3IgYSBmdW5jdGlvbi5cclxuICAgICogSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiBhIG5ldyBzdGF0ZSBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkIGJ5IGNhbGxpbmcgaXQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlN0YXRlTWFuYWdlciNhZGRcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEEgdW5pcXVlIGtleSB5b3UgdXNlIHRvIHJlZmVyZW5jZSB0aGlzIHN0YXRlLCBpLmUuIFwiTWFpbk1lbnVcIiwgXCJMZXZlbDFcIi5cclxuICAgICogQHBhcmFtIHtQaGFzZXIuU3RhdGV8b2JqZWN0fGZ1bmN0aW9ufSBzdGF0ZSAgLSBUaGUgc3RhdGUgeW91IHdhbnQgdG8gc3dpdGNoIHRvLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvU3RhcnQ9ZmFsc2VdICAtIElmIHRydWUgdGhlIFN0YXRlIHdpbGwgYmUgc3RhcnRlZCBpbW1lZGlhdGVseSBhZnRlciBhZGRpbmcgaXQuXHJcbiAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZywgYXV0b1N0YXJ0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhdXRvU3RhcnQgPT09IHVuZGVmaW5lZCkgeyBhdXRvU3RhcnQgPSBmYWxzZTsgfVxyXG5cclxuICAgICAgICAvLyAgaWYgbm90IGJvb3RlZCwgdGhlbiBwdXQgc3RhdGUgaW50byBhIGhvbGRpbmcgcGF0dGVyblxyXG4gICAgICAgIGlmICghdGhpcy5nYW1lLmlzQm9vdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLl9wZW5kaW5nLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiBhdXRvU3RhcnRcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVNYW5hZ2VyIG5vdCB5ZXQgYm9vdGVkLCBhZGRpbmcgdG8gbGlzdCcsIHRoaXMuX3BlbmRpbmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSwgc3RhdGVDb25maWcpO1xyXG5cclxuICAgICAgICB2YXIgbmV3U3RhdGU7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZUNvbmZpZyBpbnN0YW5jZW9mIFN0YXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlTWFuYWdlci5hZGQgZnJvbSBpbnN0YW5jZScsIGtleSk7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21JbnN0YW5jZShrZXksIHN0YXRlQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXRlQ29uZmlnID09PSAnb2JqZWN0JylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZU1hbmFnZXIuYWRkIGZyb20gb2JqZWN0Jywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlQ29uZmlnLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21PYmplY3Qoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZU1hbmFnZXIuYWRkIGZyb20gZnVuY3Rpb24nLCBrZXkpO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUZ1bmN0aW9uKGtleSwgc3RhdGVDb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5rZXlzW2tleV0gPSBuZXdTdGF0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChuZXdTdGF0ZSk7XHJcblxyXG4gICAgICAgIGlmIChhdXRvU3RhcnQgfHwgbmV3U3RhdGUuc2V0dGluZ3MuYWN0aXZlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZS5pc0Jvb3RlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVN0YXRlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoa2V5LCBuZXdTdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncy5rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgIG5ld1N0YXRlLnN5cy5pbml0KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdhbWUuY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGF0ZUZyYW1lQnVmZmVyKG5ld1N0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU3RhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgU3RhdGUoc3RhdGVDb25maWcpO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5nYW1lLmNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVGcmFtZUJ1ZmZlcihuZXdTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cENhbGxiYWNrcyhuZXdTdGF0ZSwgc3RhdGVDb25maWcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24gKGtleSwgc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IHN0YXRlKCk7XHJcblxyXG4gICAgICAgIGlmIChuZXdTdGF0ZSBpbnN0YW5jZW9mIFN0YXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RhdGVGcm9tSW5zdGFuY2Uoa2V5LCBuZXdTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlLmdhbWUgPSB0aGlzLmdhbWU7XHJcblxyXG4gICAgICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhuZXdTdGF0ZSwga2V5KTtcclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzID0gbmV3IFN5c3RlbXMobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWUuY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRnJhbWVCdWZmZXIobmV3U3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgRGVmYXVsdCByZXF1aXJlZCBmdW5jdGlvbnNcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBDYWxsYmFja3MobmV3U3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0dXBDYWxsYmFja3M6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgc3RhdGVDb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHN0YXRlQ29uZmlnID09PSB1bmRlZmluZWQpIHsgc3RhdGVDb25maWcgPSBuZXdTdGF0ZTsgfVxyXG5cclxuICAgICAgICAvLyAgRXh0cmFjdCBjYWxsYmFja3Mgb3Igc2V0IE5PT1BcclxuXHJcbiAgICAgICAgbmV3U3RhdGUuaW5pdCA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnaW5pdCcsIE5PT1ApO1xyXG4gICAgICAgIG5ld1N0YXRlLnByZWxvYWQgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3ByZWxvYWQnLCBOT09QKTtcclxuICAgICAgICBuZXdTdGF0ZS5jcmVhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ2NyZWF0ZScsIE5PT1ApO1xyXG4gICAgICAgIG5ld1N0YXRlLnNodXRkb3duID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdzaHV0ZG93bicsIE5PT1ApO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5wcmVVcGRhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3ByZVVwZGF0ZScsIE5PT1ApO1xyXG4gICAgICAgIG5ld1N0YXRlLnVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAndXBkYXRlJywgTk9PUCk7XHJcbiAgICAgICAgbmV3U3RhdGUucG9zdFVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncG9zdFVwZGF0ZScsIE5PT1ApO1xyXG4gICAgICAgIG5ld1N0YXRlLnJlbmRlciA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncmVuZGVyJywgTk9PUCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU3RhdGVGcmFtZUJ1ZmZlcjogZnVuY3Rpb24gKG5ld1N0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gbmV3U3RhdGUuc2V0dGluZ3MueDtcclxuICAgICAgICB2YXIgeSA9IG5ld1N0YXRlLnNldHRpbmdzLnk7XHJcblxyXG4gICAgICAgIGlmIChuZXdTdGF0ZS5zZXR0aW5ncy53aWR0aCA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncy53aWR0aCA9IHRoaXMuZ2FtZS5jb25maWcud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3U3RhdGUuc2V0dGluZ3MuaGVpZ2h0ID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlLnNldHRpbmdzLmhlaWdodCA9IHRoaXMuZ2FtZS5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gbmV3U3RhdGUuc2V0dGluZ3Mud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IG5ld1N0YXRlLnNldHRpbmdzLmhlaWdodDtcclxuXHJcbiAgICAgICAgbmV3U3RhdGUuc3lzLmZibyA9IHRoaXMuZ2FtZS5yZW5kZXJlci5jcmVhdGVGQk8obmV3U3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2tleV07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFN0YXRlSW5kZXg6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXMuaW5kZXhPZihzdGF0ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEFjdGl2ZVN0YXRlSW5kZXg6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBzdGF0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlW2ldLmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChzdGF0ZSAmJiBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUuaW5kZXhPZihzdGF0ZSkgIT09IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIGlmIG5vdCBib290ZWQsIHRoZW4gcHV0IHN0YXRlIGludG8gYSBob2xkaW5nIHBhdHRlcm5cclxuICAgICAgICBpZiAoIXRoaXMuZ2FtZS5pc0Jvb3RlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZU1hbmFnZXIgbm90IHlldCBib290ZWQsIHNldHRpbmcgYXV0b1N0YXJ0IG9uIHBlbmRpbmcgbGlzdCcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9wZW5kaW5nW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5hdXRvU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBbHJlYWR5IHN0YXJ0ZWQ/IE5vdGhpbmcgbW9yZSB0byBkbyBoZXJlIC4uLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShrZXkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldHRpbmdzLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyAgKyBhcmd1bWVudHNcclxuICAgICAgICAgICAgaWYgKHN0YXRlLmluaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmluaXQuY2FsbChzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5wcmVsb2FkICYmIHN0YXRlLnN5cy5sb2FkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubG9hZC5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLnByZWxvYWQuY2FsbChzdGF0ZSwgdGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgSXMgdGhlIGxvYWRlciBlbXB0eT9cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zeXMubG9hZC5saXN0LnNpemUgPT09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENyZWF0ZShzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIFN0YXJ0IHRoZSBsb2FkZXIgZ29pbmcgYXMgd2UgaGF2ZSBzb21ldGhpbmcgaW4gdGhlIHF1ZXVlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5sb2FkLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLmxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3lzLmxvYWQuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBObyBwcmVsb2FkPyBUaGVuIHRoZXJlIHdhcyBub3RoaW5nIHRvIGxvYWQgZWl0aGVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q3JlYXRlKHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGV2ZW50LmxvYWRlci5zdGF0ZTtcclxuXHJcbiAgICAgICAgLy8gIE1ha2Ugc3VyZSB0byBkbyBsb2FkLXVwZGF0ZSBvbmUgbGFzdCB0aW1lIGJlZm9yZSBzdGF0ZSBpcyBzZXQgdG8gX2NyZWF0ZWRcclxuXHJcbiAgICAgICAgLy8gIFN0b3AgZG9pbmcgdGhpcyAuLi5cclxuICAgICAgICBpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoJ2xvYWRVcGRhdGUnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlLmxvYWRVcGRhdGUuY2FsbChzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0Q3JlYXRlKHN0YXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDcmVhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhdGUuY3JlYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RhdGUuY3JlYXRlLmNhbGwoc3RhdGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEluc2VydCBhdCB0aGUgY29ycmVjdCBpbmRleCwgb3IgaXQganVzdCBhbGwgZ29lcyB3cm9uZyA6KVxyXG5cclxuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0U3RhdGVJbmRleChzdGF0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnB1c2goeyBpbmRleDogaSwgc3RhdGU6IHN0YXRlIH0pO1xyXG5cclxuICAgICAgICAvLyAgU29ydCB0aGUgJ2FjdGl2ZScgYXJyYXkgYmFzZWQgb24gdGhlIGluZGV4IHByb3BlcnR5XHJcbiAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRTdGF0ZXMuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHN0YXRlLnN5cy51cGRhdGVzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICBzdGF0ZS5zeXMubWFpbmxvb3Auc3RhcnQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGF1c2U6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRBY3RpdmVTdGF0ZUluZGV4KGtleSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRTdGF0ZXMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0U3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVBLCBzdGF0ZUIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFNvcnQgZGVzY2VuZGluZ1xyXG4gICAgICAgIGlmIChzdGF0ZUEuaW5kZXggPCBzdGF0ZUIuaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXRlQS5pbmRleCA+IHN0YXRlQi5pbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTZWUgaWYgd2UgY2FuIHJlZHVjZSB0aGlzIGRvd24gdG8ganVzdCB1cGRhdGUgYW5kIHJlbmRlclxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lc3RhbXApXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuYWN0aXZlW2ldLnN0YXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXRlLnN5cy5tYWlubG9vcC5ydW5uaW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubWFpbmxvb3Auc3RlcCh0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKlxyXG4gICAgcHJlVXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmFjdGl2ZVtpXS5zdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdLnByZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5wcmVVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XHJcblxyXG4gICAgICAgICAgICAvLyAgSW52b2tlIFN0YXRlIE1haW4gTG9vcCBoZXJlIC0gdXBkYXRpbmcgYWxsIG9mIGl0cyBzeXN0ZW1zICh0d2VlbnMsIHBoeXNpY3MsIGV0YylcclxuXHJcbiAgICAgICAgICAgIC8vICBUaGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaWYgdGhlIFN0YXRlIGlzIHN0aWxsIGxvYWRpbmdcclxuICAgICAgICAgICAgLy8gIEhhdmUgYSBTdGF0ZS5TVEFUVVMgY29uc3QgaW4gdGhlIFNldHRpbmdzLCBkaWN0YXRpbmcgd2hhdCBpcyBnb2luZyBvblxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3RbY107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhdGUudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwb3N0VXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmFjdGl2ZVtpXS5zdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdLnBvc3RVcGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhdGUucG9zdFVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmFjdGl2ZVtpXS5zdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIC8vICBDYW4gcHV0IGFsbCBraW5kcyBvZiBvdGhlciBjaGVja3MgaW4gaGVyZSwgbGlrZSBNYWluTG9vcCwgRlBTLCBldGMuXHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuc2V0dGluZ3MudmlzaWJsZSB8fCBzdGF0ZS5zeXMuY29sb3IuYWxwaGEgPT09IDAgfHwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5nYW1lLnJlbmRlcmVyLnJlbmRlcihzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICovXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N0YXRlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N0YXRlTWFuYWdlci5qcyIsIlxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBQRU5ESU5HOiAwLFxyXG4gICAgSU5TVEFMTEVEOiAxLFxyXG5cclxuICAgIEJPT1Q6IDAsXHJcbiAgICBJTklUOiAxLFxyXG4gICAgUFJFTE9BRDogMixcclxuICAgIENSRUFURTogMyxcclxuICAgIFVQREFURTogNCxcclxuICAgIFJFTkRFUjogNSxcclxuICAgIFNIVVRET1dOOiA2XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxuLyoqXHJcbiogVGhlIEdhbWVPYmplY3QgRmFjdG9yeSBpcyBhIHF1aWNrIHdheSB0byBjcmVhdGUgbWFueSBjb21tb24gZ2FtZSBvYmplY3RzLiBUaGUgRmFjdG9yeSBpcyBvd25lZCBieSB0aGUgU3RhdGUuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxuXHJcbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRoYXQgb3ducyB0aGlzIEZhY3RvcnlcclxuICAgICogQHByb3RlY3RlZFxyXG4gICAgKi9cclxuICAgIHN0YXRlOiBudWxsXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5pdCAoc3RhdGUpXHJcbntcclxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBHYW1lT2JqZWN0RmFjdG9yeSBpbnN0YW5jZSBmb3IgU3RhdGUnKTtcclxuXHJcbiAgICBHYW1lT2JqZWN0RmFjdG9yeS5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgIC8vICAgTG9hZCB0aGUgZmFjdG9yaWVzIGludG8gdGhpcyBPYmplY3RcclxuXHJcbiAgICByZXR1cm4gRmFjdG9yeUNvbnRhaW5lci5sb2FkKEdhbWVPYmplY3RGYWN0b3J5LCB0cnVlKTtcclxuXHJcbiAgICAvLyByZXR1cm4gR2FtZU9iamVjdEZhY3Rvcnk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvY29uc3QnKTtcclxudmFyIEJhc2VMb2FkZXIgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvQmFzZUxvYWRlcicpO1xyXG52YXIgTnVtYmVyQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheScpO1xyXG5cclxudmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlJyk7XHJcbnZhciBKU09ORmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUnKTtcclxudmFyIFhNTEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUnKTtcclxudmFyIEJpbmFyeUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUnKTtcclxudmFyIEdMU0xGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZScpO1xyXG52YXIgVGV4dEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlJyk7XHJcbnZhciBBdGxhc0pTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlJyk7XHJcblxyXG52YXIgTG9hZGVyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICBCYXNlTG9hZGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBGYWN0b3J5XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5fbXVsdGlsaXN0ID0ge307XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTG9hZGVyLnByb3RvdHlwZSk7XHJcbkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXI7XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgSlNPTkZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLnhtbCA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IFhNTEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEJpbmFyeUZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBUZXh0RmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuZ2xzbCA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEdMU0xGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5hdGxhcyA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkwsIGF0bGFzVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXHJcbntcclxuICAgIC8vICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiAndGV4dHVyZScgYW5kICdkYXRhJ1xyXG4gICAgdmFyIGZpbGVzID0gbmV3IEF0bGFzSlNPTkZpbGUoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy50ZXh0dXJlKTtcclxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy5kYXRhKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUubXVsdGlhdGxhcyA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkxzLCBhdGxhc1VSTHMsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHR5cGVvZiB0ZXh0dXJlVVJMcyA9PT0gJ251bWJlcicpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gdGV4dHVyZVVSTHM7XHJcblxyXG4gICAgICAgIHRleHR1cmVVUkxzID0gTnVtYmVyQXJyYXkoMCwgdG90YWwsIGtleSArICctJywgJy5wbmcnKTtcclxuICAgICAgICBhdGxhc1VSTHMgPSBOdW1iZXJBcnJheSgwLCB0b3RhbCwga2V5ICsgJy0nLCAnLmpzb24nKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dHVyZVVSTHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGV4dHVyZVVSTHMgPSBbIHRleHR1cmVVUkxzIF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXRsYXNVUkxzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0bGFzVVJMcyA9IFsgYXRsYXNVUkxzIF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaWxlO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIG11bHRpS2V5O1xyXG5cclxuICAgIHRoaXMuX211bHRpbGlzdFtrZXldID0gW107XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRleHR1cmVVUkxzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG11bHRpS2V5ID0gJ19NQV9JTUdfJyArIGtleSArICdfJyArIGkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgZmlsZSA9IG5ldyBJbWFnZUZpbGUobXVsdGlLZXksIHRleHR1cmVVUkxzW2ldLCB0aGlzLnBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkRmlsZShmaWxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbXVsdGlsaXN0W2tleV0ucHVzaChtdWx0aUtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGF0bGFzVVJMcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBtdWx0aUtleSA9ICdfTUFfSlNPTl8nICsga2V5ICsgJ18nICsgaS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBmaWxlID0gbmV3IEpTT05GaWxlKG11bHRpS2V5LCBhdGxhc1VSTHNbaV0sIHRoaXMucGF0aCwgYXRsYXNYaHJTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkRmlsZShmaWxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbXVsdGlsaXN0W2tleV0ucHVzaChtdWx0aUtleSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyAgVGhlIExvYWRlciBoYXMgZmluaXNoZWRcclxuTG9hZGVyLnByb3RvdHlwZS5wcm9jZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICBpZiAodGhpcy5zdG9yYWdlLnNpemUgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUaGUgZ2xvYmFsIFRleHR1cmUgTWFuYWdlclxyXG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5zdGF0ZS5zeXMudGV4dHVyZXM7XHJcblxyXG4gICAgLy8gIFByb2Nlc3MgbXVsdGlhdGxhcyBncm91cHMgZmlyc3RcclxuXHJcbiAgICB2YXIgZmlsZTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fbXVsdGlsaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5fbXVsdGlsaXN0W2tleV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdrZXknLCBrZXlzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT09ICdqc29uJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRG8gd2UgaGF2ZSBldmVyeXRoaW5nIG5lZWRlZD9cclxuICAgICAgICBpZiAoaW1hZ2VzLmxlbmd0aCArIGRhdGEubGVuZ3RoID09PSBrZXlzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBZdXAsIGFkZCB0aGVtIHRvIHRoZSBUZXh0dXJlIE1hbmFnZXJcclxuXHJcbiAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXS5mcmFtZXMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05IYXNoKGtleSwgaW1hZ2VzLCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGV4dHVyZXMuYWRkSW1hZ2UoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGUudHlwZSA9PT0gJ2F0bGFzanNvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZmlsZUEgPSBmaWxlLmZpbGVBO1xyXG4gICAgICAgICAgICB2YXIgZmlsZUIgPSBmaWxlLmZpbGVCO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpbGVBLnR5cGUgPT09ICdpbWFnZScpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEF0bGFzKGZpbGVBLmtleSwgZmlsZUEuZGF0YSwgZmlsZUIuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhcyhmaWxlQi5rZXksIGZpbGVCLmRhdGEsIGZpbGVBLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGUudHlwZSA9PT0gJ2pzb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5kaXIoZmlsZS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL3N5c3RlbXMvTG9hZGVyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLy8gTXkgdGhhbmtzIHRvIElzYWFjIFN1a2luIGZvciBjcmVhdGluZyBNYWluTG9vcC5qcywgb24gd2hpY2ggbG90cyBvZiB0aGlzIGlzIGJhc2VkLlxyXG5cclxudmFyIE1haW5Mb29wID0gZnVuY3Rpb24gKHN0YXRlLCBmcmFtZXJhdGUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5TdGF0ZX0gc3RhdGVcclxuICAgICovXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgR2FtZS5cclxuICAgICovXHJcbiAgICB0aGlzLmdhbWUgPSBzdGF0ZS5nYW1lO1xyXG5cclxuICAgIC8vIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0byBzaW11bGF0ZSBlYWNoIHRpbWUgdXBkYXRlKCkgcnVucy5cclxuICAgIHRoaXMudGltZXN0ZXAgPSAxMDAwIC8gZnJhbWVyYXRlO1xyXG5cclxuICAgIHRoaXMucGh5c2ljc1N0ZXAgPSAxIC8gZnJhbWVyYXRlO1xyXG5cclxuICAgIC8vIFRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiBpbi1hcHAgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQuXHJcbiAgICAvLyBTZWUgdGhlIGNvbW1lbnRzIGluc2lkZSBhbmltYXRlKCkgZm9yIGRldGFpbHMuXHJcbiAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xyXG5cclxuICAgIC8vIFRoZSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBsYXN0IHRpbWUgdGhlIG1haW4gbG9vcCB3YXMgcnVuLlxyXG4gICAgLy8gVXNlZCB0byBjb21wdXRlIHRoZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBmcmFtZXMuXHJcbiAgICB0aGlzLmxhc3RGcmFtZVRpbWVNcyA9IDA7XHJcblxyXG4gICAgLy8gQW4gZXhwb25lbnRpYWwgbW92aW5nIGF2ZXJhZ2Ugb2YgdGhlIGZyYW1lcyBwZXIgc2Vjb25kLlxyXG4gICAgdGhpcy5mcHMgPSA2MDtcclxuXHJcbiAgICAvLyBUaGUgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMpIG9mIHRoZSBsYXN0IHRpbWUgdGhlIGBmcHNgIG1vdmluZ1xyXG4gICAgLy8gYXZlcmFnZSB3YXMgdXBkYXRlZC5cclxuICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XHJcblxyXG4gICAgLy8gVGhlIG51bWJlciBvZiBmcmFtZXMgZGVsaXZlcmVkIGluIHRoZSBjdXJyZW50IHNlY29uZC5cclxuICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XHJcblxyXG4gICAgLy8gVGhlIG51bWJlciBvZiB0aW1lcyB1cGRhdGUoKSBpcyBjYWxsZWQgaW4gYSBnaXZlbiBmcmFtZS4gVGhpcyBpcyBvbmx5XHJcbiAgICAvLyByZWxldmFudCBpbnNpZGUgb2YgYW5pbWF0ZSgpLCBidXQgYSByZWZlcmVuY2UgaXMgaGVsZCBleHRlcm5hbGx5IHNvIHRoYXRcclxuICAgIC8vIHRoaXMgdmFyaWFibGUgaXMgbm90IG1hcmtlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIGV2ZXJ5IHRpbWUgdGhlIG1haW5cclxuICAgIC8vIGxvb3AgcnVucy5cclxuICAgIHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xyXG5cclxuICAgIC8vIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IG11c3QgcGFzcyBzaW5jZSB0aGUgbGFzdFxyXG4gICAgLy8gZnJhbWUgd2FzIGV4ZWN1dGVkIGJlZm9yZSBhbm90aGVyIGZyYW1lIGNhbiBiZSBleGVjdXRlZC4gVGhlXHJcbiAgICAvLyBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIGNhcHMgdGhlIEZQUyAodGhlIGRlZmF1bHQgb2YgemVybyBtZWFucyB0aGVyZSBpc1xyXG4gICAgLy8gbm8gY2FwKS5cclxuICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDA7XHJcblxyXG4gICAgLy8gV2hldGhlciB0aGUgbWFpbiBsb29wIGlzIHJ1bm5pbmcuXHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBgdHJ1ZWAgaWYgYE1haW5Mb29wLnN0YXJ0KClgIGhhcyBiZWVuIGNhbGxlZCBhbmQgdGhlIG1vc3QgcmVjZW50IHRpbWUgaXRcclxuICAgIC8vIHdhcyBjYWxsZWQgaGFzIG5vdCBiZWVuIGZvbGxvd2VkIGJ5IGEgY2FsbCB0byBgTWFpbkxvb3Auc3RvcCgpYC4gVGhpcyBpc1xyXG4gICAgLy8gZGlmZmVyZW50IHRoYW4gYHJ1bm5pbmdgIGJlY2F1c2UgdGhlcmUgaXMgYSBkZWxheSBvZiBhIGZldyBtaWxsaXNlY29uZHNcclxuICAgIC8vIGFmdGVyIGBNYWluTG9vcC5zdGFydCgpYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBhcHBsaWNhdGlvbiBpcyBjb25zaWRlcmVkXHJcbiAgICAvLyBcInJ1bm5pbmcuXCIgVGhpcyBkZWxheSBpcyBkdWUgdG8gd2FpdGluZyBmb3IgdGhlIG5leHQgZnJhbWUuXHJcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRoZSBzaW11bGF0aW9uIGhhcyBmYWxsZW4gdG9vIGZhciBiZWhpbmQgcmVhbCB0aW1lLlxyXG4gICAgLy8gU3BlY2lmaWNhbGx5LCBgcGFuaWNgIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCBpZiB0b28gbWFueSB1cGRhdGVzIG9jY3VyIGluXHJcbiAgICAvLyBvbmUgZnJhbWUuIFRoaXMgaXMgb25seSByZWxldmFudCBpbnNpZGUgb2YgYW5pbWF0ZSgpLCBidXQgYSByZWZlcmVuY2UgaXNcclxuICAgIC8vIGhlbGQgZXh0ZXJuYWxseSBzbyB0aGF0IHRoaXMgdmFyaWFibGUgaXMgbm90IG1hcmtlZCBmb3IgZ2FyYmFnZVxyXG4gICAgLy8gY29sbGVjdGlvbiBldmVyeSB0aW1lIHRoZSBtYWluIGxvb3AgcnVucy5cclxuICAgIHRoaXMucGFuaWMgPSBmYWxzZTtcclxufTtcclxuXHJcbk1haW5Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1haW5Mb29wO1xyXG5cclxuTWFpbkxvb3AucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldE1heEZQUzogZnVuY3Rpb24gKGZwcylcclxuICAgIHtcclxuICAgICAgICBpZiAoZnBzID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAgLyBmcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNYXhGUFM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLm1pbkZyYW1lRGVsYXk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0RnJhbWVEZWx0YTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb2xkRnJhbWVEZWx0YSA9IHRoaXMuZnJhbWVEZWx0YTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9sZEZyYW1lRGVsdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICB0aW1lc3RhbXAgPSBET01IaWdoUmVzVGltZVN0YW1wXHJcbiAgICBzdGVwOiBmdW5jdGlvbiAodGltZXN0YW1wKVxyXG4gICAge1xyXG4gICAgICAgIC8vIFRocm90dGxlIHRoZSBmcmFtZSByYXRlIChpZiBtaW5GcmFtZURlbGF5IGlzIHNldCB0byBhIG5vbi16ZXJvIHZhbHVlIGJ5XHJcbiAgICAgICAgLy8gYE1haW5Mb29wLnNldE1heEFsbG93ZWRGUFMoKWApLlxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWVNcyArIHRoaXMubWluRnJhbWVEZWxheSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZyYW1lRGVsdGEgaXMgdGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIGluLWFwcCB0aW1lIHRoYXQgaGFzbid0IGJlZW5cclxuICAgICAgICAvLyBzaW11bGF0ZWQgeWV0LiBBZGQgdGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUuIFdlIG5lZWQgdG8gdHJhY2sgdG90YWxcclxuICAgICAgICAvLyBub3QteWV0LXNpbXVsYXRlZCB0aW1lIChhcyBvcHBvc2VkIHRvIGp1c3QgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGVcclxuICAgICAgICAvLyBsYXN0IGZyYW1lKSBiZWNhdXNlIG5vdCBhbGwgYWN0dWFsbHkgZWxhcHNlZCB0aW1lIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgICAgICAvLyBzaW11bGF0ZWQgZWFjaCBmcmFtZS4gU2VlIHRoZSBjb21tZW50cyBiZWxvdyBmb3IgZGV0YWlscy5cclxuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgKz0gdGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lTXM7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICAgIC8vIFJ1biBhbnkgdXBkYXRlcyB0aGF0IGFyZSBub3QgZGVwZW5kZW50IG9uIHRpbWUgaW4gdGhlIHNpbXVsYXRpb24uXHJcblxyXG4gICAgICAgIC8vICBIZXJlIHdlJ2xsIG5lZWQgdG8gcnVuIHRoaW5ncyBsaWtlIHR3ZWVuLnVwZGF0ZSwgaW5wdXQudXBkYXRlLCBldGMuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMuYmVnaW4odGltZXN0YW1wLCB0aGlzLmZyYW1lRGVsdGEpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZSByYXRlLCBgZnBzYC4gRXZlcnkgc2Vjb25kLCB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8gb2YgZnJhbWVzIHRoYXQgb2NjdXJyZWQgaW4gdGhhdCBzZWNvbmQgYXJlIGluY2x1ZGVkIGluIGFuIGV4cG9uZW50aWFsXHJcbiAgICAgICAgLy8gbW92aW5nIGF2ZXJhZ2Ugb2YgYWxsIGZyYW1lcyBwZXIgc2Vjb25kLCB3aXRoIGFuIGFscGhhIG9mIDAuMjUuIFRoaXNcclxuICAgICAgICAvLyBtZWFucyB0aGF0IG1vcmUgcmVjZW50IHNlY29uZHMgYWZmZWN0IHRoZSBlc3RpbWF0ZWQgZnJhbWUgcmF0ZSBtb3JlIHRoYW5cclxuICAgICAgICAvLyBvbGRlciBzZWNvbmRzLlxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPiB0aGlzLmxhc3RGcHNVcGRhdGUgKyAxMDAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIHdpdGggYW4gYWxwaGEgb2YgMC4yNS5cclxuICAgICAgICAgICAgLy8gVXNpbmcgY29uc3RhbnRzIGlubGluZSBpcyBva2F5IGhlcmUuXHJcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMC4yNSAqIHRoaXMuZnJhbWVzVGhpc1NlY29uZCArIDAuNzUgKiB0aGlzLmZwcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCsrO1xyXG5cclxuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuXHJcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnRpbWVzdGVwO1xyXG5cclxuICAgICAgICB3aGlsZSAodGhpcy5mcmFtZURlbHRhID49IHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB0aGlzLnVwZGF0ZSh0aGlzLnRpbWVzdGVwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZShzdGVwLCB0aGlzLnBoeXNpY3NTdGVwKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZXhpc3RzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZShzdGVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIERldiBsZXZlbCBjYWxsYmFja1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZShzdGVwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEZWx0YSAtPSB0aGlzLnRpbWVzdGVwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCsrdGhpcy5udW1VcGRhdGVTdGVwcyA+PSAyNDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFuaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLnByZVJlbmRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNldHRpbmdzLnZpc2libGUgJiYgdGhpcy5zdGF0ZS5zeXMuY29sb3IuYWxwaGEgIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWUucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhdGUsIHRoaXMuZnJhbWVEZWx0YSAvIHRoaXMudGltZXN0ZXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlcy5zdG9wKCk7XHJcblxyXG4gICAgICAgIC8vIFJ1biBhbnkgdXBkYXRlcyB0aGF0IGFyZSBub3QgZGVwZW5kZW50IG9uIHRpbWUgaW4gdGhlIHNpbXVsYXRpb24uXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMuZW5kKHRoaXMuZnBzLCB0aGlzLnBhbmljKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYW5pYyA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKlxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZXN0ZXApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlKHRpbWVzdGVwKTtcclxuXHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgdmFyIGNoaWxkO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlKHRpbWVzdGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIERldiBsZXZlbCBjYWxsYmFja1xyXG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKHRpbWVzdGVwKTtcclxuXHJcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlKHRpbWVzdGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAqL1xyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFpbkxvb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvTWFpbkxvb3AuanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBEaXJ0eSEgTWFuYWdlclxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBVcGRhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5nYW1lID0gc3RhdGUuZ2FtZTtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSBbXTtcclxuXHJcbiAgICAvLyB0aGlzLmkgPSAxO1xyXG5cclxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICB0aGlzLnByb2Nlc3NlZCA9IDA7XHJcbn07XHJcblxyXG5VcGRhdGVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVwZGF0ZU1hbmFnZXI7XHJcblxyXG5VcGRhdGVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdG9wJywgdGhpcy5wcm9jZXNzZWQpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5pKys7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmksICdVcGRhdGVNYW5hZ2VyLnN0YXJ0JywgbGVuKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEJlY2F1c2UgaXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCAoYXMgYSBjaGlsZCBvZiBhbm90aGVyIFRyYW5zZm9ybSB0aGF0IHdhcyB1cGRhdGVkKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldICYmIHRoaXMubGlzdFtpXS5fZGlydHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RbaV0udXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHRyYW5zZm9ybSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxpc3QucHVzaCh0cmFuc2Zvcm0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9VcGRhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQSBTZXQgaXMgYSBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cclxuXHJcbnZhciBTZXQgPSBmdW5jdGlvbiAoZWxlbWVudHMpXHJcbntcclxuICAgIHRoaXMuZW50cmllcyA9IFtdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XHJcblxyXG5TZXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyeVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkdW1wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ1NldCcpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZW50cnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gIEZvciB3aGVuIHlvdSBrbm93IHRoaXMgU2V0IHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBpdGVyYXRpb25cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZW50cmllcy5zbGljZSgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGVtcFtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBGb3Igd2hlbiB5b3UgYWJzb2x1dGVseSBrbm93IHRoaXMgU2V0IHdvbid0IGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXHJcbiAgICBpdGVyYXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGhpcy5lbnRyaWVzW2ldKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluczogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpID4gLTEpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmlvbjogZnVuY3Rpb24gKHNldClcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICBzZXQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFzZXQuY29udGFpbnModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNldC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBzaXplOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RydWN0cy9TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgRXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0V4dGVuZCcpO1xyXG5cclxuLyoqXHJcbiogQSBGcmFtZSBpcyBhIHNlY3Rpb24gb2YgYSBUZXh0dXJlLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5GcmFtZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0aGlzIEZyYW1lIGJlbG9uZ3MgdG8uXHJcbiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdW5pcXVlICh3aXRoaW4gdGhlIFRleHR1cmUpIG5hbWUgb2YgdGhpcyBGcmFtZS5cclxuKiBAcGFyYW0ge251bWJlcn0geCAtIFggcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFkgcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cclxuKi9cclxudmFyIEZyYW1lID0gZnVuY3Rpb24gKHRleHR1cmUsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRoaXMgZnJhbWUgYmVsb25ncyB0by5cclxuICAgICovXHJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4gICAgKi9cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgdGhpcy5zb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IHNvdXJjZUluZGV4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WCAtIFggcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdXRYID0geDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dFkgLSBZIHBvc2l0aW9uIHdpdGhpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dCBmcm9tLlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0WSA9IHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgYXJlYSBpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dC5cclxuICAgICovXHJcbiAgICB0aGlzLmN1dFdpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0geCAtIFRoZSBYIHJlbmRlcmluZyBvZmZzZXQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMueCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIFkgcmVuZGVyaW5nIG9mZnNldCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy55ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlbmRlcmluZyB3aWR0aCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gVGhlIHJlbmRlcmluZyBoZWlnaHQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJcyB0aGlzIGZyYW1lIGlzIHJvdGF0ZWQgb3Igbm90IGluIHRoZSBUZXh0dXJlP1xyXG4gICAgKiBSb3RhdGlvbiBhbGxvd3MgeW91IHRvIHVzZSByb3RhdGVkIGZyYW1lcyBpbiB0ZXh0dXJlIGF0bGFzIHBhY2tpbmcuXHJcbiAgICAqIEl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggU3ByaXRlIHJvdGF0aW9uLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdGF0ZWRcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnJvdGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogSXMgdGhpcyBhIHRpbGluZyB0ZXh0dXJlPyBBcyB1c2VkIGJ5IHRoZSBsaWtlcyBvZiBhIFRpbGluZ1Nwcml0ZS5cclxuICAgICogVE9ETzogVHJ5IGFuZCByZW1vdmUgdGhpcywgaXQgc2hvdWxkbid0IGJlIGhlcmVcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1RpbGluZ1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNUaWxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRpbnRlZCBwYXJlbnQgaGFzIHVwZGF0ZWQgaXRzIHRleHR1cmUuXHJcbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVxdWlyZXNSZVRpbnRcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnJlcXVpcmVzUmVUaW50ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIE92ZXItcmlkZXMgdGhlIFJlbmRlcmVyIHNldHRpbmc/IC0xID0gdXNlIFJlbmRlcmVyIFNldHRpbmcsIDAgPSBObyByb3VuZGluZywgMSA9IFJvdW5kXHJcbiAgICB0aGlzLmF1dG9Sb3VuZCA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgdW4tbW9kaWZpZWQgc291cmNlIGZyYW1lLCB0cmltIGFuZCBVViBkYXRhLlxyXG4gICAgKlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YVxyXG4gICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IHtcclxuICAgICAgICBjdXQ6IHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgdzogd2lkdGgsXHJcbiAgICAgICAgICAgIGg6IGhlaWdodCxcclxuICAgICAgICAgICAgcjogeCArIHdpZHRoLFxyXG4gICAgICAgICAgICBiOiB5ICsgaGVpZ2h0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmltOiBmYWxzZSxcclxuICAgICAgICBzb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwcml0ZVNvdXJjZVNpemU6IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgdzogd2lkdGgsXHJcbiAgICAgICAgICAgIGg6IGhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXZzOiB7XHJcbiAgICAgICAgICAgIHgwOiAwLFxyXG4gICAgICAgICAgICB5MDogMCxcclxuICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICB4MjogMCxcclxuICAgICAgICAgICAgeTI6IDAsXHJcbiAgICAgICAgICAgIHgzOiAwLFxyXG4gICAgICAgICAgICB5MzogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhd0ltYWdlOiB7XHJcbiAgICAgICAgICAgIHN4OiB4LFxyXG4gICAgICAgICAgICBzeTogeSxcclxuICAgICAgICAgICAgc1dpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgc0hlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICBkV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBkSGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudXBkYXRlVVZzKCk7XHJcbn07XHJcblxyXG5GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmFtZTtcclxuXHJcbkZyYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogSWYgdGhlIGZyYW1lIHdhcyB0cmltbWVkIHdoZW4gYWRkZWQgdG8gdGhlIFRleHR1cmUgQXRsYXMsIHRoaXMgcmVjb3JkcyB0aGUgdHJpbSBhbmQgc291cmNlIGRhdGEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlRleHR1cmVGcmFtZSNzZXRUcmltXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWxXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWxIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBmcmFtZSBiZWZvcmUgYmVpbmcgdHJpbW1lZC5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RYIC0gVGhlIGRlc3RpbmF0aW9uIFggcG9zaXRpb24gb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0WSAtIFRoZSBkZXN0aW5hdGlvbiBZIHBvc2l0aW9uIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFdpZHRoIC0gVGhlIGRlc3RpbmF0aW9uIHdpZHRoIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdEhlaWdodCAtIFRoZSBkZXN0aW5hdGlvbiBoZWlnaHQgb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqL1xyXG4gICAgc2V0VHJpbTogZnVuY3Rpb24gKGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQsIGRlc3RYLCBkZXN0WSwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHZhciBzcyA9IGRhdGEuc3ByaXRlU291cmNlU2l6ZTtcclxuICAgICAgICB2YXIgZGkgPSBkYXRhLmRyYXdJbWFnZTtcclxuXHJcbiAgICAgICAgLy8gIFN0b3JlIGFjdHVhbCB2YWx1ZXNcclxuXHJcbiAgICAgICAgZGF0YS50cmltID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLncgPSBhY3R1YWxXaWR0aDtcclxuICAgICAgICBkYXRhLnNvdXJjZVNpemUuaCA9IGFjdHVhbEhlaWdodDtcclxuXHJcbiAgICAgICAgc3MueCA9IGRlc3RYO1xyXG4gICAgICAgIHNzLnkgPSBkZXN0WTtcclxuICAgICAgICBzcy53ID0gZGVzdFdpZHRoO1xyXG4gICAgICAgIHNzLmggPSBkZXN0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyAgQWRqdXN0IHByb3BlcnRpZXNcclxuICAgICAgICB0aGlzLnggPSBkZXN0WDtcclxuICAgICAgICB0aGlzLnkgPSBkZXN0WTtcclxuICAgICAgICB0aGlzLndpZHRoID0gZGVzdFdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGVzdEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gIGRyYXdJbWFnZSBkYXRhXHJcbiAgICAgICAgZGkuc3ggPSBkZXN0WDtcclxuICAgICAgICBkaS5zeSA9IGRlc3RZO1xyXG4gICAgICAgIGRpLnNXaWR0aCA9IGRlc3RXaWR0aDtcclxuICAgICAgICBkaS5zSGVpZ2h0ID0gZGVzdEhlaWdodDtcclxuICAgICAgICBkaS5kV2lkdGggPSBkZXN0V2lkdGg7XHJcbiAgICAgICAgZGkuZEhlaWdodCA9IGRlc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVVZzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgdXBkYXRlVVZzXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0dyA9IHRoaXMuc291cmNlLndpZHRoO1xyXG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcclxuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDAgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTAgPSB0aGlzLmN1dFkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngxID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0V2lkdGgpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkxID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MiA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dFdpZHRoKSAvIHR3O1xyXG4gICAgICAgIHV2cy55MiA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngzID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkzID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0SGVpZ2h0KSAvIHRoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc0ludmVydGVkXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVVZzSW52ZXJ0ZWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ID0gdGhpcy5zb3VyY2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIHRoID0gdGhpcy5zb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLmRhdGEudXZzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHV2cy54MCA9IHRoaXMuY3V0WCAvIHR3O1xyXG4gICAgICAgIHV2cy55MCA9IHRoaXMuY3V0WSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDEgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkxID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MiA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dEhlaWdodCkgLyB0dztcclxuICAgICAgICB1dnMueTIgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRXaWR0aCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngzID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkzID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgRnJhbWUodGhpcy50ZXh0dXJlLCB0aGlzLm5hbWUsIHRoaXMuc291cmNlSW5kZXgpO1xyXG5cclxuICAgICAgICBjbG9uZS5jdXRYID0gdGhpcy5jdXRYO1xyXG4gICAgICAgIGNsb25lLmN1dFkgPSB0aGlzLmN1dFk7XHJcbiAgICAgICAgY2xvbmUuY3V0V2lkdGggPSB0aGlzLmN1dFdpZHRoO1xyXG4gICAgICAgIGNsb25lLmN1dEhlaWdodCA9IHRoaXMuY3V0SGVpZ2h0O1xyXG5cclxuICAgICAgICBjbG9uZS54ID0gdGhpcy54O1xyXG4gICAgICAgIGNsb25lLnkgPSB0aGlzLnk7XHJcbiAgICAgICAgY2xvbmUud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBjbG9uZS5yb3RhdGVkID0gdGhpcy5yb3RhdGVkO1xyXG5cclxuICAgICAgICBjbG9uZS5kYXRhID0gRXh0ZW5kKHRydWUsIGNsb25lLmRhdGEsIHRoaXMuZGF0YSk7XHJcblxyXG4gICAgICAgIGNsb25lLnVwZGF0ZVVWcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRnJhbWUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxyXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxXaWR0aFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbFdpZHRoXHJcbiAgICAqL1xyXG4gICAgcmVhbFdpZHRoOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS53O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBGcmFtZSBpbiBpdHMgdW4tdHJpbW1lZCwgdW4tcGFkZGVkIHN0YXRlLCBhcyBwcmVwYXJlZCBpbiB0aGUgYXJ0IHBhY2thZ2UsXHJcbiAgICAqIGJlZm9yZSBiZWluZyBwYWNrZWQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjcmVhbEhlaWdodFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbEhlaWdodFxyXG4gICAgKi9cclxuICAgIHJlYWxIZWlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VTaXplLmg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVWc1xyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3V2c1xyXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gdXZzXHJcbiAgICAqL1xyXG4gICAgdXZzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEudXZzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYW52YXMgRHJhdyBJbWFnZSBkYXRhXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjY2FudmFzRGF0YVxyXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gY2FudmFzRGF0YVxyXG4gICAgKi9cclxuICAgIGNhbnZhc0RhdGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5kcmF3SW1hZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9GcmFtZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBGcmFtZSA9IHJlcXVpcmUoJy4vRnJhbWUnKTtcclxudmFyIFRleHR1cmVTb3VyY2UgPSByZXF1aXJlKCcuL1RleHR1cmVTb3VyY2UnKTtcclxuXHJcbi8qKlxyXG4qIEEgVGV4dHVyZSBjb25zaXN0cyBvZiBhIHNvdXJjZSwgdXN1YWxseSBhbiBJbWFnZSBmcm9tIHRoZSBDYWNoZSwgb3IgYSBDYW52YXMsIGFuZCBhIGNvbGxlY3Rpb25cclxuKiBvZiBGcmFtZXMuIFRoZSBGcmFtZXMgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgYXJlYXMgb2YgdGhlIFRleHR1cmUuIEZvciBleGFtcGxlIGEgdGV4dHVyZSBhdGxhc1xyXG4qIG1heSBoYXZlIG1hbnkgRnJhbWVzLCBvbmUgZm9yIGVhY2ggZWxlbWVudCB3aXRoaW4gdGhlIGF0bGFzLiBXaGVyZS1hcyBhIHNpbmdsZSBpbWFnZSB3b3VsZCBoYXZlXHJcbioganVzdCBvbmUgZnJhbWUsIHRoYXQgZW5jb21wYXNzZXMgdGhlIHdob2xlIGltYWdlLlxyXG4qXHJcbiogVGV4dHVyZXMgYXJlIG1hbmFnZWQgYnkgdGhlIGdsb2JhbCBUZXh0dXJlTWFuYWdlci4gVGhpcyBpcyBhIHNpbmdsZXRvbiBjbGFzcyB0aGF0IGlzXHJcbiogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBkZWxpdmVyaW5nIFRleHR1cmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIEZyYW1lcyB0byBHYW1lIE9iamVjdHMuXHJcbipcclxuKiBTcHJpdGVzIGFuZCBvdGhlciBHYW1lIE9iamVjdHMgZ2V0IHRoZSB0ZXh0dXJlIGRhdGEgdGhleSBuZWVkIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGVcclxuKi9cclxudmFyIFRleHR1cmUgPSBmdW5jdGlvbiAobWFuYWdlciwga2V5LCBzb3VyY2UpXHJcbntcclxuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXHJcbiAgICB7XHJcbiAgICAgICAgc291cmNlID0gWyBzb3VyY2UgXTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHNvdXJjZSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxyXG4gICAgKiBVc3VhbGx5IGFuIEltYWdlLCBidXQgY2FuIGFsc28gYmUgYSBDYW52YXMuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgICogQHR5cGUgYXJyYXlcclxuICAgICovXHJcbiAgICB0aGlzLnNvdXJjZSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZnJhbWVzIC0gRnJhbWVzXHJcbiAgICAqL1xyXG4gICAgdGhpcy5mcmFtZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmZyYW1lVG90YWwgPSAwO1xyXG5cclxuICAgIC8vICBMb2FkIHRoZSBTb3VyY2VzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKG5ldyBUZXh0dXJlU291cmNlKHRoaXMsIHNvdXJjZVtpXSkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlO1xyXG5cclxuVGV4dHVyZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gbmV3IEZyYW1lKHRoaXMsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZXNbbmFtZV0gPSBmcmFtZTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZVRvdGFsKys7XHJcblxyXG4gICAgICAgIHJldHVybiBmcmFtZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAobmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwgfHwgdGhpcy5mcmFtZVRvdGFsID09PSAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdfX0JBU0UnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbbmFtZV07XHJcblxyXG4gICAgICAgIGlmICghZnJhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIFRleHR1cmUuZnJhbWUgZm91bmQgd2l0aCBuYW1lICcgKyBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1snX19CQVNFJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVJbmRleDogZnVuY3Rpb24gKGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVtpXS5nbFRleHR1cmVJbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zb3VyY2VbaV0uaW1hZ2UuY3VycmVudFNyYywgJ2luZGV4ID0gJywgaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5lZWQgdG8gaXRlcmF0ZSB0aG91Z2ggdGhlIFRleHR1cmVTb3VyY2VzLCBhbmQgdW5sb2FkIGVhY2ggb25lXHJcbiAgICAgICAgLy8gIHRoZW4gY2xlYXIgb3V0IHRoZSBmcmFtZXNcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVCeUNhbnZhcyh0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgKi9cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxyXG4qXHJcbiogQHN0YXRpY1xyXG4qIEBtZXRob2QgZnJvbUNhbnZhc1xyXG4qIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHNvdXJjZSBvZiB0aGUgdGV4dHVyZVxyXG4qIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1QaGFzZXIuc2NhbGVNb2Rlc3t7L2Nyb3NzTGlua319IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuKiBAcmV0dXJuIHtCYXNlVGV4dHVyZX1cclxuUGhhc2VyLlRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcclxue1xyXG4gICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYW52YXMuaGVpZ2h0ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUGhhc2VyLlRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xyXG59O1xyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcclxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcclxuXHJcbi8qKlxyXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xyXG4qIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgZGVsaXZlcmluZyBUZXh0dXJlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBGcmFtZXMgdG8gR2FtZSBPYmplY3RzLlxyXG4qXHJcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cclxuKlxyXG4qIEFjY2VzcyBpdCB2aWEgYHN0YXRlLnRleHR1cmVzYC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZU1hbmFnZXJcclxuKiBAY29uc3RydWN0b3JcclxuKi9cclxudmFyIFRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgdGhpcy5saXN0ID0ge307XHJcbn07XHJcblxyXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlTWFuYWdlcjtcclxuXHJcblRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhZGRJbWFnZTogZnVuY3Rpb24gKGtleSwgc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFBhcnNlci5JbWFnZSh0ZXh0dXJlLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENhbnZhczogZnVuY3Rpb24gKGtleSwgc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFBhcnNlci5DYW52YXModGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhczogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBJcyBpdCBhIEhhc2ggb3IgYW4gQXJyYXk/XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZnJhbWVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkFycmF5KGtleSwgc291cmNlLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQXRsYXNKU09OSGFzaChrZXksIHNvdXJjZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc0pTT05BcnJheTogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuSlNPTkFycmF5KHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzSlNPTkhhc2g6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OSGFzaCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuSlNPTkhhc2godGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlU2hlZXQ6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRleHR1cmUuc291cmNlWzBdLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlLnNvdXJjZVswXS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTcHJpdGVTaGVldEZyb21BdGxhczogZnVuY3Rpb24gKGtleSwgYXRsYXNLZXksIGF0bGFzRnJhbWUsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhdGxhcyA9IHRoaXMuZ2V0KGF0bGFzS2V5KTtcclxuICAgICAgICB2YXIgc2hlZXQgPSBhdGxhcy5nZXQoYXRsYXNGcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzaGVldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzaGVldC5zb3VyY2UuaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgUGFyc2VyLlNwcml0ZVNoZWV0KHRleHR1cmUsIDAsIHNoZWV0LmN1dFgsIHNoZWV0LmN1dFksIHNoZWV0LmN1dFdpZHRoLCBzaGVldC5jdXRIZWlnaHQsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNTdGFybGluZ1hNTDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLlN0YXJsaW5nWE1MKHRleHR1cmUsIGksIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc1B5eGVsOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYXJzZXIuUHl4ZWwodGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLlB5eGVsKHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGtleSwgc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcywga2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBleGlzdHM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gJ19fREVGQVVMVCc7IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0WydfX01JU1NJTkcnXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lRnJhbWU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XS5nZXQoZnJhbWUpLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGcmFtZTogZnVuY3Rpb24gKGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldLmdldChmcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwga2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnYW1lT2JqZWN0LnRleHR1cmUgPSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC5mcmFtZSA9IGdhbWVPYmplY3QudGV4dHVyZS5nZXQoZnJhbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIFRleHR1cmVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBlYWNoXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBjaGlsZC5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbIG51bGwgXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIHRleHR1cmUgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1swXSA9IHRoaXMubGlzdFt0ZXh0dXJlXTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyLmpzIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBJc1NpemVQb3dlck9mVHdvID0gcmVxdWlyZSgnLi4vbWF0aC9wb3cyL0lzU2l6ZVBvd2VyT2ZUd28nKTtcclxuXHJcbi8qKlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlU291cmNlXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGVcclxuKi9cclxudmFyIFRleHR1cmVTb3VyY2UgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlKVxyXG57XHJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuICAgIHRoaXMuaW1hZ2UgPSBzb3VyY2U7XHJcblxyXG4gICAgdGhpcy5jb21wcmVzc2lvbkFsZ29yaXRobSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBSZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgcmVzb2x1dGlvblxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICovXHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0dXJlLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgd2lkdGhcclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqIEByZWFkT25seVxyXG4gICAgKi9cclxuICAgIHRoaXMud2lkdGggPSBzb3VyY2UubmF0dXJhbFdpZHRoIHx8IHNvdXJjZS53aWR0aCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgaGVpZ2h0XHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKiBAcmVhZE9ubHlcclxuICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IHNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZS5oZWlnaHQgfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZS5cclxuICAgICogTkVBUkVTVCBvciBERUZBVUxUXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBzY2FsZU1vZGVcclxuICAgICogQHR5cGUge051bWJlcn1cclxuICAgICogQGRlZmF1bHQgUGhhc2VyLnNjYWxlTW9kZXMuREVGQVVMVDtcclxuICAgICovXHJcbiAgICB0aGlzLnNjYWxlTW9kZSA9IFNjYWxlTW9kZXMuREVGQVVMVDtcclxuXHJcbiAgICAvKipcclxuICAgICogQ29udHJvbHMgaWYgUkdCIGNoYW5uZWxzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCBieSBBbHBoYSAgKFdlYkdMIG9ubHkpXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBwcmVtdWx0aXBsaWVkQWxwaGFcclxuICAgICogQHR5cGUgQm9vbGVhblxyXG4gICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIGEgbWlwbWFwIG9mIHRoaXMgdGV4dHVyZSBuZWVkcyB0byBiZSBnZW5lcmF0ZWQuIFRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSB0aGUgdGV4dHVyZSBpcyB1c2VkXHJcbiAgICAqIEFsc28gdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBzaXplIHRvIHdvcmtcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IG1pcG1hcFxyXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICovXHJcbiAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIEJhc2VUZXh0dXJlIGNhbiBiZSBzZXQgdG8gc2tpcCB0aGUgcmVuZGVyaW5nIHBoYXNlIGluIHRoZSBXZWJHTCBTcHJpdGUgQmF0Y2guXHJcbiAgICAqXHJcbiAgICAqIFlvdSBtYXkgd2FudCB0byBkbyB0aGlzIGlmIHlvdSBoYXZlIGEgcGFyZW50IFNwcml0ZSB3aXRoIG5vIHZpc2libGUgdGV4dHVyZSAoaS5lLiB1c2VzIHRoZSBpbnRlcm5hbCBgX19kZWZhdWx0YCB0ZXh0dXJlKVxyXG4gICAgKiB0aGF0IGhhcyBjaGlsZHJlbiB0aGF0IHlvdSBkbyB3YW50IHRvIHJlbmRlciwgd2l0aG91dCBjYXVzaW5nIGEgYmF0Y2ggZmx1c2ggaW4gdGhlIHByb2Nlc3MuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSByZW5kZXJhYmxlXHJcbiAgICAqIEB0eXBlIEJvb2xlYW5cclxuICAgICovXHJcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgaXNQb3dlck9mMlxyXG4gICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1Bvd2VyT2YyID0gSXNTaXplUG93ZXJPZlR3byh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSBnbFRleHR1cmVcclxuICAgICovXHJcbiAgICB0aGlzLmdsVGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBtdWx0aSB0ZXh0dXJlIGJhdGNoaW5nIGluZGV4IG51bWJlci5cclxuICAgICogQHByb3BlcnR5IGdsVGV4dHVyZUluZGV4XHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xUZXh0dXJlSW5kZXggPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgdGltZXN0YW1wIHdoZW4gdGhpcyB0ZXh0dXJlIHdhcyBsYXN0IHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyLlxyXG4gICAgKiBDYW4gYmUgdXNlZCB0byBwdXJnZSBvdXQgJ2RlYWQnIHRleHR1cmVzIGZyb20gR1BVIG1lbW9yeS5cclxuICAgICogQHByb3BlcnR5IGdsTGFzdFVzZWRcclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nbExhc3RVc2VkID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IGdsRGlydHlcclxuICAgICovXHJcbiAgICB0aGlzLmdsRGlydHkgPSB0cnVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlU291cmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgQ2FudmFzVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcclxue1xyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuXHJcbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1RleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSW1hZ2VUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4KVxyXG57XHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG5cclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0ltYWdlVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlcyBhIEpTT04gQXJyYXkgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuSlNPTkFycmF5XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUgSlNPTiBkYXRhIGZyb20gdGhlIFRleHR1cmUgQXRsYXMuIE11c3QgYmUgaW4gQXJyYXkgZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSlNPTkFycmF5VGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleCwganNvbilcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICghanNvblsnZnJhbWVzJ10pXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIFRleHR1cmUgQXRsYXMgSlNPTiBBcnJheSBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgYXJyYXknKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXHJcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBhcnJheVxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2ZyYW1lcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNbaV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKHNyYy5maWxlbmFtZSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OQXJyYXlUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05BcnJheVRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZXMgYSBKU09OIEFycmF5IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIEpTT04gSGFzaCBmb3JtYXQuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBKU09OSGFzaFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgT2JqZWN0XHJcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2tleV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKGtleSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OSGFzaFRleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkhhc2hUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgUHl4ZWwgSlNPTiBGaWxlIGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIFB5eGVsIEpTT04gZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgUHl4ZWxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/IFRoZXJlIGFyZSBhIGZldyBrZXlzIHRvIGNoZWNrIGhlcmUuXHJcbiAgICB2YXIgc2lnbmF0dXJlID0gWyAnbGF5ZXJzJywgJ3RpbGV3aWR0aCcsICd0aWxlaGVpZ2h0JywgJ3RpbGVzd2lkZScsICd0aWxlc2hpZ2gnIF07XHJcblxyXG4gICAgc2lnbmF0dXJlLmZvckVhY2goZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIWpzb25ba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBJbnZhbGlkIFB5eGVsIFRpbGVtYXAgSlNPTiBnaXZlbiwgbWlzc2luZyBcIicgKyBrZXkgKyAnXCIga2V5LicpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIEkgb25seSBjYXJlIGFib3V0IHBhcnNpbmcgdGlsZW1hcHMgd2l0aCBhIHNpbmdsZSBsYXllci5cclxuICAgIGlmIChqc29uWydsYXllcnMnXS5sZW5ndGggIT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLkpTT05EYXRhUHl4ZWw6IFRvbyBtYW55IGxheWVycywgdGhpcyBwYXJzZXIgb25seSBzdXBwb3J0cyBmbGF0IFRpbGVtYXBzLicpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb24pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XHJcblxyXG4gICAgdmFyIHRpbGVoZWlnaHQgPSBqc29uWyd0aWxlaGVpZ2h0J107XHJcbiAgICB2YXIgdGlsZXdpZHRoID0ganNvblsndGlsZXdpZHRoJ107XHJcblxyXG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2xheWVycyddWzBdWyd0aWxlcyddO1xyXG4gICAgdmFyIG5ld0ZyYW1lO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBmcmFtZXNbaV0ueCxcclxuICAgICAgICAgICAgZnJhbWVzW2ldLnksXHJcbiAgICAgICAgICAgIHRpbGV3aWR0aCxcclxuICAgICAgICAgICAgdGlsZWhlaWdodCxcclxuICAgICAgICAgICAgXCJmcmFtZV9cIiArIGkgIC8vIE5vIG5hbWVzIGFyZSBpbmNsdWRlZCBpbiBweXhlbCB0aWxlbWFwIGRhdGEuXHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIC8vIE5vIHRyaW0gZGF0YSBpcyBpbmNsdWRlZC5cclxuICAgICAgICBuZXdGcmFtZS5zZXRUcmltKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHl4ZWxUZXh0dXJlUGFyc2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLlNwcml0ZVNoZWV0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGZyYW1lSGVpZ2h0IC0gVGhlIGZpeGVkIGhlaWdodCBvZiBlYWNoIGZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRGcmFtZT0wXSAtIFNraXAgYSBudW1iZXIgb2YgZnJhbWVzLiBVc2VmdWwgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3ByaXRlIHNoZWV0cyBpbiBvbmUgVGV4dHVyZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2VuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbWFyZ2luPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBhIG1hcmdpbiwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtzcGFjaW5nPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBzcGFjaW5nIGJldHdlZW4gdGhlbSwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBTcHJpdGVTaGVldFRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nKVxyXG57XHJcbiAgICBpZiAoc3RhcnRGcmFtZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0RnJhbWUgPSAwOyB9XHJcbiAgICBpZiAoZW5kRnJhbWUgPT09IHVuZGVmaW5lZCkgeyBlbmRGcmFtZSA9IC0xOyB9XHJcbiAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHsgbWFyZ2luID0gMDsgfVxyXG4gICAgaWYgKHNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyBzcGFjaW5nID0gMDsgfVxyXG5cclxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh3aWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcclxuICAgIHZhciBjb2x1bW4gPSBNYXRoLmZsb29yKChoZWlnaHQgLSBtYXJnaW4pIC8gKGZyYW1lSGVpZ2h0ICsgc3BhY2luZykpO1xyXG4gICAgdmFyIHRvdGFsID0gcm93ICogY29sdW1uO1xyXG5cclxuICAgIGlmIChzdGFydEZyYW1lID4gdG90YWwgfHwgc3RhcnRGcmFtZSA8IC10b3RhbClcclxuICAgIHtcclxuICAgICAgICBzdGFydEZyYW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEFsbG93IG5lZ2F0aXZlIHNraXBmcmFtZXMuXHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRvdGFsID0gc3RhcnRGcmFtZSArIChlbmRGcmFtZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmeCA9IG1hcmdpbjtcclxuICAgIHZhciBmeSA9IG1hcmdpbjtcclxuICAgIHZhciBheCA9IDA7XHJcbiAgICB2YXIgYXkgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBheCA9IDA7XHJcbiAgICAgICAgYXkgPSAwO1xyXG5cclxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IGZ5ICsgZnJhbWVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheCA9IHcgLSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoID4gaGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXkgPSBoIC0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dHVyZS5hZGQoaSwgc291cmNlSW5kZXgsIHggKyBmeCwgeSArIGZ5LCBmcmFtZVdpZHRoIC0gYXgsIGZyYW1lSGVpZ2h0IC0gYXkpO1xyXG5cclxuICAgICAgICBmeCArPSBmcmFtZVdpZHRoICsgc3BhY2luZztcclxuXHJcbiAgICAgICAgaWYgKGZ4ICsgZnJhbWVXaWR0aCA+IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnggPSBtYXJnaW47XHJcbiAgICAgICAgICAgIGZ5ICs9IGZyYW1lSGVpZ2h0ICsgc3BhY2luZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZXMgdGhlIFhNTCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TdGFybGluZ1hNTFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSB4bWwgLSBUaGUgWE1MIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBTdGFybGluZyBYTUwgZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHhtbClcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICgheG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUZXh0dXJlQXRsYXMnKSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLlhNTERhdGE6IEludmFsaWQgVGV4dHVyZSBBdGxhcyBYTUwgZ2l2ZW4sIG1pc3NpbmcgPFRleHR1cmVBdGxhcz4gdGFnXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTGV0J3MgY3JlYXRlIHNvbWUgZnJhbWVzIHRoZW5cclxuICAgIHZhciBkYXRhID0gbmV3IFBoYXNlci5GcmFtZURhdGEoKTtcclxuICAgIHZhciBmcmFtZXMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1N1YlRleHR1cmUnKTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICB2YXIgbmFtZTtcclxuICAgIHZhciBmcmFtZTtcclxuICAgIHZhciB4O1xyXG4gICAgdmFyIHk7XHJcbiAgICB2YXIgd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0O1xyXG4gICAgdmFyIGZyYW1lWDtcclxuICAgIHZhciBmcmFtZVk7XHJcbiAgICB2YXIgZnJhbWVXaWR0aDtcclxuICAgIHZhciBmcmFtZUhlaWdodDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBuYW1lID0gZnJhbWUubmFtZS52YWx1ZTtcclxuICAgICAgICB4ID0gcGFyc2VJbnQoZnJhbWUueC52YWx1ZSwgMTApO1xyXG4gICAgICAgIHkgPSBwYXJzZUludChmcmFtZS55LnZhbHVlLCAxMCk7XHJcbiAgICAgICAgd2lkdGggPSBwYXJzZUludChmcmFtZS53aWR0aC52YWx1ZSwgMTApO1xyXG4gICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmhlaWdodC52YWx1ZSwgMTApO1xyXG5cclxuICAgICAgICBmcmFtZVggPSBudWxsO1xyXG4gICAgICAgIGZyYW1lWSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChmcmFtZS5mcmFtZVgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZVggPSBNYXRoLmFicyhwYXJzZUludChmcmFtZS5mcmFtZVgudmFsdWUsIDEwKSk7XHJcbiAgICAgICAgICAgIGZyYW1lWSA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWS52YWx1ZSwgMTApKTtcclxuICAgICAgICAgICAgZnJhbWVXaWR0aCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lV2lkdGgudmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgZnJhbWVIZWlnaHQgPSBwYXJzZUludChmcmFtZS5mcmFtZUhlaWdodC52YWx1ZSwgMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV3RnJhbWUgPSBkYXRhLmFkZEZyYW1lKG5ldyBQaGFzZXIuRnJhbWUoaSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbmFtZSkpO1xyXG5cclxuICAgICAgICAvLyAgVHJpbW1lZD9cclxuICAgICAgICBpZiAoZnJhbWVYICE9PSBudWxsIHx8IGZyYW1lWSAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0odHJ1ZSwgd2lkdGgsIGhlaWdodCwgZnJhbWVYLCBmcmFtZVksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGFybGluZ1hNTFRleHR1cmVQYXJzZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ2FudmFzOiByZXF1aXJlKCcuL0NhbnZhc1RleHR1cmVQYXJzZXInKSxcclxuICAgIEltYWdlOiByZXF1aXJlKCcuL0ltYWdlVGV4dHVyZVBhcnNlcicpLFxyXG4gICAgU3ByaXRlU2hlZXQ6IHJlcXVpcmUoJy4vU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBKU09OQXJyYXk6IHJlcXVpcmUoJy4vSlNPTkFycmF5VGV4dHVyZVBhcnNlcicpLFxyXG4gICAgSlNPTkhhc2g6IHJlcXVpcmUoJy4vSlNPTkhhc2hUZXh0dXJlUGFyc2VyJyksXHJcbiAgICBTdGFybGluZ1hNTDogcmVxdWlyZSgnLi9TdGFybGluZ1hNTFRleHR1cmVQYXJzZXInKSxcclxuICAgIFB5eGVsOiByZXF1aXJlKCcuL1B5eGVsVGV4dHVyZVBhcnNlcicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwiLyoqXHJcbiogU25hcHMgYSB2YWx1ZSB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhbiBhcnJheS5cclxuKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGluIHRoZSByYW5nZSBgW2ZpcnN0X3ZhbHVlLCBsYXN0X3ZhbHVlXWAuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCB2YWx1ZVxyXG4qIEBwYXJhbSB7bnVtYmVyW119IGFyciAtIFRoZSBpbnB1dCBhcnJheSB3aGljaCBfbXVzdF8gYmUgc29ydGVkLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgdmFsdWUgZm91bmQuXHJcbiovXHJcbnZhciBGaW5kQ2xvc2VzdEluU29ydGVkID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSlcclxue1xyXG4gICAgaWYgKCFhcnJheS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSB8fCB2YWx1ZSA8IGFycmF5WzBdKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVswXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKGFycmF5W2ldIDwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb3cgPSBhcnJheVtpIC0gMV07XHJcbiAgICB2YXIgaGlnaCA9IChpIDwgYXJyYXkubGVuZ3RoKSA/IGFycmF5W2ldIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuICAgIHJldHVybiAoKGhpZ2ggLSB2YWx1ZSkgPD0gKHZhbHVlIC0gbG93KSkgPyBoaWdoIDogbG93O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaW5kQ2xvc2VzdEluU29ydGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogRmV0Y2ggYSByYW5kb20gZW50cnkgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXHJcbipcclxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcclxuKiBvciBpZiB0aGVyZSBpcyBubyBpdGVtIGZvciB0aGUgcmFuZG9tbHkgY2hvc2VuIGluZGV4LlxyXG4qXHJcbiogQG1ldGhvZFxyXG4qIEBwYXJhbSB7YW55W119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxyXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIHJhbmRvbSBvYmplY3QgdGhhdCB3YXMgc2VsZWN0ZWQuXHJcbiovXHJcblxyXG52YXIgR2V0UmFuZG9tRWxlbWVudCA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnQsIGxlbmd0aClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyB9XHJcblxyXG4gICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnQgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xyXG5cclxuICAgIHJldHVybiAoYXJyYXlbcmFuZG9tSW5kZXhdID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGFycmF5W3JhbmRvbUluZGV4XTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmFuZG9tRWxlbWVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZEF3YXlGcm9tWmVybyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvUm91bmRBd2F5RnJvbVplcm8nKTtcclxuXHJcbi8qKlxyXG4qIENyZWF0ZSBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb20gYHN0YXJ0YFxyXG4qIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgIGJ5IGFkdmFuY2luZyBieSBgc3RlcGAuXHJcbipcclxuKiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgZW5kYCBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cclxuKlxyXG4qIENlcnRhaW4gdmFsdWVzIGZvciBgc3RhcnRgIGFuZCBgZW5kYCAoZWcuIE5hTi91bmRlZmluZWQvbnVsbCkgYXJlIGN1cnJlbnRseSBjb2VyY2VkIHRvIDA7XHJcbiogZm9yIGZvcndhcmQgY29tcGF0aWJpbGl0eSBtYWtlIHN1cmUgdG8gcGFzcyBpbiBhY3R1YWwgbnVtYmVycy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMjbnVtYmVyQXJyYXlTdGVwXHJcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gLSBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gLSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cclxuKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBudW1iZXJzLlxyXG4qIEBleGFtcGxlXHJcbiogTnVtYmVyQXJyYXlTdGVwKDQpO1xyXG4qIC8vID0+IFswLCAxLCAyLCAzXVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDEsIDUpO1xyXG4qIC8vID0+IFsxLCAyLCAzLCA0XVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDAsIDIwLCA1KTtcclxuKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDAsIC00LCAtMSk7XHJcbiogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNCwgMCk7XHJcbiogLy8gPT4gWzEsIDEsIDFdXHJcbipcclxuKiBOdW1iZXJBcnJheVN0ZXAoMCk7XHJcbiogLy8gPT4gW11cclxuKi9cclxudmFyIE51bWJlckFycmF5U3RlcCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgeyBlbmQgPSBudWxsOyB9XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAxOyB9XHJcblxyXG4gICAgaWYgKGVuZCA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIHZhciB0b3RhbCA9IE1hdGgubWF4KFJvdW5kQXdheUZyb21aZXJvKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICByZXN1bHQucHVzaChzdGFydCk7XHJcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheVN0ZXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L051bWJlckFycmF5U3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L051bWJlckFycmF5U3RlcC5qcyIsInZhciBTcGxpY2VPbmUgPSByZXF1aXJlKCcuL1NwbGljZU9uZScpO1xyXG5cclxuLyoqXHJcbiogUmVtb3ZlcyBhIHJhbmRvbSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXHJcbipcclxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcclxuKiBvciBpZiB0aGVyZSBpcyBubyBpdGVtIGZvciB0aGUgcmFuZG9tbHkgY2hvc2VuIGluZGV4LlxyXG4qXHJcbiogQG1ldGhvZFxyXG4qIEBwYXJhbSB7YW55W119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxyXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIHJhbmRvbSBvYmplY3QgdGhhdCB3YXMgcmVtb3ZlZC5cclxuKi9cclxuXHJcbnZhciBSZW1vdmVSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cclxuXHJcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIFNwbGljZU9uZShhcnJheSwgcmFuZG9tSW5kZXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVSYW5kb21FbGVtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIi8qKlxyXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgYXJyYXkgdG8gdGhlIGVuZCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxyXG4qIFRoZSBcInJvdGF0aW9uXCIgaGFwcGVucyB0byB0aGUgbGVmdC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMucm90YXRlXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2hpZnQvcm90YXRlLiBUaGUgYXJyYXkgaXMgbW9kaWZpZWQuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXHJcbiogQHJldHVybiB7YW55fSBUaGUgc2hpZnRlZCB2YWx1ZS5cclxuKi9cclxudmFyIFJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxyXG57XHJcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5zaGlmdCgpO1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUxlZnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1JvdGF0ZUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBNb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byB0aGUgc3RhcnQsIHNoaWZ0aW5nIGFsbCBpdGVtcyBpbiB0aGUgcHJvY2Vzcy5cclxuKiBUaGUgXCJyb3RhdGlvblwiIGhhcHBlbnMgdG8gdGhlIHJpZ2h0LlxyXG4qXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2hpZnQvcm90YXRlLiBUaGUgYXJyYXkgaXMgbW9kaWZpZWQuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXHJcbiogQHJldHVybiB7YW55fSBUaGUgc2hpZnRlZCB2YWx1ZS5cclxuKi9cclxudmFyIFJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKGFycmF5LCB0b3RhbClcclxue1xyXG4gICAgaWYgKHRvdGFsID09PSB1bmRlZmluZWQpIHsgdG90YWwgPSAxOyB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcclxuICAgIHtcclxuICAgICAgICBlbGVtZW50ID0gYXJyYXkucG9wKCk7XHJcbiAgICAgICAgYXJyYXkudW5zaGlmdChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlUmlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQSBzdGFuZGFyZCBGaXNoZXItWWF0ZXMgQXJyYXkgc2h1ZmZsZSBpbXBsZW1lbnRhdGlvbiB3aGljaCBtb2RpZmllcyB0aGUgYXJyYXkgaW4gcGxhY2UuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cclxuKiBAcmV0dXJuIHthbnlbXX0gVGhlIG9yaWdpbmFsIGFycmF5LCBub3cgc2h1ZmZsZWQuXHJcbiovXHJcbnZhciBTaHVmZmxlID0gZnVuY3Rpb24gKGFycmF5KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcclxuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaHVmZmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9TaHVmZmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGQ6L3dhbXAvd3d3L3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoYXNlci5qcyIsInJlcXVpcmUoJy4vcG9seWZpbGxzJyk7XHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdC9FeHRlbmQnKTtcclxuXHJcbi8vICBUaGlzIG9iamVjdCBpcyBleHBvcnRlZCBnbG9iYWxseVxyXG5cclxudmFyIFBoYXNlciA9IHtcclxuXHJcbiAgICBHYW1lOiByZXF1aXJlKCcuL2Jvb3QvR2FtZScpLFxyXG5cclxuICAgIEV2ZW50OiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudCcpLFxyXG4gICAgRXZlbnREaXNwYXRjaGVyOiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKSxcclxuXHJcbiAgICBNYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcclxuXHJcbiAgICBHZW9tOiByZXF1aXJlKCcuL2dlb20nKSxcclxuXHJcbiAgICBHYW1lT2JqZWN0czoge1xyXG5cclxuICAgICAgICBGYWN0b3J5OiByZXF1aXJlKCcuL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgTG9hZGVyOiB7XHJcblxyXG4gICAgICAgIEltYWdlRmlsZTogcmVxdWlyZSgnLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBTb3VuZDogcmVxdWlyZSgnLi9zb3VuZCcpLFxyXG5cclxuICAgIFV0aWxzOiB7XHJcblxyXG4gICAgICAgIEFycmF5OiByZXF1aXJlKCcuL3V0aWxzL2FycmF5LycpLFxyXG4gICAgICAgIE9iamVjdHM6IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0LycpXHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vICBSZXF1aXJlZCwgYnV0IGRvbid0IG5lZWQgUGhhc2VyIGxldmVsIGV4cG9ydHNcclxuXHJcbnJlcXVpcmUoJy4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnknKTtcclxuXHJcbi8vICAgTWVyZ2UgaW4gdGhlIGNvbnN0c1xyXG5cclxuUGhhc2VyID0gRXh0ZW5kKGZhbHNlLCBQaGFzZXIsIENPTlNUKTtcclxuXHJcbi8vICBFeHBvcnQgaXRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGhhc2VyO1xyXG5cclxuZ2xvYmFsLlBoYXNlciA9IFBoYXNlcjtcclxuXHJcbi8qXHJcbiAqIOKAnFNvbWV0aW1lcywgdGhlIGVsZWdhbnQgaW1wbGVtZW50YXRpb24gaXMganVzdCBhIGZ1bmN0aW9uLlxyXG4gKiBOb3QgYSBtZXRob2QuIE5vdCBhIGNsYXNzLiBOb3QgYSBmcmFtZXdvcmsuIEp1c3QgYSBmdW5jdGlvbi7igJ1cclxuICogLSBKb2huIENhcm1hY2tcclxuICovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoYXNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=