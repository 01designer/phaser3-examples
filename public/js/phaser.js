(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 688);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetValue = function (source, key, defaultValue)
{
    if (!source || typeof source === 'number')
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    }
    else
    {
        return defaultValue;
    }
};

module.exports = GetValue;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse

function hasGetterOrSetter (def)
{
    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');
}

function getProperty (definition, k, isClassDescriptor)
{
    //  This may be a lightweight object, OR it might be a property that was defined previously.
    
    //  For simple class descriptors we can just assume its NOT previously defined.
    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);

    if (!isClassDescriptor && def.value && typeof def.value === 'object')
    {
        def = def.value;
    }

    //  This might be a regular property, or it may be a getter/setter the user defined in a class.
    if (def && hasGetterOrSetter(def))
    {
        if (typeof def.enumerable === 'undefined')
        {
            def.enumerable = true;
        }

        if (typeof def.configurable === 'undefined')
        {
            def.configurable = true;
        }

        return def;
    }
    else
    {
        return false;
    }
}

function hasNonConfigurable (obj, k)
{
    var prop = Object.getOwnPropertyDescriptor(obj, k);

    if (!prop)
    {
        return false;
    }

    if (prop.value && typeof prop.value === 'object')
    {
        prop = prop.value;
    }

    if (prop.configurable === false)
    {
        return true;
    }

    return false;
}

function extend (ctor, definition, isClassDescriptor, extend)
{
    for (var k in definition)
    {
        if (!definition.hasOwnProperty(k))
        {
            continue;
        }

        var def = getProperty(definition, k, isClassDescriptor);

        if (def !== false)
        {
            //  If Extends is used, we will check its prototype to see if the final variable exists.
            
            var parent = extend || ctor;

            if (hasNonConfigurable(parent.prototype, k))
            {
                //  Just skip the final property
                if (Class.ignoreFinals)
                {
                    continue;
                }

                //  We cannot re-define a property that is configurable=false.
                //  So we will consider them final and throw an error. This is by
                //  default so it is clear to the developer what is happening.
                //  You can set ignoreFinals to true if you need to extend a class
                //  which has configurable=false; it will simply not re-define final properties.
                throw new Error('cannot override final property \'' + k + '\', set Class.ignoreFinals = true to skip');
            }

            Object.defineProperty(ctor.prototype, k, def);
        }
        else
        {
            ctor.prototype[k] = definition[k];
        }
    }
}

function mixin (myClass, mixins)
{
    if (!mixins)
    {
        return;
    }

    if (!Array.isArray(mixins))
    {
        mixins = [ mixins ];
    }

    for (var i = 0; i < mixins.length; i++)
    {
        extend(myClass, mixins[i].prototype || mixins[i]);
    }
}

/**
 * Creates a new class with the given descriptor.
 * The constructor, defined by the name `initialize`,
 * is an optional function. If unspecified, an anonymous
 * function will be used which calls the parent class (if
 * one exists).
 *
 * You can also use `Extends` and `Mixins` to provide subclassing
 * and inheritance.
 *
 * @class  Class
 * @constructor
 * @param {Object} definition a dictionary of functions for the class
 * @example
 *
 *      var MyClass = new Phaser.Class({
 *      
 *          initialize: function() {
 *              this.foo = 2.0;
 *          },
 *
 *          bar: function() {
 *              return this.foo + 5;
 *          }
 *      });
 */
function Class (definition)
{
    if (!definition)
    {
        definition = {};
    }

    //  The variable name here dictates what we see in Chrome debugger
    var initialize;
    var Extends;

    if (definition.initialize)
    {
        if (typeof definition.initialize !== 'function')
        {
            throw new Error('initialize must be a function');
        }

        initialize = definition.initialize;

        //  Usually we should avoid 'delete' in V8 at all costs.
        //  However, its unlikely to make any performance difference
        //  here since we only call this on class creation (i.e. not object creation).
        delete definition.initialize;
    }
    else
    {
        if (definition.Extends)
        {
            var base = definition.Extends;

            initialize = function ()
            {
                base.apply(this, arguments);
            };
        }
        else
        {
            initialize = function () {};
        }
    }

    if (definition.Extends)
    {
        initialize.prototype = Object.create(definition.Extends.prototype);
        initialize.prototype.constructor = initialize;

        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)

        Extends = definition.Extends;

        delete definition.Extends;
    }
    else
    {
        initialize.prototype.constructor = initialize;
    }

    //  Grab the mixins, if they are specified...
    var mixins = null;

    if (definition.Mixins)
    {
        mixins = definition.Mixins;
        delete definition.Mixins;
    }

    //  First, mixin if we can.
    mixin(initialize, mixins);

    //  Now we grab the actual definition which defines the overrides.
    extend(initialize, definition, true, Extends);

    return initialize;
}

Class.extend = extend;
Class.mixin = mixin;
Class.ignoreFinals = false;

module.exports = Class;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/

var Common = {};

module.exports = Common;

(function() {

    Common._nextId = 0;
    Common._seed = 0;

    /**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */
    Common.extend = function(obj, deep) {
        var argsStart,
            args,
            deepClone;

        if (typeof deep === 'boolean') {
            argsStart = 2;
            deepClone = deep;
        } else {
            argsStart = 1;
            deepClone = true;
        }

        for (var i = argsStart; i < arguments.length; i++) {
            var source = arguments[i];

            if (source) {
                for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                            obj[prop] = obj[prop] || {};
                            Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                            obj[prop] = source[prop];
                        }
                    } else {
                        obj[prop] = source[prop];
                    }
                }
            }
        }
        
        return obj;
    };

    /**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */
    Common.clone = function(obj, deep) {
        return Common.extend({}, deep, obj);
    };

    /**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */
    Common.keys = function(obj) {
        if (Object.keys)
            return Object.keys(obj);

        // avoid hasOwnProperty for performance
        var keys = [];
        for (var key in obj)
            keys.push(key);
        return keys;
    };

    /**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */
    Common.values = function(obj) {
        var values = [];
        
        if (Object.keys) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
            }
            return values;
        }
        
        // avoid hasOwnProperty for performance
        for (var key in obj)
            values.push(obj[key]);
        return values;
    };

    /**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */
    Common.get = function(obj, path, begin, end) {
        path = path.split('.').slice(begin, end);

        for (var i = 0; i < path.length; i += 1) {
            obj = obj[path[i]];
        }

        return obj;
    };

    /**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */
    Common.set = function(obj, path, val, begin, end) {
        var parts = path.split('.').slice(begin, end);
        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
        return val;
    };

    /**
     * Returns a hex colour string made by lightening or darkening color by percent.
     * @method shadeColor
     * @param {string} color
     * @param {number} percent
     * @return {string} A hex colour
     */
    Common.shadeColor = function(color, percent) {   
        // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color
        var colorInteger = parseInt(color.slice(1),16), 
            amount = Math.round(2.55 * percent), 
            R = (colorInteger >> 16) + amount, 
            B = (colorInteger >> 8 & 0x00FF) + amount, 
            G = (colorInteger & 0x0000FF) + amount;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R :255) * 0x10000 
                + (B < 255 ? B < 1 ? 0 : B : 255) * 0x100 
                + (G < 255 ? G < 1 ? 0 : G : 255)).toString(16).slice(1);
    };

    /**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */
    Common.shuffle = function(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Common.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    };

    /**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */
    Common.choose = function(choices) {
        return choices[Math.floor(Common.random() * choices.length)];
    };

    /**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */
    Common.isElement = function(obj) {
        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
        try {
            return obj instanceof HTMLElement;
        }
        catch(e){
            return (typeof obj==="object") &&
              (obj.nodeType===1) && (typeof obj.style === "object") &&
              (typeof obj.ownerDocument ==="object");
        }
    };

    /**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */
    Common.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    /**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */
    Common.isFunction = function(obj) {
        return typeof obj === "function";
    };

    /**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */
    Common.isPlainObject = function(obj) {
        return typeof obj === 'object' && obj.constructor === Object;
    };

    /**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */
    Common.isString = function(obj) {
        return toString.call(obj) === '[object String]';
    };
    
    /**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */
    Common.clamp = function(value, min, max) {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    };
    
    /**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */
    Common.sign = function(value) {
        return value < 0 ? -1 : 1;
    };
    
    /**
     * Returns the current timestamp (high-res if available).
     * @method now
     * @return {number} the current timestamp (high-res if available)
     */
    Common.now = function() {
        // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
        // https://gist.github.com/davidwaterston/2982531

        var performance = window.performance || {};

        performance.now = (function() {
            return performance.now    ||
            performance.webkitNow     ||
            performance.msNow         ||
            performance.oNow          ||
            performance.mozNow        ||
            function() { return +(new Date()); };
        })();
              
        return performance.now();
    };
    
    /**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */
    Common.random = function(min, max) {
        min = (typeof min !== "undefined") ? min : 0;
        max = (typeof max !== "undefined") ? max : 1;
        return min + _seededRandom() * (max - min);
    };

    var _seededRandom = function() {
        // https://gist.github.com/ngryman/3830489
        Common._seed = (Common._seed * 9301 + 49297) % 233280;
        return Common._seed / 233280;
    };

    /**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */
    Common.colorToNumber = function(colorString) {
        colorString = colorString.replace('#','');

        if (colorString.length == 3) {
            colorString = colorString.charAt(0) + colorString.charAt(0)
                        + colorString.charAt(1) + colorString.charAt(1)
                        + colorString.charAt(2) + colorString.charAt(2);
        }

        return parseInt(colorString, 16);
    };

    /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */
    Common.logLevel = 1;

    /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */
    Common.log = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */
    Common.info = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */
    Common.warn = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */
    Common.nextId = function() {
        return Common._nextId++;
    };

    /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */
    Common.indexOf = function(haystack, needle) {
        if (haystack.indexOf)
            return haystack.indexOf(needle);

        for (var i = 0; i < haystack.length; i++) {
            if (haystack[i] === needle)
                return i;
        }

        return -1;
    };

    /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */
    Common.map = function(list, func) {
        if (list.map) {
            return list.map(func);
        }

        var mapped = [];

        for (var i = 0; i < list.length; i += 1) {
            mapped.push(func(list[i]));
        }

        return mapped;
    };

    /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */
    Common.topologicalSort = function(graph) {
        // https://mgechev.github.io/javascript-algorithms/graphs_others_topological-sort.js.html
        var result = [],
            visited = [],
            temp = [];

        for (var node in graph) {
            if (!visited[node] && !temp[node]) {
                _topologicalSort(node, visited, temp, graph, result);
            }
        }

        return result;
    };

    var _topologicalSort = function(node, visited, temp, graph, result) {
        var neighbors = graph[node] || [];
        temp[node] = true;

        for (var i = 0; i < neighbors.length; i += 1) {
            var neighbor = neighbors[i];

            if (temp[neighbor]) {
                // skip circular dependencies
                continue;
            }

            if (!visited[neighbor]) {
                _topologicalSort(neighbor, visited, temp, graph, result);
            }
        }

        temp[node] = false;
        visited[node] = true;

        result.push(node);
    };

    /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */
    Common.chain = function() {
        var funcs = [];

        for (var i = 0; i < arguments.length; i += 1) {
            var func = arguments[i];

            if (func._chained) {
                // flatten already chained functions
                funcs.push.apply(funcs, func._chained);
            } else {
                funcs.push(func);
            }
        }

        var chain = function() {
            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
            var lastResult,
                args = new Array(arguments.length);

            for (var i = 0, l = arguments.length; i < l; i++) {
                args[i] = arguments[i];
            }

            for (i = 0; i < funcs.length; i += 1) {
                var result = funcs[i].apply(lastResult, args);

                if (typeof result !== 'undefined') {
                    lastResult = result;
                }
            }

            return lastResult;
        };

        chain._chained = funcs;

        return chain;
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathBefore = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            func,
            Common.get(base, path)
        ));
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathAfter = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            Common.get(base, path),
            func
        ));
    };

})();


/***/ }),
/* 3 */
/***/ (function(module, exports) {


/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            return this.getType(factory.KEY);
        }
        else
        {
            factories[factory.KEY] = {
                add: factory.add,
                make: factory.make
            };

            return factory;
        }
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Alpha: __webpack_require__(334),
    Animation: __webpack_require__(335),
    BlendMode: __webpack_require__(336),
    Children: __webpack_require__(337),
    Color: __webpack_require__(338),
    Data: __webpack_require__(104),
    Flip: __webpack_require__(339),
    GetBounds: __webpack_require__(340),
    Origin: __webpack_require__(341),
    RenderTarget: __webpack_require__(342),
    ScaleMode: __webpack_require__(343),
    ScrollFactor: __webpack_require__(344),
    Size: __webpack_require__(345),
    Texture: __webpack_require__(346),
    ToJSON: __webpack_require__(347),
    Transform: __webpack_require__(348),
    TransformMatrix: __webpack_require__(16),
    Visible: __webpack_require__(349)

};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var Event = function (type)
{
    this.type = type;

    //  The element that initiated the event.
    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,
    HEADLESS: 3

};

module.exports = CONST;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Class = __webpack_require__(1);
var Components = __webpack_require__(4);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
*
* @class
*/

var GameObject = new Class({

    initialize:

    function GameObject (state, type)
    {
        this.state = state;

        this.id = 0;
        this.type = type;
        this.name = '';
        this.tabIndex = -1;

        this.parent;

        //  0001 | 0010 | 0100 | 1000
        //  Will Render bitmask flags for the components Visible, Alpha, Transform and Texture respectively
        this.renderMask = 15;
        this.renderFlags = 15;
    },

    //  To be overridden by custom Game Objects
    preUpdate: function ()
    {
    },

    //  Can be overridden by custom Game Objects, but provides default export functionality
    toJSON: function ()
    {
        return Components.ToJSON(this);
    },

    destroy: function ()
    {
        this.parent.remove(this);

        this.state = undefined;
    }

});

module.exports = GameObject;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var Smoothing = __webpack_require__(64);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  Automatically apply smoothing(false) to created Canvas elements
var _disableContextSmoothing = false;

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    *
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        // console.log('CanvasPool.create', parent);

        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;

        if (_disableContextSmoothing && type === CONST.CANVAS)
        {
            Smoothing.disable(canvas.getContext('2d'));
        }
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    *
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    *
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    *
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    *
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    //  Disable context smoothing on any new Canvas element created
    var disableSmoothing = function ()
    {
        _disableContextSmoothing = true;
    };

    //  Enable context smoothing on any new Canvas element created
    var enableSmoothing = function ()
    {
        _disableContextSmoothing = false;
    };

    return {
        create2D: create2D,
        create: create,
        createWebGL: createWebGL,
        disableSmoothing: disableSmoothing,
        enableSmoothing: enableSmoothing,
        first: first,
        free: free,
        pool: pool,
        remove: remove,
        total: total
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ }),
/* 10 */
/***/ (function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/

var Bounds = {};

module.exports = Bounds;

(function() {

    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */
    Bounds.create = function(vertices) {
        var bounds = { 
            min: { x: 0, y: 0 }, 
            max: { x: 0, y: 0 }
        };

        if (vertices)
            Bounds.update(bounds, vertices);
        
        return bounds;
    };

    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */
    Bounds.update = function(bounds, vertices, velocity) {
        bounds.min.x = Infinity;
        bounds.max.x = -Infinity;
        bounds.min.y = Infinity;
        bounds.max.y = -Infinity;

        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
        }
        
        if (velocity) {
            if (velocity.x > 0) {
                bounds.max.x += velocity.x;
            } else {
                bounds.min.x += velocity.x;
            }
            
            if (velocity.y > 0) {
                bounds.max.y += velocity.y;
            } else {
                bounds.min.y += velocity.y;
            }
        }
    };

    /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */
    Bounds.contains = function(bounds, point) {
        return point.x >= bounds.min.x && point.x <= bounds.max.x 
               && point.y >= bounds.min.y && point.y <= bounds.max.y;
    };

    /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */
    Bounds.overlaps = function(boundsA, boundsB) {
        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x
                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);
    };

    /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */
    Bounds.translate = function(bounds, vector) {
        bounds.min.x += vector.x;
        bounds.max.x += vector.x;
        bounds.min.y += vector.y;
        bounds.max.y += vector.y;
    };

    /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */
    Bounds.shift = function(bounds, position) {
        var deltaX = bounds.max.x - bounds.min.x,
            deltaY = bounds.max.y - bounds.min.y;
            
        bounds.min.x = position.x;
        bounds.max.x = position.x + deltaX;
        bounds.min.y = position.y;
        bounds.max.y = position.y + deltaY;
    };
    
})();


/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/

// TODO: consider params for reusing vector objects

var Vector = {};

module.exports = Vector;

(function() {

    /**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */
    Vector.create = function(x, y) {
        return { x: x || 0, y: y || 0 };
    };

    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */
    Vector.clone = function(vector) {
        return { x: vector.x, y: vector.y };
    };

    /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */
    Vector.magnitude = function(vector) {
        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
    };

    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */
    Vector.magnitudeSquared = function(vector) {
        return (vector.x * vector.x) + (vector.y * vector.y);
    };

    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @return {vector} A new vector rotated about (0, 0)
     */
    Vector.rotate = function(vector, angle) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        return {
            x: vector.x * cos - vector.y * sin,
            y: vector.x * sin + vector.y * cos
        };
    };

    /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */
    Vector.rotateAbout = function(vector, angle, point, output) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        if (!output) output = {};
        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
        output.x = x;
        return output;
    };

    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */
    Vector.normalise = function(vector) {
        var magnitude = Vector.magnitude(vector);
        if (magnitude === 0)
            return { x: 0, y: 0 };
        return { x: vector.x / magnitude, y: vector.y / magnitude };
    };

    /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */
    Vector.dot = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
    };

    /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */
    Vector.cross = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
    };

    /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */
    Vector.cross3 = function(vectorA, vectorB, vectorC) {
        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    };

    /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */
    Vector.add = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x + vectorB.x;
        output.y = vectorA.y + vectorB.y;
        return output;
    };

    /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */
    Vector.sub = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x - vectorB.x;
        output.y = vectorA.y - vectorB.y;
        return output;
    };

    /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */
    Vector.mult = function(vector, scalar) {
        return { x: vector.x * scalar, y: vector.y * scalar };
    };

    /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */
    Vector.div = function(vector, scalar) {
        return { x: vector.x / scalar, y: vector.y / scalar };
    };

    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */
    Vector.perp = function(vector, negate) {
        negate = negate === true ? -1 : 1;
        return { x: negate * -vector.y, y: negate * vector.x };
    };

    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */
    Vector.neg = function(vector) {
        return { x: -vector.x, y: -vector.y };
    };

    /**
     * Returns the angle in radians between the two vectors relative to the x-axis.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */
    Vector.angle = function(vectorA, vectorB) {
        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    };

    /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */
    Vector._temp = [
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create()
    ];

})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var MATH = __webpack_require__(61);
var GetValue = __webpack_require__(0);

//  Allowed types:

//  Implicit
//  {
//      x: 4
//  }
//
//  From function
//  {
//      x: function ()
//  }
//
//  Randomly pick one element from the array
//  {
//      x: [a, b, c, d, e, f]
//  }
//
//  Random integer between min and max:
//  {
//      x: { randInt: [min, max] }
//  }
//
//  Random float between min and max:
//  {
//      x: { randFloat: [min, max] }
//  }

var GetAdvancedValue = function (source, key, defaultValue)
{
    var value = GetValue(source, key, null);

    if (value === null)
    {
        return defaultValue;
    }
    else if (Array.isArray(value))
    {
        return MATH.RND.pick(value);
    }
    else if (typeof value === 'object')
    {
        if (value.hasOwnProperty('randInt'))
        {
            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
        }
        else if (value.hasOwnProperty('randFloat'))
        {
            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
        }
    }
    else if (typeof value === 'function')
    {
        return value(key);
    }

    return value;
};

module.exports = GetAdvancedValue;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(387);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAcos = Math.acos;
var mathAtan = Math.atan;

var TransformMatrix = function (a, b, c, d, tx, ty) 
{
    a = typeof a === 'number' ? a : 1;
    b = typeof b === 'number' ? b : 0;
    c = typeof c === 'number' ? c : 0;
    d = typeof d === 'number' ? d : 1;
    tx = typeof tx === 'number' ? tx : 0;
    ty = typeof ty === 'number' ? ty : 0;

    this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);

    this.decomposedMatrix = {
        translateX: 0,
        translateY: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0
    };
};

TransformMatrix.prototype.loadIdentity = function ()
{
    var matrix = this.matrix;
    
    matrix[0] = 1;
    matrix[1] = 0;
    matrix[2] = 0;
    matrix[3] = 1;
    matrix[4] = 0;
    matrix[5] = 0;

    return this;
};

TransformMatrix.prototype.translate = function (x, y)
{
    var matrix = this.matrix;

    matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
    matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];

    return this;
};

TransformMatrix.prototype.scale = function (x, y)
{
    var matrix = this.matrix;

    matrix[0] = matrix[0] * x;
    matrix[1] = matrix[1] * x;
    matrix[2] = matrix[2] * y;
    matrix[3] = matrix[3] * y;

    return this;
};

TransformMatrix.prototype.rotate = function (radian)
{
    var radianSin = mathSin(radian);
    var radianCos = mathCos(radian);

    return this.transform(radianCos, -radianSin, radianSin, radianCos, 0, 0);
};

TransformMatrix.prototype.multiply = function (otherMatrix)
{
    var matrix = this.matrix;

    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];

    var a1 = otherMatrix[0];
    var b1 = otherMatrix[1];
    var c1 = otherMatrix[2];
    var d1 = otherMatrix[3];
    var tx1 = otherMatrix[4];
    var ty1 = otherMatrix[5];

    matrix[0] = a1 * a0 + b1 * c0;
    matrix[1] = a1 * b0 + b1 * d0;
    matrix[2] = c1 * a0 + d1 * c0;
    matrix[3] = c1 * b0 + d1 * d0;
    matrix[4] = tx1 * a0 + ty1 * c0 + tx0;
    matrix[5] = tx1 * b0 + ty1 * d0 + ty0;

    return this;
};

TransformMatrix.prototype.transform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;

    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];

    matrix[0] = a * a0 + b * c0;
    matrix[1] = a * b0 + b * d0;
    matrix[2] = c * a0 + d * c0;
    matrix[3] = c * b0 + d * d0;
    matrix[4] = tx * a0 + ty * c0 + tx0;
    matrix[5] = tx * b0 + ty * d0 + ty0;

    return this;
};

TransformMatrix.prototype.transformPoint = function (x, y, point)
{
    if (point === undefined) { point = { x: 0, y: 0 }; }

    var matrix = this.matrix;

    var a = matrix[0];
    var b = matrix[1];
    var c = matrix[2];
    var d = matrix[3];
    var tx = matrix[4];
    var ty = matrix[5];

    point.x = x * a + y * c + tx;
    point.y = x * b + y * d + ty;

    return point;
};

TransformMatrix.prototype.invert = function ()
{
    var matrix = this.matrix;

    var a = matrix[0];
    var b = matrix[1];
    var c = matrix[2];
    var d = matrix[3];
    var tx = matrix[4];
    var ty = matrix[5];

    var n = a * d - b * c;

    matrix[0] = d / n;
    matrix[1] = -b / n;
    matrix[2] = -c / n;
    matrix[3] = a / n;
    matrix[4] = (c * ty - d * tx) / n;
    matrix[5] = -(a * ty - b * tx) / n;

    return this;
};

TransformMatrix.prototype.setTransform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;

    matrix[0] = a;
    matrix[1] = b;
    matrix[2] = c;
    matrix[3] = d;
    matrix[4] = tx;
    matrix[5] = ty;

    return this;
};

TransformMatrix.prototype.decomposeMatrix = function ()
{
    var decomposedMatrix = this.decomposedMatrix;

    var matrix = this.matrix;

    var a = matrix[0];
    var b = matrix[1];
    var c = matrix[2];
    var d = matrix[3];

    var a2 = a * a;
    var b2 = b * b;
    var c2 = c * c;
    var d2 = d * d;

    var sx = mathSqrt(a2 + c2);
    var sy = mathSqrt(b2 + d2);

    decomposedMatrix.translateX = matrix[4];
    decomposedMatrix.translateY = matrix[5];

    decomposedMatrix.scaleX = sx;
    decomposedMatrix.scaleY = sy;

    decomposedMatrix.rotation = mathAcos(a / sx) * (mathAtan(-c / a) < 0 ? -1 : 1);

    return decomposedMatrix;
};

/* identity + translate + rotate + scale */
TransformMatrix.prototype.applyITRS = function (x, y, rotation, scaleX, scaleY)
{
    var matrix = this.matrix;

    var a = 1;
    var b = 0;
    var c = 0;
    var d = 1;
    var tx = 0;
    var ty = 0;

    var sr = mathSin(rotation);
    var cr = mathCos(rotation);

    // Translate
    matrix[4] = a * x + c * y + tx;
    matrix[5] = b * x + d * y + ty;

    // Rotate
    matrix[0] = cr * a + -sr * c;
    matrix[1] = cr * b + -sr * d;
    matrix[2] = sr * a + cr * c;
    matrix[3] = sr * b + cr * d;

    // Scale
    matrix[0] = matrix[0] * scaleX;
    matrix[1] = matrix[1] * scaleX;
    matrix[2] = matrix[2] * scaleY;
    matrix[3] = matrix[3] * scaleY;

    return this;
};

module.exports = TransformMatrix;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

var TWEEN_CONST = {

    //  TweenData:

    CREATED: 0,
    INIT: 1,
    DELAY: 2,
    PENDING_RENDER: 3,
    PLAYING_FORWARD: 4,
    PLAYING_BACKWARD: 5,
    HOLD_DELAY: 6,
    REPEAT_DELAY: 7,
    COMPLETE: 8,

    //  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)

    PENDING_ADD: 20,
    PAUSED: 21,
    LOOP_DELAY: 22,
    ACTIVE: 23,
    COMPLETE_DELAY: 24,
    PENDING_REMOVE: 25,
    REMOVED: 26

};

module.exports = TWEEN_CONST;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetBottom = function (gameObject)
{
    return (gameObject.y + gameObject.height) - (gameObject.height * gameObject.originY);
};

module.exports = GetBottom;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetLeft = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX);
};

module.exports = GetLeft;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetRight = function (gameObject)
{
    return (gameObject.x + gameObject.width) - (gameObject.width * gameObject.originX);
};

module.exports = GetRight;


/***/ }),
/* 21 */
/***/ (function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var GetTop = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY);
};

module.exports = GetTop;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetBottom = function (gameObject, value)
{
    gameObject.y = (value - gameObject.height) + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetBottom;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetLeft = function (gameObject, value)
{
    gameObject.x = value + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetLeft;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetRight = function (gameObject, value)
{
    gameObject.x = (value - gameObject.width) + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetRight;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var SetTop = function (gameObject, value)
{
    gameObject.y = value + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetTop;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(242)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  TOP
    getLineA: function ()
    {
        return { x1: this.x, y1: this.y, x2: this.right, y2: this.y };
    },

    //  RIGHT
    getLineB: function ()
    {
        return { x1: this.right, y1: this.y, x2: this.right, y2: this.bottom };
    },

    //  BOTTOM
    getLineC: function ()
    {
        return { x1: this.right, y1: this.bottom, x2: this.x, y2: this.bottom };
    },

    //  LEFT
    getLineD: function ()
    {
        return { x1: this.x, y1: this.bottom, x2: this.x, y2: this.y };
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    },

    centerX: {

        enumerable: true,

        get: function ()
        {
            return this.x + (this.width / 2);
        },

        set: function (value)
        {
            this.x = value - (this.width / 2);
        }

    },

    centerY: {

        enumerable: true,

        get: function ()
        {
            return this.y + (this.height / 2);
        },

        set: function (value)
        {
            this.y = value - (this.height / 2);
        }

    }

});

module.exports = Rectangle;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(628);
var CONST = __webpack_require__(10);
var XHRLoader = __webpack_require__(629);
var XHRSettings = __webpack_require__(83);
var MergeXHRSettings = __webpack_require__(173);

var File = function (type, key, url, responseType, xhrSettings, config)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  A config object that can be used by file types to store transitional data
    this.config = config || {};

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/

var Composite = {};

module.exports = Composite;

var Events = __webpack_require__(30);
var Common = __webpack_require__(2);
var Body = __webpack_require__(46);

(function() {

    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */
    Composite.create = function(options) {
        return Common.extend({ 
            id: Common.nextId(),
            type: 'composite',
            parent: null,
            isModified: false,
            bodies: [], 
            constraints: [], 
            composites: [],
            label: 'Composite',
            plugin: {}
        }, options);
    };

    /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */
    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
        composite.isModified = isModified;

        if (updateParents && composite.parent) {
            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
        }

        if (updateChildren) {
            for(var i = 0; i < composite.composites.length; i++) {
                var childComposite = composite.composites[i];
                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
            }
        }
    };

    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */
    Composite.add = function(composite, object) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeAdd', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                // skip adding compound parts
                if (obj.parent !== obj) {
                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');
                    break;
                }

                Composite.addBody(composite, obj);
                break;
            case 'constraint':
                Composite.addConstraint(composite, obj);
                break;
            case 'composite':
                Composite.addComposite(composite, obj);
                break;
            case 'mouseConstraint':
                Composite.addConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterAdd', { object: object });

        return composite;
    };

    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */
    Composite.remove = function(composite, object, deep) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeRemove', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                Composite.removeBody(composite, obj, deep);
                break;
            case 'constraint':
                Composite.removeConstraint(composite, obj, deep);
                break;
            case 'composite':
                Composite.removeComposite(composite, obj, deep);
                break;
            case 'mouseConstraint':
                Composite.removeConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterRemove', { object: object });

        return composite;
    };

    /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */
    Composite.addComposite = function(compositeA, compositeB) {
        compositeA.composites.push(compositeB);
        compositeB.parent = compositeA;
        Composite.setModified(compositeA, true, true, false);
        return compositeA;
    };

    /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */
    Composite.removeComposite = function(compositeA, compositeB, deep) {
        var position = Common.indexOf(compositeA.composites, compositeB);
        if (position !== -1) {
            Composite.removeCompositeAt(compositeA, position);
            Composite.setModified(compositeA, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < compositeA.composites.length; i++){
                Composite.removeComposite(compositeA.composites[i], compositeB, true);
            }
        }

        return compositeA;
    };

    /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */
    Composite.removeCompositeAt = function(composite, position) {
        composite.composites.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */
    Composite.addBody = function(composite, body) {
        composite.bodies.push(body);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBody = function(composite, body, deep) {
        var position = Common.indexOf(composite.bodies, body);
        if (position !== -1) {
            Composite.removeBodyAt(composite, position);
            Composite.setModified(composite, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeBody(composite.composites[i], body, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBodyAt = function(composite, position) {
        composite.bodies.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */
    Composite.addConstraint = function(composite, constraint) {
        composite.constraints.push(constraint);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraint = function(composite, constraint, deep) {
        var position = Common.indexOf(composite.constraints, constraint);
        if (position !== -1) {
            Composite.removeConstraintAt(composite, position);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeConstraint(composite.composites[i], constraint, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraintAt = function(composite, position) {
        composite.constraints.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */
    Composite.clear = function(composite, keepStatic, deep) {
        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.clear(composite.composites[i], keepStatic, true);
            }
        }
        
        if (keepStatic) {
            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });
        } else {
            composite.bodies.length = 0;
        }

        composite.constraints.length = 0;
        composite.composites.length = 0;
        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */
    Composite.allBodies = function(composite) {
        var bodies = [].concat(composite.bodies);

        for (var i = 0; i < composite.composites.length; i++)
            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));

        return bodies;
    };

    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */
    Composite.allConstraints = function(composite) {
        var constraints = [].concat(composite.constraints);

        for (var i = 0; i < composite.composites.length; i++)
            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));

        return constraints;
    };

    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */
    Composite.allComposites = function(composite) {
        var composites = [].concat(composite.composites);

        for (var i = 0; i < composite.composites.length; i++)
            composites = composites.concat(Composite.allComposites(composite.composites[i]));

        return composites;
    };

    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */
    Composite.get = function(composite, id, type) {
        var objects,
            object;

        switch (type) {
        case 'body':
            objects = Composite.allBodies(composite);
            break;
        case 'constraint':
            objects = Composite.allConstraints(composite);
            break;
        case 'composite':
            objects = Composite.allComposites(composite).concat(composite);
            break;
        }

        if (!objects)
            return null;

        object = objects.filter(function(object) { 
            return object.id.toString() === id.toString(); 
        });

        return object.length === 0 ? null : object[0];
    };

    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */
    Composite.move = function(compositeA, objects, compositeB) {
        Composite.remove(compositeA, objects);
        Composite.add(compositeB, objects);
        return compositeA;
    };

    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */
    Composite.rebase = function(composite) {
        var objects = Composite.allBodies(composite)
                        .concat(Composite.allConstraints(composite))
                        .concat(Composite.allComposites(composite));

        for (var i = 0; i < objects.length; i++) {
            objects[i].id = Common.nextId();
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */
    Composite.translate = function(composite, translation, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            Body.translate(bodies[i], translation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.rotate = function(composite, rotation, point, recursive) {
        var cos = Math.cos(rotation),
            sin = Math.sin(rotation),
            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
            });

            Body.rotate(body, rotation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + dx * scaleX,
                y: point.y + dy * scaleY
            });

            Body.scale(body, scaleX, scaleY);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a call to `Composite.add` is made, before objects have been added.
    *
    * @event beforeAdd
    * @param {} event An event object
    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.add` is made, after objects have been added.
    *
    * @event afterAdd
    * @param {} event An event object
    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, before objects have been removed.
    *
    * @event beforeRemove
    * @param {} event An event object
    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, after objects have been removed.
    *
    * @event afterRemove
    * @param {} event An event object
    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "composite"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage composites.
     *
     * @property label
     * @type string
     * @default "Composite"
     */

    /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
     * If you need to change it manually, you should use the `Composite.setModified` method.
     *
     * @property isModified
     * @type boolean
     * @default false
     */

    /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     *
     * @property parent
     * @type composite
     * @default null
     */

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     *
     * @property bodies
     * @type body[]
     * @default []
     */

    /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     *
     * @property constraints
     * @type constraint[]
     * @default []
     */

    /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     *
     * @property composites
     * @type composite[]
     * @default []
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/

var Events = {};

module.exports = Events;

var Common = __webpack_require__(2);

(function() {

    /**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.on = function(object, eventNames, callback) {
        var names = eventNames.split(' '),
            name;

        for (var i = 0; i < names.length; i++) {
            name = names[i];
            object.events = object.events || {};
            object.events[name] = object.events[name] || [];
            object.events[name].push(callback);
        }

        return callback;
    };

    /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.off = function(object, eventNames, callback) {
        if (!eventNames) {
            object.events = {};
            return;
        }

        // handle Events.off(object, callback)
        if (typeof eventNames === 'function') {
            callback = eventNames;
            eventNames = Common.keys(object.events).join(' ');
        }

        var names = eventNames.split(' ');

        for (var i = 0; i < names.length; i++) {
            var callbacks = object.events[names[i]],
                newCallbacks = [];

            if (callback && callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                }
            }

            object.events[names[i]] = newCallbacks;
        }
    };

    /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */
    Events.trigger = function(object, eventNames, event) {
        var names,
            name,
            callbacks,
            eventClone;

        if (object.events) {
            if (!event)
                event = {};

            names = eventNames.split(' ');

            for (var i = 0; i < names.length; i++) {
                name = names[i];
                callbacks = object.events[name];

                if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;

                    for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                    }
                }
            }
        }
    };

})();


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/

var Vertices = {};

module.exports = Vertices;

var Vector = __webpack_require__(13);
var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */
    Vertices.create = function(points, body) {
        var vertices = [];

        for (var i = 0; i < points.length; i++) {
            var point = points[i],
                vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body: body,
                    isInternal: false
                };

            vertices.push(vertex);
        }

        return vertices;
    };

    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */
    Vertices.fromPath = function(path, body) {
        var pathPattern = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,
            points = [];

        path.replace(pathPattern, function(match, x, y) {
            points.push({ x: parseFloat(x), y: parseFloat(y) });
        });

        return Vertices.create(points, body);
    };

    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */
    Vertices.centre = function(vertices) {
        var area = Vertices.area(vertices, true),
            centre = { x: 0, y: 0 },
            cross,
            temp,
            j;

        for (var i = 0; i < vertices.length; i++) {
            j = (i + 1) % vertices.length;
            cross = Vector.cross(vertices[i], vertices[j]);
            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
            centre = Vector.add(centre, temp);
        }

        return Vector.div(centre, 6 * area);
    };

    /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */
    Vertices.mean = function(vertices) {
        var average = { x: 0, y: 0 };

        for (var i = 0; i < vertices.length; i++) {
            average.x += vertices[i].x;
            average.y += vertices[i].y;
        }

        return Vector.div(average, vertices.length);
    };

    /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */
    Vertices.area = function(vertices, signed) {
        var area = 0,
            j = vertices.length - 1;

        for (var i = 0; i < vertices.length; i++) {
            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
            j = i;
        }

        if (signed)
            return area / 2;

        return Math.abs(area) / 2;
    };

    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */
    Vertices.inertia = function(vertices, mass) {
        var numerator = 0,
            denominator = 0,
            v = vertices,
            cross,
            j;

        // find the polygon's moment of inertia, using second moment of area
        // http://www.physicsforums.com/showthread.php?t=25293
        for (var n = 0; n < v.length; n++) {
            j = (n + 1) % v.length;
            cross = Math.abs(Vector.cross(v[j], v[n]));
            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
            denominator += cross;
        }

        return (mass / 6) * (numerator / denominator);
    };

    /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */
    Vertices.translate = function(vertices, vector, scalar) {
        var i;
        if (scalar) {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x * scalar;
                vertices[i].y += vector.y * scalar;
            }
        } else {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x;
                vertices[i].y += vector.y;
            }
        }

        return vertices;
    };

    /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */
    Vertices.rotate = function(vertices, angle, point) {
        if (angle === 0)
            return;

        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                dx = vertice.x - point.x,
                dy = vertice.y - point.y;
                
            vertice.x = point.x + (dx * cos - dy * sin);
            vertice.y = point.y + (dx * sin + dy * cos);
        }

        return vertices;
    };

    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */
    Vertices.contains = function(vertices, point) {
        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                nextVertice = vertices[(i + 1) % vertices.length];
            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                return false;
            }
        }

        return true;
    };

    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */
    Vertices.scale = function(vertices, scaleX, scaleY, point) {
        if (scaleX === 1 && scaleY === 1)
            return vertices;

        point = point || Vertices.centre(vertices);

        var vertex,
            delta;

        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            delta = Vector.sub(vertex, point);
            vertices[i].x = point.x + delta.x * scaleX;
            vertices[i].y = point.y + delta.y * scaleY;
        }

        return vertices;
    };

    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */
    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
        radius = radius || [8];

        if (!radius.length)
            radius = [radius];

        // quality defaults to -1, which is auto
        quality = (typeof quality !== 'undefined') ? quality : -1;
        qualityMin = qualityMin || 2;
        qualityMax = qualityMax || 14;

        var newVertices = [];

        for (var i = 0; i < vertices.length; i++) {
            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],
                vertex = vertices[i],
                nextVertex = vertices[(i + 1) % vertices.length],
                currentRadius = radius[i < radius.length ? i : radius.length - 1];

            if (currentRadius === 0) {
                newVertices.push(vertex);
                continue;
            }

            var prevNormal = Vector.normalise({ 
                x: vertex.y - prevVertex.y, 
                y: prevVertex.x - vertex.x
            });

            var nextNormal = Vector.normalise({ 
                x: nextVertex.y - vertex.y, 
                y: vertex.x - nextVertex.x
            });

            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),
                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),
                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),
                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));

            var precision = quality;

            if (quality === -1) {
                // automatically decide precision
                precision = Math.pow(currentRadius, 0.32) * 1.75;
            }

            precision = Common.clamp(precision, qualityMin, qualityMax);

            // use an even value for precision, more likely to reduce axes by using symmetry
            if (precision % 2 === 1)
                precision += 1;

            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),
                theta = alpha / precision;

            for (var j = 0; j < precision; j++) {
                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
            }
        }

        return newVertices;
    };

    /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */
    Vertices.clockwiseSort = function(vertices) {
        var centre = Vertices.mean(vertices);

        vertices.sort(function(vertexA, vertexB) {
            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
        });

        return vertices;
    };

    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */
    Vertices.isConvex = function(vertices) {
        // http://paulbourke.net/geometry/polygonmesh/

        var flag = 0,
            n = vertices.length,
            i,
            j,
            k,
            z;

        if (n < 3)
            return null;

        for (i = 0; i < n; i++) {
            j = (i + 1) % n;
            k = (i + 2) % n;
            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);

            if (z < 0) {
                flag |= 1;
            } else if (z > 0) {
                flag |= 2;
            }

            if (flag === 3) {
                return false;
            }
        }

        if (flag !== 0){
            return true;
        } else {
            return null;
        }
    };

    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */
    Vertices.hull = function(vertices) {
        // http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain

        var upper = [],
            lower = [], 
            vertex,
            i;

        // sort vertices on x-axis (y-axis for ties)
        vertices = vertices.slice(0);
        vertices.sort(function(vertexA, vertexB) {
            var dx = vertexA.x - vertexB.x;
            return dx !== 0 ? dx : vertexA.y - vertexB.y;
        });

        // build lower hull
        for (i = 0; i < vertices.length; i++) {
            vertex = vertices[i];

            while (lower.length >= 2 
                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                lower.pop();
            }

            lower.push(vertex);
        }

        // build upper hull
        for (i = vertices.length - 1; i >= 0; i--) {
            vertex = vertices[i];

            while (upper.length >= 2 
                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                upper.pop();
            }

            upper.push(vertex);
        }

        // concatenation of the lower and upper hulls gives the convex hull
        // omit last points because they are repeated at the beginning of the other list
        upper.pop();
        lower.pop();

        return upper.concat(lower);
    };

})();


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var GetAdvancedValue = __webpack_require__(14);
var ScaleModes = __webpack_require__(38);
var BlendModes = __webpack_require__(59);

var BuildGameObject = function (state, gameObject, config)
{
    //  Position

    gameObject.x = GetAdvancedValue(config, 'x', 0);
    gameObject.y = GetAdvancedValue(config, 'y', 0);
    gameObject.z = GetAdvancedValue(config, 'z', 0);

    //  Flip

    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);
    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);

    //  Scale
    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}

    var scale = GetAdvancedValue(config, 'scale', null);

    if (typeof scale === 'number')
    {
        gameObject.setScale(scale);
    }
    else if (scale !== null)
    {
        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);
        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);
    }

    //  ScrollFactor
    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}

    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);

    if (typeof scrollFactor === 'number')
    {
        gameObject.setScrollFactor(scrollFactor);
    }
    else if (scrollFactor !== null)
    {
        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);
        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);
    }

    //  Rotation

    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);

    var angle = GetAdvancedValue(config, 'angle', null);

    if (angle !== null)
    {
        gameObject.angle = angle;
    }

    //  Alpha

    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);

    //  Origin
    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}

    var origin = GetAdvancedValue(config, 'origin', null);

    if (typeof origin === 'number')
    {
        gameObject.setOrigin(origin);
    }
    else if (origin !== null)
    {
        var ox = GetAdvancedValue(config, 'x', 0.5);
        var oy = GetAdvancedValue(config, 'y', 0.5);

        gameObject.setOrigin(ox, oy);
    }

    //  ScaleMode

    gameObject.scaleMode = GetAdvancedValue(config, 'scaleMode', ScaleModes.DEFAULT);

    //  BlendMode

    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);

    //  Visible

    gameObject.visible = GetAdvancedValue(config, 'visible', true);

    //  Add to State

    var add = GetAdvancedValue(config, 'add', true);

    if (add)
    {
        state.children.add(gameObject);
    }

    return gameObject;
};

module.exports = BuildGameObject;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

var DataBuffer32 = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

DataBuffer32.prototype.clear = function ()
{
    this.dwordLength = 0;
};

DataBuffer32.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

DataBuffer32.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

DataBuffer32.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

DataBuffer32.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

DataBuffer32.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

DataBuffer32.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = DataBuffer32;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    ADD_ANIMATION_EVENT: __webpack_require__(316),
    PAUSE_ALL_ANIMATION_EVENT: __webpack_require__(317),
    REMOVE_ANIMATION_EVENT: __webpack_require__(318),
    RESUME_ALL_ANIMATION_EVENT: __webpack_require__(319)
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(81);
var GetColor32 = __webpack_require__(160);

var Color = function (red, green, blue, alpha)
{
    if (red === undefined) { red = 0; }
    if (green === undefined) { green = 0; }
    if (blue === undefined) { blue = 0; }
    if (alpha === undefined) { alpha = 255; }

    //  All private
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 255;

    this.gl = [ 0.0, 0.0, 0.0, 1.0 ];

    this._color = 0;
    this._color32 = 0;
    this._rgba = '';

    this.dirty = true;

    this.setTo(red, green, blue, alpha);
};

Color.prototype.constructor = Color;

Color.prototype = {

    transparent: function ()
    {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 255
    setTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 255; }

        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 1
    setGLTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.redGL = red;
        this.greenGL = green;
        this.blueGL = blue;
        this.alphaGL = alpha;

        this.dirty = true;

        return this.update();
    },

    setFromRGB: function (color)
    {
        this.red = color.r;
        this.green = color.g;
        this.blue = color.b;

        if (color.hasOwnProperty('a'))
        {
            this.alpha = color.a;
        }

        this.dirty = true;

        return this.update();
    },

    update: function ()
    {
        if (!this.dirty)
        {
            return this;
        }

        this._color = GetColor(this.r, this.g, this.b);
        this._color32 = GetColor32(this.r, this.g, this.b, this.a);
        this._rgba = 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + (255 / this.a) + ')';

        this.dirty = false;

        return this;
    },

    //  Same as setRGB but performs safety checks on all the values given
    clone: function ()
    {
        return new Color(this.r, this.g, this.b, this.a);
    }

};

Object.defineProperties(Color.prototype, {

    color: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color;
        }

    },

    color32: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color32;
        }

    },

    rgba: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._rgba;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 1 range
    redGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[0];
        },

        set: function (value)
        {
            this.gl[0] = Math.min(Math.abs(value), 1);

            this.r = Math.floor(this.gl[0] * 255);

            this.dirty = true;
        }

    },

    greenGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[1];
        },

        set: function (value)
        {
            this.gl[1] = Math.min(Math.abs(value), 1);

            this.g = Math.floor(this.gl[1] * 255);

            this.dirty = true;
        }

    },

    blueGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[2];
        },

        set: function (value)
        {
            this.gl[2] = Math.min(Math.abs(value), 1);

            this.b = Math.floor(this.gl[2] * 255);

            this.dirty = true;
        }

    },

    alphaGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[3];
        },

        set: function (value)
        {
            this.gl[3] = Math.min(Math.abs(value), 1);

            this.a = Math.floor(this.gl[3] * 255);

            this.dirty = true;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 255 range
    red: {

        enumerable: true,

        get: function ()
        {
            return this.r;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.r = Math.min(value, 255);

            this.gl[0] = value / 255;

            this.dirty = true;
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this.g;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.g = Math.min(value, 255);

            this.gl[1] = value / 255;

            this.dirty = true;
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this.b;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.b = Math.min(value, 255);

            this.gl[2] = value / 255;

            this.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.a;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.a = Math.min(value, 255);

            this.gl[3] = value / 255;

            this.dirty = true;
        }

    },

});


module.exports = Color;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

var DataBuffer16 = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.intView = new Int16Array(this.buffer);
    this.uintView = new Uint16Array(this.buffer);
};

DataBuffer16.prototype.clear = function ()
{
    this.wordLength = 0;
};

DataBuffer16.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

DataBuffer16.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

DataBuffer16.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

DataBuffer16.prototype.getUsedBufferAsShort = function ()
{
    return this.intView.subarray(0, this.wordLength);
};

DataBuffer16.prototype.getUsedBufferAsWord = function ()
{
    return this.uintView.subarray(0, this.wordLength);
};

module.exports = DataBuffer16;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterX = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX) + (gameObject.width * 0.5);
};

module.exports = GetCenterX;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterY = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY) + (gameObject.height * 0.5);
};

module.exports = GetCenterY;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterX = function (gameObject, x)
{
    var offsetX = gameObject.width * gameObject.originX;

    gameObject.x = (x + offsetX) - (gameObject.width * 0.5);

    return gameObject;
};

module.exports = SetCenterX;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterY = function (gameObject, y)
{
    var offsetY = gameObject.height * gameObject.originY;

    gameObject.y = (y + offsetY) - (gameObject.height * 0.5);

    return gameObject;
};

module.exports = SetCenterY;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var ImageFile = function (key, url, path, xhrSettings, config)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings, config);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

// A triangle is a plane created by connecting three points.
// The first two arguments specify the first point, the middle two arguments
// specify the second point, and the last two arguments specify the third point.

var Triangle = function (x1, y1, x2, y2, x3, y3)
{
    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;

    this.setTo(x1, y1, x2, y2, x3, y3);
};

Triangle.prototype.constructor = Triangle;

Triangle.prototype = {

    setTo: function (x1, y1, x2, y2, x3, y3)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }
        if (x3 === undefined) { x3 = 0; }
        if (y3 === undefined) { y3 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        this.x3 = x3;
        this.y3 = y3;

        return this;
    },

    getLineA: function ()
    {
        return { x1: this.x1, y1: this.y1, x2: this.x2, y2: this.y2 };
    },

    getLineB: function ()
    {
        return { x1: this.x2, y1: this.y2, x2: this.x3, y2: this.y3 };
    },

    getLineC: function ()
    {
        return { x1: this.x3, y1: this.y3, x2: this.x1, y2: this.y1 };
    }

};

Object.defineProperties(Triangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 <= this.x2 && this.x1 <= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 <= this.x1 && this.x2 <= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 >= this.x2 && this.x1 >= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 >= this.x1 && this.x2 >= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 <= this.y2 && this.y1 <= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 <= this.y1 && this.y2 <= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 >= this.y2 && this.y1 >= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 >= this.y1 && this.y2 >= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    }

});

module.exports = Triangle;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/

var Body = {};

module.exports = Body;

var Vertices = __webpack_require__(31);
var Vector = __webpack_require__(13);
var Sleeping = __webpack_require__(48);
var Render = __webpack_require__(95);
var Common = __webpack_require__(2);
var Bounds = __webpack_require__(12);
var Axes = __webpack_require__(94);

(function() {

    Body._inertiaScale = 4;
    Body._nextCollidingGroupId = 1;
    Body._nextNonCollidingGroupId = -1;
    Body._nextCategory = 0x0001;

    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */
    Body.create = function(options) {
        var defaults = {
            id: Common.nextId(),
            type: 'body',
            label: 'Body',
            parts: [],
            plugin: {},
            angle: 0,
            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
            position: { x: 0, y: 0 },
            force: { x: 0, y: 0 },
            torque: 0,
            positionImpulse: { x: 0, y: 0 },
            constraintImpulse: { x: 0, y: 0, angle: 0 },
            totalContacts: 0,
            speed: 0,
            angularSpeed: 0,
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            isSensor: false,
            isStatic: false,
            isSleeping: false,
            motion: 0,
            sleepThreshold: 60,
            density: 0.001,
            restitution: 0,
            friction: 0.1,
            frictionStatic: 0.5,
            frictionAir: 0.01,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            },
            slop: 0.05,
            timeScale: 1,
            render: {
                visible: true,
                opacity: 1,
                sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                },
                lineWidth: 0
            }
        };

        var body = Common.extend(defaults, options);

        _initProperties(body, options);

        return body;
    };

    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */
    Body.nextGroup = function(isNonColliding) {
        if (isNonColliding)
            return Body._nextNonCollidingGroupId--;

        return Body._nextCollidingGroupId++;
    };

    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */
    Body.nextCategory = function() {
        Body._nextCategory = Body._nextCategory << 1;
        return Body._nextCategory;
    };

    /**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */
    var _initProperties = function(body, options) {
        options = options || {};

        // init required properties (order is important)
        Body.set(body, {
            bounds: body.bounds || Bounds.create(body.vertices),
            positionPrev: body.positionPrev || Vector.clone(body.position),
            anglePrev: body.anglePrev || body.angle,
            vertices: body.vertices,
            parts: body.parts || [body],
            isStatic: body.isStatic,
            isSleeping: body.isSleeping,
            parent: body.parent || body
        });

        Vertices.rotate(body.vertices, body.angle, body.position);
        Axes.rotate(body.axes, body.angle);
        Bounds.update(body.bounds, body.vertices, body.velocity);

        // allow options to override the automatically calculated properties
        Body.set(body, {
            axes: options.axes || body.axes,
            area: options.area || body.area,
            mass: options.mass || body.mass,
            inertia: options.inertia || body.inertia
        });

        // render properties
        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),
            defaultStrokeStyle = Common.shadeColor(defaultFillStyle, -20);
        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
    };

    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */
    Body.set = function(body, settings, value) {
        var property;

        if (typeof settings === 'string') {
            property = settings;
            settings = {};
            settings[property] = value;
        }

        for (property in settings) {
            value = settings[property];

            if (!settings.hasOwnProperty(property))
                continue;

            switch (property) {

            case 'isStatic':
                Body.setStatic(body, value);
                break;
            case 'isSleeping':
                Sleeping.set(body, value);
                break;
            case 'mass':
                Body.setMass(body, value);
                break;
            case 'density':
                Body.setDensity(body, value);
                break;
            case 'inertia':
                Body.setInertia(body, value);
                break;
            case 'vertices':
                Body.setVertices(body, value);
                break;
            case 'position':
                Body.setPosition(body, value);
                break;
            case 'angle':
                Body.setAngle(body, value);
                break;
            case 'velocity':
                Body.setVelocity(body, value);
                break;
            case 'angularVelocity':
                Body.setAngularVelocity(body, value);
                break;
            case 'parts':
                Body.setParts(body, value);
                break;
            default:
                body[property] = value;

            }
        }
    };

    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */
    Body.setStatic = function(body, isStatic) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.isStatic = isStatic;

            if (isStatic) {
                part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                };

                part.restitution = 0;
                part.friction = 1;
                part.mass = part.inertia = part.density = Infinity;
                part.inverseMass = part.inverseInertia = 0;

                part.positionPrev.x = part.position.x;
                part.positionPrev.y = part.position.y;
                part.anglePrev = part.angle;
                part.angularVelocity = 0;
                part.speed = 0;
                part.angularSpeed = 0;
                part.motion = 0;
            } else if (part._original) {
                part.restitution = part._original.restitution;
                part.friction = part._original.friction;
                part.mass = part._original.mass;
                part.inertia = part._original.inertia;
                part.density = part._original.density;
                part.inverseMass = part._original.inverseMass;
                part.inverseInertia = part._original.inverseInertia;

                delete part._original;
            }
        }
    };

    /**
     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */
    Body.setMass = function(body, mass) {
        body.mass = mass;
        body.inverseMass = 1 / body.mass;
        body.density = body.mass / body.area;
    };

    /**
     * Sets the density of the body. Mass is automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */
    Body.setDensity = function(body, density) {
        Body.setMass(body, density * body.area);
        body.density = density;
    };

    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */
    Body.setInertia = function(body, inertia) {
        body.inertia = inertia;
        body.inverseInertia = 1 / body.inertia;
    };

    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */
    Body.setVertices = function(body, vertices) {
        // change vertices
        if (vertices[0].body === body) {
            body.vertices = vertices;
        } else {
            body.vertices = Vertices.create(vertices, body);
        }

        // update properties
        body.axes = Axes.fromVertices(body.vertices);
        body.area = Vertices.area(body.vertices);
        Body.setMass(body, body.density * body.area);

        // orient vertices around the centre of mass at origin (0, 0)
        var centre = Vertices.centre(body.vertices);
        Vertices.translate(body.vertices, centre, -1);

        // update inertia while vertices are at origin (0, 0)
        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));

        // update geometry
        Vertices.translate(body.vertices, body.position);
        Bounds.update(body.bounds, body.vertices, body.velocity);
    };

    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */
    Body.setParts = function(body, parts, autoHull) {
        var i;

        // add all the parts, ensuring that the first part is always the parent body
        parts = parts.slice(0);
        body.parts.length = 0;
        body.parts.push(body);
        body.parent = body;

        for (i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== body) {
                part.parent = body;
                body.parts.push(part);
            }
        }

        if (body.parts.length === 1)
            return;

        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;

        // find the convex hull of all parts to set on the parent body
        if (autoHull) {
            var vertices = [];
            for (i = 0; i < parts.length; i++) {
                vertices = vertices.concat(parts[i].vertices);
            }

            Vertices.clockwiseSort(vertices);

            var hull = Vertices.hull(vertices),
                hullCentre = Vertices.centre(hull);

            Body.setVertices(body, hull);
            Vertices.translate(body.vertices, hullCentre);
        }

        // sum the properties of all compound parts of the parent body
        var total = _totalProperties(body);

        body.area = total.area;
        body.parent = body;
        body.position.x = total.centre.x;
        body.position.y = total.centre.y;
        body.positionPrev.x = total.centre.x;
        body.positionPrev.y = total.centre.y;

        Body.setMass(body, total.mass);
        Body.setInertia(body, total.inertia);
        Body.setPosition(body, total.centre);
    };

    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */
    Body.setPosition = function(body, position) {
        var delta = Vector.sub(position, body.position);
        body.positionPrev.x += delta.x;
        body.positionPrev.y += delta.y;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.position.x += delta.x;
            part.position.y += delta.y;
            Vertices.translate(part.vertices, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */
    Body.setAngle = function(body, angle) {
        var delta = angle - body.angle;
        body.anglePrev += delta;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.angle += delta;
            Vertices.rotate(part.vertices, delta, body.position);
            Axes.rotate(part.axes, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
            if (i > 0) {
                Vector.rotateAbout(part.position, delta, body.position, part.position);
            }
        }
    };

    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */
    Body.setVelocity = function(body, velocity) {
        body.positionPrev.x = body.position.x - velocity.x;
        body.positionPrev.y = body.position.y - velocity.y;
        body.velocity.x = velocity.x;
        body.velocity.y = velocity.y;
        body.speed = Vector.magnitude(body.velocity);
    };

    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */
    Body.setAngularVelocity = function(body, velocity) {
        body.anglePrev = body.angle - velocity;
        body.angularVelocity = velocity;
        body.angularSpeed = Math.abs(body.angularVelocity);
    };

    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */
    Body.translate = function(body, translation) {
        Body.setPosition(body, Vector.add(body.position, translation));
    };

    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     */
    Body.rotate = function(body, rotation) {
        Body.setAngle(body, body.angle + rotation);
    };

    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */
    Body.scale = function(body, scaleX, scaleY, point) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            // scale vertices
            Vertices.scale(part.vertices, scaleX, scaleY, body.position);

            // update properties
            part.axes = Axes.fromVertices(part.vertices);

            if (!body.isStatic) {
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);

                // update inertia (requires vertices to be at origin)
                Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
                Body.setInertia(part, Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });
            }

            // update bounds
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }

        // handle circles
        if (body.circleRadius) { 
            if (scaleX === scaleY) {
                body.circleRadius *= scaleX;
            } else {
                // body is no longer a circle
                body.circleRadius = null;
            }
        }

        if (!body.isStatic) {
            var total = _totalProperties(body);
            body.area = total.area;
            Body.setMass(body, total.mass);
            Body.setInertia(body, total.inertia);
        }
    };

    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */
    Body.update = function(body, deltaTime, timeScale, correction) {
        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);

        // from the previous step
        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,
            velocityPrevX = body.position.x - body.positionPrev.x,
            velocityPrevY = body.position.y - body.positionPrev.y;

        // update velocity with Verlet integration
        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;
        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;

        body.positionPrev.x = body.position.x;
        body.positionPrev.y = body.position.y;
        body.position.x += body.velocity.x;
        body.position.y += body.velocity.y;

        // update angular velocity with Verlet integration
        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;
        body.anglePrev = body.angle;
        body.angle += body.angularVelocity;

        // track speed and acceleration
        body.speed = Vector.magnitude(body.velocity);
        body.angularSpeed = Math.abs(body.angularVelocity);

        // transform the body geometry
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            Vertices.translate(part.vertices, body.velocity);
            
            if (i > 0) {
                part.position.x += body.velocity.x;
                part.position.y += body.velocity.y;
            }

            if (body.angularVelocity !== 0) {
                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                Axes.rotate(part.axes, body.angularVelocity);
                if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                }
            }

            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */
    Body.applyForce = function(body, position, force) {
        body.force.x += force.x;
        body.force.y += force.y;
        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
        body.torque += offset.x * force.y - offset.y * force.x;
    };

    /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */
    var _totalProperties = function(body) {
        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
        // http://output.to/sideway/default.asp?qno=121100087

        var properties = {
            mass: 0,
            area: 0,
            inertia: 0,
            centre: { x: 0, y: 0 }
        };

        // sum the properties of all compound parts of the parent body
        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
            var part = body.parts[i];
            properties.mass += part.mass;
            properties.area += part.area;
            properties.inertia += part.inertia;
            properties.centre = Vector.add(properties.centre, 
                                           Vector.mult(part.position, part.mass !== Infinity ? part.mass : 1));
        }

        properties.centre = Vector.div(properties.centre, 
                                       properties.mass !== Infinity ? properties.mass : body.parts.length);

        return properties;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a body starts sleeping (where `this` is the body).
    *
    * @event sleepStart
    * @this {body} The body that has started sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a body ends sleeping (where `this` is the body).
    *
    * @event sleepEnd
    * @this {body} The body that has ended sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "body"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Body"
     */

    /**
     * An array of bodies that make up this body. 
     * The first body in the array must always be a self reference to the current body instance.
     * All bodies in the `parts` array together form a single rigid compound body.
     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
     * Parts themselves should never be added to a `World`, only the parent body should be.
     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     *
     * @property parts
     * @type body[]
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

    /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
     * See `body.parts`.
     *
     * @property parent
     * @type body
     */

    /**
     * A `Number` specifying the angle of the body, in radians.
     *
     * @property angle
     * @type number
     * @default 0
     */

    /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
     *
     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     *
     * @property vertices
     * @type vector[]
     */

    /**
     * A `Vector` that specifies the current world-space position of the body.
     *
     * @property position
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     *
     * @property force
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     *
     * @property torque
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     *
     * @readOnly
     * @property speed
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     *
     * @readOnly
     * @property angularSpeed
     * @type number
     * @default 0
     */

    /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property velocity
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property angularVelocity
     * @type number
     * @default 0
     */

    /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     *
     * @property isStatic
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
     *
     * @property isSensor
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     *
     * @property isSleeping
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     *
     * @readOnly
     * @property motion
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     *
     * @property sleepThreshold
     * @type number
     * @default 60
     */

    /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     *
     * @property density
     * @type number
     * @default 0.001
     */

    /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     *
     * @property mass
     * @type number
     */

    /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     *
     * @property inverseMass
     * @type number
     */

    /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     *
     * @property inertia
     * @type number
     */

    /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     *
     * @property inverseInertia
     * @type number
     */

    /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. 
     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
     *
     *     Math.max(bodyA.restitution, bodyB.restitution)
     *
     * @property restitution
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
     *
     * The effects of the value may be non-linear. 
     * High values may be unstable depending on the body.
     * The engine uses a Coulomb friction model including static and kinetic friction.
     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
     *
     *     Math.min(bodyA.friction, bodyB.friction)
     *
     * @property friction
     * @type number
     * @default 0.1
     */

    /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model). 
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     *
     * @property frictionStatic
     * @type number
     * @default 0.5
     */

    /**
     * A `Number` that defines the air friction of the body (air resistance). 
     * A value of `0` means the body will never slow as it moves through space.
     * The higher the value, the faster a body slows when moving through space.
     * The effects of the value are non-linear. 
     *
     * @property frictionAir
     * @type number
     * @default 0.01
     */

    /**
     * An `Object` that specifies the collision filtering properties of this body.
     *
     * Collisions between two bodies will obey the following rules:
     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
     *   they will always collide if the value is positive, and they will never collide
     *   if the value is negative.
     * - If the two bodies have different values of `collisionFilter.group` or if one
     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
     *
     * Each body belongs to a collision category, given by `collisionFilter.category`. This
     * value is used as a bit field and the category should have only one bit set, meaning that
     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
     * different collision categories available.
     *
     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
     * the categories it collides with (the value is the bitwise AND value of all these categories).
     *
     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
     * are both true.
     *
     * @property collisionFilter
     * @type object
     */

    /**
     * An Integer `Number`, that specifies the collision group this body belongs to.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.group
     * @type object
     * @default 0
     */

    /**
     * A bit field that specifies the collision category this body belongs to.
     * The category value should have only one bit set, for example `0x0001`.
     * This means there are up to 32 unique collision categories available.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.category
     * @type object
     * @default 1
     */

    /**
     * A bit mask that specifies the collision categories this body may collide with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.mask
     * @type object
     * @default -1
     */

    /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
     *
     * @property slop
     * @type number
     * @default 0.05
     */

    /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     *
     * @property timeScale
     * @type number
     * @default 1
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the body should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * Sets the opacity to use when rendering.
     *
     * @property render.opacity
     * @type number
     * @default 1
    */

    /**
     * An `Object` that defines the sprite properties to use when rendering, if any.
     *
     * @property render.sprite
     * @type object
     */

    /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     *
     * @property render.sprite.texture
     * @type string
     */
     
    /**
     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
     *
     * @property render.sprite.xScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
     *
     * @property render.sprite.yScale
     * @type number
     * @default 1
     */

     /**
      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
      *
      * @property render.sprite.xOffset
      * @type number
      * @default 0
      */

     /**
      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
      *
      * @property render.sprite.yOffset
      * @type number
      * @default 0
      */

    /**
     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 1.5
     */

    /**
     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.fillStyle
     * @type string
     * @default a random colour
     */

    /**
     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
     * They are constantly updated by `Body.update` during the simulation.
     *
     * @property axes
     * @type vector[]
     */
     
    /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     *
     * @property area
     * @type string
     * @default 
     */

    /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     *
     * @property bounds
     * @type bounds
     */

})();


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/

// TODO: fix instability issues with torque
// TODO: linked constraints
// TODO: breakable constraints
// TODO: collision constraints
// TODO: allow constrained bodies to sleep
// TODO: handle 0 length constraints properly
// TODO: impulse caching and warming

var Constraint = {};

module.exports = Constraint;

var Vertices = __webpack_require__(31);
var Vector = __webpack_require__(13);
var Sleeping = __webpack_require__(48);
var Bounds = __webpack_require__(12);
var Axes = __webpack_require__(94);
var Common = __webpack_require__(2);

(function() {

    var _minLength = 0.000001,
        _minDifference = 0.001;

    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */
    Constraint.create = function(options) {
        var constraint = options;

        // if bodies defined but no points, use body centre
        if (constraint.bodyA && !constraint.pointA)
            constraint.pointA = { x: 0, y: 0 };
        if (constraint.bodyB && !constraint.pointB)
            constraint.pointB = { x: 0, y: 0 };

        // calculate static length using initial world space points
        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,
            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,
            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
    
        constraint.length = constraint.length || length || _minLength;

        // render
        var render = {
            visible: true,
            lineWidth: 2,
            strokeStyle: '#ffffff'
        };
        
        constraint.render = Common.extend(render, constraint.render);

        // option defaults
        constraint.id = constraint.id || Common.nextId();
        constraint.label = constraint.label || 'Constraint';
        constraint.type = 'constraint';
        constraint.stiffness = constraint.stiffness || 1;
        constraint.angularStiffness = constraint.angularStiffness || 0;
        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
        constraint.plugin = {};

        return constraint;
    };

    /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */
    Constraint.solveAll = function(constraints, timeScale) {
        for (var i = 0; i < constraints.length; i++) {
            Constraint.solve(constraints[i], timeScale);
        }
    };

    /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */
    Constraint.solve = function(constraint, timeScale) {
        var bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB;

        // update reference angle
        if (bodyA && !bodyA.isStatic) {
            constraint.pointA = Vector.rotate(pointA, bodyA.angle - constraint.angleA);
            constraint.angleA = bodyA.angle;
        }
        
        // update reference angle
        if (bodyB && !bodyB.isStatic) {
            constraint.pointB = Vector.rotate(pointB, bodyB.angle - constraint.angleB);
            constraint.angleB = bodyB.angle;
        }

        var pointAWorld = pointA,
            pointBWorld = pointB;

        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);

        if (!pointAWorld || !pointBWorld)
            return;

        var delta = Vector.sub(pointAWorld, pointBWorld),
            currentLength = Vector.magnitude(delta);

        // prevent singularity
        if (currentLength === 0)
            currentLength = _minLength;

        // solve distance constraint with Gauss-Siedel method
        var difference = (currentLength - constraint.length) / currentLength,
            normal = Vector.div(delta, currentLength),
            force = Vector.mult(delta, difference * 0.5 * constraint.stiffness * timeScale * timeScale);
        
        // if difference is very small, we can skip
        if (Math.abs(1 - (currentLength / constraint.length)) < _minDifference * timeScale)
            return;

        var velocityPointA,
            velocityPointB,
            offsetA,
            offsetB,
            oAn,
            oBn,
            bodyADenom,
            bodyBDenom;
    
        if (bodyA && !bodyA.isStatic) {
            // point body offset
            offsetA = { 
                x: pointAWorld.x - bodyA.position.x + force.x, 
                y: pointAWorld.y - bodyA.position.y + force.y
            };
            
            // update velocity
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            
            // find point velocity and body mass
            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity));
            oAn = Vector.dot(offsetA, normal);
            bodyADenom = bodyA.inverseMass + bodyA.inverseInertia * oAn * oAn;
        } else {
            velocityPointA = { x: 0, y: 0 };
            bodyADenom = bodyA ? bodyA.inverseMass : 0;
        }
            
        if (bodyB && !bodyB.isStatic) {
            // point body offset
            offsetB = { 
                x: pointBWorld.x - bodyB.position.x - force.x, 
                y: pointBWorld.y - bodyB.position.y - force.y 
            };
            
            // update velocity
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // find point velocity and body mass
            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity));
            oBn = Vector.dot(offsetB, normal);
            bodyBDenom = bodyB.inverseMass + bodyB.inverseInertia * oBn * oBn;
        } else {
            velocityPointB = { x: 0, y: 0 };
            bodyBDenom = bodyB ? bodyB.inverseMass : 0;
        }
        
        var relativeVelocity = Vector.sub(velocityPointB, velocityPointA),
            normalImpulse = Vector.dot(normal, relativeVelocity) / (bodyADenom + bodyBDenom);
    
        if (normalImpulse > 0) normalImpulse = 0;
    
        var normalVelocity = {
            x: normal.x * normalImpulse, 
            y: normal.y * normalImpulse
        };

        var torque;
 
        if (bodyA && !bodyA.isStatic) {
            torque = Vector.cross(offsetA, normalVelocity) * bodyA.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyA.constraintImpulse.x -= force.x;
            bodyA.constraintImpulse.y -= force.y;
            bodyA.constraintImpulse.angle += torque;

            // apply forces
            bodyA.position.x -= force.x;
            bodyA.position.y -= force.y;
            bodyA.angle += torque;
        }

        if (bodyB && !bodyB.isStatic) {
            torque = Vector.cross(offsetB, normalVelocity) * bodyB.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyB.constraintImpulse.x += force.x;
            bodyB.constraintImpulse.y += force.y;
            bodyB.constraintImpulse.angle -= torque;
            
            // apply forces
            bodyB.position.x += force.x;
            bodyB.position.y += force.y;
            bodyB.angle -= torque;
        }

    };

    /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */
    Constraint.postSolveAll = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                impulse = body.constraintImpulse;

            if (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                continue;
            }

            Sleeping.set(body, false);

            // update geometry and reset
            for (var j = 0; j < body.parts.length; j++) {
                var part = body.parts[j];
                
                Vertices.translate(part.vertices, impulse);

                if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                }

                if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                }

                Bounds.update(part.bounds, part.vertices, body.velocity);
            }

            impulse.angle = 0;
            impulse.x = 0;
            impulse.y = 0;
        }
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Constraint"
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the constraint should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 2
     */

    /**
     * A `String` that defines the stroke style to use when rendering the constraint outline.
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * The first possible `Body` that this constraint is attached to.
     *
     * @property bodyA
     * @type body
     * @default null
     */

    /**
     * The second possible `Body` that this constraint is attached to.
     *
     * @property bodyB
     * @type body
     * @default null
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointA
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointB
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
     * A value of `0.2` means the constraint acts like a soft spring.
     *
     * @property stiffness
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the target resting length of the constraint. 
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     *
     * @property length
     * @type number
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/

var Sleeping = {};

module.exports = Sleeping;

var Events = __webpack_require__(30);

(function() {

    Sleeping._motionWakeThreshold = 0.18;
    Sleeping._motionSleepThreshold = 0.08;
    Sleeping._minBias = 0.9;

    /**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */
    Sleeping.update = function(bodies, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // update bodies sleeping status
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;

            // wake up bodies if they have a force applied
            if (body.force.x !== 0 || body.force.y !== 0) {
                Sleeping.set(body, false);
                continue;
            }

            var minMotion = Math.min(body.motion, motion),
                maxMotion = Math.max(body.motion, motion);
        
            // biased average motion estimation between frames
            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
            
            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                body.sleepCounter += 1;
                
                if (body.sleepCounter >= body.sleepThreshold)
                    Sleeping.set(body, true);
            } else if (body.sleepCounter > 0) {
                body.sleepCounter -= 1;
            }
        }
    };

    /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Sleeping.afterCollisions = function(pairs, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // wake up bodies involved in collisions
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            // don't wake inactive pairs
            if (!pair.isActive)
                continue;

            var collision = pair.collision,
                bodyA = collision.bodyA.parent, 
                bodyB = collision.bodyB.parent;
        
            // don't wake if at least one body is static
            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)
                continue;
        
            if (bodyA.isSleeping || bodyB.isSleeping) {
                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,
                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;

                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                }
            }
        }
    };
  
    /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */
    Sleeping.set = function(body, isSleeping) {
        var wasSleeping = body.isSleeping;

        if (isSleeping) {
            body.isSleeping = true;
            body.sleepCounter = body.sleepThreshold;

            body.positionImpulse.x = 0;
            body.positionImpulse.y = 0;

            body.positionPrev.x = body.position.x;
            body.positionPrev.y = body.position.y;

            body.anglePrev = body.angle;
            body.speed = 0;
            body.angularSpeed = 0;
            body.motion = 0;

            if (!wasSleeping) {
                Events.trigger(body, 'sleepStart');
            }
        } else {
            body.isSleeping = false;
            body.sleepCounter = 0;

            if (wasSleeping) {
                Events.trigger(body, 'sleepEnd');
            }
        }
    };

})();


/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'attribute vec3 a_color;',
        'attribute float a_alpha;',
        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '   v_color = a_color;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'varying vec3 v_color;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(v_color, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var MeshRender = __webpack_require__(427);

var Mesh = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        MeshRender
    ],

    initialize:

    function Mesh (state, x, y, vertices, uv, indices, colors, alphas, texture, frame)
    {
        GameObject.call(this, state, 'Mesh');

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();

        if (vertices.length !== uv.length)
        {
            throw new Error('Phaser: Vertex count must match UV count');
        }

        if (colors.length > 0 && colors.length < (vertices.length / 2)|0)
        {
            throw new Error('Phaser: Color count must match Vertex count');
        }

        if (alphas.length > 0 && alphas.length < (vertices.length / 2)|0)
        {
            throw new Error('Phaser: Alpha count must match Vertex count');
        }

        var i;

        if (colors.length === 0)
        {
            for (i = 0; i < (vertices.length / 2)|0; ++i)
            {
                colors[i] = 0xFFFFFF;
            }
        }

        if (alphas.length === 0)
        {
            for (i = 0; i < (vertices.length / 2)|0; ++i)
            {
                alphas[i] = 1.0;
            }
        }

        this.vertices = new Float32Array(vertices);
        this.uv = new Float32Array(uv);
        this.indices = new Uint16Array(indices);
        this.colors = new Uint32Array(colors);
        this.alphas = new Float32Array(alphas);
    }

});

module.exports = Mesh;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var SpriteRender = __webpack_require__(438);

var Sprite = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        SpriteRender
    ],

    initialize:

    function Sprite (state, x, y, texture, frame)
    {
        GameObject.call(this, state, 'Sprite');

        this.anims = new Components.Animation(this);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
    },

    preUpdate: function (timestamp, frameDelta)
    {
        this.anims.update(timestamp, frameDelta);
    },

    play: function (key, startFrame)
    {
        return this.anims.play(key, startFrame);
    },

    toJSON: function ()
    {
        var data = Components.ToJSON(this);

        //  Extra Sprite data is added here

        return data;
    }

});

module.exports = Sprite;


/***/ }),
/* 52 */
/***/ (function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

//  This is based off an explanation and expanded math presented by Paul Bourke:
//  See http:'local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/

var LineToLine = function (line1, line2, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = line1.x1;
    var y1 = line1.y1;
    var x2 = line1.x2;
    var y2 = line1.y2;

    var x3 = line2.x1;
    var y3 = line2.y1;
    var x4 = line2.x2;
    var y4 = line2.y2;

    var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    //  Make sure there is not a division by zero - this also indicates that the lines are parallel.
    //  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).
    //  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).

    if (deNom === 0)
    {
        return false;
    }

    //  Calculate the intermediate fractional point that the lines potentially intersect.

    var uA = numA / deNom;
    var uB = numB / deNom;

    //  The fractional point will be between 0 and 1 inclusive if the lines intersect.
    //  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1)
    {
        out.x = x1 + (uA * (x2 - x1));
        out.y = y1 + (uA * (y2 - y1));

        return true;
    }

    return false;
};

module.exports = LineToLine;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

var Contains = function (triangle, x, y)
{
    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var v2x = x - triangle.x1;
    var v2y = y - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot02 = (v0x * v2x) + (v0y * v2y);
    var dot11 = (v1x * v1x) + (v1y * v1y);
    var dot12 = (v1x * v2x) + (v1y * v2y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);
    var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
    var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

    return (u >= 0 && v >= 0 && (u + v < 1));
};

module.exports = Contains;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    return (min + ((((value - min) % range) + range) % range));
};

module.exports = Wrap;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

// Collision Types - Determine if and how entities collide with each other

// In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
// while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
// collisions, both entities are moved. LITE or PASSIVE entities don't collide
// with other LITE or PASSIVE entities at all. The behaiviour for FIXED vs.
// FIXED collisions is undefined.

module.exports = {

    NEVER: 0,
    LITE: 1,
    PASSIVE: 2,
    ACTIVE: 4,
    FIXED: 8

};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/

var Pair = {};

module.exports = Pair;

var Contact = __webpack_require__(201);

(function() {
    
    /**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */
    Pair.create = function(collision, timestamp) {
        var bodyA = collision.bodyA,
            bodyB = collision.bodyB,
            parentA = collision.parentA,
            parentB = collision.parentB;

        var pair = {
            id: Pair.id(bodyA, bodyB),
            bodyA: bodyA,
            bodyB: bodyB,
            contacts: {},
            activeContacts: [],
            separation: 0,
            isActive: true,
            isSensor: bodyA.isSensor || bodyB.isSensor,
            timeCreated: timestamp,
            timeUpdated: timestamp,
            inverseMass: parentA.inverseMass + parentB.inverseMass,
            friction: Math.min(parentA.friction, parentB.friction),
            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
            restitution: Math.max(parentA.restitution, parentB.restitution),
            slop: Math.max(parentA.slop, parentB.slop)
        };

        Pair.update(pair, collision, timestamp);

        return pair;
    };

    /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */
    Pair.update = function(pair, collision, timestamp) {
        var contacts = pair.contacts,
            supports = collision.supports,
            activeContacts = pair.activeContacts,
            parentA = collision.parentA,
            parentB = collision.parentB;
        
        pair.collision = collision;
        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
        pair.friction = Math.min(parentA.friction, parentB.friction);
        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
        pair.slop = Math.max(parentA.slop, parentB.slop);
        activeContacts.length = 0;
        
        if (collision.collided) {
            for (var i = 0; i < supports.length; i++) {
                var support = supports[i],
                    contactId = Contact.id(support),
                    contact = contacts[contactId];

                if (contact) {
                    activeContacts.push(contact);
                } else {
                    activeContacts.push(contacts[contactId] = Contact.create(support));
                }
            }

            pair.separation = collision.depth;
            Pair.setActive(pair, true, timestamp);
        } else {
            if (pair.isActive === true)
                Pair.setActive(pair, false, timestamp);
        }
    };
    
    /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */
    Pair.setActive = function(pair, isActive, timestamp) {
        if (isActive) {
            pair.isActive = true;
            pair.timeUpdated = timestamp;
        } else {
            pair.isActive = false;
            pair.activeContacts.length = 0;
        }
    };

    /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */
    Pair.id = function(bodyA, bodyB) {
        if (bodyA.id < bodyB.id) {
            return 'A' + bodyA.id + 'B' + bodyB.id;
        } else {
            return 'A' + bodyB.id + 'B' + bodyA.id;
        }
    };

})();


/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ }),
/* 60 */
/***/ (function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var RND = __webpack_require__(683);

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(665),
    Distance: __webpack_require__(668),
    Easing: __webpack_require__(670),
    Fuzzy: __webpack_require__(676),
    Interpolation: __webpack_require__(679),
    Pow2: __webpack_require__(682),
    Snap: __webpack_require__(687),

    //  Random Data Generator
    RND: new RND(),

    //  Single functions
    Average: __webpack_require__(642),
    Bernstein: __webpack_require__(175),
    Between: __webpack_require__(85),
    CatmullRom: __webpack_require__(176),
    CeilTo: __webpack_require__(643),
    Clamp: __webpack_require__(55),
    DegToRad: __webpack_require__(644),
    Difference: __webpack_require__(645),
    Factorial: __webpack_require__(177),
    FloatBetween: __webpack_require__(646),
    FloorTo: __webpack_require__(647),
    GetSpeed: __webpack_require__(648),
    Linear: __webpack_require__(178),
    MaxAdd: __webpack_require__(649),
    MinSub: __webpack_require__(650),
    Percent: __webpack_require__(651),
    RadToDeg: __webpack_require__(652),
    Rotate: __webpack_require__(653),
    RotateAround: __webpack_require__(654),
    RotateAroundDistance: __webpack_require__(86),
    RoundAwayFromZero: __webpack_require__(179),
    RoundTo: __webpack_require__(655),
    SinCosTableGenerator: __webpack_require__(656),
    SmootherStep: __webpack_require__(181),
    SmoothStep: __webpack_require__(180),
    Within: __webpack_require__(657),
    Wrap: __webpack_require__(56)

};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(229);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

var CanvasInterpolation = {

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
    * Note that if this doesn't given the desired result then see the setSmoothingEnabled.
    *
    * @method Phaser.Canvas.setImageRenderingCrisp
    * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setCrisp: function (canvas)
    {
        var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ];

        types.forEach(function(type)
        {
            canvas.style['image-rendering'] = type;
        });

        canvas.style.msInterpolationMode = 'nearest-neighbor';

        return canvas;
    },

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
    * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
    *
    * @method Phaser.Canvas.setImageRenderingBicubic
    * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setBicubic: function (canvas)
    {
        canvas.style['image-rendering'] = 'auto';
        canvas.style.msInterpolationMode = 'bicubic';

        return canvas;
    }

};

module.exports = CanvasInterpolation;


/***/ }),
/* 64 */
/***/ (function(module, exports) {


//  Browser specific prefix, so not going to change between contexts, only between browsers
var prefix = '';

var Smoothing = function ()
{
    /**
    * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.
    * iife
    *
    * @method Phaser.Canvas.getSmoothingPrefix
    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.
    * @return {string|null} Returns the smoothingEnabled vendor prefix, or null if not set on the context.
    */
    var getPrefix = function (context)
    {
        var vendors = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ];

        for (var i = 0; i < vendors.length; i++)
        {
            var s = vendors[i] + 'mageSmoothingEnabled';

            if (s in context)
            {
                return s;
            }
        }

        return null;
    };

    /**
    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
    * drawn to the context will be affected. This sets the property across all current browsers but support is
    * patchy on earlier browsers, especially on mobile.
    *
    * @method Phaser.Canvas.setSmoothingEnabled
    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.
    * @param {boolean} value - If set to true it will enable image smoothing, false will disable it.
    * @return {CanvasRenderingContext2D} Returns the source context.
    */
    var enable = function (context)
    {
        if (prefix === '')
        {
            prefix = getPrefix(context);
        }

        if (prefix)
        {
            context[prefix] = true;
        }

        return context;
    };

    /**
    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
    * drawn to the context will be affected. This sets the property across all current browsers but support is
    * patchy on earlier browsers, especially on mobile.
    *
    * @method Phaser.Canvas.setSmoothingEnabled
    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.
    * @param {boolean} value - If set to true it will enable image smoothing, false will disable it.
    * @return {CanvasRenderingContext2D} Returns the source context.
    */
    var disable = function (context)
    {
        if (prefix === '')
        {
            prefix = getPrefix(context);
        }

        if (prefix)
        {
            context[prefix] = false;
        }

        return context;
    };

    /**
     * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.
     * Returns null if no smoothing prefix is available.
     *
     * @method Phaser.Canvas.getSmoothingEnabled
     * @param {CanvasRenderingContext2D} context - The context to check for smoothing on.
     * @return {boolean} True if the given context has image smoothing enabled, otherwise false.
     */
    var isEnabled = function (context)
    {
        return (prefix !== null) ? context[prefix] : null;
    };

    return {
        disable: disable,
        enable: enable,
        getPrefix: getPrefix,
        isEnabled: isEnabled
    };
};

module.exports = Smoothing();


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var Render = __webpack_require__(412);
var TexturedAndNormalizedTintedShader = __webpack_require__(49);

//  EffectLayer renders all elements on the layer to an offscreen render target
//  and then when rendering the color buffer of that render target to the main screen
//  it applies the effect layer shader.

var EffectLayer = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function EffectLayer (state, x, y, width, height, effectName, fragmentShader)
    {
        GameObject.call(this, state, 'EffectLayer');
       
        var pot = ((width & (width - 1)) == 0 && (height & (height - 1)) == 0);
        var resourceManager = state.game.renderer.resourceManager;
        var wrap;
        var gl;

        this.dstRenderTarget = null;
        this.renderTexture = null;
        this.dstShader = null;
        this.uniforms = {};

        if (resourceManager !== undefined)
        {
            gl = state.game.renderer.gl;
            wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            this.dstShader = resourceManager.createShader(effectName, {
                vert: TexturedAndNormalizedTintedShader.vert,
                frag: fragmentShader
            });

            this.renderTexture = resourceManager.createTexture(
                0,
                gl.LINEAR, gl.LINEAR,
                wrap, wrap,
                gl.RGBA,
                null, width, height
            );

            this.dstRenderTarget = resourceManager.createRenderTarget(width, height, this.renderTexture, null);
            state.game.renderer.currentTexture = null; // force rebinding of prev texture
        }

        this.flipY = true;
        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0, 0);
    },

    renderOffScreen: function ()
    {
        this.renderTarget = this.dstRenderTarget;
    },

    renderOnScreen: function ()
    {
        this.renderTarget = null;
    },

    add: function (gameObject)
    {
        if (gameObject.renderTarget !== undefined)
        {
            gameObject.renderTarget = this.dstRenderTarget;
        }
    },

    remove: function (gameObject)
    {
        if (gameObject.renderTarget !== undefined)
        {
            gameObject.renderTarget = null;
        }
    },

    getUniformLocation: function (uniformName)
    {
        var dstShader = this.dstShader;
        var uniforms = this.uniforms;
        var location;

        if (uniformName in uniforms)
        {
            location = uniforms[uniformName];
        }
        else
        {
            location = dstShader.getUniformLocation(uniformName);
            uniforms[uniformName] = location;
        }

        return location;
    },

    setFloat: function (uniformName, x)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat1(this.getUniformLocation(uniformName), x);
    },

    setFloat2: function (uniformName, x, y)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat2(this.getUniformLocation(uniformName), x, y);
    },

    setFloat3: function (uniformName, x, y, z)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat3(this.getUniformLocation(uniformName), x, y, z);
    },

    setFloat4: function (uniformName, x, y, z, w)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantFloat4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setInt: function (uniformName, x)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt1(this.getUniformLocation(uniformName), x);
    },

    setInt2: function (uniformName, x, y)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt2(this.getUniformLocation(uniformName), x, y);
    },

    setInt3: function (uniformName, x, y, z)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt3(this.getUniformLocation(uniformName), x, y, z);
    },

    setInt4: function (uniformName, x, y, z, w)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantInt4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setMatrix2x2: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix2x2(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix3x3: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix3x3(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix4x4: function (uniformName, matrix)
    {
        var dstShader = this.dstShader;

        if (dstShader === null)
        {
            return;
        }

        dstShader.setConstantMatrix4x4(this.getUniformLocation(uniformName), matrix);
    }

});

module.exports = EffectLayer;


/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = {
    ARC: 0,
    BEGIN_PATH: 1,
    CLOSE_PATH: 2,
    FILL_RECT: 3,
    LINE_TO: 4,
    MOVE_TO: 5,
    LINE_STYLE: 6,
    FILL_STYLE: 7,
    FILL_PATH: 8,
    STROKE_PATH: 9,
    FILL_TRIANGLE: 10,
    STROKE_TRIANGLE: 11,
    LINE_FX_TO: 12,
    MOVE_FX_TO: 13,
    SAVE: 14,
    RESTORE: 15,
    TRANSLATE: 16,
    SCALE: 17,
    ROTATE: 18
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var ImageRender = __webpack_require__(421);

var Image = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        ImageRender
    ],

    initialize:

    function Image (state, x, y, texture, frame)
    {
        GameObject.call(this, state, 'Image');

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
    }

});

module.exports = Image;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var Mesh = __webpack_require__(50);

var Quad = new Class({

    Extends: Mesh,

    initialize:

    function Quad (state, x, y, texture, frame)
    {
        //  0----3
        //  |\  B|
        //  | \  |
        //  |  \ |
        //  | A \|
        //  |    \
        //  1----2

        //  Array sequence: tl, bl, br, tr
        var vertices = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
        var uv = [ 0, 0, 0, 1, 1, 1, 1, 0 ];
        var indices = [ 0, 1, 2, 0, 2, 3 ];
        var colors = [ 0xffffff, 0xffffff, 0xffffff, 0xffffff ];
        var alphas = [ 1, 1, 1, 1 ];

        Mesh.call(this, state, x, y, vertices, uv, indices, colors, alphas, texture, frame);

        this.resetPosition();
    },

    topLeftX: {

        get: function ()
        {
            return this.x + this.vertices[0];
        },

        set: function (value)
        {
            this.vertices[0] = value - this.x;
        }

    },

    topLeftY: {

        get: function ()
        {
            return this.y + this.vertices[1];
        },

        set: function (value)
        {
            this.vertices[1] = value - this.y;
        }

    },

    topRightX: {

        get: function ()
        {
            return this.x + this.vertices[6];
        },

        set: function (value)
        {
            this.vertices[6] = value - this.x;
        }

    },

    topRightY: {

        get: function ()
        {
            return this.y + this.vertices[7];
        },

        set: function (value)
        {
            this.vertices[7] = value - this.y;
        }

    },

    bottomLeftX: {

        get: function ()
        {
            return this.x + this.vertices[2];
        },

        set: function (value)
        {
            this.vertices[2] = value - this.x;
        }

    },

    bottomLeftY: {

        get: function ()
        {
            return this.y + this.vertices[3];
        },

        set: function (value)
        {
            this.vertices[3] = value - this.y;
        }

    },

    bottomRightX: {

        get: function ()
        {
            return this.x + this.vertices[4];
        },

        set: function (value)
        {
            this.vertices[4] = value - this.x;
        }

    },

    bottomRightY: {

        get: function ()
        {
            return this.y + this.vertices[5];
        },

        set: function (value)
        {
            this.vertices[5] = value - this.y;
        }

    },

        //  tl, bl, br, tr

    topLeftAlpha: {

        get: function ()
        {
            return this.alphas[0];
        },

        set: function (value)
        {
            this.alphas[0] = value;
        }

    },

    topRightAlpha: {

        get: function ()
        {
            return this.alphas[3];
        },

        set: function (value)
        {
            this.alphas[3] = value;
        }

    },

    bottomLeftAlpha: {

        get: function ()
        {
            return this.alphas[1];
        },

        set: function (value)
        {
            this.alphas[1] = value;
        }

    },

    bottomRightAlpha: {

        get: function ()
        {
            return this.alphas[2];
        },

        set: function (value)
        {
            this.alphas[2] = value;
        }

    },

    topLeftColor: {

        get: function ()
        {
            return this.colors[0];
        },

        set: function (value)
        {
            this.colors[0] = value;
        }

    },

    topRightColor: {

        get: function ()
        {
            return this.colors[3];
        },

        set: function (value)
        {
            this.colors[3] = value;
        }

    },

    bottomLeftColor: {

        get: function ()
        {
            return this.colors[1];
        },

        set: function (value)
        {
            this.colors[1] = value;
        }

    },

    bottomRightColor: {

        get: function ()
        {
            return this.colors[2];
        },

        set: function (value)
        {
            this.colors[2] = value;
        }

    },

    setTopLeft: function (x, y)
    {
        this.topLeftX = x;
        this.topLeftY = y;

        return this;
    },

    setTopRight: function (x, y)
    {
        this.topRightX = x;
        this.topRightY = y;

        return this;
    },

    setBottomLeft: function (x, y)
    {
        this.bottomLeftX = x;
        this.bottomLeftY = y;

        return this;
    },

    setBottomRight: function (x, y)
    {
        this.bottomRightX = x;
        this.bottomRightY = y;

        return this;
    },

    resetPosition: function ()
    {
        var x = this.x;
        var y = this.y;
        var halfWidth = Math.floor(this.width / 2);
        var halfHeight = Math.floor(this.height / 2);

        this.setTopLeft(x - halfWidth, y - halfHeight);
        this.setTopRight(x + halfWidth, y - halfHeight);
        this.setBottomLeft(x - halfWidth, y + halfHeight);
        this.setBottomRight(x + halfWidth, y + halfHeight);

        return this;
    },

    resetAlpha: function ()
    {
        var alphas = this.alphas;

        alphas[0] = 1;
        alphas[1] = 1;
        alphas[2] = 1;
        alphas[3] = 1;

        return this;
    },

    resetColors: function ()
    {
        var colors = this.colors;

        colors[0] = 0xffffff;
        colors[1] = 0xffffff;
        colors[2] = 0xffffff;
        colors[3] = 0xffffff;

        return this;
    },

    reset: function ()
    {
        this.resetPosition();
        this.resetAlpha();
        this.resetColors();
    }

});

module.exports = Quad;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var CanvasPool = __webpack_require__(9);
var TextRender = __webpack_require__(446);
var TextStyle = __webpack_require__(442);
var GetTextSize = __webpack_require__(440);

var Text = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Transform,
        Components.Visible,
        Components.Flip,
        Components.ScrollFactor,
        TextRender
    ],

    initialize:

    function Text (state, x, y, text, style)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (text === undefined) { text = ''; }

        GameObject.call(this, state, 'Text');

        this.setPosition(x, y);
        this.setOrigin(0, 0);

        /**
         * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
         */
        this.canvas = CanvasPool.create(this);

        /**
         * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
         */
        this.context = this.canvas.getContext('2d');

        this.style = new TextStyle(this, style);

        this.autoRound = true;

        /**
         * The Regular Expression that is used to split the text up into lines, in
         * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
         * You can change this RegExp to be anything else that you may need.
         * @property {Object} splitRegExp
         */
        this.splitRegExp = /(?:\r\n|\r|\n)/;

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.resolution = 1;

        /**
        * Specify a padding value which is added to the line width and height when calculating the Text size.
        * Allows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions.
        * @property {Phaser.Point} padding
        */
        this.padding = { x: 0, y: 0 };

        this.width = 1;
        this.height = 1;

        this.canvasTexture = null;
        this.prevWidth = 0;
        this.prevHeight = 0;
        this.dirty = false;

        if (text !== '')
        {
            this.updateText();
        }
    },

    setText: function (value)
    {
        if (Array.isArray(value))
        {
            value = value.join('\n');
        }

        if (value !== this.text)
        {
            this.text = value.toString();

            this.updateText();
        }

        return this;
    },

    setStyle: function (style)
    {
        return this.style.setStyle(style);
    },

    setFont: function (font)
    {
        return this.style.setFont(font);
    },

    setFixedSize: function (width, height)
    {
        return this.style.setFixedSize(width, height);
    },

    setBackgroundColor: function (color)
    {
        return this.style.setBackgroundColor(color);
    },

    setFill: function (color)
    {
        return this.style.setFill(color);
    },

    setStroke: function (color, thickness)
    {
        return this.style.setStroke(color, thickness);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    },

    setShadowOffset: function (x, y)
    {
        return this.style.setShadowOffset(x, y);
    },

    setShadowColor: function (color)
    {
        return this.style.setShadowColor(color);
    },

    setShadowBlur: function (blur)
    {
        return this.style.setShadowBlur(blur);
    },

    setShadowStroke: function (enabled)
    {
        return this.style.setShadowStroke(enabled);
    },

    setShadowFill: function (enabled)
    {
        return this.style.setShadowFill(enabled);
    },

    setAlign: function (align)
    {
        return this.style.setAlign(align);
    },

    setMaxLines: function (max)
    {
        return this.style.setMaxLines(max);
    },

    updateText: function ()
    {
        var canvas = this.canvas;
        var context = this.context;
        var style = this.style;
        var size = style.metrics;

        var outputText = this.text;

        // if (style.wordWrap)
        // {
        //     outputText = this.runWordWrap(this.text);
        // }

        //  Split text into lines
        var lines = outputText.split(this.splitRegExp);

        var textSize = GetTextSize(this, size, lines);

        if (!style.fixedWidth)
        {
            this.width = textSize.width;
        }

        if (!style.fixedHeight)
        {
            this.height = textSize.height;
        }

        this.updateOrigin();

        var padding = this.padding;

        var w = (textSize.width + (padding.x * 2)) * this.resolution;
        var h = (textSize.height + (padding.y * 2)) * this.resolution;

        if (canvas.width !== w || canvas.height !== h)
        {
            canvas.width = w;
            canvas.height = h;
        }
        else
        {
            context.clearRect(0, 0, w, h);
        }

        if (style.backgroundColor)
        {
            context.fillStyle = style.backgroundColor;
            context.fillRect(0, 0, w, h);
        }

        style.syncFont(canvas, context);

        context.textBaseline = 'alphabetic';

        //  Apply padding
        context.translate(padding.x, padding.y);

        var linePositionX;
        var linePositionY;

        //  Draw text line by line
        for (var i = 0; i < textSize.lines; i++)
        {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;

            if (i > 0)
            {
                linePositionY += (textSize.lineSpacing * i);
            }

            if (style.align === 'right')
            {
                linePositionX += textSize.width - textSize.lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (textSize.width - textSize.lineWidths[i]) / 2;
            }

            if (this.autoRound)
            {
                linePositionX = Math.round(linePositionX);
                linePositionY = Math.round(linePositionY);
            }

            if (style.strokeThickness)
            {
                this.style.syncShadow(context, style.shadowStroke);

                context.strokeText(lines[i], linePositionX, linePositionY);
            }

            if (style.fill)
            {
                this.style.syncShadow(context, style.shadowFill);

                context.fillText(lines[i], linePositionX, linePositionY);
            }
        }

        this.dirty = true;

        return this;
    },

    getTextMetrics: function ()
    {
        return this.style.getTextMetrics();
    },

    toJSON: function ()
    {
        var out = Components.ToJSON(this);

        //  Extra Text data is added here

        var data = {
            autoRound: this.autoRound,
            text: this.text,
            style: this.style.toJSON(),
            resolution: this.resolution,
            padding: {
                x: this.padding.x,
                y: this.padding.y
            }
        };

        out.data = data;

        return out;
    }
});

module.exports = Text;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var TilemapRender = __webpack_require__(452);
var Tile = __webpack_require__(449);

var Tilemap = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        TilemapRender
    ],

    initialize:

    function Tilemap (state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame)
    {
        GameObject.call(this, state, 'Tilemap');

        this.mapData = mapData !== null ? new Uint32Array(mapData) : new Uint32Array(mapWidth * mapHeight);
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;
        this.tileArray = [];
        this.culledTiles = [];
        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.setSize(tileWidth * mapWidth, tileHeight * mapHeight);
        this.buildTilemap();
    },

    getTotalTileCount: function ()
    {
        return this.tileArray.length;
    },

    getVisibleTileCount: function (camera)
    {
        return this.cull(camera).length;
    },

    buildTilemap: function ()
    {
        var tileArray = this.tileArray;
        var mapData = this.mapData;
        // var frame = this.frame;
        var tileWidth = this.tileWidth;
        var tileHeight = this.tileHeight;
        var width = this.texture.source[0].width;
        var height = this.texture.source[0].height;
        var mapWidth = this.mapWidth;
        var mapHeight = this.mapHeight;
        var setWidth = width / tileWidth;

        tileArray.length = 0;

        for (var y = 0; y < mapHeight; ++y)
        {
            for (var x = 0; x < mapWidth; ++x)
            {
                var tileId = mapData[y * mapWidth + x];
                var halfTileWidth = (tileWidth) * 0.5;
                var halfTileHeight = (tileHeight) * 0.5;
                var rectx = (((tileId % setWidth)|0) * tileWidth) + halfTileWidth;
                var recty = (((tileId / setWidth)|0) * tileHeight) + halfTileHeight;
                var tx = x * tileWidth;
                var ty = y * tileHeight;
                
                tileArray.push(new Tile({
                    index: x + y,
                    id: tileId,
                    x: tx,
                    y: ty,
                    width: tileWidth,
                    height: tileHeight,
                    frameX: rectx,
                    frameY: recty,
                    frameWidth: tileWidth,
                    frameHeight: tileHeight,
                    textureWidth: width,
                    textureHeight: height
                }));
            }
        }
    },

    cull: function (camera)
    {
        var culledTiles = this.culledTiles;
        var tiles = this.tileArray;
        var length = tiles.length;
        var scrollX = camera.scrollX * this.scrollFactorX;
        var scrollY = camera.scrollY * this.scrollFactorY;
        var cameraW = camera.width;
        var cameraH = camera.height;

        culledTiles.length = 0;

        for (var index = 0; index < length; ++index)
        {
            var tile = tiles[index];
            var tileX = tile.x - scrollX;
            var tileY = tile.y - scrollY;
            var tileW = tile.width;
            var tileH = tile.height;
            var cullW = cameraW + tileW;
            var cullH = cameraH + tileH;

            if (tile.visible &&
                tileX > -tileH && tileY > -tileW &&
                tileX < cullW && tileY < cullH)
            {
                culledTiles.push(tile);
            }
        }

        return culledTiles;
    },

    forEach: function (callback)
    {
        this.tileArray.forEach(callback);
    },

    //  Returns Object containing:
    //  {
    //      alpha
    //      frameWidth,
    //      frameHeight,
    //      frameX
    //      frameY
    //      id
    //      index = the tile in the tilset to render
    //      textureWidth = tileset texture size
    //      textureHeight
    //      tint
    //      visible
    //      width
    //      x
    //      y
    //  }

    getTileAt: function (x, y)
    {
        var ix = (x|0);
        var iy = (y|0);
        var tiles = this.tileArray;
        var index = iy * this.mapWidth + ix;

        if (index < tiles.length)
        {
            return tiles[index];
        }

        return null;
    },

    getTileAtIndex: function (index)
    {
        var tiles = this.tileArray;

        if (index < tiles.length)
        {
            return tiles[index];
        }

        return null;
    }

});

module.exports = Tilemap;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var StaticTilemapRender = __webpack_require__(457);
var CONST = __webpack_require__(208);

var StaticTilemap = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        StaticTilemapRender
    ],

    initialize:

    function StaticTilemap (state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame)
    {
        GameObject.call(this, state, 'StaticTilemap');

        this.vbo = null;
        this.gl = state.game.renderer.gl ? state.game.renderer.gl : null;
        this.tilemapRenderer = state.game.renderer.tilemapRenderer ? state.game.renderer.tilemapRenderer : null;
        this.resourceManager = this.gl ? state.game.renderer.resourceManager : null;
        this.bufferData = null;
        this.mapData = mapData;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;
        this.dirty = true;
        this.vertexCount = 0;
        this.cullStart = 0;
        this.cullEnd = 0;
        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.setSize(tileWidth * mapWidth, tileHeight * mapHeight);
    },

    upload: function (camera) 
    {
        if (this.gl)
        {
            if (this.dirty)
            {
                var gl = this.gl;
                var vbo = this.vbo;
                var mapWidth = this.mapWidth;
                var mapHeight = this.mapHeight;
                var tileWidth = this.tileWidth;
                var tileHeight = this.tileHeight;
                var bufferData = this.bufferData;
                var bufferF32, bufferU32;
                var voffset = 0;
                var vertexCount = 0;
                var width = this.texture.source[0].width;
                var height = this.texture.source[0].height;
                var setWidth = width / tileWidth;
                var mapData = this.mapData;

                if (this.vbo === null)
                {
                    vbo = this.resourceManager.createBuffer(gl.ARRAY_BUFFER, (4 * 6 * (mapWidth * mapHeight)) * 4, gl.STATIC_DRAW);
                    vbo.addAttribute(this.tilemapRenderer.shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
                    vbo.addAttribute(this.tilemapRenderer.shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
                    bufferData = this.bufferData = new ArrayBuffer((4 * 6 * (mapWidth * mapHeight)) * 4);
                    this.vbo = vbo;
                }

                bufferF32 = new Float32Array(bufferData);

                for (var y = 0; y < mapHeight; ++y)
                {
                    for (var x = 0; x < mapWidth; ++x)
                    {
                        var tileId = mapData[y * mapWidth + x];
                        var halfTileWidth =  (tileWidth) * 0.5;
                        var halfTileHeight =  (tileHeight) * 0.5;
                        var rectx = (((tileId % setWidth)|0) * tileWidth) + halfTileWidth;
                        var recty = (((tileId / setWidth)|0) * tileHeight) + halfTileHeight;
                        var tx = x * tileWidth;
                        var ty = y * tileHeight;
                        var txw = tx + tileWidth;
                        var tyh = ty + tileHeight;
                        var u0 = (rectx - (halfTileWidth - 0.5)) / width;
                        var v0 = (recty - (halfTileHeight - 0.5)) / height;
                        var u1 = (rectx + (halfTileWidth - 0.5)) / width;
                        var v1 = (recty + (halfTileHeight - 0.5)) / height;
                        var tx0 = tx;
                        var ty0 = ty;
                        var tx1 = tx;
                        var ty1 = tyh;
                        var tx2 = txw;
                        var ty2 = tyh;
                        var tx3 = txw;
                        var ty3 = ty;

                        bufferF32[voffset + 0] = tx0;
                        bufferF32[voffset + 1] = ty0;
                        bufferF32[voffset + 2] = u0;
                        bufferF32[voffset + 3] = v0;

                        bufferF32[voffset + 4] = tx1;
                        bufferF32[voffset + 5] = ty1;
                        bufferF32[voffset + 6] = u0;
                        bufferF32[voffset + 7] = v1;

                        bufferF32[voffset + 8] = tx2;
                        bufferF32[voffset + 9] = ty2;
                        bufferF32[voffset + 10] = u1;
                        bufferF32[voffset + 11] = v1;

                        bufferF32[voffset + 12] = tx0;
                        bufferF32[voffset + 13] = ty0;
                        bufferF32[voffset + 14] = u0;
                        bufferF32[voffset + 15] = v0;

                        bufferF32[voffset + 16] = tx2;
                        bufferF32[voffset + 17] = ty2;
                        bufferF32[voffset + 18] = u1;
                        bufferF32[voffset + 19] = v1;

                        bufferF32[voffset + 20] = tx3;
                        bufferF32[voffset + 21] = ty3;
                        bufferF32[voffset + 22] = u1;
                        bufferF32[voffset + 23] = v0;
                        
                        voffset += 24;
                        vertexCount += 6;
                    }
                }
                this.vertexCount = vertexCount;
                vbo.updateResource(bufferData, 0);

                this.dirty = false;
            }
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.scrollLocation, -camera.scrollX, -camera.scrollY);
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.scrollFactorLocation, this.scrollFactorX, this.scrollFactorY);
            this.tilemapRenderer.shader.setConstantFloat2(this.tilemapRenderer.tilemapPositionLocation, this.x, this.y);
        }
    },

    getTotalTileCount: function ()
    {
        return this.mapData.length;
    },

    getVisibleTileCount: function (camera)
    {
        this.cull(camera);
        return (this.cullEnd - this.cullStart) / 6;
    },

    cull: function (camera)
    {
        this.cullStart = 0;
        this.cullEnd = 0;
        var tileWidth = this.tileWidth;
        var tileHeight = this.tileHeight;
        var pixelX = this.x - (camera.scrollX * this.scrollFactorX);
        var pixelY = this.y - (camera.scrollY * this.scrollFactorY);
        var pixelWidth = this.mapWidth * tileWidth;
        var pixelHeight = this.mapHeight * tileHeight;

        if (pixelX < camera.x + camera.width + (tileWidth * 2) &&
            pixelX + pixelWidth > camera.x + -(tileWidth * 2) &&
            pixelY < camera.y + camera.height + (tileHeight * 2) &&
            pixelY + pixelHeight > camera.y + -(tileHeight * 2))
        {
            var interX = Math.max(pixelX, camera.x + -(tileWidth * 2));
            var interY = Math.max(pixelY, camera.y + -(tileHeight * 2));
            var interWidth = Math.min(pixelX + pixelWidth, camera.x + camera.width + (tileWidth * 2)) - interX;
            var interHeight = Math.min(pixelY + pixelHeight, camera.y + camera.height + (tileHeight * 2)) - interY;

            interX = ((interX + (camera.scrollX * this.scrollFactorX)) / tileWidth)|0;
            interY = ((interY + (camera.scrollY * this.scrollFactorY)) / tileHeight)|0;
            interWidth = (interWidth / tileWidth)|0;
            interHeight = (interHeight / tileHeight)|0;

            this.cullStart = (interY * this.mapWidth + interX) * 6;
            this.cullEnd = ((interY + interHeight) * this.mapWidth + interX) * 6;
        }
    }

});

module.exports = StaticTilemap;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);

var Zone = new Class({

    Extends: GameObject,

    Mixins: [
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.ScrollFactor,
        Components.Visible
    ],

    initialize:

    function Zone (state, x, y, width, height)
    {
        GameObject.call(this, state, 'Zone');

        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0);
    }

});

module.exports = Zone;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ }),
/* 75 */
/***/ (function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ }),
/* 76 */
/***/ (function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ }),
/* 78 */
/***/ (function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ }),
/* 79 */
/***/ (function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

//  points is an array of Point-like objects with public x/y properties
//  returns an array containing all points that are within the triangle, or an empty array if none
//  if 'returnFirst' is true it will return after the first point within the triangle is found

var ContainsArray = function (triangle, points, returnFirst, out)
{
    if (returnFirst === undefined) { returnFirst = false; }
    if (out === undefined) { out = []; }

    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot11 = (v1x * v1x) + (v1y * v1y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);

    var u;
    var v;
    var v2x;
    var v2y;
    var dot02;
    var dot12;

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    for (var i = 0; i < points.length; i++)
    {
        v2x = points[i].x - x1;
        v2y = points[i].y - y1;

        dot02 = (v0x * v2x) + (v0y * v2y);
        dot12 = (v1x * v2x) + (v1y * v2y);

        u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
        v = ((dot00 * dot12) - (dot01 * dot02)) * inv;
    
        if (u >= 0 && v >= 0 && (u + v < 1))
        {
            out.push({ x: points[i].x, y: points[i].y });

            if (returnFirst)
            {
                break;
            }
        }
    }

    return out;
};

module.exports = ContainsArray;


/***/ }),
/* 80 */
/***/ (function(module, exports) {


var RotateAroundXY = function (triangle, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = triangle.x1 - x;
    var ty = triangle.y1 - y;

    triangle.x1 = tx * c - ty * s + x;
    triangle.y1 = tx * s + ty * c + y;

    tx = triangle.x2 - x;
    ty = triangle.y2 - y;

    triangle.x2 = tx * c - ty * s + x;
    triangle.y2 = tx * s + ty * c + y;

    tx = triangle.x3 - x;
    ty = triangle.y3 - y;

    triangle.x3 = tx * c - ty * s + x;
    triangle.y3 = tx * s + ty * c + y;

    return triangle;
};

module.exports = RotateAroundXY;


/***/ }),
/* 81 */
/***/ (function(module, exports) {

/**
 * Given 3 color values this will return an integer representation of it.
 *
 * @method getColor
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor = function (red, green, blue)
{
    return red << 16 | green << 8 | blue;
};

module.exports = GetColor;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,

    SHIFT: 16,
    CTRL: 17,
    ALT: 18,

    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,

    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    PRINT_SCREEN: 42,
    INSERT: 45,
    DELETE: 46,

    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,

    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,

    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,

    SEMICOLON: 186,
    PLUS: 187,
    COMMA: 188,
    MINUS: 189,
    PERIOD: 190,
    FORWAD_SLASH: 191,
    BACK_SLASH: 220,
    QUOTES: 222
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ }),
/* 85 */
/***/ (function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ }),
/* 86 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties, the item to be rotated
//  x/y = the coordinate to rotate around
//  angle = radians
//  distance = in px

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ }),
/* 87 */
/***/ (function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

// Collision Types - Determine if and how entities collide with each other

// In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
// while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
// collisions, both entities are moved. LITE or PASSIVE entities don't collide
// with other LITE or PASSIVE entities at all. The behaiviour for FIXED vs.
// FIXED collisions is undefined.

module.exports = {

    NONE: 0,
    A: 1,
    B: 2,
    BOTH: 3

};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/

// TODO: speculative contacts

var Detector = {};

module.exports = Detector;

var SAT = __webpack_require__(91);
var Pair = __webpack_require__(58);
var Bounds = __webpack_require__(12);

(function() {

    /**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */
    Detector.collisions = function(broadphasePairs, engine) {
        var collisions = [],
            pairsTable = engine.pairs.table;

        // @if DEBUG
        var metrics = engine.metrics;
        // @endif
        
        for (var i = 0; i < broadphasePairs.length; i++) {
            var bodyA = broadphasePairs[i][0], 
                bodyB = broadphasePairs[i][1];

            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                continue;
            
            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                continue;

            // @if DEBUG
            metrics.midphaseTests += 1;
            // @endif

            // mid phase
            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];

                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                        var partB = bodyB.parts[k];

                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {
                            // find a previous collision we could reuse
                            var pairId = Pair.id(partA, partB),
                                pair = pairsTable[pairId],
                                previousCollision;

                            if (pair && pair.isActive) {
                                previousCollision = pair.collision;
                            } else {
                                previousCollision = null;
                            }

                            // narrow phase
                            var collision = SAT.collides(partA, partB, previousCollision);

                            // @if DEBUG
                            metrics.narrowphaseTests += 1;
                            if (collision.reused)
                                metrics.narrowReuseCount += 1;
                            // @endif

                            if (collision.collided) {
                                collisions.push(collision);
                                // @if DEBUG
                                metrics.narrowDetections += 1;
                                // @endif
                            }
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */
    Detector.canCollide = function(filterA, filterB) {
        if (filterA.group === filterB.group && filterA.group !== 0)
            return filterA.group > 0;

        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
    };

})();


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/

var Grid = {};

module.exports = Grid;

var Pair = __webpack_require__(58);
var Detector = __webpack_require__(89);
var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */
    Grid.create = function(options) {
        var defaults = {
            controller: Grid,
            detector: Detector.collisions,
            buckets: {},
            pairs: {},
            pairsList: [],
            bucketWidth: 48,
            bucketHeight: 48
        };

        return Common.extend(defaults, options);
    };

    /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */

    /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */

    /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */
    Grid.update = function(grid, bodies, engine, forceUpdate) {
        var i, col, row,
            world = engine.world,
            buckets = grid.buckets,
            bucket,
            bucketId,
            gridChanged = false;

        // @if DEBUG
        var metrics = engine.metrics;
        metrics.broadphaseTests = 0;
        // @endif

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isSleeping && !forceUpdate)
                continue;

            // don't update out of world bodies
            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x
                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                continue;

            var newRegion = _getRegion(grid, body);

            // if the body has changed grid region
            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {

                // @if DEBUG
                metrics.broadphaseTests += 1;
                // @endif

                if (!body.region || forceUpdate)
                    body.region = newRegion;

                var union = _regionUnion(newRegion, body.region);

                // update grid buckets affected by region change
                // iterate over the union of both regions
                for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                        bucketId = _getBucketId(col, row);
                        bucket = buckets[bucketId];

                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol
                                                && row >= newRegion.startRow && row <= newRegion.endRow);

                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol
                                                && row >= body.region.startRow && row <= body.region.endRow);

                        // remove from old region buckets
                        if (!isInsideNewRegion && isInsideOldRegion) {
                            if (isInsideOldRegion) {
                                if (bucket)
                                    _bucketRemoveBody(grid, bucket, body);
                            }
                        }

                        // add to new region buckets
                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {
                            if (!bucket)
                                bucket = _createBucket(buckets, bucketId);
                            _bucketAddBody(grid, bucket, body);
                        }
                    }
                }

                // set the new region
                body.region = newRegion;

                // flag changes so we can update pairs
                gridChanged = true;
            }
        }

        // update pairs list only if pairs changed (i.e. a body changed region)
        if (gridChanged)
            grid.pairsList = _createActivePairsList(grid);
    };

    /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */
    Grid.clear = function(grid) {
        grid.buckets = {};
        grid.pairs = {};
        grid.pairsList = [];
    };

    /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */
    var _regionUnion = function(regionA, regionB) {
        var startCol = Math.min(regionA.startCol, regionB.startCol),
            endCol = Math.max(regionA.endCol, regionB.endCol),
            startRow = Math.min(regionA.startRow, regionB.startRow),
            endRow = Math.max(regionA.endRow, regionB.endRow);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */
    var _getRegion = function(grid, body) {
        var bounds = body.bounds,
            startCol = Math.floor(bounds.min.x / grid.bucketWidth),
            endCol = Math.floor(bounds.max.x / grid.bucketWidth),
            startRow = Math.floor(bounds.min.y / grid.bucketHeight),
            endRow = Math.floor(bounds.max.y / grid.bucketHeight);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */
    var _createRegion = function(startCol, endCol, startRow, endRow) {
        return { 
            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,
            startCol: startCol, 
            endCol: endCol, 
            startRow: startRow, 
            endRow: endRow 
        };
    };

    /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */
    var _getBucketId = function(column, row) {
        return 'C' + column + 'R' + row;
    };

    /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */
    var _createBucket = function(buckets, bucketId) {
        var bucket = buckets[bucketId] = [];
        return bucket;
    };

    /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketAddBody = function(grid, bucket, body) {
        // add new pairs
        for (var i = 0; i < bucket.length; i++) {
            var bodyB = bucket[i];

            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))
                continue;

            // keep track of the number of buckets the pair exists in
            // important for Grid.update to work
            var pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair) {
                pair[2] += 1;
            } else {
                grid.pairs[pairId] = [body, bodyB, 1];
            }
        }

        // add to bodies (after pairs, otherwise pairs with self)
        bucket.push(body);
    };

    /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketRemoveBody = function(grid, bucket, body) {
        // remove from bucket
        bucket.splice(Common.indexOf(bucket, body), 1);

        // update pair counts
        for (var i = 0; i < bucket.length; i++) {
            // keep track of the number of buckets the pair exists in
            // important for _createActivePairsList to work
            var bodyB = bucket[i],
                pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair)
                pair[2] -= 1;
        }
    };

    /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */
    var _createActivePairsList = function(grid) {
        var pairKeys,
            pair,
            pairs = [];

        // grid.pairs is used as a hashmap
        pairKeys = Common.keys(grid.pairs);

        // iterate over grid.pairs
        for (var k = 0; k < pairKeys.length; k++) {
            pair = grid.pairs[pairKeys[k]];

            // if pair exists in at least one bucket
            // it is a pair that needs further collision testing so push it
            if (pair[2] > 0) {
                pairs.push(pair);
            } else {
                delete grid.pairs[pairKeys[k]];
            }
        }

        return pairs;
    };
    
})();


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/

// TODO: true circles and curves

var SAT = {};

module.exports = SAT;

var Vertices = __webpack_require__(31);
var Vector = __webpack_require__(13);

(function() {

    /**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */
    SAT.collides = function(bodyA, bodyB, previousCollision) {
        var overlapAB,
            overlapBA, 
            minOverlap,
            collision,
            canReusePrevCol = false;

        if (previousCollision) {
            // estimate total motion
            var parentA = bodyA.parent,
                parentB = bodyB.parent,
                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed
                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;

            // we may be able to (partially) reuse collision result 
            // but only safe if collision was resting
            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;

            // reuse collision object
            collision = previousCollision;
        } else {
            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };
        }

        if (previousCollision && canReusePrevCol) {
            // if we can reuse the collision result
            // we only need to test the previously found axis
            var axisBodyA = collision.axisBody,
                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,
                axes = [axisBodyA.axes[previousCollision.axisNumber]];

            minOverlap = _overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
            collision.reused = true;

            if (minOverlap.overlap <= 0) {
                collision.collided = false;
                return collision;
            }
        } else {
            // if we can't reuse a result, perform a full SAT test

            overlapAB = _overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);

            if (overlapAB.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            overlapBA = _overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);

            if (overlapBA.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            if (overlapAB.overlap < overlapBA.overlap) {
                minOverlap = overlapAB;
                collision.axisBody = bodyA;
            } else {
                minOverlap = overlapBA;
                collision.axisBody = bodyB;
            }

            // important for reuse later
            collision.axisNumber = minOverlap.axisNumber;
        }

        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
        collision.collided = true;
        collision.depth = minOverlap.overlap;
        collision.parentA = collision.bodyA.parent;
        collision.parentB = collision.bodyB.parent;
        
        bodyA = collision.bodyA;
        bodyB = collision.bodyB;

        // ensure normal is facing away from bodyA
        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
            collision.normal = {
                x: minOverlap.axis.x,
                y: minOverlap.axis.y
            };
        } else {
            collision.normal = {
                x: -minOverlap.axis.x,
                y: -minOverlap.axis.y
            };
        }

        collision.tangent = Vector.perp(collision.normal);

        collision.penetration = collision.penetration || {};
        collision.penetration.x = collision.normal.x * collision.depth;
        collision.penetration.y = collision.normal.y * collision.depth; 

        // find support points, there is always either exactly one or two
        var verticesB = _findSupports(bodyA, bodyB, collision.normal),
            supports = [];

        // find the supports from bodyB that are inside bodyA
        if (Vertices.contains(bodyA.vertices, verticesB[0]))
            supports.push(verticesB[0]);

        if (Vertices.contains(bodyA.vertices, verticesB[1]))
            supports.push(verticesB[1]);

        // find the supports from bodyA that are inside bodyB
        if (supports.length < 2) {
            var verticesA = _findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                
            if (Vertices.contains(bodyB.vertices, verticesA[0]))
                supports.push(verticesA[0]);

            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                supports.push(verticesA[1]);
        }

        // account for the edge case of overlapping but no vertex containment
        if (supports.length < 1)
            supports = [verticesB[0]];
        
        collision.supports = supports;

        return collision;
    };

    /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */
    var _overlapAxes = function(verticesA, verticesB, axes) {
        var projectionA = Vector._temp[0], 
            projectionB = Vector._temp[1],
            result = { overlap: Number.MAX_VALUE },
            overlap,
            axis;

        for (var i = 0; i < axes.length; i++) {
            axis = axes[i];

            _projectToAxis(projectionA, verticesA, axis);
            _projectToAxis(projectionB, verticesB, axis);

            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);

            if (overlap <= 0) {
                result.overlap = overlap;
                return result;
            }

            if (overlap < result.overlap) {
                result.overlap = overlap;
                result.axis = axis;
                result.axisNumber = i;
            }
        }

        return result;
    };

    /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */
    var _projectToAxis = function(projection, vertices, axis) {
        var min = Vector.dot(vertices[0], axis),
            max = min;

        for (var i = 1; i < vertices.length; i += 1) {
            var dot = Vector.dot(vertices[i], axis);

            if (dot > max) { 
                max = dot; 
            } else if (dot < min) { 
                min = dot; 
            }
        }

        projection.min = min;
        projection.max = max;
    };
    
    /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */
    var _findSupports = function(bodyA, bodyB, normal) {
        var nearestDistance = Number.MAX_VALUE,
            vertexToBody = Vector._temp[0],
            vertices = bodyB.vertices,
            bodyAPosition = bodyA.position,
            distance,
            vertex,
            vertexA,
            vertexB;

        // find closest vertex on bodyB
        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            distance = -Vector.dot(normal, vertexToBody);

            if (distance < nearestDistance) {
                nearestDistance = distance;
                vertexA = vertex;
            }
        }

        // find next closest vertex using the two connected to it
        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
        vertex = vertices[prevIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        nearestDistance = -Vector.dot(normal, vertexToBody);
        vertexB = vertex;

        var nextIndex = (vertexA.index + 1) % vertices.length;
        vertex = vertices[nextIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        distance = -Vector.dot(normal, vertexToBody);
        if (distance < nearestDistance) {
            vertexB = vertex;
        }

        return [vertexA, vertexB];
    };

})();


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/

var Mouse = {};

module.exports = Mouse;

var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */
    Mouse.create = function(element) {
        var mouse = {};

        if (!element) {
            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');
        }
        
        mouse.element = element || document.body;
        mouse.absolute = { x: 0, y: 0 };
        mouse.position = { x: 0, y: 0 };
        mouse.mousedownPosition = { x: 0, y: 0 };
        mouse.mouseupPosition = { x: 0, y: 0 };
        mouse.offset = { x: 0, y: 0 };
        mouse.scale = { x: 1, y: 1 };
        mouse.wheelDelta = 0;
        mouse.button = -1;
        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;

        mouse.sourceEvents = {
            mousemove: null,
            mousedown: null,
            mouseup: null,
            mousewheel: null
        };
        
        mouse.mousemove = function(event) { 
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.sourceEvents.mousemove = event;
        };
        
        mouse.mousedown = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            } else {
                mouse.button = event.button;
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mousedownPosition.x = mouse.position.x;
            mouse.mousedownPosition.y = mouse.position.y;
            mouse.sourceEvents.mousedown = event;
        };
        
        mouse.mouseup = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                event.preventDefault();
            }
            
            mouse.button = -1;
            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mouseupPosition.x = mouse.position.x;
            mouse.mouseupPosition.y = mouse.position.y;
            mouse.sourceEvents.mouseup = event;
        };

        mouse.mousewheel = function(event) {
            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            event.preventDefault();
        };

        Mouse.setElement(mouse, mouse.element);

        return mouse;
    };

    /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */
    Mouse.setElement = function(mouse, element) {
        mouse.element = element;

        element.addEventListener('mousemove', mouse.mousemove);
        element.addEventListener('mousedown', mouse.mousedown);
        element.addEventListener('mouseup', mouse.mouseup);
        
        element.addEventListener('mousewheel', mouse.mousewheel);
        element.addEventListener('DOMMouseScroll', mouse.mousewheel);

        element.addEventListener('touchmove', mouse.mousemove);
        element.addEventListener('touchstart', mouse.mousedown);
        element.addEventListener('touchend', mouse.mouseup);
    };

    /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */
    Mouse.clearSourceEvents = function(mouse) {
        mouse.sourceEvents.mousemove = null;
        mouse.sourceEvents.mousedown = null;
        mouse.sourceEvents.mouseup = null;
        mouse.sourceEvents.mousewheel = null;
        mouse.wheelDelta = 0;
    };

    /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */
    Mouse.setOffset = function(mouse, offset) {
        mouse.offset.x = offset.x;
        mouse.offset.y = offset.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };

    /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */
    Mouse.setScale = function(mouse, scale) {
        mouse.scale.x = scale.x;
        mouse.scale.y = scale.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };
    
    /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */
    var _getRelativeMousePosition = function(event, element, pixelRatio) {
        var elementBounds = element.getBoundingClientRect(),
            rootNode = (document.documentElement || document.body.parentNode || document.body),
            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,
            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,
            touches = event.changedTouches,
            x, y;
        
        if (touches) {
            x = touches[0].pageX - elementBounds.left - scrollX;
            y = touches[0].pageY - elementBounds.top - scrollY;
        } else {
            x = event.pageX - elementBounds.left - scrollX;
            y = event.pageY - elementBounds.top - scrollY;
        }

        return { 
            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
        };
    };

})();


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/

// TODO: true circle bodies

var Bodies = {};

module.exports = Bodies;

var Vertices = __webpack_require__(31);
var Common = __webpack_require__(2);
var Body = __webpack_require__(46);
var Bounds = __webpack_require__(12);
var Vector = __webpack_require__(13);
var decomp = __webpack_require__(207);

(function() {

    /**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */
    Bodies.rectangle = function(x, y, width, height, options) {
        options = options || {};

        var rectangle = { 
            label: 'Rectangle Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, rectangle, options));
    };
    
    /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */
    Bodies.trapezoid = function(x, y, width, height, slope, options) {
        options = options || {};

        slope *= 0.5;
        var roof = (1 - (slope * 2)) * width;
        
        var x1 = width * slope,
            x2 = x1 + roof,
            x3 = x2 + x1,
            verticesPath;

        if (slope < 0.5) {
            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        } else {
            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        }

        var trapezoid = { 
            label: 'Trapezoid Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(verticesPath)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, trapezoid, options));
    };

    /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */
    Bodies.circle = function(x, y, radius, options, maxSides) {
        options = options || {};

        var circle = {
            label: 'Circle Body',
            circleRadius: radius
        };
        
        // approximate circles with polygons until true circles implemented in SAT
        maxSides = maxSides || 25;
        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));

        // optimisation: always use even number of sides (half the number of unique axes)
        if (sides % 2 === 1)
            sides += 1;

        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    };

    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */
    Bodies.polygon = function(x, y, sides, radius, options) {
        options = options || {};

        if (sides < 3)
            return Bodies.circle(x, y, radius, options);

        var theta = 2 * Math.PI / sides,
            path = '',
            offset = theta * 0.5;

        for (var i = 0; i < sides; i += 1) {
            var angle = offset + (i * theta),
                xx = Math.cos(angle) * radius,
                yy = Math.sin(angle) * radius;

            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
        }

        var polygon = { 
            label: 'Polygon Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(path)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, polygon, options));
    };

    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */
    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
        var body,
            parts,
            isConvex,
            vertices,
            i,
            j,
            k,
            v,
            z;

        options = options || {};
        parts = [];

        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;
        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;
        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;

        if (!decomp) {
            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');
        }

        // ensure vertexSets is an array of arrays
        if (!Common.isArray(vertexSets[0])) {
            vertexSets = [vertexSets];
        }

        for (v = 0; v < vertexSets.length; v += 1) {
            vertices = vertexSets[v];
            isConvex = Vertices.isConvex(vertices);

            if (isConvex || !decomp) {
                if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                } else {
                    // fallback to convex hull when decomposition is not possible
                    vertices = Vertices.hull(vertices);
                }

                parts.push({
                    position: { x: x, y: y },
                    vertices: vertices
                });
            } else {
                // initialise a decomposition
                var concave = vertices.map(function(vertex) {
                    return [vertex.x, vertex.y];
                });

                // vertices are concave and simple, we can decompose into parts
                decomp.makeCCW(concave);
                if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);

                // use the quick decomposition algorithm (Bayazit)
                var decomposed = decomp.quickDecomp(concave);

                // for each decomposed chunk
                for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];

                    // convert vertices into the correct structure
                    var chunkVertices = chunk.map(function(vertices) {
                        return {
                            x: vertices[0],
                            y: vertices[1]
                        };
                    });

                    // skip small chunks
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                        continue;

                    // create a compound part
                    parts.push({
                        position: Vertices.centre(chunkVertices),
                        vertices: chunkVertices
                    });
                }
            }
        }

        // create body parts
        for (i = 0; i < parts.length; i++) {
            parts[i] = Body.create(Common.extend(parts[i], options));
        }

        // flag internal edges (coincident part edges)
        if (flagInternal) {
            var coincident_max_dist = 5;

            for (i = 0; i < parts.length; i++) {
                var partA = parts[i];

                for (j = i + 1; j < parts.length; j++) {
                    var partB = parts[j];

                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices,
                            pbv = partB.vertices;

                        // iterate vertices of both parts
                        for (k = 0; k < partA.vertices.length; k++) {
                            for (z = 0; z < partB.vertices.length; z++) {
                                // find distances between the vertices
                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),
                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));

                                // if both vertices are very close, consider the edge concident (internal)
                                if (da < coincident_max_dist && db < coincident_max_dist) {
                                    pav[k].isInternal = true;
                                    pbv[z].isInternal = true;
                                }
                            }
                        }

                    }
                }
            }
        }

        if (parts.length > 1) {
            // create the parent body to be returned, that contains generated compound parts
            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));
            Body.setPosition(body, { x: x, y: y });

            return body;
        } else {
            return parts[0];
        }
    };

})();


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/

var Axes = {};

module.exports = Axes;

var Vector = __webpack_require__(13);
var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */
    Axes.fromVertices = function(vertices) {
        var axes = {};

        // find the unique axes, using edge normal gradients
        for (var i = 0; i < vertices.length; i++) {
            var j = (i + 1) % vertices.length, 
                normal = Vector.normalise({ 
                    x: vertices[j].y - vertices[i].y, 
                    y: vertices[i].x - vertices[j].x
                }),
                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);
            
            // limit precision
            gradient = gradient.toFixed(3).toString();
            axes[gradient] = normal;
        }

        return Common.values(axes);
    };

    /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */
    Axes.rotate = function(axes, angle) {
        if (angle === 0)
            return;
        
        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i],
                xx;
            xx = axis.x * cos - axis.y * sin;
            axis.y = axis.x * sin + axis.y * cos;
            axis.x = xx;
        }
    };

})();


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/

var Render = {};

module.exports = Render;

var Common = __webpack_require__(2);
var Composite = __webpack_require__(29);
var Bounds = __webpack_require__(12);
var Events = __webpack_require__(30);
var Grid = __webpack_require__(90);
var Vector = __webpack_require__(13);
var Mouse = __webpack_require__(92);

(function() {
    
    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */
    Render.create = function(options) {
        var defaults = {
            controller: Render,
            engine: null,
            element: null,
            canvas: null,
            mouse: null,
            frameRequestId: null,
            options: {
                width: 800,
                height: 600,
                pixelRatio: 1,
                background: '#18181d',
                wireframeBackground: '#0f0f13',
                hasBounds: !!options.bounds,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showSeparations: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false,
                showVertexNumbers: false,
                showConvexHulls: false,
                showInternalEdges: false,
                showMousePosition: false
            }
        };

        var render = Common.extend(defaults, options);

        if (render.canvas) {
            render.canvas.width = render.options.width || render.canvas.width;
            render.canvas.height = render.options.height || render.canvas.height;
        }

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
        render.context = render.canvas.getContext('2d');
        render.textures = {};

        render.bounds = render.bounds || { 
            min: { 
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.canvas.width,
                y: render.canvas.height
            }
        };

        if (render.options.pixelRatio !== 1) {
            Render.setPixelRatio(render, render.options.pixelRatio);
        }

        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');
        }

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */
    Render.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            Render.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */
    Render.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */
    Render.setPixelRatio = function(render, pixelRatio) {
        var options = render.options,
            canvas = render.canvas;

        if (pixelRatio === 'auto') {
            pixelRatio = _getPixelRatio(canvas);
        }

        options.pixelRatio = pixelRatio;
        canvas.setAttribute('data-pixel-ratio', pixelRatio);
        canvas.width = options.width * pixelRatio;
        canvas.height = options.height * pixelRatio;
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
        render.context.scale(pixelRatio, pixelRatio);
    };

    /**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */
    Render.lookAt = function(render, objects, padding, center) {
        center = typeof center !== 'undefined' ? center : true;
        objects = Common.isArray(objects) ? objects : [objects];
        padding = padding || {
            x: 0,
            y: 0
        };

        // find bounds of all objects
        var bounds = {
            min: { x: Infinity, y: Infinity },
            max: { x: -Infinity, y: -Infinity }
        };

        for (var i = 0; i < objects.length; i += 1) {
            var object = objects[i],
                min = object.bounds ? object.bounds.min : (object.min || object.position || object),
                max = object.bounds ? object.bounds.max : (object.max || object.position || object); 

            if (min && max) { 
                if (min.x < bounds.min.x) 
                    bounds.min.x = min.x;
                    
                if (max.x > bounds.max.x) 
                    bounds.max.x = max.x;

                if (min.y < bounds.min.y) 
                    bounds.min.y = min.y;

                if (max.y > bounds.max.y) 
                    bounds.max.y = max.y;
            }
        }

        // find ratios
        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,
            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,
            viewHeight = render.canvas.height,
            viewWidth = render.canvas.width,
            outerRatio = viewWidth / viewHeight,
            innerRatio = width / height,
            scaleX = 1,
            scaleY = 1;

        // find scale factor
        if (innerRatio > outerRatio) {
            scaleY = innerRatio / outerRatio;
        } else {
            scaleX = outerRatio / innerRatio;
        }

        // enable bounds
        render.options.hasBounds = true;

        // position and size
        render.bounds.min.x = bounds.min.x;
        render.bounds.max.x = bounds.min.x + width * scaleX;
        render.bounds.min.y = bounds.min.y;
        render.bounds.max.y = bounds.min.y + height * scaleY;

        // center
        if (center) {
            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;
            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;
        }

        // padding
        render.bounds.min.x -= padding.x;
        render.bounds.max.x -= padding.x;
        render.bounds.min.y -= padding.y;
        render.bounds.max.y -= padding.y;

        // update mouse
        if (render.mouse) {
            Mouse.setScale(render.mouse, {
                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
            });

            Mouse.setOffset(render.mouse, render.bounds.min);
        }
    };

    /**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */
    Render.startViewTransform = function(render) {
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        render.context.scale(1 / boundsScaleX, 1 / boundsScaleY);
        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
    };

    /**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */
    Render.endViewTransform = function(render) {
        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
    };

    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */
    Render.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            canvas = render.canvas,
            context = render.context,
            options = render.options,
            allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            background = options.wireframes ? options.wireframeBackground : options.background,
            bodies = [],
            constraints = [],
            i;

        var event = {
            timestamp: engine.timing.timestamp
        };

        Events.trigger(render, 'beforeRender', event);

        // apply background if it has changed
        if (render.currentBackground !== background)
            _applyBackground(render, background);

        // clear the canvas with a transparent fill, to allow the canvas background to show
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = "transparent";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.globalCompositeOperation = 'source-over';

        // handle bounds
        if (options.hasBounds) {
            // filter out bodies that are not in view
            for (i = 0; i < allBodies.length; i++) {
                var body = allBodies[i];
                if (Bounds.overlaps(body.bounds, render.bounds))
                    bodies.push(body);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            Render.startViewTransform(render);

            // update mouse
            if (render.mouse) {
                Mouse.setScale(render.mouse, {
                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                });

                Mouse.setOffset(render.mouse, render.bounds.min);
            }
        } else {
            constraints = allConstraints;
            bodies = allBodies;
        }

        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {
            // fully featured rendering of bodies
            Render.bodies(render, bodies, context);
        } else {
            if (options.showConvexHulls)
                Render.bodyConvexHulls(render, bodies, context);

            // optimised method for wireframes only
            Render.bodyWireframes(render, bodies, context);
        }

        if (options.showBounds)
            Render.bodyBounds(render, bodies, context);

        if (options.showAxes || options.showAngleIndicator)
            Render.bodyAxes(render, bodies, context);
        
        if (options.showPositions)
            Render.bodyPositions(render, bodies, context);

        if (options.showVelocity)
            Render.bodyVelocity(render, bodies, context);

        if (options.showIds)
            Render.bodyIds(render, bodies, context);

        if (options.showSeparations)
            Render.separations(render, engine.pairs.list, context);

        if (options.showCollisions)
            Render.collisions(render, engine.pairs.list, context);

        if (options.showVertexNumbers)
            Render.vertexNumbers(render, bodies, context);

        if (options.showMousePosition)
            Render.mousePosition(render, render.mouse, context);

        Render.constraints(constraints, context);

        if (options.showBroadphase && engine.broadphase.controller === Grid)
            Render.grid(render, engine.broadphase, context);

        if (options.showDebug)
            Render.debug(render, context);

        if (options.hasBounds) {
            // revert view transforms
            Render.endViewTransform(render);
        }

        Events.trigger(render, 'afterRender', event);
    };

    /**
     * Description
     * @private
     * @method debug
     * @param {render} render
     * @param {RenderingContext} context
     */
    Render.debug = function(render, context) {
        var c = context,
            engine = render.engine,
            world = engine.world,
            metrics = engine.metrics,
            options = render.options,
            bodies = Composite.allBodies(world),
            space = "    ";

        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
            var text = "";

            if (metrics.timing) {
                text += "fps: " + Math.round(metrics.timing.fps) + space;
            }

            // @if DEBUG
            if (metrics.extended) {
                if (metrics.timing) {
                    text += "delta: " + metrics.timing.delta.toFixed(3) + space;
                    text += "correction: " + metrics.timing.correction.toFixed(3) + space;
                }

                text += "bodies: " + bodies.length + space;

                if (engine.broadphase.controller === Grid)
                    text += "buckets: " + metrics.buckets + space;

                text += "\n";

                text += "collisions: " + metrics.collisions + space;
                text += "pairs: " + engine.pairs.list.length + space;
                text += "broad: " + metrics.broadEff + space;
                text += "mid: " + metrics.midEff + space;
                text += "narrow: " + metrics.narrowEff + space;
            }
            // @endif            

            render.debugString = text;
            render.debugTimestamp = engine.timing.timestamp;
        }

        if (render.debugString) {
            c.font = "12px Arial";

            if (options.wireframes) {
                c.fillStyle = 'rgba(255,255,255,0.5)';
            } else {
                c.fillStyle = 'rgba(0,0,0,0.5)';
            }

            var split = render.debugString.split('\n');

            for (var i = 0; i < split.length; i++) {
                c.fillText(split[i], 50, 50 + i * 18);
            }
        }
    };

    /**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */
    Render.constraints = function(constraints, context) {
        var c = context;

        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];

            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                continue;

            var bodyA = constraint.bodyA,
                bodyB = constraint.bodyB;

            if (bodyA) {
                c.beginPath();
                c.moveTo(bodyA.position.x + constraint.pointA.x, bodyA.position.y + constraint.pointA.y);
            } else {
                c.beginPath();
                c.moveTo(constraint.pointA.x, constraint.pointA.y);
            }

            if (bodyB) {
                c.lineTo(bodyB.position.x + constraint.pointB.x, bodyB.position.y + constraint.pointB.y);
            } else {
                c.lineTo(constraint.pointB.x, constraint.pointB.y);
            }

            if (constraint.render.lineWidth) {
                c.lineWidth = constraint.render.lineWidth;
                c.strokeStyle = constraint.render.strokeStyle;
                c.stroke();
            }
        }
    };
    
    /**
     * Description
     * @private
     * @method bodyShadows
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyShadows = function(render, bodies, context) {
        var c = context,
            engine = render.engine;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            if (body.circleRadius) {
                c.beginPath();
                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                c.closePath();
            } else {
                c.beginPath();
                c.moveTo(body.vertices[0].x, body.vertices[0].y);
                for (var j = 1; j < body.vertices.length; j++) {
                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                }
                c.closePath();
            }

            var distanceX = body.position.x - render.options.width * 0.5,
                distanceY = body.position.y - render.options.height * 0.2,
                distance = Math.abs(distanceX) + Math.abs(distanceY);

            c.shadowColor = 'rgba(0,0,0,0.15)';
            c.shadowOffsetX = 0.05 * distanceX;
            c.shadowOffsetY = 0.05 * distanceY;
            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);

            c.fill();

            c.shadowColor = null;
            c.shadowOffsetX = null;
            c.shadowOffsetY = null;
            c.shadowBlur = null;
        }
    };

    /**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodies = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            showInternalEdges = options.showInternalEdges || !options.wireframes,
            body,
            part,
            i,
            k;

        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                if (!part.render.visible)
                    continue;

                if (options.showSleeping && body.isSleeping) {
                    c.globalAlpha = 0.5 * part.render.opacity;
                } else if (part.render.opacity !== 1) {
                    c.globalAlpha = part.render.opacity;
                }

                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    // part sprite
                    var sprite = part.render.sprite,
                        texture = _getTexture(render, sprite.texture);

                    c.translate(part.position.x, part.position.y); 
                    c.rotate(part.angle);

                    c.drawImage(
                        texture,
                        texture.width * -sprite.xOffset * sprite.xScale, 
                        texture.height * -sprite.yOffset * sprite.yScale, 
                        texture.width * sprite.xScale, 
                        texture.height * sprite.yScale
                    );

                    // revert translation, hopefully faster than save / restore
                    c.rotate(-part.angle);
                    c.translate(-part.position.x, -part.position.y); 
                } else {
                    // part polygon
                    if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);

                        for (var j = 1; j < part.vertices.length; j++) {
                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                            } else {
                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                            }

                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                            }
                        }
                        
                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                    }

                    if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;

                        if (part.render.lineWidth) {
                            c.lineWidth = part.render.lineWidth;
                            c.strokeStyle = part.render.strokeStyle;
                            c.stroke();
                        }

                        c.fill();
                    } else {
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    }
                }

                c.globalAlpha = 1;
            }
        }
    };

    /**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyWireframes = function(render, bodies, context) {
        var c = context,
            showInternalEdges = render.options.showInternalEdges,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render all bodies
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                c.moveTo(part.vertices[0].x, part.vertices[0].y);

                for (j = 1; j < part.vertices.length; j++) {
                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                    } else {
                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                    }

                    if (part.vertices[j].isInternal && !showInternalEdges) {
                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                    }
                }
                
                c.lineTo(part.vertices[0].x, part.vertices[0].y);
            }
        }

        c.lineWidth = 1;
        c.strokeStyle = '#bbb';
        c.stroke();
    };

    /**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyConvexHulls = function(render, bodies, context) {
        var c = context,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render convex hulls
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible || body.parts.length === 1)
                continue;

            c.moveTo(body.vertices[0].x, body.vertices[0].y);

            for (j = 1; j < body.vertices.length; j++) {
                c.lineTo(body.vertices[j].x, body.vertices[j].y);
            }
            
            c.lineTo(body.vertices[0].x, body.vertices[0].y);
        }

        c.lineWidth = 1;
        c.strokeStyle = 'rgba(255,255,255,0.2)';
        c.stroke();
    };

    /**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.vertexNumbers = function(render, bodies, context) {
        var c = context,
            i,
            j,
            k;

        for (i = 0; i < bodies.length; i++) {
            var parts = bodies[i].parts;
            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {
                var part = parts[k];
                for (j = 0; j < part.vertices.length; j++) {
                    c.fillStyle = 'rgba(255,255,255,0.2)';
                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                }
            }
        }
    };

    /**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */
    Render.mousePosition = function(render, mouse, context) {
        var c = context;
        c.fillStyle = 'rgba(255,255,255,0.8)';
        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
    };

    /**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyBounds = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.render.visible) {
                var parts = bodies[i].parts;
                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,255,255,0.08)';
        } else {
            c.strokeStyle = 'rgba(0,0,0,0.1)';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyAxes = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            part,
            i,
            j,
            k;

        c.beginPath();

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                parts = body.parts;

            if (!body.render.visible)
                continue;

            if (options.showAxes) {
                // render all axes
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                }
            } else {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        // render a single axis indicator
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2, 
                                 (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);
                    }
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'indianred';
            c.lineWidth = 1;
        } else {
            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            c.globalCompositeOperation = 'overlay';
            c.lineWidth = 2;
        }

        c.stroke();
        c.globalCompositeOperation = 'source-over';
    };

    /**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyPositions = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            body,
            part,
            i,
            k;

        c.beginPath();

        // render current positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = 0; k < body.parts.length; k++) {
                part = body.parts[k];
                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'indianred';
        } else {
            c.fillStyle = 'rgba(0,0,0,0.5)';
        }
        c.fill();

        c.beginPath();

        // render previous positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];
            if (body.render.visible) {
                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        c.fillStyle = 'rgba(255,165,0,0.8)';
        c.fill();
    };

    /**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyVelocity = function(render, bodies, context) {
        var c = context;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            c.moveTo(body.position.x, body.position.y);
            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
        }

        c.lineWidth = 3;
        c.strokeStyle = 'cornflowerblue';
        c.stroke();
    };

    /**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyIds = function(render, bodies, context) {
        var c = context,
            i,
            j;

        for (i = 0; i < bodies.length; i++) {
            if (!bodies[i].render.visible)
                continue;

            var parts = bodies[i].parts;
            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                var part = parts[j];
                c.font = "12px Arial";
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.fillText(part.id, part.position.x + 10, part.position.y - 10);
            }
        }
    };

    /**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.collisions = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render collision positions
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            for (j = 0; j < pair.activeContacts.length; j++) {
                var contact = pair.activeContacts[j],
                    vertex = contact.vertex;
                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'rgba(255,255,255,0.7)';
        } else {
            c.fillStyle = 'orange';
        }
        c.fill();

        c.beginPath();
            
        // render collision normals
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;

            if (pair.activeContacts.length > 0) {
                var normalPosX = pair.activeContacts[0].vertex.x,
                    normalPosY = pair.activeContacts[0].vertex.y;

                if (pair.activeContacts.length === 2) {
                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                }
                
                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                } else {
                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                }

                c.lineTo(normalPosX, normalPosY);
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.7)';
        } else {
            c.strokeStyle = 'orange';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.separations = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render separations
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            bodyA = collision.bodyA;
            bodyB = collision.bodyB;

            var k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyB.isStatic) k = 0;

            c.moveTo(bodyB.position.x, bodyB.position.y);
            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);

            k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyA.isStatic) k = 0;

            c.moveTo(bodyA.position.x, bodyA.position.y);
            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.5)';
        } else {
            c.strokeStyle = 'orange';
        }
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */
    Render.grid = function(render, grid, context) {
        var c = context,
            options = render.options;

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,180,0,0.1)';
        } else {
            c.strokeStyle = 'rgba(255,180,0,0.5)';
        }

        c.beginPath();

        var bucketKeys = Common.keys(grid.buckets);

        for (var i = 0; i < bucketKeys.length; i++) {
            var bucketId = bucketKeys[i];

            if (grid.buckets[bucketId].length < 2)
                continue;

            var region = bucketId.split(/C|R/);
            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth, 
                    0.5 + parseInt(region[2], 10) * grid.bucketHeight, 
                    grid.bucketWidth, 
                    grid.bucketHeight);
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */
    Render.inspector = function(inspector, context) {
        var engine = inspector.engine,
            selected = inspector.selected,
            render = inspector.render,
            options = render.options,
            bounds;

        if (options.hasBounds) {
            var boundsWidth = render.bounds.max.x - render.bounds.min.x,
                boundsHeight = render.bounds.max.y - render.bounds.min.y,
                boundsScaleX = boundsWidth / render.options.width,
                boundsScaleY = boundsHeight / render.options.height;
            
            context.scale(1 / boundsScaleX, 1 / boundsScaleY);
            context.translate(-render.bounds.min.x, -render.bounds.min.y);
        }

        for (var i = 0; i < selected.length; i++) {
            var item = selected[i].data;

            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.9)';
            context.setLineDash([1,2]);

            switch (item.type) {

            case 'body':

                // render body selections
                bounds = item.bounds;
                context.beginPath();
                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), 
                             Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                context.closePath();
                context.stroke();

                break;

            case 'constraint':

                // render constraint selections
                var point = item.pointA;
                if (item.bodyA)
                    point = item.pointB;
                context.beginPath();
                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                context.closePath();
                context.stroke();

                break;

            }

            context.setLineDash([]);
            context.translate(-0.5, -0.5);
        }

        // render selection region
        if (inspector.selectStart !== null) {
            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.6)';
            context.fillStyle = 'rgba(255,165,0,0.1)';
            bounds = inspector.selectBounds;
            context.beginPath();
            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), 
                         Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
            context.closePath();
            context.stroke();
            context.fill();
            context.translate(-0.5, -0.5);
        }

        if (options.hasBounds)
            context.setTransform(1, 0, 0, 1, 0, 0);
    };

    /**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */
    var _createCanvas = function(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.oncontextmenu = function() { return false; };
        canvas.onselectstart = function() { return false; };
        return canvas;
    };

    /**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */
    var _getPixelRatio = function(canvas) {
        var context = canvas.getContext('2d'),
            devicePixelRatio = window.devicePixelRatio || 1,
            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio
                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio
                                      || context.backingStorePixelRatio || 1;

        return devicePixelRatio / backingStorePixelRatio;
    };

    /**
     * Gets the requested texture (an Image) via its path
     * @method _getTexture
     * @private
     * @param {render} render
     * @param {string} imagePath
     * @return {Image} texture
     */
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };

    /**
     * Applies the background to the canvas using CSS.
     * @method applyBackground
     * @private
     * @param {render} render
     * @param {string} background
     */
    var _applyBackground = function(render, background) {
        var cssBackground = background;

        if (/(jpg|gif|png)$/.test(background))
            cssBackground = 'url(' + background + ')';

        render.canvas.style.background = cssBackground;
        render.canvas.style.backgroundSize = "contain";
        render.currentBackground = background;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */

    /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */

    /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */

    /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */

    /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */

    /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */

    /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */

    /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */

    /**
     * A `Bounds` object that specifies the drawing view region. 
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */

    /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */

    /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */

})();


/***/ }),
/* 96 */
/***/ (function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.set(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i], i) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

//  Shallow Object Clone. Will not clone nested objects.

var Clone = function (obj)
{
    var clone = {};

    for (var key in obj)
    {
        if (Array.isArray(obj[key]))
        {
            clone[key] = obj[key].slice(0);
        }
        else
        {
            clone[key] = obj[key];
        }
    }

    return clone;
};

module.exports = Clone;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Actions

module.exports = {

    Angle: __webpack_require__(244),
    Call: __webpack_require__(245),
    GetFirst: __webpack_require__(246),
    GridAlign: __webpack_require__(247),
    IncAlpha: __webpack_require__(248),
    IncX: __webpack_require__(249),
    IncXY: __webpack_require__(250),
    IncY: __webpack_require__(251),
    PlaceOnCircle: __webpack_require__(252),
    PlaceOnLine: __webpack_require__(253),
    PlaceOnRectangle: __webpack_require__(254),
    PlaceOnTriangle: __webpack_require__(255),
    PlayAnimation: __webpack_require__(256),
    RandomCircle: __webpack_require__(257),
    RandomEllipse: __webpack_require__(258),
    RandomLine: __webpack_require__(259),
    RandomRectangle: __webpack_require__(260),
    RandomTriangle: __webpack_require__(261),
    Rotate: __webpack_require__(262),
    RotateAround: __webpack_require__(263),
    RotateAroundDistance: __webpack_require__(264),
    ScaleX: __webpack_require__(265),
    ScaleXY: __webpack_require__(266),
    ScaleY: __webpack_require__(267),
    SetAlpha: __webpack_require__(268),
    SetOrigin: __webpack_require__(269),
    SetRotation: __webpack_require__(270),
    SetScale: __webpack_require__(271),
    SetScaleX: __webpack_require__(272),
    SetScaleY: __webpack_require__(273),
    SetVisible: __webpack_require__(274),
    SetX: __webpack_require__(275),
    SetXY: __webpack_require__(276),
    SetY: __webpack_require__(277),
    ShiftPosition: __webpack_require__(278),
    SmootherStep: __webpack_require__(280),
    SmoothStep: __webpack_require__(279),
    Spread: __webpack_require__(281),
    ToggleVisible: __webpack_require__(282)

};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Systems = __webpack_require__(211);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The State Systems. You must never overwrite this property, or all hell will break lose.
    this.sys = new Systems(this, config);

    this.settings = this.sys.settings;
};

State.prototype.constructor = State;

State.prototype = {

    //  Should be overridden by your own States
    update: function ()
    {
    },

    //  Should be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var Frame = __webpack_require__(288);
var GetValue = __webpack_require__(0);

var GetFrames = function (textureManager, frames)
{
    //      frames: [
    //          { key: textureKey, frame: textureFrame },
    //          { key: textureKey, frame: textureFrame, duration: float },
    //          { key: textureKey, frame: textureFrame, onUpdate: function }
    //          { key: textureKey, frame: textureFrame, visible: boolean }
    //      ],

    var out = [];
    var prev;
    var animationFrame;
    var index = 1;
    var i;
    var textureKey;

    //  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet
    if (typeof frames === 'string')
    {
        textureKey = frames;

        var texture = textureManager.get(textureKey);
        var frameKeys = texture.getFrameNames();

        frames = [];

        frameKeys.forEach(function (idx, value) {
            frames.push({ key: textureKey, frame: value });
        });
    }

    // console.table(frames);

    if (!Array.isArray(frames) || frames.length === 0)
    {
        return out;
    }

    for (i = 0; i < frames.length; i++)
    {
        var item = frames[i];

        var key = GetValue(item, 'key', null);

        if (!key)
        {
            continue;
        }

        var frame = GetValue(item, 'frame', 0);

        var textureFrame = textureManager.getFrame(key, frame);

        animationFrame = new Frame(key, frame, index, textureFrame);

        animationFrame.duration = GetValue(item, 'duration', 0);
        animationFrame.onUpdate = GetValue(item, 'onUpdate', null);

        var visible = GetValue(item, 'visible', null);

        if (visible !== null)
        {
            animationFrame.setVisible = true;
            animationFrame.visible = visible;
        }

        animationFrame.isFirst = (!prev);

        //  The previously created animationFrame
        if (prev)
        {
            prev.nextFrame = animationFrame;

            animationFrame.prevFrame = prev;
        }

        out.push(animationFrame);

        prev = animationFrame;

        index++;
    }

    if (out.length > 0)
    {
        animationFrame.isLast = true;

        //  Link them end-to-end, so they loop
        animationFrame.nextFrame = out[0];

        out[0].prevFrame = animationFrame;

        //  Generate the progress data

        var slice = 1 / (out.length - 1);

        for (i = 0; i < out.length; i++)
        {
            out[i].progress = i * slice;
        }
    }

    return out;
};

module.exports = GetFrames;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);
var TransformMatrix = __webpack_require__(16);

var Camera = function (x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.roundPixels = false;
    this.useBounds = false;

    this._bounds = new Rectangle();

    this.scrollX = 0.0;
    this.scrollY = 0.0;
    this.zoom = 1.0;
    this.rotation = 0.0;
    this.matrix = new TransformMatrix(1, 0, 0, 1, 0, 0);

    // shake
    this._shakeDuration = 0.0;
    this._shakeIntensity = 0.0;
    this._shakeOffsetX = 0.0;
    this._shakeOffsetY = 0.0;

    // fade
    this._fadeDuration = 0.0;
    this._fadeRed = 0.0;
    this._fadeGreen = 0.0;
    this._fadeBlue = 0.0;
    this._fadeAlpha = 0.0;

    // flash
    this._flashDuration = 0.0;
    this._flashRed = 1.0;
    this._flashGreen = 1.0;
    this._flashBlue = 1.0;
    this._flashAlpha = 0.0;

    // origin
    this._follow = null;
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    removeBounds: function ()
    {
        this.useBounds = false;

        this._bounds.setEmpty();

        return this;
    },

    setBounds: function (x, y, width, height)
    {
        this._bounds.setTo(x, y, width, height);

        this.useBounds = true;

        return this;
    },

    setViewport: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    },

    setState: function (state)
    {
        this.state = state;

        return this;
    },

    update: function (timestep, delta)
    {
        if (this._flashAlpha > 0.0)
        {
            this._flashAlpha -= delta / this._flashDuration;

            if (this._flashAlpha < 0.0)
            {
                this._flashAlpha = 0.0;
            }
        }

        if (this._fadeAlpha > 0.0 && this._fadeAlpha < 1.0)
        {
            this._fadeAlpha += delta / this._fadeDuration;

            if (this._fadeAlpha >= 1.0)
            {
                this._fadeAlpha = 1.0;
            }
        }

        if (this._shakeDuration > 0.0)
        {
            var intensity = this._shakeIntensity;

            this._shakeDuration -= delta;

            if (this._shakeDuration <= 0.0)
            {
                this._shakeOffsetX = 0.0;
                this._shakeOffsetY = 0.0;
            }
            else
            {
                this._shakeOffsetX = (Math.random() * intensity * this.width * 2 - intensity * this.width) * this.zoom;
                this._shakeOffsetY = (Math.random() * intensity * this.height * 2 - intensity * this.height) * this.zoom;
            }
        }
    },

    startFollow: function (gameObjectOrPoint, roundPx)
    {
        if (this._follow !== null)
        {
            this.stopFollow();
        }

        this._follow = gameObjectOrPoint;

        if (roundPx !== undefined)
        {
            this.roundPixels = roundPx;
        }
    },

    stopFollow: function ()
    {
        /* do unfollow work here */
        this._follow = null;
    },

    flash: function (duration, red, green, blue, force)
    {
        if (!force && this._flashAlpha > 0.0)
        {
            return;
        }

        if (red === undefined) { red = 1.0; }
        if (green === undefined) { green = 1.0; }
        if (blue === undefined) { blue = 1.0; }

        this._flashRed = red;
        this._flashGreen = green;
        this._flashBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._flashDuration = duration;
        this._flashAlpha = 1.0;
    },

    fade: function (duration, red, green, blue, force)
    {
        if (red === undefined) { red = 0.0; }
        if (green === undefined) { green = 0.0; }
        if (blue === undefined) { blue = 0.0; }

        if (!force && this._fadeAlpha > 0.0)
        {
            return;
        }

        this._fadeRed = red;
        this._fadeGreen = green;
        this._fadeBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._fadeDuration = duration;
        this._fadeAlpha = Number.MIN_VALUE;
    },

    shake: function (duration, intensity, force)
    {
        if (intensity === undefined) { intensity = 0.05; }

        if (!force && (this._shakeOffsetX !== 0.0 || this._shakeOffsetY !== 0.0))
        {
            return;
        }

        this._shakeDuration = duration;
        this._shakeIntensity = intensity;
        this._shakeOffsetX = 0;
        this._shakeOffsetY = 0;
    },

    preRender: function ()
    {
        var width = this.width;
        var height = this.height;
        var zoom = this.zoom;
        var matrix = this.matrix;
        var originX = width / 2;
        var originY = height / 2;
        var follow = this._follow;

        if (follow !== null)
        {
            originX = follow.x;
            originY = follow.y;
            
            this.scrollX = originX - width * 0.5;
            this.scrollY = originY - height * 0.5;
        }

        if (this.useBounds)
        {
            var bounds = this._bounds;
            var boundsX = bounds.x;
            var boundsY = bounds.y;
            var boundsR = Math.max(bounds.right - width, width);
            var boundsB = Math.max(bounds.bottom - height, height);

            if (this.scrollX < boundsX)
            {
                this.scrollX = boundsX;
            }
            if (this.scrollX > boundsR)
            {
                this.scrollX = boundsR;
            }

            if (this.scrollY < boundsY)
            {
                this.scrollY = boundsY;
            }
            if (this.scrollY > boundsB)
            {
                this.scrollY = boundsB;
            }
        }

        if (this.roundPixels)
        {
            this.scrollX = Math.round(this.scrollX);
            this.scrollY = Math.round(this.scrollY);
        }

        matrix.loadIdentity();
        matrix.translate(this.x + originX, this.y + originY);
        matrix.rotate(this.rotation);
        matrix.scale(zoom, zoom);
        matrix.translate(-originX, -originY);
        matrix.translate(this._shakeOffsetX, this._shakeOffsetY);
    },

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = Camera;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

var GetContext = function (canvas, options)
{
    return (
        canvas.getContext('2d', options) || 
        null
    );
};

module.exports = GetContext;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Event = __webpack_require__(5);
var EventDispatcher = __webpack_require__(15);

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.events = new EventDispatcher();

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        // this.events.dispatch(new Event.LOADER_START_EVENT(this));

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var Arne16 = __webpack_require__(106);
var CanvasPool = __webpack_require__(9);

var GenerateTexture = function (config)
{
    var data = GetValue(config, 'data', []);
    var canvas = GetValue(config, 'canvas', null);
    var palette = GetValue(config, 'palette', Arne16);
    var pixelWidth = GetValue(config, 'pixelWidth', 1);
    var pixelHeight = GetValue(config, 'pixelHeight', pixelWidth);
    var resizeCanvas = GetValue(config, 'resizeCanvas', true);
    var clearCanvas = GetValue(config, 'clearCanvas', true);
    var preRender = GetValue(config, 'preRender', null);
    var postRender = GetValue(config, 'postRender', null);

    var width = Math.floor(Math.abs(data[0].length * pixelWidth));
    var height = Math.floor(Math.abs(data.length * pixelHeight));

    if (!canvas)
    {
        canvas = CanvasPool.create2D(this, width, height);
        resizeCanvas = false;
        clearCanvas = false;
    }

    if (resizeCanvas)
    {
        canvas.width = width;
        canvas.height = height;
    }

    var ctx = canvas.getContext('2d');

    if (clearCanvas)
    {
        ctx.clearRect(0, 0, width, height);
    }

    //  preRender Callback?
    if (preRender)
    {
        preRender(canvas, ctx);
    }

    //  Draw it
    for (var y = 0; y < data.length; y++)
    {
        var row = data[y];

        for (var x = 0; x < row.length; x++)
        {
            var d = row[x];

            if (d !== '.' && d !== ' ')
            {
                ctx.fillStyle = palette[d];
                ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
            }
        }
    }

    //  postRender Callback?
    if (postRender)
    {
        postRender(canvas, ctx);
    }

    return canvas;
};

module.exports = GenerateTexture;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

/**
* A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)
* @constant
* @type {Array}
*/

module.exports = {
    0: '#000', 
    1: '#9D9D9D', 
    2: '#FFF', 
    3: '#BE2633', 
    4: '#E06F8B', 
    5: '#493C2B', 
    6: '#A46422', 
    7: '#EB8931', 
    8: '#F7E26B', 
    9: '#2F484E', 
    A: '#44891A', 
    B: '#A3CE27', 
    C: '#1B2632', 
    D: '#005784', 
    E: '#31A2F2', 
    F: '#B2DCEF'
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(9);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();
    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    var yellow = new Image();
    yellow.src = pngHead + '/wCKxvRF' + pngEnd;

    var canvas = CanvasPool.create(this, 6, 1);
    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    if (!context.getImageData(2, 0, 1, 1))
    {
        return false;
    }

    var data = context.getImageData(2, 0, 1, 1).data;

    CanvasPool.remove(this);

    return (data[0] === 255 && data[1] === 0 && data[2] === 0);
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);
var CanvasPool = __webpack_require__(9);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = true;//testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ }),
/* 109 */
/***/ (function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(26);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var NOOP = __webpack_require__(60);

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
var RequestAnimationFrame = function ()
{
    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.callback = NOOP;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.callback(timestamp);

        _this.timeOutID = window.requestAnimationFrame(step);
    };

    var stepTimeout = function ()
    {
        var d = Date.now();

        _this.tick = d;

        _this.callback(d);

        _this.timeOutID = window.setTimeout(stepTimeout, _this.timeToCall);
    };

    this.step = step;
    this.stepTimeout = stepTimeout;
};

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

RequestAnimationFrame.prototype = {

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    start: function (callback, forceSetTimeOut)
    {
        this.callback = callback;

        this.isSetTimeOut = forceSetTimeOut;

        this.isRunning = true;

        var _this = this;

        this.timeOutID = (forceSetTimeOut) ? window.setTimeout(_this.stepTimeout, 0) : window.requestAnimationFrame(_this.step);
    },

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    stop: function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    },

    destroy: function ()
    {
        this.stop();

        this.callback = NOOP;
    }

};

module.exports = RequestAnimationFrame;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ }),
/* 114 */
/***/ (function(module, exports) {


var GetBitmapTextSize = function (src)
{
    var text = src.text;
    var textLength = text.length;

    var bx = Number.MAX_VALUE;
    var by = Number.MAX_VALUE;
    var bw = 0;
    var bh = 0;
    
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (bx > x)
        {
            bx = x;
        }

        if (by > y)
        {
            by = y;
        }

        var gw = x + glyphW - bx;
        var gh = y + glyphH - by;

        if (bw < gw)
        {
            bw = gw;
        }
        
        if (bh < gh)
        {
            bh = gh;
        }

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    var scale = (src.fontSize / src.fontData.size);
    var sx = scale * src.scaleX;
    var sy = scale * src.scaleY;

    return {
        local: {
            x: bx * scale,
            y: by * scale,
            width: bw * scale,
            height: bh * scale
        },
        global: {
            x: src.x + (bx * sx),
            y: src.y + (by * sy),
            width: bw * sx,
            height: bh * sy
        }
    };
};

module.exports = GetBitmapTextSize;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var Render = __webpack_require__(394);
var GetBitmapTextSize = __webpack_require__(114);

var DynamicBitmapText = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.RenderTarget,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function DynamicBitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state, 'DynamicBitmapText');

        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.fontSize = size || this.fontData.size;

        this.scrollX = 0;
        this.scrollY = 0;

        this.width = 0;
        this.height = 0;

        this.displayCallback;

        this.setTexture(font);
        this.setPosition(x, y);
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    },

    setDisplayCallback: function (callback)
    {
        this.displayCallback = callback;

        return this;
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    setScrollX: function (value)
    {
        this.scrollX = value;

        return this;
    },

    setScrollY: function (value)
    {
        this.scrollY = value;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    }

});

module.exports = DynamicBitmapText;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var Render = __webpack_require__(398);
var GetBitmapTextSize = __webpack_require__(114);
var ParseRetroFont = __webpack_require__(390);

var BitmapText = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function BitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state, 'BitmapText');

        this.font = font;
        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.fontSize = size || this.fontData.size;

        this.setTexture(font);
        this.setPosition(x, y);
        this.setOrigin(0, 0);
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    },

    toJSON: function ()
    {
        var out = Components.ToJSON(this);

        //  Extra data is added here

        var data = {
            font: this.font,
            text: this.text,
            fontSize: this.fontSize
        };

        out.data = data;

        return out;
    }

});

BitmapText.ParseRetroFont = ParseRetroFont;

module.exports = BitmapText;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var BlitterRender = __webpack_require__(402);
var Bob = __webpack_require__(404);

/**
* A Blitter Game Object.
*
* The Blitter Game Object is a special type of Container, that contains Blitter.Bob objects.
* These objects can be thought of as just texture frames with a position and nothing more.
* Bobs don't have any update methods, or the ability to have children, or any kind of special effects.
* They are essentially just super-fast texture frame renderers, and the Blitter object creates and manages them.
*
* @class Blitter
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/

var Blitter = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        BlitterRender
    ],

    initialize:

    function Blitter (state, x, y, texture, frame)
    {
        GameObject.call(this, state, 'Blitter');

        this.setTexture(texture, frame);
        this.setPosition(x, y);

        this.children = new Components.Children(this);

        this.renderList = [];

        this.dirty = false;
    },

    //  frame MUST be part of the Blitter texture
    create: function (x, y, frame, visible, index)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }
        if (index === undefined) { index = this.children.length; }

        if (typeof frame === 'string')
        {
            frame = this.texture.get(frame);
        }

        var bob = new Bob(this, x, y, frame, visible);

        this.children.addAt(bob, index, false);

        this.dirty = true;

        return bob;
    },

    //  frame MUST be part of the Blitter texture
    createFromCallback: function (callback, quantity, frame, visible)
    {
        var bobs = this.createMultiple(quantity, frame, visible);

        for (var i = 0; i < bobs.length; i++)
        {
            var bob = bobs[i];

            callback.call(this, bob, i);
        }

        return bobs;
    },

    //  frame MUST be part of the Blitter texture
    createMultiple: function (quantity, frame, visible)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }

        if (!Array.isArray(frame))
        {
            frame = [ frame ];
        }

        var bobs = [];
        var _this = this;

        frame.forEach(function (singleFrame)
        {
            for (var i = 0; i < quantity; i++)
            {
                bobs.push(_this.create(0, 0, singleFrame, visible));
            }
        });

        return bobs;
    },

    childCanRender: function (child)
    {
        return (child.visible && child.alpha > 0);
    },

    getRenderList: function ()
    {
        if (this.dirty)
        {
            this.renderList = this.children.list.filter(this.childCanRender, this);
            this.dirty = false;
        }

        return this.renderList;
    },

    clear: function ()
    {
        this.children.removeAll();
        this.dirty = true;
    }

});

module.exports = Blitter;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var ContainerRender = __webpack_require__(407);

var Container = new Class({

    Mixins: [
        Components.Visible,
        ContainerRender
    ],

    initialize:

    function Container (state)
    {
        GameObject.call(this, state);

        this.children = new Components.Children(this);
    }

});

module.exports = Container;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var Render = __webpack_require__(416);
var Commands = __webpack_require__(66);
var MATH_CONST = __webpack_require__(11);
var GetValue = __webpack_require__(0);
var CanvasPool = __webpack_require__(9);
var Camera = __webpack_require__(102);

var Graphics = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Transform,
        Components.RenderTarget,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function Graphics (state, options)
    {
        var x = GetValue(options, 'x', 0);
        var y = GetValue(options, 'y', 0);

        GameObject.call(this, state, 'Graphics');

        this.setPosition(x, y);

        this.commandBuffer = [];

        this.defaultFillColor = -1;
        this.defaultFillAlpha = 1;

        this.defaultStrokeWidth = 1;
        this.defaultStrokeColor = -1;
        this.defaultStrokeAlpha = 1;

        this.setDefaultStyles(options);

        var resourceManager = state.game.renderer.resourceManager;

        if (resourceManager !== undefined)
        {
            this.resourceManager = resourceManager;
            this.gl = state.game.renderer.gl;   
        }
    },

    //  STYLES

    setDefaultStyles: function (options)
    {
        if (GetValue(options, 'lineStyle', null))
        {
            this.defaultStrokeWidth = GetValue(options, 'lineStyle.width', 1);
            this.defaultStrokeColor = GetValue(options, 'lineStyle.color', 0xffffff);
            this.defaultStrokeAlpha = GetValue(options, 'lineStyle.alpha', 1);

            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        if (GetValue(options, 'fillStyle', null))
        {
            this.defaultFillColor = GetValue(options, 'fillStyle.color', 0xffffff);
            this.defaultFillAlpha = GetValue(options, 'fillStyle.alpha', 1);

            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        return this;
    },

    lineStyle: function (lineWidth, color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.LINE_STYLE,
            lineWidth, color, alpha
        );

        return this;
    },

    fillStyle: function (color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.FILL_STYLE,
            color, alpha
        );

        return this;
    },

    //  PATH

    beginPath: function ()
    {
        this.commandBuffer.push(
            Commands.BEGIN_PATH
        );

        return this;
    },

    closePath: function ()
    {
        this.commandBuffer.push(
            Commands.CLOSE_PATH
        );

        return this;
    },

    fillPath: function ()
    {
        this.commandBuffer.push(
            Commands.FILL_PATH
        );

        return this;
    },

    strokePath: function ()
    {
        this.commandBuffer.push(
            Commands.STROKE_PATH
        );

        return this;
    },

    //  CIRCLE

    fillCircleShape: function (circle)
    {
        return this.fillCircle(circle.x, circle.y, circle.radius);
    },

    strokeCircleShape: function (circle)
    {
        return this.strokeCircle(circle.x, circle.y, circle.radius);
    },

    fillCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.fillPath();
        this.closePath();

        return this;
    },

    strokeCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.closePath();
        this.strokePath();

        return this;
    },

    //  RECTANGLE

    fillRectShape: function (rect)
    {
        return this.fillRect(rect.x, rect.y, rect.width, rect.height);
    },

    strokeRectShape: function (rect)
    {
        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
    },

    fillRect: function (x, y, width, height)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, width, height
        );

        return this;
    },

    strokeRect: function (x, y, width, height)
    {
        this.beginPath();
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.strokePath();
        this.closePath();

        return this;
    },

    //  POINT

    fillPointShape: function (point, size)
    {
        return this.fillPoint(point.x, point.y, size);
    },

    fillPoint: function (x, y, size)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, size, size
        );

        return this;
    },

    //  TRIANGLE

    fillTriangleShape: function (triangle)
    {
        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    strokeTriangleShape: function (triangle)
    {
        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    fillTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.FILL_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    strokeTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.STROKE_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    //  LINE

    strokeLineShape: function (line)
    {
        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
    },

    lineBetween: function (x1, y1, x2, y2)
    {
        this.beginPath();
        this.moveTo(x1, y1);
        this.lineTo(x2, y2);
        this.strokePath();
        this.closePath();

        return this;
    },

    lineTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.LINE_TO,
            x, y
        );

        return this;
    },

    moveTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.MOVE_TO,
            x, y
        );

        return this;
    },

    lineFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.LINE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    moveFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.MOVE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    //  ARC

    arc: function (x, y, radius, startAngle, endAngle, anticlockwise)
    {
        this.commandBuffer.push(
            Commands.ARC,
            x, y, radius, startAngle, endAngle, anticlockwise
        );

        return this;
    },

    save: function () {
        this.commandBuffer.push(
            Commands.SAVE
        );
        return this;
    },

    restore: function () {
        this.commandBuffer.push(
            Commands.RESTORE
        );
        return this;
    },

    translate: function (x, y) {
        this.commandBuffer.push(
            Commands.TRANSLATE,
            x, y
        );
        return this;
    },

    scale: function (x, y) {
        this.commandBuffer.push(
            Commands.SCALE,
            x, y
        );
        return this;
    },

    rotate: function (radian) {
        this.commandBuffer.push(
            Commands.ROTATE,
            radian
        );
        return this;
    },

    clear: function ()
    {
        this.commandBuffer.length = 0;

        if (this.defaultFillColor > -1)
        {
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        if (this.defaultStrokeColor > -1)
        {
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        return this;
    },

    generateTexture: function (key, width, height) 
    {
        var screenWidth = this.state.game.config.width;
        var screenHeight = this.state.game.config.height;
        width = (typeof width === 'number') ? width : screenWidth;
        height = (typeof height === 'number') ? height : screenHeight;
        
        Graphics.TargetCamera.setViewport(0, 0, width, height);
        Graphics.TargetCamera.scrollX = this.x;
        Graphics.TargetCamera.scrollY = this.y;

        var texture = this.state.game.textures.createCanvas(key, width, height);
        var ctx = texture.source[0].image.getContext('2d');
        texture.add('__BASE', 0, 0, 0, width, height);
        this.renderCanvas(this.state.game.renderer, this, 0, Graphics.TargetCamera, ctx);
        if (this.gl)
        {
            this.state.game.renderer.uploadCanvasToGPU(ctx.canvas, texture.source[0].glTexture, true);
        }
    }

});

Graphics.TargetCamera = new Camera(0, 0, 0, 0);

module.exports = Graphics;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var Set = __webpack_require__(96);
var GetValue = __webpack_require__(0);
var Range = __webpack_require__(223);
var Actions = __webpack_require__(99);
var Sprite = __webpack_require__(51);

var Layer = new Class({

    initialize:

    function Layer (state, children)
    {
        this.state = state;

        this.children = new Set(children);

        this.classType = Sprite;
    },

    //  Layer management methods:

    add: function (child)
    {
        this.children.set(child);

        return this;
    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.children.set(children[i]);
            }
        }

        return this;
    },

    create: function (x, y, key, frame, visible)
    {
        if (visible === undefined) { visible = true; }

        var child = this.state.sys.children.add(new this.classType(this.state, x, y, key, frame));

        child.visible = visible;

        this.add(child);

        return child;
    },

    createFromConfig: function (options)
    {
        var key = GetValue(options, 'key', undefined);
        var frame = GetValue(options, 'frame', null);
        var visible = GetValue(options, 'visible', true);

        var entries = [];

        //  Can't do anything without at least a key
        if (key === undefined)
        {
            return entries;
        }
        else
        {
            if (!Array.isArray(key))
            {
                key = [ key ];
            }

            if (!Array.isArray(frame))
            {
                frame = [ frame ];
            }
        }

        //  Build an array of key frame pairs to loop through

        var repeat = GetValue(options, 'repeat', 0);
        var randomKey = GetValue(options, 'randomKey', false);
        var randomFrame = GetValue(options, 'randomFrame', false);
        var yoyo = GetValue(options, 'yoyo', false);
        var quantity = GetValue(options, 'frameQuantity', 1);
        var max = GetValue(options, 'max', 0);

        var range = Range(key, frame, {
            max: max,
            qty: quantity,
            random: randomKey,
            randomB: randomFrame,
            repeat: repeat,
            yoyo: yoyo
        });

        for (var c = 0; c < range.length; c++)
        {
            entries.push(this.create(0, 0, range[c].a, range[c].b, visible));
        }

        //  Post-creation options (applied only to those items created in this call):

        var x = GetValue(options, 'setXY.x', 0);
        var y = GetValue(options, 'setXY.y', 0);
        var stepX = GetValue(options, 'setXY.stepX', 0);
        var stepY = GetValue(options, 'setXY.stepY', 0);

        Actions.SetXY(entries, x, y, stepX, stepY);

        var rotation = GetValue(options, 'setRotation.value', 0);
        var stepRotation = GetValue(options, 'setRotation.step', 0);

        Actions.SetRotation(entries, rotation, stepRotation);

        var scaleX = GetValue(options, 'setScale.x', 1);
        var scaleY = GetValue(options, 'setScale.y', scaleX);
        var stepScaleX = GetValue(options, 'setScale.stepX', 0);
        var stepScaleY = GetValue(options, 'setScale.stepY', 0);

        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);

        var alpha = GetValue(options, 'setAlpha.value', 1);
        var stepAlpha = GetValue(options, 'setAlpha.step', 0);

        Actions.SetAlpha(entries, alpha, stepAlpha);

        return entries;
    },

    createMultiple: function (config)
    {
        if (!Array.isArray(config))
        {
            config = [ config ];
        }

        var output = [];

        for (var i = 0; i < config.length; i++)
        {
            var entries = this.createFromConfig(config[i]);

            output = output.concat(entries);
        }

        return output;
    },

    remove: function (child)
    {
        this.children.delete(child);

        return this;
    },

    clear: function ()
    {
        this.children.clear();

        return this;
    },

    getChildren: function ()
    {
        return this.children.entries;
    },

    getLength: function ()
    {
        return this.children.size;
    },

    getFirst: function (compare, index)
    {
        if (index === undefined) { index = 0; }

        return Actions.GetFirst(this.children.entries, compare, index);
    },

    destroy: function ()
    {
        this.children.clear();

        this.state = undefined;
        this.children = undefined;
    },

    //  Child related methods

    angle: function (value)
    {
        Actions.Angle(this.children.entries, value);

        return this;
    },

    gridAlign: function (options)
    {
        Actions.GridAlign(this.children.entries, options);

        return this;
    },

    incAlpha: function (value, step)
    {
        Actions.IncAlpha(this.children.entries, value, step);

        return this;
    },

    incX: function (value)
    {
        Actions.IncX(this.children.entries, value);

        return this;
    },

    incXY: function (x, y)
    {
        Actions.IncXY(this.children.entries, x, y);

        return this;
    },

    incY: function (value)
    {
        Actions.IncY(this.children.entries, value);

        return this;
    },

    placeOnCircle: function (circle, startAngle, endAngle)
    {
        Actions.PlaceOnCircle(this.children.entries, circle, startAngle, endAngle);

        return this;
    },

    placeOnLine: function (line)
    {
        Actions.PlaceOnLine(this.children.entries, line);

        return this;
    },

    placeOnRectangle: function (rect, shift)
    {
        Actions.PlaceOnRectangle(this.children.entries, rect, shift);

        return this;
    },

    placeOnTriangle: function (triangle, stepRate)
    {
        Actions.PlaceOnTriangle(this.children.entries, triangle, stepRate);

        return this;
    },

    playAnimation: function (key, startFrame)
    {
        Actions.PlayAnimation(this.children.entries, key, startFrame);

        return this;
    },

    randomCircle: function (circle)
    {
        Actions.RandomCircle(this.children.entries, circle);

        return this;
    },

    randomEllipse: function (ellipse)
    {
        Actions.RandomEllipse(this.children.entries, ellipse);

        return this;
    },

    randomLine: function (line)
    {
        Actions.RandomLine(this.children.entries, line);

        return this;
    },

    randomRectangle: function (rect)
    {
        Actions.RandomRectangle(this.children.entries, rect);

        return this;
    },

    randomTriangle: function (triangle)
    {
        Actions.RandomTriangle(this.children.entries, triangle);

        return this;
    },

    rotate: function (value, step)
    {
        Actions.Rotate(this.children.entries, value, step);

        return this;
    },

    rotateAround: function (point, angle)
    {
        Actions.RotateAround(this.children.entries, point, angle);

        return this;
    },

    rotateAroundDistance: function (point, angle, distance)
    {
        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);

        return this;
    },

    setAlpha: function (value, step)
    {
        Actions.SetAlpha(this.children.entries, value, step);

        return this;
    },

    setOrigin: function (x, y)
    {
        Actions.SetOrigin(this.children.entries, x, y);

        return this;
    },

    scaleX: function (value)
    {
        Actions.ScaleX(this.children.entries, value);

        return this;
    },

    scaleXY: function (x, y)
    {
        Actions.ScaleXY(this.children.entries, x, y);

        return this;
    },

    scaleY: function (value)
    {
        Actions.ScaleY(this.children.entries, value);

        return this;
    },

    setRotation: function (value, step)
    {
        Actions.SetRotation(this.children.entries, value, step);

        return this;
    },

    setScale: function (x, y, stepX, stepY)
    {
        Actions.SetScale(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setScaleX: function (value, step)
    {
        Actions.SetScaleX(this.children.entries, value, step);

        return this;
    },

    setScaleY: function (value, step)
    {
        Actions.SetScaleY(this.children.entries, value, step);

        return this;
    },

    setVisible: function (value)
    {
        Actions.SetVisible(this.children.entries, value);

        return this;
    },

    setX: function (value, step)
    {
        Actions.SetX(this.children.entries, value, step);

        return this;
    },

    setXY: function (x, y, stepX, stepY)
    {
        Actions.SetXY(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setY: function (value, step)
    {
        Actions.SetY(this.children.entries, value, step);

        return this;
    },

    shiftPosition: function (x, y, direction, output)
    {
        Actions.ShiftPosition(this.children.entries, x, y, direction, output);

        return this;
    },

    smootherStep: function (property, min, max, inc)
    {
        Actions.SmootherStep(this.children.entries, property, min, max, inc);

        return this;
    },

    smoothStep: function (property, min, max, inc)
    {
        Actions.SmoothStep(this.children.entries, property, min, max, inc);

        return this;
    },

    spread: function (property, min, max, inc)
    {
        Actions.Spread(this.children.entries, property, min, max, inc);

        return this;
    },

    toggleVisible: function ()
    {
        Actions.ToggleVisible(this.children.entries);

        return this;
    }

});

module.exports = Layer;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// RenderPass Will only work with Sprite and Image GameObjects.

var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var Render = __webpack_require__(433);
var TexturedAndNormalizedTintedShader = __webpack_require__(49);

//   RenderPass - the user has a higher control on the rendering since you explicitly
//   indicate what is rendered. RenderPass also has a render target but the difference
//   is that when explicitly rendering an object to the render pass the shader from that
//   render pass is applied. This is useful for additive passes and specific object effects.

var RenderPass = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        Render
    ],

    initialize:

    function RenderPass (state, x, y, width, height, shaderName, fragmentShader)
    {
        GameObject.call(this, state, 'RenderPass');
       
        var resourceManager = state.game.renderer.resourceManager;
        var pot = ((width & (width - 1)) == 0 && (height & (height - 1)) == 0);
        var gl;
        var wrap;
        
        this.renderer = state.game.renderer;
        this.passRenderTarget = null;
        this.renderTexture = null;
        this.passShader = null;
        this.uniforms = {};

        if (resourceManager !== undefined)
        {
            gl = state.game.renderer.gl;
            wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            this.passShader = resourceManager.createShader(shaderName, {vert: TexturedAndNormalizedTintedShader.vert, frag: fragmentShader});
            this.renderTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, wrap, wrap, gl.RGBA, null, width, height);
            this.passRenderTarget = resourceManager.createRenderTarget(width, height, this.renderTexture, null);
            state.game.renderer.currentTexture = null; // force rebinding of prev texture
        }

        this.flipY = true;
        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0, 0);
    },

    clearColorBuffer: function (r, g, b, a)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearColor(r, g, b, a);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    clearDepthStencilBuffers: function (depth, stencil)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearDepth(depth);
            gl.clearStencil(stencil);
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    clearAllBuffers: function (r, g, b, a, depth, stencil)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.passRenderTarget.framebufferObject);
            gl.clearColor(r, g, b, a);
            gl.clearDepth(depth);
            gl.clearStencil(stencil);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    render: function (gameObject, camera)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            this.renderer.setRenderer(this.renderer.spriteBatch, null, null);
            this.renderer.spriteBatch.addSprite(gameObject, camera);
            this.renderer.spriteBatch.flush(this.passShader, this.passRenderTarget.framebufferObject);
        }
    },

    setRenderTextureAt: function (renderTexture, samplerName, unit)
    {
        var gl = this.renderer.gl;

        if (gl)
        {
            /* Texture 1 is reserved for Phasers Main Renderer */
            unit = (unit > 0) ? unit : 1;
            this.setInt(samplerName, unit);
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, renderTexture.texture);
            gl.activeTexture(gl.TEXTURE0);
        }
    },

    getUniformLocation: function (uniformName)
    {
        var passShader = this.passShader;
        var uniforms = this.uniforms;
        var location;

        if (uniformName in uniforms)
        {
            location = uniforms[uniformName];
        }
        else
        {
            location = passShader.getUniformLocation(uniformName);
            uniforms[uniformName] = location;
        }

        return location;
    },

    setFloat: function (uniformName, x)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat1(this.getUniformLocation(uniformName), x);
    },

    setFloat2: function (uniformName, x, y)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat2(this.getUniformLocation(uniformName), x, y);
    },

    setFloat3: function (uniformName, x, y, z)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat3(this.getUniformLocation(uniformName), x, y, z);
    },

    setFloat4: function (uniformName, x, y, z, w)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantFloat4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setInt: function (uniformName, x)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt1(this.getUniformLocation(uniformName), x);
    },

    setInt2: function (uniformName, x, y)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt2(this.getUniformLocation(uniformName), x, y);
    },

    setInt3: function (uniformName, x, y, z)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt3(this.getUniformLocation(uniformName), x, y, z);
    },

    setInt4: function (uniformName, x, y, z, w)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantInt4(this.getUniformLocation(uniformName), x, y, z, w);
    },

    setMatrix2x2: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix2x2(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix3x3: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix3x3(this.getUniformLocation(uniformName), matrix);
    },

    setMatrix4x4: function (uniformName, matrix)
    {
        var passShader = this.passShader;

        if (passShader === null)
        {
            return;
        }

        passShader.setConstantMatrix4x4(this.getUniformLocation(uniformName), matrix);
    }

});

module.exports = RenderPass;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var GameObject = __webpack_require__(7);
var Components = __webpack_require__(4);
var TileSpriteRender = __webpack_require__(461);
var CanvasPool = __webpack_require__(9);

var TileSprite = new Class({

    Extends: GameObject,

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderTarget,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.ScrollFactor,
        TileSpriteRender
    ],

    initialize:

    function TileSprite (state, x, y, width, height, texture, frame)
    {
        var resourceManager = state.game.renderer.resourceManager;

        GameObject.call(this, state, 'TileSprite');

        this.tilePositionX = 0;
        this.tilePositionY = 0;
        this.dirty = true;
        this.tileTexture = null;
        this.renderer = null;

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.setSize(width, height);

        this.potWidth = this.frame.width;
        this.potHeight = this.frame.height;
        this.canvasPattern = null;

        if (resourceManager)
        {
            this.potWidth--;
            this.potWidth |= this.potWidth >> 1;
            this.potWidth |= this.potWidth >> 2;
            this.potWidth |= this.potWidth >> 4;
            this.potWidth |= this.potWidth >> 8;
            this.potWidth |= this.potWidth >> 16;
            this.potWidth++;

            this.potHeight--;
            this.potHeight |= this.potHeight >> 1;
            this.potHeight |= this.potHeight >> 2;
            this.potHeight |= this.potHeight >> 4;
            this.potHeight |= this.potHeight >> 8;
            this.potHeight |= this.potHeight >> 16;
            this.potHeight++;

            this.renderer = state.game.renderer;
            var gl = state.game.renderer.gl;

            this.tileTexture = resourceManager.createTexture(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.canvasBuffer, this.potWidth, this.potHeight);
        }

        this.canvasBuffer = CanvasPool.create2D(null, this.potWidth, this.potHeight);
        this.canvasBufferCtx = this.canvasBuffer.getContext('2d');

        this.updateTileTexture();
    },

    updateTileTexture: function ()
    {
        if (!this.dirty)
        {
            return;
        }

        this.canvasBuffer.width = this.canvasBuffer.width;

        this.canvasBufferCtx.drawImage(
            this.frame.source.image,
            this.frame.cutX, this.frame.cutY,
            this.frame.cutWidth, this.frame.cutHeight,
            0, 0,
            this.potWidth, this.potHeight
        );

        if (this.renderer)
        {
            this.renderer.uploadCanvasToGPU(this.canvasBuffer, this.tileTexture, true);
        }
        else
        {
            this.canvasPattern = this.canvasBufferCtx.createPattern(this.canvasBuffer, 'repeat');
        }

        this.dirty = false;
    },

    destroy: function ()
    {
        if (this.renderer)
        {
            this.renderer.gl.deleteTexture(this.tileTexture);
        }

        CanvasPool.remove(this.canvasBuffer);

        this.canvasPattern = null;
        this.canvasBufferCtx = null;
        this.canvasBuffer = null;

        this.renderer = null;
        this.visible = false;
    }

});

module.exports = TileSprite;


/***/ }),
/* 123 */
/***/ (function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//  Based on code by Matt DesLauriers
//  https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md

var Contains = __webpack_require__(52);

var tmp = { x: 0, y: 0 };

var LineToCircle = function (line, circle, nearest)
{
    if (nearest === undefined) { nearest = tmp; }

    if (Contains(circle, line.x1, line.y1))
    {
        nearest.x = line.x1;
        nearest.y = line.y1;

        return true;
    }

    if (Contains(circle, line.x2, line.y2))
    {
        nearest.x = line.x2;
        nearest.y = line.y2;

        return true;
    }

    var dx = line.x2 - line.x1;
    var dy = line.y2 - line.y1;

    var lcx = circle.x - line.x1;
    var lcy = circle.y - line.y1;

    //  project lc onto d, resulting in vector p
    var dLen2 = (dx * dx) + (dy * dy);
    var px = dx;
    var py = dy;

    if (dLen2 > 0)
    {
        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;

        px *= dp;
        py *= dp;
    }

    nearest.x = line.x1 + px;
    nearest.y = line.y1 + py;
    
    //  len2 of p
    var pLen2 = (px * px) + (py * py);
    
    return (
        pLen2 <= dLen2 &&
        ((px * dx) + (py * dy)) >= 0 &&
        Contains(circle, nearest.x, nearest.y)
    );
};

module.exports = LineToCircle;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ }),
/* 130 */
/***/ (function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;

    this.setTo(x1, y1, x2, y2);
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    },

    getPointA: function ()
    {
        return { x1: this.x1, y1: this.y1 };
    },

    getPointB: function ()
    {
        return { x1: this.x2, y1: this.y2 };
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);
var Wrap = __webpack_require__(56);
var Angle = __webpack_require__(36);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ }),
/* 135 */
/***/ (function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(133);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ }),
/* 138 */
/***/ (function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

var Decompose = function (rect, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: rect.x, y: rect.y });
    out.push({ x: rect.right, y: rect.y });
    out.push({ x: rect.right, y: rect.bottom });
    out.push({ x: rect.x, y: rect.bottom });

    return out;
};

module.exports = Decompose;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var Perimeter = __webpack_require__(141);

//  Return an array of points from the perimeter of the rectangle
//  each spaced out based on the quantity or step required

var MarchingAnts = function (rect, step, quantity, out)
{
    if (out === undefined) { out = []; }

    if (!step && !quantity)
    {
        //  Bail out
        return out;
    }

    //  If step is a falsey value (false, null, 0, undefined, etc) then we calculate
    //  it based on the quantity instead, otherwise we always use the step value
    if (!step)
    {
        step = Perimeter(rect) / quantity;
    }
    else
    {
        quantity = Math.round(Perimeter(rect) / step);
    }

    var x = rect.x;
    var y = rect.y;
    var face = 0;

    //  Loop across each face of the rectangle

    for (var i = 0; i < quantity; i++)
    {
        out.push({ x: x, y: y });

        switch (face)
        {
            //  Top face
            case 0:
                x += step;

                if (x >= rect.right)
                {
                    face = 1;
                    y += (x - rect.right);
                    x = rect.right;
                }
                break;

            //  Right face
            case 1:
                y += step;

                if (y >= rect.bottom)
                {
                    face = 2;
                    x -= (y - rect.bottom);
                    y = rect.bottom;
                }
                break;

            //  Bottom face
            case 2:
                x -= step;

                if (x <= rect.left)
                {
                    face = 3;
                    y -= (rect.left - x);
                    x = rect.left;
                }
                break;

            //  Left face
            case 3:
                y -= step;

                if (y <= rect.top)
                {
                    face = 0;
                    y = rect.top;
                }
                break;
        }
    }

    return out;
};

module.exports = MarchingAnts;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ }),
/* 143 */
/***/ (function(module, exports) {

//  The three medians (the lines drawn from the vertices to the bisectors of the opposite sides)
//  meet in the centroid or center of mass (center of gravity).
//  The centroid divides each median in a ratio of 2:1

var Centroid = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;

    return out;
};

module.exports = Centroid;


/***/ }),
/* 144 */
/***/ (function(module, exports) {

var Decompose = function (triangle, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: triangle.x1, y: triangle.y1 });
    out.push({ x: triangle.x2, y: triangle.y2 });
    out.push({ x: triangle.x3, y: triangle.y3 });

    return out;
};

module.exports = Decompose;


/***/ }),
/* 145 */
/***/ (function(module, exports) {

// The three angle bisectors of a triangle meet in one point called the incenter.
// It is the center of the incircle, the circle inscribed in the triangle.

function getLength (x1, y1, x2, y2)
{
    var x = x1 - x2;
    var y = y1 - y2;
    var magnitude = (x * x) + (y * y);

    return Math.sqrt(magnitude);
}

var InCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var d1 = getLength(x3, y3, x2, y2);
    var d2 = getLength(x1, y1, x3, y3);
    var d3 = getLength(x2, y2, x1, y1);

    var p = d1 + d2 + d3;

    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;

    return out;
};

module.exports = InCenter;


/***/ }),
/* 146 */
/***/ (function(module, exports) {

var Offset = function (triangle, x, y)
{
    triangle.x1 += x;
    triangle.y1 += y;

    triangle.x2 += x;
    triangle.y2 += y;

    triangle.x3 += x;
    triangle.y3 += y;

    return triangle;
};

module.exports = Offset;


/***/ }),
/* 147 */
/***/ (function(module, exports) {


var Random = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    //  Basis vectors
    var ux = triangle.x2 - triangle.x1;
    var uy = triangle.y2 - triangle.y1;

    var vx = triangle.x3 - triangle.x1;
    var vy = triangle.y3 - triangle.y1;

    //  Random point within the unit square
    var r = Math.random();
    var s = Math.random();

    //  Point outside the triangle? Remap it.
    if (r + s >= 1)
    {
        r = 1 - r;
        s = 1 - s;
    }

    out.x = triangle.x1 + ((ux * r) + (vx * s));
    out.y = triangle.y1 + ((uy * r) + (vy * s));

    return out;
};

module.exports = Random;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

/**
* Adds the source and backdrop colors together and returns the value, up to a maximum of 255.
*
* @method Lazer.Color.blendAdd
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Add = function (a, b)
{
    return Math.min(255, a + b);
};

module.exports = Add;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
* Darkens the backdrop color to reflect the source color.
* Painting with white produces no change. 
*
* @method Lazer.Color.blendColorBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorBurn = function (a, b)
{
    return (b === 0) ? b : Math.max(0, (255 - ((255 - a) << 8) / b));
};

module.exports = ColorBurn;


/***/ }),
/* 150 */
/***/ (function(module, exports) {

/**
* Brightens the backdrop color to reflect the source color. 
* Painting with black produces no change.
*
* @method Lazer.Color.blendColorDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorDodge = function (a, b)
{
    return (b === 255) ? b : Math.min(255, ((a << 8) / (255 - b)));
};

module.exports = ColorDodge;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
* Selects the darker of the backdrop and source colors.
*
* @method Lazer.Color.blendDarken
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Darken = function (a, b)
{
    return (b > a) ? a : b;
};

module.exports = Darken;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
* Selects the lighter of the backdrop and source colors.
*
* @method Lazer.Color.blendLighten
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Lighten = function (a, b)
{
    return (b > a) ? b : a;
};

module.exports = Lighten;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var Subtract = __webpack_require__(157);

/**
* An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.
*
* @method Lazer.Color.blendLinearBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearBurn = function (a, b)
{
    return Subtract(a, b);
};

module.exports = LinearBurn;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Add = __webpack_require__(148);

/**
* An alias for blendAdd, it simply sums the values of the two colors.
*
* @method Lazer.Color.blendLinearDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearDodge = function (a, b)
{
    return Add(a, b);
};

module.exports = LinearDodge;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

/**
* Multiplies or screens the colors, depending on the backdrop color.
* Source colors overlay the backdrop while preserving its highlights and shadows. 
* The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.
*
* @method Lazer.Color.blendOverlay
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Overlay = function (a, b)
{
    return (b < 128) ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);
};

module.exports = Overlay;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/**
* Reflect blend mode. This mode is useful when adding shining objects or light zones to images. 
*
* @method Lazer.Color.blendReflect
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Reflect = function (a, b)
{
    return (b === 255) ? b : Math.min(255, (a * a / (255 - b)));
};

module.exports = Reflect;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
* Combines the source and backdrop colors and returns their value minus 255.
*
* @method Lazer.Color.blendSubtract
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Subtract = function (a, b)
{
    return Math.max(0, a + b - 255);
};

module.exports = Subtract;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var ColorBurn = __webpack_require__(149);
var ColorDodge = __webpack_require__(150);

/**
* This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).
* Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.
* The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom 
* layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.
*
* @method Lazer.Color.blendVividLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var VividLight = function (a, b)
{
    return (b < 128) ? ColorBurn(a, 2 * b) : ColorDodge(a, (2 * (b - 128)));
};

module.exports = VividLight;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
* Return a string containing a hex representation of the given color component.
*
* @param {integer} color - The color channel to get the hex value for, must be a value between 0 and 255.
* @return {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.
*/
var ComponentToHex = function (color)
{
    var hex = color.toString(16);

    return (hex.length === 1) ? '0' + hex : hex;
};

module.exports = ComponentToHex;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

/**
 * Given an alpha and 3 color values this will return an integer representation of it.
 *
 * @method getColor32
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor32 = function (red, green, blue, alpha)
{
    return alpha << 24 | red << 16 | green << 8 | blue;
};

module.exports = GetColor32;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(81);

/**
 * Converts an HSV (hue, saturation and value) color value to RGB.
 * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
 * Based on code by Michael Jackson (https://github.com/mjijackson)
 *
 * @method fromHSV
 * @param {number} h - The hue, in the range 0 - 1.
 * @param {number} s - The saturation, in the range 0 - 1.
 * @param {number} v - The value, in the range 0 - 1.
 * @return {BaseColor} This
 */
var HSVToRGB = function (h, s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var i = Math.floor(h * 6);
    var f = h * 6 - i;

    var p = Math.floor((v * (1 - s)) * 255);
    var q = Math.floor((v * (1 - f * s)) * 255);
    var t = Math.floor((v * (1 - (1 - f) * s)) * 255);

    v = Math.floor(v *= 255);

    var output = { r: v, g: v, b: v, color: 0 };

    var r = i % 6;

    if (r === 0)
    {
        output.g = t;
        output.b = p;
    }
    else if (r === 1)
    {
        output.r = q;
        output.b = p;
    }
    else if (r === 2)
    {
        output.r = p;
        output.b = t;
    }
    else if (r === 3)
    {
        output.r = p;
        output.g = q;
    }
    else if (r === 4)
    {
        output.r = t;
        output.g = p;
    }
    else if (r === 5)
    {
        output.g = p;
        output.b = q;
    }

    output.color = GetColor(output.r, output.g, output.b);

    return output;
};

module.exports = HSVToRGB;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(37);

/**
* Converts a hex string into a Phaser Color object.
*
* The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.    
*
* An alpha channel is _not_ supported.
*
* @method Phaser.Color.hexToColor
* @static
* @param {string} hex - The color string in a hex format.
* @param {object} [out] - An object into which 3 properties will be created or set: r, g and b. If not provided a new object will be created.
* @return {object} An object with the red, green and blue values set in the r, g and b properties.
*/
var HexStringToColor = function (hex)
{
    var color = new Color();

    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    if (result)
    {
        var r = parseInt(result[1], 16);
        var g = parseInt(result[2], 16);
        var b = parseInt(result[3], 16);

        color.setTo(r, g, b);
    }

    return color;
};

module.exports = HexStringToColor;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
* Converts a hue to an RGB color.
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.hueToColor
* @param {number} p
* @param {number} q
* @param {number} t
* @return {number} The color component value.
*/
var HueToComponent = function (p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }

    if (t > 1)
    {
        t -= 1;
    }

    if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2)
    {
        return q;
    }

    if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

module.export = HueToComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(243)(module)))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(37);
var IntegerToRGB = __webpack_require__(165);

var IntegerToColor = function (input)
{
    var rgb = IntegerToRGB(input);

    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
};

module.exports = IntegerToColor;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/**
* Return the component parts of a color as an Object with the properties alpha, red, green, blue.
*
* Alpha will only be set if it exist in the given color (0xAARRGGBB)
*
* @method Phaser.Color.getRGB
* @static
* @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).
* @return {object} An Object with properties: alpha, red, green, blue (also r, g, b and a). Alpha will only be present if a color value > 16777215 was given.
*/
var IntegerToRGB = function (color)
{
    if (color > 16777215)
    {
        //  The color value has an alpha component
        return {
            a: color >>> 24,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
    else
    {
        return {
            a: 255,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
};

module.exports = IntegerToRGB;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(37);

/**
* Converts a CSS 'web' string into a Phaser Color object.
*
* The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
*
* @method Phaser.Color.webToColor
* @static
* @param {string} web - The color string in CSS 'web' format.
* @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.
* @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
*/
var RGBStringToColor = function (rgb)
{
    var color = new Color();

    var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());

    if (result)
    {
        var r = parseInt(result[1], 10);
        var g = parseInt(result[2], 10);
        var b = parseInt(result[3], 10);
        var a = (result[4] !== undefined) ? parseFloat(result[4]) : 1;

        color.setTo(r, g, b, a * 255);
    }

    return color;
};

module.exports = RGBStringToColor;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var RGBStringToColor = __webpack_require__(166);
var HexStringToColor = __webpack_require__(162);
var IntegerToColor = __webpack_require__(164);

var ValueToColor = function (input)
{
    if (typeof input === 'string')
    {
        if (input.substr(0, 3).toLowerCase() === 'rgb')
        {
            return RGBStringToColor(input);
        }
        else
        {
            return HexStringToColor(input);
        }
    }
    else if (typeof input === 'number')
    {
        return IntegerToColor(input);
    }
};

module.exports = ValueToColor;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(614);
var KeyCodes = __webpack_require__(82);
var Key = __webpack_require__(171);
var KeyCombo = __webpack_require__(169);
var ProcessKeyCombo = __webpack_require__(170);
var ProcessKeyDown = __webpack_require__(619);
var ProcessKeyUp = __webpack_require__(620);

/**
* The Keyboard class monitors keyboard input and dispatches keyboard events.
*
* _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
* See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
*
* Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
* For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
* So please check your extensions before opening Phaser issues.
*
* @class Phaser.Keyboard
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var KeyboardManager = function (inputManager)
{
    this.manager = inputManager;

    this.enabled = false;

    this.target;

    this.keys = [];

    this.combos = [];

    this.captures = [];

    //   Standard FIFO queue
    this.queue = [];

    this.handler;
};

KeyboardManager.prototype.constructor = KeyboardManager;

KeyboardManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        var config = this.manager.gameConfig;

        this.enabled = config.inputKeyboard;
        this.target = config.inputKeyboardEventTarget;

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.queue;
        var captures = this.captures;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);

            if (captures[event.keyCode])
            {
                event.preventDefault();
            }
        };

        this.handler = handler;

        this.target.addEventListener('keydown', handler, false);
        this.target.addEventListener('keyup', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('keydown', this.handler);
        this.target.removeEventListener('keyup', this.handler);
    },

    /**
    * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.
    *
    * @method Phaser.Keyboard#createCursorKeys
    * @return {object} An object containing properties: `up`, `down`, `left` and `right` of {@link Phaser.Key} objects.
    */
    createCursorKeys: function ()
    {
        return this.addKeys({
            up: KeyCodes.UP,
            down: KeyCodes.DOWN,
            left: KeyCodes.LEFT,
            right: KeyCodes.RIGHT
        });
    },

    /**
    * A practical way to create an object containing user selected hotkeys.
    *
    * For example,
    *
    *     addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );
    *
    * would return an object containing properties (`up`, `down`, `left` and `right`) referring to {@link Phaser.Key} object.
    *
    * @method Phaser.Keyboard#addKeys
    * @param {object} keys - A key mapping object, i.e. `{ 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S }` or `{ 'up': 52, 'down': 53 }`.
    * @return {object} An object containing the properties mapped to {@link Phaser.Key} values.
    */
    addKeys: function (keys)
    {
        var output = {};

        for (var key in keys)
        {
            output[key] = this.addKey(keys[key]);
        }

        return output;
    },

    /**
    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
    * The Key object can then be polled, have events attached to it, etc.
    *
    * @method Phaser.Keyboard#addKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key.
    * @return {Phaser.Key} The Key object which you can store locally and reference directly.
    */
    addKey: function (keyCode)
    {
        var keys = this.keys;

        if (!keys[keyCode])
        {
            keys[keyCode] = new Key(keyCode);
            this.captures[keyCode] = true;
        }

        return keys[keyCode];
    },

    /**
    * Removes a Key object from the Keyboard manager.
    *
    * @method Phaser.Keyboard#removeKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key to remove.
    */
    removeKey: function (keyCode)
    {
        if (this.keys[keyCode])
        {
            this.keys[keyCode] = undefined;
            this.captures[keyCode] = false;
        }
    },

    addKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = true;
        }
    },

    removeKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = false;
        }
    },

    createCombo: function (keys, config)
    {
        return new KeyCombo(this, keys, config);
    },

    //  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
    //  type = 'keydown', 'keyup'
    //  keyCode = integer

    update: function ()
    {
        var len = this.queue.length;

        if (!this.enabled || len === 0)
        {
            return;
        }

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, len);

        var keys = this.keys;
        var singleKey;

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < len; i++)
        {
            var event = queue[i];

            if (event.type === 'keydown')
            {
                this.manager.events.dispatch(new Event.KEY_DOWN_EVENT(event));

                singleKey = Event._DOWN[event.keyCode];

                if (singleKey)
                {
                    this.manager.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyDown(keys[event.keyCode], event);
                }
            }
            else
            {
                this.manager.events.dispatch(new Event.KEY_UP_EVENT(event));

                singleKey = Event._UP[event.keyCode];

                if (singleKey)
                {
                    this.manager.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyUp(keys[event.keyCode], event);
                }
            }
        }
    }

};

module.exports = KeyboardManager;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var ResetKeyCombo = __webpack_require__(611);
var ProcessKeyCombo = __webpack_require__(170);
var KeyComboMatchEvent = __webpack_require__(610);

//  Keys can be either:
//
//  A string (ATARI)
//  An array of either integers (key codes) or strings, or a mixture of both
//  An array of objects (such as Key objects) with a public 'keyCode' property

var KeyCombo = function (keyboardManager, keys, config)
{
    if (config === undefined) { config = {}; }

    //  Can't have a zero or single length combo (string or array based)
    if (keys.length < 2)
    {
        return false;
    }

    this.manager = keyboardManager;

    this.enabled = true;

    this.keyCodes = [];

    //  if 'keys' is a string we need to get the keycode of each character in it

    for (var i = 0; i < keys.length; i++)
    {
        var char = keys[i];

        if (typeof char === 'string')
        {
            this.keyCodes.push(char.toUpperCase().charCodeAt(0));
        }
        else if (typeof char === 'number')
        {
            this.keyCodes.push(char);
        }
        else if (char.hasOwnProperty('keyCode'))
        {
            this.keyCodes.push(char.keyCode);
        }
    }

    //  The current keyCode the combo is waiting for
    this.current = this.keyCodes[0];

    //  The current index of the key being waited for in the 'keys' string
    this.index = 0;

    //  The length of this combo (in keycodes)
    this.size = this.keyCodes.length;

    //  The time the previous key in the combo was matched
    this.timeLastMatched = 0;

    //  Has this Key Combo been matched yet?
    this.matched = false;

    //  The time the entire combo was matched
    this.timeMatched = 0;

    //  Custom options ...

    //  If they press the wrong key do we reset the combo?
    this.resetOnWrongKey = GetValue(config, 'resetOnWrongKey', true);

    //  The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
    this.maxKeyDelay = GetValue(config, 'maxKeyDelay', 0);

    //  If previously matched and they press Key 1 again, will it reset?
    this.resetOnMatch = GetValue(config, 'resetOnMatch', false);

    //  If the combo matches, will it delete itself?
    this.deleteOnMatch = GetValue(config, 'deleteOnMatch', false);

    var _this = this;

    var onKeyDownHandler = function (event)
    {
        if (_this.matched || !_this.enabled)
        {
            return;
        }

        var matched = ProcessKeyCombo(event.data, _this);

        if (matched)
        {
            _this.manager.events.dispatch(new KeyComboMatchEvent(_this, event));

            if (_this.resetOnMatch)
            {
                ResetKeyCombo(_this);
            }
            else if (_this.deleteOnMatch)
            {
                _this.destroy();
            }
        }
    };

    this.onKeyDown = onKeyDownHandler;

    this.manager.events.on('KEY_DOWN_EVENT', onKeyDownHandler);
};

KeyCombo.prototype.constructor = KeyCombo;

KeyCombo.prototype = {

    destroy: function ()
    {
        this.enabled = false;
        this.keyCodes = [];

        this.manager.events.off('KEY_DOWN', this.onKeyDown);
        this.manager = undefined;
    }

};

Object.defineProperties(KeyCombo.prototype, {

    progress: {

        enumerable: true,

        //  How far complete is this combo? A value between 0 and 1.
        get: function ()
        {
            return this.index / this.size;
        }

    }

});

module.exports = KeyCombo;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var AdvanceKeyCombo = __webpack_require__(609);

var ProcessKeyCombo = function (event, combo)
{
    if (combo.matched)
    {
        return true;
    }

    var comboMatched = false;
    var keyMatched = false;

    if (event.keyCode === combo.current)
    {
        //  Key was correct

        if (combo.index > 0 && combo.maxKeyDelay > 0)
        {
            //  We have to check to see if the delay between
            //  the new key and the old one was too long (if enabled)

            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;

            //  Check if they pressed it in time or not
            if (event.timeStamp <= timeLimit)
            {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
            }
        }
        else
        {
            keyMatched = true;

            //  We don't check the time for the first key pressed, so just advance it
            comboMatched = AdvanceKeyCombo(event, combo);
        }
    }

    if (!keyMatched && combo.resetOnWrongKey)
    {
        //  Wrong key was pressed
        combo.index = 0;
        combo.current = combo.keyCodes[0];
    }

    if (comboMatched)
    {
        combo.timeLastMatched = event.timeStamp;
        combo.matched = true;
        combo.timeMatched = event.timeStamp;
    }

    return comboMatched;
};

module.exports = ProcessKeyCombo;


/***/ }),
/* 171 */
/***/ (function(module, exports) {

//  A generic Key object which can be passed to the Process functions (and so on)

//  keycode must be an integer

var Key = function (keyCode)
{
    /**
    * @property {integer} keyCode - The keycode of this key.
    */
    this.keyCode = keyCode;

    /**
    * @property {KeyboardEvent} originalEvent - The original DOM event.
    */
    this.originalEvent = undefined;

    /**
    * @property {boolean} preventDefault - Should this Key prevent event propagation?
    * @default
    */
    this.preventDefault = true;

    /**
    * @property {boolean} enabled - Can this Key be processed?
    * @default
    */
    this.enabled = true;

    /**
    * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
    * @default
    */
    this.isDown = false;

    /**
    * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
    * @default
    */
    this.isUp = true;

    /**
    * @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.
    * @default
    */
    this.altKey = false;

    /**
    * @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.
    * @default
    */
    this.ctrlKey = false;

    /**
    * @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.
    * @default
    */
    this.shiftKey = false;

    /**
    * @property {integer} location - The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
    * @default
    */
    this.location = 0;

    /**
    * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
    */
    this.timeDown = 0;

    /**
    * If the key is down this value holds the duration of that key press and is constantly updated.
    * If the key is up it holds the duration of the previous down session.
    * @property {number} duration - The number of milliseconds this key has been held down for.
    * @default
    */
    this.duration = 0;

    /**
    * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
    * @default
    */
    this.timeUp = 0;

    /**
    * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
    * @default
    */
    this.repeats = 0;

    /**
     * @property {boolean} _justDown - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justDown = false;

    /**
     * @property {boolean} _justUp - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justUp = false;
};

Key.prototype.constructor = Key;

module.exports = Key;


/***/ }),
/* 172 */
/***/ (function(module, exports) {

//  https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
//  https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md

var MouseManager = function (inputManager)
{
    this.manager = inputManager;

    this.enabled = false;

    this.target;

    this.handler;
};

MouseManager.prototype.constructor = MouseManager;

MouseManager.prototype = {

    boot: function ()
    {
        var config = this.manager.gameConfig;

        this.enabled = config.inputMouse;
        this.target = config.inputMouseEventTarget;

        if (!this.target)
        {
            this.target = this.manager.game.canvas;
        }

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.manager.queue;

        var handler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);
        };

        this.handler = handler;

        this.target.addEventListener('mousemove', handler, false);
        this.target.addEventListener('mousedown', handler, false);
        this.target.addEventListener('mouseup', handler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('mousemove', this.handler);
        this.target.removeEventListener('mousedown', this.handler);
        this.target.removeEventListener('mouseup', this.handler);
    }
};

module.exports = MouseManager;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(83);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;
};

module.exports = MergeXHRSettings;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);
var ParseXML = __webpack_require__(111);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(177);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ }),
/* 176 */
/***/ (function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ }),
/* 177 */
/***/ (function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ }),
/* 179 */
/***/ (function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ }),
/* 181 */
/***/ (function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(56);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(56);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ }),
/* 185 */
/***/ (function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 186 */
/***/ (function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 187 */
/***/ (function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 188 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 189 */
/***/ (function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 190 */
/***/ (function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 191 */
/***/ (function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ }),
/* 192 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 193 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 194 */
/***/ (function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 195 */
/***/ (function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(178);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ }),
/* 197 */
/***/ (function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.Body

var Class = __webpack_require__(1);
var GetVelocity = __webpack_require__(690);
var UpdateMotion = __webpack_require__(694);
var COLLIDES = __webpack_require__(57);
var TYPE = __webpack_require__(88);

/**
* An Impact.js compatible physics body.
* This re-creates the properties you'd get on an Entity and the math needed to update them.
*
* @class
*/

var Body = new Class({

    initialize:

    function Body (world, x, y, sx, sy)
    {
        if (sx === undefined) { sx = 16; }
        if (sy === undefined) { sy = 16; }

        this.world = world;

        this.enabled = true;

        this.size = { x: sx, y: sy };
        this.pos = { x: x, y: y };
        this.last = { x: x, y: y };
        this.vel = { x: 0, y: 0 };
        this.accel = { x: 0, y: 0 };
        this.friction = { x: 0, y: 0 };
        this.maxVel = { x: 100, y: 100 };
        this.gravityFactor = 1;
        this.standing = false;
        this.bounciness = 0;
        this.minBounceVelocity = 40;

        this.accelGround = 0;
        this.accelAir = 0;
        this.jumpSpeed = 0;
    
        this.type = TYPE.NONE;
        this.checkAgainst = TYPE.NONE;
        this.collides = COLLIDES.NEVER;
    
        //  min 44 deg, max 136 deg
        this.slopeStanding = { min: 0.767944870877505, max: 2.3736477827122884 };
    },

    reset: function ()
    {
        //  TODO
    },

    update: function (delta)
    {
        this.last.x = this.pos.x;
        this.last.y = this.pos.y;

        this.vel.y += this.world.gravity * delta * this.gravityFactor;
        
        this.vel.x = GetVelocity(delta, this.vel.x, this.accel.x, this.friction.x, this.maxVel.x);
        this.vel.y = GetVelocity(delta, this.vel.y, this.accel.y, this.friction.y, this.maxVel.y);
        
        if (window.dumpit)
        {
            console.log('');
            console.log('UPDATE: pos', this.pos.x, this.pos.y, 'vel', this.vel.x, this.vel.y);
        }

        var mx = this.vel.x * delta;
        var my = this.vel.y * delta;

        var res = this.world.collisionMap.trace(this.pos.x, this.pos.y, mx, my, this.size.x, this.size.y);

        UpdateMotion(this, res);

        if (window.dumpit)
        {
            console.log('END res', res.pos.x, res.pos.y);
        }
    },

    skipHash: function ()
    {
        return (!this.enabled || (this.type === 0 && this.checkAgainst === 0 && this.collides === 0));
    },

    touches: function (other)
    {
        return !(
            this.pos.x >= other.pos.x + other.size.x ||
            this.pos.x + this.size.x <= other.pos.x ||
            this.pos.y >= other.pos.y + other.size.y ||
            this.pos.y + this.size.y <= other.pos.y
        );
    },

    setBounce: function (value)
    {
        this.bounciness = value;

        return this;
    },

    setVelocityX: function (x)
    {
        this.vel.x = x;

        return this;
    },

    setVelocityY: function (y)
    {
        this.vel.y = y;

        return this;
    },

    setVelocity: function (x, y)
    {
        this.vel.x = x;
        this.vel.y = y;

        return this;
    },

    setMaxVelocity: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.maxVel.x = x;
        this.maxVel.y = y;

        return this;
    },

    setAccelerationX: function (x)
    {
        this.accel.x = x;

        return this;
    },

    setAccelerationY: function (y)
    {
        this.accel.y = y;

        return this;
    },

    setAcceleration: function (x, y)
    {
        this.accel.x = x;
        this.accel.y = y;

        return this;
    },

    setTypeNone: function ()
    {
        this.type = TYPE.NONE;

        return this;
    },

    setTypeA: function ()
    {
        this.type = TYPE.A;

        return this;
    },

    setTypeB: function ()
    {
        this.type = TYPE.B;

        return this;
    },

    setCheckAgainstNone: function ()
    {
        this.checkAgainst = TYPE.NONE;

        return this;
    },

    setCheckAgainstA: function ()
    {
        this.checkAgainst = TYPE.A;

        return this;
    },

    setCheckAgainstB: function ()
    {
        this.checkAgainst = TYPE.B;

        return this;
    },

    setCollidesNever: function ()
    {
        this.collides = COLLIDES.NEVER;

        return this;
    },

    setLite: function ()
    {
        this.collides = COLLIDES.LITE;

        return this;
    },

    setPassive: function ()
    {
        this.collides = COLLIDES.PASSIVE;

        return this;
    },

    setActive: function ()
    {
        this.collides = COLLIDES.ACTIVE;

        return this;
    },

    setFixed: function ()
    {
        this.collides = COLLIDES.FIXED;

        return this;
    },

    check: function (other)
    {
        //  Overridden by user code
    },

    collideWith: function (other, axis)
    {
        //  Overridden by user code
    }

});

module.exports = Body;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.CollisionMap

var Class = __webpack_require__(1);
var DefaultDefs = __webpack_require__(689);

var CollisionMap = new Class({

    initialize:

    function CollisionMap (tilesize, data)
    {
        this.tilesize = tilesize;

        this.data = data;

        this.width = (Array.isArray(data)) ? data[0].length : 0;
        this.height = (Array.isArray(data)) ? data.length : 0;

        this.lastSlope = 55;

        this.tiledef = DefaultDefs;
    },

    trace: function (x, y, vx, vy, objectWidth, objectHeight)
    {
        // Set up the trace-result
        var res = {
            collision: { x: false, y: false, slope: false },
            pos: { x: x, y: y },
            tile: { x: 0, y: 0 }
        };

        if (!this.data)
        {
            res.pos.x += vx;
            res.pos.y += vy;

            return res;
        }
        
        var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);

        if (steps > 1)
        {
            var sx = vx / steps;
            var sy = vy / steps;
            
            for (var i = 0; i < steps && (sx || sy); i++)
            {
                this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);
                
                x = res.pos.x;
                y = res.pos.y;

                if (res.collision.x)
                {
                    sx = 0;
                    vx = 0;
                }

                if (res.collision.y)
                {
                    sy = 0;
                    vy = 0;
                }

                if (res.collision.slope)
                {
                    break;
                }
            }
        }
        else
        {
            this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);
        }
        
        return res;
    },

    step: function (res, x, y, vx, vy, width, height, rvx, rvy, step)
    {
        res.pos.x += vx;
        res.pos.y += vy;

        if (window.dumpit)
        {
            console.log('STEP', res.pos.x, res.pos.y, 'VX', vx, 'VY', vy, 'step', step);
        }
        
        var t = 0;
        var tilesize = this.tilesize;
        var mapWidth = this.width;
        var mapHeight = this.height;
        
        //  Horizontal
        if (vx)
        {
            var pxOffsetX = (vx > 0 ? width : 0);
            var tileOffsetX = (vx < 0 ? tilesize : 0);
            
            var firstTileY = Math.max(Math.floor(y / tilesize), 0);
            var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);
            var tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);

            var prevTileX = Math.floor((x + pxOffsetX) / tilesize);

            if (step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth)
            {
                prevTileX = -1;
            }

            if (window.debugslopes)
            {
                console.group('VX');
                console.log('pxOffsetX', pxOffsetX);
                console.log('tileOffsetX', tileOffsetX);
                console.log('firstTileY', firstTileY);
                console.log('lastTileY', lastTileY);
                console.log('tileX', tileX);
                console.log('prevTileX', prevTileX);
            }
            
            if (tileX >= 0 && tileX < mapWidth)
            {
                // console.log('X:', tileX);

                for (var tileY = firstTileY; tileY < lastTileY; tileY++)
                {
                    // console.log('Y:', tileY);

                    if (prevTileX !== -1)
                    {
                        t = this.data[tileY][prevTileX];

                        // console.log('t1', t);

                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY))
                        {
                            // console.log('t1 break');
                            break;
                        }
                    }
                    
                    t = this.data[tileY][tileX];

                        if (window.debugslopes)
                        {
                            console.log('Tile at', tileX, 'x', tileY, '=', t);
                        }

                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))
                    {
                        if (t > 1 && t <= this.lastSlope && res.collision.slope)
                        {
                            // console.log('t2 break');
                            break;
                        }
                        
                        res.collision.x = true;
                        res.tile.x = t;
                        res.pos.x = (tileX * tilesize) - pxOffsetX + tileOffsetX;
                        x = res.pos.x;
                        rvx = 0;

                        if (window.debugslopes)
                        {
                            console.log('>>> Hit solid tile <<<');

                            console.log('tileX', tileX);
                            console.log('tilesize', tilesize);
                            console.log('pxOffsetX', pxOffsetX);
                            console.log('tileOffsetX', tileOffsetX);
                            console.log('=', res.pos.x);
                        }

                        //  9 * 32 = 288
                        //  - 16 = 272
                        //  + 0 = 272

                        //  Where does the 16 come from?

                        break;
                    }
                }
            }

            if (window.debugslopes)
            {
                console.groupEnd();
            }
        }
        
        //  Vertical
        if (vy)
        {
            var pxOffsetY = (vy > 0 ? height : 0);
            var tileOffsetY = (vy < 0 ? tilesize : 0);
            
            var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);
            var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);
            var tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);
            
            var prevTileY = Math.floor((y + pxOffsetY) / tilesize);

            if (step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight)
            {
                prevTileY = -1;
            }
            
            if (tileY >= 0 && tileY < mapHeight)
            {
                for (var tileX = firstTileX; tileX < lastTileX; tileX++)
                {
                    if (prevTileY !== -1)
                    {
                        t = this.data[prevTileY][tileX];

                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY))
                        {
                            break;
                        }
                    }
                    
                    t = this.data[tileY][tileX];

                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))
                    {
                        if (t > 1 && t <= this.lastSlope && res.collision.slope)
                        {
                            break;
                        }
                        
                        res.collision.y = true;
                        res.tile.y = t;
                        res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;

                        break;
                    }
                }
            }
        }
    },
    
    checkDef: function (res, t, x, y, vx, vy, width, height, tileX, tileY)
    {
        var def = this.tiledef[t];

        if (!def)
        {
            return false;
        }

        var tilesize = this.tilesize;
        
        var lx = (tileX + def[0]) * tilesize;
        var ly = (tileY + def[1]) * tilesize;
        var lvx = (def[2] - def[0]) * tilesize;
        var lvy = (def[3] - def[1]) * tilesize;
        var solid = def[4];
        
        var tx = x + vx + (lvy < 0 ? width : 0) - lx;
        var ty = y + vy + (lvx > 0 ? height : 0) - ly;
        
        if (lvx * ty - lvy * tx > 0)
        {
            if (vx * -lvy + vy * lvx < 0)
            {
                return solid;
            }
            
            var length = Math.sqrt(lvx * lvx + lvy * lvy);
            var nx = lvy / length;
            var ny = -lvx / length;
            
            var proj = tx * nx + ty * ny;
            var px = nx * proj;
            var py = ny * proj;
            
            if (px * px + py * py >= vx * vx + vy * vy)
            {
                return solid || (lvx * (ty - vy) - lvy * (tx - vx) < 0.5);
            }
            
            res.pos.x = x + vx - px;
            res.pos.y = y + vy - py;
            res.collision.slope = { x: lvx, y: lvy, nx: nx, ny: ny };

            return true;
        }
        
        return false;
    }

});

module.exports = CollisionMap;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/

var World = {};

module.exports = World;

var Composite = __webpack_require__(29);
var Constraint = __webpack_require__(47);
var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */
    World.create = function(options) {
        var composite = Composite.create();

        var defaults = {
            label: 'World',
            gravity: {
                x: 0,
                y: 1,
                scale: 0.001
            },
            bounds: { 
                min: { x: -Infinity, y: -Infinity }, 
                max: { x: Infinity, y: Infinity } 
            }
        };
        
        return Common.extend(composite, defaults, options);
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * The gravity to apply on the world.
     *
     * @property gravity
     * @type object
     */

    /**
     * The gravity x component.
     *
     * @property gravity.x
     * @type object
     * @default 0
     */

    /**
     * The gravity y component.
     *
     * @property gravity.y
     * @type object
     * @default 1
     */

    /**
     * The gravity scale factor.
     *
     * @property gravity.scale
     * @type object
     * @default 0.001
     */

    /**
     * A `Bounds` object that defines the world bounds for collision detection.
     *
     * @property bounds
     * @type bounds
     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }
     */

    // World is a Composite body
    // see src/module/Outro.js for these aliases:
    
    /**
     * An alias for Composite.clear
     * @method clear
     * @param {world} world
     * @param {boolean} keepStatic
     */

    /**
     * An alias for Composite.add
     * @method addComposite
     * @param {world} world
     * @param {composite} composite
     * @return {world} The original world with the objects from composite added
     */
    
     /**
      * An alias for Composite.addBody
      * @method addBody
      * @param {world} world
      * @param {body} body
      * @return {world} The original world with the body added
      */

     /**
      * An alias for Composite.addConstraint
      * @method addConstraint
      * @param {world} world
      * @param {constraint} constraint
      * @return {world} The original world with the constraint added
      */

})();


/***/ }),
/* 201 */
/***/ (function(module, exports) {

/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/

var Contact = {};

module.exports = Contact;

(function() {

    /**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */
    Contact.create = function(vertex) {
        return {
            id: Contact.id(vertex),
            vertex: vertex,
            normalImpulse: 0,
            tangentImpulse: 0
        };
    };
    
    /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */
    Contact.id = function(vertex) {
        return vertex.body.id + '_' + vertex.index;
    };

})();


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/

var Pairs = {};

module.exports = Pairs;

var Pair = __webpack_require__(58);
var Common = __webpack_require__(2);

(function() {
    
    var _pairMaxIdleLife = 1000;

    /**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */
    Pairs.create = function(options) {
        return Common.extend({ 
            table: {},
            list: [],
            collisionStart: [],
            collisionActive: [],
            collisionEnd: []
        }, options);
    };

    /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */
    Pairs.update = function(pairs, collisions, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            collisionStart = pairs.collisionStart,
            collisionEnd = pairs.collisionEnd,
            collisionActive = pairs.collisionActive,
            activePairIds = [],
            collision,
            pairId,
            pair,
            i;

        // clear collision state arrays, but maintain old reference
        collisionStart.length = 0;
        collisionEnd.length = 0;
        collisionActive.length = 0;

        for (i = 0; i < collisions.length; i++) {
            collision = collisions[i];

            if (collision.collided) {
                pairId = Pair.id(collision.bodyA, collision.bodyB);
                activePairIds.push(pairId);

                pair = pairsTable[pairId];
                
                if (pair) {
                    // pair already exists (but may or may not be active)
                    if (pair.isActive) {
                        // pair exists and is active
                        collisionActive.push(pair);
                    } else {
                        // pair exists but was inactive, so a collision has just started again
                        collisionStart.push(pair);
                    }

                    // update the pair
                    Pair.update(pair, collision, timestamp);
                } else {
                    // pair did not exist, create a new pair
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;

                    // push the new pair
                    collisionStart.push(pair);
                    pairsList.push(pair);
                }
            }
        }

        // deactivate previously active pairs that are now inactive
        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {
                Pair.setActive(pair, false, timestamp);
                collisionEnd.push(pair);
            }
        }
    };
    
    /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */
    Pairs.removeOld = function(pairs, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            indexesToRemove = [],
            pair,
            collision,
            pairIndex,
            i;

        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            collision = pair.collision;
            
            // never remove sleeping pairs
            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                pair.timeUpdated = timestamp;
                continue;
            }

            // if pair is inactive for too long, mark it to be removed
            if (timestamp - pair.timeUpdated > _pairMaxIdleLife) {
                indexesToRemove.push(i);
            }
        }

        // remove marked pairs
        for (i = 0; i < indexesToRemove.length; i++) {
            pairIndex = indexesToRemove[i] - i;
            pair = pairsList[pairIndex];
            delete pairsTable[pair.id];
            pairsList.splice(pairIndex, 1);
        }
    };

    /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */
    Pairs.clear = function(pairs) {
        pairs.table = {};
        pairs.list.length = 0;
        pairs.collisionStart.length = 0;
        pairs.collisionActive.length = 0;
        pairs.collisionEnd.length = 0;
        return pairs;
    };

})();


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/

var Resolver = {};

module.exports = Resolver;

var Vertices = __webpack_require__(31);
var Vector = __webpack_require__(13);
var Common = __webpack_require__(2);
var Bounds = __webpack_require__(12);

(function() {

    Resolver._restingThresh = 4;
    Resolver._restingThreshTangent = 6;
    Resolver._positionDampen = 0.9;
    Resolver._positionWarming = 0.8;
    Resolver._frictionNormalMultiplier = 5;

    /**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */
    Resolver.preSolvePosition = function(pairs) {
        var i,
            pair,
            activeCount;

        // find total contacts on each body
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive)
                continue;
            
            activeCount = pair.activeContacts.length;
            pair.collision.parentA.totalContacts += activeCount;
            pair.collision.parentB.totalContacts += activeCount;
        }
    };

    /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solvePosition = function(pairs, timeScale) {
        var i,
            pair,
            collision,
            bodyA,
            bodyB,
            normal,
            bodyBtoA,
            contactShare,
            positionImpulse,
            contactCount = {},
            tempA = Vector._temp[0],
            tempB = Vector._temp[1],
            tempC = Vector._temp[2],
            tempD = Vector._temp[3];

        // find impulses required to resolve penetration
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;

            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;

            // get current separation between body edges involved in collision
            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), 
                                    Vector.add(bodyA.positionImpulse, 
                                        Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);

            pair.separation = Vector.dot(normal, bodyBtoA);
        }
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive || pair.isSensor || pair.separation < 0)
                continue;
            
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            positionImpulse = (pair.separation - pair.slop) * timeScale;

            if (bodyA.isStatic || bodyB.isStatic)
                positionImpulse *= 2;
            
            if (!(bodyA.isStatic || bodyA.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyA.totalContacts;
                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
            }

            if (!(bodyB.isStatic || bodyB.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyB.totalContacts;
                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
            }
        }
    };

    /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */
    Resolver.postSolvePosition = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset contact count
            body.totalContacts = 0;

            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                // update body geometry
                for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                }

                // move the body without changing velocity
                body.positionPrev.x += body.positionImpulse.x;
                body.positionPrev.y += body.positionImpulse.y;

                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    // reset cached impulse if the body has velocity along it
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                } else {
                    // warm the next iteration
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                }
            }
        }
    };

    /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */
    Resolver.preSolveVelocity = function(pairs) {
        var i,
            j,
            pair,
            contacts,
            collision,
            bodyA,
            bodyB,
            normal,
            tangent,
            contact,
            contactVertex,
            normalImpulse,
            tangentImpulse,
            offset,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1];
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            contacts = pair.activeContacts;
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            tangent = collision.tangent;

            // resolve each contact
            for (j = 0; j < contacts.length; j++) {
                contact = contacts[j];
                contactVertex = contact.vertex;
                normalImpulse = contact.normalImpulse;
                tangentImpulse = contact.tangentImpulse;

                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    // total impulse from contact
                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                    
                    // apply impulse from contact
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyA.position, tempA);
                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }

                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyB.position, tempA);
                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                }
            }
        }
    };

    /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solveVelocity = function(pairs, timeScale) {
        var timeScaleSquared = timeScale * timeScale,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1],
            tempB = Vector._temp[2],
            tempC = Vector._temp[3],
            tempD = Vector._temp[4],
            tempE = Vector._temp[5];
        
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            var collision = pair.collision,
                bodyA = collision.parentA,
                bodyB = collision.parentB,
                normal = collision.normal,
                tangent = collision.tangent,
                contacts = pair.activeContacts,
                contactShare = 1 / contacts.length;

            // update body velocities
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // resolve each contact
            for (var j = 0; j < contacts.length; j++) {
                var contact = contacts[j],
                    contactVertex = contact.vertex,
                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),
                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),
                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),
                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), 
                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),
                    normalVelocity = Vector.dot(normal, relativeVelocity);

                var tangentVelocity = Vector.dot(tangent, relativeVelocity),
                    tangentSpeed = Math.abs(tangentVelocity),
                    tangentVelocityDirection = Common.sign(tangentVelocity);

                // raw impulses
                var normalImpulse = (1 + pair.restitution) * normalVelocity,
                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;

                // coulomb friction
                var tangentImpulse = tangentVelocity,
                    maxFriction = Infinity;

                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(
                        pair.friction * tangentVelocityDirection * timeScaleSquared,
                        -maxFriction, maxFriction
                    );
                }

                // modify impulses accounting for mass, inertia and offset
                var oAcN = Vector.cross(offsetA, normal),
                    oBcN = Vector.cross(offsetB, normal),
                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);

                normalImpulse *= share;
                tangentImpulse *= share;

                // handle high velocity and resting collisions separately
                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    // high normal velocity so clear cached contact normal impulse
                    contact.normalImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // impulse constraint tends to 0
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                }

                // handle high velocity and resting collisions separately
                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    // high tangent velocity so clear cached contact tangent impulse
                    contact.tangentImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                }

                // total impulse from contact
                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                
                // apply impulse from contact
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                }

                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                }
            }
        }
    };

})();


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/

var Engine = {};

module.exports = Engine;

var World = __webpack_require__(200);
var Sleeping = __webpack_require__(48);
var Resolver = __webpack_require__(203);
var Render = __webpack_require__(95);
var Pairs = __webpack_require__(202);
var Metrics = __webpack_require__(205);
var Grid = __webpack_require__(90);
var Events = __webpack_require__(30);
var Composite = __webpack_require__(29);
var Constraint = __webpack_require__(47);
var Common = __webpack_require__(2);
var Body = __webpack_require__(46);

(function() {

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */
    Engine.create = function(element, options) {
        // options may be passed as the first (and only) argument
        options = Common.isElement(element) ? options : element;
        element = Common.isElement(element) ? element : null;
        options = options || {};

        if (element || options.render) {
            Common.warn('Engine.create: engine.render is deprecated (see docs)');
        }

        var defaults = {
            positionIterations: 6,
            velocityIterations: 4,
            constraintIterations: 2,
            enableSleeping: false,
            events: [],
            plugin: {},
            timing: {
                timestamp: 0,
                timeScale: 1
            },
            broadphase: {
                controller: Grid
            }
        };

        var engine = Common.extend(defaults, options);

        // @deprecated
        if (element || engine.render) {
            var renderDefaults = {
                element: element,
                controller: Render
            };
            
            engine.render = Common.extend(renderDefaults, engine.render);
        }

        // @deprecated
        if (engine.render && engine.render.controller) {
            engine.render = engine.render.controller.create(engine.render);
        }

        // @deprecated
        if (engine.render) {
            engine.render.engine = engine;
        }

        engine.world = options.world || World.create(engine.world);
        engine.pairs = Pairs.create();
        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
        engine.metrics = engine.metrics || { extended: false };

        // @if DEBUG
        engine.metrics = Metrics.create(engine.metrics);
        // @endif

        return engine;
    };

    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */
    Engine.update = function(engine, delta, correction) {
        delta = delta || 1000 / 60;
        correction = correction || 1;

        var world = engine.world,
            timing = engine.timing,
            broadphase = engine.broadphase,
            broadphasePairs = [],
            i;

        // increment timestamp
        timing.timestamp += delta * timing.timeScale;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(engine, 'beforeUpdate', event);

        // get lists of all bodies and constraints, no matter what composites they are in
        var allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world);

        // @if DEBUG
        // reset metrics logging
        Metrics.reset(engine.metrics);
        // @endif

        // if sleeping enabled, call the sleeping controller
        if (engine.enableSleeping)
            Sleeping.update(allBodies, timing.timeScale);

        // applies gravity to all bodies
        _bodiesApplyGravity(allBodies, world.gravity);

        // update all body position and rotation by integration
        _bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);

        // update all constraints
        for (i = 0; i < engine.constraintIterations; i++) {
            Constraint.solveAll(allConstraints, timing.timeScale);
        }
        Constraint.postSolveAll(allBodies);

        // broadphase pass: find potential collision pairs
        if (broadphase.controller) {

            // if world is dirty, we must flush the whole grid
            if (world.isModified)
                broadphase.controller.clear(broadphase);

            // update the grid buckets based on current bodies
            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
            broadphasePairs = broadphase.pairsList;
        } else {

            // if no broadphase set, we just pass all bodies
            broadphasePairs = allBodies;
        }

        // clear all composite modified flags
        if (world.isModified) {
            Composite.setModified(world, false, false, true);
        }

        // narrowphase pass: find actual collisions, then create or update collision pairs
        var collisions = broadphase.detector(broadphasePairs, engine);

        // update collision pairs
        var pairs = engine.pairs,
            timestamp = timing.timestamp;
        Pairs.update(pairs, collisions, timestamp);
        Pairs.removeOld(pairs, timestamp);

        // wake up bodies involved in collisions
        if (engine.enableSleeping)
            Sleeping.afterCollisions(pairs.list, timing.timeScale);

        // trigger collision events
        if (pairs.collisionStart.length > 0)
            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });

        // iteratively resolve position between collisions
        Resolver.preSolvePosition(pairs.list);
        for (i = 0; i < engine.positionIterations; i++) {
            Resolver.solvePosition(pairs.list, timing.timeScale);
        }
        Resolver.postSolvePosition(allBodies);

        // iteratively resolve velocity between collisions
        Resolver.preSolveVelocity(pairs.list);
        for (i = 0; i < engine.velocityIterations; i++) {
            Resolver.solveVelocity(pairs.list, timing.timeScale);
        }

        // trigger collision events
        if (pairs.collisionActive.length > 0)
            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });

        if (pairs.collisionEnd.length > 0)
            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });

        // @if DEBUG
        // update metrics log
        Metrics.update(engine.metrics, engine);
        // @endif

        // clear force buffers
        _bodiesClearForces(allBodies);

        Events.trigger(engine, 'afterUpdate', event);

        return engine;
    };
    
    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */
    Engine.merge = function(engineA, engineB) {
        Common.extend(engineA, engineB);
        
        if (engineB.world) {
            engineA.world = engineB.world;

            Engine.clear(engineA);

            var bodies = Composite.allBodies(engineA.world);

            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                Sleeping.set(body, false);
                body.id = Common.nextId();
            }
        }
    };

    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */
    Engine.clear = function(engine) {
        var world = engine.world;
        
        Pairs.clear(engine.pairs);

        var broadphase = engine.broadphase;
        if (broadphase.controller) {
            var bodies = Composite.allBodies(world);
            broadphase.controller.clear(broadphase);
            broadphase.controller.update(broadphase, bodies, engine, true);
        }
    };

    /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method bodiesClearForces
     * @private
     * @param {body[]} bodies
     */
    var _bodiesClearForces = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset force buffers
            body.force.x = 0;
            body.force.y = 0;
            body.torque = 0;
        }
    };

    /**
     * Applys a mass dependant force to all given bodies.
     * @method bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */
    var _bodiesApplyGravity = function(bodies, gravity) {
        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;

        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {
            return;
        }
        
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            // apply gravity
            body.force.y += body.mass * gravity.y * gravityScale;
            body.force.x += body.mass * gravity.x * gravityScale;
        }
    };

    /**
     * Applys `Body.update` to all given `bodies`.
     * @method updateAll
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */
    var _bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            Body.update(body, deltaTime, timeScale, correction);
        }
    };

    /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method run
     * @param {engine} engine
     */

    /**
    * Fired just before an update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update and all collision events
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
    *
    * @event collisionStart
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
    *
    * @event collisionActive
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
    *
    * @event collisionEnd
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property positionIterations
     * @type number
     * @default 6
     */

    /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property velocityIterations
     * @type number
     * @default 4
     */

    /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * The default value of `2` is usually very adequate.
     *
     * @property constraintIterations
     * @type number
     * @default 2
     */

    /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     *
     * @property enableSleeping
     * @type boolean
     * @default false
     */

    /**
     * An `Object` containing properties regarding the timing systems of the engine. 
     *
     * @property timing
     * @type object
     */

    /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
     * A value of `0.1` gives a slow-motion effect.
     * A value of `1.2` gives a speed-up effect.
     *
     * @property timing.timeScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. 
     * It is incremented on every `Engine.update` by the given `delta` argument. 
     *
     * @property timing.timestamp
     * @type number
     * @default 0
     */

    /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
     *
     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     *
     * @property render
     * @type render
     * @deprecated see Demo.js for an example of creating a renderer
     * @default a Matter.Render instance
     */

    /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     *
     * @property broadphase
     * @type grid
     * @default a Matter.Grid instance
     */

    /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     *
     * @property world
     * @type world
     * @default a Matter.World instance
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

// @if DEBUG
/**
* _Internal Class_, not generally used outside of the engine's internals.
*
*/

var Metrics = {};

module.exports = Metrics;

var Composite = __webpack_require__(29);
var Common = __webpack_require__(2);

(function() {

    /**
     * Creates a new metrics.
     * @method create
     * @private
     * @return {metrics} A new metrics
     */
    Metrics.create = function(options) {
        var defaults = {
            extended: false,
            narrowDetections: 0,
            narrowphaseTests: 0,
            narrowReuse: 0,
            narrowReuseCount: 0,
            midphaseTests: 0,
            broadphaseTests: 0,
            narrowEff: 0.0001,
            midEff: 0.0001,
            broadEff: 0.0001,
            collisions: 0,
            buckets: 0,
            bodies: 0,
            pairs: 0
        };

        return Common.extend(defaults, false, options);
    };

    /**
     * Resets metrics.
     * @method reset
     * @private
     * @param {metrics} metrics
     */
    Metrics.reset = function(metrics) {
        if (metrics.extended) {
            metrics.narrowDetections = 0;
            metrics.narrowphaseTests = 0;
            metrics.narrowReuse = 0;
            metrics.narrowReuseCount = 0;
            metrics.midphaseTests = 0;
            metrics.broadphaseTests = 0;
            metrics.narrowEff = 0;
            metrics.midEff = 0;
            metrics.broadEff = 0;
            metrics.collisions = 0;
            metrics.buckets = 0;
            metrics.pairs = 0;
            metrics.bodies = 0;
        }
    };

    /**
     * Updates metrics.
     * @method update
     * @private
     * @param {metrics} metrics
     * @param {engine} engine
     */
    Metrics.update = function(metrics, engine) {
        if (metrics.extended) {
            var world = engine.world,
                bodies = Composite.allBodies(world);

            metrics.collisions = metrics.narrowDetections;
            metrics.pairs = engine.pairs.list.length;
            metrics.bodies = bodies.length;
            metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
            metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
            metrics.broadEff = (1 - (metrics.broadphaseTests / (bodies.length || 1))).toFixed(2);
            metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
            //var broadphase = engine.broadphase[engine.broadphase.current];
            //if (broadphase.instance)
            //    metrics.buckets = Common.keys(broadphase.instance.buckets).length;
        }
    };

})();
// @endif


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/

var Plugin = {};

module.exports = Plugin;

var Common = __webpack_require__(2);

(function() {

    Plugin._registry = {};

    /**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */
    Plugin.register = function(plugin) {
        if (!Plugin.isPlugin(plugin)) {
            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');
        }

        if (plugin.name in Plugin._registry) {
            var registered = Plugin._registry[plugin.name],
                pluginVersion = Plugin.versionParse(plugin.version).number,
                registeredVersion = Plugin.versionParse(registered.version).number;

            if (pluginVersion > registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));
                Plugin._registry[plugin.name] = plugin;
            } else if (pluginVersion < registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));
            } else if (plugin !== registered) {
                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');
            }
        } else {
            Plugin._registry[plugin.name] = plugin;
        }

        return plugin;
    };

    /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */
    Plugin.resolve = function(dependency) {
        return Plugin._registry[Plugin.dependencyParse(dependency).name];
    };

    /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */
    Plugin.toString = function(plugin) {
        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');
    };

    /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */
    Plugin.isPlugin = function(obj) {
        return obj && obj.name && obj.version && obj.install;
    };

    /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */
    Plugin.isUsed = function(module, name) {
        return module.used.indexOf(name) > -1;
    };

    /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */
    Plugin.isFor = function(plugin, module) {
        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));
    };

    /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick ✅ indicates a dependency was resolved and installed.
     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross ❌ indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */
    Plugin.use = function(module, plugins) {
        module.uses = (module.uses || []).concat(plugins || []);

        if (module.uses.length === 0) {
            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');
            return;
        }

        var dependencies = Plugin.dependencies(module),
            sortedDependencies = Common.topologicalSort(dependencies),
            status = [];

        for (var i = 0; i < sortedDependencies.length; i += 1) {
            if (sortedDependencies[i] === module.name) {
                continue;
            }

            var plugin = Plugin.resolve(sortedDependencies[i]);

            if (!plugin) {
                status.push('❌ ' + sortedDependencies[i]);
                continue;
            }

            if (Plugin.isUsed(module, plugin.name)) {
                continue;
            }

            if (!Plugin.isFor(plugin, module)) {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');
                plugin._warned = true;
            }

            if (plugin.install) {
                plugin.install(module);
            } else {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');
                plugin._warned = true;
            }

            if (plugin._warned) {
                status.push('🔶 ' + Plugin.toString(plugin));
                delete plugin._warned;
            } else {
                status.push('✅ ' + Plugin.toString(plugin));
            }

            module.used.push(plugin.name);
        }

        if (status.length > 0) {
            Common.info(status.join('  '));
        }
    };

    /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */
    Plugin.dependencies = function(module, tracked) {
        var parsedBase = Plugin.dependencyParse(module),
            name = parsedBase.name;

        tracked = tracked || {};

        if (name in tracked) {
            return;
        }

        module = Plugin.resolve(module) || module;

        tracked[name] = Common.map(module.uses || [], function(dependency) {
            if (Plugin.isPlugin(dependency)) {
                Plugin.register(dependency);
            }

            var parsed = Plugin.dependencyParse(dependency),
                resolved = Plugin.resolve(dependency);

            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',
                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'
                );

                resolved._warned = true;
                module._warned = true;
            } else if (!resolved) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',
                    Plugin.toString(parsedBase), 'could not be resolved.'
                );

                module._warned = true;
            }

            return parsed.name;
        });

        for (var i = 0; i < tracked[name].length; i += 1) {
            Plugin.dependencies(tracked[name][i], tracked);
        }

        return tracked;
    };

    /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */
    Plugin.dependencyParse = function(dependency) {
        if (Common.isString(dependency)) {
            var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;

            if (!pattern.test(dependency)) {
                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');
            }

            return {
                name: dependency.split('@')[0],
                range: dependency.split('@')[1] || '*'
            };
        }

        return {
            name: dependency.name,
            range: dependency.range || dependency.version
        };
    };

    /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */
    Plugin.versionParse = function(range) {
        var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;

        if (!pattern.test(range)) {
            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');
        }

        var identifiers = range.split('-');
        range = identifiers[0];

        var isRange = isNaN(Number(range[0])),
            version = isRange ? range.substr(1) : range,
            parts = Common.map(version.split('.'), function(part) {
                return Number(part);
            });

        return {
            isRange: isRange,
            version: version,
            range: range,
            operator: isRange ? range[0] : '',
            parts: parts,
            prerelease: identifiers[1],
            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
        };
    };

    /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */
    Plugin.versionSatisfies = function(version, range) {
        range = range || '*';

        var rangeParsed = Plugin.versionParse(range),
            rangeParts = rangeParsed.parts,
            versionParsed = Plugin.versionParse(version),
            versionParts = versionParsed.parts;

        if (rangeParsed.isRange) {
            if (rangeParsed.operator === '*' || version === '*') {
                return true;
            }

            if (rangeParsed.operator === '~') {
                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
            }

            if (rangeParsed.operator === '^') {
                if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                }

                if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }

                return versionParts[2] === rangeParts[2];
            }
        }

        return version === range || version === '*';
    };

})();


/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    makeCCW: polygonMakeCCW
};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2){
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	var da = q2[0] - q1[0];
	var db = q2[1] - q1[1];

	// segments are parallel
	if((da*dy - db*dx) === 0){
		return false;
	}

	var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
	var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);

	return (s>=0 && s<=1 && t>=0 && t<=1);
}

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
}

function isLeft(a,b,c){
    return triangleArea(a,b,c) > 0;
}

function isLeftOn(a,b,c) {
    return triangleArea(a, b, c) >= 0;
}

function isRight(a,b,c) {
    return triangleArea(a, b, c) < 0;
}

function isRightOn(a,b,c) {
    return triangleArea(a, b, c) <= 0;
}

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a,b,c,thresholdAngle) {
    if(!thresholdAngle){
        return triangleArea(a, b, c) === 0;
    } else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
}

function sqdist(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i){
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon){
    polygon.length = 0;
}

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to){
    for(var i=from; i<to; i++){
        polygon.push(poly[i]);
    }
}

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon){
    var br = 0,
        v = polygon;

    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
    }
}

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon){
    var tmp = [];
    var N = polygon.length;
    for(var i=0; i!==N; i++){
        tmp.push(polygon.pop());
    }
    for(var i=0; i!==N; i++){
		polygon[i] = tmp[i];
    }
}

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i){
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1,l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
}

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i,j,targetPoly){
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++){
            p.push(polygon[k]);
        }

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++){
            p.push(polygon[k]);
        }

        // Insert vertices i to end
        for(var k=i; k<polygon.length; k++){
            p.push(polygon[k]);
        }
    }

    return p;
}

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min=[], tmp1=[], tmp2=[], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                    for(var k=0; k<tmp2.length; k++){
                        tmp1.push(tmp2[k]);
                    }

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                }
            }
        }
    }

    return min;
}

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon){
    var edges = polygonGetCutEdges(polygon);
    if(edges.length > 0){
        return polygonSlice(polygon, edges);
    } else {
        return [polygon];
    }
}

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges){
    if(cutEdges.length === 0){
		return [polygon];
    }
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){

        var polys = [polygon];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);

        if(i !== -1 && j !== -1){
            return [polygonCopy(polygon, i,j),
                    polygonCopy(polygon, j,i)];
        } else {
            return false;
        }
    }
}

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon){
    var path = polygon, i;
    // Check
    for(i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(i=1; i<path.length-2; i++){
        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
}

function getIntersectionPoint(p1, p2, q1, q2, delta){
	delta = delta || 0;
	var a1 = p2[1] - p1[1];
	var b1 = p1[0] - p2[0];
	var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	var a2 = q2[1] - q1[1];
	var b2 = q1[0] - q2[0];
	var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	var det = (a1 * b2) - (a2 * b1);

	if(!scalar_eq(det,0,delta)){
		return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];
	} else {
		return [0,0];
    }
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!=="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=[], upperPoly=[]; // polygons
    var poly = polygon,
        v = polygon;

    if(v.length < 3){
		return result;
    }

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly,i,poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly,0,upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly,i,closestIndex+1);
                    if (closestIndex !== 0){
                        polygonAppend(upperPoly, poly,closestIndex,v.length);
                    }
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        polygonAppend(lowerPoly, poly,i,v.length);
                    }
                    polygonAppend(lowerPoly, poly,0,closestIndex+1);
                    polygonAppend(upperPoly, poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(polygon);

    return result;
}

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision){
    var num = 0;
    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){
        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){
            // Remove the middle point
            polygon.splice(i%polygon.length,1);
            num++;
        }
    }
    return num;
}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
}


/***/ }),
/* 208 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2)
    VERTEX_SIZE: 16,
    INDEX_SIZE: 2,
    TILEMAP_VERTEX_COUNT: 4,
    TILEMAP_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    TILEMAP_VERTEX_COMPONENT_COUNT: 4,
    MAX_TILEMAP: 2000,

};

module.exports = CONST;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    IndexBuffer: __webpack_require__(734),
    RenderTarget: __webpack_require__(735),
    Shader: __webpack_require__(736),
    Texture: __webpack_require__(737),
    VertexBuffer: __webpack_require__(738)

};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    CanvasSnapshot: __webpack_require__(743),
    WebGLSnapshot: __webpack_require__(744)
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {


var CameraManager = __webpack_require__(750);
var Component = __webpack_require__(4);
var EventDispatcher = __webpack_require__(15);
var GameObjectCreator = __webpack_require__(751);
var GameObjectFactory = __webpack_require__(752);
var Loader = __webpack_require__(753);
var Settings = __webpack_require__(748);
var StableSort = __webpack_require__(807);
var StateManager = __webpack_require__(754);
var UpdateManager = __webpack_require__(755);
var TweenManager = __webpack_require__(775);

var Systems = function (state, config)
{
    this.state = state;

    this.config = config;
    this.settings = Settings.create(config);

    this.x = this.settings.x;
    this.y = this.settings.y;
    this.width = this.settings.width;
    this.height = this.settings.height;

    this.sortChildrenFlag = false;

    //  Set by the GlobalStateManager
    this.mask = null;
    this.canvas;
    this.context;

    //  CORE (GLOBAL) SYSTEMS / PROPERTIES

    this.game;

    this.anims;
    this.cache;
    this.input;
    this.textures;

    //  Reference to State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.cameras;
    this.events;
    this.load;
    this.make;
    this.stateManager;
    this.updates;
    this.tweens;

    //  State properties
    this.children;
    this.color;
    this.data;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function (game)
    {
        this.game = game;

        Settings.init(this.settings, this.game.config);

        this.width = this.settings.width;
        this.height = this.settings.height;

        this.anims = this.game.anims;
        this.cache = this.game.cache;
        this.input = this.game.input;
        this.textures = this.game.textures;

        //  State specific properties (transform, data, children, etc)

        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)

        this.add = new GameObjectFactory(this.state);
        this.cameras = new CameraManager(this.state);
        this.events = new EventDispatcher();
        this.load = new Loader(this.state);
        this.make = new GameObjectCreator(this.state);
        this.stateManager = new StateManager(this.state, game);
        this.tweens = new TweenManager(this.state);
        this.updates = new UpdateManager(this.state);

        this.inject();
    },

    inject: function ()
    {
        //  Defaults properties injected into the State

        this.state.game = this.game;

        this.state.anims = this.anims;
        this.state.cache = this.cache;
        this.state.input = this.input;
        this.state.textures = this.textures;

        this.state.add = this.add;
        this.state.make = this.make;
        this.state.cameras = this.cameras;
        this.state.events = this.events;
        this.state.load = this.load;
        this.state.settings = this.settings;
        this.state.state = this.stateManager;
        this.state.tweens = this.tweens;

        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
    },

    step: function (time, delta)
    {
        this.tweens.begin(time);

        var list = this.children.list;

        for (var i = 0; i < list.length; i++)
        {
            list[i].preUpdate(time, delta);
        }

        this.tweens.update(time, delta);

        this.cameras.update(time, delta);

        this.state.update.call(this.state, time, delta);
    },

    //  Called just once per frame, regardless of speed

    /*
    begin: function (timestamp, frameDelta)
    {
        var list = this.children.list;

        for (var i = 0; i < list.length; i++)
        {
            list[i].preUpdate(timestamp, frameDelta);
        }
    },

    //  Potentially called multiple times per frame (on super-fast systems)
    update: function (timestep, physicsStep)
    {
        this.cameras.update(timestep);

        this.state.update.call(this.state, timestep, physicsStep);
    },
    */

    //  Called just once per frame
    render: function (interpolation, renderer)
    {
        if (!this.settings.visible)
        {
            return;
        }

        if (this.sortChildrenFlag)
        {
            StableSort.inplace(this.children.list, this.sortZ);

            this.sortChildrenFlag = false;
        }

        this.cameras.render(renderer, this.children, interpolation);
    },

    sortZ: function (childA, childB)
    {
        return childA._z - childB._z;
    }
};

module.exports = Systems;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(40);
var GetBottom = __webpack_require__(18);
var SetCenterX = __webpack_require__(42);
var SetBottom = __webpack_require__(22);

var InBottomCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomCenter;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetBottom = __webpack_require__(18);
var SetLeft = __webpack_require__(23);
var SetBottom = __webpack_require__(22);

var InBottomLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomLeft;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetBottom = __webpack_require__(18);
var SetRight = __webpack_require__(24);
var SetBottom = __webpack_require__(22);

var InBottomRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomRight;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(40);
var GetCenterY = __webpack_require__(41);
var CenterOn = __webpack_require__(228);

var InCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    CenterOn(gameObject, GetCenterX(container) + offsetX, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InCenter;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetCenterY = __webpack_require__(41);
var SetLeft = __webpack_require__(23);
var SetCenterY = __webpack_require__(43);

var InLeftCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InLeftCenter;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetCenterY = __webpack_require__(41);
var SetRight = __webpack_require__(24);
var SetCenterY = __webpack_require__(43);

var InRightCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InRightCenter;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(40);
var GetTop = __webpack_require__(21);
var SetCenterX = __webpack_require__(42);
var SetTop = __webpack_require__(25);

var InTopCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopCenter;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetTop = __webpack_require__(21);
var SetLeft = __webpack_require__(23);
var SetTop = __webpack_require__(25);

var InTopLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopLeft;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetTop = __webpack_require__(21);
var SetRight = __webpack_require__(24);
var SetTop = __webpack_require__(25);

var InTopRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopRight;


/***/ }),
/* 221 */
/***/ (function(module, exports) {

var CONST = {

    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_RIGHT: 12

};

module.exports = CONST;


/***/ }),
/* 222 */
/***/ (function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var Shuffle = __webpack_require__(226);
var GetValue = __webpack_require__(0);

var BuildChunk = function (a, b, qty)
{
    var out = [];

    for (var aIndex = 0; aIndex < a.length; aIndex++)
    {
        for (var bIndex = 0; bIndex < b.length; bIndex++)
        {
            for (var i = 0; i < qty; i++)
            {
                out.push({ a: a[aIndex], b: b[bIndex] });
            }
        }
    }

    return out;
};

//  options = repeat, random, randomB, yoyo, max, qty

//  Range ([a,b,c], [1,2,3]) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2,3], qty = 3) =
//  a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3

//  Range ([a,b,c], [1,2,3], repeat x1) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2], repeat -1 = endless, max = 14) =
//  Maybe if max is set then repeat goes to -1 automatically?
//  a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)

//  Range ([a], [1,2,3,4,5], random = true) =
//  a4, a1, a5, a2, a3

//  Range ([a, b], [1,2,3], random = true) =
//  b3, a2, a1, b1, a3, b2

//  Range ([a, b, c], [1,2,3], randomB = true) =
//  a3, a1, a2, b2, b3, b1, c1, c3, c2

//  Range ([a], [1,2,3,4,5], yoyo = true) =
//  a1, a2, a3, a4, a5, a5, a4, a3, a2, a1

//  Range ([a, b], [1,2,3], yoyo = true) =
//  a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1

var Range = function (a, b, options)
{
    var max = GetValue(options, 'max', 0);
    var qty = GetValue(options, 'qty', 1);
    var random = GetValue(options, 'random', false);
    var randomB = GetValue(options, 'randomB', false);
    var repeat = GetValue(options, 'repeat', 0);
    var yoyo = GetValue(options, 'yoyo', false);

    var out = [];

    if (randomB)
    {
        Shuffle(b);
    }

    //  Endless repeat, so limit by max
    if (repeat === -1)
    {
        if (max === 0)
        {
            repeat = 0;
        }
        else
        {
            //  Work out how many repeats we need
            var total = (a.length * b.length) * qty;

            if (yoyo)
            {
                total *= 2;
            }

            repeat = Math.ceil(max / total);
        }
    }

    for (var i = 0; i <= repeat; i++)
    {
        var chunk = BuildChunk(a, b, qty);

        if (random)
        {
            Shuffle(chunk);
        }

        out = out.concat(chunk);

        if (yoyo)
        {
            chunk.reverse();

            out = out.concat(chunk);
        }
    }

    if (max)
    {
        out.splice(max);
    }

    return out;
};

module.exports = Range;


/***/ }),
/* 224 */
/***/ (function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ }),
/* 225 */
/***/ (function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ }),
/* 226 */
/***/ (function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ }),
/* 227 */
/***/ (function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var SetCenterX = __webpack_require__(42);
var SetCenterY = __webpack_require__(43);

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var CenterOn = function (gameObject, x, y)
{
    SetCenterX(gameObject, x);

    return SetCenterY(gameObject, y);
};

module.exports = CenterOn;


/***/ }),
/* 229 */
/***/ (function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try
    {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))
        {
            return false;
        }
    }
    catch (e)
    {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ }),
/* 230 */
/***/ (function(module, exports) {

/**
* Takes the given string and pads it out, to the length required, using the character
* specified. For example if you need a string to be 6 characters long, you can call:
*
* `pad('bob', 6, '-', 2)`
*
* This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
*
* You can also use it to pad numbers (they are always returned as strings):
* 
* `pad(512, 6, '0', 1)`
*
* Would return: `000512` with the string padded to the left.
*
* If you don't specify a direction it'll pad to both sides:
* 
* `pad('c64', 7, '*')`
*
* Would return: `**c64**`
*
* @method Phaser.Utils.pad
* @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
* @param {integer} [len=0] - The number of characters to be added.
* @param {string} [pad=" "] - The string to pad it out with (defaults to a space).
* @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).
* @return {string} The padded string.
*/
var Pad = function (str, len, pad, dir)
{
    if (len === undefined) { len = 0; }
    if (pad === undefined) { pad = ' '; }
    if (dir === undefined) { dir = 3; }

    str = str.toString();

    var padlen = 0;

    if (len + 1 >= str.length)
    {
        switch (dir)
        {
            case 1:
                str = new Array(len + 1 - str.length).join(pad) + str;
                break;

            case 3:
                var right = Math.ceil((padlen = len - str.length) / 2);
                var left = padlen - right;
                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                break;

            default:
                str = str + new Array(len + 1 - str.length).join(pad);
                break;
        }
    }

    return str;
};

module.exports = Pad;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {


var Config = __webpack_require__(320);
var DebugHeader = __webpack_require__(322);
var Device = __webpack_require__(381);

var AddToDOM = __webpack_require__(109);
var DOMContentLoaded = __webpack_require__(110);
var VisibilityHandler = __webpack_require__(324);
var EventDispatcher = __webpack_require__(15);

var TimeStep = __webpack_require__(323);
var CreateRenderer = __webpack_require__(321);
var GlobalInputManager = __webpack_require__(606);
var GlobalStateManager = __webpack_require__(747);
var AnimationManager = __webpack_require__(301);
var TextureManager = __webpack_require__(759);
var Data = __webpack_require__(104);
var Cache = __webpack_require__(326);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {EventDispatcher} events - Global / Global Game System Events
    */
    this.events = new EventDispatcher();

    /**
    * @property {Phaser.AnimationManager} anims - Reference to the Phaser Animation Manager.
    */
    this.anims = new AnimationManager(this);

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager(this);

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    this.cache = new Cache();

    /**
    * @property {Phaser.Data} registry - Game wide data store.
    */
    this.registry = new Data(this);

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = new GlobalInputManager(this, this.config);

    /**
    * @property {Phaser.GlobalStateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new GlobalStateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    /**
    * @property {Phaser.MainLoop} mainloop - Main Loop handler.
    * @protected
    */
    this.loop = new TimeStep(this, this.config.fps);

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.anims.boot(this.textures);

        this.state.boot();

        this.input.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.loop.start(this.step.bind(this));

        VisibilityHandler(this.events);

        this.events.on('HIDDEN', this.onHidden.bind(this));
        this.events.on('VISIBLE', this.onVisible.bind(this));
        this.events.on('ON_BLUR', this.onBlur.bind(this));
        this.events.on('ON_FOCUS', this.onFocus.bind(this));
    },

    step: function (time, delta)
    {
        var active = this.state.active;
        var renderer = this.renderer;

        //  Global Managers (Time, Input, etc)

        this.input.update(time, delta);

        //  States

        for (var i = 0; i < active.length; i++)
        {
            active[i].state.sys.step(time, delta);
        }

        //  Render

        // var interpolation = this.frameDelta / this.timestep;

        renderer.preRender();

        //  This uses active.length, in case state.update removed the state from the active list
        for (i = 0; i < active.length; i++)
        {
            active[i].state.sys.render(0, renderer);
        }

        renderer.postRender();
    },

    onHidden: function ()
    {
        this.loop.pause();
    },

    onVisible: function ()
    {
        this.loop.resume();
    },

    onBlur: function ()
    {
        this.loop.blur();
    },

    onFocus: function ()
    {
        this.loop.focus();
    }
};

module.exports = Game;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Create

module.exports = {
  
    GenerateTexture: __webpack_require__(105),
    Grid: __webpack_require__(371),
    Palettes: __webpack_require__(376)

};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.DOM

module.exports = {

    AddEventListener: __webpack_require__(382),
    AddToDOM: __webpack_require__(109),
    CanvasInterpolation: __webpack_require__(63),
    CanvasPool: __webpack_require__(9),
    DOMContentLoaded: __webpack_require__(110),
    ParseXML: __webpack_require__(111),
    RemoveEventListener: __webpack_require__(383),
    RemoveFromDOM: __webpack_require__(384),
    RequestAnimationFrame: __webpack_require__(112),
    Smoothing: __webpack_require__(64),
    TouchAction: __webpack_require__(385),
    UserSelect: __webpack_require__(386)

};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

//  Required, but don't need Phaser level exports
//  (maybe these should be Phaser export level?)

__webpack_require__(401);
__webpack_require__(406);
__webpack_require__(420);
__webpack_require__(437);
__webpack_require__(397);
__webpack_require__(393);
__webpack_require__(415);
__webpack_require__(445);
__webpack_require__(423);
__webpack_require__(463);
__webpack_require__(411);
__webpack_require__(432);
__webpack_require__(460);
__webpack_require__(426);
__webpack_require__(430);
__webpack_require__(456);
__webpack_require__(451);

//  Phaser.GameObjects

module.exports = {

    Factory: __webpack_require__(3),

    BitmapText: __webpack_require__(116),
    Blitter: __webpack_require__(117),
    Container: __webpack_require__(118),
    DynamicBitmapText: __webpack_require__(115),
    Graphics: __webpack_require__(119),
    Image: __webpack_require__(67),
    TileSprite: __webpack_require__(122),
    Layer: __webpack_require__(120),
    RenderPass: __webpack_require__(121),
    Sprite: __webpack_require__(51),
    Text: __webpack_require__(69),
    Zone: __webpack_require__(72),
    EffectLayer: __webpack_require__(65),
    Mesh: __webpack_require__(50),
    Quad: __webpack_require__(68),
    StaticTilemap: __webpack_require__(71),
    Tilemap: __webpack_require__(70),
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(475),
    Ellipse: __webpack_require__(485),
    Intersects: __webpack_require__(496),
    Line: __webpack_require__(515),
    Point: __webpack_require__(535),
    Polygon: __webpack_require__(541),
    Rectangle: __webpack_require__(567),
    Triangle: __webpack_require__(581)

};


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics

module.exports = {

    BlendModes: __webpack_require__(596),
    Color: __webpack_require__(605)
  
};


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input

module.exports = {

    Keyboard: __webpack_require__(615),
    Mouse: __webpack_require__(626)

};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics

module.exports = {
    Impact: __webpack_require__(696),
    PolyDecomp: __webpack_require__(207),
    MatterJS: __webpack_require__(703)
};


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(705);
__webpack_require__(706);
__webpack_require__(707);
__webpack_require__(711);
__webpack_require__(708);
__webpack_require__(709);
__webpack_require__(712);
__webpack_require__(713);
__webpack_require__(710);


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(746)

};


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils

module.exports = {

    Align: __webpack_require__(801),
    Array: __webpack_require__(808),
    Bounds: __webpack_require__(811),
    Objects: __webpack_require__(815),
    String: __webpack_require__(818)

};


/***/ }),
/* 242 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 243 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 244 */
/***/ (function(module, exports) {

var Angle = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].angle += value;
    }

    return items;
};

module.exports = Angle;


/***/ }),
/* 245 */
/***/ (function(module, exports) {

var Call = function (items, callback, thisArg)
{
    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        callback.call(thisArg, item);
    }

    return items;
};

module.exports = Call;


/***/ }),
/* 246 */
/***/ (function(module, exports) {

//  compare = Object:
//  {
//      scaleX: 0.5,
//      scaleY: 1
//  }

var GetFirst = function (items, compare, index)
{
    for (var i = index; i < items.length; i++)
    {
        var item = items[i];

        var match = true;

        for (var property in compare)
        {
            if (item[property] !== compare[property])
            {
                match = false;
            }
        }

        if (match)
        {
            return item;
        }
    }

    return null;
};

module.exports = GetFirst;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(221);
var AlignIn = __webpack_require__(788);
var Zone = __webpack_require__(72);
var GetValue = __webpack_require__(0);

var tempZone = new Zone({}, 0, 0, 1, 1);

/**
* This method iterates through all children in the Group (regardless if they are visible or exist)
* and then changes their position so they are arranged in a Grid formation. Children must have
* the `alignTo` method in order to be positioned by this call. All default Phaser Game Objects have
* this.
*
* The grid dimensions are determined by the first four arguments. The `width` and `height` arguments
* relate to the width and height of the grid respectively.
*
* For example if the Group had 100 children in it:
*
* `Group.align(10, 10, 32, 32)`
*
* This will align all of the children into a grid formation of 10x10, using 32 pixels per
* grid cell. If you want a wider grid, you could do:
* 
* `Group.align(25, 4, 32, 32)`
*
* This will align the children into a grid of 25x4, again using 32 pixels per grid cell.
*
* You can choose to set _either_ the `width` or `height` value to -1. Doing so tells the method
* to keep on aligning children until there are no children left. For example if this Group had
* 48 children in it, the following:
*
* `Group.align(-1, 8, 32, 32)`
*
* ... will align the children so that there are 8 children vertically (the second argument), 
* and each row will contain 6 sprites, except the last one, which will contain 5 (totaling 48)
*
* You can also do:
* 
* `Group.align(10, -1, 32, 32)`
*
* In this case it will create a grid 10 wide, and as tall as it needs to be in order to fit
* all of the children in.
*
* The `position` property allows you to control where in each grid cell the child is positioned.
* This is a constant and can be one of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, 
* `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, 
* `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.
*
* The final argument; `offset` lets you start the alignment from a specific child index.
*
* @method Phaser.Group#align
* @param {integer} width - The width of the grid in items (not pixels). Set to -1 for a dynamic width. If -1 then you must set an explicit height value.
* @param {integer} height - The height of the grid in items (not pixels). Set to -1 for a dynamic height. If -1 then you must set an explicit width value.
* @param {integer} cellWidth - The width of each grid cell, in pixels.
* @param {integer} cellHeight - The height of each grid cell, in pixels.
* @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.
* @return {boolean} True if the Group children were aligned, otherwise false.
*/
var GridAlign = function (items, options)
{
    var width = GetValue(options, 'width', -1);
    var height = GetValue(options, 'height', -1);
    var cellWidth = GetValue(options, 'cellWidth', 1);
    var cellHeight = GetValue(options, 'cellHeight', cellWidth);
    var position = GetValue(options, 'position', CONST.TOP_LEFT);
    var x = GetValue(options, 'x', 0);
    var y = GetValue(options, 'y', 0);
    // var centerX = GetValue(options, 'centerX', null);
    // var centerY = GetValue(options, 'centerY', null);

    var cx = 0;
    var cy = 0;
    var w = (width * cellWidth);
    var h = (height * cellHeight);

    //  If the Grid is centered on a position then we need to calculate it now
    // if (centerX !== null && centerY !== null)
    // {
        // 
    // }

    tempZone.setPosition(x, y);
    tempZone.setSize(cellWidth, cellHeight);

    for (var i = 0; i < items.length; i++)
    {
        AlignIn(items[i], tempZone, position);

        if (width === -1)
        {
            //  We keep laying them out horizontally until we've done them all
            cy += cellHeight;
            tempZone.y += cellHeight;

            if (cy === h)
            {
                cy = 0;
                tempZone.x += cellWidth;
                tempZone.y = y;
            }
        }
        else if (height === -1)
        {
            //  We keep laying them out vertically until we've done them all
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                tempZone.x = x;
                tempZone.y += cellHeight;
            }
        }
        else
        {
            //  We keep laying them out until we hit the column limit
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                cy += cellHeight;
                tempZone.x = x;
                tempZone.y += cellHeight;

                if (cy === h)
                {
                    //  We've hit the column limit, so return, even if there are items left
                    break;
                }
            }
        }
    }

    return items;
};

module.exports = GridAlign;


/***/ }),
/* 248 */
/***/ (function(module, exports) {

var IncAlpha = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha += value;
    }

    return items;
};

module.exports = IncAlpha;


/***/ }),
/* 249 */
/***/ (function(module, exports) {

var IncX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += value;
    }

    return items;
};

module.exports = IncX;


/***/ }),
/* 250 */
/***/ (function(module, exports) {

var IncXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += x;
        items[i].y += y;
    }

    return items;
};

module.exports = IncXY;


/***/ }),
/* 251 */
/***/ (function(module, exports) {

var IncY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].y += value;
    }

    return items;
};

module.exports = IncY;


/***/ }),
/* 252 */
/***/ (function(module, exports) {

var PlaceOnCircle = function (items, circle, startAngle, endAngle)
{
    if (startAngle === undefined) { startAngle = 0; }
    if (endAngle === undefined) { endAngle = 6.28; }

    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = circle.x + (circle.radius * Math.cos(angle));
        items[i].y = circle.y + (circle.radius * Math.sin(angle));

        angle += angleStep;
    }

    return items;
};

module.exports = PlaceOnCircle;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(74);

var PlaceOnLine = function (items, line)
{
    var points = GetPointsOnLine(line);
    var step = points.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = points[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnLine;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var MarchingAnts = __webpack_require__(140);
var RotateLeft = __webpack_require__(224);
var RotateRight = __webpack_require__(225);

//  Place the items in the array around the perimeter of the given rectangle.

//  Placement starts from the top-left of the rectangle, and proceeds in a
//  clockwise direction. If the shift parameter is given you can offset where
//  placement begins.

var PlaceOnRectangle = function (items, rect, shift)
{
    if (shift === undefined) { shift = 0; }

    var points = MarchingAnts(rect, false, items.length);

    if (shift > 0)
    {
        RotateLeft(points, shift);
    }
    else if (shift < 0)
    {
        RotateRight(points, Math.abs(shift));
    }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = points[i].x;
        items[i].y = points[i].y;
    }

    return items;
};

module.exports = PlaceOnRectangle;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(74);

var PlaceOnTriangle = function (items, triangle, stepRate)
{
    var p1 = GetPointsOnLine({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
    var p2 = GetPointsOnLine({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
    var p3 = GetPointsOnLine({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);

    //  Remove overlaps
    p1.pop();
    p2.pop();
    p3.pop();

    p1 = p1.concat(p2, p3);

    var step = p1.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = p1[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnTriangle;


/***/ }),
/* 256 */
/***/ (function(module, exports) {

var PlayAnimation = function (items, key, startFrame)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].anims.play(key, startFrame);
    }

    return items;
};

module.exports = PlayAnimation;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(124);

var RandomCircle = function (items, circle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(circle, items[i]);
    }

    return items;
};

module.exports = RandomCircle;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(126);

var RandomEllipse = function (items, ellipse)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(ellipse, items[i]);
    }

    return items;
};

module.exports = RandomEllipse;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(132);

var RandomLine = function (items, line)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(line, items[i]);
    }

    return items;
};

module.exports = RandomLine;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(142);

var RandomRectangle = function (items, rect)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(rect, items[i]);
    }

    return items;
};

module.exports = RandomRectangle;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var Random = __webpack_require__(147);

var RandomTriangle = function (items, triangle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(triangle, items[i]);
    }

    return items;
};

module.exports = RandomTriangle;


/***/ }),
/* 262 */
/***/ (function(module, exports) {

var Rotate = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation += value + (i * step);
    }

    return items;
};

module.exports = Rotate;


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundDistance = __webpack_require__(86);
var DistanceBetween = __webpack_require__(87);

//  point = any object with public x/y properties

var RotateAround = function (items, point, angle)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
    }

    return items;
};

module.exports = RotateAround;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var MathRotateAroundDistance = __webpack_require__(86);

//  point = any object with public x/y properties
//  angle = radians
//  distance = px

var RotateAroundDistance = function (items, point, angle, distance)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        MathRotateAroundDistance(items[i], x, y, angle, distance);
    }

    return items;
};

module.exports = RotateAroundDistance;


/***/ }),
/* 265 */
/***/ (function(module, exports) {

var ScaleX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += value;
    }

    return items;
};

module.exports = ScaleX;


/***/ }),
/* 266 */
/***/ (function(module, exports) {

var ScaleXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += x;
        items[i].scaleY += y;
    }

    return items;
};

module.exports = ScaleXY;


/***/ }),
/* 267 */
/***/ (function(module, exports) {

var ScaleY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY += value;
    }

    return items;
};

module.exports = ScaleY;


/***/ }),
/* 268 */
/***/ (function(module, exports) {

var SetAlpha = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha = value + (i * step);
    }

    return items;
};

module.exports = SetAlpha;


/***/ }),
/* 269 */
/***/ (function(module, exports) {

var SetOrigin = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].setOrigin(x, y);
    }

    return items;
};

module.exports = SetOrigin;


/***/ }),
/* 270 */
/***/ (function(module, exports) {

var SetRotation = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation = value + (i * step);
    }

    return items;
};

module.exports = SetRotation;


/***/ }),
/* 271 */
/***/ (function(module, exports) {

var SetScale = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].setScale(
            x + (i * stepX),
            y + (i * stepY)
        );
    }

    return items;
};

module.exports = SetScale;


/***/ }),
/* 272 */
/***/ (function(module, exports) {

var SetScaleX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX = value + (i * step);
    }

    return items;
};

module.exports = SetScaleX;


/***/ }),
/* 273 */
/***/ (function(module, exports) {

var SetScaleY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY = value + (i * step);
    }

    return items;
};

module.exports = SetScaleY;


/***/ }),
/* 274 */
/***/ (function(module, exports) {

var SetVisible = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = value;
    }

    return items;
};

module.exports = SetVisible;


/***/ }),
/* 275 */
/***/ (function(module, exports) {

var SetX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = value + (i * step);
    }

    return items;
};

module.exports = SetX;


/***/ }),
/* 276 */
/***/ (function(module, exports) {

var SetXY = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = x + (i * stepX);
        items[i].y = y + (i * stepY);
    }

    return items;
};

module.exports = SetXY;


/***/ }),
/* 277 */
/***/ (function(module, exports) {

var SetY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].y = value + (i * step);
    }

    return items;
};

module.exports = SetY;


/***/ }),
/* 278 */
/***/ (function(module, exports) {

//  Iterate through items changing the position of each element to
//  be that of the element that came before it in the array (or after it if direction = 1)
//  The first items position is set to x/y.
//  The final x/y coords are returned

var ShiftPosition = function (items, x, y, direction, output)
{
    if (direction === undefined) { direction = 0; }
    if (output === undefined) { output = { x: 0, y: 0 }; }

    var px;
    var py;

    if (items.length > 1)
    {
        var i;
        var cx;
        var cy;
        var cur;

        if (direction === 0)
        {
            //  Bottom to Top

            var len = items.length - 1;

            px = items[len].x;
            py = items[len].y;

            for (i = len - 1; i >= 0; i--)
            {
                //  Current item
                cur = items[i];

                //  Get current item x/y, to be passed to the next item in the list
                cx = cur.x;
                cy = cur.y;

                //  Set current item to the previous items x/y
                cur.x = px;
                cur.y = py;

                //  Set current as previous
                px = cx;
                py = cy;
            }

            //  Update the head item to the new x/y coordinates
            items[len].x = x;
            items[len].y = y;
        }
        else
        {
            //  Top to Bottom

            px = items[0].x;
            py = items[0].y;

            for (i = 1; i < items.length; i++)
            {
                //  Current item
                cur = items[i];

                //  Get current item x/y, to be passed to the next item in the list
                cx = cur.x;
                cy = cur.y;

                //  Set current item to the previous items x/y
                cur.x = px;
                cur.y = py;

                //  Set current as previous
                px = cx;
                py = cy;
            }

            //  Update the head item to the new x/y coordinates
            items[0].x = x;
            items[0].y = y;
        }
    }
    else
    {
        px = items[0].x;
        py = items[0].y;

        items[0].x = x;
        items[0].y = y;
    }

    //  Return the final set of coordinates as they're effectively lost from the shift and may be needed

    output.x = px;
    output.y = py;

    return output;
};

module.exports = ShiftPosition;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var MathSmoothStep = __webpack_require__(180);

var SmoothStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmoothStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmoothStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmoothStep;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var MathSmootherStep = __webpack_require__(181);

var SmootherStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmootherStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmootherStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmootherStep;


/***/ }),
/* 281 */
/***/ (function(module, exports) {

var Spread = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += i * step;
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = i * step;
        }
    }

    return items;
};

module.exports = Spread;


/***/ }),
/* 282 */
/***/ (function(module, exports) {

var ToggleVisible = function (items)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = !items[i].visible;
    }

    return items;
};

module.exports = ToggleVisible;


/***/ }),
/* 283 */
/***/ (function(module, exports) {

//  config = Array of Animation config objects, like:
//  [
//      { key: 'gems', frame: 'diamond0001', [duration], [visible], [onUpdate] }
//  ]

//  Add frames to the end of the animation
var AddFrame = function (config)
{
    return this.addFrameAt(this.frames.length, config);
};

module.exports = AddFrame;


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var GetFrames = __webpack_require__(101);

//  config = Array of Animation config objects, like:
//  [
//      { key: 'gems', frame: 'diamond0001', [duration], [visible], [onUpdate] }
//  ]

//  Add frame/s into the animation
var AddFrameAt = function (index, config)
{
    if (index === undefined) { index = 0; }

    var newFrames = GetFrames(this.manager.textureManager, config);

    if (newFrames.length > 0)
    {
        if (index === 0)
        {
            this.frames = newFrames.concat(this.frames);
        }
        else if (index === this.frames.length)
        {
            this.frames = this.frames.concat(newFrames);
        }
        else
        {
            var pre = this.frames.slice(0, index);
            var post = this.frames.slice(index);

            this.frames = pre.concat(newFrames, post);
        }

        this.updateFrameSequence();
    }

    return this;
};

module.exports = AddFrameAt;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var GetFrames = __webpack_require__(101);

//  A Frame based Animation
//  This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.
//  The Animation Manager creates these
//  Game Objects don't own an instance of these directly
//  Game Objects have the Animation Component, which are like playheads to global Animations (these objects)
//  So multiple Game Objects can have playheads all pointing to this one Animation instance

var Animation = function (manager, key, config)
{
    this.manager = manager;

    this.key = key;

    //  A frame based animation (as opposed to a bone based animation)
    this.type = 'frame';

    //  Extract all the frame data into the frames array
    this.frames = GetFrames(manager.textureManager, GetValue(config, 'frames', []));

    //  The frame rate of playback in frames per second (default 24 if duration is null)
    this.frameRate = GetValue(config, 'framerate', null);

    //  How long the animation should play for. If frameRate is set it overrides this value
    //  otherwise frameRate is derived from duration
    this.duration = GetValue(config, 'duration', null);

    if (this.duration === null && this.frameRate === null)
    {
        //  No duration or frameRate given, use default frameRate of 24fps
        this.frameRate = 24;
        this.duration = this.frameRate / this.frames.length;
    }
    else if (this.duration && this.frameRate === null)
    {
        //  Duration given but no frameRate, so set the frameRate based on duration
        //  I.e. 12 frames in the animation, duration = 4 (4000 ms)
        //  So frameRate is 12 / 4 = 3 fps
        this.frameRate = this.frames.length / this.duration;
    }
    else
    {
        //  frameRate given, derive duration from it (even if duration also specified)
        //  I.e. 15 frames in the animation, frameRate = 30 fps
        //  So duration is 15 / 30 = 0.5 (half a second)
        this.duration = this.frames.length / this.frameRate;
    }

    //  ms per frame (without including frame specific modifiers)
    this.msPerFrame = 1000 / this.frameRate;

    //  Skip frames if the time lags, or always advanced anyway?
    this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);

    //  Delay before starting playback (in seconds)
    this.delay = GetValue(config, 'delay', 0);

    //  Number of times to repeat the animation (-1 for infinity)
    this.repeat = GetValue(config, 'repeat', 0);

    //  Delay before the repeat starts (in seconds)
    this.repeatDelay = GetValue(config, 'repeatDelay', 0);

    //  Should the animation yoyo? (reverse back down to the start) before repeating?
    this.yoyo = GetValue(config, 'yoyo', false);

    //  Should sprite.visible = true when the animation starts to play?
    this.showOnStart = GetValue(config, 'showOnStart', false);

    //  Should sprite.visible = false when the animation finishes?
    this.hideOnComplete = GetValue(config, 'hideOnComplete', false);

    //  Callbacks
    this.callbackScope = GetValue(config, 'callbackScope', this);

    this.onStart = GetValue(config, 'onStart', false);
    this.onStartParams = GetValue(config, 'onStartParams', []);

    this.onRepeat = GetValue(config, 'onRepeat', false);
    this.onRepeatParams = GetValue(config, 'onRepeatParams', []);

    //  Called for EVERY frame of the animation.
    //  See AnimationFrame.onUpdate for a frame specific callback.
    this.onUpdate = GetValue(config, 'onUpdate', false);
    this.onUpdateParams = GetValue(config, 'onUpdateParams', []);

    this.onComplete = GetValue(config, 'onComplete', false);
    this.onCompleteParams = GetValue(config, 'onCompleteParams', []);

    //  Global pause, effects all Game Objects using this Animation instance
    this.paused = false;

    this.manager.events.on('PAUSE_ALL_ANIMATION_EVENT', this.pause.bind(this));
    this.manager.events.on('RESUME_ALL_ANIMATION_EVENT', this.resume.bind(this));
};

Animation.prototype.constructor = Animation;

Animation.prototype = {

    addFrame: __webpack_require__(283),
    addFrameAt: __webpack_require__(284),
    checkFrame: __webpack_require__(286),
    completeAnimation: __webpack_require__(287),
    getFirstTick: __webpack_require__(289),
    getFrameAt: __webpack_require__(290),
    getNextTick: __webpack_require__(291),
    load: __webpack_require__(292),
    nextFrame: __webpack_require__(293),
    previousFrame: __webpack_require__(294),
    removeFrame: __webpack_require__(295),
    removeFrameAt: __webpack_require__(296),
    repeatAnimation: __webpack_require__(297),
    setFrame: __webpack_require__(298),
    toJSON: __webpack_require__(299),
    updateFrameSequence: __webpack_require__(300),

    pause: function ()
    {
        this.paused = true;
    },

    resume: function ()
    {
        this.paused = false;
    },

    destroy: function ()
    {

    }
};

module.exports = Animation;


/***/ }),
/* 286 */
/***/ (function(module, exports) {

var CheckFrame = function (index)
{
    return (index < this.frames.length);
};

module.exports = CheckFrame;


/***/ }),
/* 287 */
/***/ (function(module, exports) {

var CompleteAnimation = function (component)
{
    if (this.hideOnComplete)
    {
        component.parent.visible = false;
    }

    component.stop(true);
};

module.exports = CompleteAnimation;


/***/ }),
/* 288 */
/***/ (function(module, exports) {

var Frame = function (textureKey, textureFrame, index, frame)
{
    //  The keys into the Texture Manager of the texture + frame this uses
    this.textureKey = textureKey;
    this.textureFrame = textureFrame;

    //  The index of this frame within the Animation.frames array
    this.index = index;

    //  Texture Frame
    this.frame = frame;

    //  Read-only
    this.isFirst = false;

    //  Read-only
    this.isLast = false;

    //  The frame that comes before this one in the animation (if any)
    //  Read-only
    this.prevFrame = null;

    //  The frame that comes after this one in the animation (if any)
    //  Read-only
    this.nextFrame = null;

    //   Additional time (in ms) this frame should appear for - added onto the msPerFrame
    this.duration = 0;

    //   What % through the animation progress is this frame?
    //  Read-only
    this.progress = 0;

    //  Callback if this frame gets displayed
    this.onUpdate = null;

    //  When this frame hits, set sprite.visible to this
    this.setVisible = false;

    this.visible = false;
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    toJSON: function ()
    {
        return {
            key: this.textureKey,
            frame: this.textureFrame,
            duration: this.duration,
            visible: this.visible
        };
    },

    destroy: function ()
    {
        this.frame = undefined;
        this.onUpdate = undefined;
    }

};

module.exports = Frame;


/***/ }),
/* 289 */
/***/ (function(module, exports) {

var GetFirstTick = function (component, includeDelay)
{
    if (includeDelay === undefined) { includeDelay = true; }

    //  When is the first update due?
    component.accumulator = 0;
    component.nextTick = component.msPerFrame + component.currentFrame.duration;

    if (includeDelay)
    {
        component.nextTick += (component._delay * 1000);
    }
};

module.exports = GetFirstTick;


/***/ }),
/* 290 */
/***/ (function(module, exports) {

var GetFrameAt = function (index)
{
    return this.frames[index];
};

module.exports = GetFrameAt;


/***/ }),
/* 291 */
/***/ (function(module, exports) {

var GetNextTick = function (component)
{
    // accumulator += delta * _timeScale
    // after a large delta surge (perf issue for example) we need to adjust for it here

    //  When is the next update due?
    component.accumulator -= component.nextTick;

    component.nextTick = component.msPerFrame + component.currentFrame.duration;
};

module.exports = GetNextTick;


/***/ }),
/* 292 */
/***/ (function(module, exports) {

var Load = function (component, startFrame)
{
    if (startFrame >= this.frames.length)
    {
        startFrame = 0;
    }

    if (component.currentAnim !== this)
    {
        component.currentAnim = this;

        component._timeScale = 1;
        component.frameRate = this.frameRate;
        component.duration = this.duration;
        component.msPerFrame = this.msPerFrame;
        component.skipMissedFrames = this.skipMissedFrames;
        component._delay = this.delay;
        component._repeat = this.repeat;
        component._repeatDelay = this.repeatDelay;
        component._yoyo = this.yoyo;
        component._callbackArgs[1] = this;
        component._updateParams = component._callbackArgs.concat(this.onUpdateParams);
    }

    component.updateFrame(this.frames[startFrame]);
};

module.exports = Load;


/***/ }),
/* 293 */
/***/ (function(module, exports) {

var NextFrame = function (component)
{
    var frame = component.currentFrame;

    //  TODO: Add frame skip support

    if (frame.isLast)
    {
        //  We're at the end of the animation

        //  Yoyo? (happens before repeat)
        if (this.yoyo)
        {
            component.forward = false;

            component.updateFrame(frame.prevFrame);

            //  Delay for the current frame
            this.getNextTick(component);
        }
        else if (component.repeatCounter > 0)
        {
            //  Repeat (happens before complete)
            this.repeatAnimation(component);
        }
        else
        {
            this.completeAnimation(component);
        }
    }
    else
    {
        component.updateFrame(frame.nextFrame);

        this.getNextTick(component);
    }
};

module.exports = NextFrame;


/***/ }),
/* 294 */
/***/ (function(module, exports) {

var PreviousFrame = function (component)
{
    var frame = component.currentFrame;

    //  TODO: Add frame skip support

    if (frame.isFirst)
    {
        //  We're at the start of the animation

        if (component.repeatCounter > 0)
        {
            //  Repeat (happens before complete)
            this.repeatAnimation(component);
        }
        else
        {
            this.completeAnimation(component);
        }
    }
    else
    {
        component.updateFrame(frame.prevFrame);

        this.getNextTick(component);
    }
};

module.exports = PreviousFrame;


/***/ }),
/* 295 */
/***/ (function(module, exports) {

//  Remove frame if it matches the given frame
var RemoveFrame = function (frame)
{
    var index = this.frames.indexOf(frame);

    if (index !== -1)
    {
        this.removeFrameAt(index);
    }

    return this;
};

module.exports = RemoveFrame;


/***/ }),
/* 296 */
/***/ (function(module, exports) {

var RemoveFrameAt = function (index)
{
    this.frames.splice(index, 1);

    this.updateFrameSequence();

    return this;
};

module.exports = RemoveFrameAt;


/***/ }),
/* 297 */
/***/ (function(module, exports) {

var RepeatAnimation = function (component)
{
    if (component._repeatDelay > 0 && component.pendingRepeat === false)
    {
        component.pendingRepeat = true;
        component.accumulator -= component.nextTick;
        component.nextTick += (component._repeatDelay * 1000);
    }
    else
    {
        component.repeatCounter--;

        component.forward = true;

        component.updateFrame(component.currentFrame.nextFrame);

        this.getNextTick(component);

        component.pendingRepeat = false;

        if (this.onRepeat)
        {
            this.onRepeat.apply(this.callbackScope, component._callbackArgs.concat(this.onRepeatParams));
        }
    }
};

module.exports = RepeatAnimation;


/***/ }),
/* 298 */
/***/ (function(module, exports) {

var SetFrame = function (component)
{
    //  Work out which frame should be set next on the child, and set it
    if (component.forward)
    {
        this.nextFrame(component);
    }
    else
    {
        this.previousFrame(component);
    }
};

module.exports = SetFrame;


/***/ }),
/* 299 */
/***/ (function(module, exports) {

var ToJSON = function ()
{
    var output = {
        key: this.key,
        type: this.type,
        frames: [],
        framerate: this.frameRate,
        duration: this.duration,
        skipMissedFrames: this.skipMissedFrames,
        delay: this.delay,
        repeat: this.repeat,
        repeatDelay: this.repeatDelay,
        yoyo: this.yoyo,
        showOnStart: this.showOnStart,
        hideOnComplete: this.hideOnComplete
    };

    this.frames.forEach(function (frame)
    {
        output.frames.push(frame.toJSON());
    });

    return output;
};

module.exports = ToJSON;


/***/ }),
/* 300 */
/***/ (function(module, exports) {

var UpdateFrameSequence = function ()
{
    var len = this.frames.length;
    var slice = 1 / (len - 1);

    for (var i = 0; i < len; i++)
    {
        var frame = this.frames[i];

        frame.index = i + 1;
        frame.isFirst = false;
        frame.isLast = false;
        frame.progress = i * slice;

        if (i === 0)
        {
            frame.isFirst = true;
            frame.isLast = (len === 1);
            frame.prevFrame = this.frames[len - 1];
            frame.nextFrame = this.frames[i + 1];
        }
        else if (i === len - 1)
        {
            frame.isLast = true;
            frame.prevFrame = this.frames[len - 2];
            frame.nextFrame = this.frames[0];
        }
        else if (len > 1)
        {
            frame.prevFrame = this.frames[i - 1];
            frame.nextFrame = this.frames[i + 1];
        }
    }

    return this;
};

module.exports = UpdateFrameSequence;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Map = __webpack_require__(756);
var Components = __webpack_require__(315);
var EventDispatcher = __webpack_require__(15);
var Event = __webpack_require__(34);

/**
* Animations are managed by the global AnimationManager. This is a singleton class that is
* responsible for creating and delivering animations and their corresponding data to Game Objects.
*
* Sprites and other Game Objects get the data they need from the AnimationManager.
*
* Access it via `state.anims`.
*
* @class Phaser.AnimationManager
* @constructor
*/
var AnimationManager = function (game)
{
    this.game = game;

    this.textureManager = null;

    this.events = new EventDispatcher();

    this.globalTimeScale = 1;

    this.anims = new Map();

    this.paused = false;
};

AnimationManager.prototype.constructor = AnimationManager;

AnimationManager.prototype = {

    boot: function (textureManager)
    {
        this.textureManager = textureManager;
    },

    add: Components.AddAnimation,
    create: Components.CreateFrameAnimation,
    fromJSON: Components.FromJSON,
    generateFrameNames: Components.GenerateFrameNames,
    generateFrameNumbers: Components.GenerateFrameNumbers,
    get: Components.GetAnimation,
    load: Components.LoadAnimationToGameObject,
    play: Components.PlayAnimation,
    pauseAll: Components.PauseAll,
    remove: Components.RemoveAnimation,
    resumeAll: Components.ResumeAll,
    staggerPlay: Components.StaggerPlayAnimation,
    toJSON: Components.ToJSON,

    destroy: function ()
    {
        //  TODO
    }
};

module.exports = AnimationManager;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(34);

var AddAnimation = function (key, animation)
{
    if (this.anims.has(key))
    {
        console.error('Animation with key', key, 'already exists');
        return;
    }

    animation.key = key;

    this.anims.set(key, animation);

    this.events.dispatch(new Event.ADD_ANIMATION_EVENT(key, animation));

    return this;
};

module.exports = AddAnimation;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(34);
var Animation = __webpack_require__(285);

var CreateFrameAnimation = function (config)
{
    var key = config.key;

    if (!key || this.anims.has(key))
    {
        console.warn('Invalid Animation Key, or Key already in use: ' + key);
        return;
    }

    var anim = new Animation(this, key, config);

    this.anims.set(key, anim);

    this.events.dispatch(new Event.ADD_ANIMATION_EVENT(key, anim));

    return anim;
};

module.exports = CreateFrameAnimation;


/***/ }),
/* 304 */
/***/ (function(module, exports) {

var FromJSON = function (data, clearCurrentAnimations)
{
    if (clearCurrentAnimations === undefined) { clearCurrentAnimations = false; }

    if (clearCurrentAnimations)
    {
        this.anims.clear();
    }

    //  Do we have a String (i.e. from JSON, or an Object?)
    if (typeof data === 'string')
    {
        data = JSON.parse(data);
    }

    var output = [];

    //  Array of animations, or a single animation?
    if (data.hasOwnProperty('anims') && Array.isArray(data.anims))
    {
        for (var i = 0; i < data.anims.length; i++)
        {
            output.push(this.create(data.anims[i]));
        }

        if (data.hasOwnProperty('globalTimeScale'))
        {
            this.globalTimeScale = data.globalTimeScale;
        }
    }
    else if (data.hasOwnProperty('key') && data.type === 'frame')
    {
        output.push(this.create(data));
    }

    return output;
};

module.exports = FromJSON;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var Pad = __webpack_require__(230);

var GenerateFrameNames = function (key, config)
{
    var prefix = GetValue(config, 'prefix', '');
    var start = GetValue(config, 'start', 0);
    var end = GetValue(config, 'end', 0);
    var suffix = GetValue(config, 'suffix', '');
    var zeroPad = GetValue(config, 'zeroPad', 0);
    var out = GetValue(config, 'framesArray', []);

    var diff = (start < end) ? 1 : -1;

    //  Adjust because we use i !== end in the for loop
    end += diff;

    var texture = this.textureManager.get(key);

    if (!texture)
    {
        return out;
    }

    for (var i = start; i !== end; i += diff)
    {
        var frame = prefix + Pad(i, zeroPad, '0', 1) + suffix;

        if (texture.has(frame))
        {
            out.push({ key: key, frame: frame });
        }
    }

    return out;
};

module.exports = GenerateFrameNames;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);

var GenerateFrameNumbers = function (key, config)
{
    var startFrame = GetValue(config, 'start', 0);
    var endFrame = GetValue(config, 'end', -1);
    var firstFrame = GetValue(config, 'first', false);
    var out = GetValue(config, 'framesArray', []);

    var texture = this.textureManager.get(key);

    if (!texture)
    {
        return out;
    }

    //  No endFrame then see if we can get it

    if (endFrame === -1)
    {
        endFrame = texture.frameTotal;
    }

    if (firstFrame && texture.has(firstFrame))
    {
        out.push({ key: key, frame: firstFrame });
    }

    for (var i = startFrame; i <= endFrame; i++)
    {
        if (texture.has(i))
        {
            out.push({ key: key, frame: i });
        }
    }

    return out;
};

module.exports = GenerateFrameNumbers;


/***/ }),
/* 307 */
/***/ (function(module, exports) {

var GetAnimation = function (key)
{
    return this.anims.get(key);
};

module.exports = GetAnimation;


/***/ }),
/* 308 */
/***/ (function(module, exports) {

//  Load an Animation into a Game Objects Animation Component
var LoadAnimationToGameObject = function (child, key, startFrame)
{
    var anim = this.get(key);

    if (anim)
    {
        anim.load(child, startFrame);
    }

    return child;
};

module.exports = LoadAnimationToGameObject;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(34);

var PauseAll = function ()
{
    if (!this.paused)
    {
        this.paused = true;

        this.events.dispatch(new Event.PAUSE_ALL_ANIMATION_EVENT());
    }

    return this;
};

module.exports = PauseAll;


/***/ }),
/* 310 */
/***/ (function(module, exports) {

var PlayAnimation = function (key, child)
{
    if (!Array.isArray(child))
    {
        child = [ child ];
    }

    var anim = this.get(key);

    if (!anim)
    {
        return;
    }

    for (var i = 0; i < child.length; i++)
    {
        child[i].anims.play(key);
    }

    return this;
};

module.exports = PlayAnimation;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(34);

var RemoveAnimation = function (key)
{
    var anim = this.get(key);

    if (anim)
    {
        this.events.dispatch(new Event.REMOVE_ANIMATION_EVENT(key, anim));

        this.anims.delete(key);
    }

    return anim;
};

module.exports = RemoveAnimation;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(34);

var ResumeAll = function ()
{
    if (this.paused)
    {
        this.paused = false;

        this.events.dispatch(new Event.RESUME_ALL_ANIMATION_EVENT());
    }

    return this;
};

module.exports = ResumeAll;


/***/ }),
/* 313 */
/***/ (function(module, exports) {

var StaggerPlayAnimation = function (key, child, stagger)
{
    if (stagger === undefined) { stagger = 0; }

    if (!Array.isArray(child))
    {
        child = [ child ];
    }

    var anim = this.get(key);

    if (!anim)
    {
        return;
    }

    for (var i = 0; i < child.length; i++)
    {
        child[i].anims.delayedPlay(stagger * i, key);
    }

    return this;
};

module.exports = StaggerPlayAnimation;


/***/ }),
/* 314 */
/***/ (function(module, exports) {

var ToJSON = function (key)
{
    if (key !== undefined && key !== '')
    {
        return this.anims.get(key).toJSON();
    }
    else
    {
        var output = {
            anims: [],
            globalTimeScale: this.globalTimeScale
        };

        this.anims.each(function (animationKey, animation)
        {
            output.anims.push(animation.toJSON());
        });

        return output;
    }
};

module.exports = ToJSON;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  
    AddAnimation: __webpack_require__(302),
    CreateFrameAnimation: __webpack_require__(303),
    FromJSON: __webpack_require__(304),
    GenerateFrameNames: __webpack_require__(305),
    GenerateFrameNumbers: __webpack_require__(306),
    GetAnimation: __webpack_require__(307),
    LoadAnimationToGameObject: __webpack_require__(308),
    PlayAnimation: __webpack_require__(310),
    PauseAll: __webpack_require__(309),
    ResumeAll: __webpack_require__(312),
    RemoveAnimation: __webpack_require__(311),
    StaggerPlayAnimation: __webpack_require__(313),
    ToJSON: __webpack_require__(314)

};


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var AddAnimationEvent = function (key, animation)
{
    Event.call(this, 'ADD_ANIMATION_EVENT');

    this.key = key;
    this.animation = animation;
};

AddAnimationEvent.prototype = Object.create(Event.prototype);
AddAnimationEvent.prototype.constructor = AddAnimationEvent;

module.exports = AddAnimationEvent;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var PauseAllAnimationEvent = function ()
{
    Event.call(this, 'PAUSE_ALL_ANIMATION_EVENT');
};

PauseAllAnimationEvent.prototype = Object.create(Event.prototype);
PauseAllAnimationEvent.prototype.constructor = PauseAllAnimationEvent;

module.exports = PauseAllAnimationEvent;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var RemoveAnimationEvent = function (key, animation)
{
    Event.call(this, 'REMOVE_ANIMATION_EVENT');

    this.key = key;
    this.animation = animation;
};

RemoveAnimationEvent.prototype = Object.create(Event.prototype);
RemoveAnimationEvent.prototype.constructor = RemoveAnimationEvent;

module.exports = RemoveAnimationEvent;


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var ResumeAllAnimationEvent = function ()
{
    Event.call(this, 'RESUME_ALL_ANIMATION_EVENT');
};

ResumeAllAnimationEvent.prototype = Object.create(Event.prototype);
ResumeAllAnimationEvent.prototype.constructor = ResumeAllAnimationEvent;

module.exports = ResumeAllAnimationEvent;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH = __webpack_require__(61);
var CONST = __webpack_require__(6);
var NOOP = __webpack_require__(60);
var GetValue = __webpack_require__(0);
var ValueToColor = __webpack_require__(167);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetValue(config, 'width', 1024);
    this.height = GetValue(config, 'height', 768);
    this.zoom = GetValue(config, 'zoom', 1);

    this.resolution = GetValue(config, 'resolution', 1);

    this.renderType = GetValue(config, 'type', CONST.AUTO);

    this.parent = GetValue(config, 'parent', null);
    this.canvas = GetValue(config, 'canvas', null);
    this.canvasStyle = GetValue(config, 'canvasStyle', null);

    this.stateConfig = GetValue(config, 'state', null);

    this.seed = GetValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    MATH.RND.init(this.seed);

    this.gameTitle = GetValue(config, 'title', '');
    this.gameURL = GetValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetValue(config, 'version', '');

    //  Input
    this.inputKeyboard = GetValue(config, 'input.keyboard', true);
    this.inputKeyboardEventTarget = GetValue(config, 'input.keyboard.target', window);

    this.inputMouse = GetValue(config, 'input.mouse', true);
    this.inputMouseEventTarget = GetValue(config, 'input.mouse.target', null);

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetValue(config, 'banner', null) === false);

    this.hidePhaser = GetValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetValue(config, 'banner.background', defaultBannerColor);
   
    //  Frame Rate config
    //      fps: {
    //          min: 10,
    //          target: 60,
    //          max: 120
    //          forceSetTimeOut: false,
    //          deltaHistory: 10
    //     }

    this.fps = GetValue(config, 'fps', null);

    this.pixelArt = GetValue(config, 'pixelArt', false);
    this.transparent = GetValue(config, 'transparent', false);
    this.clearBeforeRender = GetValue(config, 'clearBeforeRender', true);
    this.backgroundColor = ValueToColor(GetValue(config, 'backgroundColor', 0));
    this.preserveDrawingBuffer = ValueToColor(GetValue(config, 'preserveDrawingBuffer', false));

    //  Callbacks
    this.preBoot = GetValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetValue(config, 'callbacks.postBoot', NOOP);

    this.useTicker = GetValue(config, 'useTicker', false);

    //  Default / Missing Images
    var pngPrefix = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg';

    this.defaultImage = GetValue(config, 'images.default', pngPrefix + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');
    this.missingImage = GetValue(config, 'images.missing', pngPrefix + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var CanvasPool = __webpack_require__(9);
var Features = __webpack_require__(108);
var CanvasRenderer = __webpack_require__(714);
var WebGLRenderer = __webpack_require__(719);
var CanvasInterpolation = __webpack_require__(63);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasPool.disableSmoothing();
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasInterpolation.setCrisp(game.canvas);
    }

    //  Zoomed?
    if (config.zoom !== 1)
    {
        game.canvas.style.width = (config.width * config.zoom).toString() + 'px';
        game.canvas.style.height = (config.height * config.zoom).toString() + 'px';
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.gameContext;

        //  debug
        game.canvas.id = 'game';
    }
};

module.exports = CreateRenderer;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var CHECKSUM = __webpack_require__(333);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var NOOP = __webpack_require__(60);
var GetValue = __webpack_require__(0);
var RequestAnimationFrame = __webpack_require__(112);

//  Frame Rate config
//      fps: {
//          min: 10,
//          target: 60,
//          max: 120
//          forceSetTimeOut: false,
//          deltaHistory: 10,
//          panicMax: 120
//     }

// http://www.testufo.com/#test=animation-time-graph
// 

var TimeStep = function (game, config)
{
    this.game = game;

    this.raf = new RequestAnimationFrame();

    this.started = false;
    this.running = false;
    
    this.minFps = GetValue(config, 'min', 5);
    this.maxFps = GetValue(config, 'max', 120);
    this.targetFps = GetValue(config, 'target', 60);

    this._min = 1000 / this.minFps;         //  200ms between frames (i.e. super slow!)
    this._max = 1000 / this.maxFps;         //  8.333ms between frames (i.e. super fast, 120Hz displays)
    this._target = 1000 / this.targetFps;   //  16.666ms between frames (i.e. normal)

    //  200 / 1000 = 0.2 (5fps)
    //  8.333 / 1000 = 0.008333 (120fps)
    //  16.666 / 1000 = 0.01666 (60fps)

    /**
    * @property {number} fps - An exponential moving average of the frames per second.
    * @readOnly
    */
    this.actualFps = this.targetFps;

    this.nextFpsUpdate = 0;
    this.framesThisSecond = 0;

    this.callback = NOOP;

    this.forceSetTimeOut = GetValue(config, 'forceSetTimeOut', false);

    this.time = 0;
    this.startTime = 0;
    this.lastTime = 0;
    this.frame = 0;

    this.inFocus = true;

    this._pauseTime = 0;
    this._coolDown = 0;

    this.delta = 0;
    this.deltaIndex = 0;
    this.deltaHistory = [];
    this.deltaSmoothingMax = GetValue(config, 'deltaHistory', 10);
    this.panicMax = GetValue(config, 'panicMax', 120);

    //  The actual elapsed time in ms between one update and the next.
    //  No smoothing, no capping, no averaging. So please be aware of this when using the contents of this property.
    this.rawDelta = 0;
};

TimeStep.prototype.constructor = TimeStep;

TimeStep.prototype = {

    //  Called when the DOM window.onBlur event triggers
    blur: function ()
    {
        this.inFocus = false;

        // console.log('TimeStep.blur');
    },

    //  Called when the DOM window.onFocus event triggers
    focus: function ()
    {
        this.inFocus = true;

        // console.log('TimeStep.focus');

        this.resetDelta();
    },

    //  Called when the visibility API says the game is 'hidden' (tab switch, etc)
    pause: function ()
    {
        // console.log('TimeStep.pause');

        this._pauseTime = window.performance.now();
    },

    //  Called when the visibility API says the game is 'visible' again (tab switch, etc)
    resume: function ()
    {
        this.resetDelta();

        this.startTime += this.time - this._pauseTime;

        // console.log('TimeStep.resume - paused for', (this.time - this._pauseTime));
    },

    resetDelta: function ()
    {
        var now = window.performance.now();

        this.time = now;
        this.lastTime = now;
        this.nextFpsUpdate = now + 1000;
        this.framesThisSecond = 0;
        this.frame = 0;

        //  Pre-populate smoothing array

        for (var i = 0; i < this.deltaSmoothingMax; i++)
        {
            this.deltaHistory[i] = this._target;
        }

        this.delta = 0;
        this.deltaIndex = 0;

        this._coolDown = this.panicMax;
    },

    start: function (callback)
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.deltaHistory = [];

        this.resetDelta();

        this.startTime = window.performance.now();

        this.callback = callback;

        this.raf.start(this.step.bind(this), this.forceSetTimeOut);
    },

    //  time comes from requestAnimationFrame and is either a high res time value,
    //  or Date.now if using setTimeout
    step: function (time)
    {
        //  Debug only
        // var debug = 0;
        // var dump = [];

        this.frame++;

        this.rawDelta = time - this.lastTime;

        var idx = this.deltaIndex;
        var history = this.deltaHistory;
        var max = this.deltaSmoothingMax;

        //  delta time (time is in ms)
        var dt = (time - this.lastTime);

        //  When a browser switches tab, then comes back again, it takes around 10 frames before
        //  the delta time settles down so we employ a 'cooling down' period before we start
        //  trusting the delta values again, to avoid spikes flooding through our delta average

        if (this._coolDown > 0 || !this.inFocus)
        {
            this._coolDown--;

            dt = this._target;
            // debug = (time - this.lastTime);
        }

        //  min / max range (yes, the < and > should be this way around)
        if (dt > this._min || dt < this._max)
        {
            //  Probably super bad start time or browser tab context loss,
            //  so use the last 'sane' dt value

            // debug = dt;

            dt = history[idx];

            //  Clamp delta to min max range (in case history has become corrupted somehow)
            dt = Math.max(Math.min(dt, this._max), this._min);
        }

        //  Smooth out the delta over the previous X frames

        //  add the delta to the smoothing array
        history[idx] = dt;

        //  adjusts the delta history array index based on the smoothing count
        //  this stops the array growing beyond the size of deltaSmoothingMax
        this.deltaIndex++;

        if (this.deltaIndex > max)
        {
            this.deltaIndex = 0;
        }

        //  Delta Average
        var avg = 0;

        //  Loop the history array, adding the delta values together

        for (var i = 0; i < max; i++)
        {
            //   Debug
            // if (history[i] < 16 || history[i] > 17)
            // {
            //     dump.push({ i: i, dt: history[i] });
            // }

            avg += history[i];
        }

        //  Then divide by the array length to get the average delta
        avg /= max;

        //  Set as the world delta value
        this.delta = avg;

        //  Real-world timer advance
        // this.time += avg;
        this.time += this.rawDelta;

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        //
        // When a browser window is NOT minimized, but is covered up (i.e. you're using
        // another app which has spawned a window over the top of the browser), then it
        // will start to throttle the raf callback time. It waits for a while, and then
        // starts to drop the frame rate at 1 frame per second until it's down to just over 1fps.
        // So if the game was running at 60fps, and the player opens a new window, then
        // after 60 seconds (+ the 'buffer time') it'll be down to 1fps, so rafin'g at 1Hz.
        //
        // When they make the game visible again, the frame rate is increased at a rate of
        // approx. 8fps, back up to 60fps (or the max it can obtain)
        //
        // There is no easy way to determine if this drop in frame rate is because the
        // browser is throttling raf, or because the game is struggling with performance
        // because you're asking it to do too much on the device.

        if (time > this.nextFpsUpdate)
        {
            //  Compute the new exponential moving average with an alpha of 0.25.
            this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
            this.nextFpsUpdate = time + 1000;
            this.framesThisSecond = 0;

            // if (this.actualFps < 56)
            // {
            //     console.log(this.actualFps);
            //     console.log('F', this.frame, 'Avg', avg, 'Dt', debug, 'Panic', this._coolDown);
            // }
        }

        this.framesThisSecond++;

        //  Interpolation - how far between what is expected and where we are?
        var interpolation = avg / this._target;

        this.callback(time, avg, interpolation);

        //  Shift time value over
        this.lastTime = time;

        // if (debug !== 0)
        // {
        //     console.log('F', this.frame, 'Avg', avg, 'Dt', debug, 'Panic', this._coolDown);
        // }

        /*
        if (debug !== 0 || dump.length)
        {
            console.group('Frame ' + this.frame);
            console.log('Interpolation', interpolation, '%');

            if (debug)
            {
                console.log('Elapsed', debug, 'ms');
            }

            // console.log('Frame', this.frame, 'Delta', avg, '(average)', debug, '(now)');

            console.log('Delta', avg, '(average)');

            if (dump.length)
            {
                console.table(dump);
            }

            console.groupEnd();
        }
        */
    },

    tick: function ()
    {
        this.step(window.performance.now());
    },

    sleep: function ()
    {
        if (this.running)
        {
            this.raf.stop();
            
            this.running = false;
        }
    },

    wake: function (seamless)
    {
        if (this.running)
        {
            this.sleep();
        }
        else if (seamless)
        {
            this.startTime += -this.lastTime + (this.lastTime = window.performance.now());
        }

        this.raf.start(this.step.bind(this), this.useRAF);

        this.running = true;

        this.step(window.performance.now());
    },

    setFps: function (value)
    {
        this.fps = value;

        this.wake();
    },

    getFps: function ()
    {
        return this.fps;
    },

    stop: function ()
    {
        this.running = false;
        this.started = false;

        this.raf.stop();

        return this;
    }
};

module.exports = TimeStep;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var VisibilityHandler = function (eventDispatcher)
{
    var hiddenVar;

    if (document.hidden !== undefined)
    {
        hiddenVar = 'visibilitychange';
    }
    else
    {
        var vendors = [ 'webkit', 'moz', 'ms' ];

        vendors.forEach(function (prefix)
        {
            if (document[prefix + 'Hidden'] !== undefined)
            {
                document.hidden = function ()
                {
                    return document[prefix + 'Hidden'];
                };

                hiddenVar = prefix + 'visibilitychange';
            }

        });
    }

    var onChange = function (event)
    {
        if (document.hidden || event.type === 'pause')
        {
            eventDispatcher.dispatch(new Event('HIDDEN'));
        }
        else
        {
            eventDispatcher.dispatch(new Event('VISIBLE'));
        }
    };

    //  Does browser support it?
    //  If not (like in IE9 or old Android) we need to fall back to blur / focus
    if (hiddenVar)
    {
        document.addEventListener(hiddenVar, onChange, false);
    }
    else
    {
        console.log('Fallback TODO');
    }

    window.onblur = function ()
    {
        eventDispatcher.dispatch(new Event('ON_BLUR'));
    };

    window.onfocus = function ()
    {
        eventDispatcher.dispatch(new Event('ON_FOCUS'));
    };

};

module.exports = VisibilityHandler;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var CacheEntry = __webpack_require__(327);
var Events = __webpack_require__(330);
var EventDispatcher = __webpack_require__(15);

var BaseCache = function ()
{
    this.entries = new Map();

    this.events = new EventDispatcher();
};

BaseCache.prototype.constructor = BaseCache;

BaseCache.prototype = {

    add: function (key, data)
    {
        this.entries.set(key, data);

        this.events.dispatch(new Events.CACHE_ADD_EVENT(this, key, data));
    },

    has: function (key)
    {
        return this.entries.has(key);
    },

    get: function (key)
    {
        return this.entries.get(key);
    },

    remove: function (key)
    {
        var entry = this.get(key);

        if (entry)
        {
            this.entries.delete(key);

            this.events.dispatch(new Events.CACHE_REMOVE_EVENT(this, key, entry.data));
        }
    },

    destroy: function ()
    {
        this.entries.clear();
    }

};

module.exports = BaseCache;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var BaseCache = __webpack_require__(325);

var Cache = function ()
{
    this.sound = new BaseCache();
    this.video = new BaseCache();
    this.text = new BaseCache();
    this.json = new BaseCache();
    this.xml = new BaseCache();
    this.physics = new BaseCache();
    this.tilemap = new BaseCache();
    this.binary = new BaseCache();
    this.bitmapFont = new BaseCache();
    this.shader = new BaseCache();

    this.custom = {};
};

Cache.prototype.constructor = Cache;

Cache.prototype = {

    //  Add your own custom Cache entry, available under Cache.custom.key
    addCustom: function (key)
    {
        if (!this.custom.hasOwnProperty(key))
        {
            this.custom[key] = new BaseCache();

            return this.custom[key];
        }
    }

};

module.exports = Cache;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

var CacheEntry = function (key, url, data)
{
    this.key = key;

    this.url = url;

    this.data = data;
};

CacheEntry.prototype.constructor = CacheEntry;

module.exports = CacheEntry;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var CacheAddEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheAddEvent.prototype = Object.create(Event.prototype);
CacheAddEvent.prototype.constructor = CacheAddEvent;

module.exports = CacheAddEvent;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var CacheRemoveEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheRemoveEvent.prototype = Object.create(Event.prototype);
CacheRemoveEvent.prototype.constructor = CacheRemoveEvent;

module.exports = CacheRemoveEvent;


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    CACHE_ADD_EVENT: __webpack_require__(328),
    CACHE_REMOVE_EVENT: __webpack_require__(329)

};


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);

//  var camControl = new CameraControl({
//      camera: this.cameras.main,
//      left: cursors.left,
//      right: cursors.right,
//      speed: float OR { x: 0, y: 0 }
//  })

var KeyControl = function (config)
{
    this.camera = GetValue(config, 'camera', null);

    this.left = GetValue(config, 'left', null);
    this.right = GetValue(config, 'right', null);
    this.up = GetValue(config, 'up', null);
    this.down = GetValue(config, 'down', null);

    var speed = GetValue(config, 'speed', null);

    if (typeof speed === 'number')
    {
        this.speedX = speed;
        this.speedY = speed;
    }
    else
    {
        this.speedX = GetValue(config, 'speed.x', 0);
        this.speedY = GetValue(config, 'speed.y', 0);
    }

    this.active = (this.camera !== null);
};

KeyControl.prototype.constructor = KeyControl;

KeyControl.prototype = {

    start: function ()
    {
        this.active = (this.camera !== null);
    },

    stop: function ()
    {
        this.active = false;
    },

    update: function (delta)
    {
        if (!this.active)
        {
            return;
        }

        if (delta === undefined) { delta = 1; }

        var cam = this.camera;

        if (this.up && this.up.isDown)
        {
            cam.scrollY -= ((this.speedY * delta) | 0);
        }
        else if (this.down && this.down.isDown)
        {
            cam.scrollY += ((this.speedY * delta) | 0);
        }

        if (this.left && this.left.isDown)
        {
            cam.scrollX -= ((this.speedX * delta) | 0);
        }
        else if (this.right && this.right.isDown)
        {
            cam.scrollX += ((this.speedX * delta) | 0);
        }
    },

    destroy: function ()
    {
        this.camera = null;

        this.left = null;
        this.right = null;
        this.up = null;
        this.down = null;
    }
};

module.exports = KeyControl;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);

//  var camControl = new SmoothedKeyControl({
//      camera: this.cameras.main,
//      left: cursors.left,
//      right: cursors.right,
//      acceleration: float || { x: 0, y: 0 }
//      drag: float || { x: 0, y: 0 }
//      maxSpeed: float || { x: 0, y: 0 }
//  })

var SmoothedKeyControl = function (config)
{
    this.camera = GetValue(config, 'camera', null);

    this.left = GetValue(config, 'left', null);
    this.right = GetValue(config, 'right', null);
    this.up = GetValue(config, 'up', null);
    this.down = GetValue(config, 'down', null);

    var accel = GetValue(config, 'acceleration', null);

    if (typeof accel === 'number')
    {
        this.accelX = accel;
        this.accelY = accel;
    }
    else
    {
        this.accelX = GetValue(config, 'acceleration.x', 0);
        this.accelY = GetValue(config, 'acceleration.y', 0);
    }

    var drag = GetValue(config, 'drag', null);

    if (typeof drag === 'number')
    {
        this.dragX = drag;
        this.dragY = drag;
    }
    else
    {
        this.dragX = GetValue(config, 'drag.x', 0);
        this.dragY = GetValue(config, 'drag.y', 0);
    }

    var maxSpeed = GetValue(config, 'maxSpeed', null);

    if (typeof maxSpeed === 'number')
    {
        this.maxSpeedX = maxSpeed;
        this.maxSpeedY = maxSpeed;
    }
    else
    {
        this.maxSpeedX = GetValue(config, 'maxSpeed.x', 0);
        this.maxSpeedY = GetValue(config, 'maxSpeed.y', 0);
    }

    this._speedX = 0;
    this._speedY = 0;

    this.active = (this.camera !== null);
};

SmoothedKeyControl.prototype.constructor = SmoothedKeyControl;

SmoothedKeyControl.prototype = {

    start: function ()
    {
        this.active = (this.camera !== null);
    },

    stop: function ()
    {
        this.active = false;
    },

    update: function (delta)
    {
        if (!this.active)
        {
            return;
        }

        if (delta === undefined) { delta = 1; }

        var cam = this.camera;

        //  Apply Deceleration

        if (this._speedX > 0)
        {
            this._speedX -= this.dragX * delta;

            if (this._speedX < 0)
            {
                this._speedX = 0;
            }
        }
        else if (this._speedX < 0)
        {
            this._speedX += this.dragX * delta;

            if (this._speedX > 0)
            {
                this._speedX = 0;
            }
        }

        if (this._speedY > 0)
        {
            this._speedY -= this.dragY * delta;

            if (this._speedY < 0)
            {
                this._speedY = 0;
            }
        }
        else if (this._speedY < 0)
        {
            this._speedY += this.dragY * delta;

            if (this._speedY > 0)
            {
                this._speedY = 0;
            }
        }

        //  Check for keys

        if (this.up.isDown)
        {
            this._speedY += this.accelY;

            if (this._speedY > this.maxSpeedY)
            {
                this._speedY = this.maxSpeedY;
            }
        }
        else if (this.down.isDown)
        {
            this._speedY -= this.accelY;

            if (this._speedY < -this.maxSpeedY)
            {
                this._speedY = -this.maxSpeedY;
            }
        }

        if (this.left.isDown)
        {
            this._speedX += this.accelX;

            if (this._speedX > this.maxSpeedX)
            {
                this._speedX = this.maxSpeedX;
            }
        }
        else if (this.right.isDown)
        {
            this._speedX -= this.accelX;

            if (this._speedX < -this.maxSpeedX)
            {
                this._speedX = -this.maxSpeedX;
            }
        }

        //  Apply to Camera

        if (this._speedX !== 0)
        {
            cam.scrollX -= ((this._speedX * delta) | 0);
        }

        if (this._speedY !== 0)
        {
            cam.scrollY -= ((this._speedY * delta) | 0);
        }
    },

    destroy: function ()
    {
        this.camera = null;

        this.left = null;
        this.right = null;
        this.up = null;
        this.down = null;
    }
};

module.exports = SmoothedKeyControl;


/***/ }),
/* 333 */
/***/ (function(module, exports) {

var CHECKSUM = {
build: 'adb03e70-5a7d-11e7-8ee9-f7ee67d93c13'
};
module.exports = CHECKSUM;

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(55);

//  Alpha Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 2; // 0010

var Alpha = {

    _alpha: 1,

    alpha: {

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = Clamp(value, 0, 1);

            if (this._alpha === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    setAlpha: function (value)
    {
        this.alpha = value;

        return this;
    }

};

module.exports = Alpha;


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {


var Class = __webpack_require__(1);
var Components = __webpack_require__(370);

//  Game Object Animation Controller

var Animation = new Class({

    initialize:

    function Animation (parent)
    {
        //  Sprite / Game Object
        this.parent = parent;

        this.animationManager = parent.state.sys.anims;

        this.animationManager.events.once('REMOVE_ANIMATION_EVENT', this.remove.bind(this));

        this.isPlaying = false;

        //  Reference to the Phaser.Animation object
        this.currentAnim = null;

        //  Reference to the Phaser.AnimationFrame object
        this.currentFrame = null;

        //  Animation specific values
        //  -------------------------

        //  Scale the time (make it go faster / slower)
        //  Factor that's used to scale time where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.
        this._timeScale = 1;

        //  The frame rate of playback in frames per second (default 24 if duration is null)
        this.frameRate = 0;

        //  How long the animation should play for. If framerate is set it overrides this value
        //  otherwise framerate is derived from duration
        this.duration = 0;

        //  ms per frame (without including frame specific modifiers)
        this.msPerFrame = 0;

        //  Skip frames if the time lags, or always advanced anyway?
        this.skipMissedFrames = true;

        //  Delay before starting playback (in seconds)
        this._delay = 0;

        //  Number of times to repeat the animation (-1 for infinity)
        this._repeat = 0;

        //  Delay before the repeat starts (in seconds)
        this._repeatDelay = 0;

        //  Should the animation yoyo? (reverse back down to the start) before repeating?
        this._yoyo = false;

        //  Playhead values
        //  ---------------

        //  Move the playhead forward (true) or in reverse (false)
        this.forward = true;

        this.accumulator = 0;
        this.nextTick = 0;

        this.repeatCounter = 0;

        this.pendingRepeat = false;

        this._paused = false;
        this._wasPlaying = false;

        this._callbackArgs = [ parent, null ];
        this._updateParams = [];
    },


    destroy: function ()
    {

    },

    delay: Components.Delay,
    delayedPlay: Components.DelayedPlay,
    getCurrentKey: Components.GetCurrentKey,
    load: Components.Load,
    pause: Components.Pause,
    paused: Components.Paused,
    play: Components.Play,
    progress: Components.Progress,
    remove: Components.Remove,
    repeat: Components.Repeat,
    repeatDelay: Components.RepeatDelay,
    restart: Components.Restart,
    resume: Components.Resume,
    stop: Components.Stop,
    timeScale: Components.TimeScale,
    totalFrames: Components.TotalFrames,
    totalProgress: Components.TotalProgress,
    update: Components.Update,
    updateFrame: Components.UpdateFrame,
    yoyo: Components.Yoyo

});

module.exports = Animation;


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

var BlendModes = __webpack_require__(59);

//  BlendMode Component

var BlendMode = {

    _blendMode: BlendModes.NORMAL,

    blendMode: {

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            value | 0;

            if (value >= 0 && value <= 16)
            {
                this._blendMode = value;
            }
        }

    },

    setBlendMode: function (value)
    {
        this.blendMode = value;

        return this;
    }

};

module.exports = BlendMode;


/***/ }),
/* 337 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child)
    {
        if (child.parent === this)
        {
            return child;
        }
        else if (child.parent)
        {
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        return child;
    },

    addAt: function (child, index)
    {
        if (index === undefined) { index = 0; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        return child;

    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i]);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    getFirst: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (child[property] === value)
            {
                return child;
            }
        }

        return null;
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);
        }
        
        return child;
    },

    removeAt: function (index)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild);
            }

            this.remove(oldChild);

            this.addAt(newChild, index);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1);

        parentChildren.remove(child2);

        this.addAt(child2, index1);

        parentChildren.addAt(child1, index2);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ }),
/* 338 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ }),
/* 339 */
/***/ (function(module, exports) {

var Flip = {

    flipX: false,
    flipY: false,

    setFlipX: function (value)
    {
        this.flipX = value;

        return this;
    },

    setFlipY: function (value)
    {
        this.flipX = value;

        return this;
    },

    setFlip: function (x, y)
    {
        this.flipX = x;
        this.flipY = y;

        return this;
    },

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    }

};

module.exports = Flip;


/***/ }),
/* 340 */
/***/ (function(module, exports) {

var GetBounds = {

    getBounds: function (output)
    {
        if (output === undefined) { output = { x: 0, y: 0, width: 0, height: 0 }; }

        var x = this.x;
        var y = this.y;

        var w = this.displayWidth;
        var h = this.displayHeight;

        var r = this.rotation;

        var wct = w * Math.cos(r);
        var hct = h * Math.cos(r);

        var wst = w * Math.sin(r);
        var hst = h * Math.sin(r);

        var xMin = x;
        var xMax = x;
        var yMin = y;
        var yMax = y;

        if (r > 0)
        {
            if (r < 1.5707963267948966)
            {
                // 0 < theta < 90
                yMax = y + hct + wst;
                xMin = x - hst;
                xMax = x + wct;
            }
            else
            {
                // 90 <= theta <= 180
                yMin = y + hct;
                yMax = y + wst;
                xMin = x - hst + wct;
            }
        }
        else if (r > -1.5707963267948966)
        {
            // -90 < theta <= 0
            yMin = y + wst;
            yMax = y + hct;
            xMax = x + wct - hst;
        }
        else
        {
            // -180 <= theta <= -90
            yMin = y + wst + hct;
            xMin = x + wct;
            xMax = x - hst;
        }

        output.x = xMin;
        output.y = yMin;
        output.width = xMax - xMin;
        output.height = yMax - yMin;

        return output;
    }
};

module.exports = GetBounds;


/***/ }),
/* 341 */
/***/ (function(module, exports) {

//  Origin Component
//  Values are normalized, given in the range 0 to 1.
//  Display values contain the calculated pixel values.

var Origin = {

    originX: 0.5,
    originY: 0.5,

    //  READ ONLY
    displayOriginX: 0,
    displayOriginY: 0,

    setOrigin: function (x, y)
    {
        if (x === undefined) { x = 0.5; }
        if (y === undefined) { y = x; }

        this.originX = x;
        this.originY = y;

        return this.updateOrigin();
    },

    setDisplayOrigin: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.displayOriginX = x;
        this.displayOriginY = y;

        this.originX = this.width / x;
        this.originY = this.height / y;

        return this;
    },

    updateOrigin: function ()
    {
        this.displayOriginX = Math.round(this.originX * this.width);
        this.displayOriginY = Math.round(this.originY * this.height);

        return this;
    }

};

module.exports = Origin;


/***/ }),
/* 342 */
/***/ (function(module, exports) {

var RenderTarget = {

    renderTarget: null
    
};

module.exports = RenderTarget;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(38);

//  ScaleMode Component

var ScaleMode = {

    _scaleMode: ScaleModes.DEFAULT,

    scaleMode: {

        get: function ()
        {
            return this._scaleMode;
        },

        set: function (value)
        {
            if (value === ScaleModes.LINEAR || value === ScaleModes.NEAREST)
            {
                this._scaleMode = value;
            }
        }

    },

    setScaleMode: function (value)
    {
        this.scaleMode = value;

        return this;
    }

};

module.exports = ScaleMode;


/***/ }),
/* 344 */
/***/ (function(module, exports) {

var ScrollFactor = {

    scrollFactorX: 1.0,
    scrollFactorY: 1.0,

    setScrollFactor: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.scrollFactorX = x;
        this.scrollFactorY = y;

        return this;
    }

};

module.exports = ScrollFactor;


/***/ }),
/* 345 */
/***/ (function(module, exports) {

var Size = {

    width: 0,
    height: 0,

    displayWidth: {

        get: function ()
        {
            return this.scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    displayHeight: {

        get: function ()
        {
            return this.scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    },

    setSizeToFrame: function (frame)
    {
        if (frame === undefined) { frame = this.frame; }

        this.width = frame.realWidth;
        this.height = frame.realHeight;

        return this;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    }

};

module.exports = Size;


/***/ }),
/* 346 */
/***/ (function(module, exports) {

//  Texture Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 8; // 1000

var Texture = {

    texture: null,
    frame: null,

    setTexture: function (key, frame)
    {
        this.texture = this.state.sys.textures.get(key);

        this.frame = this.texture.get(frame);

        if (!this.frame.cutWidth || !this.frame.cutHeight)
        {
            this.renderFlags &= ~_FLAG;
        }
        else
        {
            this.renderFlags |= _FLAG;
        }

        return this;
    }

};

module.exports = Texture;


/***/ }),
/* 347 */
/***/ (function(module, exports) {

//  Default Game Object JSON export
//  Is extended further by Game Object specific implementations

var ToJSON = function (gameObject)
{
    var out = {
        name: gameObject.name,
        type: gameObject.type,
        x: gameObject.x,
        y: gameObject.y,
        z: gameObject.z,
        scale: {
            x: gameObject.scaleX,
            y: gameObject.scaleY
        },
        origin: {
            x: gameObject.originX,
            y: gameObject.originY
        },
        flipX: gameObject.flipX,
        flipY: gameObject.flipY,
        rotation: gameObject.rotation,
        alpha: gameObject.alpha,
        visible: gameObject.visible,
        scaleMode: gameObject.scaleMode,
        blendMode: gameObject.blendMode,
        textureKey: '',
        frameKey: '',
        data: {}
    };

    if (gameObject.texture)
    {
        out.textureKey = gameObject.texture.key;
        out.frameKey = gameObject.frame.name;
    }

    return out;
};

module.exports = ToJSON;


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);
var WrapAngle = __webpack_require__(183);
var WrapAngleDegrees = __webpack_require__(184);

//  global bitmask flag for GameObject.renderMask (used by Scale)
var _FLAG = 4; // 0100

//  Transform Component

var Transform = {

    //  "private" properties
    _scaleX: 1,
    _scaleY: 1,
    _rotation: 0,
    _z: 0,

    //  public properties / methods

    x: 0,
    y: 0,

    z: {

        get: function ()
        {
            return this._z;
        },

        set: function (value)
        {
            this.state.sys.sortChildrenFlag = true;
            this._z = value;
        }

    },

    scaleX: {

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            if (this._scaleX === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    scaleY: {

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            if (this._scaleY === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    angle: {

        get: function ()
        {
            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            //  value is in degrees
            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
    },

    rotation: {

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            //  value is in radians
            this._rotation = WrapAngle(value);
        }
    },

    setPosition: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setRotation: function (radians)
    {
        if (radians === undefined) { radians = 0; }

        this.rotation = radians;

        return this;
    },

    setScale: function (x, y)
    {
        if (x === undefined) { x = 1; }
        if (y === undefined) { y = x; }

        this.scaleX = x;
        this.scaleY = y;

        return this;
    },

    setZ: function (value)
    {
        if (value === undefined) { value = 0; }

        this.z = value;

        return this;
    }

};

module.exports = Transform;


/***/ }),
/* 349 */
/***/ (function(module, exports) {


//  Visible Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 1; // 0001

var Visible = {

    _visible: true,

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            if (value)
            {
                this._visible = true;
                this.renderFlags |= _FLAG;
            }
            else
            {
                this._visible = false;
                this.renderFlags &= ~_FLAG;
            }
        }

    }

};

module.exports = Visible;


/***/ }),
/* 350 */
/***/ (function(module, exports) {

//  Gets or sets the amount of time in seconds between repeats.
//  For example, if repeat is 2 and repeatDelay is 1, the animation will play initially,
//  then wait for 1 second before it repeats, then play again, then wait 1 second again
//  before doing its final repeat.

var Delay = function (value)
{
    if (value === undefined)
    {
        return this._delay;
    }
    else
    {
        this._delay = value;

        return this;
    }
};

module.exports = Delay;


/***/ }),
/* 351 */
/***/ (function(module, exports) {

var DelayedPlay = function (delay, key, startFrame)
{
    this.play(key, startFrame);

    this.nextTick += (delay * 1000);

    return this;
};

module.exports = DelayedPlay;


/***/ }),
/* 352 */
/***/ (function(module, exports) {

var GetCurrentKey = function ()
{
    if (this.currentAnim)
    {
        return this.currentAnim.key;
    }
};

module.exports = GetCurrentKey;


/***/ }),
/* 353 */
/***/ (function(module, exports) {

var Load = function (key, startFrame)
{
    if (startFrame === undefined) { startFrame = 0; }

    if (this.isPlaying)
    {
        this.stop();
    }

    //  Load the new animation in
    this.animationManager.load(this, key, startFrame);

    return this;
};

module.exports = Load;


/***/ }),
/* 354 */
/***/ (function(module, exports) {

var Pause = function (atFrame)
{
    if (!this._paused)
    {
        this._paused = true;
        this._wasPlaying = this.isPlaying;
        this.isPlaying = false;
    }

    if (atFrame !== undefined)
    {
        this.updateFrame(atFrame);
    }
    
    return this;
};

module.exports = Pause;


/***/ }),
/* 355 */
/***/ (function(module, exports) {

var Paused = function (value)
{
    if (value !== undefined)
    {
        //  Setter
        if (value)
        {
            return this.pause();
        }
        else
        {
            return this.resume();
        }
    }
    else
    {
        return this._paused;
    }
};

module.exports = Paused;


/***/ }),
/* 356 */
/***/ (function(module, exports) {

var Play = function (key, ignoreIfPlaying, startFrame)
{
    if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }
    if (startFrame === undefined) { startFrame = 0; }

    if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === key)
    {
        return this;
    }

    this.load(key, startFrame);

    var anim = this.currentAnim;

    //  Should give us 9,007,199,254,740,991 safe repeats
    this.repeatCounter = (this._repeat === -1) ? Number.MAX_SAFE_INTEGER : this._repeat;

    anim.getFirstTick(this);

    this.forward = true;
    this.isPlaying = true;
    this.pendingRepeat = false;

    if (anim.showOnStart)
    {
        this.parent.visible = true;
    }

    if (anim.onStart)
    {
        anim.onStart.apply(anim.callbackScope, this._callbackArgs.concat(anim.onStartParams));
    }

    return this;
};

module.exports = Play;


/***/ }),
/* 357 */
/***/ (function(module, exports) {

//  Value between 0 and 1. How far this animation is through, ignoring repeats and yoyos.
//  If the animation has a non-zero repeat defined, progress and totalProgress will be different
//  because progress doesn't include any repeats or repeatDelays whereas totalProgress does.
var Progress = function (value)
{
    if (value === undefined)
    {
        var p = this.currentFrame.progress;

        if (!this.forward)
        {
            p = 1 - p;
        }

        return p;
    }
    else
    {
        //  TODO: Set progress

        return this;
    }
};

module.exports = Progress;


/***/ }),
/* 358 */
/***/ (function(module, exports) {

var Remove = function (event)
{
    if (event === undefined) { event = this.currentAnim; }

    if (this.isPlaying && event.key === this.currentAnim.key)
    {
        this.stop();

        var sprite = this.parent;
        var frame = this.currentAnim.frames[0];

        this.currentFrame = frame;

        sprite.texture = frame.frame.texture;
        sprite.frame = frame.frame;
    }
};

module.exports = Remove;


/***/ }),
/* 359 */
/***/ (function(module, exports) {

//  Gets or sets the number of times that the animation should repeat
//  after its first iteration. For example, if repeat is 1, the animation will
//  play a total of twice (the initial play plus 1 repeat).
//  To repeat indefinitely, use -1. repeat should always be an integer.

var Repeat = function (value)
{
    if (value === undefined)
    {
        return this._repeat;
    }
    else
    {
        this._repeat = value;
        this.repeatCounter = 0;

        return this;
    }
};

module.exports = Repeat;


/***/ }),
/* 360 */
/***/ (function(module, exports) {

//  Gets or sets the amount of time in seconds between repeats.
//  For example, if repeat is 2 and repeatDelay is 1, the animation will play initially,
//  then wait for 1 second before it repeats, then play again, then wait 1 second again
//  before doing its final repeat.

var RepeatDelay = function (value)
{
    if (value === undefined)
    {
        return this._repeatDelay;
    }
    else
    {
        this._repeatDelay = value;

        return this;
    }
};

module.exports = RepeatDelay;


/***/ }),
/* 361 */
/***/ (function(module, exports) {

var Restart = function (includeDelay)
{
    if (includeDelay === undefined) { includeDelay = false; }

    this.currentAnim.getFirstTick(this, includeDelay);

    this.forward = true;
    this.isPlaying = true;
    this.pendingRepeat = false;

    //  Set frame
    this.updateFrame(this.currentAnim.frames[0]);

    return this;
};

module.exports = Restart;


/***/ }),
/* 362 */
/***/ (function(module, exports) {

var Resume = function (fromFrame)
{
    if (this._paused)
    {
        this._paused = false;
        this.isPlaying = this._wasPlaying;
    }

    if (fromFrame !== undefined)
    {
        this.updateFrame(fromFrame);
    }
    
    return this;
};

module.exports = Resume;


/***/ }),
/* 363 */
/***/ (function(module, exports) {

var Stop = function (dispatchCallbacks)
{
    if (dispatchCallbacks === undefined) { dispatchCallbacks = false; }

    this.isPlaying = false;

    var anim = this.currentAnim;

    if (dispatchCallbacks && anim.onComplete)
    {
        anim.onComplete.apply(anim.callbackScope, this._callbackArgs.concat(anim.onCompleteParams));
    }

    return this;
};

module.exports = Stop;


/***/ }),
/* 364 */
/***/ (function(module, exports) {

var TimeScale = function (value)
{
    if (value === undefined)
    {
        return this._timeScale;
    }
    else
    {
        this._timeScale = value;

        return this;
    }
};

module.exports = TimeScale;


/***/ }),
/* 365 */
/***/ (function(module, exports) {

var TotalFrames = function ()
{
    return this.currentAnim.frames.length;
};

module.exports = TotalFrames;


/***/ }),
/* 366 */
/***/ (function(module, exports) {

//  Value between 0 and 1. How far this animation is through, including things like delays
//  repeats, custom frame durations, etc. If the animation is set to repeat -1 it can never
//  have a duration, therefore this will return -1.
var TotalProgres = function ()
{

};

module.exports = TotalProgres;


/***/ }),
/* 367 */
/***/ (function(module, exports) {

var Update = function (timestamp, delta)
{
    if (!this.isPlaying || this.currentAnim.paused)
    {
        return;
    }

    this.accumulator += delta * this._timeScale;

    if (this.accumulator >= this.nextTick)
    {
        this.currentAnim.setFrame(this);
    }
};

module.exports = Update;


/***/ }),
/* 368 */
/***/ (function(module, exports) {

var UpdateFrame = function (animationFrame)
{
    var sprite = this.parent;

    this.currentFrame = animationFrame;

    sprite.texture = animationFrame.frame.texture;
    sprite.frame = animationFrame.frame;

    if (this.isPlaying)
    {
        if (animationFrame.setAlpha)
        {
            sprite.alpha = animationFrame.alpha;
        }

        var anim = this.currentAnim;

        if (anim.onUpdate)
        {
            anim.onUpdate.apply(anim.callbackScope, this._updateParams);
        }

        if (animationFrame.onUpdate)
        {
            animationFrame.onUpdate(sprite, animationFrame);
        }
    }
};

module.exports = UpdateFrame;


/***/ }),
/* 369 */
/***/ (function(module, exports) {

var Yoyo = function (value)
{
    if (value === undefined)
    {
        return this._yoyo;
    }
    else
    {
        this._yoyo = value;

        return this;
    }
};

module.exports = Yoyo;


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Animation.Frame.Components

//  Used by the GameObject Animation Controller, not the Animation itself

module.exports = {

    Delay: __webpack_require__(350),
    DelayedPlay: __webpack_require__(351),
    GetCurrentKey: __webpack_require__(352),
    Load: __webpack_require__(353),
    Pause: __webpack_require__(354),
    Paused: __webpack_require__(355),
    Play: __webpack_require__(356),
    Progress: __webpack_require__(357),
    Remove: __webpack_require__(358),
    Repeat: __webpack_require__(359),
    RepeatDelay: __webpack_require__(360),
    Restart: __webpack_require__(361),
    Resume: __webpack_require__(362),
    Stop: __webpack_require__(363),
    TimeScale: __webpack_require__(364),
    TotalFrames: __webpack_require__(365),
    TotalProgress: __webpack_require__(366),
    Update: __webpack_require__(367),
    UpdateFrame: __webpack_require__(368),
    Yoyo: __webpack_require__(369)
    
};


/***/ }),
/* 371 */
/***/ (function(module, exports) {

/*
import Canvas from 'canvas/Canvas.js';
import GetContext from 'canvas/GetContext.js';

export default function Grid  (
        {
            canvas = undefined,
            width = 256,
            height = width,
            cellWidth = 32,
            cellHeight = cellWidth,
            color1 = '#fff',
            color2 = '#000',
            drawLines = false,
            lineColor = '#ff0000',
            alternate = true,
            resizeCanvas = true,
            clear = true,
            preRender = undefined,
            postRender = undefined
        } = {}
    ) {

    if (!canvas)
    {
        canvas = Canvas(width, height);
        resizeCanvas = false;
        clear = false;
    }
    else
    {
        //  They provided own canvas, so we use its dimensions
        if (!resizeCanvas)
        {
            width = canvas.width;
            height = canvas.height;
        }
    }

    let ctx = GetContext(canvas);

    if (resizeCanvas)
    {
        Resize(canvas, width, height);
    }

    if (clear)
    {
        ctx.clearRect(0, 0, width, height);
    }

    if (drawLines)
    {
        ctx.lineWidth = 1;
        ctx.strokeStyle = lineColor;
    }

    //  preRender Callback?
    if (preRender)
    {
        preRender(canvas, ctx);
    }

    //  Draw the grid cells first (the lines go on top)

    let cx = Math.ceil(width / cellWidth);
    let cy = Math.ceil(height / cellHeight);
    let c = 0;
    let color = color1;

    for (let y = 0; y < cy; y++)
    {
        for (let x = 0; x < cx; x++)
        {
            if (c === 0)
            {
                color = color1;
                c = 1;
            }
            else
            {
                color = color2;
                c = 0;
            }

            if (color)
            {
                ctx.fillStyle = color;
                ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
            }

            if (drawLines)
            {
                //  +- 0.5 because we're using stroke, and will get anti-aliased line strokes without
                let ox = 0.5;
                let oy = 0.5;

                if (x === cx - 1)
                {
                    ox = -0.5;
                }

                if (y === cy - 1)
                {
                    oy = -0.5;
                }

                ctx.strokeRect((x * cellWidth) + ox, (y * cellHeight) + oy, cellWidth, cellHeight);
            }
        }

        if (alternate)
        {
            if (c === 0)
            {
                c = 1;
            }
            else
            {
                c = 0;
            }
        }

    }

    //  postRender Callback?
    if (postRender)
    {
        postRender(canvas, ctx);
    }

    return canvas;

}
*/


/***/ }),
/* 372 */
/***/ (function(module, exports) {

/**
* A 16 color C64 inspired palette.
* @constant
* @type {Array}
*/

module.exports = {
    0: '#000',
    1: '#fff',
    2: '#8b4131',
    3: '#7bbdc5',
    4: '#8b41ac',
    5: '#6aac41',
    6: '#3931a4',
    7: '#d5de73',
    8: '#945a20',
    9: '#5a4100',
    A: '#bd736a',
    B: '#525252',
    C: '#838383',
    D: '#acee8b',
    E: '#7b73de',
    F: '#acacac'
};


/***/ }),
/* 373 */
/***/ (function(module, exports) {

/**
* A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)
* @constant
* @type {Array}
*/

module.exports = {
    0: '#000',
    1: '#2234d1',
    2: '#0c7e45',
    3: '#44aacc',
    4: '#8a3622',
    5: '#5c2e78',
    6: '#aa5c3d',
    7: '#b5b5b5',
    8: '#5e606e',
    9: '#4c81fb',
    A: '#6cd947',
    B: '#7be2f9',
    C: '#eb8a60',
    D: '#e23d69',
    E: '#ffd93f',
    F: '#fff'
};


/***/ }),
/* 374 */
/***/ (function(module, exports) {

/**
* A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)
* @constant
* @type {Array}
*/

module.exports = {
    0: '#000',
    1: '#191028',
    2: '#46af45',
    3: '#a1d685',
    4: '#453e78',
    5: '#7664fe',
    6: '#833129',
    7: '#9ec2e8',
    8: '#dc534b',
    9: '#e18d79',
    A: '#d6b97b',
    B: '#e9d8a1',
    C: '#216c4b',
    D: '#d365c8',
    E: '#afaab9',
    F: '#f5f4eb'
};


/***/ }),
/* 375 */
/***/ (function(module, exports) {

/**
* A 16 color palette inspired by Japanese computers like the MSX.
* @constant
* @type {Array}
*/

module.exports = {
    0: '#000',
    1: '#191028',
    2: '#46af45',
    3: '#a1d685',
    4: '#453e78',
    5: '#7664fe',
    6: '#833129',
    7: '#9ec2e8',
    8: '#dc534b',
    9: '#e18d79',
    A: '#d6b97b',
    B: '#e9d8a1',
    C: '#216c4b',
    D: '#d365c8',
    E: '#afaab9',
    F: '#fff'
};


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    ARNE16: __webpack_require__(106),
    C64: __webpack_require__(372),
    CGA: __webpack_require__(373),
    JMP: __webpack_require__(374),
    MSX: __webpack_require__(375)
    
};


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(26);
var Browser = __webpack_require__(35);
var Features = __webpack_require__(108);
var Input = __webpack_require__(379);
var Audio = __webpack_require__(377);
var Video = __webpack_require__(380);
var Fullscreen = __webpack_require__(378);
var CanvasFeatures = __webpack_require__(107);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ }),
/* 382 */
/***/ (function(module, exports) {

var AddEventListener = function (target, event, listener, useCapture)
{
    if (useCapture === undefined) { useCapture = false; }

    target.addEventListener(event, listener, useCapture);
};

module.exports = AddEventListener;


/***/ }),
/* 383 */
/***/ (function(module, exports) {

var RemoveEventListener = function (target, event, listener)
{
    target.removeEventListener(event, listener);
};

module.exports = RemoveEventListener;


/***/ }),
/* 384 */
/***/ (function(module, exports) {

var RemoveFromDOM = function (element)
{
    if (element.parentNode)
    {
        element.parentNode.removeChild(element);
    }
};

module.exports = RemoveFromDOM;


/***/ }),
/* 385 */
/***/ (function(module, exports) {

/**
* Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
*
* @method Phaser.Canvas.TouchAction
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var TouchAction = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    canvas.style['msTouchAction'] = value;
    canvas.style['ms-touch-action'] = value;
    canvas.style['touch-action'] = value;

    return canvas;
};

module.exports = TouchAction;


/***/ }),
/* 386 */
/***/ (function(module, exports) {

/**
* Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
*
* @method Phaser.Canvas.setUserSelect
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var UserSelect = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    var vendors = [
        '-webkit-',
        '-khtml-',
        '-moz-',
        '-ms-',
        ''
    ];

    vendors.forEach(function (vendor)
    {
        canvas.style[vendor + 'user-select'] = value;
    });

    canvas.style['-webkit-touch-callout'] = value;
    canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';

    return canvas;
};

module.exports = UserSelect;


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(113);
var EventListener = __webpack_require__(388);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        //  Nothing to do ...
        if (this.active.length === 0)
        {
            return;
        }

        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(113);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

var GetAdvancedValue = __webpack_require__(14);

var BuildGameObjectAnimation = function (sprite, config)
{
    var animConfig = GetAdvancedValue(config, 'anims', null);

    if (animConfig === null)
    {
        return sprite;
    }

    if (typeof animConfig === 'string')
    {
        //  { anims: 'key' }
        sprite.anims.play(animConfig);
    }
    else if (typeof animConfig === 'object')
    {
        //  { anims: {
        //              key: string
        //              startFrame: [string|integer]
        //              delay: [float]
        //              repeat: [integer]
        //              repeatDelay: [float]
        //              yoyo: [boolean]
        //              play: [boolean]
        //              delayedPlay: [boolean]
        //           }
        //  }

        var anims = sprite.anims;

        var key = GetAdvancedValue(animConfig, 'key', undefined);
        var startFrame = GetAdvancedValue(animConfig, 'startFrame', undefined);

        anims.load(key);

        var delay = GetAdvancedValue(animConfig, 'delay', 0);
        var repeat = GetAdvancedValue(animConfig, 'repeat', 0);
        var repeatDelay = GetAdvancedValue(animConfig, 'repeatDelay', 0);
        var yoyo = GetAdvancedValue(animConfig, 'yoyo', false);

        anims.delay(delay);
        anims.repeat(repeat);
        anims.repeatDelay(repeatDelay);
        anims.yoyo(yoyo);

        if (GetAdvancedValue(animConfig, 'play', false))
        {
            anims.play(key, startFrame);
        }
        else
        {
            var d = GetAdvancedValue(animConfig, 'delayedPlay', 0);

            if (d > 0)
            {
                anims.delayedPlay(d, key, startFrame);
            }
        }
    }

    return sprite;
};

module.exports = BuildGameObjectAnimation;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);

// * @param {number} characterWidth - The width of each character in the font set.
// * @param {number} characterHeight - The height of each character in the font set.
// * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
// * @param {number} [charsPerRow] - The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.
// * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.
// * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.
// * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
// * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
// Phaser.GameObject.RetroFont = function (game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset)

// {
//      image: key,    
//      width: 32,
//      height: 32,
//      chars: 'string',
//      charsPerRow: null,
//      spacing: { x: 0, y: 0 },
//      offset: { x: 0, y: 0 }
// }

var ParseRetroFont = function (state, config)
{
    var w = config.width;
    var h = config.height;
    var cx = Math.floor(w / 2);
    var cy = Math.floor(h / 2);
    var letters = config.chars;

    var key = GetValue(config, 'image', '');
    var offsetX = GetValue(config, 'offset.x', 0);
    var offsetY = GetValue(config, 'offset.y', 0);
    var spacingX = GetValue(config, 'spacing.x', 0);
    var spacingY = GetValue(config, 'spacing.y', 0);

    var charsPerRow = GetValue(config, 'charsPerRow', null);

    if (charsPerRow === null)
    {
        charsPerRow = state.sys.textures.getFrame(key).width / w;
    }

    var x = offsetX;
    var y = offsetY;

    var data = {
        retroFont: true,
        font: key,
        size: w,
        lineHeight: h,
        chars: {}
    };

    var r = 0;

    for (var i = 0; i < letters.length; i++)
    {
        var node = letters[i];

        var charCode = letters.charCodeAt(i);

        data.chars[charCode] =
        {
            x: x,
            y: y,
            width: w,
            height: h,
            centerX: cx,
            centerY: cy,
            xOffset: 0,
            yOffset: 0,
            xAdvance: w,
            data: {},
            kerning: {}
        };

        r++;

        if (r === charsPerRow)
        {
            r = 0;
            x = offsetX;
            y += h + spacingY;
        }
        else
        {
            x += w + spacingX;
        }
    }

    return data;
};

ParseRetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

/**
* Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";

/**
* Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";

/**
* Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";

/**
* Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' 
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";

/**
* Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";

/**
* Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";

/**
* Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
* Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
* @constant
* @type {string}
*/
ParseRetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";

module.exports = ParseRetroFont;


/***/ }),
/* 391 */
/***/ (function(module, exports) {

function getValue (node, attribute)
{
    return parseInt(node.getAttribute(attribute), 10);
}

var ParseXMLBitmapFont = function (xml, xSpacing, ySpacing, frame)
{
    if (xSpacing === undefined) { xSpacing = 0; }
    if (ySpacing === undefined) { ySpacing = 0; }

    var data = {};
    var info = xml.getElementsByTagName('info')[0];
    var common = xml.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = getValue(info, 'size');
    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;
    data.chars = {};

    var letters = xml.getElementsByTagName('char');

    var x = (frame) ? frame.x : 0;
    var y = (frame) ? frame.y : 0;

    for (var i = 0; i < letters.length; i++)
    {
        var node = letters[i];

        var charCode = getValue(node, 'id');
        var gw = getValue(node, 'width');
        var gh = getValue(node, 'height');

        data.chars[charCode] =
        {
            x: x + getValue(node, 'x'),
            y: y + getValue(node, 'y'),
            width: gw,
            height: gh,
            centerX: Math.floor(gw / 2),
            centerY: Math.floor(gh / 2),
            xOffset: getValue(node, 'xoffset'),
            yOffset: getValue(node, 'yoffset'),
            xAdvance: getValue(node, 'xadvance') + xSpacing,
            data: {},
            kerning: {}
        };
    }

    var kernings = xml.getElementsByTagName('kerning');

    for (i = 0; i < kernings.length; i++)
    {
        var kern = kernings[i];

        var first = getValue(kern, 'first');
        var second = getValue(kern, 'second');
        var amount = getValue(kern, 'amount');

        data.chars[second].kerning[first] = amount;
    }

    return data;
};

module.exports = ParseXMLBitmapFont;


/***/ }),
/* 392 */
/***/ (function(module, exports) {

var DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var displayCallback = src.displayCallback;

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x, src.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    if (src.width > 0 && src.height > 0)
    {
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, src.width, src.height);
        ctx.clip();
        ctx.closePath();
    }

    for (var index = 0; index < textLength; ++index)
    {
        //  Reset the scale (in case the callback changed it)
        scale = (src.fontSize / src.fontData.size);
        rotation = 0;

        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = (indexCount + glyph.xOffset + xAdvance) - src.scrollX;
        y = (glyph.yOffset + yAdvance) - src.scrollY;

        //  This could be optimized so that it doesn't even bother drawing it if the x/y is out of range

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0, data: glyph.data });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        x *= scale;
        y *= scale;

        x -= cameraScrollX;
        y -= cameraScrollY;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);

        // ctx.fillStyle = 'rgba(0,255,0,0.2)';
        // ctx.fillRect(0, 0, glyphW, glyphH);

        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    if (src.width > 0 && src.height > 0)
    {
        ctx.restore();
    }

    ctx.restore();
};

module.exports = DynamicBitmapTextCanvasRenderer;


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(115);
var FactoryContainer = __webpack_require__(3);

var DynamicBitmapTextFactory = {

    KEY: 'dynamicBitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(DynamicBitmapTextFactory);


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(392),
    renderWebGL: __webpack_require__(395)

};


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(16);
var tempMatrix = new TransformMatrix();
var tempMatrixChar = new TransformMatrix();

var DynamicBitmapTextWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var displayCallback = gameObject.displayCallback;
    var textureFrame = gameObject.frame;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    var text = gameObject.text;
    var textLength = text.length;
    var chars = gameObject.fontData.chars;
    var lineHeight = gameObject.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = gameObject.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var textureData = gameObject.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var rotation = 0;
    var xw = 0;
    var yh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (gameObject.fontSize / gameObject.fontData.size);
    var uta, utb, utc, utd, ute, utf;
    var tempMatrixCharMatrix = tempMatrixChar.matrix;
    var renderTarget = gameObject.renderTarget;

    tempMatrix.applyITRS(
        gameObject.x - cameraScrollX, gameObject.y - cameraScrollY, 
        -gameObject.rotation, 
        gameObject.scaleX, gameObject.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    var gl = renderer.gl;

    if (gameObject.width > 0 && gameObject.height > 0)
    {
        if (renderer.currentRenderer !== null)
        {
            renderer.currentRenderer.flush();
        }

        if (!renderer.scissor.enabled)
        {
            gl.enable(gl.SCISSOR_TEST);
        }

        var sw = gameObject.width * gameObject.scaleX;
        var sh = gameObject.height * gameObject.scaleY;

        gl.scissor(gameObject.x, gl.drawingBufferHeight - gameObject.y - sh, sw, sh);
    }

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;
        rotation = 0;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0, data: glyph.data });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        x -= gameObject.scrollX | 0;
        y -= gameObject.scrollY | 0;

        tempMatrixChar.applyITRS(
            x, y,
            -rotation,
            scale, scale
        );

        uta = tempMatrixCharMatrix[0];
        utb = tempMatrixCharMatrix[1];
        utc = tempMatrixCharMatrix[2];
        utd = tempMatrixCharMatrix[3];
        ute = tempMatrixCharMatrix[4];
        utf = tempMatrixCharMatrix[5];

        sra = uta * mva + utb * mvc;
        srb = uta * mvb + utb * mvd;
        src = utc * mva + utd * mvc;
        srd = utc * mvb + utd * mvd;
        sre = ute * mva + utf * mvc + mve;
        srf = ute * mvb + utf * mvd + mvf;

        xw = glyphW;
        yh = glyphH;
        tx0 = sre;
        ty0 = srf;
        tx1 = yh * src + sre;
        ty1 = yh * srd + srf;
        tx2 = xw * sra + yh * src + sre;
        ty2 = xw * srb + yh * srd + srf;
        tx3 = xw * sra + sre;
        ty3 = xw * srb + srf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setRenderer(blitterBatch, texture, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    if (gameObject.width > 0 && gameObject.height > 0)
    {
        blitterBatch.flush();

        if (renderer.scissor.enabled)
        {
            gl.scissor(renderer.scissor.x, renderer.scissor.y, renderer.scissor.width, renderer.scissor.height);
        }
        else
        {
            gl.scissor(camera.x, gl.drawingBufferHeight - camera.y - camera.height, camera.width, camera.height);
            gl.disable(gl.SCISSOR_TEST);
        }
    }
};

module.exports = DynamicBitmapTextWebGLRenderer;


/***/ }),
/* 396 */
/***/ (function(module, exports) {

var BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x - cameraScrollX, src.y - cameraScrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        x *= scale;
        y *= scale;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    ctx.restore();
};

module.exports = BitmapTextCanvasRenderer;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(116);
var FactoryContainer = __webpack_require__(3);

var BitmapTextFactory = {

    KEY: 'bitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(BitmapTextFactory);


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(396),
    renderWebGL: __webpack_require__(399)

};


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(16);
var tempMatrix = new TransformMatrix();

var BitmapTextWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var textureFrame = gameObject.frame;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    var text = gameObject.text;
    var textLength = text.length;
    var chars = gameObject.fontData.chars;
    var lineHeight = gameObject.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = gameObject.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var srcX = gameObject.x; 
    var srcY = gameObject.y;
    var textureData = gameObject.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var tx = 0;
    var ty = 0;
    var txw = 0;
    var tyh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (gameObject.fontSize / gameObject.fontData.size);
    var renderTarget = gameObject.renderTarget;

    tempMatrix.applyITRS(
        gameObject.x - cameraScrollX, gameObject.y - cameraScrollY, 
        -gameObject.rotation, 
        gameObject.scaleX, gameObject.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);
        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];
        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        xw = x + glyphW * scale;
        yh = y + glyphH * scale;
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setRenderer(blitterBatch, texture, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }
};

module.exports = BitmapTextWebGLRenderer;


/***/ }),
/* 400 */
/***/ (function(module, exports) {


var BlitterCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();

    renderer.setBlendMode(src.blendMode);

    var ca = renderer.currentAlpha;

    //  Render bobs
    for (var i = 0; i < list.length; i++)
    {
        var bob = list[i];

        if (ca !== bob.alpha)
        {
            ca = renderer.setAlpha(bob.alpha);
        }

        renderer.blitImage(bob.x, bob.y, bob.frame, camera);
    }
};

module.exports = BlitterCanvasRenderer;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {


var Blitter = __webpack_require__(117);
var FactoryContainer = __webpack_require__(3);

var BlitterFactory = {

    KEY: 'blitter',

    add: function (x, y, key, frame)
    {
        return this.children.add(new Blitter(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        return new Blitter(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(BlitterFactory);


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(400),
    renderWebGL: __webpack_require__(403)

};


/***/ }),
/* 403 */
/***/ (function(module, exports) {

var BlitterWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();
    var blitterBatch = renderer.blitterBatch;
    var cameraMatrix = camera.matrix.matrix;
    var a = cameraMatrix[0];
    var b = cameraMatrix[1];
    var c = cameraMatrix[2];
    var d = cameraMatrix[3];
    var e = cameraMatrix[4];
    var f = cameraMatrix[5];
    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;
    var renderTarget = src.renderTarget;

    //  Render bobs

    for (var i = 0, l = list.length; i < l; i++)
    {
        var bob = list[i];
        var frame = bob.frame;
        var alpha = bob.alpha;
        var vertexDataBuffer = blitterBatch.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (bob.flipX ? -1 : 1);
        var height = frame.height * (bob.flipY ? -1 : 1);
        var x = bob.x + frame.x - cameraScrollX + ((frame.width) * (bob.flipX ? 1 : 0.0));
        var y = bob.y + frame.y - cameraScrollY + ((frame.height) * (bob.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var tx = x * a + y * c + e;
        var ty = x * b + y * d + f;
        var txw = xw * a + yh * c + e;
        var tyh = xw * b + yh * d + f;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setRenderer(blitterBatch, frame.texture.source[frame.sourceIndex].glTexture, camera, renderTarget);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;
        x += frame.x;
        y += frame.y;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x0;
        vertexBuffer[vertexOffset++] = uvs.y0;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x1;
        vertexBuffer[vertexOffset++] = uvs.y1;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x2;
        vertexBuffer[vertexOffset++] = uvs.y2;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x3;
        vertexBuffer[vertexOffset++] = uvs.y3;
        vertexBuffer[vertexOffset++] = alpha;
    }
};

module.exports = BlitterWebGLRenderer;


/***/ }),
/* 404 */
/***/ (function(module, exports) {

var Bob = function (blitter, x, y, frame, visible)
{
    this.parent = blitter;

    this.x = x;
    this.y = y;
    this.frame = frame;
    this.data = {};

    this._visible = visible;
    this._alpha = 1;

    this.flipX - false;
    this.flipY = false;

};

Bob.prototype.constructor = Bob;

Bob.prototype = {

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    },


    reset: function (x, y, frame)
    {
        this.x = x;
        this.y = y;
        this.frame = frame;
    },

    destroy: function ()
    {
        this.parent = undefined;
        this.frame = undefined;
        this.data = undefined;
    }

};

Object.defineProperties(Bob.prototype, {

    visible: {

        enumerable: true,

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            this._visible = value;
            this.parent.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = value;
            this.parent.dirty = true;
        }

    }

});

module.exports = Bob;


/***/ }),
/* 405 */
/***/ (function(module, exports) {


var ContainerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderCanvas(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerCanvasRenderer;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {


var Container = __webpack_require__(118);
var FactoryContainer = __webpack_require__(3);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(405),
    renderWebGL: __webpack_require__(408)

};


/***/ }),
/* 408 */
/***/ (function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderWebGL(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

var EffectLayer = __webpack_require__(65);
var GetAdvancedValue = __webpack_require__(14);

var BuildFromConfig = function (state, config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var width = GetAdvancedValue(config, 'width', 512);
    var height = GetAdvancedValue(config, 'height', 512);
    var key = GetAdvancedValue(config, 'key', null);
    var fragmentShader = GetAdvancedValue(config, 'fragmentShader', '');

    var layer = new EffectLayer(state, x, y, width, height, key, fragmentShader);

    return layer;
};

module.exports = BuildFromConfig;


/***/ }),
/* 410 */
/***/ (function(module, exports) {

var EffectLayerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = EffectLayerCanvasRenderer;
 

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var EffectLayer = __webpack_require__(65);
var BuildFromConfig = __webpack_require__(409);
var FactoryContainer = __webpack_require__(3);

var EffectLayerFactory = {

    KEY: 'effectLayer',

    add: function (x, y, width, height, effectName, fragmentShader)
    {
        return this.children.add(new EffectLayer(this.state, x, y, width, height, effectName, fragmentShader));
    },

    make: function (x, y, width, height, effectName, fragmentShader)
    {
        return new EffectLayer(this.state, x, y, width, height, effectName, fragmentShader);
    }

    // make: function (config)
    // {
    //     return BuildFromConfig(this.state, config);
    // }

};

module.exports = FactoryContainer.register(EffectLayerFactory);


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(410),
    renderWebGL: __webpack_require__(413)

};


/***/ }),
/* 413 */
/***/ (function(module, exports) {

var EffectLayerWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.effectRenderer.renderEffect(src, camera, src.renderTexture, src.width, src.height);
};

module.exports = EffectLayerWebGLRenderer;
 

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(66);
var MATH_CONST = __webpack_require__(11);

var GraphicsCanvasRenderer = function (renderer, src, interpolationPercentage, camera, renderTargetCtx)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;
    var srcX = src.x;
    var srcY = src.y;
    var srcScaleX = src.scaleX;
    var srcScaleY = src.scaleY;
    var srcRotation = src.rotation;
    var commandBuffer = src.commandBuffer;
    var ctx = renderTargetCtx || renderer.currentContext;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var red = 0;
    var green = 0;
    var blue = 0;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(srcX - cameraScrollX, srcY - cameraScrollY);
    ctx.rotate(srcRotation);
    ctx.scale(srcScaleX, srcScaleY);
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = src.alpha;

    for (var index = 0, length = commandBuffer.length; index < length; ++index)
    {
        var commandID = commandBuffer[index];

        switch (commandID)
        {
            case Commands.ARC:
                ctx.arc(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4],
                    commandBuffer[index + 5],
                    commandBuffer[index + 6]
                );
                index += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[index + 1];
                lineColor = commandBuffer[index + 2];
                lineAlpha = commandBuffer[index + 3];
                red = ((lineColor & 0xFF0000) >>> 16);
                green = ((lineColor & 0xFF00) >>> 8);
                blue = (lineColor & 0xFF);
                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';
                ctx.lineWidth = lineWidth;
                index += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[index + 1];
                fillAlpha = commandBuffer[index + 2];
                red = ((fillColor & 0xFF0000) >>> 16);
                green = ((fillColor & 0xFF00) >>> 8);
                blue = (fillColor & 0xFF);
                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
                index += 2;
                break;

            case Commands.BEGIN_PATH:
                ctx.beginPath();
                break;

            case Commands.CLOSE_PATH:
                ctx.closePath();
                break;

            case Commands.FILL_PATH:
                ctx.fill();
                break;

            case Commands.STROKE_PATH:
                ctx.stroke();
                break;

            case Commands.FILL_RECT:
                ctx.fillRect(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4]
                );
                index += 4;
                break;

            case Commands.FILL_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.fill();
                index += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.stroke();
                index += 6;
                break;

            case Commands.LINE_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.MOVE_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.LINE_FX_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            case Commands.MOVE_FX_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            case Commands.SAVE:
                ctx.save();
                break;

            case Commands.RESTORE:
                ctx.restore();
                break;

            case Commands.TRANSLATE:
                ctx.translate(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.SCALE:
                ctx.scale(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.ROTATE:
                ctx.rotate(
                    commandBuffer[index + 1]
                );
                index += 1;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + commandID);
                break;
        }
    }

    ctx.restore();
};

module.exports = GraphicsCanvasRenderer;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var Graphics = __webpack_require__(119);
var FactoryContainer = __webpack_require__(3);

var GraphicsFactory = {

    KEY: 'graphics',

    add: function (options)
    {
        return this.children.add(new Graphics(this.state, options));
    },

    make: function (options)
    {
        return new Graphics(this.state, options);
    }

};

module.exports = FactoryContainer.register(GraphicsFactory);


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(414),
    renderWebGL: __webpack_require__(417)

};


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(66);
var TransformMatrix = __webpack_require__(16);
var pathArray = [];
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
var tempMatrix = new TransformMatrix();
var matrixStack = new Float32Array(6 * 1000);
var matrixStackLength = 0;
var currentMatrix = new TransformMatrix();

var Point = function (x, y, width, rgb, alpha)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.rgb = rgb;
    this.alpha = alpha;
};

var Path = function (x, y, width, rgb, alpha)
{
    this.points = [];
    this.pointsLength = 1;
    this.points[0] = new Point(x, y, width, rgb, alpha);
};

var GraphicsWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera, forceRenderTarget)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var renderTarget = forceRenderTarget || gameObject.renderTarget;
    var shapeBatch = renderer.shapeBatch;
    var vertexDataBuffer = shapeBatch.vertexDataBuffer;
    var vertexBufferF32 = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var cameraScrollX = camera.scrollX * gameObject.scrollFactorX;
    var cameraScrollY = camera.scrollY * gameObject.scrollFactorY;
    const srcX = gameObject.x - cameraScrollX;
    const srcY = gameObject.y - cameraScrollY;
    const srcScaleX = gameObject.scaleX;
    const srcScaleY = gameObject.scaleY;
    const srcRotation = -gameObject.rotation;
    var commandBuffer = gameObject.commandBuffer;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var cameraMatrix = camera.matrix.matrix;
    var lastPath = null;
    var iteration = 0;
    var iterStep = 0.01;
    var tx = 0;
    var ty = 0;
    var ta = 0;
    var x, y, radius, startAngle, endAngle, anticlockwise;
    var width, height, txw, tyh;
    var vertexCount = shapeBatch.vertexCount;
    var polygon = [];
    var x0, y0, x1, y1, x2, y2;
    var tx0, ty0, tx1, ty1, tx2, ty2;
    var v0, v1, v2;
    var polygonIndex;
    var path;
    var pathLength;
    var point;
    var maxVertices = shapeBatch.maxVertices;
    var translateX, translateY;
    var tempMatrixMatrix = tempMatrix.matrix;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var mva, mvb, mvc, mvd, mve, mvf;

    tempMatrix.applyITRS(srcX, srcY, srcRotation, srcScaleX, srcScaleY);

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    renderer.setRenderer(shapeBatch, null, renderTarget);

    for (var cmdIndex = 0, cmdLength = commandBuffer.length; cmdIndex < cmdLength; ++cmdIndex)
    {
        var cmd = commandBuffer[cmdIndex];

        switch(cmd)
        {
            case Commands.ARC:
                iteration = 0;
                x = commandBuffer[cmdIndex + 1];
                y = commandBuffer[cmdIndex + 2];
                radius = commandBuffer[cmdIndex + 3];
                startAngle = commandBuffer[cmdIndex + 4];
                endAngle = commandBuffer[cmdIndex + 5];
                anticlockwise = commandBuffer[cmdIndex + 6];
                
                while (iteration < 1)
                {
                    ta = (endAngle - startAngle) * iteration + startAngle;
                    tx = x + cos(ta) * radius;
                    ty = y + sin(ta) * radius;

                    if (iteration === 0)
                    {
                        lastPath = new Path(tx, ty, lineWidth, lineColor, lineAlpha);
                        pathArray.push(lastPath);
                    }
                    else
                    {
                        lastPath.points.push(new Point(tx, ty, lineWidth, lineColor, lineAlpha));
                    }

                    iteration += iterStep;
                }
                cmdIndex += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[cmdIndex + 1];
                lineColor = commandBuffer[cmdIndex + 2];
                lineAlpha = commandBuffer[cmdIndex + 3];
                cmdIndex += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[cmdIndex + 1];
                fillAlpha = commandBuffer[cmdIndex + 2];
                cmdIndex += 2;
                break;

            case Commands.BEGIN_PATH:
                pathArray.length = 0;
                break;

            case Commands.CLOSE_PATH:
                if (lastPath !== null && lastPath.points.length > 0)
                {
                    var firstPoint = lastPath.points[0];
                    var lastPoint = lastPath.points[lastPath.points.length - 1];
                    lastPath.points.push(firstPoint);
                    lastPath = new Path(lastPoint.x, lastPoint.y, lastPoint.width, lastPoint.rgb, lastPoint.alpha);
                    pathArray.push(lastPath);
                }
                break;

            case Commands.FILL_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    shapeBatch.addFillPath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        pathArray[pathArrayIndex].points,
                        fillColor,
                        fillAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        currentMatrix
                    );
                }
                break;

            case Commands.STROKE_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    var path = pathArray[pathArrayIndex];
                    shapeBatch.addStrokePath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        path.points,
                        lineWidth,
                        lineColor,
                        lineAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        path === this._lastPath,
                        currentMatrix

                    );
                }
                break;
                
            case Commands.FILL_RECT:
                shapeBatch.addFillRect(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Rectangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
             
                cmdIndex += 4;
                break;

            case Commands.FILL_TRIANGLE:
                shapeBatch.addFillTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
                
                cmdIndex += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                shapeBatch.addStrokeTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    lineWidth,
                    lineColor,
                    lineAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf,
                    currentMatrix

                );
                
                cmdIndex += 6;
                break

            case Commands.LINE_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha));
                }
                else
                {
                    lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                    pathArray.push(lastPath);
                }
                cmdIndex += 2;
                break;

            case Commands.MOVE_TO:
                lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                pathArray.push(lastPath);
                cmdIndex += 2;
                break;

            case Commands.LINE_FX_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    ));
                }
                else
                {
                    lastPath = new Path(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    );
                    pathArray.push(lastPath);
                }
                cmdIndex += 5;
                break;

            case Commands.MOVE_FX_TO:
                lastPath = new Path(
                    commandBuffer[cmdIndex + 1], 
                    commandBuffer[cmdIndex + 2], 
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    commandBuffer[cmdIndex + 5]
                );
                pathArray.push(lastPath);
                cmdIndex += 5;
                break;

            case Commands.SAVE:
                matrixStack[matrixStackLength + 0] = currentMatrix.matrix[0];
                matrixStack[matrixStackLength + 1] = currentMatrix.matrix[1];
                matrixStack[matrixStackLength + 2] = currentMatrix.matrix[2];
                matrixStack[matrixStackLength + 3] = currentMatrix.matrix[3];
                matrixStack[matrixStackLength + 4] = currentMatrix.matrix[4];
                matrixStack[matrixStackLength + 5] = currentMatrix.matrix[5];
                matrixStackLength += 6;
                break;

            case Commands.RESTORE:
                matrixStackLength -= 6;
                currentMatrix.matrix[0] = matrixStack[matrixStackLength + 0];
                currentMatrix.matrix[1] = matrixStack[matrixStackLength + 1];
                currentMatrix.matrix[2] = matrixStack[matrixStackLength + 2];
                currentMatrix.matrix[3] = matrixStack[matrixStackLength + 3];
                currentMatrix.matrix[4] = matrixStack[matrixStackLength + 4];
                currentMatrix.matrix[5] = matrixStack[matrixStackLength + 5];
                break;

            case Commands.TRANSLATE:
                currentMatrix.translate(
                    commandBuffer[cmdIndex + 1],
                    commandBuffer[cmdIndex + 2]
                );
                cmdIndex += 2;
                break;

            case Commands.SCALE:
                currentMatrix.scale(
                    commandBuffer[cmdIndex + 1],
                    commandBuffer[cmdIndex + 2]
                );
                cmdIndex += 2;
                break;

            case Commands.ROTATE:
                currentMatrix.rotate(
                    -commandBuffer[cmdIndex + 1]
                );
                cmdIndex += 1;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + cmd);
                break;
        }
    }
    currentMatrix.loadIdentity();
    pathArray.length = 0;
};

module.exports = GraphicsWebGLRenderer;


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

var Image = __webpack_require__(67);
var GetAdvancedValue = __webpack_require__(14);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var image = new Image(state, 0, 0, key, frame);

    BuildGameObject(state, image, config);

    return image;
};

module.exports = BuildFromConfig;


/***/ }),
/* 419 */
/***/ (function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = ImageCanvasRenderer;


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {


var Image = __webpack_require__(67);
var BuildFromConfig = __webpack_require__(418);
var FactoryContainer = __webpack_require__(3);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame)
    {
        return this.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(419),
    renderWebGL: __webpack_require__(422)

};


/***/ }),
/* 422 */
/***/ (function(module, exports) {

var ImageWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = ImageWebGLRenderer;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

var Layer = __webpack_require__(120);
var FactoryContainer = __webpack_require__(3);

var LayerFactory = {

    KEY: 'layer',

    add: function (children)
    {
        return new Layer(this.state, children);
    },

    make: function (children)
    {
        return new Layer(this.state, children);
    }

};

module.exports = FactoryContainer.register(LayerFactory);


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var Mesh = __webpack_require__(50);
var GetAdvancedValue = __webpack_require__(14);
var GetValue = __webpack_require__(0);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);
    var vertices = GetValue(config, 'vertices', []);
    var indices = GetValue(config, 'indices', []);
    var colors = GetValue(config, 'colors', []);
    var alphas = GetValue(config, 'alphas', []);
    var uv = GetValue(config, 'uv', []);

    var mesh = new Mesh(state, 0, 0, vertices, uv, indices, colors, alphas, key, frame);

    BuildGameObject(state, mesh, config);

    return mesh;
};

module.exports = BuildFromConfig;


/***/ }),
/* 425 */
/***/ (function(module, exports) {

var MeshCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
};

module.exports = MeshCanvasRenderer;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {


var Mesh = __webpack_require__(50);
var BuildFromConfig = __webpack_require__(424);
var FactoryContainer = __webpack_require__(3);

var MeshFactory = {

    KEY: 'mesh',

    add: function (x, y, vertices, uv, key, frame)
    {
        return this.children.add(new Mesh(this.state, x, y, vertices, uv, key, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(MeshFactory);


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(425),
    renderWebGL: __webpack_require__(428)

};


/***/ }),
/* 428 */
/***/ (function(module, exports) {

var MeshWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    if (src.indices.length > 0)
        renderer.spriteBatch.addMeshIndexed(src, camera);
    else
        renderer.spriteBatch.addMesh(src, camera);
};

module.exports = MeshWebGLRenderer


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var Quad = __webpack_require__(68);
var GetAdvancedValue = __webpack_require__(14);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    var x = GetAdvancedValue(config, 'x', 0);
    var y = GetAdvancedValue(config, 'y', 0);
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var quad = new Quad(state, x, y, key, frame);

    BuildGameObject(state, quad, config);

    return quad;
};

module.exports = BuildFromConfig;


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {


var Quad = __webpack_require__(68);
var BuildFromConfig = __webpack_require__(429);
var FactoryContainer = __webpack_require__(3);

var QuadFactory = {

    KEY: 'quad',

    add: function (x, y, key, frame)
    {
        return this.children.add(new Quad(this.state, x, y, key, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(QuadFactory);


/***/ }),
/* 431 */
/***/ (function(module, exports) {

var RenderPassCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{

};

module.exports = RenderPassCanvasRenderer;
 

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

var RenderPass = __webpack_require__(121);
var FactoryContainer = __webpack_require__(3);

var RenderPassFactory = {

    KEY: 'renderPass',

    add: function (x, y, width, height, shaderName, fragmentShader)
    {
        return this.children.add(new RenderPass(this.state, x, y, width, height, shaderName, fragmentShader));
    },

    make: function (x, y, width, height, shaderName, fragmentShader)
    {
        return new RenderPass(this.state, x, y, width, height, shaderName, fragmentShader);
    }

};

module.exports = FactoryContainer.register(RenderPassFactory);


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(431),
    renderWebGL: __webpack_require__(434)

};


/***/ }),
/* 434 */
/***/ (function(module, exports) {

var RenderPassWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSpriteTexture(src, camera, src.renderTexture, src.width, src.height);
};

module.exports = RenderPassWebGLRenderer;
 

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

var Sprite = __webpack_require__(51);
var GetAdvancedValue = __webpack_require__(14);
var BuildGameObject = __webpack_require__(32);
var BuildGameObjectAnimation = __webpack_require__(389);

var BuildFromConfig = function (state, config)
{
    var key = GetAdvancedValue(config, 'key', null);
    var frame = GetAdvancedValue(config, 'frame', null);

    var sprite = new Sprite(state, 0, 0, key, frame);

    BuildGameObject(state, sprite, config);

    //  Sprite specific config options:

    BuildGameObjectAnimation(sprite, config);

    //  Physics, Input, etc to follow ...

    return sprite;
};

module.exports = BuildFromConfig;


/***/ }),
/* 436 */
/***/ (function(module, exports) {


var SpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = SpriteCanvasRenderer;


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {


var Sprite = __webpack_require__(51);
var BuildFromConfig = __webpack_require__(435);
var FactoryContainer = __webpack_require__(3);

var SpriteFactory = {

    KEY: 'sprite',

    /**
    * Create a new Sprite with specific position and sprite sheet key.
    *
    * At its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.
    * They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
    * events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
    *
    * @method Phaser.GameObject.Factory#sprite
    * @param {number} [x=0] - The x coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {number} [y=0] - The y coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Sprite} The newly created Sprite object.
    */
    add: function (x, y, key, frame)
    {
        return this.children.add(new Sprite(this.state, x, y, key, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(SpriteFactory);


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(436),
    renderWebGL: __webpack_require__(439)

};


/***/ }),
/* 439 */
/***/ (function(module, exports) {

var SpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = SpriteWebGLRenderer;


/***/ }),
/* 440 */
/***/ (function(module, exports) {


var GetTextSize = function (text, size, lines)
{
    var canvas = text.canvas;
    var context = text.context;
    var style = text.style;

    var lineWidths = [];
    var maxLineWidth = 0;
    var drawnLines = lines.length;
    
    if (style.maxLines > 0 && style.maxLines < lines.length)
    {
        drawnLines = style.maxLines;
    }

    style.syncFont(canvas, context);

    //  Text Width

    for (var i = 0; i < drawnLines; i++)
    {
        var lineWidth = style.strokeThickness;

        lineWidth += context.measureText(lines[i]).width;

        // Adjust for wrapped text
        if (style.wordWrap)
        {
            lineWidth -= context.measureText(' ').width;
        }

        lineWidths[i] = Math.ceil(lineWidth);
        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
    }

    //  Text Height

    var lineHeight = size.fontSize + style.strokeThickness;
    var height = lineHeight * drawnLines;
    var lineSpacing = text._lineSpacing || 0;

    if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight)
    {
        lineSpacing = -lineHeight;
    }

    //  Adjust for line spacing
    if (lineSpacing !== 0)
    {
        height += (lineSpacing > 0) ? lineSpacing * lines.length : lineSpacing * (lines.length - 1);
    }

    return {
        width: maxLineWidth,
        height: height,
        lines: drawnLines,
        lineWidths: lineWidths,
        lineSpacing: lineSpacing,
        lineHeight: lineHeight
    };
};

module.exports = GetTextSize;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(9);

/**
* Calculates the ascent, descent and fontSize of a given font style.
*
* @method Phaser.GameObject.Text#determineFontProperties
* @private
* @param {object} textStyle
*/
var MeasureText = function (textStyle, testString)
{
    if (testString === undefined) { testString = '|MÉqgy'; }

    /**
     * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
     */
    var canvas = CanvasPool.create(this);

    /**
     * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
     */
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var width = Math.ceil(context.measureText(testString).width * 1.2);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * 1.4 | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle.font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(testString, 0, baseline);

    var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height))
    {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;

        CanvasPool.remove(canvas);

        return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx += line;
        }
        else
        {
            break;
        }
    }

    output.ascent = baseline - i;

    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx -= line;
        }
        else
        {
            break;
        }
    }

    output.descent = (i - baseline);
    output.fontSize = output.ascent + output.descent;

    CanvasPool.remove(canvas);

    return output;
};

module.exports = MeasureText;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var Class = __webpack_require__(1);
var GetValue = __webpack_require__(0);
var GetAdvancedValue = __webpack_require__(14);
var MeasureText = __webpack_require__(441);

//  Key: [ Object Key, Default Value ]

var propertyMap = {
    font: [ 'font', '16px Courier' ],
    backgroundColor: [ 'backgroundColor', null ],
    fill: [ 'fill', '#fff' ],
    stroke: [ 'stroke', '#fff' ],
    strokeThickness: [ 'strokeThickness', 0 ],
    shadowOffsetX: [ 'shadow.offsetX', 0 ],
    shadowOffsetY: [ 'shadow.offsetY', 0 ],
    shadowColor: [ 'shadow.color', '#000' ],
    shadowBlur: [ 'shadow.blur', 0 ],
    shadowStroke: [ 'shadow.stroke', false ],
    shadowFill: [ 'shadow.fill', false ],
    align: [ 'align', 'left' ],
    maxLines: [ 'maxLines', 0 ],
    fixedWidth: [ 'fixedWidth', false ],
    fixedHeight: [ 'fixedHeight', false ],
    rtl: [ 'rtl', false ]
};

var TextStyle = new Class({

    initialize:

    function TextStyle (text, style)
    {
        this.parent = text;

        this.font;
        this.backgroundColor;
        this.fill;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;
        this.align;
        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.rtl;

        //  Set to defaults
        this.reset();

        if (style)
        {
            for (var key in propertyMap)
            {
                this[key] = GetAdvancedValue(style, propertyMap[key][0], this[key]);
            }
        }

        var metrics = GetValue(style, 'metrics', false);

        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
        //  Doing this is un-done if you then change the font of this TextStyle after creation
        if (metrics)
        {
            this.metrics = {
                ascent: GetValue(metrics, 'ascent', 0),
                descent: GetValue(metrics, 'descent', 0),
                fontSize: GetValue(metrics, 'fontSize', 0)
            };
        }
        else
        {
            this.metrics = MeasureText(this);
        }
    },

    reset: function ()
    {
        for (var key in propertyMap)
        {
            this[key] = propertyMap[key][1];
        }

        return this;
    },

    syncFont: function (canvas, context)
    {
        if (this.rtl)
        {
            canvas.dir = 'rtl';
        }

        context.font = this.font;
        context.textBaseline = 'alphabetic';

        context.fillStyle = this.fill;
        context.strokeStyle = this.stroke;

        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
    },

    syncShadow: function (context, enabled)
    {
        if (enabled)
        {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
        }
        else
        {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
        }
    },

    update: function (recalculateMetrics)
    {
        if (recalculateMetrics)
        {
            this.metrics = MeasureText(this);
        }

        return this.parent.updateText();
    },

    setStyle: function (style)
    {
        for (var key in propertyMap)
        {
            this[key] = GetAdvancedValue(style, propertyMap[key][0], this[key]);
        }

        return this.update(true);
    },

    setFont: function (font)
    {
        this.font = font;

        return this.update(true);
    },

    setFixedSize: function (width, height)
    {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width)
        {
            this.text.width = width;
        }

        if (height)
        {
            this.text.height = height;
        }

        return this.update(false);
    },

    setBackgroundColor: function (color)
    {
        this.backgroundColor = color;

        return this.update(false);
    },

    setFill: function (color)
    {
        this.fill = color;

        return this.update(false);
    },

    setStroke: function (color, thickness)
    {
        if (color === undefined)
        {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
        }
        else
        {
            if (thickness === undefined) { thickness = this.strokeThickness; }

            this.stroke = color;
            this.strokeThickness = thickness;
        }

        return this.update(true);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (color === undefined) { color = '#000'; }
        if (blur === undefined) { blur = 0; }
        if (shadowStroke === undefined) { shadowStroke = false; }
        if (shadowFill === undefined) { shadowFill = false; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = color;
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;

        return this.update(false);
    },

    setShadowOffset: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;

        return this.update(false);
    },

    setShadowColor: function (color)
    {
        if (color === undefined) { color = '#000'; }

        this.shadowColor = color;

        return this.update(false);
    },

    setShadowBlur: function (blur)
    {
        if (blur === undefined) { blur = 0; }

        this.shadowBlur = blur;

        return this.update(false);
    },

    setShadowStroke: function (enabled)
    {
        this.shadowStroke = enabled;

        return this.update(false);
    },

    setShadowFill: function (enabled)
    {
        this.shadowFill = enabled;

        return this.update(false);
    },

    setAlign: function (align)
    {
        if (align === undefined) { align = 'left'; }

        this.align = align;

        return this.update(false);
    },

    setMaxLines: function (max)
    {
        if (max === undefined) { max = 0; }

        this.maxLines = max;

        return this.update(false);
    },

    getTextMetrics: function ()
    {
        var metrics = this.metrics;

        return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
        };
    },

    toJSON: function ()
    {
        var output = {};

        for (var key in propertyMap)
        {
            output[key] = this[key];
        }

        output.metrics = this.getTextMetrics();

        return output;
    },

    destroy: function ()
    {
        this.parent = undefined;
    }

});

module.exports = TextStyle;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

var Text = __webpack_require__(69);
var GetAdvancedValue = __webpack_require__(14);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    // style Object = {
    //     font: [ 'font', '16px Courier' ],
    //     backgroundColor: [ 'backgroundColor', null ],
    //     fill: [ 'fill', '#fff' ],
    //     stroke: [ 'stroke', '#fff' ],
    //     strokeThickness: [ 'strokeThickness', 0 ],
    //     shadowOffsetX: [ 'shadow.offsetX', 0 ],
    //     shadowOffsetY: [ 'shadow.offsetY', 0 ],
    //     shadowColor: [ 'shadow.color', '#000' ],
    //     shadowBlur: [ 'shadow.blur', 0 ],
    //     shadowStroke: [ 'shadow.stroke', false ],
    //     shadowFill: [ 'shadow.fill', false ],
    //     align: [ 'align', 'left' ],
    //     maxLines: [ 'maxLines', 0 ],
    //     fixedWidth: [ 'fixedWidth', false ],
    //     fixedHeight: [ 'fixedHeight', false ],
    //     rtl: [ 'rtl', false ]
    // }

    var content = GetAdvancedValue(config, 'text', '');
    var style = GetAdvancedValue(config, 'style', null);

    var text = new Text(state, 0, 0, content, style);

    BuildGameObject(state, text, config);

    //  Text specific config options:

    text.autoRound = GetAdvancedValue(config, 'autoRound', true);
    text.resolution = GetAdvancedValue(config, 'resolution', 1);

    //  Padding
    //  Either: { padding: 2 } or { padding: { x: 2, y: 2 }}

    var padding = GetAdvancedValue(config, 'padding', null);

    if (typeof padding === 'number')
    {
        text.padding.x = padding;
        text.padding.y = padding;
    }
    else if (padding !== null)
    {
        text.padding.x = GetAdvancedValue(padding, 'x', 1);
        text.padding.y = GetAdvancedValue(padding, 'y', 1);
    }

    text.updateText();

    return text;
};

module.exports = BuildFromConfig;


/***/ }),
/* 444 */
/***/ (function(module, exports) {

var TextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    
    var ctx = renderer.currentContext;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    var canvas = src.canvas;

    ctx.save();
    ctx.translate(src.x - camera.scrollX * src.scrollFactorX, src.y - camera.scrollY * src.scrollFactorY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.translate(canvas.width * (src.flipX ? 1 : 0), canvas.height * (src.flipY ? 1 : 0));
    ctx.scale(src.flipX ? -1 : 1, src.flipY ? -1 : 1);
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, -src.displayOriginX, -src.displayOriginY, canvas.width, canvas.height);
    ctx.restore();
};

module.exports = TextCanvasRenderer;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {


var Text = __webpack_require__(69);
var BuildFromConfig = __webpack_require__(443);
var FactoryContainer = __webpack_require__(3);

var TextFactory = {

    KEY: 'text',

    add: function (x, y, text, style)
    {
        return this.children.add(new Text(this.state, x, y, text, style));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(TextFactory);


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(444),
    renderWebGL: __webpack_require__(447)

};


/***/ }),
/* 447 */
/***/ (function(module, exports) {

var TextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    
    if (src.dirty)
    {
        var w = src.canvas.width;
        var h = src.canvas.height;
        var resize = !(src.prevWidth < w || src.prevHeight < h);

        src.canvasTexture = renderer.uploadCanvasToGPU(src.canvas, src.canvasTexture, resize);
        src.prevWidth = w;
        src.prevHeight = h;
        src.dirty = false;
    }

    renderer.spriteBatch.addSpriteTexture(src, camera, src.canvasTexture, src.prevWidth, src.prevHeight);
};

module.exports = TextWebGLRenderer;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var Tilemap = __webpack_require__(70);
var GetValue = __webpack_require__(0);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    var mapData = GetValue(config, 'map.data', null);
    var mapWidth = GetValue(config, 'map.width', 1);
    var mapHeight = GetValue(config, 'map.height', 1);

    var x = GetValue(config, 'x', 0);
    var y = GetValue(config, 'y', 0);

    var tileWidth = GetValue(config, 'tile.width', 16);
    var tileHeight = GetValue(config, 'tile.height', 16);
    var tileTexture = GetValue(config, 'tile.texture', null);
    var tileFrame = GetValue(config, 'tile.frame', null);

    var map = new Tilemap(state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileTexture, tileFrame);

    BuildGameObject(state, map, config);

    return map;
};

module.exports = BuildFromConfig;


/***/ }),
/* 449 */
/***/ (function(module, exports) {

function Tile(properties)
{
    this.index = properties.index;
	this.id = properties.id;
	this.x =  properties.x;
	this.y = properties.y;
	this.width = properties.width;
	this.height = properties.height;
    this.frameX = properties.frameX;
    this.frameY = properties.frameY;
    this.frameWidth = properties.frameWidth;
	this.frameHeight = properties.frameHeight;
    this.alpha = 1.0;
	this.tint = 0xFFFFFF;
	this.visible = true;
    this.textureWidth = properties.textureWidth;
    this.textureHeight = properties.textureHeight;
}

Tile.prototype.setId = function (id)
{
    var tileId = this.id = id;
    var tileWidth = this.width;
    var tileHeight = this.height;
    var setWidth = this.textureWidth / tileWidth;
    var halfTileWidth = (tileWidth) * 0.5;
    var halfTileHeight = (tileHeight) * 0.5;
    var rectx = (((tileId % setWidth)|0) * tileWidth) + halfTileWidth;
    var recty = (((tileId / setWidth)|0) * tileHeight) + halfTileHeight;

    this.frameX = rectx;
    this.frameY = recty;

};

module.exports = Tile;


/***/ }),
/* 450 */
/***/ (function(module, exports) {

var TilemapCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
};

module.exports = TilemapCanvasRenderer;


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {


var Tilemap = __webpack_require__(70);
var BuildFromConfig = __webpack_require__(448);
var FactoryContainer = __webpack_require__(3);

var TilemapFactory = {

    KEY: 'tilemap',

    add: function (mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame)
    {
        return this.children.add(new Tilemap(this.state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(TilemapFactory);


/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(450),
    renderWebGL: __webpack_require__(453)

};


/***/ }),
/* 453 */
/***/ (function(module, exports) {

var TilemapWebGLRenderer = function (renderer, gameObject, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    this.cull(camera);

    var renderTiles = gameObject.culledTiles;
    var length = renderTiles.length;
    var batch = renderer.spriteBatch;
    var texture = gameObject.texture.source[0].glTexture;
    var textureWidth = texture.width;
    var textureHeight = texture.height;
    var renderTarget = gameObject.renderTarget;
    var scrollFactorX = gameObject.scrollFactorX;
    var scrollFactorY = gameObject.scrollFactorY;
    var alpha = gameObject.alpha;
    var x = gameObject.x;
    var y = gameObject.y;

    for (var index = 0; index < length; ++index)
    {
        var tile = renderTiles[index];
        batch.addTileTextureRect(
            texture,
            x + tile.x, y + tile.y, tile.width, tile.height, alpha * tile.alpha, tile.tint,
            scrollFactorX, scrollFactorY,
            textureWidth, textureHeight,
            tile.frameX, tile.frameY, tile.frameWidth, tile.frameHeight,
            camera,
            renderTarget
        );
    }
};

module.exports = TilemapWebGLRenderer;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

var StaticTilemap = __webpack_require__(71);
var GetValue = __webpack_require__(0);
var BuildGameObject = __webpack_require__(32);

var BuildFromConfig = function (state, config)
{
    var mapData = GetValue(config, 'map.data', null);
    var mapWidth = GetValue(config, 'map.width', 1);
    var mapHeight = GetValue(config, 'map.height', 1);

    var x = GetValue(config, 'x', 0);
    var y = GetValue(config, 'y', 0);

    var tileWidth = GetValue(config, 'tile.width', 16);
    var tileHeight = GetValue(config, 'tile.height', 16);
    var tileTexture = GetValue(config, 'tile.texture', null);
    var tileFrame = GetValue(config, 'tile.frame', null);

    var map = new StaticTilemap(state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, tileTexture, tileFrame);

    BuildGameObject(state, map, config);

    return map;
};

module.exports = BuildFromConfig;


/***/ }),
/* 455 */
/***/ (function(module, exports) {

var StaticTilemapCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
};

module.exports = StaticTilemapCanvasRenderer;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {


var StaticTilemap = __webpack_require__(71);
var BuildFromConfig = __webpack_require__(454);
var FactoryContainer = __webpack_require__(3);

var StaticTilemapFactory = {

    KEY: 'staticTilemap',

    add: function (mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame)
    {
        return this.children.add(new StaticTilemap(this.state, mapData, x, y, tileWidth, tileHeight, mapWidth, mapHeight, texture, frame));
    },

    make: function (config)
    {
        return BuildFromConfig(this.state, config);
    }

};

module.exports = FactoryContainer.register(StaticTilemapFactory);


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(455),
    renderWebGL: __webpack_require__(458)

};


/***/ }),
/* 458 */
/***/ (function(module, exports) {

var StaticTilemapWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var gameObject = src;
    var frame = gameObject.frame;
    var gl = gameObject.gl;

    renderer.setRenderer(gameObject.tilemapRenderer, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
    gameObject.tilemapRenderer.bind();
    gameObject.upload(camera);
    //gameObject.cull(camera);
    gameObject.vbo.bind();

    //var vertexCount = gameObject.cullEnd - gameObject.cullStart;
    //if (vertexCount > 0)
    //{
    //    gl.drawArrays(gl.TRIANGLES, gameObject.cullStart, vertexCount);
    //}
    gl.drawArrays(gl.TRIANGLES, 0, gameObject.vertexCount);
};

module.exports = StaticTilemapWebGLRenderer;


/***/ }),
/* 459 */
/***/ (function(module, exports) {


var TileSpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var ctx = renderer.currentContext;
    var frame = src.frame;

    //  Blend Mode

    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha

    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    var dx = frame.x - (src.originX * src.width);
    var dy = frame.y - (src.originY * src.height);

    ctx.save();
    ctx.translate(dx, dy);
    ctx.translate(src.x - camera.scrollX * src.scrollFactorX, src.y - camera.scrollY * src.scrollFactorY);
    ctx.fillStyle = src.canvasPattern;
    ctx.translate(-this.tilePositionX, -this.tilePositionY);
    ctx.fillRect(this.tilePositionX, this.tilePositionY, src.width, src.height);
    ctx.restore();
};

module.exports = TileSpriteCanvasRenderer;


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {


var TileSprite = __webpack_require__(122);
var FactoryContainer = __webpack_require__(3);

var TileSpriteFactory = {

    KEY: 'tileSprite',

    add: function (x, y, width, height, key, frame)
    {
        return this.children.add(new TileSprite(this.state, x, y, width, height, key, frame));
    },

    make: function (x, y, width, height, key, frame)
    {
        return new TileSprite(this.state, x, y, width, height, key, frame);
    }

};

module.exports = FactoryContainer.register(TileSpriteFactory);


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(459),
    renderWebGL: __webpack_require__(462)

};


/***/ }),
/* 462 */
/***/ (function(module, exports) {

var TileSpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    src.updateTileTexture();
    renderer.tileBatch.addTileSprite(src, camera);
};

module.exports = TileSpriteWebGLRenderer;


/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

var Zone = __webpack_require__(72);
var FactoryContainer = __webpack_require__(3);

var ZoneFactory = {

    KEY: 'zone',

    add: function (x, y, width, height)
    {
        return new Zone(this.state, x, y, width, height);
    },

    make: function (x, y, width, height)
    {
        return new Zone(this.state, x, y, width, height);
    }

};

module.exports = FactoryContainer.register(ZoneFactory);


/***/ }),
/* 464 */
/***/ (function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ }),
/* 465 */
/***/ (function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ }),
/* 466 */
/***/ (function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(123);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(52);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(52);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 470 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ }),
/* 471 */
/***/ (function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ }),
/* 473 */
/***/ (function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ }),
/* 474 */
/***/ (function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(123);

Circle.Area = __webpack_require__(464);
Circle.Circumference = __webpack_require__(465);
Circle.CircumferencePoint = __webpack_require__(466);
Circle.Clone = __webpack_require__(467);
Circle.Contains = __webpack_require__(52);
Circle.ContainsPoint = __webpack_require__(468);
Circle.ContainsRect = __webpack_require__(469);
Circle.CopyFrom = __webpack_require__(470);
Circle.Equals = __webpack_require__(471);
Circle.GetBounds = __webpack_require__(472);
Circle.Offset = __webpack_require__(473);
Circle.OffsetPoint = __webpack_require__(474);
Circle.Random = __webpack_require__(124);

module.exports = Circle;


/***/ }),
/* 476 */
/***/ (function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(125);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(73);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(73);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 480 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ }),
/* 481 */
/***/ (function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ }),
/* 483 */
/***/ (function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ }),
/* 484 */
/***/ (function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(125);

Ellipse.Area = __webpack_require__(476);
Ellipse.Clone = __webpack_require__(477);
Ellipse.Contains = __webpack_require__(73);
Ellipse.ContainsPoint = __webpack_require__(478);
Ellipse.ContainsRect = __webpack_require__(479);
Ellipse.CopyFrom = __webpack_require__(480);
Ellipse.Equals = __webpack_require__(481);
Ellipse.GetBounds = __webpack_require__(482);
Ellipse.Offset = __webpack_require__(483);
Ellipse.OffsetPoint = __webpack_require__(484);
Ellipse.Random = __webpack_require__(126);

module.exports = Ellipse;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(87);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ }),
/* 487 */
/***/ (function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);
var RectangleToRectangle = __webpack_require__(129);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ }),
/* 489 */
/***/ (function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(128);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(53);
var Contains = __webpack_require__(77);
var ContainsArray = __webpack_require__(79);
var Decompose = __webpack_require__(139);

var RectangleToTriangle = function (rect, triangle)
{
    //  First the cheapest ones:

    if (
        triangle.left > rect.right ||
        triangle.right < rect.left ||
        triangle.top > rect.bottom ||
        triangle.bottom < rect.top)
    {
        return false;
    }

    var triA = triangle.getLineA();
    var triB = triangle.getLineB();
    var triC = triangle.getLineC();

    //  Are any of the triangle points within the rectangle?

    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2))
    {
        return true;
    }

    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2))
    {
        return true;
    }

    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2))
    {
        return true;
    }

    //  Cheap tests over, now to see if any of the lines intersect ...

    var rectA = rect.getLineA();
    var rectB = rect.getLineB();
    var rectC = rect.getLineC();
    var rectD = rect.getLineD();

    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD))
    {
        return true;
    }

    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD))
    {
        return true;
    }

    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD))
    {
        return true;
    }

    //  None of the lines intersect, so are any rectangle points within the triangle?

    var points = Decompose(rect);
    var within = ContainsArray(triangle, points, true);

    return (within.length > 0);
};

module.exports = RectangleToTriangle;


/***/ }),
/* 492 */
/***/ (function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {


var LineToCircle = __webpack_require__(127);
var Contains = __webpack_require__(54);

var TriangleToCircle = function (triangle, circle)
{
     //  First the cheapest ones:

    if (
        triangle.left > circle.right ||
        triangle.right < circle.left ||
        triangle.top > circle.bottom ||
        triangle.bottom < circle.top)
    {
        return false;
    }

    if (Contains(triangle, circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineA(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineB(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineC(), circle))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToCircle;


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(53);
var Contains = __webpack_require__(54);

var TriangleToLine = function (triangle, line)
{
    //  If the Triangle contains either the start or end point of the line, it intersects
    if (Contains(triangle, line.getPointA()) || Contains(triangle, line.getPointB()))
    {
        return true;
    }

    //  Now check the line against each line of the Triangle
    if (LineToLine(triangle.getLineA(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineB(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineC(), line))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToLine;


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(53);
var ContainsArray = __webpack_require__(79);
var Decompose = __webpack_require__(144);

var TriangleToTriangle = function (triangleA, triangleB)
{
    //  First the cheapest ones:

    if (
        triangleA.left > triangleB.right ||
        triangleA.right < triangleB.left ||
        triangleA.top > triangleB.bottom ||
        triangleA.bottom < triangleB.top)
    {
        return false;
    }

    var lineAA = triangleA.getLineA();
    var lineAB = triangleA.getLineB();
    var lineAC = triangleA.getLineC();

    var lineBA = triangleB.getLineA();
    var lineBB = triangleB.getLineB();
    var lineBC = triangleB.getLineC();

    //  Now check the lines against each line of TriangleB
    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))
    {
        return true;
    }

    //  Nope, so check to see if any of the points of triangleA are within triangleB

    var points = Decompose(triangleA);
    var within = ContainsArray(triangleB, points, true);

    if (within.length > 0)
    {
        return true;
    }

    //  Finally check to see if any of the points of triangleB are within triangleA

    points = Decompose(triangleB);
    within = ContainsArray(triangleA, points, true);

    if (within.length > 0)
    {
        return true;
    }

    return false;
};

module.exports = TriangleToTriangle;


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Intersects

module.exports = {

    CircleToCircle: __webpack_require__(486),
    CircleToRectangle: __webpack_require__(487),
    GetRectangleIntersection: __webpack_require__(488),
    LineToCircle: __webpack_require__(127),
    LineToLine: __webpack_require__(53),
    LineToRectangle: __webpack_require__(489),
    PointToLine: __webpack_require__(128),
    PointToLineSegment: __webpack_require__(490),
    RectangleToRectangle: __webpack_require__(129),
    RectangleToTriangle: __webpack_require__(491),
    RectangleToValues: __webpack_require__(492),
    TriangleToCircle: __webpack_require__(493),
    TriangleToLine: __webpack_require__(494),
    TriangleToTriangle: __webpack_require__(495)

};


/***/ }),
/* 497 */
/***/ (function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

var Line = __webpack_require__(130);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ }),
/* 499 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Line.
* @method Phaser.Line#copyFrom
* @param {any} source - The object to copy from.
* @return {Line} This Line object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ }),
/* 500 */
/***/ (function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);
var Angle = __webpack_require__(36);
var Point = __webpack_require__(8);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ }),
/* 503 */
/***/ (function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ }),
/* 504 */
/***/ (function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);
var Angle = __webpack_require__(36);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);
var Angle = __webpack_require__(36);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ }),
/* 507 */
/***/ (function(module, exports) {

var Offset = function (line, x, y)
{
    line.x1 += x;
    line.y1 += y;

    line.x2 += x;
    line.y2 += y;

    return line;
};

module.exports = Offset;


/***/ }),
/* 508 */
/***/ (function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(36);
var NormalAngle = __webpack_require__(131);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(75);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(75);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ }),
/* 512 */
/***/ (function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ }),
/* 513 */
/***/ (function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ }),
/* 514 */
/***/ (function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(130);

Line.Angle = __webpack_require__(36);
Line.CenterOn = __webpack_require__(497);
Line.Clone = __webpack_require__(498);
Line.CopyFrom = __webpack_require__(499);
Line.Equals = __webpack_require__(500);
Line.GetMidPoint = __webpack_require__(501);
Line.GetNormal = __webpack_require__(502);
Line.GetPointsOnLine = __webpack_require__(74);
Line.Height = __webpack_require__(503);
Line.Length = __webpack_require__(504);
Line.NormalAngle = __webpack_require__(131);
Line.NormalX = __webpack_require__(505);
Line.NormalY = __webpack_require__(506);
Line.Offset = __webpack_require__(507);
Line.PerpSlope = __webpack_require__(508);
Line.Random = __webpack_require__(132);
Line.ReflectAngle = __webpack_require__(509);
Line.Rotate = __webpack_require__(510);
Line.RotateAroundPoint = __webpack_require__(511);
Line.RotateAroundXY = __webpack_require__(75);
Line.SetToAngle = __webpack_require__(512);
Line.Slope = __webpack_require__(513);
Line.Width = __webpack_require__(514);

module.exports = Line;


/***/ }),
/* 516 */
/***/ (function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ }),
/* 517 */
/***/ (function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ }),
/* 519 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ }),
/* 520 */
/***/ (function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ }),
/* 521 */
/***/ (function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ }),
/* 522 */
/***/ (function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ }),
/* 523 */
/***/ (function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ }),
/* 526 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(8);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ }),
/* 528 */
/***/ (function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ }),
/* 529 */
/***/ (function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(76);
var Point = __webpack_require__(8);
var GetMagnitudeSq = __webpack_require__(134);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(76);
var Point = __webpack_require__(8);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ }),
/* 532 */
/***/ (function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(136);
var Multiply = __webpack_require__(135);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ }),
/* 534 */
/***/ (function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(8);

Point.Add = __webpack_require__(516);
Point.Ceil = __webpack_require__(517);
Point.Clone = __webpack_require__(518);
Point.CopyFrom = __webpack_require__(519);
Point.Cross = __webpack_require__(520);
Point.Divide = __webpack_require__(521);
Point.Dot = __webpack_require__(76);
Point.Equals = __webpack_require__(522);
Point.Floor = __webpack_require__(523);
Point.GetCentroid = __webpack_require__(524);
Point.GetMagnitude = __webpack_require__(133);
Point.GetMagnitudeSq = __webpack_require__(134);
Point.Interpolate = __webpack_require__(525);
Point.Invert = __webpack_require__(526);
Point.Multiply = __webpack_require__(135);
Point.Negative = __webpack_require__(527);
Point.Normalize = __webpack_require__(136);
Point.NormalizeRightHand = __webpack_require__(528);
Point.Perp = __webpack_require__(529);
Point.Project = __webpack_require__(530);
Point.ProjectUnit = __webpack_require__(531);
Point.RPerp = __webpack_require__(532);
Point.SetMagnitude = __webpack_require__(533);
Point.Subtract = __webpack_require__(534);

module.exports = Point;


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(138);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(137);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//  2.1.1 (Mar 17, 2016)

/*
ISC License

Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
 */



module.exports = earcut;

/*
vertices is a flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...].
holes is an array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11).
dimensions is the number of coordinates per vertice in the input array (2 by default).
Each group of three vertice indices in the resulting array forms a triangle.
 */

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

/***/ }),
/* 539 */
/***/ (function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ }),
/* 540 */
/***/ (function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(138);

Polygon.Clone = __webpack_require__(536);
Polygon.Contains = __webpack_require__(137);
Polygon.ContainsPoint = __webpack_require__(537);
Polygon.GetAABB = __webpack_require__(539);
Polygon.GetNumberArray = __webpack_require__(540);

module.exports = Polygon;


/***/ }),
/* 542 */
/***/ (function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ }),
/* 543 */
/***/ (function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ }),
/* 544 */
/***/ (function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ }),
/* 545 */
/***/ (function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(77);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 548 */
/***/ (function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return (
        (rectB.x > rectA.x && rectB.x < rectA.right) &&
        (rectB.right > rectA.x && rectB.right < rectA.right) &&
        (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
    );
};

module.exports = ContainsRect;


/***/ }),
/* 549 */
/***/ (function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ }),
/* 550 */
/***/ (function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(78);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(78);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ }),
/* 553 */
/***/ (function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ }),
/* 554 */
/***/ (function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ }),
/* 555 */
/***/ (function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ }),
/* 556 */
/***/ (function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ }),
/* 557 */
/***/ (function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ }),
/* 558 */
/***/ (function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ }),
/* 559 */
/***/ (function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ }),
/* 560 */
/***/ (function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ }),
/* 561 */
/***/ (function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ }),
/* 562 */
/***/ (function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ }),
/* 563 */
/***/ (function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);

//  deg = degrees (0-360)

var PerimeterPoint = function (rect, deg, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var theta = deg * MATH_CONST.DEG_TO_RAD;

    while (theta < -Math.PI)
    {
        theta += MATH_CONST.PI2;
    }

    while (theta > Math.PI)
    {
        theta -= MATH_CONST.PI2;
    }

    var rectAtan = Math.atan2(rect.height, rect.width);
    var tanTheta = Math.tan(theta);
    var thetaBounds = Math.PI - rectAtan;
    var region;
    var xFactor = 1;
    var yFactor = 1;

    if (theta > -rectAtan && theta <= rectAtan)
    {
        region = 1;
        yFactor = -1;
    }
    else if (theta > rectAtan && theta <= thetaBounds)
    {
        region = 2;
        yFactor = -1;
    }
    else if (theta > thetaBounds || theta <= -thetaBounds)
    {
        region = 3;
        xFactor = -1;
    }
    else
    {
        region = 4;
        xFactor = -1;
    }

    out.x = rect.x + (rect.width / 2);
    out.y = rect.y + (rect.height / 2);

    if (region === 1 || region === 3)
    {
        out.x += xFactor * (rect.width / 2);                                     // "Z0"
        out.y += yFactor * (rect.width / 2) * tanTheta;
    }
    else
    {
        out.x += xFactor * (rect.height / (2 * tanTheta));                        // "Z1"
        out.y += yFactor * (rect.height / 2);
    }

    return out;
};

module.exports = PerimeterPoint;


/***/ }),
/* 565 */
/***/ (function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(27);

Rectangle.Area = __webpack_require__(542);
Rectangle.Ceil = __webpack_require__(543);
Rectangle.CeilAll = __webpack_require__(544);
Rectangle.CenterOn = __webpack_require__(545);
Rectangle.Clone = __webpack_require__(546);
Rectangle.Contains = __webpack_require__(77);
Rectangle.ContainsPoint = __webpack_require__(547);
Rectangle.ContainsRect = __webpack_require__(548);
Rectangle.CopyFrom = __webpack_require__(549);
Rectangle.Decompose = __webpack_require__(139);
Rectangle.Equals = __webpack_require__(550);
Rectangle.FitInside = __webpack_require__(551);
Rectangle.FitOutside = __webpack_require__(552);
Rectangle.Floor = __webpack_require__(553);
Rectangle.FloorAll = __webpack_require__(554);
Rectangle.GetAspectRatio = __webpack_require__(78);
Rectangle.GetCenter = __webpack_require__(555);
Rectangle.GetSize = __webpack_require__(556);
Rectangle.Inflate = __webpack_require__(557);
Rectangle.MarchingAnts = __webpack_require__(140);
Rectangle.MergePoints = __webpack_require__(558);
Rectangle.MergeRect = __webpack_require__(559);
Rectangle.MergeXY = __webpack_require__(560);
Rectangle.Offset = __webpack_require__(561);
Rectangle.OffsetPoint = __webpack_require__(562);
Rectangle.Overlaps = __webpack_require__(563);
Rectangle.Perimeter = __webpack_require__(141);
Rectangle.PerimeterPoint = __webpack_require__(564);
Rectangle.Random = __webpack_require__(142);
Rectangle.Scale = __webpack_require__(565);
Rectangle.Union = __webpack_require__(566);

module.exports = Rectangle;


/***/ }),
/* 568 */
/***/ (function(module, exports) {

// The 2D area of a triangle. The area value is always non-negative.

var Area = function (triangle)
{
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
};

module.exports = Area;


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(45);

// Builds an equilateral triangle.
// In the equilateral triangle, all the sides are the same length (congruent)
// and all the angles are the same size (congruent).

//  The x/y specifies the top-middle of the triangle (x1/y1) and length
//  is the length of each side

var BuildEquilateral = function (x, y, length)
{
    var height = length * (Math.sqrt(3) / 2);

    var x1 = x;
    var y1 = y;

    var x2 = x + (length / 2);
    var y2 = y + height;

    var x3 = x - (length / 2);
    var y3 = y + height;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildEquilateral;


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

var EarCut = __webpack_require__(538);
var Triangle = __webpack_require__(45);

var BuildFromPolygon = function (data, holes, scaleX, scaleY, out)
{
    if (holes === undefined) { holes = null; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }
    if (out === undefined) { out = []; }

    var tris = EarCut(data, holes);

    var a;
    var b;
    var c;

    var x1;
    var y1;

    var x2;
    var y2;

    var x3;
    var y3;

    for (var i = 0; i < tris.length; i += 3)
    {
        a = tris[i];
        b = tris[i + 1];
        c = tris[i + 2];

        x1 = data[a * 2] * scaleX;
        y1 = data[(a * 2) + 1] * scaleY;

        x2 = data[b * 2] * scaleX;
        y2 = data[(b * 2) + 1] * scaleY;

        x3 = data[c * 2] * scaleX;
        y3 = data[(c * 2) + 1] * scaleY;

        out.push(new Triangle(x1, y1, x2, y2, x3, y3));
    }

    return out;
};

module.exports = BuildFromPolygon;


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(45);

//  Builds a right triangle, with one 90 degree angle and two acute angles
//  The x/y is the coordinate of the 90 degree angle (and will map to x1/y1 in the resulting Triangle)
//  w/h can be positive or negative and represent the length of each side

var BuildRight = function (x, y, width, height)
{
    if (height === undefined) {  height = width; }

    //  90 degree angle
    var x1 = x;
    var y1 = y;

    var x2 = x;
    var y2 = y - height;

    var x3 = x + width;
    var y3 = y;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildRight;


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

var Centroid = __webpack_require__(143);
var Offset = __webpack_require__(146);

var CenterOn = function (triangle, x, y, centerFunc)
{
    if (centerFunc === undefined) { centerFunc = Centroid; }

    //  Get the center of the triangle
    var center = centerFunc(triangle);

    //  Difference
    var diffX = x - center.x;
    var diffY = y - center.y;

    return Offset(triangle, diffX, diffY);
};

module.exports = CenterOn;


/***/ }),
/* 573 */
/***/ (function(module, exports) {

//  Adapted from http://bjornharrtell.github.io/jsts/doc/api/jsts_geom_Triangle.js.html

/**
 * Computes the determinant of a 2x2 matrix. Uses standard double-precision
 * arithmetic, so is susceptible to round-off error.
 *
 * @param {Number}
 *          m00 the [0,0] entry of the matrix.
 * @param {Number}
 *          m01 the [0,1] entry of the matrix.
 * @param {Number}
 *          m10 the [1,0] entry of the matrix.
 * @param {Number}
 *          m11 the [1,1] entry of the matrix.
 * @return {Number} the determinant.
 */
function det (m00, m01, m10, m11)
{
    return (m00 * m11) - (m01 * m10);
}

/**
 * Computes the circumcentre of a triangle. The circumcentre is the centre of
 * the circumcircle, the smallest circle which encloses the triangle. It is also
 * the common intersection point of the perpendicular bisectors of the sides of
 * the triangle, and is the only point which has equal distance to all three
 * vertices of the triangle.
 * <p>
 * This method uses an algorithm due to J.R.Shewchuk which uses normalization to
 * the origin to improve the accuracy of computation. (See <i>Lecture Notes on
 * Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
 */
var CircumCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var cx = triangle.x3;
    var cy = triangle.y3;

    var ax = triangle.x1 - cx;
    var ay = triangle.y1 - cy;

    var bx = triangle.x2 - cx;
    var by = triangle.y2 - cy;

    var denom = 2 * det(ax, ay, bx, by);
    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);

    out.x = cx - numx / denom;
    out.y = cy + numy / denom;

    return out;
};

module.exports = CircumCenter;


/***/ }),
/* 574 */
/***/ (function(module, exports) {

//  Adapted from https://gist.github.com/mutoo/5617691

var CircumCircle = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0, radius: 0 }; }

    //  A
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    //  B
    var x2 = triangle.x2;
    var y2 = triangle.y2;

    //  C
    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var A = x2 - x1;
    var B = y2 - y1;
    var C = x3 - x1;
    var D = y3 - y1;
    var E = A * (x1 + x2) + B * (y1 + y2);
    var F = C * (x1 + x3) + D * (y1 + y3);
    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));

    var dx;
    var dy;

    //  If the points of the triangle are collinear, then just find the
    //  extremes and use the midpoint as the center of the circumcircle.

    if (Math.abs(G) < 0.000001)
    {
        var minX = Math.min(x1, x2, x3);
        var minY = Math.min(y1, y2, y3);
        dx = (Math.max(x1, x2, x3) - minX) * 0.5;
        dy = (Math.max(y1, y2, y3) - minY) * 0.5;

        out.x = minX + dx;
        out.y = minY + dy;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }
    else
    {
        out.x = (D * E - B * F) / G;
        out.y = (A * F - C * E) / G;
        dx = out.x - x1;
        dy = out.y - y1;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }

    return out;
};

module.exports = CircumCircle;


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(45);

var Clone = function (source)
{
    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = Clone;


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(54);

var ContainsPoint = function (triangle, point)
{
    return Contains(triangle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ }),
/* 577 */
/***/ (function(module, exports) {

/**
* Copies the x1, y1 - x3, y3 properties from any given object to this Triangle.
* @method Phaser.Line#copyFrom
* @param {any} source - The object to copy from.
* @return {Line} This Line object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = CopyFrom;


/***/ }),
/* 578 */
/***/ (function(module, exports) {

var Equals = function (triangle, toCompare)
{
    return (
        triangle.x1 === toCompare.x1 &&
        triangle.y1 === toCompare.y1 &&
        triangle.x2 === toCompare.x2 &&
        triangle.y2 === toCompare.y2 &&
        triangle.x3 === toCompare.x3 &&
        triangle.y3 === toCompare.y3
    );
};

module.exports = Equals;


/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(80);
var InCenter = __webpack_require__(145);

var Rotate = function (triangle, angle)
{
    var point = InCenter(triangle);

    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = Rotate;


/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(80);

var RotateAroundPoint = function (triangle, point, angle)
{
    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Geom.Triangle

var Triangle = __webpack_require__(45);

Triangle.Area = __webpack_require__(568);
Triangle.BuildEquilateral = __webpack_require__(569);
Triangle.BuildFromPolygon = __webpack_require__(570);
Triangle.BuildRight = __webpack_require__(571);
Triangle.CenterOn = __webpack_require__(572);
Triangle.Centroid = __webpack_require__(143);
Triangle.CircumCenter = __webpack_require__(573);
Triangle.CircumCircle = __webpack_require__(574);
Triangle.Clone = __webpack_require__(575);
Triangle.Contains = __webpack_require__(54);
Triangle.ContainsArray = __webpack_require__(79);
Triangle.ContainsPoint = __webpack_require__(576);
Triangle.CopyFrom = __webpack_require__(577);
Triangle.Decompose = __webpack_require__(144);
Triangle.Equals = __webpack_require__(578);
Triangle.InCenter = __webpack_require__(145);
Triangle.Offset = __webpack_require__(146);
Triangle.Random = __webpack_require__(147);
Triangle.Rotate = __webpack_require__(579);
Triangle.RotateAroundPoint = __webpack_require__(580);
Triangle.RotateAroundXY = __webpack_require__(80);

module.exports = Triangle;


/***/ }),
/* 582 */
/***/ (function(module, exports) {

/**
* Takes the average of the source and backdrop colors.
*
* @method Lazer.Color.blendAverage
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Average = function (a, b)
{
    return (a + b) / 2;
};

module.exports = Average;


/***/ }),
/* 583 */
/***/ (function(module, exports) {

/**
* Subtracts the darker of the two constituent colors from the lighter.
* 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendDifference
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ }),
/* 584 */
/***/ (function(module, exports) {

/**
* Produces an effect similar to that of the Difference mode, but lower in contrast. 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendExclusion
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Exclusion =  function (a, b)
{
    return a + b - 2 * a * b / 255;
};

module.exports = Exclusion;


/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

var Reflect = __webpack_require__(156);

/**
* Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.
*
* @method Lazer.Color.blendGlow
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Glow = function (a, b)
{
    return Reflect(b, a);
};

module.exports = Glow;


/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

var Overlay = __webpack_require__(155);

/**
* Multiplies or screens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; 
* this is useful for adding shadows to a scene. 
* 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop. 
*
* @method Lazer.Color.blendHardLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardLight = function (a, b)
{
    return Overlay(b, a);
};

module.exports = HardLight;


/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

var VividLight = __webpack_require__(158);

/**
* Runs blendVividLight on the source and backdrop colors.
* If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.
* Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.
* This changes all pixels to primary additive colors (red, green, or blue), white, or black.
*
* @method Lazer.Color.blendHardMix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardMix = function (a, b)
{
    return (VividLight(a, b) < 128) ? 0 : 255;
};

module.exports = HardMix;


/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

var LinearBurn = __webpack_require__(153);
var LinearDodge = __webpack_require__(154);

/**
* This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).
* Dodge applies to values of top layer lighter than middle gray, and burn to darker values.
* The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.
*
* @method Lazer.Color.blendLinearLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearLight = function (a, b)
{
    return (b < 128) ? LinearBurn(a, 2 * b) : LinearDodge(a, (2 * (b - 128)));
};

module.exports = LinearLight;


/***/ }),
/* 589 */
/***/ (function(module, exports) {

/**
* Multiplies the backdrop and source color values.
* The result color is always at least as dark as either of the two constituent
* colors. Multiplying any color with black produces black;
* multiplying with white leaves the original color unchanged.
*
* @method Lazer.Color.blendMultiply
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Multiply = function (a, b)
{
    return (a * b) / 255;
};

module.exports = Multiply;


/***/ }),
/* 590 */
/***/ (function(module, exports) {

/**
* Negation blend mode.
*
* @method Lazer.Color.blendNegation
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Negation = function (a, b)
{
    return 255 - Math.abs(255 - a - b);
};

module.exports = Negation;


/***/ }),
/* 591 */
/***/ (function(module, exports) {

/**
* Blends the source color, ignoring the backdrop.
*
* @method Lazer.Color.blendNormal
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Normal = function (a)
{
    return a;
};

module.exports = Normal;


/***/ }),
/* 592 */
/***/ (function(module, exports) {

/**
* Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.
*
* @method Lazer.Color.blendPhoenix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Phoenix = function (a, b)
{
    return Math.min(a, b) - Math.max(a, b) + 255;
};

module.exports = Phoenix;


/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

var Darken = __webpack_require__(151);
var Lighten = __webpack_require__(152);

/**
* If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.
* If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.
*
* @method Lazer.Color.blendPinLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var PinLight = function (a, b)
{
    return (b < 128) ? Darken(a, 2 * b) : Lighten(a, (2 * (b - 128)));
};

module.exports = PinLight;


/***/ }),
/* 594 */
/***/ (function(module, exports) {

/**
* Multiplies the complements of the backdrop and source color values, then complements the result.
* The result color is always at least as light as either of the two constituent colors. 
* Screening any color with white produces white; screening with black leaves the original color unchanged. 
*
* @method Lazer.Color.blendScreen
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Screen = function (a, b)
{
    return 255 - (((255 - a) * (255 - b)) >> 8);
};

module.exports = Screen;


/***/ }),
/* 595 */
/***/ (function(module, exports) {

/**
* Darkens or lightens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. 
* The effect is similar to shining a diffused spotlight on the backdrop. 
*
* @method Lazer.Color.blendSoftLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var SoftLight = function (a, b)
{
    return (b < 128) ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255);
};

module.exports = SoftLight;


/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics.BlendModes

module.exports = {

    Add: __webpack_require__(148),
    Average: __webpack_require__(582),
    ColorBurn: __webpack_require__(149),
    ColorDodge: __webpack_require__(150),
    Darken: __webpack_require__(151),
    Difference: __webpack_require__(583),
    Exclusion: __webpack_require__(584),
    Glow: __webpack_require__(585),
    HardLight: __webpack_require__(586),
    HardMix: __webpack_require__(587),
    Lighten: __webpack_require__(152),
    LinearBurn: __webpack_require__(153),
    LinearDodge: __webpack_require__(154),
    LinearLight: __webpack_require__(588),
    Multiply: __webpack_require__(589),
    Negation: __webpack_require__(590),
    Normal: __webpack_require__(591),
    Overlay: __webpack_require__(155),
    Phoenix: __webpack_require__(592),
    PinLight: __webpack_require__(593),
    Reflect: __webpack_require__(156),
    Screen: __webpack_require__(594),
    SoftLight: __webpack_require__(595),
    Subtract: __webpack_require__(157),
    VividLight: __webpack_require__(158)
    
};


/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(37);

var CSSMap = {
    aliceblue: [ 240, 248, 245 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [ 0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [ 0, 0, 0 ],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [ 0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 35 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0 ],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    darkblue: [ 0, 0, 139 ],
    darkcyan: [ 0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [ 0, 100, 0 ],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0 ],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0 ],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [ 0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [ 0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0 ],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    green: [ 0, 128, 0 ],
    greenyellow: [ 173, 255, 47 ],
    grey: [ 128, 128, 128 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0 ],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [ 0, 255, 0 ],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    maroon: [ 128, 0, 0 ],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [ 0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [ 0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [ 0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0 ],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0 ],
    orangered: [ 255, 69, 0 ],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    rebeccapurple: [ 102, 51, 153 ],
    red: [ 255, 0, 0 ],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 129 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [ 0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [ 0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0 ],
    yellowgreen: [ 154, 205, 50 ]
};

var CSSToColor = function (name)
{
    name = name.toLowerCase();

    var color = new Color();
    var entry = CSSMap[name];

    if (entry)
    {
        color.setTo(entry[0], entry[1], entry[2], 255);
    }

    return color;
};

module.exports = CSSToColor;


/***/ }),
/* 598 */
/***/ (function(module, exports) {

var ColorToRGBA = function (color)
{
    var output = {
        r: color >> 16 & 0xFF,
        g: color >> 8 & 0xFF,
        b: color & 0xFF,
        a: 255
    };

    if (color > 16777215)
    {
        output.a = color >>> 24;
    }

    return output;
};

module.exports = ColorToRGBA;


/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

var Color = __webpack_require__(37);
var HueToComponent = __webpack_require__(163);

var HSLToColor = function (h, s, l)
{
    // achromatic by default
    var r = l;
    var g = l;
    var b = l;

    if (s !== 0)
    {
        var q = (l < 0.5) ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = HueToComponent(p, q, h + 1 / 3);
        g = HueToComponent(p, q, h);
        b = HueToComponent(p, q, h - 1 / 3);
    }

    var color = new Color();

    return color.setGLTo(r, g, b, 1);
};

module.exports = HSLToColor;


/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

var HSVToRGB = __webpack_require__(161);

/**
* Get HSV color wheel values in an array which will be 360 elements in size.
*
* @method Phaser.Color.HSVColorWheel
* @static
* @param {number} [s=1] - The saturation, in the range 0 - 1.
* @param {number} [v=1] - The value, in the range 0 - 1.
* @return {array} An array containing 360 elements corresponding to the HSV color wheel.
*/
var HSVColorWheel = function (s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var colors = [];

    for (var c = 0; c <= 359; c++)
    {
        colors.push(HSVToRGB(c / 359, s, v));
    }

    return colors;
};

module.exports = HSVColorWheel;


/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(196);

var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    var t = index / length;

    return {
        r: Linear(r1, r2, t),
        g: Linear(g1, g2, t),
        b: Linear(b1, b2, t)
    };
};

var ColorWithColor = function (color1, color2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
};

var ColorWithRGB = function  (color, r, g, b, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
};


module.exports = {

    RGBWithRGB: RGBWithRGB,
    ColorWithRGB: ColorWithRGB,
    ColorWithColor: ColorWithColor

};


/***/ }),
/* 602 */
/***/ (function(module, exports) {

/**
* Converts an RGB color value to HSV (hue, saturation and value).
* Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
* Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.RGBtoHSV
* @static
* @param {number} r - The red color component, in the range 0 - 255.
* @param {number} g - The green color component, in the range 0 - 255.
* @param {number} b - The blue color component, in the range 0 - 255.
* @return {object} An object with the hue, saturation and value set in the h, s and v properties.
*/
var RGBToHSV = function (r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var d = max - min;

    // achromatic by default
    var h = 0;
    var s = (max === 0) ? 0 : d / max;
    var v = max;

    if (max !== min)
    {
        if (max === r)
        {
            h = (g - b) / d + ((g < b) ? 6 : 0);
        }
        else if (max === g)
        {
            h = (b - r) / d + 2;
        }
        else if (max === b)
        {
            h = (r - g) / d + 4;
        }

        h /= 6;
    }

    return { h: h, s: s, v: v };
};

module.exports = RGBToHSV;


/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

var ComponentToHex = __webpack_require__(159);

var RGBToString = function (r, g, b, a, prefix)
{
    if (a === undefined) { a = 255; }
    if (prefix === undefined) { prefix = '#'; }

    if (prefix === '#')
    {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    else
    {
        return '0x' + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    }
};

module.exports = RGBToString;


/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

var Between = __webpack_require__(85);

var RandomRGB = function (min, max)
{
    if (min === undefined) { min = 0; }
    if (max === undefined) { max = 255; }

    return {
        r: Between(min, max),
        g: Between(min, max),
        b: Between(min, max)
    };
};

module.exports = RandomRGB;


/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Graphics.Color

var Color = __webpack_require__(37);

Color.ColorToRGBA = __webpack_require__(598);
Color.ComponentToHex = __webpack_require__(159);
Color.CSSToColor = __webpack_require__(597);
Color.GetColor = __webpack_require__(81);
Color.GetColor32 = __webpack_require__(160);
Color.HexStringToColor = __webpack_require__(162);
Color.HSLToColor = __webpack_require__(599);
Color.HSVColorWheel = __webpack_require__(600);
Color.HSVToRGB = __webpack_require__(161);
Color.HueToComponent = __webpack_require__(163);
Color.IntegerToColor = __webpack_require__(164);
Color.IntegerToRGB = __webpack_require__(165);
Color.Interpolate = __webpack_require__(601);
Color.RandomRGB = __webpack_require__(604);
Color.RGBStringToColor = __webpack_require__(166);
Color.RGBToHSV = __webpack_require__(602);
Color.RGBToString = __webpack_require__(603);
Color.ValueToColor = __webpack_require__(167);

module.exports = Color;


/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

//  GlobalInputManager

var Keyboard = __webpack_require__(168);
var Mouse = __webpack_require__(172);
var MouseEvent = __webpack_require__(625);
var EventDispatcher = __webpack_require__(15);
var GetTransformedPoint = __webpack_require__(607);
var PointWithinGameObject = __webpack_require__(608);
var TransformMatrix = __webpack_require__(16);

var GlobalInputManager = function (game, gameConfig)
{
    this.game = game;

    this.gameConfig = gameConfig;

    this.enabled = true;

    this.events = new EventDispatcher();

    //   Standard FIFO queue
    this.queue = [];

    //  Listeners
    this.keyboard = new Keyboard(this);
    this.mouse = new Mouse(this);

    this._tempMatrix = new TransformMatrix();
    this._tempPoint = { x: 0, y: 0 };
};

GlobalInputManager.prototype.constructor = GlobalInputManager;

GlobalInputManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        this.keyboard.boot();
        this.mouse.boot();
    },

    update: function ()
    {
        this.keyboard.update();

        var len = this.queue.length;

        if (!this.enabled || len === 0)
        {
            return;
        }

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, len);

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < len; i++)
        {
            var event = queue[i];

            switch (event.type)
            {
                case 'mousemove':
                    this.events.dispatch(new MouseEvent.MOVE(event));
                    break;

                case 'mousedown':
                    this.events.dispatch(new MouseEvent.DOWN(event));
                    break;

                case 'mouseup':
                    this.events.dispatch(new MouseEvent.UP(event));
                    break;
            }
        }
    },

    getTransformedPoint: function (gameObject, x, y)
    {
        return GetTransformedPoint(this._tempMatrix, gameObject, x, y, this._tempPoint);
    },

    pointWithinGameObject: function (gameObject, x, y)
    {
        return PointWithinGameObject(gameObject, x, y);
    }

};

module.exports = GlobalInputManager;


/***/ }),
/* 607 */
/***/ (function(module, exports) {

/**
* This will return the local coordinates of the specified displayObject based on the given Pointer.
*
* @method Phaser.Input#getLocalPosition
* @param {Phaser.Sprite|Phaser.Image} gameObject - The DisplayObject to get the local coordinates for.
* @param {Phaser.Pointer} pointer - The Pointer to use in the check against the gameObject.
* @return {Phaser.Point} A point containing the coordinates of the Pointer position relative to the DisplayObject.
*/
var GetTransformedPoint = function (matrix, gameObject, x, y, output)
{
    if (output === undefined) { output = { x: 0, y: 0 }; }

    matrix.applyITRS(gameObject.x, gameObject.y, -gameObject.rotation, gameObject.scaleX, gameObject.scaleY);

    matrix.invert();

    return matrix.transformPoint(x, y, output);
};

module.exports = GetTransformedPoint;


/***/ }),
/* 608 */
/***/ (function(module, exports) {

//  x/y MUST be translated before being passed to this function, unless the gameObject is guarnateed to
//  be not rotated or scaled in any way

var PointWithinGameObject = function (gameObject, x, y)
{
    var width = gameObject.width;
    var height = gameObject.height;

    var x1 = -width * gameObject.originX;
    var y1 = -height * gameObject.originY;

    return (x >= x1 && x < (x1 + width) && y >= y1 && y < (y1 + height));
};

module.exports = PointWithinGameObject;


/***/ }),
/* 609 */
/***/ (function(module, exports) {

//  Return boolean (true if it reached the end of the combo, false if not)

var AdvanceKeyCombo = function (event, combo)
{
    combo.timeLastMatched = event.timeStamp;
    combo.index++;

    if (combo.index === combo.size)
    {
        return true;
    }
    else
    {
        combo.current = combo.keyCodes[combo.index];
        return false;
    }
};

module.exports = AdvanceKeyCombo;


/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyComboMatchEvent = function (keyCombo, keyboardEvent)
{
    Event.call(this, 'KEY_COMBO_MATCH_EVENT');

    this.target = keyCombo;

    this.data = keyboardEvent;
};

KeyComboMatchEvent.prototype = Object.create(Event.prototype);
KeyComboMatchEvent.prototype.constructor = KeyComboMatchEvent;

module.exports = KeyComboMatchEvent;


/***/ }),
/* 611 */
/***/ (function(module, exports) {

var ResetKeyCombo = function (combo)
{
    combo.current = combo.keyCodes[0];
    combo.index = 0;
    combo.timeLastMatched = 0;
    combo.matched = false;
    combo.timeMatched = 0;

    return combo;
};

module.exports = ResetKeyCombo;


/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyDownEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_DOWN_EVENT');

    this.data = keyboardEvent;
};

KeyDownEvent.prototype = Object.create(Event.prototype);
KeyDownEvent.prototype.constructor = KeyDownEvent;

module.exports = KeyDownEvent;


/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var KeyUpEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_UP_EVENT');

    this.data = keyboardEvent;
};

KeyUpEvent.prototype = Object.create(Event.prototype);
KeyUpEvent.prototype.constructor = KeyUpEvent;

module.exports = KeyUpEvent;


/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);
var KeyCodes = __webpack_require__(82);

var events = {
    KEY_DOWN_EVENT: __webpack_require__(612),
    KEY_UP_EVENT: __webpack_require__(613),
    _UP: [],
    _DOWN: []
};

function createKeyEvent (type)
{
    var KeyEvent = function (keyboardEvent)
    {
        Event.call(this, type);

        this.data = keyboardEvent;
    };

    KeyEvent.prototype = Object.create(Event.prototype);
    KeyEvent.prototype.constructor = KeyEvent;

    return KeyEvent;
}

//  Inject the KeyCode events

for (var code in KeyCodes)
{
    //  The Key Down Event Types

    var downType = 'KEY_DOWN_' + code;
    var upType = 'KEY_UP_' + code;

    events._DOWN[KeyCodes[code]] = createKeyEvent(downType);
    events._UP[KeyCodes[code]] = createKeyEvent(upType);

    //  More friendly aliases to the main events
    events[downType] = events._DOWN[KeyCodes[code]];
    events[upType] = events._UP[KeyCodes[code]];
}

module.exports = events;


/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Keyboard

module.exports = {

    KeyboardManager: __webpack_require__(168),

    Key: __webpack_require__(171),
    KeyCodes: __webpack_require__(82),

    KeyCombo: __webpack_require__(169),

    JustDown: __webpack_require__(617),
    JustUp: __webpack_require__(618),
    DownDuration: __webpack_require__(616),
    UpDuration: __webpack_require__(621)
    
};


/***/ }),
/* 616 */
/***/ (function(module, exports) {

/**
* Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
* or was pressed down longer ago than then given duration.
* 
* @method Phaser.Key#downDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just pressed. Given in ms.
* @return {boolean} True if the key was pressed down within the given duration.
*/
var DownDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isDown && key.duration < duration);
};

module.exports = DownDuration;


/***/ }),
/* 617 */
/***/ (function(module, exports) {

/**
* The justDown value allows you to test if this Key has just been pressed down or not.
* When you check this value it will return `true` if the Key is down, otherwise `false`.
* You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
* This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
* 
* @property {boolean} justDown
* @memberof Phaser.Key
* @default false
*/

var JustDown = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justDown;
        key._justDown = false;
    }

    return current;
};

module.exports = JustDown;


/***/ }),
/* 618 */
/***/ (function(module, exports) {

/**
* The justUp value allows you to test if this Key has just been released or not.
* When you check this value it will return `true` if the Key is up, otherwise `false`.
* You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
* This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
* 
* @property {boolean} justUp
* @memberof Phaser.Key
* @default false
*/

var JustUp = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justUp;
        key._justUp = false;
    }

    return current;
};

module.exports = JustUp;


/***/ }),
/* 619 */
/***/ (function(module, exports) {


var ProcessKeyDown = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.altKey = event.altKey;
    key.ctrlKey = event.ctrlKey;
    key.shiftKey = event.shiftKey;
    key.location = event.location;

    key.isDown = true;
    key.isUp = false;
    key.timeDown = event.timeStamp;
    key.duration = 0;
    key.repeats++;

    key._justDown = true;
    key._justUp = false;

    return key;
};

module.exports = ProcessKeyDown;


/***/ }),
/* 620 */
/***/ (function(module, exports) {


var ProcessKeyUp = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.isDown = false;
    key.isUp = true;
    key.timeUp = event.timeStamp;
    key.duration = key.timeUp - key.timeDown;
    key.repeats = 0;

    key._justDown = false;
    key._justUp = true;

    return key;
};

module.exports = ProcessKeyUp;


/***/ }),
/* 621 */
/***/ (function(module, exports) {

/**
* Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
* or was released longer ago than then given duration.
* 
* @method Phaser.Key#upDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just released. Given in ms.
* @return {boolean} True if the key was released within the given duration.
*/
var UpDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isUp && key.duration < duration);
};

module.exports = UpDuration;


/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var MouseDownEvent = function (nativeEvent)
{
    Event.call(this, 'MOUSE_DOWN_EVENT');

    this.data = nativeEvent;

    this.x = nativeEvent.clientX;
    this.y = nativeEvent.clientY;
};

MouseDownEvent.prototype = Object.create(Event.prototype);
MouseDownEvent.prototype.constructor = MouseDownEvent;

module.exports = MouseDownEvent;


/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var MouseMoveEvent = function (nativeEvent)
{
    Event.call(this, 'MOUSE_MOVE_EVENT');

    this.data = nativeEvent;

    this.x = nativeEvent.clientX;
    this.y = nativeEvent.clientY;
};

MouseMoveEvent.prototype = Object.create(Event.prototype);
MouseMoveEvent.prototype.constructor = MouseMoveEvent;

module.exports = MouseMoveEvent;


/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var MouseUpEvent = function (nativeEvent)
{
    Event.call(this, 'MOUSE_UP_EVENT');

    this.data = nativeEvent;

    this.x = nativeEvent.clientX;
    this.y = nativeEvent.clientY;
};

MouseUpEvent.prototype = Object.create(Event.prototype);
MouseUpEvent.prototype.constructor = MouseUpEvent;

module.exports = MouseUpEvent;


/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
    DOWN: __webpack_require__(622),
    UP: __webpack_require__(624),
    MOVE: __webpack_require__(623)
};


/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Input.Mouse

module.exports = {

    MouseManager: __webpack_require__(172) 
       
};


/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var Set = __webpack_require__(96);
var XHRSettings = __webpack_require__(83);
var Event = __webpack_require__(632);
var EventDispatcher = __webpack_require__(15);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log(this.state.settings.key, '- BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log(this.state.settings.key, '- Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.events.removeAll('LOADER_START_EVENT');
        this.events.removeAll('LOADER_COMPLETE_EVENT');

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ }),
/* 628 */
/***/ (function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(173);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

var Event = __webpack_require__(5);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(631),
    LOADER_COMPLETE_EVENT: __webpack_require__(630)

};


/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

var JSONFile = __webpack_require__(84);

var AnimationJSONFile = function (key, url, path, xhrSettings)
{
    var json = new JSONFile(key, url, path, xhrSettings);

    //  Override the File type
    json.type = 'animationJSON';

    return json;
};

module.exports = AnimationJSONFile;


/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(44);
var JSONFile = __webpack_require__(84);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(44);
var XMLFile = __webpack_require__(174);

var BitmapFontFile = function (key, textureURL, xmlURL, path, textureXhrSettings, xmlXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new XMLFile(key, xmlURL, path, xmlXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'bitmapfont';
    data.linkType = 'bitmapfont';

    return { texture: image, data: data };
};

module.exports = BitmapFontFile;


/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var HTMLFile = function (key, url, width, height, path, xhrSettings)
{
    if (width === undefined) { width = 512; }
    if (height === undefined) { height = 512; }
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.html\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.html';
    }
    else
    {
        url = path.concat(url);
    }

    var config = {
        width: width,
        height: height
    };

    File.call(this, 'html', key, url, 'text', xhrSettings, config);
};

HTMLFile.prototype = Object.create(File.prototype);
HTMLFile.prototype.constructor = HTMLFile;

HTMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    var w = this.config.width;
    var h = this.config.height;

    var data = [];

    data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + ' ' + h + '" xmlns="http://www.w3.org/2000/svg">');
    data.push('<foreignObject width="100%" height="100%">');
    data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
    data.push(this.xhrLoader.responseText);
    data.push('</body>');
    data.push('</foreignObject>');
    data.push('</svg>');

    var svg = [ data.join('\n') ];

    try
    {
        var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
    }
    catch (e)
    {
        _this.state = CONST.FILE_ERRORED;

        callback(_this);

        return;
    }

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(blob);
};

module.exports = HTMLFile;


/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var SVGFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.svg\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.svg';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'svg', key, url, 'text', xhrSettings);
};

SVGFile.prototype = Object.create(File.prototype);
SVGFile.prototype.constructor = SVGFile;

SVGFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    var svg = [ this.xhrLoader.responseText ];

    try
    {
        var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
    }
    catch (e)
    {
        _this.state = CONST.FILE_ERRORED;

        callback(_this);

        return;
    }

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;
    var retry = false;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        //  Safari 8 re-try
        if (!retry)
        {
            retry = true;

            var url = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));

            _this.data.src = URL.createObjectURL(url);
        }
        else
        {
            _this.state = CONST.FILE_ERRORED;

            callback(_this);
        }
    };

    this.data.src = URL.createObjectURL(blob);
};

module.exports = SVGFile;


/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(44);

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing

var SpriteSheet = function (key, url, config, path, xhrSettings)
{
    var image = new ImageFile(key, url, path, xhrSettings, config);

    //  Override the File type
    image.type = 'spritesheet';

    return image;
};

module.exports = SpriteSheet;


/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(10);
var File = __webpack_require__(28);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ }),
/* 642 */
/***/ (function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ }),
/* 643 */
/***/ (function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(11);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ }),
/* 645 */
/***/ (function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ }),
/* 646 */
/***/ (function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ }),
/* 647 */
/***/ (function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ }),
/* 648 */
/***/ (function(module, exports) {

//  distance - usually in pixels
//  time - how long should it take to cover the distance? In seconds
//  Returns the amount you will need to increment by each step to cover the distance in the time given
var GetSpeed = function (distance, time)
{
    return (distance / time) / 1000;
};

module.exports = GetSpeed;


/***/ }),
/* 649 */
/***/ (function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ }),
/* 650 */
/***/ (function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ }),
/* 651 */
/***/ (function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(11);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ }),
/* 653 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ }),
/* 654 */
/***/ (function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ }),
/* 655 */
/***/ (function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ }),
/* 656 */
/***/ (function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ }),
/* 657 */
/***/ (function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ }),
/* 658 */
/***/ (function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ }),
/* 659 */
/***/ (function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ }),
/* 660 */
/***/ (function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ }),
/* 661 */
/***/ (function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(182);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(11);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ }),
/* 664 */
/***/ (function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(658),
    BetweenY: __webpack_require__(661),
    BetweenPoints: __webpack_require__(659),
    BetweenPointsY: __webpack_require__(660),
    Reverse: __webpack_require__(662),
    RotateTo: __webpack_require__(663),
    ShortestBetween: __webpack_require__(664),
    Normalize: __webpack_require__(182),
    Wrap: __webpack_require__(183),
    WrapDegrees: __webpack_require__(184)

};


/***/ }),
/* 666 */
/***/ (function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ }),
/* 667 */
/***/ (function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(87),
    Power: __webpack_require__(666),
    Squared: __webpack_require__(667)

};


/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

var Back = __webpack_require__(185);
var Bounce = __webpack_require__(186);
var Circular = __webpack_require__(187);
var Cubic = __webpack_require__(188);
var Elastic = __webpack_require__(189);
var Expo = __webpack_require__(190);
var Linear = __webpack_require__(191);
var Quadratic = __webpack_require__(192);
var Quartic = __webpack_require__(193);
var Quintic = __webpack_require__(194);
var Sine = __webpack_require__(195);

//  EaseMap
module.exports = {

    Power0: Linear,
    Power1: Quadratic.Out,
    Power2: Cubic.Out,
    Power3: Quartic.Out,
    Power4: Quintic.Out,

    Linear: Linear,
    Quad: Quadratic.Out,
    Cubic: Cubic.Out,
    Quart: Quartic.Out,
    Quint: Quintic.Out,
    Sine: Sine.Out,
    Expo: Expo.Out,
    Circ: Circular.Out,
    Elastic: Elastic.Out,
    Back: Back.Out,
    Bounce: Bounce.Out,

    'Quad.easeIn': Quadratic.In,
    'Cubic.easeIn': Cubic.In,
    'Quart.easeIn': Quartic.In,
    'Quint.easeIn': Quintic.In,
    'Sine.easeIn': Sine.In,
    'Expo.easeIn': Expo.In,
    'Circ.easeIn': Circular.In,
    'Elastic.easeIn': Elastic.In,
    'Back.easeIn': Back.In,
    'Bounce.easeIn': Bounce.In,

    'Quad.easeOut': Quadratic.Out,
    'Cubic.easeOut': Cubic.Out,
    'Quart.easeOut': Quartic.Out,
    'Quint.easeOut': Quintic.Out,
    'Sine.easeOut': Sine.Out,
    'Expo.easeOut': Expo.Out,
    'Circ.easeOut': Circular.Out,
    'Elastic.easeOut': Elastic.Out,
    'Back.easeOut': Back.Out,
    'Bounce.easeOut': Bounce.Out,

    'Quad.easeInOut': Quadratic.InOut,
    'Cubic.easeInOut': Cubic.InOut,
    'Quart.easeInOut': Quartic.InOut,
    'Quint.easeInOut': Quintic.InOut,
    'Sine.easeInOut': Sine.InOut,
    'Expo.easeInOut': Expo.InOut,
    'Circ.easeInOut': Circular.InOut,
    'Elastic.easeInOut': Elastic.InOut,
    'Back.easeInOut': Back.InOut,
    'Bounce.easeInOut': Bounce.InOut

};


/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(185),
    Bounce: __webpack_require__(186),
    Circular: __webpack_require__(187),
    Cubic: __webpack_require__(188),
    Elastic: __webpack_require__(189),
    Expo: __webpack_require__(190),
    Linear: __webpack_require__(191),
    Quadratic: __webpack_require__(192),
    Quartic: __webpack_require__(193),
    Quintic: __webpack_require__(194),
    Sine: __webpack_require__(195)

};


/***/ }),
/* 671 */
/***/ (function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ }),
/* 672 */
/***/ (function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ }),
/* 673 */
/***/ (function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ }),
/* 674 */
/***/ (function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ }),
/* 675 */
/***/ (function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(671),
    Equal: __webpack_require__(672),
    Floor: __webpack_require__(673),
    GreaterThan: __webpack_require__(674),
    LessThan: __webpack_require__(675)

};


/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(175);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(176);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(677),
    CatmullRom: __webpack_require__(678),
    Linear: __webpack_require__(196)

};


/***/ }),
/* 680 */
/***/ (function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ }),
/* 681 */
/***/ (function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    GetNext: __webpack_require__(680),
    IsSize: __webpack_require__(197),
    IsValue: __webpack_require__(681)

};


/***/ }),
/* 683 */
/***/ (function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (seeds)
    {
        this.init(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    init: function (seeds)
    {
        if (typeof seeds === 'string')
        {
            this.state(seeds);
        }
        else
        {
            this.sow(seeds);
        }
    },

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ }),
/* 684 */
/***/ (function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ }),
/* 685 */
/***/ (function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ }),
/* 686 */
/***/ (function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(684),
    Floor: __webpack_require__(685),
    To: __webpack_require__(686)

};


/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(239);

var CONST = __webpack_require__(6);
var Extend = __webpack_require__(62);

//  This object is exported globally

var Phaser = {

    Actions: __webpack_require__(99),

    Create: __webpack_require__(232),

    DOM: __webpack_require__(233),

    Game: __webpack_require__(231),

    Event: __webpack_require__(5),
    EventDispatcher: __webpack_require__(15),

    Math: __webpack_require__(61),

    Components: __webpack_require__(4),

    Geom: __webpack_require__(235),

    Graphics: __webpack_require__(236),

    Input: __webpack_require__(237),

    GameObjects: __webpack_require__(234),

    State: __webpack_require__(100),

    Loader: {

        ImageFile: __webpack_require__(44)

    },

    Sound: __webpack_require__(240),

    Physics: __webpack_require__(238),

    Class: __webpack_require__(1),

    Utils: __webpack_require__(241)

};

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * "Documentation is like sex:  when it is good, it is very, very good;
 * and when it is bad, it is better than nothing."
 *  -- Dick Brandon
 */

/*
 * "Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function."
 *  -- John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)))

/***/ }),
/* 689 */
/***/ (function(module, exports) {

var H = 0.5;
var N = 1 / 3;
var M = 2 / 3;

//  Tile ID to Slope defs.
//  First 4 elements = line data, final = solid or non-solid behind the line
    
module.exports = {

    2: [ 0, 1, 1, 0, true ],
    3: [ 0, 1, 1, H, true ],
    4: [ 0, H, 1, 0, true ],
    5: [ 0, 1, 1, M, true ],
    6: [ 0, M, 1, N, true ],
    7: [ 0, N, 1, 0, true ],
    8: [ H, 1, 0, 0, true ],
    9: [ 1, 0, H, 1, true ],
    10: [ H, 1, 1, 0, true ],
    11: [ 0, 0, H, 1, true ],
    12: [ 0, 0, 1, 0, false ],
    13: [ 1, 1, 0, 0, true ],
    14: [ 1, H, 0, 0, true ],
    15: [ 1, 1, 0, H, true ],
    16: [ 1, N, 0, 0, true ],
    17: [ 1, M, 0, N, true ],
    18: [ 1, 1, 0, M, true ],
    19: [ 1, 1, H, 0, true ],
    20: [ H, 0, 0, 1, true ],
    21: [ 0, 1, H, 0, true ],
    22: [ H, 0, 1, 1, true ],
    23: [ 1, 1, 0, 1, false ],
    24: [ 0, 0, 1, 1, true ],
    25: [ 0, 0, 1, H, true ],
    26: [ 0, H, 1, 1, true ],
    27: [ 0, 0, 1, N, true ],
    28: [ 0, N, 1, M, true ],
    29: [ 0, M, 1, 1, true ],
    30: [ N, 1, 0, 0, true ],
    31: [ 1, 0, M, 1, true ],
    32: [ M, 1, 1, 0, true ],
    33: [ 0, 0, N, 1, true ],
    34: [ 1, 0, 1, 1, false ],
    35: [ 1, 0, 0, 1, true ],
    36: [ 1, H, 0, 1, true ],
    37: [ 1, 0, 0, H, true ],
    38: [ 1, M, 0, 1, true ],
    39: [ 1, N, 0, M, true ],
    40: [ 1, 0, 0, N, true ],
    41: [ M, 1, N, 0, true ],
    42: [ M, 0, N, 1, true ],
    43: [ N, 1, M, 0, true ],
    44: [ N, 0, M, 1, true ],
    45: [ 0, 1, 0, 0, false ],
    52: [ 1, 1, M, 0, true ],
    53: [ N, 0, 0, 1, true ],
    54: [ 0, 1, N, 0, true ],
    55: [ M, 0, 1, 1, true ]

};


/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(55);

var GetVelocity = function (delta, vel, accel, friction, max)
{
    if (accel)
    {
        return Clamp(vel + accel * delta, -max, max);
    }
    else if (friction)
    {
        var frictionDelta = friction * delta;
        
        if (vel - frictionDelta > 0)
        {
            return vel - frictionDelta;
        }
        else if (vel + frictionDelta < 0)
        {
            return vel + frictionDelta;
        }
        else
        {
            return 0;
        }
    }

    return Clamp(vel, -max, max);
};

module.exports = GetVelocity;


/***/ }),
/* 691 */
/***/ (function(module, exports) {


var SeperateX = function (world, left, right, weak)
{
    var nudge = left.pos.x + left.size.x - right.pos.x;
    
    // We have a weak entity, so just move this one
    if (weak)
    {
        var strong = (left === weak) ? right : left;

        weak.vel.x = -weak.vel.x * weak.bounciness + strong.vel.x;
        
        var resWeak = world.collisionMap.trace(weak.pos.x, weak.pos.y, weak === left ? -nudge : nudge, 0, weak.size.x, weak.size.y);

        weak.pos.x = resWeak.pos.x;
    }
    else
    {
        var v2 = (left.vel.x - right.vel.x) / 2;

        left.vel.x = -v2;
        right.vel.x = v2;
    
        var resLeft = world.collisionMap.trace(left.pos.x, left.pos.y, -nudge / 2, 0, left.size.x, left.size.y);

        left.pos.x = Math.floor(resLeft.pos.x);
        
        var resRight = world.collisionMap.trace(right.pos.x, right.pos.y, nudge / 2, 0, right.size.x, right.size.y);

        right.pos.x = Math.ceil(resRight.pos.x);
    }
};

module.exports = SeperateX;


/***/ }),
/* 692 */
/***/ (function(module, exports) {


var SeperateY = function (world, top, bottom, weak)
{
    var nudge = (top.pos.y + top.size.y - bottom.pos.y);
    var nudgeX;
    var resTop;
    
    if (weak)
    {
        var strong = (top === weak) ? bottom : top;

        weak.vel.y = -weak.vel.y * weak.bounciness + strong.vel.y;
        
        // Riding on a platform?
        nudgeX = 0;

        if (weak === top && Math.abs(weak.vel.y - strong.vel.y) < weak.minBounceVelocity)
        {
            weak.standing = true;
            nudgeX = strong.vel.x * world.delta;
        }
        
        var resWeak = world.collisionMap.trace(weak.pos.x, weak.pos.y, nudgeX, weak === top ? -nudge : nudge, weak.size.x, weak.size.y);

        weak.pos.y = resWeak.pos.y;
        weak.pos.x = resWeak.pos.x;
    }
    else if (world.gravity && (bottom.standing || top.vel.y > 0))
    {
        resTop = world.collisionMap.trace(top.pos.x, top.pos.y, 0, -(top.pos.y + top.size.y - bottom.pos.y), top.size.x, top.size.y);

        top.pos.y = resTop.pos.y;
        
        if (top.bounciness > 0 && top.vel.y > top.minBounceVelocity)
        {
            top.vel.y *= -top.bounciness;
        }
        else
        {
            top.standing = true;
            top.vel.y = 0;
        }
    }
    else
    {
        var v2 = (top.vel.y - bottom.vel.y) / 2;

        top.vel.y = -v2;
        bottom.vel.y = v2;
        
        nudgeX = bottom.vel.x * world.delta;

        resTop = world.collisionMap.trace(top.pos.x, top.pos.y, nudgeX, -nudge / 2, top.size.x, top.size.y);

        top.pos.y = resTop.pos.y;
        
        var resBottom = world.collisionMap.trace(bottom.pos.x, bottom.pos.y, 0, nudge / 2, bottom.size.x, bottom.size.y);

        bottom.pos.y = resBottom.pos.y;
    }
};

module.exports = SeperateY;


/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

var SeperateX = __webpack_require__(691);
var SeperateY = __webpack_require__(692);
var COLLIDES = __webpack_require__(57);

//  Impact Physics Solver

var Solver = function (world, bodyA, bodyB)
{
    var weak = null;

    if (bodyA.collides === COLLIDES.LITE || bodyB.collides === COLLIDES.FIXED)
    {
        weak = bodyA;
    }
    else if (bodyB.collides === COLLIDES.LITE || bodyA.collides === COLLIDES.FIXED)
    {
        weak = bodyB;
    }

    if (bodyA.last.x + bodyA.size.x > bodyB.last.x && bodyA.last.x < bodyB.last.x + bodyB.size.x)
    {
        if (bodyA.last.y < bodyB.last.y)
        {
            SeperateY(world, bodyA, bodyB, weak);
        }
        else
        {
            SeperateY(world, bodyB, bodyA, weak);
        }

        bodyA.collideWith(bodyB, 'y');
        bodyB.collideWith(bodyA, 'y');
    }
    else if (bodyA.last.y + bodyA.size.y > bodyB.last.y && bodyA.last.y < bodyB.last.y + bodyB.size.y)
    {
        if (bodyA.last.x < bodyB.last.x)
        {
            SeperateX(world, bodyA, bodyB, weak);
        }
        else
        {
            SeperateX(world, bodyB, bodyA, weak);
        }

        bodyA.collideWith(bodyB, 'x');
        bodyB.collideWith(bodyA, 'x');
    }
};

module.exports = Solver;


/***/ }),
/* 694 */
/***/ (function(module, exports) {

// Set up the trace-result
// var res = {
//     collision: {x: false, y: false, slope: false},
//     pos: {x: x, y: y},
//     tile: {x: 0, y: 0}
// };

var UpdateMotion = function (body, res)
{
    body.standing = false;

    //  Y
    if (res.collision.y)
    {
        if (body.bounciness > 0 && Math.abs(body.vel.y) > body.minBounceVelocity)
        {
            body.vel.y *= -body.bounciness;
        }
        else
        {
            if (body.vel.y > 0)
            {
                body.standing = true;
            }

            body.vel.y = 0;
        }
    }

    //  X
    if (res.collision.x)
    {
        if (body.bounciness > 0 && Math.abs(body.vel.x) > body.minBounceVelocity)
        {
            body.vel.x *= -body.bounciness;
        }
        else
        {
            body.vel.x = 0;
        }
    }

    //  SLOPE
    if (res.collision.slope)
    {
        var s = res.collision.slope;
       
        if (body.bounciness > 0)
        {
            var proj = body.vel.x * s.nx + body.vel.y * s.ny;

            body.vel.x = (body.vel.x - s.nx * proj * 2) * body.bounciness;
            body.vel.y = (body.vel.y - s.ny * proj * 2) * body.bounciness;
        }
        else
        {
            var lengthSquared = s.x * s.x + s.y * s.y;
            var dot = (body.vel.x * s.x + body.vel.y * s.y) / lengthSquared;
            
            body.vel.x = s.x * dot;
            body.vel.y = s.y * dot;
            
            var angle = Math.atan2(s.x, s.y);

            if (angle > body.slopeStanding.min && angle < body.slopeStanding.max)
            {
                body.standing = true;
            }
        }

        if (window.dumpit)
        {
            console.group('slope');
            console.log(s);
            console.log('pos', res.pos.x, res.pos.y);
            console.log('vel', body.vel.x, body.vel.y);
            console.groupEnd();
        }
    }

    // body.pos = res.pos;

    body.pos.x = res.pos.x;
    body.pos.y = res.pos.y;
};

module.exports = UpdateMotion;


/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact.World

var Class = __webpack_require__(1);
var Set = __webpack_require__(96);
var Body = __webpack_require__(198);
var Solver = __webpack_require__(693);
var CollisionMap = __webpack_require__(199);
var COLLIDES = __webpack_require__(57);
var TYPE = __webpack_require__(88);

var World = new Class({

    initialize:

    function World (gravity, cellSize)
    {
        if (gravity === undefined) { gravity = 0; }
        if (cellSize === undefined) { cellSize = 64; }

        this.bodies = new Set();

        this.gravity = gravity;

        //  Spatial hash cell dimensions
        this.cellSize = cellSize;

        this.collisionMap = new CollisionMap();

        this.delta = 0;
    },

    create: function (x, y, sizeX, sizeY)
    {
        var body = new Body(this, x, y, sizeX, sizeY);

        this.bodies.set(body);

        return body;
    },

    update: function (time, delta)
    {
        if (this.bodies.size === 0)
        {
            return;
        }

        //  Impact uses a divided delta value
        delta /= 1000;

        this.delta = delta;

        //  Update all bodies

        this.bodies.iterate(function (body) {

            if (body.enabled)
            {
                body.update(delta);
            }

        });

        //  Run collision against them all

        var hash = {};
        var size = this.cellSize;

        var bodies = this.bodies.entries;

        for (var i = 0; i < bodies.length; i++)
        {
            var body = bodies[i];

            if (body.skipHash())
            {
                continue;
            }
            else
            {
                this.checkHash(body, hash, size);
            }
        }
    },

    //  Check the body against the spatial hash
    checkHash: function (body, hash, size)
    {
        console.log('checkHash');

        var checked = {};
        var xmin = Math.floor(body.pos.x / size);
        var ymin = Math.floor(body.pos.y / size);
        var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;
        var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;

        for (var x = xmin; x < xmax; x++)
        {
            for (var y = ymin; y < ymax; y++)
            {
                if (!hash[x])
                {
                    hash[x] = {};
                    hash[x][y] = [ body ];
                }
                else if (!hash[x][y])
                {
                    hash[x][y] = [ body ];
                }
                else
                {
                    var cell = hash[x][y];

                    for (var c = 0; c < cell.length; c++)
                    {
                        if (body.touches(cell[c]) && !checked[cell[c].id])
                        {
                            checked[cell[c].id] = true;

                            this.checkBodies(body, cell[c]);
                        }
                    }

                    cell.push(body);
                }
            }
        }
    },

    checkBodies: function (bodyA, bodyB)
    {
        //  bitwise checks
        if (bodyA.checkAgainst & bodyB.type)
        {
            bodyA.check(bodyB);
        }
        
        if (bodyB.checkAgainst & bodyA.type)
        {
            bodyB.check(bodyA);
        }
        
        if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE)
        {
            console.log('solve');
            Solver(this, bodyA, bodyB);
        }
    }

});

module.exports = World;


/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Physics.Impact

//  An Impact.js compatible physics world, body and solver, for those who are used
//  to the Impact way of defining and controlling physics bodies. Also works with
//  the new Loader support for Weltmeister map data.
//
//  World updated to run off the Phaser main loop.
//  Body extended to support additional setter functions.
//
//  To create the map data you'll need Weltmeister, which comes with Impact
//  and can be purchased from http://impactjs.com
//
//  My thanks to Dominic Szablewski for his permission to support Impact in Phaser.

module.exports = {

    Body: __webpack_require__(198),
    COLLIDES: __webpack_require__(57),
    CollisionMap: __webpack_require__(199),
    TYPE: __webpack_require__(88),
    World: __webpack_require__(695)
  
};


/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/

var Query = {};

module.exports = Query;

var Vector = __webpack_require__(13);
var SAT = __webpack_require__(91);
var Bounds = __webpack_require__(12);
var Bodies = __webpack_require__(93);
var Vertices = __webpack_require__(31);

(function() {

    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */
    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
        rayWidth = rayWidth || 1e-100;

        var rayAngle = Vector.angle(startPoint, endPoint),
            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),
            rayX = (endPoint.x + startPoint.x) * 0.5,
            rayY = (endPoint.y + startPoint.y) * 0.5,
            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),
            collisions = [];

        for (var i = 0; i < bodies.length; i++) {
            var bodyA = bodies[i];
            
            if (Bounds.overlaps(bodyA.bounds, ray.bounds)) {
                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];

                    if (Bounds.overlaps(part.bounds, ray.bounds)) {
                        var collision = SAT.collides(part, ray);
                        if (collision.collided) {
                            collision.body = collision.bodyA = collision.bodyB = bodyA;
                            collisions.push(collision);
                            break;
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */
    Query.region = function(bodies, bounds, outside) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                overlaps = Bounds.overlaps(body.bounds, bounds);
            if ((overlaps && !outside) || (!overlaps && outside))
                result.push(body);
        }

        return result;
    };

    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */
    Query.point = function(bodies, point) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            
            if (Bounds.contains(body.bounds, point)) {
                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];

                    if (Bounds.contains(part.bounds, point)
                        && Vertices.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                    }
                }
            }
        }

        return result;
    };

})();


/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/

var MouseConstraint = {};

module.exports = MouseConstraint;

var Vertices = __webpack_require__(31);
var Sleeping = __webpack_require__(48);
var Mouse = __webpack_require__(92);
var Events = __webpack_require__(30);
var Detector = __webpack_require__(89);
var Constraint = __webpack_require__(47);
var Composite = __webpack_require__(29);
var Common = __webpack_require__(2);
var Bounds = __webpack_require__(12);

(function() {

    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */
    MouseConstraint.create = function(engine, options) {
        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);

        if (!mouse) {
            if (engine && engine.render && engine.render.canvas) {
                mouse = Mouse.create(engine.render.canvas);
            } else if (options && options.element) {
                mouse = Mouse.create(options.element);
            } else {
                mouse = Mouse.create();
                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');
            }
        }

        var constraint = Constraint.create({ 
            label: 'Mouse Constraint',
            pointA: mouse.position,
            pointB: { x: 0, y: 0 },
            length: 0.01, 
            stiffness: 0.1,
            angularStiffness: 1,
            render: {
                strokeStyle: '#90EE90',
                lineWidth: 3
            }
        });

        var defaults = {
            type: 'mouseConstraint',
            mouse: mouse,
            element: null,
            body: null,
            constraint: constraint,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            }
        };

        var mouseConstraint = Common.extend(defaults, options);

        Events.on(engine, 'beforeUpdate', function() {
            var allBodies = Composite.allBodies(engine.world);
            MouseConstraint.update(mouseConstraint, allBodies);
            _triggerEvents(mouseConstraint);
        });

        return mouseConstraint;
    };

    /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */
    MouseConstraint.update = function(mouseConstraint, bodies) {
        var mouse = mouseConstraint.mouse,
            constraint = mouseConstraint.constraint,
            body = mouseConstraint.body;

        if (mouse.button === 0) {
            if (!constraint.bodyB) {
                for (var i = 0; i < bodies.length; i++) {
                    body = bodies[i];
                    if (Bounds.contains(body.bounds, mouse.position) 
                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {
                            var part = body.parts[j];
                            if (Vertices.contains(part.vertices, mouse.position)) {
                                constraint.pointA = mouse.position;
                                constraint.bodyB = mouseConstraint.body = body;
                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };
                                constraint.angleB = body.angle;

                                Sleeping.set(body, false);
                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });

                                break;
                            }
                        }
                    }
                }
            } else {
                Sleeping.set(constraint.bodyB, false);
                constraint.pointA = mouse.position;
            }
        } else {
            constraint.bodyB = mouseConstraint.body = null;
            constraint.pointB = null;

            if (body)
                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });
        }
    };

    /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */
    var _triggerEvents = function(mouseConstraint) {
        var mouse = mouseConstraint.mouse,
            mouseEvents = mouse.sourceEvents;

        if (mouseEvents.mousemove)
            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });

        if (mouseEvents.mousedown)
            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });

        if (mouseEvents.mouseup)
            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });

        // reset the mouse state ready for the next step
        Mouse.clearSourceEvents(mouse);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when the mouse has moved (or a touch moves) during the last step
    *
    * @event mousemove
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is down (or a touch has started) during the last step
    *
    * @event mousedown
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is up (or a touch has ended) during the last step
    *
    * @event mouseup
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user starts dragging a body
    *
    * @event startdrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user ends dragging a body
    *
    * @event enddrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body that has stopped being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     *
     * @property mouse
     * @type mouse
     * @default mouse
     */

    /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     *
     * @property body
     * @type body
     * @default null
     */

    /**
     * The `Constraint` object that is used to move the body during interaction.
     *
     * @property constraint
     * @type constraint
     */

    /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter
     * @type object
     */

})();


/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/

var Matter = {};

module.exports = Matter;

var Plugin = __webpack_require__(206);
var Common = __webpack_require__(2);

(function() {

    /**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */
    Matter.name = 'matter-js';

    /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */
    Matter.version = '@@VERSION@@';

    /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */
    Matter.uses = [];

    /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */
    Matter.used = [];

    /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */
    Matter.use = function() {
        Plugin.use(Matter, Array.prototype.slice.call(arguments));
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Matter.before = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathBefore(Matter, path, func);
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Matter.after = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathAfter(Matter, path, func);
    };

})();


/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/

var Runner = {};

module.exports = Runner;

var Events = __webpack_require__(30);
var Engine = __webpack_require__(204);
var Common = __webpack_require__(2);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    if (!_requestAnimationFrame) {
        var _frameTimeout;

        _requestAnimationFrame = function(callback){ 
            _frameTimeout = setTimeout(function() { 
                callback(Common.now()); 
            }, 1000 / 60);
        };

        _cancelAnimationFrame = function() {
            clearTimeout(_frameTimeout);
        };
    }

    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */
    Runner.create = function(options) {
        var defaults = {
            fps: 60,
            correction: 1,
            deltaSampleSize: 60,
            counterTimestamp: 0,
            frameCounter: 0,
            deltaHistory: [],
            timePrev: null,
            timeScalePrev: 1,
            frameRequestId: null,
            isFixed: false,
            enabled: true
        };

        var runner = Common.extend(defaults, options);

        runner.delta = runner.delta || 1000 / runner.fps;
        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
        runner.fps = 1000 / runner.delta;

        return runner;
    };

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */
    Runner.run = function(runner, engine) {
        // create runner if engine is first argument
        if (typeof runner.positionIterations !== 'undefined') {
            engine = runner;
            runner = Runner.create();
        }

        (function render(time){
            runner.frameRequestId = _requestAnimationFrame(render);

            if (time && runner.enabled) {
                Runner.tick(runner, engine, time);
            }
        })();

        return runner;
    };

    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */
    Runner.tick = function(runner, engine, time) {
        var timing = engine.timing,
            correction = 1,
            delta;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(runner, 'beforeTick', event);
        Events.trigger(engine, 'beforeTick', event); // @deprecated

        if (runner.isFixed) {
            // fixed timestep
            delta = runner.delta;
        } else {
            // dynamic timestep based on wall clock between calls
            delta = (time - runner.timePrev) || runner.delta;
            runner.timePrev = time;

            // optimistically filter delta over a few frames, to improve stability
            runner.deltaHistory.push(delta);
            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
            delta = Math.min.apply(null, runner.deltaHistory);
            
            // limit delta
            delta = delta < runner.deltaMin ? runner.deltaMin : delta;
            delta = delta > runner.deltaMax ? runner.deltaMax : delta;

            // correction for delta
            correction = delta / runner.delta;

            // update engine timing object
            runner.delta = delta;
        }

        // time correction for time scaling
        if (runner.timeScalePrev !== 0)
            correction *= timing.timeScale / runner.timeScalePrev;

        if (timing.timeScale === 0)
            correction = 0;

        runner.timeScalePrev = timing.timeScale;
        runner.correction = correction;

        // fps counter
        runner.frameCounter += 1;
        if (time - runner.counterTimestamp >= 1000) {
            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
            runner.counterTimestamp = time;
            runner.frameCounter = 0;
        }

        Events.trigger(runner, 'tick', event);
        Events.trigger(engine, 'tick', event); // @deprecated

        // if world has been modified, clear the render scene graph
        if (engine.world.isModified 
            && engine.render
            && engine.render.controller
            && engine.render.controller.clear) {
            engine.render.controller.clear(engine.render); // @deprecated
        }

        // update
        Events.trigger(runner, 'beforeUpdate', event);
        Engine.update(engine, delta, correction);
        Events.trigger(runner, 'afterUpdate', event);

        // render
        // @deprecated
        if (engine.render && engine.render.controller) {
            Events.trigger(runner, 'beforeRender', event);
            Events.trigger(engine, 'beforeRender', event); // @deprecated

            engine.render.controller.world(engine.render);

            Events.trigger(runner, 'afterRender', event);
            Events.trigger(engine, 'afterRender', event); // @deprecated
        }

        Events.trigger(runner, 'afterTick', event);
        Events.trigger(engine, 'afterTick', event); // @deprecated
    };

    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */
    Runner.stop = function(runner) {
        _cancelAnimationFrame(runner.frameRequestId);
    };

    /**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */
    Runner.start = function(runner, engine) {
        Runner.run(runner, engine);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired at the start of a tick, before any updates to the engine or timing
    *
    * @event beforeTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine timing updated, but just before update
    *
    * @event tick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired at the end of a tick, after engine update and after rendering
    *
    * @event afterTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after update
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A flag that specifies whether the runner is running or not.
     *
     * @property enabled
     * @type boolean
     * @default true
     */

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     *
     * @property isFixed
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     *
     * @property delta
     * @type number
     * @default 1000 / 60
     */

})();


/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/

var Composites = {};

module.exports = Composites;

var Composite = __webpack_require__(29);
var Constraint = __webpack_require__(47);
var Common = __webpack_require__(2);
var Body = __webpack_require__(46);
var Bodies = __webpack_require__(93);

(function() {

    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        var stack = Composite.create({ label: 'Stack' }),
            x = xx,
            y = yy,
            lastBody,
            i = 0;

        for (var row = 0; row < rows; row++) {
            var maxHeight = 0;
            
            for (var column = 0; column < columns; column++) {
                var body = callback(x, y, column, row, lastBody, i);
                    
                if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,
                        bodyWidth = body.bounds.max.x - body.bounds.min.x; 

                    if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                    
                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });

                    x = body.bounds.max.x + columnGap;

                    Composite.addBody(stack, body);
                    
                    lastBody = body;
                    i += 1;
                } else {
                    x += columnGap;
                }
            }
            
            y += maxHeight + rowGap;
            x = xx;
        }

        return stack;
    };
    
    /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */
    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
        var bodies = composite.bodies;
        
        for (var i = 1; i < bodies.length; i++) {
            var bodyA = bodies[i - 1],
                bodyB = bodies[i],
                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,
                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, 
                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,
                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
        
            var defaults = {
                bodyA: bodyA,
                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                bodyB: bodyB,
                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
            };
            
            var constraint = Common.extend(defaults, options);
        
            Composite.addConstraint(composite, Constraint.create(constraint));
        }

        composite.label += ' Chain';
        
        return composite;
    };

    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */
    Composites.mesh = function(composite, columns, rows, crossBrace, options) {
        var bodies = composite.bodies,
            row,
            col,
            bodyA,
            bodyB,
            bodyC;
        
        for (row = 0; row < rows; row++) {
            for (col = 1; col < columns; col++) {
                bodyA = bodies[(col - 1) + (row * columns)];
                bodyB = bodies[col + (row * columns)];
                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));
            }

            if (row > 0) {
                for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + ((row - 1) * columns)];
                    bodyB = bodies[col + (row * columns)];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));

                    if (crossBrace && col > 0) {
                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }

                    if (crossBrace && col < columns - 1) {
                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }
                }
            }
        }

        composite.label += ' Mesh';
        
        return composite;
    };
    
    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
            var actualRows = Math.min(rows, Math.ceil(columns / 2)),
                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
            
            if (row > actualRows)
                return;
            
            // reverse row order
            row = actualRows - row;
            
            var start = row,
                end = columns - 1 - row;

            if (column < start || column > end)
                return;
            
            // retroactively fix the first body's position, since width was unknown
            if (i === 1) {
                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
            }

            var xOffset = lastBody ? column * lastBodyWidth : 0;
            
            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
        });
    };

    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */
    Composites.newtonsCradle = function(xx, yy, number, size, length) {
        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });

        for (var i = 0; i < number; i++) {
            var separation = 1.9,
                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, 
                            { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),
                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });

            Composite.addBody(newtonsCradle, circle);
            Composite.addConstraint(newtonsCradle, constraint);
        }

        return newtonsCradle;
    };
    
    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */
    Composites.car = function(xx, yy, width, height, wheelSize) {
        var group = Body.nextGroup(true),
            wheelBase = -20,
            wheelAOffset = -width * 0.5 + wheelBase,
            wheelBOffset = width * 0.5 - wheelBase,
            wheelYOffset = 0;
    
        var car = Composite.create({ label: 'Car' }),
            body = Bodies.trapezoid(xx, yy, width, height, 0.3, { 
                collisionFilter: {
                    group: group
                },
                friction: 0.01,
                chamfer: {
                    radius: 10
                }
            });
    
        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var axelA = Constraint.create({
            bodyA: body,
            pointA: { x: wheelAOffset, y: wheelYOffset },
            bodyB: wheelA,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
                        
        var axelB = Constraint.create({
            bodyA: body,
            pointA: { x: wheelBOffset, y: wheelYOffset },
            bodyB: wheelB,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
        
        Composite.addBody(car, body);
        Composite.addBody(car, wheelA);
        Composite.addBody(car, wheelB);
        Composite.addConstraint(car, axelA);
        Composite.addConstraint(car, axelB);

        return car;
    };

    /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */
    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
        constraintOptions = Common.extend({ stiffness: 0.4 }, constraintOptions);

        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
            return Bodies.circle(x, y, particleRadius, particleOptions);
        });

        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);

        softBody.label = 'Soft Body';

        return softBody;
    };

})();


/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/

var Svg = {};

module.exports = Svg;

var Bounds = __webpack_require__(12);

(function() {

    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */
    Svg.pathToVertices = function(path, sampleLength) {
        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
        var i, il, total, point, segment, segments, 
            segmentsQueue, lastSegment, 
            lastPoint, segmentIndex, points = [],
            lx, ly, length = 0, x = 0, y = 0;

        sampleLength = sampleLength || 15;

        var addPoint = function(px, py, pathSegType) {
            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;

            // when the last point doesn't equal the current point add the current point
            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                } else {
                    lx = 0;
                    ly = 0;
                }

                var point = {
                    x: lx + px,
                    y: ly + py
                };

                // set last point
                if (isRelative || !lastPoint) {
                    lastPoint = point;
                }

                points.push(point);

                x = lx + px;
                y = ly + py;
            }
        };

        var addSegmentPoint = function(segment) {
            var segType = segment.pathSegTypeAsLetter.toUpperCase();

            // skip path ends
            if (segType === 'Z') 
                return;

            // map segment to x and y
            switch (segType) {

            case 'M':
            case 'L':
            case 'T':
            case 'C':
            case 'S':
            case 'Q':
                x = segment.x;
                y = segment.y;
                break;
            case 'H':
                x = segment.x;
                break;
            case 'V':
                y = segment.y;
                break;
            }

            addPoint(x, y, segment.pathSegType);
        };

        // ensure path is absolute
        _svgPathToAbsolute(path);

        // get total length
        total = path.getTotalLength();

        // queue segments
        segments = [];
        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
            segments.push(path.pathSegList.getItem(i));

        segmentsQueue = segments.concat();

        // sample through path
        while (length < total) {
            // get segment at position
            segmentIndex = path.getPathSegAtLength(length);
            segment = segments[segmentIndex];

            // new segment
            if (segment != lastSegment) {
                while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());

                lastSegment = segment;
            }

            // add points in between when curving
            // TODO: adaptive sampling
            switch (segment.pathSegTypeAsLetter.toUpperCase()) {

            case 'C':
            case 'T':
            case 'S':
            case 'Q':
            case 'A':
                point = path.getPointAtLength(length);
                addPoint(point.x, point.y, 0);
                break;

            }

            // increment by sample value
            length += sampleLength;
        }

        // add remaining segments not passed by sampling
        for (i = 0, il = segmentsQueue.length; i < il; ++i)
            addSegmentPoint(segmentsQueue[i]);

        return points;
    };

    var _svgPathToAbsolute = function(path) {
        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,
            x = 0, y = 0, len = segs.numberOfItems;

        for (var i = 0; i < len; ++i) {
            var seg = segs.getItem(i),
                segType = seg.pathSegTypeAsLetter;

            if (/[MLHVCSQTA]/.test(segType)) {
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
            } else {
                if ('x1' in seg) x1 = x + seg.x1;
                if ('x2' in seg) x2 = x + seg.x2;
                if ('y1' in seg) y1 = y + seg.y1;
                if ('y2' in seg) y2 = y + seg.y2;
                if ('x' in seg) x += seg.x;
                if ('y' in seg) y += seg.y;

                switch (segType) {

                case 'm':
                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                    break;
                case 'l':
                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                    break;
                case 'h':
                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                    break;
                case 'v':
                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                    break;
                case 'c':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                    break;
                case 's':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                    break;
                case 'q':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                    break;
                case 't':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                    break;
                case 'a':
                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                    break;
                case 'z':
                case 'Z':
                    x = x0;
                    y = y0;
                    break;

                }
            }

            if (segType == 'M' || segType == 'm') {
                x0 = x;
                y0 = y;
            }
        }
    };

})();

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

var Matter = module.exports = __webpack_require__(699);

Matter.Body = __webpack_require__(46);
Matter.Composite = __webpack_require__(29);
Matter.World = __webpack_require__(200);

Matter.Contact = __webpack_require__(201);
Matter.Detector = __webpack_require__(89);
Matter.Grid = __webpack_require__(90);
Matter.Pairs = __webpack_require__(202);
Matter.Pair = __webpack_require__(58);
Matter.Query = __webpack_require__(697);
Matter.Resolver = __webpack_require__(203);
Matter.SAT = __webpack_require__(91);

Matter.Constraint = __webpack_require__(47);
Matter.MouseConstraint = __webpack_require__(698);

Matter.Common = __webpack_require__(2);
Matter.Engine = __webpack_require__(204);
Matter.Events = __webpack_require__(30);
Matter.Mouse = __webpack_require__(92);
Matter.Runner = __webpack_require__(700);
Matter.Sleeping = __webpack_require__(48);
Matter.Plugin = __webpack_require__(206);

// @if DEBUG
Matter.Metrics = __webpack_require__(205);
// @endif

Matter.Bodies = __webpack_require__(93);
Matter.Composites = __webpack_require__(701);

Matter.Axes = __webpack_require__(94);
Matter.Bounds = __webpack_require__(12);
Matter.Svg = __webpack_require__(702);
Matter.Vector = __webpack_require__(13);
Matter.Vertices = __webpack_require__(31);

Matter.Render = __webpack_require__(95);
Matter.RenderPixi = __webpack_require__(704);

// aliases

Matter.World.add = Matter.Composite.add;
Matter.World.remove = Matter.Composite.remove;
Matter.World.addComposite = Matter.Composite.addComposite;
Matter.World.addBody = Matter.Composite.addBody;
Matter.World.addConstraint = Matter.Composite.addConstraint;
Matter.World.clear = Matter.Composite.clear;
Matter.Engine.run = Matter.Runner.run;


/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

/**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/

var RenderPixi = {};

module.exports = RenderPixi;

var Bounds = __webpack_require__(12);
var Composite = __webpack_require__(29);
var Common = __webpack_require__(2);
var Events = __webpack_require__(30);
var Vector = __webpack_require__(13);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }
    
    /**
     * Creates a new Pixi.js WebGL renderer
     * @method create
     * @param {object} options
     * @return {RenderPixi} A new renderer
     * @deprecated
     */
    RenderPixi.create = function(options) {
        Common.warn('RenderPixi.create: Matter.RenderPixi is deprecated (see docs)');

        var defaults = {
            controller: RenderPixi,
            engine: null,
            element: null,
            frameRequestId: null,
            canvas: null,
            renderer: null,
            container: null,
            spriteContainer: null,
            pixiOptions: null,
            options: {
                width: 800,
                height: 600,
                background: '#fafafa',
                wireframeBackground: '#222',
                hasBounds: false,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false
            }
        };

        var render = Common.extend(defaults, options),
            transparent = !render.options.wireframes && render.options.background === 'transparent';

        // init pixi
        render.pixiOptions = render.pixiOptions || {
            view: render.canvas,
            transparent: transparent,
            antialias: true,
            backgroundColor: options.background
        };

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
        render.container = render.container || new PIXI.Container();
        render.spriteContainer = render.spriteContainer || new PIXI.Container();
        render.canvas = render.canvas || render.renderer.view;
        render.bounds = render.bounds || { 
            min: {
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.options.width,
                y: render.options.height
            }
        };

        // event listeners
        Events.on(render.engine, 'beforeUpdate', function() {
            RenderPixi.clear(render);
        });

        // caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // use a sprite batch for performance
        render.container.addChild(render.spriteContainer);

        // insert canvas
        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
        }

        // prevent menus on canvas
        render.canvas.oncontextmenu = function() { return false; };
        render.canvas.onselectstart = function() { return false; };

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     * @deprecated
     */
    RenderPixi.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            RenderPixi.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     * @deprecated
     */
    RenderPixi.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Clears the scene graph
     * @method clear
     * @param {RenderPixi} render
     * @deprecated
     */
    RenderPixi.clear = function(render) {
        var container = render.container,
            spriteContainer = render.spriteContainer;

        // clear stage container
        while (container.children[0]) { 
            container.removeChild(container.children[0]); 
        }

        // clear sprite batch
        while (spriteContainer.children[0]) { 
            spriteContainer.removeChild(spriteContainer.children[0]); 
        }

        var bgSprite = render.sprites['bg-0'];

        // clear caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // set background sprite
        render.sprites['bg-0'] = bgSprite;
        if (bgSprite)
            container.addChildAt(bgSprite, 0);

        // add sprite batch back into container
        render.container.addChild(render.spriteContainer);

        // reset background state
        render.currentBackground = null;

        // reset bounds transforms
        container.scale.set(1, 1);
        container.position.set(0, 0);
    };

    /**
     * Sets the background of the canvas 
     * @method setBackground
     * @param {RenderPixi} render
     * @param {string} background
     * @deprecated
     */
    RenderPixi.setBackground = function(render, background) {
        if (render.currentBackground !== background) {
            var isColor = background.indexOf && background.indexOf('#') !== -1,
                bgSprite = render.sprites['bg-0'];

            if (isColor) {
                // if solid background color
                var color = Common.colorToNumber(background);
                render.renderer.backgroundColor = color;

                // remove background sprite if existing
                if (bgSprite)
                    render.container.removeChild(bgSprite); 
            } else {
                // initialise background sprite if needed
                if (!bgSprite) {
                    var texture = _getTexture(render, background);

                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);
                    bgSprite.position.x = 0;
                    bgSprite.position.y = 0;
                    render.container.addChildAt(bgSprite, 0);
                }
            }

            render.currentBackground = background;
        }
    };

    /**
     * Description
     * @method world
     * @param {engine} engine
     * @deprecated
     */
    RenderPixi.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            renderer = render.renderer,
            container = render.container,
            options = render.options,
            bodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            constraints = [],
            i;

        if (options.wireframes) {
            RenderPixi.setBackground(render, options.wireframeBackground);
        } else {
            RenderPixi.setBackground(render, options.background);
        }

        // handle bounds
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        if (options.hasBounds) {
            // Hide bodies that are not in view
            for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
        } else {
            constraints = allConstraints;
        }

        for (i = 0; i < bodies.length; i++)
            RenderPixi.body(render, bodies[i]);

        for (i = 0; i < constraints.length; i++)
            RenderPixi.constraint(render, constraints[i]);

        renderer.render(container);
    };


    /**
     * Description
     * @method constraint
     * @param {engine} engine
     * @param {constraint} constraint
     * @deprecated
     */
    RenderPixi.constraint = function(render, constraint) {
        var engine = render.engine,
            bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB,
            container = render.container,
            constraintRender = constraint.render,
            primitiveId = 'c-' + constraint.id,
            primitive = render.primitives[primitiveId];

        // initialise constraint primitive if not existing
        if (!primitive)
            primitive = render.primitives[primitiveId] = new PIXI.Graphics();

        // don't render if constraint does not have two end points
        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
            primitive.clear();
            return;
        }

        // add to scene graph if not already there
        if (Common.indexOf(container.children, primitive) === -1)
            container.addChild(primitive);

        // render the constraint on every update, since they can change dynamically
        primitive.clear();
        primitive.beginFill(0, 0);
        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
        
        if (bodyA) {
            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
        } else {
            primitive.moveTo(pointA.x, pointA.y);
        }

        if (bodyB) {
            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
        } else {
            primitive.lineTo(pointB.x, pointB.y);
        }

        primitive.endFill();
    };
    
    /**
     * Description
     * @method body
     * @param {engine} engine
     * @param {body} body
     * @deprecated
     */
    RenderPixi.body = function(render, body) {
        var engine = render.engine,
            bodyRender = body.render;

        if (!bodyRender.visible)
            return;

        if (bodyRender.sprite && bodyRender.sprite.texture) {
            var spriteId = 'b-' + body.id,
                sprite = render.sprites[spriteId],
                spriteContainer = render.spriteContainer;

            // initialise body sprite if not existing
            if (!sprite)
                sprite = render.sprites[spriteId] = _createBodySprite(render, body);

            // add to scene graph if not already there
            if (Common.indexOf(spriteContainer.children, sprite) === -1)
                spriteContainer.addChild(sprite);

            // update body sprite
            sprite.position.x = body.position.x;
            sprite.position.y = body.position.y;
            sprite.rotation = body.angle;
            sprite.scale.x = bodyRender.sprite.xScale || 1;
            sprite.scale.y = bodyRender.sprite.yScale || 1;
        } else {
            var primitiveId = 'b-' + body.id,
                primitive = render.primitives[primitiveId],
                container = render.container;

            // initialise body primitive if not existing
            if (!primitive) {
                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                primitive.initialAngle = body.angle;
            }

            // add to scene graph if not already there
            if (Common.indexOf(container.children, primitive) === -1)
                container.addChild(primitive);

            // update body primitive
            primitive.position.x = body.position.x;
            primitive.position.y = body.position.y;
            primitive.rotation = body.angle - primitive.initialAngle;
        }
    };

    /**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */
    var _createBodySprite = function(render, body) {
        var bodyRender = body.render,
            texturePath = bodyRender.sprite.texture,
            texture = _getTexture(render, texturePath),
            sprite = new PIXI.Sprite(texture);

        sprite.anchor.x = body.render.sprite.xOffset;
        sprite.anchor.y = body.render.sprite.yOffset;

        return sprite;
    };

    /**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */
    var _createBodyPrimitive = function(render, body) {
        var bodyRender = body.render,
            options = render.options,
            primitive = new PIXI.Graphics(),
            fillStyle = Common.colorToNumber(bodyRender.fillStyle),
            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleWireframe = Common.colorToNumber('#bbb'),
            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),
            part;

        primitive.clear();

        // handle compound parts
        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
            part = body.parts[k];

            if (!options.wireframes) {
                primitive.beginFill(fillStyle, 1);
                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
            } else {
                primitive.beginFill(0, 0);
                primitive.lineStyle(1, strokeStyleWireframe, 1);
            }

            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            for (var j = 1; j < part.vertices.length; j++) {
                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
            }

            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            primitive.endFill();

            // angle indicator
            if (options.showAngleIndicator || options.showAxes) {
                primitive.beginFill(0, 0);

                if (options.wireframes) {
                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                } else {
                    primitive.lineStyle(1, strokeStyleIndicator);
                }

                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), 
                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));

                primitive.endFill();
            }
        }

        return primitive;
    };

    /**
     * Gets the requested texture (a PIXI.Texture) via its path
     * @method _getTexture
     * @private
     * @param {RenderPixi} render
     * @param {string} imagePath
     * @return {PIXI.Texture} texture
     * @deprecated
     */
    var _getTexture = function(render, imagePath) {
        var texture = render.textures[imagePath];

        if (!texture)
            texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);

        return texture;
    };

})();


/***/ }),
/* 705 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ }),
/* 706 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ }),
/* 707 */
/***/ (function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ }),
/* 708 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ }),
/* 709 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ }),
/* 710 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ }),
/* 711 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ }),
/* 712 */
/***/ (function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function () {

    if ('performance' in window === false)
    {
        window.performance = {};
    }

    //  Thanks IE8
    Date.now = (Date.now || function () {
        return new Date().getTime();
    });

    if ('now' in window.performance === false)
    {
        var nowOffset = Date.now();

        if (performance.timing && performance.timing.navigationStart)
        {
            nowOffset = performance.timing.navigationStart;
        }

        window.performance.now = function now ()
        {
            return Date.now() - nowOffset;
        }
    }

})();


/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)))

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(6);
var DrawImage = __webpack_require__(716);
var BlitImage = __webpack_require__(715);
var GetBlendModes = __webpack_require__(717);
var GetContext = __webpack_require__(103);
var Snapshot = __webpack_require__(210);
var Smoothing = __webpack_require__(64);
var ScaleModes = __webpack_require__(38);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = game;

    //  Needed?
    this.type = CONST.CANVAS;

    this.drawCount = 0;

    //  Read all the following from game config (or State config?)
    // this.clearBeforeRender = true;
    // this.transparent = false;
    // this.autoResize = false;
    // this.roundPixels = false;

    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;

    this.scaleMode = (game.config.pixelArt) ? ScaleModes.NEAREST : ScaleModes.LINEAR;

    this.gameCanvas = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.gameContext = GetContext(this.gameCanvas);

    this.gameConfig = game.config;

    this.currentContext = this.gameContext;

    //  Map to the required function
    this.drawImage = DrawImage;
    this.blitImage = BlitImage;

    this.blendModes = GetBlendModes();

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    //  Resize the main game canvas
    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.gameCanvas.width = this.width;
        this.gameCanvas.height = this.height;

        if (this.autoResize)
        {
            this.gameCanvas.style.width = (this.width / res) + 'px';
            this.gameCanvas.style.height = (this.height / res) + 'px';
        }

        //  Resizing a canvas will reset imageSmoothingEnabled (and probably other properties)
        if (this.scaleMode === ScaleModes.NEAREST)
        {
            Smoothing.disable(this.gameContext);
        }
    },

    resetTransform: function ()
    {
        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
    },

    setBlendMode: function (blendMode)
    {
        if (this.currentBlendMode !== blendMode)
        {
            this.currentContext.globalCompositeOperation = blendMode;
            this.currentBlendMode = blendMode;
        }

        return this.currentBlendMode;
    },

    setAlpha: function (alpha)
    {
        if (this.currentAlpha !== alpha)
        {
            this.currentContext.globalAlpha = alpha;
            this.currentAlpha = alpha;
        }

        return this.currentAlpha;
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.gameContext;
        var config = this.gameConfig;

        var width = this.width;
        var height = this.height;

        if (config.clearBeforeRender)
        {
            ctx.clearRect(0, 0, width, height);
        }

        if (!config.transparent)
        {
            ctx.fillStyle = config.backgroundColor.rgba;
            ctx.fillRect(0, 0, width, height);
        }

        //  Add Pre-render hook

        this.drawCount = 0;
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        var w = state.sys.width;
        var h = state.sys.height;
        var ctx = state.sys.context;
        var settings = state.sys.settings;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== ctx.canvas.width || camera.height !== ctx.canvas.height);
        var list = children.list;

        this.currentContext = ctx;

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        if (settings.renderToTexture)
        {
            if (settings.clearBeforeRender)
            {
                ctx.clearRect(0, 0, w, h);
            }

            if (settings.backgroundColor)
            {
                ctx.fillStyle = settings.backgroundColor;
                ctx.fillRect(0, 0, w, h);
            }
        }

        this.drawCount += list.length;

        if (scissor)
        {
            ctx.save();
            ctx.beginPath();
            ctx.rect(camera.x, camera.y, camera.width, camera.height);
            ctx.clip();
            ctx.closePath();
        }

        var matrix = camera.matrix.matrix;

        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

        for (var c = 0; c < list.length; c++)
        {
            var child = list[c];

            child.renderCanvas(this, child, interpolationPercentage, camera);
        }

        //  Call the State.render function
        state.render.call(state, ctx, interpolationPercentage);
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            // fade rendering
            ctx.fillStyle = 'rgb(' + (camera._fadeRed * 255) + ',' + (camera._fadeGreen * 255) + ',' + (camera._fadeBlue * 255) + ')';
            ctx.globalAlpha = camera._fadeAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            // flash rendering
            ctx.fillStyle = 'rgb(' + (camera._flashRed * 255) + ',' + (camera._flashGreen * 255) + ',' + (camera._flashBlue * 255) + ')';
            ctx.globalAlpha = camera._flashAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            ctx.globalAlpha = 1.0;
        }

        //  Reset the camera scissor
        if (scissor)
        {
            ctx.restore();
        }
        
        //  Blast it to the Game Canvas (if needed)
        if (settings.renderToTexture)
        {
            this.gameContext.drawImage(state.sys.canvas, 0, 0, w, h, settings.x, settings.y, w, h);
        }
    },

    postRender: function ()
    {
        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        var ctx = this.gameContext;

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        this.currentAlpha = 1;
        this.currentBlendMode = 0;

        if (this.snapshotCallback)
        {
            this.snapshotCallback(Snapshot.CanvasSnapshot(this.gameCanvas));
            this.snapshotCallback = null;
        }

        //  Add Post-render hook
    },

    snapshot: function (callback)
    {
        this.snapshotCallback = callback;
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removegameCanvas=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.gameCanvas = null;
        this.gameContext = null;
    }

};

module.exports = CanvasRenderer;


/***/ }),
/* 715 */
/***/ (function(module, exports) {


//  No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas
var BlitImage = function (dx, dy, frame, camera)
{
    var ctx = this.currentContext;
    var cd = frame.canvasData;

    ctx.drawImage(
        frame.source.image,
        cd.sx,
        cd.sy,
        cd.sWidth,
        cd.sHeight,
        dx - camera.scrollX,
        dy - camera.scrollY,
        cd.dWidth,
        cd.dHeight
    );
};

module.exports = BlitImage;


/***/ }),
/* 716 */
/***/ (function(module, exports) {


var DrawImage = function (src, camera)
{
    var ctx = this.currentContext;
    var frame = src.frame;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== src.blendMode)
    {
        this.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = this.blendModes[src.blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== src.alpha)
    {
        this.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (this.currentScaleMode !== src.scaleMode)
    {
        this.currentScaleMode = src.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    var dx = frame.x - src.displayOriginX;
    var dy = frame.y - src.displayOriginY;

    ctx.save();
    ctx.translate(src.x - camera.scrollX, src.y - camera.scrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.scale(src.flipX ? -1 : 1, src.flipY ? -1 : 1);
    ctx.translate(src.dWidth * (src.flipX ? 1 : 0), src.dHeight * (src.flipY ? 1 : 0));
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, dx, dy, cd.dWidth, cd.dHeight);
    ctx.restore();
};

module.exports = DrawImage;


/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

var modes = __webpack_require__(59);
var CanvasFeatures = __webpack_require__(107);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

var Resources = __webpack_require__(209);

var ResourceManager = function (gl) 
{
    this.gl = gl;
    /* Maybe add pooling here */
    this.shaderCache = {};
    this.shaderCount = 0;
};

ResourceManager.prototype.constructor = ResourceManager;

ResourceManager.prototype = {

    createRenderTarget: function (width, height, colorBuffer, depthStencilBuffer) 
    {
        var gl = this.gl;
        var framebufferObject = gl.createFramebuffer();
        var depthStencilRenderbufferObject = null;
        var colorRenderbufferObject = null;
        var complete = 0;

        gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferObject)

        if (depthStencilBuffer !== undefined && depthStencilBuffer !== null) 
        {
            depthStencilBuffer.isRenderTexture = true;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, depthStencilBuffer.texture, depthStencilBuffer.mipLevel);
        }
        else
        {
            depthStencilRenderbufferObject = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderbufferObject);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderbufferObject);
        }

        if (colorBuffer !== undefined && colorBuffer !== null) 
        {
            colorBuffer.isRenderTexture = true;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer.texture, colorBuffer.mipLevel);
        } 
        else
        {
            colorRenderbufferObject = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbufferObject);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbufferObject);
        }

        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        if (complete !== gl.FRAMEBUFFER_COMPLETE) 
        {
            var errors = {
                36054: 'Incomplete Attachment',
                36055: 'Missing Attachment',
                36057: 'Incomplete Dimensions',
                36061: 'Framebuffer Unsupported'
            };
            throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return new Resources.RenderTarget(
            framebufferObject,
            width, height,
            (colorBuffer === undefined ? null : colorBuffer),
            (depthStencilBuffer === undefined ? null : depthStencilBuffer)
        );
    },

    createBuffer: function (target, initialDataOrSize, bufferUsage) 
    {
        var gl = this.gl;
        var bufferObject = gl.createBuffer();
        gl.bindBuffer(target, bufferObject);
        gl.bufferData(target, initialDataOrSize, bufferUsage);

        switch (target) 
        {
            case gl.ARRAY_BUFFER:
                return new Resources.VertexBuffer(gl, bufferObject);
            case gl.ELEMENT_ARRAY_BUFFER:
                return new Resources.IndexBuffer(gl, bufferObject);
            default:
                throw new Error('Invalid Buffer Target');
        }

        return null;
    },

    createTexture: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height) 
    {
        var gl = this.gl;
        var texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);

        if (pixels === null || pixels === undefined) 
        {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
        } 
        else 
        {
            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
            width = pixels.width;
            height = pixels.height;
        }
        gl.bindTexture(gl.TEXTURE_2D, null);

        return new Resources.Texture(texture, width, height);
    },

    createShader: function (shaderName, shaderSources) 
    {
        if (shaderName === null || shaderName === undefined)
        {
            shaderName += 'Shader' + this.shaderCount;
            this.shaderCount += 1;
        }
        if (!(shaderName in this.shaderCache))
        {
            var gl = this.gl;
            var program;
            var vertShader;
            var fragShader;
            var status;
            var error;
            var shader;

            vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, shaderSources.vert);
            gl.compileShader(vertShader);

            error = gl.getShaderInfoLog(vertShader);
            status = gl.getShaderParameter(vertShader, gl.COMPILE_STATUS);

            if (!status && error && error.length > 0) 
            {
                throw new Error('Vertex Shader Compilation Error. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.vert);
            }
            else if (error && error.length > 0)
            {
                console.warn('Vertex Shader Compilation Warning. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.vert);
            }

            fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, shaderSources.frag);
            gl.compileShader(fragShader);

            error = gl.getShaderInfoLog(fragShader);
            status = gl.getShaderParameter(fragShader, gl.COMPILE_STATUS);

            if (!status && error && error.length > 0) 
            {
                throw new Error('Fragment Shader Compilation Error. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.frag);
            }
            else if (error && error.length > 0)
            {
                console.warn('Fragment Shader Compilation Warning. Shader name: ' + shaderName + '.\n' + error + '\n\n Shader source:\n' + shaderSources.frag);
            }

            program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            gl.validateProgram(program);

            error = gl.getProgramParameter(program, gl.LINK_STATUS);

            if (error === 0)
            {
                error = gl.getProgramInfoLog(program);

                throw new Error('Program Linking Error. Shader name: ' + shaderName + '.\n' + error);
            }
            
            error = gl.getProgramParameter(program, gl.VALIDATE_STATUS);
            if (error === 0)
            {
                error = gl.getProgramInfoLog(program);
                throw new Error('Program Validation Error. Shader name: ' + shaderName + '.\n' + error);
            }

            shader = new Resources.Shader(shaderName, gl, program, vertShader, fragShader);
            this.shaderCache[shaderName] = shader;
            return  shader;
        }
        else
        {
            return this.shaderCache[shaderName];   
        }
    },

    deleteShader: function (shader)
    {
        var storedShader = this.shaderCache[shader.name]
        var gl = this.gl;
        if (storedShader !== undefined)
        {
            delete this.shaderCache;
        }
        gl.deleteShader(shader.vertexShader);
        gl.deleteShader(shader.fragmentShader);
        gl.deleteProgram(shader.program);
        shader.vertexShader = null;
        shader.fragmentShader = null;
        shader.program = null;
        shader.name = null;
    },

    deleteBuffer: function (buffer)
    {
        var gl = this.gl;

        gl.deleteBuffer(buffer.bufferObject);
    }

};

module.exports = ResourceManager;


/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey (@photonstorm)
* @author       Felipe Alfonso (@bitnenfer)
* @copyright    2017 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var BlitterBatch = __webpack_require__(720);
var QuadBatch = __webpack_require__(724);
var SpriteBatch = __webpack_require__(729);
var TileBatch = __webpack_require__(731);
var ShapeBatch = __webpack_require__(726);
var EffectRenderer = __webpack_require__(722);
var TilemapRenderer = __webpack_require__(733);
var BlendModes = __webpack_require__(59);
var ScaleModes = __webpack_require__(38);
var ResourceManager = __webpack_require__(718);
var Resources = __webpack_require__(209);
var Snapshot = __webpack_require__(210);

var WebGLRenderer = function (game)
{
    this.game = game;
    this.type = CONST.WEBGL;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;
    this.view = game.canvas;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.contextLost = false;
    this.maxTextures = 1;
    this.multiTexture = false;
    this.blendModes = [];
    this.gl = null;
    this.extensions = null;
    this.rendererArray = [];
    this.blitterBatch = null;
    this.aaQuadBatch = null;
    this.spriteBatch = null;
    this.shapeBatch = null;
    this.effectRenderer = null;
    this.currentRenderer = null;
    this.currentTexture = null;
    this.shaderCache = {};
    this.currentShader = null;
    this.resourceManager = null;
    this.currentRenderTarget = null;
    this.snapshotCallback = null;

    this.scissor = {
        enabled: false,
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };

    this.init();
};

WebGLRenderer.prototype.constructor = WebGLRenderer;

WebGLRenderer.prototype = {

    init: function ()
    {
        // console.log('WebGLRenderer.init');

        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }

        var gl = this.gl;
        var color = this.game.config.backgroundColor;

        this.resourceManager = new ResourceManager(gl);
    
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        //  Map Blend Modes

        var add = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
        var normal = [ gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        var multiply = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
        var screen = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendModes = [
            normal, add, multiply, screen, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal
        ];

        this.blendMode = -1;
        this.extensions = gl.getSupportedExtensions();
        this.blitterBatch = this.addRenderer(new BlitterBatch(this.game, gl, this));
        this.quadBatch = this.addRenderer(new QuadBatch(this.game, gl, this));
        this.spriteBatch = this.addRenderer(new SpriteBatch(this.game, gl, this));
        this.shapeBatch = this.addRenderer(new ShapeBatch(this.game, gl, this));
        this.effectRenderer = this.addRenderer(new EffectRenderer(this.game, gl, this));
        this.tileBatch = this.addRenderer(new TileBatch(this.game, gl, this));
        this.tilemapRenderer = this.addRenderer(new TilemapRenderer(this.game, gl, this));
        this.currentRenderer = this.spriteBatch;
        this.setBlendMode(0);
        this.resize(this.width, this.height);
    },

    createTexture: function (source, width, height)
    {
        width = source ? source.width : width;
        height = source ? source.height : height;
        var pot = ((width & (width - 1)) == 0 && (height & (height - 1)) == 0);
        var gl = this.gl;
        var filter = gl.NEAREST;
        var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;

        if (!source.glTexture)
        {
            if (source.scaleMode === ScaleModes.LINEAR)
            {
                filter = gl.LINEAR;
            }
            else if (source.scaleMode === ScaleModes.NEAREST || this.game.config.pixelArt)
            {
                filter = gl.NEAREST;
            }

            if (!source && typeof width === 'number' && typeof height === 'number')
            {
                source.glTexture = this.resourceManager.createTexture(
                    0,
                    filter,
                    filter,
                    wrap,
                    wrap,
                    gl.RGBA,
                    null,
                    width, height
                );
            }
            else
            {
                source.glTexture = this.resourceManager.createTexture(
                    0,
                    filter,
                    filter,
                    wrap,
                    wrap,
                    gl.RGBA,
                    source.image
                );
            }
        }

        this.currentTexture = null;
    },

    setTexture: function (texture)
    {
        if (this.currentTexture !== texture)
        {
            var gl = this.gl;

            this.currentRenderer.flush();
            
            gl.activeTexture(gl.TEXTURE0);

            if (texture !== null)
            {
                gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            }
            else
            {
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            this.currentTexture = texture;
        }
    },

    setRenderer: function (renderer, texture, renderTarget)
    {
        this.setTexture(texture);
        this.setRenderTarget(renderTarget);
        
        if (this.currentRenderer !== renderer || this.currentRenderer.shouldFlush())
        {
            this.currentRenderer.flush();
            this.currentRenderer = renderer;
        }
    },

    setRenderTarget: function (renderTarget)
    {
        var gl = this.gl;

        if (this.currentRenderTarget !== renderTarget)
        {
            this.currentRenderer.flush();

            if (renderTarget !== null)
            {
                gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.framebufferObject);
                if (renderTarget.shouldClear)
                {
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    renderTarget.shouldClear = false;
                }
            }
            else
            {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.width, this.height);
            }
            this.currentRenderTarget = renderTarget;
        }
    },

    resize: function (width, height)
    {
        var resolution = this.game.config.resolution;

        this.width = width * resolution;
        this.height = height * resolution;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / resolution) + 'px';
            this.view.style.height = (this.height / resolution) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);
        for (var i = 0, l = this.rendererArray.length; i < l; ++i)
        {
            this.rendererArray[i].bind();
            this.rendererArray[i].resize(width, height, resolution);
        }
        this.currentRenderer.bind();
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        this.setRenderTarget(null);

        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        //  Add Pre-render hook

        var gl = this.gl;
        var color = this.game.config.backgroundColor;

        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        // Some drivers require to call glClear
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

        this.setBlendMode(BlendModes.NORMAL);
    },

    /**
     * Renders a single State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        //  Could move to the State Systems or MainLoop
        var gl = this.gl;

        this.scissor.enabled = (camera.x !== 0 || camera.y !== 0 || camera.width !== gl.canvas.width || camera.height !== gl.canvas.height);

        this.setRenderTarget(null);

        if (this.scissor.enabled)
        {
            gl.enable(gl.SCISSOR_TEST);

            this.scissor.x = camera.x;
            this.scissor.y = gl.drawingBufferHeight - camera.y - camera.height;
            this.scissor.width = camera.width;
            this.scissor.height = camera.height;

            gl.scissor(this.scissor.x, this.scissor.y, this.scissor.width, this.scissor.height);
        }

        // We could either clear color or render a quad
        var color = this.game.config.backgroundColor;
        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);
        gl.clear(gl.COLOR_BUFFER_BIT);

        var list = children.list;
        var length = list.length;

        for (var index = 0; index < length; ++index)
        {
            var child = list[index];

            // Setting blend mode if needed            
            var renderer = this.currentRenderer;
            var newBlendMode = child.blendMode;

            if (this.blendMode !== newBlendMode)
            {
                if (renderer)
                {
                    renderer.flush();
                }
                var blend = this.blendModes[newBlendMode];
                gl.enable(gl.BLEND);
                if (blend.length > 2)
                {
                    gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
                }
                else
                {
                    gl.blendFunc(blend[0], blend[1]);        
                }
                this.blendMode = newBlendMode;
            }

            // drawing child
            child.renderWebGL(this, child, interpolationPercentage, camera);
            renderer = this.currentRenderer;
            if (renderer.isFull() || renderer.shouldFlush())
            {
                renderer.flush();
            }
        }
        
        this.currentRenderer.flush();
        
        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            this.setRenderTarget(null);
            var quadBatch = this.quadBatch;
            quadBatch.bind();

            // fade rendering
            quadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._fadeRed, 
                camera._fadeGreen, 
                camera._fadeBlue, 
                camera._fadeAlpha
            );

            // flash rendering
            quadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._flashRed, 
                camera._flashGreen, 
                camera._flashBlue, 
                camera._flashAlpha
            );
            quadBatch.flush();
            this.currentRenderer.bind();
        }

        if (this.scissor.enabled)
        {
            gl.disable(gl.SCISSOR_TEST);
        }
    },

    //  Called at the end of the render loop (tidy things up, etc)
    postRender: function ()
    {
        this.currentRenderer.flush();

        if (this.snapshotCallback)
        {
            this.snapshotCallback(Snapshot.WebGLSnapshot(this.view));
            this.snapshotCallback = null;
        }

        //  Add Post-render hook

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');
    },

    snapshot: function (callback) 
    {
        this.snapshotCallback = callback;
    },


    destroy: function ()
    {
        this.gl = null;
    },

    createFBO: function () {},

    setBlendMode: function (newBlendMode)
    {
        var gl = this.gl;
        var renderer = this.currentRenderer;
        var blend = null;

        if (this.blendMode !== newBlendMode)
        {
            if (renderer)
            {
                renderer.flush();
            }

            blend = this.blendModes[newBlendMode];
            gl.enable(gl.BLEND);

            if (blend.length > 2)
            {
                gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
            }
            else
            {
                gl.blendFunc(blend[0], blend[1]);        
            }

            this.blendMode = newBlendMode;
        }
    },

    addRenderer: function (rendererInstance)
    {
        var index = this.rendererArray.indexOf(rendererInstance);

        if (index < 0)
        {
            this.rendererArray.push(rendererInstance);
            return rendererInstance;
        }

        return null;
    },

    setTextureFilterMode: function (texture, filterMode)
    {
        var gl = this.gl;
        var glFilter = [ gl.LINEAR, gl.NEAREST ][filterMode];

        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);

        if (this.currentTexture !== null)
        {
            gl.bindTexture(gl.TEXTURE_2D, this.currentTexture.texture);
        }
        else
        {
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        return texture;
    },

    uploadCanvasToGPU: function (srcCanvas, dstTexture, shouldUpdateResource)
    {
        var gl = this.gl;

        if (!dstTexture)
        {
            dstTexture = new Resources.Texture(null, 0, 0);
            /* only call this once */
            dstTexture.texture = gl.createTexture();
        }
        if (shouldUpdateResource)
        {
            /* Update resource */
            gl.bindTexture(gl.TEXTURE_2D, dstTexture.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
        }
        else
        {
            /* Allocate or Reallocate resource */
            gl.bindTexture(gl.TEXTURE_2D, dstTexture.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        dstTexture.width = srcCanvas.width;
        dstTexture.height = srcCanvas.height;

        /* we must rebind old texture */
        this.currentTexture = null;

        return dstTexture;
    }
};

module.exports = WebGLRenderer;


/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var TexturedAndAlphaShader = __webpack_require__(739);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(721);

var BlitterBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxParticles = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

BlitterBatch.prototype.constructor = BlitterBatch;

BlitterBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);
        var shader = this.manager.resourceManager.createShader('TexturedAndAlphaShader', TexturedAndAlphaShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 16);

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxParticles = max;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();
        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    }
};

module.exports = BlitterBatch;


/***/ }),
/* 721 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2) + sizeof(float)
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_PARTICLES: 2000,

};

module.exports = CONST;


/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var TransformMatrix = __webpack_require__(16);
var TexturedAndNormalizedTintedShader = __webpack_require__(49);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(723);

var EffectRenderer = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxSprites = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.tempMatrix = new TransformMatrix();
    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

EffectRenderer.prototype.constructor = EffectRenderer;

EffectRenderer.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.QUAD_VERTEX_COUNT * CONST.MAX_QUADS);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.QUAD_INDEX_COUNT * CONST.MAX_QUADS);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_QUADS * CONST.QUAD_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.QUAD_INDEX_COUNT, indexB += CONST.QUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },
    
    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);

        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();
        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;

        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            activeShader.getUniformLocation('u_view_matrix'),
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    renderEffect: function (gameObject, camera, texture, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = textureWidth * (gameObject.flipX ? -1 : 1);
        var height = textureHeight * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + ((textureWidth) * (gameObject.flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + ((textureHeight) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        this.flush(gameObject.dstShader);
        gameObject.dstRenderTarget.shouldClear = true;

    }

};

module.exports = EffectRenderer;


/***/ }),
/* 723 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    QUAD_VERTEX_COUNT: 4,
    QUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    QUAD_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_QUADS: 2
    
};

module.exports = CONST;


/***/ }),
/* 724 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var UntexturedAndTintedShader = __webpack_require__(742);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(725);

var QuadBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxQuads = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

QuadBatch.prototype.constructor = QuadBatch;

QuadBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.AAQUAD_VERTEX_COUNT * CONST.MAX_AAQUAD);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.AAQUAD_INDEX_COUNT * CONST.MAX_AAQUAD);
        var shader = this.manager.resourceManager.createShader('UntexturedAndTintedShader', UntexturedAndTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_AAQUAD * CONST.AAQUAD_INDEX_COUNT;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 4, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.AAQUAD_INDEX_COUNT, indexB += CONST.AAQUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var floatBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.AAQUAD_VERTEX_COMPONENT_COUNT * CONST.AAQUAD_VERTEX_COUNT);

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        this.elementCount += CONST.AAQUAD_INDEX_COUNT;
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();
        this.elementCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    }
};

module.exports = QuadBatch;


/***/ }),
/* 725 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec4)
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    AAQUAD_VERTEX_COUNT: 4,
    AAQUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    AAQUAD_VERTEX_COMPONENT_COUNT: 6,
    MAX_AAQUAD: 2000,

};

module.exports = CONST;


/***/ }),
/* 726 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var Earcut = __webpack_require__(728);
var UntexturedAndNormalizedTintedShader = __webpack_require__(741);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(727);

var ShapeBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxVertices = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.vertexDataBuffer = null;
    this.vertexCount = 0;
    this.viewMatrixLocation = null;
    this.tempTriangle = [
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0}
    ];

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;
    this.context = null;
    this.init(this.glContext);

};

ShapeBatch.prototype.constructor = ShapeBatch;

ShapeBatch.prototype = {

    init: function (gl)
    {
        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.MAX_VERTICES);
        var shader = this.manager.resourceManager.createShader('UntexturedAndNormalizedTintedShader', UntexturedAndNormalizedTintedShader);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var max = CONST.MAX_VERTICES;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 4, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 12);

        this.vertexDataBuffer = vertexDataBuffer;
        this.shader = shader;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxVertices = max;
        this.polygonCache = [];

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.vertexBufferObject.bind();
    },

    flush: function (shader)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.vertexCount === 0)
        {
            return;
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);
        gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
        vertexDataBuffer.clear();
        this.vertexCount = 0;
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;

        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.vertexBufferObject = null;
    },

    addLine: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* line properties */
        ax, ay, bx, by, aLineWidth, bLineWidth, aLineColor, bLineColor, lineAlpha,
        /* transform */
        a1, b1, c1, d1, e1, f1,
        currentMatrix
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }

        this.vertexCount += 6;

        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var dx = bx - ax;
        var dy = by - ay;
        var len = Math.sqrt(dx * dx + dy * dy);
        var al0 = aLineWidth * (by - ay) / len;
        var al1 = aLineWidth * (ax - bx) / len;
        var bl0 = bLineWidth * (by - ay) / len;
        var bl1 = bLineWidth * (ax - bx) / len;
        var lx0 = bx - bl0;
        var ly0 = by - bl1;
        var lx1 = ax - al0;
        var ly1 = ay - al1;
        var lx2 = bx + bl0;
        var ly2 = by + bl1;
        var lx3 = ax + al0;
        var ly3 = ay + al1;
        var x0 = lx0 * a + ly0 * c + e;
        var y0 = lx0 * b + ly0 * d + f;
        var x1 = lx1 * a + ly1 * c + e;
        var y1 = lx1 * b + ly1 * d + f;
        var x2 = lx2 * a + ly2 * c + e;
        var y2 = lx2 * b + ly2 * d + f;
        var x3 = lx3 * a + ly3 * c + e;
        var y3 = lx3 * b + ly3 * d + f;
        var vertexOffset = vertexDataBuffer.allocate(24);

        vertexBufferF32[vertexOffset++] = x0;
        vertexBufferF32[vertexOffset++] = y0;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x3;
        vertexBufferF32[vertexOffset++] = y3;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        return [
            x0, y0, bLineColor,
            x1, y1, aLineColor,
            x2, y2, bLineColor,
            x3, y3, aLineColor
        ];

    },

    addStrokePath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f,
        /* is last connection */
        isLastPath,
        currentMatrix
    ) {
        var point0, point1;
        var pathLength = path.length;
        var polylines = this.polygonCache;
        var halfLineWidth = lineWidth * 0.5;
        var last, curr;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset;
        var x0, y0, x1, y1, x2, y2;
        var line;

        for (var pathIndex = 0; pathIndex + 1 < pathLength; pathIndex += 1)
        {
            point0 = path[pathIndex];
            point1 = path[pathIndex + 1];
            line = this.addLine(
                srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                point0.x, point0.y, 
                point1.x, point1.y, 
                point0.width / 2, point1.width / 2, 
                point0.rgb, point1.rgb, lineAlpha,
                a, b, c, d, e, f,
                currentMatrix
            );
            polylines.push(line);
        }

        /* Render joints */
        for (var index = 1, polylinesLength = polylines.length;
            index < polylinesLength; ++index)
        {

            if (this.vertexCount + 6 > this.maxVertices)
            {
                this.flush();
            }

            last = polylines[index - 1] || polylines[polylinesLength - 1];
            curr = polylines[index];
            vertexOffset = vertexDataBuffer.allocate(24)

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 3 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 1 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            this.vertexCount += 6;
        }
        polylines.length = 0;
    },

    addFillPath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, fillColor, fillAlpha,
        /* transform */
        a1, b1, c1, d1, e1, f1,
        currentMatrix
    ) {
        var length = path.length;
        var polygonCache = this.polygonCache;
        var polygonIndexArray;
        var point;
        var v0, v1, v2;
        var vertexOffset;
        var vertexCount = this.vertexCount;
        var maxVertices = this.maxVertices;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var x0, y0, x1, y1, x2, y2;
        var tx0, ty0, tx1, ty1, tx2, ty2;
        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;

        for (var pathIndex = 0; pathIndex < length; ++pathIndex)
        {
            point = path[pathIndex];
            polygonCache.push(point.x, point.y);
        }
        polygonIndexArray = Earcut(polygonCache);
        length = polygonIndexArray.length;

        for (var index = 0; index < length; index += 3)
        {
            v0 = polygonIndexArray[index + 0] * 2;
            v1 = polygonIndexArray[index + 1] * 2;
            v2 = polygonIndexArray[index + 2] * 2;

            if (vertexCount + 3 > maxVertices)
            {
                this.vertexCount = vertexCount;
                this.flush();
                vertexCount = 0;
            }
            vertexOffset = vertexDataBuffer.allocate(12);
            vertexCount += 3;

            x0 = polygonCache[v0 + 0];
            y0 = polygonCache[v0 + 1];
            x1 = polygonCache[v1 + 0];
            y1 = polygonCache[v1 + 1];
            x2 = polygonCache[v2 + 0];
            y2 = polygonCache[v2 + 1];

            tx0 = x0 * a + y0 * c + e;
            ty0 = x0 * b + y0 * d + f;
            tx1 = x1 * a + y1 * c + e;
            ty1 = x1 * b + y1 * d + f;
            tx2 = x2 * a + y2 * c + e;
            ty2 = x2 * b + y2 * d + f;

            vertexBufferF32[vertexOffset++] = tx0;
            vertexBufferF32[vertexOffset++] = ty0;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx1;
            vertexBufferF32[vertexOffset++] = ty1;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx2;
            vertexBufferF32[vertexOffset++] = ty2;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

        }
        this.vertexCount = vertexCount;
        polygonCache.length = 0;
    },

    addFillRect: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Rectangle properties */
        x, y, width, height, fillColor, fillAlpha,
        /* transform */
        a1, b1, c1, d1, e1, f1,
        currentMatrix
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(24);
        var xw = x + width;
        var yh = y + height;
        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var tx0 = x * a + y * c + e;
        var ty0 = x * b + y * d + f;
        var tx1 = x * a + yh * c + e;
        var ty1 = x * b + yh * d + f;
        var tx2 = xw * a + yh * c + e;
        var ty2 = xw * b + yh * d + f;
        var tx3 = xw * a + y * c + e;
        var ty3 = xw * b + y * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 6;
    },

    addFillTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, fillColor, fillAlpha,
        /* transform */
        a1, b1, c1, d1, e1, f1,
        currentMatrix
    ) {
        if (this.vertexCount + 3 > this.maxVertices)
        {
            this.flush();
        }
        var a0 = currentMatrix.matrix[0];
        var b0 = currentMatrix.matrix[1];
        var c0 = currentMatrix.matrix[2];
        var d0 = currentMatrix.matrix[3];
        var e0 = currentMatrix.matrix[4];
        var f0 = currentMatrix.matrix[5];
        var a = a1 * a0 + b1 * c0;
        var b = a1 * b0 + b1 * d0;
        var c = c1 * a0 + d1 * c0;
        var d = c1 * b0 + d1 * d0;
        var e = e1 * a0 + f1 * c0 + e0;
        var f = e1 * b0 + f1 * d0 + f0;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(12);
        var tx0 = x0 * a + y0 * c + e;
        var ty0 = x0 * b + y0 * d + f;
        var tx1 = x1 * a + y1 * c + e;
        var ty1 = x1 * b + y1 * d + f;
        var tx2 = x2 * a + y2 * c + e;
        var ty2 = x2 * b + y2 * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 3;
    },

    addStrokeTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f,
        currentMatrix
    ) {
        var tempTriangle = this.tempTriangle;

        tempTriangle[0].x = x0;
        tempTriangle[0].y = y0;
        tempTriangle[0].width = lineWidth;
        tempTriangle[0].rgb = lineColor;
        tempTriangle[0].alpha = lineAlpha;
        tempTriangle[1].x = x1;
        tempTriangle[1].y = y1;
        tempTriangle[1].width = lineWidth;
        tempTriangle[1].rgb = lineColor;
        tempTriangle[1].alpha = lineAlpha;
        tempTriangle[2].x = x2;
        tempTriangle[2].y = y2;
        tempTriangle[2].width = lineWidth;
        tempTriangle[2].rgb = lineColor;
        tempTriangle[2].alpha = lineAlpha;
        tempTriangle[3].x = x0;
        tempTriangle[3].y = y0;
        tempTriangle[3].width = lineWidth;
        tempTriangle[3].rgb = lineColor;
        tempTriangle[3].alpha = lineAlpha;

        this.addStrokePath(
            srcX, srcY, srcScaleX, srcScaleY, srcRotation,
            tempTriangle, lineWidth, lineColor, lineAlpha,
            a, b, c, d, e, f,
            false,
            currentMatrix
        );
    }
};

module.exports = ShapeBatch;


/***/ }),
/* 727 */
/***/ (function(module, exports) {

var CONST = {

    VERTEX_SIZE: 16,

    // How many 32-bit components does the vertex have.
    SHAPE_VERTEX_COMPONENT_COUNT: 4,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_VERTICES: 16000
    
};

module.exports = CONST;


/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.earcut=e()}}(function(){return function e(n,t,r){function x(u,f){if(!t[u]){if(!n[u]){var o="function"==typeof require&&require;if(!f&&o)return require(u,!0);if(i)return require(u,!0);var v=new Error("Cannot find module '"+u+"'");throw v.code="MODULE_NOT_FOUND",v}var l=t[u]={exports:{}};n[u][0].call(l.exports,function(e){var t=n[u][1][e];return x(t?t:e)},l,l.exports,e,n,t,r)}return t[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)x(r[u]);return x}({1:[function(e,n,t){"use strict";function r(e,n,t){t=t||2;var r=n&&n.length,i=r?n[0]*t:e.length,f=x(e,0,i,t,!0),o=[];if(!f)return o;var v,l,p,a,h,s,c;if(r&&(f=y(e,n,f,t)),e.length>80*t){v=p=e[0],l=a=e[1];for(var d=t;i>d;d+=t)h=e[d],s=e[d+1],v>h&&(v=h),l>s&&(l=s),h>p&&(p=h),s>a&&(a=s);c=Math.max(p-v,a-l)}return u(f,o,t,v,l,c),o}function x(e,n,t,r,x){var i,u;if(x===_(e,n,t,r)>0)for(i=n;t>i;i+=r)u=E(i,e[i],e[i+1],u);else for(i=t-r;i>=n;i-=r)u=E(i,e[i],e[i+1],u);return u&&z(u,u.next)&&(N(u),u=u.next),u}function i(e,n){if(!e)return e;n||(n=e);var t,r=e;do if(t=!1,r.steiner||!z(r,r.next)&&0!==b(r.prev,r,r.next))r=r.next;else{if(N(r),r=n=r.prev,r===r.next)return null;t=!0}while(t||r!==n);return n}function u(e,n,t,r,x,y,p){if(e){!p&&y&&s(e,r,x,y);for(var a,h,c=e;e.prev!==e.next;)if(a=e.prev,h=e.next,y?o(e,r,x,y):f(e))n.push(a.i/t),n.push(e.i/t),n.push(h.i/t),N(e),e=h.next,c=h.next;else if(e=h,e===c){p?1===p?(e=v(e,n,t),u(e,n,t,r,x,y,2)):2===p&&l(e,n,t,r,x,y):u(i(e),n,t,r,x,y,1);break}}}function f(e){var n=e.prev,t=e,r=e.next;if(b(n,t,r)>=0)return!1;for(var x=e.next.next;x!==e.prev;){if(g(n.x,n.y,t.x,t.y,r.x,r.y,x.x,x.y)&&b(x.prev,x,x.next)>=0)return!1;x=x.next}return!0}function o(e,n,t,r){var x=e.prev,i=e,u=e.next;if(b(x,i,u)>=0)return!1;for(var f=x.x<i.x?x.x<u.x?x.x:u.x:i.x<u.x?i.x:u.x,o=x.y<i.y?x.y<u.y?x.y:u.y:i.y<u.y?i.y:u.y,v=x.x>i.x?x.x>u.x?x.x:u.x:i.x>u.x?i.x:u.x,l=x.y>i.y?x.y>u.y?x.y:u.y:i.y>u.y?i.y:u.y,y=d(f,o,n,t,r),p=d(v,l,n,t,r),a=e.nextZ;a&&a.z<=p;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.nextZ}for(a=e.prevZ;a&&a.z>=y;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.prevZ}return!0}function v(e,n,t){var r=e;do{var x=r.prev,i=r.next.next;!z(x,i)&&M(x,r,r.next,i)&&q(x,i)&&q(i,x)&&(n.push(x.i/t),n.push(r.i/t),n.push(i.i/t),N(r),N(r.next),r=e=i),r=r.next}while(r!==e);return r}function l(e,n,t,r,x,f){var o=e;do{for(var v=o.next.next;v!==o.prev;){if(o.i!==v.i&&w(o,v)){var l=D(o,v);return o=i(o,o.next),l=i(l,l.next),u(o,n,t,r,x,f),void u(l,n,t,r,x,f)}v=v.next}o=o.next}while(o!==e)}function y(e,n,t,r){var u,f,o,v,l,y=[];for(u=0,f=n.length;f>u;u++)o=n[u]*r,v=f-1>u?n[u+1]*r:e.length,l=x(e,o,v,r,!1),l===l.next&&(l.steiner=!0),y.push(Z(l));for(y.sort(p),u=0;u<y.length;u++)a(y[u],t),t=i(t,t.next);return t}function p(e,n){return e.x-n.x}function a(e,n){if(n=h(e,n)){var t=D(n,e);i(t,t.next)}}function h(e,n){var t,r=n,x=e.x,i=e.y,u=-(1/0);do{if(i<=r.y&&i>=r.next.y){var f=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(x>=f&&f>u){if(u=f,f===x){if(i===r.y)return r;if(i===r.next.y)return r.next}t=r.x<r.next.x?r:r.next}}r=r.next}while(r!==n);if(!t)return null;if(x===u)return t.prev;var o,v=t,l=t.x,y=t.y,p=1/0;for(r=t.next;r!==v;)x>=r.x&&r.x>=l&&g(y>i?x:u,i,l,y,y>i?u:x,i,r.x,r.y)&&(o=Math.abs(i-r.y)/(x-r.x),(p>o||o===p&&r.x>t.x)&&q(r,e)&&(t=r,p=o)),r=r.next;return t}function s(e,n,t,r){var x=e;do null===x.z&&(x.z=d(x.x,x.y,n,t,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next;while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,c(x)}function c(e){var n,t,r,x,i,u,f,o,v=1;do{for(t=e,e=null,i=null,u=0;t;){for(u++,r=t,f=0,n=0;v>n&&(f++,r=r.nextZ,r);n++);for(o=v;f>0||o>0&&r;)0===f?(x=r,r=r.nextZ,o--):0!==o&&r?t.z<=r.z?(x=t,t=t.nextZ,f--):(x=r,r=r.nextZ,o--):(x=t,t=t.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;t=r}i.nextZ=null,v*=2}while(u>1);return e}function d(e,n,t,r,x){return e=32767*(e-t)/x,n=32767*(n-r)/x,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),e|n<<1}function Z(e){var n=e,t=e;do n.x<t.x&&(t=n),n=n.next;while(n!==e);return t}function g(e,n,t,r,x,i,u,f){return(x-u)*(n-f)-(e-u)*(i-f)>=0&&(e-u)*(r-f)-(t-u)*(n-f)>=0&&(t-u)*(i-f)-(x-u)*(r-f)>=0}function w(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!m(e,n)&&q(e,n)&&q(n,e)&&O(e,n)}function b(e,n,t){return(n.y-e.y)*(t.x-n.x)-(n.x-e.x)*(t.y-n.y)}function z(e,n){return e.x===n.x&&e.y===n.y}function M(e,n,t,r){return z(e,n)&&z(t,r)||z(e,r)&&z(t,n)?!0:b(e,n,t)>0!=b(e,n,r)>0&&b(t,r,e)>0!=b(t,r,n)>0}function m(e,n){var t=e;do{if(t.i!==e.i&&t.next.i!==e.i&&t.i!==n.i&&t.next.i!==n.i&&M(t,t.next,e,n))return!0;t=t.next}while(t!==e);return!1}function q(e,n){return b(e.prev,e,e.next)<0?b(e,n,e.next)>=0&&b(e,e.prev,n)>=0:b(e,n,e.prev)<0||b(e,e.next,n)<0}function O(e,n){var t=e,r=!1,x=(e.x+n.x)/2,i=(e.y+n.y)/2;do t.y>i!=t.next.y>i&&x<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==e);return r}function D(e,n){var t=new U(e.i,e.x,e.y),r=new U(n.i,n.x,n.y),x=e.next,i=n.prev;return e.next=n,n.prev=e,t.next=x,x.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function E(e,n,t,r){var x=new U(e,n,t);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function N(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function U(e,n,t){this.i=e,this.x=n,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function _(e,n,t,r){for(var x=0,i=n,u=t-r;t>i;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}n.exports=r,r.deviation=function(e,n,t,r){var x=n&&n.length,i=x?n[0]*t:e.length,u=Math.abs(_(e,0,i,t));if(x)for(var f=0,o=n.length;o>f;f++){var v=n[f]*t,l=o-1>f?n[f+1]*t:e.length;u-=Math.abs(_(e,v,l,t))}var y=0;for(f=0;f<r.length;f+=3){var p=r[f]*t,a=r[f+1]*t,h=r[f+2]*t;y+=Math.abs((e[p]-e[h])*(e[a+1]-e[p+1])-(e[p]-e[a])*(e[h+1]-e[p+1]))}return 0===u&&0===y?0:Math.abs((y-u)/u)},r.flatten=function(e){for(var n=e[0][0].length,t={vertices:[],holes:[],dimensions:n},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;n>u;u++)t.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,t.holes.push(r))}return t}},{}]},{},[1])(1)});

/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var TransformMatrix = __webpack_require__(16);
var TexturedAndNormalizedTintedShader = __webpack_require__(49);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(730);

var SpriteBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxSprites = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.indexBufferObject = null;
    this.indexBufferObjectForMesh = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.tempMatrix = new TransformMatrix();
    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;
    this.drawIndexed = true;
    this.lastDrawIndexed = true;
    this.lastDrawingMesh = false;
    this.drawingMesh = false;
    this.vertexCount = 0;

    this.init(this.glContext);
};

SpriteBatch.prototype.constructor = SpriteBatch;

SpriteBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var indexBufferObjectForMesh = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.indexBufferObjectForMesh = indexBufferObjectForMesh;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        if (this.drawIndexed != this.lastDrawIndexed || this.lastDrawingMesh !== this.drawingMesh || this.isFull())
        {
            this.lastDrawIndexed = this.drawIndexed;
            this.lastDrawingMesh = this.drawingMesh;
            return true;
        }
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.vertexBufferObject.bind();
    },

    flush: function (shader, renderTarget)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0 && this.vertexCount === 0)
        {
            return;
        }
        
        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget);
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);
        if (this.drawIndexed)
        {
            if (this.drawingMesh)
            {
                this.indexBufferObjectForMesh.bind();
                this.indexBufferObjectForMesh.updateResource(this.indexDataBuffer.buffer, 0)
            }
            else
                this.indexBufferObject.bind();

            gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        }
        else
        {
            gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
        }
        
        vertexDataBuffer.clear();
        this.elementCount = 0;
        this.vertexCount = 0;

        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;
        var location = activeShader == this.shader ? this.viewMatrixLocation : activeShader.getUniformLocation('u_view_matrix');
        this.width = width * resolution;
        this.height = height * resolution;
        this.setProjectionMatrix(activeShader, location);
    },

    setProjectionMatrix: function (shader, location)
    {
        shader.setConstantMatrix4x4(
            location,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    addMeshIndexed: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;
        var vertices = gameObject.vertices;
        var uv = gameObject.uv;
        var length = vertices.length;
        var totalVertices = (length / 2)|0;
        var indexBuffer = this.indexDataBuffer.uintView;
        var indices = gameObject.indices;
        var colors = gameObject.colors;
        var alphas = gameObject.alphas;
        var indexLength = indices.length;
        var indexOffset = 0;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        indexOffset = this.vertexCount;
        this.drawIndexed = true;
        this.drawingMesh = true;
        this.vertexCount += totalVertices;

        vertexOffset = vertexDataBuffer.allocate(totalVertices * 6);

        for (var index = 0, index0 = 0; index < length; index += 2)
        {
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var tx = x * mva + y * mvc + mve;
            var ty = x * mvb + y * mvd + mvf;
            vertexBufferObjectF32[vertexOffset++] = tx;
            vertexBufferObjectF32[vertexOffset++] = ty;
            vertexBufferObjectF32[vertexOffset++] = uv[index + 0];
            vertexBufferObjectF32[vertexOffset++] = uv[index + 1];
            vertexBufferObjectU32[vertexOffset++] = colors[index0];
            vertexBufferObjectF32[vertexOffset++] = alphas[index0];
            index0 += 1;
        }
        var elementCount = this.elementCount;
        for (var index = 0; index < indexLength; ++index)
        {
            indexBuffer[elementCount + index] = indexOffset + indices[index];
        }

        this.elementCount += indexLength;
    },

    addMesh: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;
        var vertices = gameObject.vertices;
        var uv = gameObject.uv;
        var colors = gameObject.colors;
        var alphas = gameObject.alphas;
        var length = vertices.length;
        var totalVertices = (length / 2)|0;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        this.drawIndexed = false;
        this.drawingMesh = true;
        this.vertexCount += totalVertices;

        vertexOffset = vertexDataBuffer.allocate(totalVertices * 6);

        for (var index = 0, index0 = 0; index < length; index += 2)
        {
            var x = vertices[index + 0];
            var y = vertices[index + 1];
            var tx = x * mva + y * mvc + mve;
            var ty = x * mvb + y * mvd + mvf;
            vertexBufferObjectF32[vertexOffset++] = tx;
            vertexBufferObjectF32[vertexOffset++] = ty;
            vertexBufferObjectF32[vertexOffset++] = uv[index + 0];
            vertexBufferObjectF32[vertexOffset++] = uv[index + 1];
            vertexBufferObjectU32[vertexOffset++] = colors[index0];
            vertexBufferObjectF32[vertexOffset++] = alphas[index0];
            index0 += 1;
        }
    },

    addTileTextureRect: function (texture, x, y, width, height, alpha, tint, scrollFactorX, scrollFactorY, textureWidth, textureHeight, rectX, rectY, rectW, rectH, camera, renderTarget)
    {
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var halfTileWidth = (width) * 0.5;
        var halfTileHeight = (height) * 0.5;
        var u0 = (rectX - (halfTileWidth - 0.5)) / textureWidth;
        var v0 = (rectY - (halfTileHeight - 0.5)) / textureHeight;
        var u1 = (rectX + (halfTileWidth - 0.5)) / textureWidth;
        var v1 = (rectY + (halfTileHeight - 0.5)) / textureHeight;
        var scrollX = camera.scrollX * scrollFactorX;
        var scrollY = camera.scrollY * scrollFactorY;
        
        mva = cameraMatrix[0];
        mvb = cameraMatrix[1];
        mvc = cameraMatrix[2];
        mvd = cameraMatrix[3];
        mve = cameraMatrix[4];
        mvf = cameraMatrix[5];

        tx0 = (x * mva + y * mvc + mve) - scrollX;
        ty0 = (x * mvb + y * mvd + mvf) - scrollY;
        tx1 = (x * mva + yh * mvc + mve) - scrollX;
        ty1 = (x * mvb + yh * mvd + mvf) - scrollY;
        tx2 = (xw * mva + yh * mvc + mve) - scrollX;
        ty2 = (xw * mvb + yh * mvd + mvf) - scrollY;
        tx3 = (xw * mva + y * mvc + mve) - scrollX;
        ty3 = (xw * mvb + y * mvd + mvf) - scrollY;

        this.manager.setRenderer(this, texture, renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        this.elementCount += 6;
        vertexOffset = vertexDataBuffer.allocate(24);
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tint; 
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = u0;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tint; 
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v1;
        vertexBufferObjectU32[vertexOffset++] = tint; 
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = u1;
        vertexBufferObjectF32[vertexOffset++] = v0;
        vertexBufferObjectU32[vertexOffset++] = tint;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    },

    addSpriteTexture: function (gameObject, camera, texture, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = textureWidth * (gameObject.flipX ? -1 : 1);
        var height = textureHeight * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + ((textureWidth) * (gameObject.flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + ((textureHeight) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = 1;
        vertexBufferObjectF32[vertexOffset++] = 0;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    },

    addSprite: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = gameObject.frame;
        var alpha = 16777216;
        var forceFlipY = (frame.texture.source[frame.sourceIndex].glTexture.isRenderTexture ? true : false);
        var flipX = gameObject.flipX;
        var flipY = gameObject.flipY ^ forceFlipY;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (flipX ? -1 : 1);
        var height = frame.height * (flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -gameObject.displayOriginX + frame.x + ((frame.width) * (flipX ? 1 : 0.0));
        var y = -gameObject.displayOriginY + frame.y + ((frame.height) * (flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, frame.texture.source[frame.sourceIndex].glTexture, gameObject.renderTarget);
        this.drawIndexed = true;
        this.drawingMesh = false;
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = uvs.x0;
        vertexBufferObjectF32[vertexOffset++] = uvs.y0;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = uvs.x1;
        vertexBufferObjectF32[vertexOffset++] = uvs.y1;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = uvs.x2;
        vertexBufferObjectF32[vertexOffset++] = uvs.y2;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = uvs.x3;
        vertexBufferObjectF32[vertexOffset++] = uvs.y3;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    }

};

module.exports = SpriteBatch;


/***/ }),
/* 730 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000
    
};

module.exports = CONST;


/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var TransformMatrix = __webpack_require__(16);
var TexturedAndNormalizedTintedShader = __webpack_require__(49);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(732);

var TileBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxSprites = null;
    this.shader = null;
    this.vertexBufferObject = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.tempMatrix = new TransformMatrix();
    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

TileBatch.prototype.constructor = TileBatch;

TileBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new DataBuffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new DataBuffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var shader = this.manager.resourceManager.createShader('TexturedAndNormalizedTintedShader', TexturedAndNormalizedTintedShader);
        var indexBufferObject = this.manager.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);
        var vertexBufferObject = this.manager.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.shader = shader;
        this.indexBufferObject = indexBufferObject;
        this.vertexBufferObject = vertexBufferObject;
        this.viewMatrixLocation = viewMatrixLocation;

        vertexBufferObject.addAttribute(shader.getAttribLocation('a_position'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_tex_coord'), 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_color'), 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16);
        vertexBufferObject.addAttribute(shader.getAttribLocation('a_alpha'), 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20);

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        indexBufferObject.updateResource(indexBuffer, 0);

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
        this.indexBufferObject.bind();
        this.vertexBufferObject.bind();
    },

    flush: function (shader, renderTarget)
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.elementCount === 0)
        {
            return;
        }
        
        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget);
        }

        this.bind(shader);
        this.vertexBufferObject.updateResource(vertexDataBuffer.getUsedBufferAsFloat(), 0);
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();
        this.elementCount = 0;

        if (renderTarget)
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;
        var location = activeShader == this.shader ? this.viewMatrixLocation : activeShader.getUniformLocation('u_view_matrix');
        this.width = width * resolution;
        this.height = height * resolution;
        this.setProjectionMatrix(activeShader, location);
    },

    setProjectionMatrix: function (shader, location)
    {
        shader.setConstantMatrix4x4(
            location,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);
        this.manager.resourceManager.deleteBuffer(this.indexBufferObject);
        this.manager.resourceManager.deleteBuffer(this.vertexBufferObject);

        this.shader = null;
        this.indexBufferObject = null;
        this.vertexBufferObject = null;
    },

    addTileSprite: function (gameObject, camera)
    {
        var tempMatrix = this.tempMatrix;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferObjectF32 = vertexDataBuffer.floatView;
        var vertexBufferObjectU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = gameObject.width * (gameObject.flipX ? -1 : 1);
        var height = gameObject.height * (gameObject.flipY ? -1 : 1);
        var translateX = gameObject.x - camera.scrollX * gameObject.scrollFactorX;
        var translateY = gameObject.y - camera.scrollY * gameObject.scrollFactorY;
        var scaleX = gameObject.scaleX;
        var scaleY = gameObject.scaleY;
        var rotation = -gameObject.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var displayOriginX = gameObject.originX * gameObject.width;
        var displayOriginY = gameObject.originY * gameObject.height;
        var x = -displayOriginX + ((gameObject.width) * (gameObject.flipX ? 1 : 0.0));
        var y = -displayOriginY + ((gameObject.height) * (gameObject.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var u0 = 0;
        var v0 = 0;
        var u1 = width / gameObject.frame.width;
        var v1 = height / gameObject.frame.height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = gameObject.alpha;
        var tilePositionX = gameObject.tilePositionX / gameObject.frame.width;
        var tilePositionY = gameObject.tilePositionY / gameObject.frame.height;
        var texture = gameObject.tileTexture;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setRenderer(this, texture, gameObject.renderTarget);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferObjectF32[vertexOffset++] = tx0;
        vertexBufferObjectF32[vertexOffset++] = ty0;
        vertexBufferObjectF32[vertexOffset++] = u0 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v0 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx1;
        vertexBufferObjectF32[vertexOffset++] = ty1;
        vertexBufferObjectF32[vertexOffset++] = u0 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v1 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx2;
        vertexBufferObjectF32[vertexOffset++] = ty2;
        vertexBufferObjectF32[vertexOffset++] = u1 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v1 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;

        vertexBufferObjectF32[vertexOffset++] = tx3;
        vertexBufferObjectF32[vertexOffset++] = ty3;
        vertexBufferObjectF32[vertexOffset++] = u1 + tilePositionX;
        vertexBufferObjectF32[vertexOffset++] = v0 + tilePositionY;
        vertexBufferObjectU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
        vertexBufferObjectF32[vertexOffset++] = alpha;
    }

};

module.exports = TileBatch;


/***/ }),
/* 732 */
/***/ (function(module, exports) {

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000
    
};

module.exports = CONST;


/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

var DataBuffer32 = __webpack_require__(33);
var DataBuffer16 = __webpack_require__(39);
var TilemapShader = __webpack_require__(740);

var PHASER_CONST = __webpack_require__(6);
var CONST = __webpack_require__(208);

var TilemapRenderer = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.shader = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

TilemapRenderer.prototype.constructor = TilemapRenderer;

TilemapRenderer.prototype = {

    init: function (gl)
    {
        var shader = this.manager.resourceManager.createShader('TilemapShader', TilemapShader);
        var viewMatrixLocation = shader.getUniformLocation('u_view_matrix');
        var scrollLocation = shader.getUniformLocation('u_scroll');
        var scrollFactorLocation = shader.getUniformLocation('u_scroll_factor');
        var tilemapPositionLocation = shader.getUniformLocation('u_tilemap_position');

        this.shader = shader;
        this.viewMatrixLocation = viewMatrixLocation;
        this.scrollLocation = scrollLocation;
        this.scrollFactorLocation = scrollFactorLocation;
        this.tilemapPositionLocation = tilemapPositionLocation;

        this.resize(this.width, this.height, this.game.config.resolution);
    },

    shouldFlush: function ()
    {
        return false;
    },

    isFull: function ()
    {
        return false;
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        
    },

    bind: function (shader)
    {
        if (shader === undefined)
        {
            this.shader.bind();
        }
        else
        {
            shader.bind();
            this.resize(this.width, this.height, this.game.config.resolution, shader);
        }
    },

    flush: function (shader)
    {
    },

    resize: function (width, height, resolution, shader)
    {
        var gl = this.glContext;
        var activeShader = shader !== undefined ? shader : this.shader;
        
        this.width = width * resolution;
        this.height = height * resolution;

        activeShader.setConstantMatrix4x4(
            this.viewMatrixLocation,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        this.manager.resourceManager.deleteShader(this.shader);

        this.shader = null;
    }
};

module.exports = TilemapRenderer;


/***/ }),
/* 734 */
/***/ (function(module, exports) {


var IndexBuffer = function (gl, bufferObject) 
{
    this.gl = gl;
    this.bufferTarget = gl.ELEMENT_ARRAY_BUFFER;
    this.bufferObject = bufferObject;
};

IndexBuffer.prototype.constructor = IndexBuffer;

IndexBuffer.prototype = {

    bind: function ()
    {
        var gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferObject);
        return this;
    },

    updateResource: function (bufferData, offset)
    {
        var gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, bufferData);
        return this;
    }

};

module.exports = IndexBuffer;


/***/ }),
/* 735 */
/***/ (function(module, exports) {

var RenderTarget = function (framebufferObject, width, height, colorBuffer, depthStencilBuffer)
{
    this.framebufferObject = framebufferObject;
    this.width = width;
    this.height = height;
    this.colorBuffer = colorBuffer;
    this.depthStencilBuffer = depthStencilBuffer;
    this.shouldClear = false;
};

module.exports = RenderTarget;


/***/ }),
/* 736 */
/***/ (function(module, exports) {

var Shader = function(name, gl, program, vertexShader, fragmentShader) 
{
    this.gl = gl;
    this.program = program;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.name = name;
};

Shader.prototype.constructor = Shader;

/* For WebGL2 this won't be necessary */
Shader.prototype = {

    getUniformLocation: function(name) 
    {
        return this.gl.getUniformLocation(this.program, name);
    },

    getAttribLocation: function (name)
    {
        return this.gl.getAttribLocation(this.program, name);
    },  

    setConstantFloat1: function(location, x) 
    {
        this.gl.useProgram(this.program);
        this.gl.uniform1f(location, x);
        return this;
    },
    
    setConstantFloat2: function(location, x, y) 
    {
        this.gl.useProgram(this.program);
        this.gl.uniform2f(location, x, y);
        return this;
    },
    
    setConstantFloat3: function(location, x, y, z) {
        this.gl.useProgram(this.program);
        this.gl.uniform3f(location, x, y, z);
        return this;
    },
    
    setConstantFloat4: function(location, x, y, z, w) {
        this.gl.useProgram(this.program);
        this.gl.uniform4f(location, x, y, z, w);
        return this;
    },
    
    setConstantInt1: function(location, x) {
        this.gl.useProgram(this.program);
        this.gl.uniform1i(location, x);
        return this;
    },
    
    setConstantInt2: function(location, x, y) {
        this.gl.useProgram(this.program);
        this.gl.uniform2i(location, x, y);
        return this;
    },
    
    setConstantInt3: function(location, x, y, z) {
        this.gl.useProgram(this.program);
        this.gl.uniform3i(location, x, y, z);
        return this;
    },
    
    setConstantInt4: function(location, x, y, z, w) {
        this.gl.useProgram(this.program);
        this.gl.uniform4i(location, x, y, z, w);
        return this;
    },
    
    setConstantMatrix2x2: function(location, floatArray) {
        this.gl.useProgram(this.program);
        this.gl.uniformMatrix2fv(location, false, floatArray);
        return this;
    },
    
    setConstantMatrix3x3: function(location, floatArray) {
        this.gl.useProgram(this.program);
        this.gl.uniformMatrix3fv(location, false, floatArray);
        return this;
    },
    
    setConstantMatrix4x4: function(location, floatArray) {
        this.gl.useProgram(this.program);
        this.gl.uniformMatrix4fv(location, false, floatArray);
        return this;
    },

    bind: function ()
    {
        this.gl.useProgram(this.program);
        return this;
    }
    
};

module.exports = Shader;


/***/ }),
/* 737 */
/***/ (function(module, exports) {

var Texture = function (texture, width, height) 
{
    this.texture = texture;
    this.width = width;
    this.height = height;
    this.isRenderTexture = false;
};

Texture.prototype.constructor = Texture;

module.exports = Texture;


/***/ }),
/* 738 */
/***/ (function(module, exports) {

var VertexBuffer = function (gl, bufferObject) 
{
    this.gl = gl;
    this.bufferTarget = gl.ARRAY_BUFFER;
    this.bufferObject = bufferObject;
    this.attributes = [];
};

VertexBuffer.prototype.constructor = VertexBuffer;

VertexBuffer.prototype = {

    addAttribute: function (index, size, type, normalized, stride, offset)
    {
        this.attributes.push({
            index: index,
            size: size,
            type: type,
            normalized: normalized,
            stride: stride,
            offset: offset
        });
        return this;
    },

    updateResource: function (bufferData, offset)
    {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferObject);
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, bufferData);
        return this;
    },

    bind: function ()
    {
        var gl = this.gl;
        var bufferObject = this.bufferObject;
        var attributes = this.attributes;
        var attributesLength = attributes.length;

        gl.bindBuffer(gl.ARRAY_BUFFER, bufferObject);
        for (var index = 0; index < attributesLength; ++index)
        {
            var element = attributes[index];
            if (element !== undefined && element !== null) 
            {
                gl.enableVertexAttribArray(element.index);
                gl.vertexAttribPointer(
                    element.index, 
                    element.size, 
                    element.type, 
                    element.normalized, 
                    element.stride, 
                    element.offset
                );
            }
        }
        return this;
    }

};

module.exports = VertexBuffer;


/***/ }),
/* 739 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'attribute float a_alpha;',
        'varying vec2 v_tex_coord;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(1.0, 1.0, 1.0, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 740 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'uniform vec2 u_scroll;',
        'uniform vec2 u_scroll_factor;',
        'uniform vec2 u_tilemap_position;',
        'attribute vec2 a_position;',
        'attribute vec2 a_tex_coord;',
        'varying vec2 v_tex_coord;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(u_tilemap_position + a_position + (u_scroll * u_scroll_factor), 1.0, 1.0);',
        '   v_tex_coord = a_tex_coord;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'uniform sampler2D u_sampler2D;',
        'varying vec2 v_tex_coord;',
        'void main() {',
        '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord);',
        '}'
    ].join('\n')
};


/***/ }),
/* 741 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'precision mediump float;',
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec4 a_color;',
        'attribute float a_alpha;',
        'varying vec4 v_color;',
        'varying float v_alpha;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_color = a_color;',
        '   v_alpha = a_alpha;',
        '}'
    ].join('\n'),
    frag: [
        'precision mediump float;',
        'varying vec4 v_color;',
        'varying float v_alpha;',
        'void main() {',
        '   gl_FragColor = vec4(v_color.bgr, v_alpha);',
        '}'
    ].join('\n')
};


/***/ }),
/* 742 */
/***/ (function(module, exports) {

module.exports = {
    vert: [
        'uniform mat4 u_view_matrix;',
        'attribute vec2 a_position;',
        'attribute vec4 a_color;',
        'varying vec4 v_color;',
        'void main () {',
        '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
        '   v_color = a_color;',
        '}'
    ].join('\n'),
    frag:[
        'precision lowp float;',
        'varying vec4 v_color;',
        'void main() {',
        '   gl_FragColor = v_color;',
        '}'
    ].join('\n')
};


/***/ }),
/* 743 */
/***/ (function(module, exports) {

var CanvasSnapshot = function (canvas) 
{
    var src = canvas.toDataURL();
    var image =  new Image();
    image.src = src;
    return image;
};

module.exports = CanvasSnapshot;


/***/ }),
/* 744 */
/***/ (function(module, exports) {

var WebGLSnapshot = function (canvas) 
{
    var gl = canvas.getContext('experimental-webgl');
    var pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var imageData;
    canvas.width = gl.drawingBufferWidth;
    canvas.height = gl.drawingBufferHeight;

    imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var data = imageData.data;
    for (var y = 0; y <  canvas.height; y += 1)
    {
        for (var x = 0; x < canvas.width; x += 1)
        {
            var si = ((canvas.height - y) * canvas.width + x) * 4;
            var di = (y * canvas.width + x) * 4;
            data[di + 0] = pixels[si + 0];
            data[di + 1] = pixels[si + 1];
            data[di + 2] = pixels[si + 2];
            data[di + 3] = pixels[si + 3];
        }
    }
    ctx.putImageData(imageData, 0, 0);

    var src = canvas.toDataURL();
    var image =  new Image();
    image.src = src;

    return image;
};

module.exports = WebGLSnapshot;


/***/ }),
/* 745 */
/***/ (function(module, exports, __webpack_require__) {


var Between = __webpack_require__(85);
var GetValue = __webpack_require__(0);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetValue(config, 'frequency', 200);
    this.attack = GetValue(config, 'attack', 0);
    this.decay = GetValue(config, 'decay', 1);
    this.type = GetValue(config, 'type', 'sine');
    this.volumeValue = GetValue(config, 'volume', 1);
    this.panValue = GetValue(config, 'pan', 0);
    this.wait = GetValue(config, 'wait', 0);
    this.pitchBendAmount = GetValue(config, 'pitchBend', 0);
    this.reverse = GetValue(config, 'reverse', false);
    this.randomValue = GetValue(config, 'random', 0);
    this.dissonance = GetValue(config, 'dissonance', 0);
    this.echo = GetValue(config, 'echo', false);
    this.echoDelay = GetValue(config, 'echo.delay', 0);
    this.echoFeedback = GetValue(config, 'echo.feedback', 0);
    this.echoFilter = GetValue(config, 'echo.filter', 0);
    this.reverb = GetValue(config, 'reverb', false);
    this.reverbDuration = GetValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetValue(config, 'reverb.reverse', false);
    this.timeout = GetValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ }),
/* 746 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(745)

};


/***/ }),
/* 747 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var NOOP = __webpack_require__(60);
var State = __webpack_require__(100);
var Systems = __webpack_require__(211);
var GetValue = __webpack_require__(0);
var EventDispatcher = __webpack_require__(15);
var Rectangle = __webpack_require__(27);
var CanvasPool = __webpack_require__(9);
var CanvasInterpolation = __webpack_require__(63);
var GetContext = __webpack_require__(103);

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.GlobalStateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GlobalStateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0),
                    data: {}
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true,
                data: {}
            });
        }
    }
};

GlobalStateManager.prototype.constructor = GlobalStateManager;

GlobalStateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.GlobalStateManager#boot
    * @private
    */
    boot: function ()
    {
        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    //  private
    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the GlobalStateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.GlobalStateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            console.log('GlobalStateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        // console.log('GlobalStateManager.add', key, stateConfig, autoStart);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('GlobalStateManager.add from instance:', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('GlobalStateManager.add from object:', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('GlobalStateManager.add from function:', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.settings.key = key;

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.sys = new Systems(newState);

            newState.sys.init(this.game);

            this.createStateDisplay(newState);

            //  Default required functions

            if (!newState.init)
            {
                newState.init = NOOP;
            }

            if (!newState.preload)
            {
                newState.preload = NOOP;
            }

            if (!newState.create)
            {
                newState.create = NOOP;
            }

            if (!newState.shutdown)
            {
                newState.shutdown = NOOP;
            }

            if (!newState.update)
            {
                newState.update = NOOP;
            }

            if (!newState.render)
            {
                newState.render = NOOP;
            }

            return newState;
        }
    },

    setupCallbacks: function (state, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = state; }

        //  Extract callbacks or set NOOP

        state.init = GetValue(stateConfig, 'init', NOOP);
        state.preload = GetValue(stateConfig, 'preload', NOOP);
        state.create = GetValue(stateConfig, 'create', NOOP);
        state.shutdown = GetValue(stateConfig, 'shutdown', NOOP);

        //  Game Loop level callbacks

        state.update = GetValue(stateConfig, 'update', NOOP);
        state.render = GetValue(stateConfig, 'render', NOOP);

        return state;
    },

    createStateDisplay: function (state)
    {
        // console.log('createStateDisplay', state.settings.key);

        var settings = state.sys.settings;

        // var x = settings.x;
        // var y = settings.y;
        var width = settings.width;
        var height = settings.height;

        var config = this.game.config;

        if (config.renderType === CONST.CANVAS)
        {
            if (settings.renderToTexture)
            {
                // console.log('renderToTexture', width, height);
                state.sys.canvas = CanvasPool.create(state, width, height);
                state.sys.context = GetContext(state.sys.canvas);

                //  Pixel Art mode?
                if (config.pixelArt)
                {
                    CanvasInterpolation.setCrisp(state.sys.canvas);
                }
            }
            else
            {
                // console.log('using game canvas');
                state.sys.mask = new Rectangle(0, 0, width, height);
                state.sys.canvas = this.game.canvas;
                state.sys.context = this.game.context;
            }
        }
        else if (config.renderType === CONST.WEBGL)
        {
            // state.sys.fbo = this.game.renderer.createFBO(state, x, y, width, height);
        }
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        var index = -1;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                index = this.active[i].index;
            }
        }

        return index;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key, data)
    {
        if (data === undefined) { data = {}; }

        // console.log('start:', key);
        // console.dir(data);

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('GlobalStateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                    entry.data = data;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            state.settings.data = data;

            var loader = state.sys.load;

            //  Files payload?
            if (loader && Array.isArray(state.sys.settings.files))
            {
                loader.reset();

                if (loader.loadArray(state.sys.settings.files))
                {
                    loader.events.once('LOADER_COMPLETE_EVENT', this.payloadComplete.bind(this));

                    loader.start();
                }
                else
                {
                    this.bootState(state);
                }
            }
            else
            {
                this.bootState(state);
            }
        }
    },

    payloadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('payloadComplete', state.sys.settings.key);

        this.bootState(state);
    },

    bootState: function (state)
    {
        // console.log('bootState', state.sys.settings.key);

        if (state.init)
        {
            state.init.call(state, state.sys.settings.data);
        }

        var loader = state.sys.load;
            
        loader.reset();

        if (state.preload)
        {
            state.preload(this.game);

            //  Is the loader empty?
            if (loader.list.size === 0)
            {
                this.create(state);
            }
            else
            {
                //  Start the loader going as we have something in the queue

                loader.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                loader.start();
            }
        }
        else
        {
            //  No preload? Then there was nothing to load either
            this.create(state);
        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('loadComplete', state.sys.settings.key);

        this.create(state);
    },

    create: function (state)
    {
        // console.log('create', state.sys.settings.key);
        // console.log(state);

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        // console.log('create.index', state.sys.settings.key, i);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates);

        state.sys.updates.running = true;

        if (state.create)
        {
            state.create.call(state, state.sys.settings.data);
        }
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(this.getState(key));

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates);
        }
    },

    sortStates: function (stateA, stateB)
    {
        // console.log('sortStates', stateA.state.sys.settings.key, stateA.index, stateB.state.sys.settings.key, stateB.index);

        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

};

module.exports = GlobalStateManager;


/***/ }),
/* 748 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(749);
var ScaleModes = __webpack_require__(38);
var GetValue = __webpack_require__(0);

var Settings = {

    create: function (config)
    {
        if (typeof config === 'string')
        {
            config = { key: config };
        }
        else if (config === undefined)
        {
            //  Pass the 'hasOwnProperty' checks
            config = {};
        }

        return {

            status: CONST.PENDING,

            op: CONST.BOOT,

            key: GetValue(config, 'key', ''),
            active: GetValue(config, 'active', false),
            visible: GetValue(config, 'visible', true),

            //  Loader payload array

            data: {},

            files: GetValue(config, 'files', false),

            //  -1 means the State Manager will set it to be the Game dimensions

            x: GetValue(config, 'x', 0),
            y: GetValue(config, 'y', 0),
            rotation: GetValue(config, 'rotation', 0),
            width: GetValue(config, 'width', -1),
            height: GetValue(config, 'height', -1),

            //  State Render Settings (applies only to this State)

            scaleMode: GetValue(config, 'scaleMode', ScaleModes.DEFAULT),
            roundPixels: GetValue(config, 'roundPixels', false),

            dirtyRender: GetValue(config, 'dirtyRender', false),
            renderToTexture: GetValue(config, 'renderToTexture', false),

            //  The following only apply if renderToTexture is true

            autoResize: GetValue(config, 'autoResize', false),
            transparent: GetValue(config, 'transparent', false),
            clearBeforeRender: GetValue(config, 'clearBeforeRender', true),
            backgroundColor: GetValue(config, 'backgroundColor', false)

        };
    },

    init: function (config, gameConfig)
    {
        if (config.width === -1)
        {
            config.width = gameConfig.width;
        }

        if (config.height === -1)
        {
            config.height = gameConfig.height;
        }
    }

};

module.exports = Settings;


/***/ }),
/* 749 */
/***/ (function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ }),
/* 750 */
/***/ (function(module, exports, __webpack_require__) {

var Camera = __webpack_require__(102);
var KeyControl = __webpack_require__(331);
var SmoothedKeyControl = __webpack_require__(332);

var CameraManager = function (state)
{
    this.state = state;

    this.cameras = [];
    this.cameraPool = [];

    this.main = this.add();
};

CameraManager.prototype.constructor = CameraManager;

CameraManager.prototype = {

    add: function (x, y, width, height)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = this.state.sys.width; }
        if (height === undefined) { height = this.state.sys.height; }

        var camera = null;

        if (this.cameraPool.length > 0)
        {
            camera = this.cameraPool.pop();
            camera.setViewport(x, y, width, height);
        }
        else
        {
            camera = new Camera(x, y, width, height);
        }

        camera.setState(this.state);

        this.cameras.push(camera);

        return camera;
    },

    addKeyControl: function (config)
    {
        return new KeyControl(config);
    },

    addSmoothedKeyControl: function (config)
    {
        return new SmoothedKeyControl(config);
    },

    addReference: function (camera)
    {
        var index = this.cameras.indexOf(camera);
        var poolIndex = this.cameraPool.indexOf(camera);

        if (index < 0 && poolIndex >= 0)
        {
            this.cameras.push(camera);
            this.cameraPool.slice(poolIndex, 1);
            return camera;
        }
        
        return null;
    },

    remove: function (camera)
    {
        var cameraIndex = this.cameras.indexOf(camera);

        if (cameraIndex >= 0)
        {
            this.cameraPool.push(this.cameras[cameraIndex]);
            this.cameras.splice(cameraIndex, 1);
        }
    },

    resetAll: function ()
    {
        while (this.cameras.length > 0)
        {
            this.cameraPool.push(this.cameras.pop());
        }

        this.main = this.add();
    },

    update: function (timestep, delta)
    {
        for (var i = 0, l = this.cameras.length; i < l; ++i)
        {
            this.cameras[i].update(timestep, delta);
        }
    },

    render: function (renderer, children, interpolation)
    {
        var cameras = this.cameras;
        for (var i = 0, l = cameras.length; i < l; ++i)
        {
            var camera = cameras[i];

            camera.preRender();

            renderer.render(this.state, children, interpolation, camera);
        }

    },

    destroy: function ()
    {
        this.main = undefined;

        for (var i = 0; i < this.cameras.length; i++)
        {
            this.cameras[i].destroy();
        }

        for (i = 0; i < this.cameraPool.length; i++)
        {
            this.cameraPool[i].destroy();
        }

        this.cameras = [];
        this.cameraPool = [];
        this.state = undefined;
    }

};

module.exports = CameraManager;


/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(3);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectCreator = function (state)
{
    this.state = state;

    this.children = state.sys.children;

    FactoryContainer.load(this, false);
};

GameObjectCreator.prototype.constructor = GameObjectCreator;

GameObjectCreator.prototype = {

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectCreator;


/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(3);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectFactory = function (state)
{
    this.state = state;

    this.children = state.sys.children;

    FactoryContainer.load(this, true);
};

GameObjectFactory.prototype.constructor = GameObjectFactory;

GameObjectFactory.prototype = {

    existing: function (child)
    {
        return this.children.add(child);
    },

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectFactory;


/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(10);
var BaseLoader = __webpack_require__(627);
var NumberArray = __webpack_require__(222);

var ImageFile = __webpack_require__(44);
var AnimationJSONFile = __webpack_require__(633);
var JSONFile = __webpack_require__(84);
var XMLFile = __webpack_require__(174);
var BinaryFile = __webpack_require__(635);
var GLSLFile = __webpack_require__(637);
var TextFile = __webpack_require__(641);
var AtlasJSONFile = __webpack_require__(634);
var BitmapFontFile = __webpack_require__(636);
var SpriteSheet = __webpack_require__(640);
var SVGFile = __webpack_require__(639);
var HTMLFile = __webpack_require__(638);

var ParseXMLBitmapFont = __webpack_require__(391);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.loadArray = function (files)
{
    if (Array.isArray(files))
    {
        for (var i = 0; i < files.length; i++)
        {
            this.file(files[i]);
        }
    }

    return (this.list.size > 0);
};

Loader.prototype.file = function (file)
{
    var entry;

    switch (file.type)
    {
        case 'image':
        case 'json':
        case 'xml':
        case 'binary':
        case 'text':
        case 'glsl':
        case 'svg':
            entry = this[file.type](file.key, file.url, file.xhrSettings);
            break;

        case 'spritesheet':
            entry = this.spritesheet(file.key, file.url, file.config, file.xhrSettings);
            break;

        case 'atlas':
            entry = this.atlas(file.key, file.textureURL, file.atlasURL, file.textureXhrSettings, file.atlasXhrSettings);
            break;

        case 'bitmapFont':
            entry = this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.textureXhrSettings, file.xmlXhrSettings);
            break;

        case 'multiatlas':
            entry = this.multiatlas(file.key, file.textureURLs, file.atlasURLs, file.textureXhrSettings, file.atlasXhrSettings);
            break;
    }

    return entry;
};

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.animation = function (key, url, xhrSettings)
{
    var file = new AnimationJSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing
Loader.prototype.spritesheet = function (key, url, config, xhrSettings)
{
    var file = new SpriteSheet(key, url, config, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.html = function (key, url, width, height, xhrSettings)
{
    var file = new HTMLFile(key, url, width, height, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.bitmapFont = function (key, textureURL, xmlURL, textureXhrSettings, xmlXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new BitmapFontFile(key, textureURL, xmlURL, this.path, textureXhrSettings, xmlXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.svg = function (key, url, xhrSettings)
{
    var file = new SVGFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;
        var suffix = (atlasURLs === undefined) ? '' : atlasURLs;

        textureURLs = NumberArray(0, total, key + suffix, '.png');
        atlasURLs = NumberArray(0, total, key + suffix, '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var cache = this.state.sys.cache;
    var textures = this.state.sys.textures;
    var anims = this.state.sys.anims;

    //  Process multiatlas groups first

    var file;
    var fileA;
    var fileB;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    //  Process all of the files

    //  Because AnimationJSON may require images to be loaded first, we process them last
    var animJSON = [];

    this.storage.each(function (file)
    {
        switch (file.type)
        {
            case 'animationJSON':
                animJSON.push(file);
                break;

            case 'image':
            case 'svg':
            case 'html':
                textures.addImage(file.key, file.data);
                break;

            case 'atlasjson':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    textures.addAtlas(fileA.key, fileA.data, fileB.data);
                }
                else
                {
                    textures.addAtlas(fileB.key, fileB.data, fileA.data);
                }
                break;

            case 'bitmapfont':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    cache.bitmapFont.add(fileB.key, ParseXMLBitmapFont(fileB.data));
                    textures.addImage(fileA.key, fileA.data);
                }
                else
                {
                    cache.bitmapFont.add(fileA.key, ParseXMLBitmapFont(fileA.data));
                    textures.addImage(fileB.key, fileB.data);
                }
                break;

            case 'spritesheet':
                textures.addSpriteSheet(file.key, file.data, file.config);
                break;

            case 'json':
                cache.json.add(file.key, file.data);
                break;

            case 'xml':
                cache.xml.add(file.key, file.data);
                break;

            case 'text':
                cache.text.add(file.key, file.data);
                break;

            case 'binary':
                cache.binary.add(file.key, file.data);
                break;

            case 'sound':
                cache.sound.add(file.key, file.data);
                break;

            case 'glsl':
                cache.shader.add(file.key, file.data);
                break;
        }
    });

    animJSON.forEach(function (file)
    {
        anims.fromJSON(file.data);
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ }),
/* 754 */
/***/ (function(module, exports) {

//  A proxy class to the Global State Manager

var StateManager = function (state, game)
{
    //  The State that owns this StateManager
    this.state = state;

    this.key = state.sys.settings.key;

    //  GlobalStateManager
    this.manager = game.state;
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    //  Start this State (or the one given via key)
    start: function (key, data)
    {
        if (key === undefined) { key = this.key; }

        this.manager.start(key, data);
    },

    //  Pause this State (or the one given via key)
    pause: function (key)
    {
        if (key === undefined) { key = this.key; }

        this.manager.pause(key);
    },

    //  Stop this State and start the one given
    swap: function (key)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    moveUp: function ()
    {

    },

    moveDown: function ()
    {

    },

    bringToTop: function ()
    {

    },

    sendToBack: function ()
    {

    },

    //  TODO
    transitionTo: function (key, duration)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    isActive: function (key)
    {
        if (key === undefined) { key = this.key; }

        return this.manager.isActive(key);
    }

};

module.exports = StateManager;


/***/ }),
/* 755 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ }),
/* 756 */
/***/ (function(module, exports) {

// The keys of a Map can be arbitrary values.

/*
var map = new Map([
    [ 1, 'one' ],
    [ 2, 'two' ],
    [ 3, 'three' ]
]);
*/

var Map = function (elements)
{
    this.entries = {};

    this.size = 0;

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.set(elements[i][0], elements[i][1]);
        }
    }
};

Map.prototype.constructor = Map;

Map.prototype = {

    set: function (key, value)
    {
        if (!this.has(key))
        {
            this.entries[key] = value;
            this.size++;
        }

        return this;
    },

    get: function (key)
    {
        if (this.has(key))
        {
            return this.entries[key];
        }
    },

    has: function (key)
    {
        return (this.entries.hasOwnProperty(key));
    },

    delete: function (key)
    {
        if (this.has(key))
        {
            delete this.entries[key];
            this.size--;
        }

        return this;
    },

    clear: function ()
    {
        Object.keys(this.entries).forEach(function (prop)
        {
            delete this.entries[prop];
        });

        this.size = 0;

        return this;
    },

    keys: function ()
    {
        return Object.keys(this.entries);
    },

    values: function ()
    {
        var output = [];
        var entries = this.entries;

        for (var key in entries)
        {
            output.push(entries[key]);
        }

        return output;
    },

    dump: function ()
    {
        var entries = this.entries;

        console.group('Map');

        for (var key in entries)
        {
            console.log(key, entries[key]);
        }

        console.groupEnd();
    },


    each: function (callback)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (callback(key, entries[key]) === false)
            {
                break;
            }
        }

        return this;
    },

    contains: function (value)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (entries[key] === value)
            {
                return true;
            }
        }

        return false;
    },

    //  Merges all new keys from the given Map into this one
    //  If it encounters a key that already exists it will be skipped
    //  unless override = true
    merge: function (map, override)
    {
        if (override === undefined) { override = false; }

        var local = this.entries;
        var source = map.entries;

        for (var key in source)
        {
            if (local.hasOwnProperty(key) && override)
            {
                local[key] = source[key];
            }
            else
            {
                this.set(key, source[key]);
            }
        }

        return this;
    }
};

module.exports = Map;


/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(62);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.centerX = Math.floor(width / 2);

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.centerY = Math.floor(height / 2);

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        radius: 0.5 * Math.sqrt(width * width + height * height),
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;

        this.width = destWidth;
        this.height = destHeight;

        this.centerX = Math.floor(destWidth / 2);
        this.centerY = Math.floor(destHeight / 2);

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = this.cutX / tw;
        uvs.y1 = (this.cutY + this.cutHeight) / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = (this.cutX + this.cutWidth) / tw;
        uvs.y3 = this.cutY / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x3 = (this.cutX + this.cutHeight) / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        uvs.x2 = this.cutX / tw;        
        uvs.y2 = (this.cutY + this.cutWidth) / th;
        
        uvs.x1 = this.cutX / tw;
        uvs.y1 = this.cutY / th;
        
        uvs.x0 = (this.cutX + this.cutHeight) / tw;
        uvs.y0 = this.cutY / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;

        clone.width = this.width;
        clone.height = this.height;

        clone.centerX = this.centerX;
        clone.centerY = this.centerY;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
    * @name Phaser.TextureFrame#radius
    * @property {number} radius
    */
    radius: {

        enumerable: true,

        get: function ()
        {
            return this.data.radius;
        }

    },

    /**
    * Is the Frame trimmed?
    * @name Phaser.TextureFrame#trimmed
    * @property {boolean} trimmed
    */
    trimmed: {

        enumerable: true,

        get: function ()
        {
            return this.data.trim;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ }),
/* 758 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(757);
var TextureSource = __webpack_require__(760);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source, width, height)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.firstFrame = '__BASE';

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i], width, height));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        //  Set the first frame of the Texture (other than __BASE)
        //  This is used to ensure we don't spam the display with entire
        //  atlases of sprite sheets, but instead just the first frame of them
        //  should the dev incorrectly specify the frame index
        if (this.frameTotal === 1)
        {
            this.firstFrame = name;
        }

        this.frameTotal++;

        return frame;
    },

    has: function (name)
    {
        return (this.frames[name]);
    },

    get: function (name)
    {
        if (name === undefined || name === null)
        {
            name = (this.frameTotal === 1) ? '__BASE' : this.firstFrame;
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    getFrameNames: function (includeBase)
    {
        if (includeBase === undefined) { includeBase = false; }

        var out = Object.keys(this.frames);

        if (!includeBase)
        {
            var idx = out.indexOf('__BASE');

            if (idx !== -1)
            {
                out.splice(idx, 1);
            }
        }

        return out;
    },

    getSourceImage: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'].source.image;
        }
        else
        {
            return frame.source.image;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            // console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  TODO
    },

    setFilter: function (filterMode)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].setFilter(filterMode);
        }
    }

};

module.exports = Texture;


/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(769);
var Texture = __webpack_require__(758);
var CanvasPool = __webpack_require__(9);
var GetValue = __webpack_require__(0);
var GenerateTexture = __webpack_require__(105);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function (game)
{
    this.game = game;

    this.list = {};

    this.addBase64('__DEFAULT', game.config.defaultImage);
    this.addBase64('__MISSING', game.config.missingImage);
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addBase64: function (key, data)
    {
        var _this = this;
        var image = new Image();

        image.onload = function ()
        {
            var texture = _this.create(key, image);
        
            Parser.Image(texture, 0);
        };

        image.src = data;
    },

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    generate: function (key, config)
    {
        var canvas = CanvasPool.create(this, 1, 1);

        config.canvas = canvas;

        GenerateTexture(config);

        return this.addCanvas(key, canvas);
    },

    createCanvas: function (key, width, height)
    {
        if (width === undefined) { width = 256; }
        if (height === undefined) { height = 256; }

        var canvas = CanvasPool.create(this, width, height);

        return this.addCanvas(key, canvas);
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    /**
     * [addSpriteSheet description]
     * @param {[type]} key    [description]
     * @param {[type]} source [description]
     * @param {[type]} config [description]
     * @param {number} config.frameWidth - The fixed width of each frame.
     * @param {number} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.
     * @param {number} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     * @param {number} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.
     * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
     */
    addSpriteSheet: function (key, source, config)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, config)
    {
        var atlasKey = GetValue(config, 'atlas', null);
        var atlasFrame = GetValue(config, 'frame', null);

        if (!atlasKey || !atlasFrame)
        {
            return;
        }

        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            // {
            //     "filename": "explosion",
            //     "frame": {"x":2,"y":2,"w":319,"h":312}, = cutX, Y, W, H
            //     "rotated": false,
            //     "trimmed": true,
            //     "spriteSourceSize": {"x":1,"y":6,"w":319,"h":312},
            //     "sourceSize": {"w":320,"h":320},
            //     "pivot": {"x":0.5,"y":0.5}
            // },

            //  If trimmed we need to help the parser adjust

            console.log(sheet);

            if (sheet.trimmed)
            {
                Parser.SpriteSheetFromAtlas(texture, sheet, config);
            }
            else
            {
                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);
            }

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source, width, height)
    {
        var texture = new Texture(this, key, source, width, height);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ }),
/* 760 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(6);
var ScaleModes = __webpack_require__(38);
var IsSizePowerOfTwo = __webpack_require__(197);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source, width, height)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = width || source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = height || source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = ScaleModes.DEFAULT;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmapLevel
    * @type {integer}
    */
    this.mipmapLevel = 0;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;

    var game = texture.manager.game;

    if (game.config.renderType === CONST.WEBGL)
    {
        game.renderer.createTexture(this, width, height);
    }

    if (game.config.pixelArt)
    {
        this.setFilter(1);
    }
};

TextureSource.prototype.setFilter = function (filterMode)
{
    var game = this.texture.manager.game;

    if (game.config.renderType === CONST.WEBGL)
    {
        game.renderer.setTextureFilterMode(this.glTexture, filterMode);
    }
};

module.exports = TextureSource;


/***/ }),
/* 761 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var Canvas = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = Canvas;


/***/ }),
/* 762 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var Image = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = Image;


/***/ }),
/* 763 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArray = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONArray;


/***/ }),
/* 764 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHash = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONHash;


/***/ }),
/* 765 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var Pyxel = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = Pyxel;


/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var GetValue = __webpack_require__(0);

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheet = function (texture, sourceIndex, x, y, width, height, config)
{
    var frameWidth = GetValue(config, 'frameWidth', null);
    var frameHeight = GetValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (frameWidth === null)
    {
        throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.');
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    var startFrame = GetValue(config, 'startFrame', 0);
    var endFrame = GetValue(config, 'endFrame', -1);
    var margin = GetValue(config, 'margin', 0);
    var spacing = GetValue(config, 'spacing', 0);

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheet;


/***/ }),
/* 767 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var GetValue = __webpack_require__(0);

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetFromAtlas = function (texture, frame, config)
{
    var frameWidth = GetValue(config, 'frameWidth', null);
    var frameHeight = GetValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (!frameWidth)
    {
        throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.');
    }

    //  Add in a __BASE entry (for the entire atlas)
    // var source = texture.source[0];
    // texture.add('__BASE', 0, 0, 0, source.width, source.height);

    var startFrame = GetValue(config, 'startFrame', 0);
    var endFrame = GetValue(config, 'endFrame', -1);
    var margin = GetValue(config, 'margin', 0);
    var spacing = GetValue(config, 'spacing', 0);

    var x = frame.cutX;
    var y = frame.cutY;
    var cutWidth = frame.cutWidth;
    var cutHeight = frame.cutHeight;
    var sheetWidth = frame.realWidth;
    var sheetHeight = frame.realHeight;

    var row = Math.floor((sheetWidth - margin) / (frameWidth + spacing));
    var column = Math.floor((sheetHeight - margin) / (frameHeight + spacing));
    var total = row * column;

    console.log('split sheet into rows/cols:', row, column, 'total frames:', total);

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;
    var sheetFrame;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        sheetFrame = texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        // sheetFrame.setTrim(sheetWidth, sheetHeight, )

        // setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)


        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetFromAtlas;


/***/ }),
/* 768 */
/***/ (function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXML = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXML;


/***/ }),
/* 769 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(761),
    Image: __webpack_require__(762),
    JSONArray: __webpack_require__(763),
    JSONHash: __webpack_require__(764),
    Pyxel: __webpack_require__(765),
    SpriteSheet: __webpack_require__(766),
    SpriteSheetFromAtlas: __webpack_require__(767),
    StarlingXML: __webpack_require__(768)
};


/***/ }),
/* 770 */
/***/ (function(module, exports, __webpack_require__) {

var EaseMap = __webpack_require__(669);

var GetEaseFunction = function (ease, easeParams)
{
    if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))
    {
        if (easeParams)
        {
            var cloneParams = easeParams.slice(0);

            cloneParams.unshift(0);

            return function (v)
            {
                cloneParams[0] = v;

                return EaseMap[ease].apply(this, cloneParams);
            };
        }
        else
        {
            //  String based look-up
            return EaseMap[ease];
        }
    }
    else if (typeof ease === 'function')
    {
        //  Custom function
        return ease;
    }
    else if (Array.isArray(ease) && ease.length === 4)
    {
        //  Bezier function (TODO)
    }

    return EaseMap.Power0;
};

module.exports = GetEaseFunction;


/***/ }),
/* 771 */
/***/ (function(module, exports) {

//  RESERVED properties that a Tween config object uses

module.exports = [
    'completeDelay',
    'delay',
    'duration',
    'ease',
    'easeParams',
    'hold',
    'loop',
    'loopDelay',
    'offset',
    'paused',
    'props',
    'repeat',
    'repeatDelay',
    'startAt',
    'targets',
    'useFrames',
    'yoyo'
];


/***/ }),
/* 772 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var Tween = function (manager, data)
{
    this.manager = manager;

    //  An array of TweenData objects, each containing a unique property and target being tweened.
    this.data = data;

    //  data array doesn't change, so we can cache the length
    this.totalData = data.length;

    //  Cached target total (not necessarily the same as the data total)
    this.totalTargets = 0;

    //  If true then duration, delay, etc values are all frame totals
    this.useFrames = false;

    //  Loop this tween? Can be -1 for an infinite loop, or an integer.
    //  When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
    this.loop = 0;

    //  Time in ms/frames before the tween loops.
    this.loopDelay = 0;

    //  How many loops are left to run?
    this.loopCounter = 0;

    //  Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)
    this.completeDelay = 0;

    //  Countdown timer (used by loopDelay and completeDelay)
    this.countdown = 0;

    //  The current state of the tween
    this.state = TWEEN_CONST.PENDING_ADD;

    //  The state of the tween when it was paused (used by Resume)
    this._pausedState = TWEEN_CONST.PENDING_ADD;

    //  Does the Tween start off paused? (if so it needs to be started with Tween.play)
    this.paused = false;

    //  Elapsed time in ms/frames of this run through the Tween.
    this.elapsed = 0;

    //  Total elapsed time in ms/frames of the entire Tween, including looping.
    this.totalElapsed = 0;

    //  Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays
    this.duration = 0;

    //  Value between 0 and 1. The amount through the Tween, excluding loops.
    this.progress = 0;

    //  Time in ms/frames for the Tween to complete (including looping)
    this.totalDuration = 0;

    //  Value between 0 and 1. The amount through the entire Tween, including looping.
    this.totalProgress = 0;

    this.callbacks = {
        onStart: { callback: null, scope: null, params: null },
        onUpdate: { callback: null, scope: null, params: null },
        onRepeat: { callback: null, scope: null, params: null },
        onLoop: { callback: null, scope: null, params: null },
        onComplete: { callback: null, scope: null, params: null }
    };

    this.callbackScope;
};

Tween.prototype.constructor = Tween;

Tween.prototype = {

    calcDuration: __webpack_require__(776),
    init: __webpack_require__(777),
    loadValues: __webpack_require__(778),
    nextState: __webpack_require__(779),
    pause: __webpack_require__(780),
    play: __webpack_require__(781),
    resetTweenData: __webpack_require__(782),
    resume: __webpack_require__(783),
    seek: __webpack_require__(784),
    setEventCallback: __webpack_require__(785),
    update: __webpack_require__(786)

};

module.exports = Tween;


/***/ }),
/* 773 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var GetAdvancedValue = __webpack_require__(14);
var Tween = __webpack_require__(772);
var RESERVED = __webpack_require__(771);
var GetEaseFunction = __webpack_require__(770);
var TweenData = __webpack_require__(774);

var GetTargets = function (config)
{
    var targets = GetValue(config, 'targets', null);

    if (typeof targets === 'function')
    {
        targets = targets.call();
    }

    if (!Array.isArray(targets))
    {
        targets = [ targets ];
    }

    return targets;
};

var GetProps = function (config)
{
    var key;
    var keys = [];

    //  First see if we have a props object

    if (config.hasOwnProperty('props'))
    {
        for (key in config.props)
        {
            keys.push({ key: key, value: config.props[key] });
        }
    }
    else
    {
        for (key in config)
        {
            if (RESERVED.indexOf(key) === -1)
            {
                keys.push({ key: key, value: config[key] });
            }
        }
    }

    return keys;
};

var GetValueOp = function (key, value)
{
    var valueCallback;
    var t = typeof(value);

    if (t === 'number')
    {
        // props: {
        //     x: 400,
        //     y: 300
        // }

        valueCallback = function ()
        {
            return value;
        };
    }
    else if (t === 'string')
    {
        // props: {
        //     x: '+=400',
        //     y: '-=300',
        //     z: '*=2',
        //     w: '/=2'
        // }

        var op = value[0];
        var num = parseFloat(value.substr(2));

        switch (op)
        {
            case '+':
                valueCallback = function (i)
                {
                    return i + num;
                };
                break;

            case '-':
                valueCallback = function (i)
                {
                    return i - num;
                };
                break;

            case '*':
                valueCallback = function (i)
                {
                    return i * num;
                };
                break;

            case '/':
                valueCallback = function (i)
                {
                    return i / num;
                };
                break;

            default:
                valueCallback = function ()
                {
                    return parseFloat(value);
                };
        }
    }
    else if (t === 'function')
    {
        // props: {
        //     x: function (startValue, target, index, totalTargets) { return startValue + (index * 50); },
        // }

        valueCallback = function (startValue, target, index, total)
        {
            return value(startValue, target, index, total);
        };
    }
    else if (value.hasOwnProperty('value'))
    {
        //  Value may still be a string, function or a number
        // props: {
        //     x: { value: 400, ... },
        //     y: { value: 300, ... }
        // }

        valueCallback = GetValueOp(key, value.value);
    }

    return valueCallback;
};

var GetBoolean = function (source, key, defaultValue)
{
    if (!source)
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else
    {
        return defaultValue;
    }
};

var GetNewValue = function (source, key, defaultValue)
{
    var valueCallback;

    if (source.hasOwnProperty(key))
    {
        var t = typeof(source[key]);

        if (t === 'function')
        {
            valueCallback = function (index, totalTargets, target)
            {
                return source[key](index, totalTargets, target);
            };
        }
        else
        {
            valueCallback = function ()
            {
                return source[key];
            };
        }
    }
    else if (typeof defaultValue === 'function')
    {
        valueCallback = defaultValue;
    }
    else
    {
        valueCallback = function ()
        {
            return defaultValue;
        };
    }

    return valueCallback;
};

var TweenBuilder = function (manager, config)
{
    //  Create arrays of the Targets and the Properties
    var targets = GetTargets(config);
    var props = GetProps(config);

    //  Default Tween values
    var easeParams = GetValue(config, 'easeParams', null);
    var ease = GetEaseFunction(GetValue(config, 'ease', 'Power0'), easeParams);
    var duration = GetNewValue(config, 'duration', 1000);
    var yoyo = GetBoolean(config, 'yoyo', false);
    var hold = GetNewValue(config, 'hold', 0);
    var repeat = GetNewValue(config, 'repeat', 0);
    var repeatDelay = GetNewValue(config, 'repeatDelay', 0);
    var delay = GetNewValue(config, 'delay', 0);
    var startAt = GetNewValue(config, 'startAt', null);

    var data = [];

    //  Loop through every property defined in the Tween, i.e.: props { x, y, alpha }
    for (var p = 0; p < props.length; p++)
    {
        var key = props[p].key;
        var value = props[p].value;

        for (var t = 0; t < targets.length; t++)
        {
            //  Swap for faster getters, if they want Advanced Value style things, they can do it via their own functions
            var tweenData = TweenData(
                targets[t],
                key,
                GetValueOp(key, value),
                GetEaseFunction(GetValue(value, 'ease', ease), easeParams),
                GetNewValue(value, 'delay', delay),
                GetNewValue(value, 'duration', duration),
                GetBoolean(value, 'yoyo', yoyo),
                GetNewValue(value, 'hold', hold),
                GetNewValue(value, 'repeat', repeat),
                GetNewValue(value, 'repeatDelay', repeatDelay),
                GetNewValue(value, 'startAt', startAt)
            );

            //  TODO: Calculate total duration

            data.push(tweenData);
        }
    }

    var tween = new Tween(manager, data);

    tween.totalTargets = targets.length;
    tween.useFrames = GetBoolean(config, 'useFrames', false);
    tween.loop = GetBoolean(config, 'loop', 0);
    tween.loopDelay = GetAdvancedValue(config, 'loopDelay', 0);
    tween.completeDelay = GetAdvancedValue(config, 'completeDelay', 0);
    tween.paused = GetBoolean(config, 'paused', false);

    return tween;
};

module.exports = TweenBuilder;


/***/ }),
/* 774 */
/***/ (function(module, exports) {

var TweenData = function (target, key, value, ease, delay, duration, yoyo, hold, repeat, repeatDelay, startAt)
{
    return {

        //  The target to tween
        target: target,

        //  The property of the target to tween
        key: key,

        //  A function to call when starting the tween, populates the 'start' and 'end' values
        value: value,

        //  The ease function this tween uses.
        ease: ease,

        //  Duration of the tween in ms/frames, excludes time for yoyo or repeats.
        duration: 0,

        //  The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)
        totalDuration: 0,

        //  Time in ms/frames before tween will start.
        delay: 0,

        //  Cause the tween to return back to its start value after hold has expired.
        yoyo: yoyo,

        //  Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
        hold: 0,

        //  Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
        repeat: 0,

        //  Time in ms/frames before the repeat will start.
        repeatDelay: 0,

        //  Changes the property to be this value before starting the tween.
        startAt: startAt,

        //  Between 0 and 1 showing completion of this TweenData.
        progress: 0,

        //  Delta counter.
        elapsed: 0,

        //  How many repeats are left to run?
        repeatCounter: 0,

        //  Ease Value Data:

        start: 0,
        current: 0,
        end: 0,
        startCache: 0,
        endCache: 0,

        //  Time Durations
        t1: 0,
        t2: 0,

        //  LoadValue generation functions
        gen: {
            delay: delay,
            duration: duration,
            hold: hold,
            repeat: repeat,
            repeatDelay: repeatDelay
        },

        //  TWEEN_CONST.CREATED
        state: 0
    };
};

module.exports = TweenData;


/***/ }),
/* 775 */
/***/ (function(module, exports, __webpack_require__) {


var EventDispatcher = __webpack_require__(15);
var TweenBuilder = __webpack_require__(773);

var TweenManager = function (state)
{
    //  The State the Tween Manager belongs to (tweens are State specific, not Game global)
    this.state = state;

    /**
    * @property {EventDispatcher} events - Global / Global Game System Events
    */
    this.events = new EventDispatcher(); // should use State event dispatcher?

    //  TODO:
    //  Add _pool array and make the queue re-use objects within it.
    //  Add a pool max size.

    this._add = [];
    this._pending = [];
    this._active = [];
    this._destroy = [];

    this._toProcess = 0;
};

TweenManager.prototype.constructor = TweenManager;

TweenManager.prototype = {

    boot: function ()
    {
        //  State is starting up
    },

    add: function (config)
    {
        var tween = TweenBuilder(this, config);

        this._add.push(tween);

        this._toProcess++;

        return tween;
    },

    timeline: function ()
    {
        // return new Timeline(this);
    },

    //  Add a 'to' GSAP equivalent?

    exists: function (tween)
    {
    },

    get: function (target)
    {
    },

    begin: function ()
    {
        if (this._toProcess === 0)
        {
            //  Quick bail
            return;
        }

        var list = this._destroy;
        var active = this._active;
        var i;
        var tween;

        //  Clear the 'destroy' list
        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  Remove from the 'active' array
            var idx = active.indexOf(tween);

            if (idx !== -1)
            {
                active.splice(idx, 1);
            }
        }

        list.length = 0;

        //  Process the addition list
        //  This stops callbacks and out of sync events from populating the active array mid-way during the update

        list = this._add;

        for (i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  Return true if the Tween should be started right away, otherwise false
            if (tween.init())
            {
                tween.play();

                this._active.push(tween);
            }
            else
            {
                this._pending.push(tween);
            }
        }

        list.length = 0;

        this._toProcess = 0;
    },

    update: function (timestamp, delta)
    {
        //  Process active tweens
        var list = this._active;
        var tween;

        for (var i = 0; i < list.length; i++)
        {
            tween = list[i];

            //  If Tween.update returns 'true' then it means it has completed,
            //  so move it to the destroy list
            if (tween.update(timestamp, delta))
            {
                this._destroy.push(tween);
                this._toProcess++;
            }
        }
    },

    makeActive: function (tween)
    {
        var idx = this._pending.indexOf(tween);

        if (idx !== -1)
        {
            this._pending.splice(idx, 1);
        }

        this._add.push(tween);

        this._toProcess++;
    },

    globalTimeScale: function ()
    {
    },

    getAllTweens: function ()
    {
    },

    getTweensOf: function (target)
    {
    },

    isTweening: function (target)
    {
    },

    kill: function (vars, target)
    {
    },

    killAll: function ()
    {
    },

    killTweensOf: function (target)
    {
    },

    pauseAll: function ()
    {
    },

    resumeAll: function ()
    {
    },

    delayedCall: function ()
    {
    },

    /**
    * Passes all Tweens to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    },

    shutdown: function ()
    {
        //  State is shutting down (swapping to another State)
    }

};

module.exports = TweenManager;


/***/ }),
/* 776 */
/***/ (function(module, exports) {

var CalcDuration = function ()
{
    var max = 0;

    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];

        //  Set t1 (duration + hold + yoyo)
        tweenData.t1 = tweenData.duration + tweenData.hold;

        if (tweenData.yoyo)
        {
            tweenData.t1 += tweenData.duration;
        }

        //  Set t2 (repeatDelay + duration + hold + yoyo)
        tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;

        //  Total Duration
        tweenData.totalDuration = tweenData.delay + tweenData.t1;

        tweenData.totalDuration += tweenData.t2 * (tweenData.repeat === -1) ? 999999999999 : tweenData.repeat;

        if (tweenData.totalDuration > max)
        {
            max = tweenData.totalDuration;
        }
    }

    //  Excludes loop values
    this.duration = max;

    this.loopCounter = (this.loop === -1) ? 999999999999 : this.loop;

    if (this.loopCounter > 0)
    {
        this.totalDuration = this.duration + this.completeDelay + ((this.duration + this.loopDelay) * this.loopCounter);
    }
    else
    {
        this.totalDuration = this.duration + this.completeDelay;
    }
};

module.exports = CalcDuration;


/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

//  Return true if this Tween should be moved from the pending list to the active list
var Init = function ()
{
    var data = this.data;
    var totalTargets = this.totalTargets;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];
        var target = tweenData.target;
        var gen = tweenData.gen;

        tweenData.delay = gen.delay(i, totalTargets, target);
        tweenData.duration = gen.duration(i, totalTargets, target);
        tweenData.hold = gen.hold(i, totalTargets, target);
        tweenData.repeat = gen.repeat(i, totalTargets, target);
        tweenData.repeatDelay = gen.repeatDelay(i, totalTargets, target);
    }

    this.calcDuration();

    this.progress = 0;
    this.totalProgress = 0;

    console.log('Tween duration', this.duration, 'totalDuration', this.totalDuration);

    if (this.paused)
    {
        this.state = TWEEN_CONST.PAUSED;

        return false;
    }
    else
    {
        return true;
    }
};

module.exports = Init;


/***/ }),
/* 778 */
/***/ (function(module, exports) {

//  Calculate the start and end values and store them into the TweenTarget objects

var LoadValues = function (tweenData)
{
    var targets = this.targets;
    var prop = tweenData.key;

    // console.log('--> LoadValues', prop);

    //  Targets array:
    //  0:
    //      ref: GameObject,
    //      keys: {
    //          x: {
    //              start,
    //              current,
    //              end,
    //              startCache,
    //              endCache
    //          },
    //          y: {
    //              start,
    //              current,
    //              end,
    //              startCache,
    //              endCache
    //          }
    //      }

    for (var i = 0; i < this.totalTargets; i++)
    {
        var keys = targets[i].keys;
        var entry = keys[prop];
        var gameObject = targets[i].ref;

        if (entry.startCache === null)
        {
            entry.start = gameObject[prop];
            entry.current = entry.start;
            entry.end = tweenData.value(entry.start);

            //  Cache the start and end values so we only do this once (needed?)
            entry.startCache = entry.start;
            entry.endCache = entry.end;
        }
        else
        {
            entry.start = entry.startCache;
            entry.current = entry.start;
            entry.end = entry.endCache;

            gameObject[prop] = entry.start;
        }

        // console.log('target', gameObject.name, 'key', prop, 'start', entry.start, 'end', entry.end);
    }
};

module.exports = LoadValues;


/***/ }),
/* 779 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var NextState = function ()
{
    if (this.loopCounter > 0)
    {
        this.resetTweenData(true);

        this.elapsed = 0;
        this.progress = 0;
        this.loopCounter--;

        if (this.loopDelay > 0)
        {
            this.countdown = this.loopDelay;
            this.state = TWEEN_CONST.LOOP_DELAY;
        }
        else
        {
            this.state = TWEEN_CONST.ACTIVE;
        }
    }
    else if (this.completeDelay > 0)
    {
        this.countdown = this.completeDelay;
        this.state = TWEEN_CONST.COMPLETE_DELAY;
    }
    else
    {
        this.state = TWEEN_CONST.PENDING_REMOVE;
    }
};

module.exports = NextState;


/***/ }),
/* 780 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var Pause = function ()
{
    if (this.state === TWEEN_CONST.PAUSED)
    {
        return;
    }

    this.paused = true;

    this._pausedState = this.state;

    this.state = TWEEN_CONST.PAUSED;

    return this;
};

module.exports = Pause;


/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var Play = function ()
{
    if (this.state === TWEEN_CONST.ACTIVE)
    {
        return;
    }

    if (this.paused)
    {
        this.paused = false;
    
        this.manager.makeActive(this);
    }
    else
    {
        //  Reset the TweenData
        this.resetTweenData();

        this.state = TWEEN_CONST.ACTIVE;
    }
};

module.exports = Play;


/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var ResetTweenData = function (resetFromLoop)
{
    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        var tweenData = data[i];

        tweenData.progress = 0;
        tweenData.elapsed = 0;

        tweenData.repeatCounter = (tweenData.repeat === -1) ? 999999999999 : tweenData.repeat;

        if (resetFromLoop)
        {
            tweenData.start = tweenData.startCache;
            tweenData.current = tweenData.start;
            tweenData.end = tweenData.endCache;

            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
        }
        else if (tweenData.delay > 0)
        {
            tweenData.elapsed = tweenData.delay;
            tweenData.state = TWEEN_CONST.DELAY;
        }
        else
        {
            tweenData.state = TWEEN_CONST.PENDING_RENDER;
        }
    }
};

module.exports = ResetTweenData;


/***/ }),
/* 783 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var Pause = function ()
{
    if (this.state === TWEEN_CONST.PAUSED)
    {
        this.paused = false;

        this.state = this._pausedState;
    }

    return this;
};

module.exports = Pause;


/***/ }),
/* 784 */
/***/ (function(module, exports) {

// var TWEEN_CONST = require('../const');

//  For now progress = 0 to 1
var Seek = function (toPosition)
{
    var data = this.data;

    for (var i = 0; i < this.totalData; i++)
    {
        //  This won't work with loop > 0 yet
        var ms = this.totalDuration * toPosition;

        var tweenData = data[i];
        var progress = 0;
        var elapsed = 0;

        if (ms <= tweenData.delay)
        {
            progress = 0;
            elapsed = 0;
        }
        else if (ms >= tweenData.totalDuration)
        {
            progress = 1;
            elapsed = tweenData.duration;
        }
        else if (ms > tweenData.delay && ms <= tweenData.t1)
        {
            //  Keep it zero bound
            ms = Math.max(0, ms - tweenData.delay);

            //  Somewhere in the first playthru range
            progress = ms / tweenData.t1;
            elapsed = tweenData.duration * progress;
        }
        else if (ms > tweenData.t1 && ms < tweenData.totalDuration)
        {
            //  Somewhere in repeat land
            ms -= tweenData.delay;
            ms -= tweenData.t1;

            var repeats = Math.floor(ms / tweenData.t2);

            //  remainder
            ms = ((ms / tweenData.t2) % 1) * tweenData.t2;

            if (ms > tweenData.repeatDelay)
            {
                progress = ms / tweenData.t1;
                elapsed = tweenData.duration * progress;
            }
        }

        tweenData.progress = progress;
        tweenData.elapsed = elapsed;

        var v = tweenData.ease(tweenData.progress);

        tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);

        // console.log(tweenData.key, 'Seek', tweenData.target[tweenData.key], 'to', tweenData.current, 'pro', tweenData.progress, 'marker', marker, progress);

        tweenData.target[tweenData.key] = tweenData.current;
    }
};

module.exports = Seek;


/***/ }),
/* 785 */
/***/ (function(module, exports) {

var SetEventCallback = function (type, callback, params, scope)
{
    var types = [ 'onStart', 'onUpdate', 'onRepeat', 'onLoop', 'onComplete' ];

    if (types.indexOf(type) !== -1)
    {
        this.callbacks[type] = { callback: callback, scope: scope, params: params };
    }

    return this;
};

module.exports = SetEventCallback;


/***/ }),
/* 786 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);
var UpdateTweenData = __webpack_require__(787);

var Update = function (timestamp, delta)
{
    if (this.useFrames)
    {
        delta = 1;
    }

    this.elapsed += delta;
    this.progress = Math.min(this.elapsed / this.duration, 1);

    this.totalElapsed += delta;
    this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);

    switch (this.state)
    {
        case TWEEN_CONST.ACTIVE:

            var stillRunning = false;

            for (var i = 0; i < this.totalData; i++)
            {
                if (UpdateTweenData(this, this.data[i], delta))
                {
                    stillRunning = true;
                }
            }

            //  Anything still running? If not, we're done
            if (!stillRunning)
            {
                this.nextState();
            }

            break;

        case TWEEN_CONST.LOOP_DELAY:

            this.countdown -= delta;

            if (this.countdown <= 0)
            {
                this.state = TWEEN_CONST.ACTIVE;
            }

            break;

        case TWEEN_CONST.COMPLETE_DELAY:

            this.countdown -= delta;

            if (this.countdown <= 0)
            {
                this.state = TWEEN_CONST.PENDING_REMOVE;
            }

            break;
    }

    return (this.state === TWEEN_CONST.PENDING_REMOVE);
};

module.exports = Update;


/***/ }),
/* 787 */
/***/ (function(module, exports, __webpack_require__) {

var TWEEN_CONST = __webpack_require__(17);

var SetStateFromEnd = function (tween, tweenData)
{
    if (tweenData.yoyo)
    {
        //  Playing forward and we have a yoyo

        tweenData.progress = 0;
        tweenData.elapsed = 0;

        return TWEEN_CONST.PLAYING_BACKWARD;
    }
    else if (tweenData.repeatCounter > 0)
    {
        tweenData.repeatCounter--;

        tweenData.elapsed = 0;
        tweenData.progress = 0;

        //  Delay?
        if (tweenData.repeatDelay > 0)
        {
            tweenData.elapsed = tweenData.repeatDelay;

            tweenData.current = tweenData.start;

            tweenData.target[tweenData.key] = tweenData.current;

            return TWEEN_CONST.REPEAT_DELAY;
        }
        else
        {
            return TWEEN_CONST.PLAYING_FORWARD;
        }
    }

    return TWEEN_CONST.COMPLETE;
};

//  Was PLAYING_BACKWARD and has hit the start
var SetStateFromStart = function (tween, tweenData)
{
    if (tweenData.repeatCounter > 0)
    {
        tweenData.repeatCounter--;

        tweenData.elapsed = 0;
        tweenData.progress = 0;

        //  Delay?
        if (tweenData.repeatDelay > 0)
        {
            tweenData.elapsed = tweenData.repeatDelay;

            tweenData.current = tweenData.start;

            tweenData.target[tweenData.key] = tweenData.current;

            return TWEEN_CONST.REPEAT_DELAY;
        }
        else
        {
            return TWEEN_CONST.PLAYING_FORWARD;
        }
    }

    return TWEEN_CONST.COMPLETE;
};

//  Delta is either a value in ms, or 1 if Tween.useFrames is true
var UpdateTweenData = function (tween, tweenData, delta)
{
    switch (tweenData.state)
    {
        case TWEEN_CONST.PLAYING_FORWARD:
        case TWEEN_CONST.PLAYING_BACKWARD:

            var elapsed = tweenData.elapsed;
            var duration = tweenData.duration;

            elapsed += delta;

            if (elapsed > duration)
            {
                elapsed = duration;
            }

            var forward = (tweenData.state === TWEEN_CONST.PLAYING_FORWARD);
            var progress = elapsed / duration;
            var v;

            if (forward)
            {
                v = tweenData.ease(progress);
            }
            else
            {
                v = tweenData.ease(1 - progress);
            }

            tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);

            tweenData.target[tweenData.key] = tweenData.current;

            tweenData.elapsed = elapsed;
            tweenData.progress = progress;

            if (progress === 1)
            {
                if (forward)
                {
                    if (tweenData.hold > 0)
                    {
                        tweenData.elapsed = tweenData.hold;

                        tweenData.state = TWEEN_CONST.HOLD_DELAY;
                    }
                    else
                    {
                        tweenData.state = SetStateFromEnd(tween, tweenData);
                    }
                }
                else
                {
                    tweenData.state = SetStateFromStart(tween, tweenData);
                }
            }

            break;

        case TWEEN_CONST.DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                //  TODO - Move elapsed block below switch statement so that calls to render and play happen this frame, not the next one?
                tweenData.elapsed = Math.abs(tweenData.elapsed);

                tweenData.state = TWEEN_CONST.PENDING_RENDER;
            }

            break;

        case TWEEN_CONST.REPEAT_DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                tweenData.elapsed = Math.abs(tweenData.elapsed);
                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
            }

            break;

        case TWEEN_CONST.HOLD_DELAY:

            tweenData.elapsed -= delta;

            if (tweenData.elapsed <= 0)
            {
                tweenData.state = SetStateFromEnd(tween, tweenData);
            }

            break;

        case TWEEN_CONST.PENDING_RENDER:

            tweenData.start = tweenData.target[tweenData.key];
            tweenData.current = tweenData.start;
            tweenData.end = tweenData.value(tweenData.start);

            tweenData.startCache = tweenData.start;
            tweenData.endCache = tweenData.end;

            tweenData.target[tweenData.key] = tweenData.current;

            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;

            break;
    }

    //  Return TRUE if this TweenData still playing, otherwise return FALSE
    return (tweenData.state !== TWEEN_CONST.COMPLETE);
};

module.exports = UpdateTweenData;


/***/ }),
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(221);

var AlignInMap = [];

AlignInMap[CONST.BOTTOM_CENTER] = __webpack_require__(212);
AlignInMap[CONST.BOTTOM_LEFT] = __webpack_require__(213);
AlignInMap[CONST.BOTTOM_RIGHT] = __webpack_require__(214);
AlignInMap[CONST.CENTER] = __webpack_require__(215);
AlignInMap[CONST.LEFT_CENTER] = __webpack_require__(216);
AlignInMap[CONST.RIGHT_CENTER] = __webpack_require__(217);
AlignInMap[CONST.TOP_CENTER] = __webpack_require__(218);
AlignInMap[CONST.TOP_LEFT] = __webpack_require__(219);
AlignInMap[CONST.TOP_RIGHT] = __webpack_require__(220);

var AlignIn = function (child, container, position, offsetX, offsetY)
{
    return AlignInMap[position](child, container, offsetX, offsetY);
};

module.exports = AlignIn;


/***/ }),
/* 789 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(40);
var GetBottom = __webpack_require__(18);
var SetCenterX = __webpack_require__(42);
var SetTop = __webpack_require__(25);

var ToBottomCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomCenter;


/***/ }),
/* 790 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetBottom = __webpack_require__(18);
var SetLeft = __webpack_require__(23);
var SetTop = __webpack_require__(25);

var ToBottomLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomLeft;


/***/ }),
/* 791 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetBottom = __webpack_require__(18);
var SetRight = __webpack_require__(24);
var SetTop = __webpack_require__(25);

var ToBottomRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomRight;


/***/ }),
/* 792 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetBottom = __webpack_require__(18);
var SetRight = __webpack_require__(24);
var SetBottom = __webpack_require__(22);

var ToLeftBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftBottom;


/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetCenterY = __webpack_require__(41);
var SetRight = __webpack_require__(24);
var SetCenterY = __webpack_require__(43);

var ToLeftCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftCenter;


/***/ }),
/* 794 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetTop = __webpack_require__(21);
var SetRight = __webpack_require__(24);
var SetTop = __webpack_require__(25);

var ToLeftTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToLeftTop;


/***/ }),
/* 795 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetBottom = __webpack_require__(18);
var SetLeft = __webpack_require__(23);
var SetBottom = __webpack_require__(22);

var ToRightBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightBottom;


/***/ }),
/* 796 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetCenterY = __webpack_require__(41);
var SetLeft = __webpack_require__(23);
var SetCenterY = __webpack_require__(43);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ }),
/* 797 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetTop = __webpack_require__(21);
var SetLeft = __webpack_require__(23);
var SetTop = __webpack_require__(25);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ }),
/* 798 */
/***/ (function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(40);
var GetTop = __webpack_require__(21);
var SetCenterX = __webpack_require__(42);
var SetBottom = __webpack_require__(22);

var ToTopCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopCenter;


/***/ }),
/* 799 */
/***/ (function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(19);
var GetTop = __webpack_require__(21);
var SetLeft = __webpack_require__(23);
var SetBottom = __webpack_require__(22);

var ToTopLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopLeft;


/***/ }),
/* 800 */
/***/ (function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(20);
var GetTop = __webpack_require__(21);
var SetRight = __webpack_require__(24);
var SetBottom = __webpack_require__(22);

var ToTopRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopRight;


/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Align

module.exports = {

    InBottomCenter: __webpack_require__(212),
    InBottomLeft: __webpack_require__(213),
    InBottomRight: __webpack_require__(214),
    InCenter: __webpack_require__(215),
    InLeftCenter: __webpack_require__(216),
    InRightCenter: __webpack_require__(217),
    InTopCenter: __webpack_require__(218),
    InTopLeft: __webpack_require__(219),
    InTopRight: __webpack_require__(220),
    ToBottomCenter: __webpack_require__(789),
    ToBottomLeft: __webpack_require__(790),
    ToBottomRight: __webpack_require__(791),
    ToLeftBottom: __webpack_require__(792),
    ToLeftCenter: __webpack_require__(793),
    ToLeftTop: __webpack_require__(794),
    ToRightBottom: __webpack_require__(795),
    ToRightCenter: __webpack_require__(796),
    ToRightTop: __webpack_require__(797),
    ToTopCenter: __webpack_require__(798),
    ToTopLeft: __webpack_require__(799),
    ToTopRight: __webpack_require__(800)

};


/***/ }),
/* 802 */
/***/ (function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ }),
/* 803 */
/***/ (function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ }),
/* 804 */
/***/ (function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(179);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ }),
/* 805 */
/***/ (function(module, exports) {

//  This is from the quickselect npm package: https://www.npmjs.com/package/quickselect
//  Coded by https://www.npmjs.com/~mourner (Vladimir Agafonkin)

// https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

var QuickSelect = function (arr, k, left, right, compare)
{
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left)
    {
        if (right - left > 600)
        {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));

            QuickSelect(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);

        if (compare(arr[right], t) > 0)
        {
            swap(arr, left, right);
        }

        while (i < j)
        {
            swap(arr, i, j);

            i++;
            j--;

            while (compare(arr[i], t) < 0)
            {
                i++;
            }

            while (compare(arr[j], t) > 0)
            {
                j--;
            }
        }

        if (compare(arr[left], t) === 0)
        {
            swap(arr, left, j);
        }
        else
        {
            j++;
            swap(arr, j, right);
        }

        if (j <= k)
        {
            left = j + 1;
        }

        if (k <= j)
        {
            right = j - 1;
        }
    }
};

function swap (arr, i, j)
{
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare (a, b)
{
    return a < b ? -1 : a > b ? 1 : 0;
}

module.exports = QuickSelect;


/***/ }),
/* 806 */
/***/ (function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(227);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ }),
/* 807 */
/***/ (function(module, exports, __webpack_require__) {

//! stable.js 0.1.6, https://github.com/Two-Screen/stable
//! © 2017 Angry Bytes and contributors. MIT licensed.

(function() {

// A stable array sort, because `Array#sort()` is not guaranteed stable.
// This is an implementation of merge sort, without recursion.

var stable = function(arr, comp) {
    return exec(arr.slice(), comp);
};

stable.inplace = function(arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
        pass(result, null, arr.length, arr);
    }

    return arr;
};

// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
        comp = function(a, b) {
            return String(a).localeCompare(b);
        };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
        return arr;
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);

        var tmp = arr;
        arr = buffer;
        buffer = tmp;
    }

    return arr;
}

// Run a single pass with the given chunk size.
var pass = function(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len) r = len;
        if (e > len) e = len;

        // Iterate both chunks in parallel.
        li = l;
        ri = r;
        while (true) {
            // Compare the chunks.
            if (li < r && ri < e) {
                // This works for a regular `sort()` compatible comparator,
                // but also for a simple comparator like: `a > b`
                if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                }
                else {
                    result[i++] = arr[ri++];
                }
            }
            // Nothing to compare, just flush what's left.
            else if (li < r) {
                result[i++] = arr[li++];
            }
            else if (ri < e) {
                result[i++] = arr[ri++];
            }
            // Both iterators are at the chunk ends.
            else {
                break;
            }
        }
    }
};

// Export using CommonJS or to the window.
if (true) {
    module.exports = stable;
}
else {
    window.stable = stable;
}

})();

/***/ }),
/* 808 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(802),
    GetRandomElement: __webpack_require__(803),
    NumberArray: __webpack_require__(222),
    NumberArrayStep: __webpack_require__(804),
    QuickSelect: __webpack_require__(805),
    Range: __webpack_require__(223),
    RemoveRandomElement: __webpack_require__(806),
    RotateLeft: __webpack_require__(224),
    RotateRight: __webpack_require__(225),
    Shuffle: __webpack_require__(226),
    SpliceOne: __webpack_require__(227)

};


/***/ }),
/* 809 */
/***/ (function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetX = function (gameObject)
{
    return gameObject.width * gameObject.originX;
};

module.exports = GetOffsetX;


/***/ }),
/* 810 */
/***/ (function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetY = function (gameObject)
{
    return gameObject.height * gameObject.originY;
};

module.exports = GetOffsetY;


/***/ }),
/* 811 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Bounds

module.exports = {

    CenterOn: __webpack_require__(228),
    GetBottom: __webpack_require__(18),
    GetCenterX: __webpack_require__(40),
    GetCenterY: __webpack_require__(41),
    GetLeft: __webpack_require__(19),
    GetOffsetX: __webpack_require__(809),
    GetOffsetY: __webpack_require__(810),
    GetRight: __webpack_require__(20),
    GetTop: __webpack_require__(21),
    SetBottom: __webpack_require__(22),
    SetCenterX: __webpack_require__(42),
    SetCenterY: __webpack_require__(43),
    SetLeft: __webpack_require__(23),
    SetRight: __webpack_require__(24),
    SetTop: __webpack_require__(25)
    
};


/***/ }),
/* 812 */
/***/ (function(module, exports, __webpack_require__) {

var GetValue = __webpack_require__(0);
var Clamp = __webpack_require__(55);

var GetMinMaxValue = function (source, key, min, max, defaultValue)
{
    if (defaultValue === undefined) { defaultValue = min; }

    var value = GetValue(source, key, defaultValue);

    return Clamp(value, min, max);
};

module.exports = GetMinMaxValue;


/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

//  Creates a new Object using all values from obj1 and obj2.
//  If a value exists in both obj1 and obj2, the value in obj1 is used.

var Clone = __webpack_require__(97);

var Merge = function (obj1, obj2)
{
    var clone = Clone(obj1);

    for (var key in obj2)
    {
        if (!clone.hasOwnProperty(key))
        {
            clone[key] = obj2[key];
        }
    }

    return clone;
};

module.exports = Merge;


/***/ }),
/* 814 */
/***/ (function(module, exports, __webpack_require__) {

//  Creates a new Object using all values from obj1.
//  
//  Then scans obj2. If a property is found in obj2 that *also* exists in obj1,
//  the value from obj2 is used, otherwise the property is skipped.

var Clone = __webpack_require__(97);

var MergeRight = function (obj1, obj2)
{
    var clone = Clone(obj1);

    for (var key in obj2)
    {
        if (clone.hasOwnProperty(key))
        {
            clone[key] = obj2[key];
        }
    }

    return clone;
};

module.exports = MergeRight;


/***/ }),
/* 815 */
/***/ (function(module, exports, __webpack_require__) {

//  Phaser.Utils.Object

module.exports = {

    Clone: __webpack_require__(97),
    Extend: __webpack_require__(62),
    GetAdvancedValue: __webpack_require__(14),
    GetMinMaxValue: __webpack_require__(812),
    GetValue: __webpack_require__(0),
    IsPlainObject: __webpack_require__(229),
    Merge: __webpack_require__(813),
    MergeRight: __webpack_require__(814)

};


/***/ }),
/* 816 */
/***/ (function(module, exports) {

/**
 * Replaces %1, %2, %3 etc in the String with the values
 * given in the array. Values are cast to strings.
 * If no value exists an empty string is inserted.
 * 
 * @param {string} string - The string containing the markers
 * @param {array} values - An array containing the values to replace the markers with
*/
var Format = function (string, values)
{
    string.replace(/%([0-9]+)/g, function (s, n)
    {
        return values[Number(n) - 1];
    });

    return string;
};

module.exports = Format;


/***/ }),
/* 817 */
/***/ (function(module, exports) {

/**
* Takes the given string and reverses it, returning the reversed string.
* For example if given the string `Atari 520ST` it would return `TS025 iratA`.
*
* @method Phaser.Utils.reverseString
* @param {string} string - The string to be reversed.
* @return {string} The reversed string.
*/
var ReverseString = function (string)
{
    return string.split('').reverse().join('');
};

module.exports = ReverseString;


/***/ }),
/* 818 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {

    Pad: __webpack_require__(230),
    Format: __webpack_require__(816),
    Reverse: __webpack_require__(817)

};


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA1NTg3ODdkNjM5NTY5N2VmYzYyMiIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvR2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Db21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2V2ZW50cy9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2NvbnN0LmpzIiwid2VicGFjazovLy8uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQm91bmRzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4LmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9HZXRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0dldExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0dldFJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2JvdW5kcy9HZXRUb3AuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL1NldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0TGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0UmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL1NldFRvcC5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvT1MuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9GaWxlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRXZlbnRzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlcnRpY2VzLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL0J1aWxkR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC91dGlscy9EYXRhQnVmZmVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2RldmljZS9Ccm93c2VyLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9TY2FsZU1vZGVzLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0RhdGFCdWZmZXIxNi5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL1RyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQm9keS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9TbGVlcGluZy5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9tZXNoL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL21hdGgvQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9XcmFwLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0NPTExJREVTLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL0JsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvTk9PUC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9FeHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL1Ntb290aGluZy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9Db21tYW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3pvbmUvWm9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Eb3QuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Db250YWluc0FycmF5LmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQva2V5cy9LZXlDb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvWEhSU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9UWVBFLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9EZXRlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vU0FULmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Cb2RpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9yZW5kZXIvUmVuZGVyLmpzIiwid2VicGFjazovLy8uL3N0cnVjdHMvU2V0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3RhdGUvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL0dldEZyYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvQ2FtZXJhLmpzIiwid2VicGFjazovLy8uL2NhbnZhcy9HZXRDb250ZXh0LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdGUvR2VuZXJhdGVUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9wYWxldHRlcy9Bcm5lMTYuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzLmpzIiwid2VicGFjazovLy8uL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb20vQWRkVG9ET00uanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL0RPTUNvbnRlbnRMb2FkZWQuanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL1BhcnNlWE1MLmpzIiwid2VicGFjazovLy8uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vZXZlbnRzL2NvbnN0LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvR2V0Qml0bWFwVGV4dFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9jaXJjbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9FbGxpcHNlLmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9MaW5lLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9NdWx0aXBseS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvRGVjb21wb3NlLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9EZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9JbkNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0FkZC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yRG9kZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9EYXJrZW4uanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaWdodGVuLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1JlZmxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1ZpdmlkTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvQ29tcG9uZW50VG9IZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IzMi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9IZXhTdHJpbmdUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0h1ZVRvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9SR0JTdHJpbmdUb0NvbG9yLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9LZXlib2FyZE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUHJvY2Vzc0tleUNvbWJvLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzIiwid2VicGFjazovLy8uL2lucHV0L21vdXNlL01vdXNlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9CZXJuc3RlaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9DYXRtdWxsUm9tLmpzIiwid2VicGFjazovLy8uL21hdGgvRmFjdG9yaWFsLmpzIiwid2VicGFjazovLy8uL21hdGgvTGluZWFyLmpzIiwid2VicGFjazovLy8uL21hdGgvUm91bmRBd2F5RnJvbVplcm8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9TbW9vdGhTdGVwLmpzIiwid2VicGFjazovLy8uL21hdGgvU21vb3RoZXJTdGVwLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvTm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL0JhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvQm91bmNlLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL0N1YmljLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL0VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvRXhwby5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9MaW5lYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvUXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL1F1YXJ0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9lYXNpbmcvUXVpbnRpYy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9TaW5lLmpzIiwid2VicGFjazovLy8uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0JvZHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvQ29sbGlzaW9uTWFwLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvV29ybGQuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0NvbnRhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1BhaXJzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9SZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL0VuZ2luZS5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL01ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9wb2x5LWRlY29tcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zbmFwc2hvdC9TbmFwc2hvdC5qcyIsIndlYnBhY2s6Ly8vLi9zdGF0ZS9TeXN0ZW1zLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luQm90dG9tQ2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luQm90dG9tTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JbkJvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luQ2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luTGVmdENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luVG9wQ2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL0luVG9wTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L051bWJlckFycmF5LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1JhbmdlLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1JvdGF0ZUxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvU2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9TcGxpY2VPbmUuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9Jc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL3N0cmluZy9QYWQuanMiLCJ3ZWJwYWNrOi8vLy4vYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0FuZ2xlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL0dldEZpcnN0LmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvR3JpZEFsaWduLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvSW5jQWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9JbmNYLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvSW5jWFkuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9JbmNZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUGxhY2VPbkNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYWNlT25MaW5lLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUGxhY2VPblJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYWNlT25UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1BsYXlBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9SYW5kb21DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9SYW5kb21FbGxpcHNlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUmFuZG9tTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1JhbmRvbVJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1JhbmRvbVRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlQXJvdW5kLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvUm90YXRlQXJvdW5kRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TY2FsZVguanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TY2FsZVhZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2NhbGVZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0QWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRSb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFNjYWxlLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0U2NhbGVYLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0U2NhbGVZLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU2V0VmlzaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFguanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TZXRYWS5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NldFkuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9TaGlmdFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMvU21vb3RoU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1Ntb290aGVyU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9hY3Rpb25zL1RvZ2dsZVZpc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL0FkZEZyYW1lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9BZGRGcmFtZUF0LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL0NoZWNrRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL2ZyYW1lL0NvbXBsZXRlQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvR2V0Rmlyc3RUaWNrLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9HZXRGcmFtZUF0LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9HZXROZXh0VGljay5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvTG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvTmV4dEZyYW1lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9QcmV2aW91c0ZyYW1lLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9SZW1vdmVGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvUmVtb3ZlRnJhbWVBdC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvUmVwZWF0QW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9TZXRGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vZnJhbWUvVG9KU09OLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9mcmFtZS9VcGRhdGVGcmFtZVNlcXVlbmNlLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL0FuaW1hdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9BZGRBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9DcmVhdGVGcmFtZUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9jb21wb25lbnRzL0Zyb21KU09OLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvR2VuZXJhdGVGcmFtZU5hbWVzLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvR2VuZXJhdGVGcmFtZU51bWJlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9HZXRBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9Mb2FkQW5pbWF0aW9uVG9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvUGF1c2VBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9QbGF5QW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvUmVtb3ZlQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvUmVzdW1lQWxsLmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvU3RhZ2dlclBsYXlBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9Ub0pTT04uanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvQWRkQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1BhdXNlQWxsQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vYW5pbWF0aW9uL21hbmFnZXIvZXZlbnRzL1JlbW92ZUFuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9SZXN1bWVBbGxBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ib290L0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2Jvb3QvRGVidWdIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYm9vdC9UaW1lU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9ib290L1Zpc2liaWxpdHlIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL2NhY2hlL0Jhc2VDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9jYWNoZS9DYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9jYWNoZS9DYWNoZUVudHJ5LmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzIiwid2VicGFjazovLy8uL2NhY2hlL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvS2V5Q29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9jYW1lcmEvU21vb3RoZWRLZXlDb250cm9sLmpzIiwid2VicGFjazovLy8uL2NoZWNrc3VtLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvQWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9CbGVuZE1vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0NvbG9yLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvRmxpcC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL09yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1NjYWxlTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1Njcm9sbEZhY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1NpemUuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvVG9KU09OLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvVmlzaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9EZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9EZWxheWVkUGxheS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9HZXRDdXJyZW50S2V5LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL0xvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24vUGF1c2UuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24vUGF1c2VkLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL1BsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24vUHJvZ3Jlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hbmltYXRpb24vUmVtb3ZlLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL1JlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXBlYXREZWxheS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXN0YXJ0LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL1Jlc3VtZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9TdG9wLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL1RpbWVTY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9Ub3RhbEZyYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9Ub3RhbFByb2dyZXNzLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL1VwZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9VcGRhdGVGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FuaW1hdGlvbi9Zb3lvLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9HcmlkLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9wYWxldHRlcy9DNjQuanMiLCJ3ZWJwYWNrOi8vLy4vY3JlYXRlL3BhbGV0dGVzL0NHQS5qcyIsIndlYnBhY2s6Ly8vLi9jcmVhdGUvcGFsZXR0ZXMvSk1QLmpzIiwid2VicGFjazovLy8uL2NyZWF0ZS9wYWxldHRlcy9NU1guanMiLCJ3ZWJwYWNrOi8vLy4vY3JlYXRlL3BhbGV0dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2RldmljZS9BdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2aWNlL1ZpZGVvLmpzIiwid2VicGFjazovLy8uL2RldmljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kb20vQWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9kb20vUmVtb3ZlRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9kb20vUmVtb3ZlRnJvbURPTS5qcyIsIndlYnBhY2s6Ly8vLi9kb20vVG91Y2hBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZG9tL1VzZXJTZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9CdWlsZEdhbWVPYmplY3RBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVJldHJvRm9udC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L1BhcnNlWE1MQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvYmxpdHRlci9Cb2IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvQnVpbGRGcm9tQ29uZmlnLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvaW1hZ2UvQnVpbGRGcm9tQ29uZmlnLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9sYXllci9MYXllckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9CdWlsZEZyb21Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9tZXNoL01lc2hSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9xdWFkL0J1aWxkRnJvbUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlL0J1aWxkRnJvbUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L0dldFRleHRTaXplLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RleHQvTWVhc3VyZVRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9UZXh0U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvQnVpbGRGcm9tQ29uZmlnLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9CdWlsZEZyb21Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXBXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL0J1aWxkRnJvbUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2FtZW9iamVjdHMvdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVGYWN0b3J5LmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZVJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGVXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2dhbWVvYmplY3RzL3pvbmUvWm9uZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9jaXJjbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uL2dlb20vY2lyY2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2NpcmNsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9lbGxpcHNlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1RyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvSGVpZ2h0LmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9MZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUGVycFNsb3BlLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9saW5lL1Nsb3BlLmpzIiwid2VicGFjazovLy8uL2dlb20vbGluZS9XaWR0aC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9BZGQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9DZWlsLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0Nyb3NzLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRGl2aWRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvSW52ZXJ0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9QZXJwLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvUHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9pbnQvUlBlcnAuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vRWFyY3V0LmpzIiwid2VicGFjazovLy8uL2dlb20vcG9seWdvbi9HZXRBQUJCLmpzIiwid2VicGFjazovLy8uL2dlb20vcG9seWdvbi9HZXROdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3BvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9DZWlsLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0NlaWxBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ2VudGVyT24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0Zsb29yLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0Zsb29yQWxsLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3JlY3RhbmdsZS9HZXRTaXplLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL0luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VSZWN0LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL092ZXJsYXBzLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlclBvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL1NjYWxlLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzIiwid2VicGFjazovLy8uL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0J1aWxkRXF1aWxhdGVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9CdWlsZEZyb21Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQnVpbGRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2VudGVyLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uL2dlb20vdHJpYW5nbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ2VvbS90cmlhbmdsZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL3RyaWFuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvQXZlcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9FeGNsdXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZExpZ2h0LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZE1peC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckxpZ2h0LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9OZWdhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL05vcm1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1Bob2VuaXguanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1NjcmVlbi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL1NvZnRMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9ibGVuZG1vZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0NTU1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvQ29sb3JUb1JHQkEuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29sb3IvSFNMVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9IU1ZDb2xvcldoZWVsLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL1JHQlRvSFNWLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL1JHQlRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbG9yL1JhbmRvbVJHQi5qcyIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvY29tcG9uZW50cy9HZXRUcmFuc2Zvcm1lZFBvaW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2NvbXBvbmVudHMvUG9pbnRXaXRoaW5HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2NvbWJvL0FkdmFuY2VLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21ib01hdGNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUmVzZXRLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlVcEV2ZW50LmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9rZXlzL0Rvd25EdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3REb3duLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvSnVzdFVwLmpzIiwid2VicGFjazovLy8uL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleURvd24uanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQva2V5cy9Qcm9jZXNzS2V5VXAuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQva2V5Ym9hcmQva2V5cy9VcER1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL2lucHV0L21vdXNlL2V2ZW50cy9Nb3VzZURvd25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9tb3VzZS9ldmVudHMvTW91c2VNb3ZlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbW91c2UvZXZlbnRzL01vdXNlVXBFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9pbnB1dC9tb3VzZS9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5wdXQvbW91c2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL0Jhc2VMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL0dldFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvWEhSTG9hZGVyLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9ldmVudHMvTG9hZGVyQ29tcGxldGVFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZXZlbnRzL0xvYWRlclN0YXJ0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL0FuaW1hdGlvbkpTT05GaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvSFRNTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9TVkdGaWxlLmpzIiwid2VicGFjazovLy8uL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9DZWlsVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9EZWdUb1JhZC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9GbG9hdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9GbG9vclRvLmpzIiwid2VicGFjazovLy8uL21hdGgvR2V0U3BlZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9NYXhBZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9NaW5TdWIuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9QZXJjZW50LmpzIiwid2VicGFjazovLy8uL21hdGgvUmFkVG9EZWcuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3RhdGVBcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9Sb3VuZFRvLmpzIiwid2VicGFjazovLy8uL21hdGgvU2luQ29zVGFibGVHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9XaXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50cy5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHNZLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvQmV0d2VlblkuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzIiwid2VicGFjazovLy8uL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9TaG9ydGVzdEJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9hbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVNxdWFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Vhc2luZy9FYXNlTWFwLmpzIiwid2VicGFjazovLy8uL21hdGgvZWFzaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Z1enp5L0VxdWFsLmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9mdXp6eS9HcmVhdGVyVGhhbi5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzIiwid2VicGFjazovLy8uL21hdGgvZnV6enkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3BvdzIvSXNWYWx1ZVBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9wb3cyL2luZGV4LmpzIiwid2VicGFjazovLy8uL21hdGgvcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9zbmFwL1NuYXBDZWlsLmpzIiwid2VicGFjazovLy8uL21hdGgvc25hcC9TbmFwRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbWF0aC9zbmFwL1NuYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9tYXRoL3NuYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGhhc2VyLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0RlZmF1bHREZWZzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L0dldFZlbG9jaXR5LmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L1NlcGVyYXRlWC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9TZXBlcmF0ZVkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9pbXBhY3QvU29sdmVyLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvaW1wYWN0L1VwZGF0ZU1vdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9Xb3JsZC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL2ltcGFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Db21wb3NpdGVzLmpzIiwid2VicGFjazovLy8uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9tb2R1bGUvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9waHlzaWNzL21hdHRlci1qcy9yZW5kZXIvUmVuZGVyUGl4aS5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXJyYXkuZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXJyYXkuaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9wb2x5ZmlsbHMvQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL01hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxscy9jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0JsaXRJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvRHJhd0ltYWdlLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9HZXRCbGVuZE1vZGVzLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL1Jlc291cmNlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9ibGl0dGVyYmF0Y2gvQmxpdHRlckJhdGNoLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9ibGl0dGVyYmF0Y2gvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2VmZmVjdHJlbmRlcmVyL0VmZmVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9lZmZlY3RyZW5kZXJlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvcXVhZGJhdGNoL1F1YWRCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvcXVhZGJhdGNoL2NvbnN0LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9zaGFwZWJhdGNoL1NoYXBlQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvZWFyY3V0LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9zcHJpdGViYXRjaC9TcHJpdGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvc3ByaXRlYmF0Y2gvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGViYXRjaC9UaWxlQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGViYXRjaC9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZW1hcHJlbmRlcmVyL1RpbGVtYXBSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvSW5kZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9WZXJ0ZXhCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UZXh0dXJlZEFuZEFscGhhU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVGlsZW1hcFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1VudGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVW50ZXh0dXJlZEFuZFRpbnRlZFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zbmFwc2hvdC9DYW52YXNTbmFwc2hvdC5qcyIsIndlYnBhY2s6Ly8vLi9zbmFwc2hvdC9XZWJHTFNuYXBzaG90LmpzIiwid2VicGFjazovLy8uL3NvdW5kL2R5bmFtaWMvRlguanMiLCJ3ZWJwYWNrOi8vLy4vc291bmQvZHluYW1pYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zdGF0ZS9HbG9iYWxTdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3RhdGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3RhdGUvc3lzdGVtcy9DYW1lcmFNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zdGF0ZS9zeXN0ZW1zL1N0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zdGF0ZS9zeXN0ZW1zL1VwZGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3RydWN0cy9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9KU09OSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4vdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldEZyb21BdGxhcy5qcyIsIndlYnBhY2s6Ly8vLi90ZXh0dXJlcy9wYXJzZXJzL1N0YXJsaW5nWE1MLmpzIiwid2VicGFjazovLy8uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vR2V0RWFzZUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL1Jlc2VydmVkUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vVHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vVHdlZW5CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL1R3ZWVuRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9Ud2Vlbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vY29tcG9uZW50cy9DYWxjRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vY29tcG9uZW50cy9Jbml0LmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2NvbXBvbmVudHMvTG9hZFZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9jb21wb25lbnRzL05leHRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9jb21wb25lbnRzL1BhdXNlLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2NvbXBvbmVudHMvUGxheS5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9jb21wb25lbnRzL1Jlc2V0VHdlZW5EYXRhLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2NvbXBvbmVudHMvUmVzdW1lLmpzIiwid2VicGFjazovLy8uL3R3ZWVuL2NvbXBvbmVudHMvU2Vlay5qcyIsIndlYnBhY2s6Ly8vLi90d2Vlbi9jb21wb25lbnRzL1NldEV2ZW50Q2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vY29tcG9uZW50cy9VcGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vdHdlZW4vY29tcG9uZW50cy9VcGRhdGVUd2VlbkRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vQWxpZ25Jbi5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9Cb3R0b21SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub0xlZnRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9MZWZ0Q2VudGVyLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvTGVmdFRvcC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub1JpZ2h0Qm90dG9tLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FsaWduL1RvUmlnaHRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9SaWdodFRvcC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9Ub1RvcExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWxpZ24vVG9Ub3BSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hbGlnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L0dldFJhbmRvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1F1aWNrU2VsZWN0LmpzIiwid2VicGFjazovLy8uL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYXJyYXkvU3RhYmxlU29ydC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ib3VuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvb2JqZWN0L0dldE1pbk1heFZhbHVlLmpzIiwid2VicGFjazovLy8uL3V0aWxzL29iamVjdC9NZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvTWVyZ2VSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvc3RyaW5nL0Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9zdHJpbmcvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9zdHJpbmcvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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TztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxLQUFLO0FBQ3BCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEk7Ozs7OztBQzVPRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzdEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYzs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixVQUFVLGNBQWM7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDL09BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUcsdUJBQXVCLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUNwUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakMsOEJBQThCLFdBQVc7QUFDekMsK0JBQStCLFlBQVk7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0IsS0FBSyxnQkFBZ0I7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjLEtBQUssVUFBVTs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPLHNHQUFzRztBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQyw4QkFBOEIsV0FBVztBQUN6Qyw2QkFBNkIsVUFBVTtBQUN2Qyw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7OztBQUdEOzs7Ozs7O0FDaFZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYSxHQUFHLGVBQWUsR0FBRyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FDcm9DRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQ2paRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUNoSUQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCLHFFQUFxRTtBQUNyRSxzQ0FBc0M7QUFDdEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0Isc0JBQXNCO0FBQ3RCLHdGQUF3RjtBQUN4RixVQUFVO0FBQ1Y7QUFDQTs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE1BQU07QUFDaEIsVUFBVSxNQUFNO0FBQ2hCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3ZDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDalZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTztBQUNyQyxpQ0FBaUMsV0FBVzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7OztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ25MQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7O0FDcEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVDQUF1QztBQUN4RCxpQkFBaUIsd0RBQXdEO0FBQ3pFLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pELFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxXQUFXO0FBQzNDLGtDQUFrQyxhQUFhO0FBQy9DLGlDQUFpQyxZQUFZOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDLGtDQUFrQyxhQUFhO0FBQy9DLGlDQUFpQyxZQUFZOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDalNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25PQTtBQUNBO0FBQ0EsdUNBQXVD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QUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QyxrQ0FBa0MsZ0JBQWdCOztBQUVsRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOzs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxjQUFjO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RCxvQ0FBb0MsZ0JBQWdCO0FBQ3BELGtDQUFrQyw4QkFBOEI7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RCxvQ0FBb0MsZ0JBQWdCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7Ozs7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjs7QUFFcEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxXQUFXOztBQUU3QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUN2Y0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG1FQUFtRTtBQUMzSTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7OztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDaklBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3hKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUJBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQyw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDN0tBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixNQUFNLDZFQUE2RSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDdEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakUsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDekpBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7QUFFdEMsY0FBYyx1QkFBdUI7QUFDckMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyw0QkFBNEI7O0FBRTFDO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQSxrQkFBa0IsYUFBYTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7O0FBRXRDLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsaUNBQWlDOztBQUUvQztBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxxQ0FBcUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDeENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLHVFQUF1RSxpQkFBaUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0dBQXdHO0FBQzVIO0FBQ0Esb0dBQW9HLGlCQUFpQjtBQUNySDtBQUNBO0FBQ0EsY0FBYyxPQUFPLHFDQUFxQyxtREFBbUQsT0FBTyx1QkFBdUI7QUFDM0ksZUFBZSxPQUFPLGdEQUFnRCxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsZ0JBQWdCLDZCQUE2QjtBQUNuRSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsZ0JBQWdCLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzdJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeERBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3hHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsK0JBQStCLGNBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QywrQkFBK0IsU0FBUzs7QUFFeEM7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzNQQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Qsa0JBQWtCLGFBQWE7QUFDL0IsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FB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QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3Qzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ05BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNJQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsaUNBQWlDLGlCQUFpQjs7QUFFbEQ7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixxRUFBcUU7QUFDbkcsOEJBQThCLHFFQUFxRTtBQUNuRyw4QkFBOEIscUVBQXFFOztBQUVuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDhCQUE4QixXQUFXOztBQUV6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDhCQUE4QixXQUFXOztBQUV6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQsK0JBQStCLFdBQVcsY0FBYzs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEdBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDblhBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxXQUFXOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6RkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QixLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVzs7QUFFN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xNQTtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7O0FDSEE7O0FBRUE7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQzFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDNUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxXQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzVZQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25DQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsbUNBQW1DOztBQUVqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2hEQTs7QUFFQTs7QUFFQTs7QUFFQSw4Qjs7Ozs7O0FDTkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbENBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9COztBQUV0RDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckRBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM5QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7O0FBRXJFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OEJBQThCLGdCQUFnQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUMzUUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakVBOztBQUVBLGFBQWEsT0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyw0RkFBNEY7O0FBRXRJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEtBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25CQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsNEZBQTRGOztBQUV0STtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzSEE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMzQkE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7O0FBRXhEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3RCQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDekJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeE5BO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25CQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDREQUE0RCxzQkFBc0I7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5WEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyx3RUFBd0U7QUFDdEYsY0FBYyxjQUFjO0FBQzVCLGNBQWMsYUFBYTtBQUMzQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLGtDQUFrQyxnQkFBZ0I7QUFDbEQsaUNBQWlDLFVBQVU7QUFDM0MseUNBQXlDLHNCQUFzQjtBQUMvRCx1Q0FBdUMsb0JBQW9COztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7O0FBRWxEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7O0FBRTNDOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7O0FBRWxEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7O0FBRXpDOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDM1RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhLEtBQUssV0FBVzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM3Q0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QixVQUFVLE9BQU87QUFDakIsVUFBVSxhQUFhO0FBQ3ZCLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1RBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsd0JBQXdCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyRkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBLGtDQUFrQyxlQUFlOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNYQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdkNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLFlBQVk7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsS0FBSztBQUNMLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGlDQUFpQywrQkFBK0I7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLHVCQUF1QixvQkFBb0I7QUFDM0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDcnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7O0FBRTVDLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRLGNBQWM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkRBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSx5QkFBeUI7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGO0FBQ0E7QUFDQTtBQUNBLDZGO0FBQ0E7QUFDQTtBQUNBLDJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQSwyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPOztBQUVqQzs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFCQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsOEJBQThCLFdBQVc7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsOEJBQThCLFdBQVc7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLDhCQUE4QixXQUFXOztBQUV6QztBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7Ozs7Ozs7QUNqREE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDRCQUE0QixXQUFXOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQyxVQUFVLGVBQWU7QUFDekIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLGNBQWM7O0FBRXhEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7O0FBRWhEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTs7QUFFaEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnRkFBZ0YscUJBQXFCOztBQUVyRztBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MseURBQXlEOztBQUUzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTs7Ozs7Ozs7QUNsQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNq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QUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwTEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHlEQUF5RCxxQkFBcUI7O0FBRTlFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzdCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5REFBeUQscUJBQXFCO0FBQzlFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN0UUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6TUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQWdEO0FBQ3pELFNBQVMsZ0RBQWdEO0FBQ3pELFNBQVMsZ0RBQWdEO0FBQ3pELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0FBdUMsd0JBQXdCLFFBQVEsUUFBUSxXQUFXLE1BQU0sbUNBQW1DLHFFQUFxRSx3Q0FBd0MsdUJBQXVCLDRCQUE0QixrQ0FBa0MsU0FBUyxXQUFXLEtBQUssWUFBWSxjQUFjLGdCQUFnQixJQUFJLGdDQUFnQyx3Q0FBd0MsVUFBVSxHQUFHLEVBQUUsR0FBRyxTQUFTLEU7Ozs7OztBQ0FwM007QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2puQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN4UkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3pVQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIseUJBQXlCOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMWhCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7O0FBRXBCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUMxRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTztBQUNyQyxrQ0FBa0MsOEJBQThCO0FBQ2hFLG1DQUFtQyxnQ0FBZ0M7O0FBRW5FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOzs7Ozs7O0FDM1hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUM5RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUxBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLFNBQVM7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJQaGFzZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUGhhc2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBoYXNlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY4OCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNTU4Nzg3ZDYzOTU2OTdlZmM2MjIiLCIvLyAgU291cmNlIG9iamVjdFxyXG4vLyAgVGhlIGtleSBhcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Yga2V5cywgaS5lLiAnYmFubmVyJywgb3IgJ2Jhbm5lci5oaWRlQmFubmVyJ1xyXG4vLyAgVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBrZXkgZG9lc24ndCBleGlzdFxyXG5cclxudmFyIEdldFZhbHVlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpXHJcbntcclxuICAgIGlmICghc291cmNlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkuaW5kZXhPZignLicpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHNvdXJjZTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcblxyXG4gICAgICAgIC8vICBVc2UgZm9yIGxvb3AgaGVyZSBzbyB3ZSBjYW4gYnJlYWsgZWFybHlcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Lmhhc093blByb3BlcnR5KGtleXNbaV0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgWWVzIGl0IGhhcyBhIGtleSBwcm9wZXJ0eSwgbGV0J3MgY2Fycnkgb24gZG93blxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJlbnRba2V5c1tpXV07XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W2tleXNbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIENhbid0IGdvIGFueSBmdXJ0aGVyLCBzbyByZXNldCB0byBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VmFsdWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0dldFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUYWtlbiBmcm9tIGtsYXNzZSBieSBtYXR0ZGVzbCBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wva2xhc3NlXHJcblxyXG5mdW5jdGlvbiBoYXNHZXR0ZXJPclNldHRlciAoZGVmKVxyXG57XHJcbiAgICByZXR1cm4gKCEhZGVmLmdldCAmJiB0eXBlb2YgZGVmLmdldCA9PT0gJ2Z1bmN0aW9uJykgfHwgKCEhZGVmLnNldCAmJiB0eXBlb2YgZGVmLnNldCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5IChkZWZpbml0aW9uLCBrLCBpc0NsYXNzRGVzY3JpcHRvcilcclxue1xyXG4gICAgLy8gIFRoaXMgbWF5IGJlIGEgbGlnaHR3ZWlnaHQgb2JqZWN0LCBPUiBpdCBtaWdodCBiZSBhIHByb3BlcnR5IHRoYXQgd2FzIGRlZmluZWQgcHJldmlvdXNseS5cclxuICAgIFxyXG4gICAgLy8gIEZvciBzaW1wbGUgY2xhc3MgZGVzY3JpcHRvcnMgd2UgY2FuIGp1c3QgYXNzdW1lIGl0cyBOT1QgcHJldmlvdXNseSBkZWZpbmVkLlxyXG4gICAgdmFyIGRlZiA9IChpc0NsYXNzRGVzY3JpcHRvcikgPyBkZWZpbml0aW9uW2tdIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZpbml0aW9uLCBrKTtcclxuXHJcbiAgICBpZiAoIWlzQ2xhc3NEZXNjcmlwdG9yICYmIGRlZi52YWx1ZSAmJiB0eXBlb2YgZGVmLnZhbHVlID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBkZWYgPSBkZWYudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoaXMgbWlnaHQgYmUgYSByZWd1bGFyIHByb3BlcnR5LCBvciBpdCBtYXkgYmUgYSBnZXR0ZXIvc2V0dGVyIHRoZSB1c2VyIGRlZmluZWQgaW4gYSBjbGFzcy5cclxuICAgIGlmIChkZWYgJiYgaGFzR2V0dGVyT3JTZXR0ZXIoZGVmKSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRlZi5lbnVtZXJhYmxlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlZi5lbnVtZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvbmZpZ3VyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWYuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNOb25Db25maWd1cmFibGUgKG9iaiwgaylcclxue1xyXG4gICAgdmFyIHByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgayk7XHJcblxyXG4gICAgaWYgKCFwcm9wKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvcC52YWx1ZSAmJiB0eXBlb2YgcHJvcC52YWx1ZSA9PT0gJ29iamVjdCcpXHJcbiAgICB7XHJcbiAgICAgICAgcHJvcCA9IHByb3AudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3AuY29uZmlndXJhYmxlID09PSBmYWxzZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCAoY3RvciwgZGVmaW5pdGlvbiwgaXNDbGFzc0Rlc2NyaXB0b3IsIGV4dGVuZClcclxue1xyXG4gICAgZm9yICh2YXIgayBpbiBkZWZpbml0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlZiA9IGdldFByb3BlcnR5KGRlZmluaXRpb24sIGssIGlzQ2xhc3NEZXNjcmlwdG9yKTtcclxuXHJcbiAgICAgICAgaWYgKGRlZiAhPT0gZmFsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgSWYgRXh0ZW5kcyBpcyB1c2VkLCB3ZSB3aWxsIGNoZWNrIGl0cyBwcm90b3R5cGUgdG8gc2VlIGlmIHRoZSBmaW5hbCB2YXJpYWJsZSBleGlzdHMuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZXh0ZW5kIHx8IGN0b3I7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzTm9uQ29uZmlndXJhYmxlKHBhcmVudC5wcm90b3R5cGUsIGspKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgSnVzdCBza2lwIHRoZSBmaW5hbCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgaWYgKENsYXNzLmlnbm9yZUZpbmFscylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgV2UgY2Fubm90IHJlLWRlZmluZSBhIHByb3BlcnR5IHRoYXQgaXMgY29uZmlndXJhYmxlPWZhbHNlLlxyXG4gICAgICAgICAgICAgICAgLy8gIFNvIHdlIHdpbGwgY29uc2lkZXIgdGhlbSBmaW5hbCBhbmQgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgYnlcclxuICAgICAgICAgICAgICAgIC8vICBkZWZhdWx0IHNvIGl0IGlzIGNsZWFyIHRvIHRoZSBkZXZlbG9wZXIgd2hhdCBpcyBoYXBwZW5pbmcuXHJcbiAgICAgICAgICAgICAgICAvLyAgWW91IGNhbiBzZXQgaWdub3JlRmluYWxzIHRvIHRydWUgaWYgeW91IG5lZWQgdG8gZXh0ZW5kIGEgY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vICB3aGljaCBoYXMgY29uZmlndXJhYmxlPWZhbHNlOyBpdCB3aWxsIHNpbXBseSBub3QgcmUtZGVmaW5lIGZpbmFsIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBmaW5hbCBwcm9wZXJ0eSBcXCcnICsgayArICdcXCcsIHNldCBDbGFzcy5pZ25vcmVGaW5hbHMgPSB0cnVlIHRvIHNraXAnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrLCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVtrXSA9IGRlZmluaXRpb25ba107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaXhpbiAobXlDbGFzcywgbWl4aW5zKVxyXG57XHJcbiAgICBpZiAoIW1peGlucylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1peGlucykpXHJcbiAgICB7XHJcbiAgICAgICAgbWl4aW5zID0gWyBtaXhpbnMgXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBleHRlbmQobXlDbGFzcywgbWl4aW5zW2ldLnByb3RvdHlwZSB8fCBtaXhpbnNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBkZXNjcmlwdG9yLlxyXG4gKiBUaGUgY29uc3RydWN0b3IsIGRlZmluZWQgYnkgdGhlIG5hbWUgYGluaXRpYWxpemVgLFxyXG4gKiBpcyBhbiBvcHRpb25hbCBmdW5jdGlvbi4gSWYgdW5zcGVjaWZpZWQsIGFuIGFub255bW91c1xyXG4gKiBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgd2hpY2ggY2FsbHMgdGhlIHBhcmVudCBjbGFzcyAoaWZcclxuICogb25lIGV4aXN0cykuXHJcbiAqXHJcbiAqIFlvdSBjYW4gYWxzbyB1c2UgYEV4dGVuZHNgIGFuZCBgTWl4aW5zYCB0byBwcm92aWRlIHN1YmNsYXNzaW5nXHJcbiAqIGFuZCBpbmhlcml0YW5jZS5cclxuICpcclxuICogQGNsYXNzICBDbGFzc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gYSBkaWN0aW9uYXJ5IG9mIGZ1bmN0aW9ucyBmb3IgdGhlIGNsYXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqICAgICAgdmFyIE15Q2xhc3MgPSBuZXcgUGhhc2VyLkNsYXNzKHtcclxuICogICAgICBcclxuICogICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgICAgICAgICB0aGlzLmZvbyA9IDIuMDtcclxuICogICAgICAgICAgfSxcclxuICpcclxuICogICAgICAgICAgYmFyOiBmdW5jdGlvbigpIHtcclxuICogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbyArIDU7XHJcbiAqICAgICAgICAgIH1cclxuICogICAgICB9KTtcclxuICovXHJcbmZ1bmN0aW9uIENsYXNzIChkZWZpbml0aW9uKVxyXG57XHJcbiAgICBpZiAoIWRlZmluaXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgZGVmaW5pdGlvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBUaGUgdmFyaWFibGUgbmFtZSBoZXJlIGRpY3RhdGVzIHdoYXQgd2Ugc2VlIGluIENocm9tZSBkZWJ1Z2dlclxyXG4gICAgdmFyIGluaXRpYWxpemU7XHJcbiAgICB2YXIgRXh0ZW5kcztcclxuXHJcbiAgICBpZiAoZGVmaW5pdGlvbi5pbml0aWFsaXplKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5pbml0aWFsaXplICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsaXplIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdGlhbGl6ZSA9IGRlZmluaXRpb24uaW5pdGlhbGl6ZTtcclxuXHJcbiAgICAgICAgLy8gIFVzdWFsbHkgd2Ugc2hvdWxkIGF2b2lkICdkZWxldGUnIGluIFY4IGF0IGFsbCBjb3N0cy5cclxuICAgICAgICAvLyAgSG93ZXZlciwgaXRzIHVubGlrZWx5IHRvIG1ha2UgYW55IHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcclxuICAgICAgICAvLyAgaGVyZSBzaW5jZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbiBjbGFzcyBjcmVhdGlvbiAoaS5lLiBub3Qgb2JqZWN0IGNyZWF0aW9uKS5cclxuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5pbml0aWFsaXplO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmIChkZWZpbml0aW9uLkV4dGVuZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9IGRlZmluaXRpb24uRXh0ZW5kcztcclxuXHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uRXh0ZW5kcylcclxuICAgIHtcclxuICAgICAgICBpbml0aWFsaXplLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZGVmaW5pdGlvbi5FeHRlbmRzLnByb3RvdHlwZSk7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG5cclxuICAgICAgICAvLyAgRm9yIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB0byB3b3JrLCB3ZSBuZWVkIHRvIGFjdCBkaXJlY3RseSBvbiB0aGUgRXh0ZW5kcyAob3IgTWl4aW4pXHJcblxyXG4gICAgICAgIEV4dGVuZHMgPSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcblxyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLkV4dGVuZHM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBHcmFiIHRoZSBtaXhpbnMsIGlmIHRoZXkgYXJlIHNwZWNpZmllZC4uLlxyXG4gICAgdmFyIG1peGlucyA9IG51bGw7XHJcblxyXG4gICAgaWYgKGRlZmluaXRpb24uTWl4aW5zKVxyXG4gICAge1xyXG4gICAgICAgIG1peGlucyA9IGRlZmluaXRpb24uTWl4aW5zO1xyXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLk1peGlucztcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRmlyc3QsIG1peGluIGlmIHdlIGNhbi5cclxuICAgIG1peGluKGluaXRpYWxpemUsIG1peGlucyk7XHJcblxyXG4gICAgLy8gIE5vdyB3ZSBncmFiIHRoZSBhY3R1YWwgZGVmaW5pdGlvbiB3aGljaCBkZWZpbmVzIHRoZSBvdmVycmlkZXMuXHJcbiAgICBleHRlbmQoaW5pdGlhbGl6ZSwgZGVmaW5pdGlvbiwgdHJ1ZSwgRXh0ZW5kcyk7XHJcblxyXG4gICAgcmV0dXJuIGluaXRpYWxpemU7XHJcbn1cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGV4dGVuZDtcclxuQ2xhc3MubWl4aW4gPSBtaXhpbjtcclxuQ2xhc3MuaWdub3JlRmluYWxzID0gZmFsc2U7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL0NsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkNvbW1vbmAgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiB0byBhbGwgbW9kdWxlcy5cclxuKlxyXG4qIEBjbGFzcyBDb21tb25cclxuKi9cclxuXHJcbnZhciBDb21tb24gPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tbW9uO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIENvbW1vbi5fbmV4dElkID0gMDtcclxuICAgIENvbW1vbi5fc2VlZCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmRzIHRoZSBvYmplY3QgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IHVzaW5nIHRoZSBvYmplY3QgaW4gdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICAgICAqIEBtZXRob2QgZXh0ZW5kXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXBcclxuICAgICAqIEByZXR1cm4ge30gb2JqIGV4dGVuZGVkXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5leHRlbmQgPSBmdW5jdGlvbihvYmosIGRlZXApIHtcclxuICAgICAgICB2YXIgYXJnc1N0YXJ0LFxyXG4gICAgICAgICAgICBhcmdzLFxyXG4gICAgICAgICAgICBkZWVwQ2xvbmU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGVlcCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGFyZ3NTdGFydCA9IDI7XHJcbiAgICAgICAgICAgIGRlZXBDbG9uZSA9IGRlZXA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXJnc1N0YXJ0ID0gMTtcclxuICAgICAgICAgICAgZGVlcENsb25lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBhcmdzU3RhcnQ7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXBDbG9uZSAmJiBzb3VyY2VbcHJvcF0gJiYgc291cmNlW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmpbcHJvcF0gfHwgb2JqW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IG9ialtwcm9wXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5leHRlbmQob2JqW3Byb3BdLCBkZWVwQ2xvbmUsIHNvdXJjZVtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbG9uZSBvZiB0aGUgb2JqZWN0LCBpZiBkZWVwIGlzIHRydWUgcmVmZXJlbmNlcyB3aWxsIGFsc28gYmUgY2xvbmVkLlxyXG4gICAgICogQG1ldGhvZCBjbG9uZVxyXG4gICAgICogQHBhcmFtIHt9IG9ialxyXG4gICAgICogQHBhcmFtIHtib29sfSBkZWVwXHJcbiAgICAgKiBAcmV0dXJuIHt9IG9iaiBjbG9uZWRcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNsb25lID0gZnVuY3Rpb24ob2JqLCBkZWVwKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoe30sIGRlZXAsIG9iaik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBrZXlzIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBrZXlzXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0ga2V5c1xyXG4gICAgICovXHJcbiAgICBDb21tb24ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cylcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcblxyXG4gICAgICAgIC8vIGF2b2lkIGhhc093blByb3BlcnR5IGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcclxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHt9IG9ialxyXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHRoZSBvYmplY3RzIHByb3BlcnR5IHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBDb21tb24udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gob2JqW2tleXNbaV1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBhdm9pZCBoYXNPd25Qcm9wZXJ0eSBmb3IgcGVyZm9ybWFuY2VcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChvYmpba2V5XSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgZnJvbSBgYmFzZWAgcmVsYXRpdmUgdG8gdGhlIGBwYXRoYCBzdHJpbmcuXHJcbiAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICogQHBhcmFtIHt9IG9iaiBUaGUgYmFzZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYCwgZS5nLiAnRm9vLkJhci5iYXonXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXSBQYXRoIHNsaWNlIGJlZ2luXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcclxuICAgICAqIEByZXR1cm4ge30gVGhlIG9iamVjdCBhdCB0aGUgZ2l2ZW4gcGF0aFxyXG4gICAgICovXHJcbiAgICBDb21tb24uZ2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKS5zbGljZShiZWdpbiwgZW5kKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHZhbHVlIG9uIGBiYXNlYCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gYHBhdGhgIHN0cmluZy5cclxuICAgICAqIEBtZXRob2Qgc2V0XHJcbiAgICAgKiBAcGFyYW0ge30gb2JqIFRoZSBiYXNlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgLCBlLmcuICdGb28uQmFyLmJheidcclxuICAgICAqIEBwYXJhbSB7fSB2YWwgVGhlIHZhbHVlIHRvIHNldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbl0gUGF0aCBzbGljZSBiZWdpblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIFBhdGggc2xpY2UgZW5kXHJcbiAgICAgKiBAcmV0dXJuIHt9IFBhc3MgdGhyb3VnaCBgdmFsYCBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLnNldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgdmFsLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLicpLnNsaWNlKGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIENvbW1vbi5nZXQob2JqLCBwYXRoLCAwLCAtMSlbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGhleCBjb2xvdXIgc3RyaW5nIG1hZGUgYnkgbGlnaHRlbmluZyBvciBkYXJrZW5pbmcgY29sb3IgYnkgcGVyY2VudC5cclxuICAgICAqIEBtZXRob2Qgc2hhZGVDb2xvclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudFxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIGhleCBjb2xvdXJcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLnNoYWRlQ29sb3IgPSBmdW5jdGlvbihjb2xvciwgcGVyY2VudCkgeyAgIFxyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU2MDI0OC9wcm9ncmFtbWF0aWNhbGx5LWxpZ2h0ZW4tb3ItZGFya2VuLWEtaGV4LWNvbG9yXHJcbiAgICAgICAgdmFyIGNvbG9ySW50ZWdlciA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLDE2KSwgXHJcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGgucm91bmQoMi41NSAqIHBlcmNlbnQpLCBcclxuICAgICAgICAgICAgUiA9IChjb2xvckludGVnZXIgPj4gMTYpICsgYW1vdW50LCBcclxuICAgICAgICAgICAgQiA9IChjb2xvckludGVnZXIgPj4gOCAmIDB4MDBGRikgKyBhbW91bnQsIFxyXG4gICAgICAgICAgICBHID0gKGNvbG9ySW50ZWdlciAmIDB4MDAwMEZGKSArIGFtb3VudDtcclxuICAgICAgICByZXR1cm4gXCIjXCIgKyAoMHgxMDAwMDAwICsgKFIgPCAyNTUgPyBSIDwgMSA/IDAgOiBSIDoyNTUpICogMHgxMDAwMCBcclxuICAgICAgICAgICAgICAgICsgKEIgPCAyNTUgPyBCIDwgMSA/IDAgOiBCIDogMjU1KSAqIDB4MTAwIFxyXG4gICAgICAgICAgICAgICAgKyAoRyA8IDI1NSA/IEcgPCAxID8gMCA6IEcgOiAyNTUpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2h1ZmZsZXMgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cclxuICAgICAqIEBtZXRob2Qgc2h1ZmZsZVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyYXlcclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBzaHVmZmxlZCByYW5kb21seVxyXG4gICAgICovXHJcbiAgICBDb21tb24uc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKENvbW1vbi5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgICAgICAgICBhcnJheVtqXSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSYW5kb21seSBjaG9vc2VzIGEgdmFsdWUgZnJvbSBhIGxpc3Qgd2l0aCBlcXVhbCBwcm9iYWJpbGl0eS5cclxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXHJcbiAgICAgKiBAbWV0aG9kIGNob29zZVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gY2hvaWNlc1xyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJhbmRvbSBjaG9pY2Ugb2JqZWN0IGZyb20gdGhlIGFycmF5XHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNob2ljZXNbTWF0aC5mbG9vcihDb21tb24ucmFuZG9tKCkgKiBjaG9pY2VzLmxlbmd0aCldO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqIEBtZXRob2QgaXNFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NDI4Ni9qYXZhc2NyaXB0LWlzZG9tLWhvdy1kby15b3UtY2hlY2staWYtYS1qYXZhc2NyaXB0LW9iamVjdC1pcy1hLWRvbS1vYmplY3RcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpe1xyXG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvYmo9PT1cIm9iamVjdFwiKSAmJlxyXG4gICAgICAgICAgICAgIChvYmoubm9kZVR5cGU9PT0xKSAmJiAodHlwZW9mIG9iai5zdHlsZSA9PT0gXCJvYmplY3RcIikgJiZcclxuICAgICAgICAgICAgICAodHlwZW9mIG9iai5vd25lckRvY3VtZW50ID09PVwib2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheS5cclxuICAgICAqIEBtZXRob2QgaXNBcnJheVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5LCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbi5cclxuICAgICAqIEBtZXRob2QgaXNGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBDb21tb24uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBwbGFpbiBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGlzUGxhaW5PYmplY3RcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHBsYWluIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nLlxyXG4gICAgICogQG1ldGhvZCBpc1N0cmluZ1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdpdmVuIHZhbHVlIGNsYW1wZWQgYmV0d2VlbiBhIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuXHJcbiAgICAgKiBAbWV0aG9kIGNsYW1wXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGNsYW1wZWQgYmV0d2VlbiBtaW4gYW5kIG1heCBpbmNsdXNpdmVcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKVxyXG4gICAgICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+IG1heClcclxuICAgICAgICAgICAgcmV0dXJuIG1heDtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICogQG1ldGhvZCBzaWduXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgaWYgbmVnYXRpdmUsICsxIGlmIDAgb3IgcG9zaXRpdmVcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLnNpZ24gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyAtMSA6IDE7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZXN0YW1wIChoaWdoLXJlcyBpZiBhdmFpbGFibGUpLlxyXG4gICAgICogQG1ldGhvZCBub3dcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgdGltZXN0YW1wIChoaWdoLXJlcyBpZiBhdmFpbGFibGUpXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5ub3cgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMTI5NC9ob3ctZG8teW91LWdldC1hLXRpbWVzdGFtcC1pbi1qYXZhc2NyaXB0XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZGF2aWR3YXRlcnN0b24vMjk4MjUzMVxyXG5cclxuICAgICAgICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge307XHJcblxyXG4gICAgICAgIHBlcmZvcm1hbmNlLm5vdyA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdyAgICB8fFxyXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS53ZWJraXROb3cgICAgIHx8XHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgICAgfHxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2Uub05vdyAgICAgICAgICB8fFxyXG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgICAgIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKTsgfTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIGEgbWluaW11bSBhbmQgYSBtYXhpbXVtIHZhbHVlIGluY2x1c2l2ZS5cclxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXHJcbiAgICAgKiBAbWV0aG9kIHJhbmRvbVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heCBpbmNsdXNpdmVcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgbWluID0gKHR5cGVvZiBtaW4gIT09IFwidW5kZWZpbmVkXCIpID8gbWluIDogMDtcclxuICAgICAgICBtYXggPSAodHlwZW9mIG1heCAhPT0gXCJ1bmRlZmluZWRcIikgPyBtYXggOiAxO1xyXG4gICAgICAgIHJldHVybiBtaW4gKyBfc2VlZGVkUmFuZG9tKCkgKiAobWF4IC0gbWluKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9zZWVkZWRSYW5kb20gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZ3J5bWFuLzM4MzA0ODlcclxuICAgICAgICBDb21tb24uX3NlZWQgPSAoQ29tbW9uLl9zZWVkICogOTMwMSArIDQ5Mjk3KSAlIDIzMzI4MDtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLl9zZWVkIC8gMjMzMjgwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgQ1NTIGhleCBjb2xvdXIgc3RyaW5nIGludG8gYW4gaW50ZWdlci5cclxuICAgICAqIEBtZXRob2QgY29sb3JUb051bWJlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBDU1MgaGV4IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBDb21tb24uY29sb3JUb051bWJlciA9IGZ1bmN0aW9uKGNvbG9yU3RyaW5nKSB7XHJcbiAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5yZXBsYWNlKCcjJywnJyk7XHJcblxyXG4gICAgICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLmNoYXJBdCgwKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNvbG9yU3RyaW5nLmNoYXJBdCgxKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNvbG9yU3RyaW5nLmNoYXJBdCgyKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25zb2xlIGxvZ2dpbmcgbGV2ZWwgdG8gdXNlLCB3aGVyZSBlYWNoIGxldmVsIGluY2x1ZGVzIGFsbCBsZXZlbHMgYWJvdmUgYW5kIGV4Y2x1ZGVzIHRoZSBsZXZlbHMgYmVsb3cuXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBsZXZlbCBpcyAnZGVidWcnIHdoaWNoIHNob3dzIGFsbCBjb25zb2xlIG1lc3NhZ2VzLiAgXHJcbiAgICAgKlxyXG4gICAgICogUG9zc2libGUgbGV2ZWwgdmFsdWVzIGFyZTpcclxuICAgICAqIC0gMCA9IE5vbmVcclxuICAgICAqIC0gMSA9IERlYnVnXHJcbiAgICAgKiAtIDIgPSBJbmZvXHJcbiAgICAgKiAtIDMgPSBXYXJuXHJcbiAgICAgKiAtIDQgPSBFcnJvclxyXG4gICAgICogQHByb3BlcnR5IENvbW1vbi5sb2dMZXZlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmxvZ0xldmVsID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGEgYGNvbnNvbGUubG9nYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxyXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cclxuICAgICAqIEBtZXRob2QgbG9nXHJcbiAgICAgKiBAcGFyYW0gLi4ub2JqcyB7fSBUaGUgb2JqZWN0cyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5sb2cgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29uc29sZSAmJiBDb21tb24ubG9nTGV2ZWwgPiAwICYmIENvbW1vbi5sb2dMZXZlbCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGEgYGNvbnNvbGUuaW5mb2AgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cclxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXHJcbiAgICAgKiBAbWV0aG9kIGluZm9cclxuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmluZm8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29uc29sZSAmJiBDb21tb24ubG9nTGV2ZWwgPiAwICYmIENvbW1vbi5sb2dMZXZlbCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLndhcm5gIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXHJcbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxyXG4gICAgICogQG1ldGhvZCB3YXJuXHJcbiAgICAgKiBAcGFyYW0gLi4ub2JqcyB7fSBUaGUgb2JqZWN0cyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi53YXJuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgc2VxdWVudGlhbCBJRC5cclxuICAgICAqIEBtZXRob2QgbmV4dElkXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBzZXF1ZW50aWFsIElEXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5uZXh0SWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLl9uZXh0SWQrKztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNyb3NzIGJyb3dzZXIgY29tcGF0aWJsZSBpbmRleE9mIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBpbmRleE9mXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBoYXlzdGFja1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5lZWRsZVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgbmVlZGxlIGluIGhheXN0YWNrLCBvdGhlcndpc2UgLTEuXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5pbmRleE9mID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSkge1xyXG4gICAgICAgIGlmIChoYXlzdGFjay5pbmRleE9mKVxyXG4gICAgICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXlzdGFja1tpXSA9PT0gbmVlZGxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjcm9zcyBicm93c2VyIGNvbXBhdGlibGUgYXJyYXkgbWFwIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBtYXBcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxpc3RcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEByZXR1cm4ge2FycmF5fSBWYWx1ZXMgZnJvbSBsaXN0IHRyYW5zZm9ybWVkIGJ5IGZ1bmMuXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5tYXAgPSBmdW5jdGlvbihsaXN0LCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKGxpc3QubWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZ1bmMobGlzdFtpXSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGRpcmVjdGVkIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBwYXJ0aWFsbHkgb3JkZXJlZCBzZXQgb2YgdmVydGljZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXHJcbiAgICAgKiBDaXJjdWxhciBkZXBlbmRlbmNpZXMgYXJlIGFsbG93ZWQuXHJcbiAgICAgKiBAbWV0aG9kIHRvcG9sb2dpY2FsU29ydFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gUGFydGlhbGx5IG9yZGVyZWQgc2V0IG9mIHZlcnRpY2VzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBDb21tb24udG9wb2xvZ2ljYWxTb3J0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcclxuICAgICAgICAvLyBodHRwczovL21nZWNoZXYuZ2l0aHViLmlvL2phdmFzY3JpcHQtYWxnb3JpdGhtcy9ncmFwaHNfb3RoZXJzX3RvcG9sb2dpY2FsLXNvcnQuanMuaHRtbFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgdmlzaXRlZCA9IFtdLFxyXG4gICAgICAgICAgICB0ZW1wID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIG5vZGUgaW4gZ3JhcGgpIHtcclxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW25vZGVdICYmICF0ZW1wW25vZGVdKSB7XHJcbiAgICAgICAgICAgICAgICBfdG9wb2xvZ2ljYWxTb3J0KG5vZGUsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3RvcG9sb2dpY2FsU29ydCA9IGZ1bmN0aW9uKG5vZGUsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpIHtcclxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGhbbm9kZV0gfHwgW107XHJcbiAgICAgICAgdGVtcFtub2RlXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ZW1wW25laWdoYm9yXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbmVpZ2hib3JdKSB7XHJcbiAgICAgICAgICAgICAgICBfdG9wb2xvZ2ljYWxTb3J0KG5laWdoYm9yLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGVtcFtub2RlXSA9IGZhbHNlO1xyXG4gICAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBfbl8gZnVuY3Rpb25zIGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZW0gaW4gb3JkZXIuXHJcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFwcGxpZWQgd2hlbiBjYWxsaW5nIHRoZSBuZXcgZnVuY3Rpb24gd2lsbCBhbHNvIGJlIGFwcGxpZWQgdG8gZXZlcnkgZnVuY3Rpb24gcGFzc2VkLlxyXG4gICAgICogVGhlIHZhbHVlIG9mIGB0aGlzYCByZWZlcnMgdG8gdGhlIGxhc3QgdmFsdWUgcmV0dXJuZWQgaW4gdGhlIGNoYWluIHRoYXQgd2FzIG5vdCBgdW5kZWZpbmVkYC5cclxuICAgICAqIFRoZXJlZm9yZSBpZiBhIHBhc3NlZCBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZSwgdGhlIHByZXZpb3VzbHkgcmV0dXJuZWQgdmFsdWUgaXMgbWFpbnRhaW5lZC5cclxuICAgICAqIEFmdGVyIGFsbCBwYXNzZWQgZnVuY3Rpb25zIGhhdmUgYmVlbiBjYWxsZWQgdGhlIG5ldyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXN0IHJldHVybmVkIHZhbHVlIChpZiBhbnkpLlxyXG4gICAgICogSWYgYW55IG9mIHRoZSBwYXNzZWQgZnVuY3Rpb25zIGFyZSBhIGNoYWluLCB0aGVuIHRoZSBjaGFpbiB3aWxsIGJlIGZsYXR0ZW5lZC5cclxuICAgICAqIEBtZXRob2QgY2hhaW5cclxuICAgICAqIEBwYXJhbSAuLi5mdW5jcyB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbnMgdG8gY2hhaW4uXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcGFzc2VkIGZ1bmN0aW9ucyBpbiBvcmRlci5cclxuICAgICAqL1xyXG4gICAgQ29tbW9uLmNoYWluID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGZ1bmNzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJndW1lbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZ1bmMuX2NoYWluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gYWxyZWFkeSBjaGFpbmVkIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgZnVuY3MucHVzaC5hcHBseShmdW5jcywgZnVuYy5fY2hhaW5lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jcy5wdXNoKGZ1bmMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9kZXZ0b29scy1kb2NzL2lzc3Vlcy81MyNpc3N1ZWNvbW1lbnQtNTE5NDEzNThcclxuICAgICAgICAgICAgdmFyIGxhc3RSZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jc1tpXS5hcHBseShsYXN0UmVzdWx0LCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjaGFpbi5fY2hhaW5lZCA9IGZ1bmNzO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hhaW47XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGJlZm9yZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgYmFzZWAuXHJcbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cclxuICAgICAqIEBtZXRob2QgY2hhaW5QYXRoQmVmb3JlXHJcbiAgICAgKiBAcGFyYW0ge30gYmFzZSBUaGUgYmFzZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYmVmb3JlIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5jaGFpblBhdGhCZWZvcmUgPSBmdW5jdGlvbihiYXNlLCBwYXRoLCBmdW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5zZXQoYmFzZSwgcGF0aCwgQ29tbW9uLmNoYWluKFxyXG4gICAgICAgICAgICBmdW5jLFxyXG4gICAgICAgICAgICBDb21tb24uZ2V0KGJhc2UsIHBhdGgpXHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGFmdGVyIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBiYXNlYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBjaGFpblBhdGhBZnRlclxyXG4gICAgICogQHBhcmFtIHt9IGJhc2UgVGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGFmdGVyIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIENvbW1vbi5jaGFpblBhdGhBZnRlciA9IGZ1bmN0aW9uKGJhc2UsIHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLnNldChiYXNlLCBwYXRoLCBDb21tb24uY2hhaW4oXHJcbiAgICAgICAgICAgIENvbW1vbi5nZXQoYmFzZSwgcGF0aCksXHJcbiAgICAgICAgICAgIGZ1bmNcclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvQ29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgZ2xvYmFsIGxldmVsIGNvbnRhaW5lciBvZiBGYWN0b3J5IGluc3RhbmNlcy5cclxuKiBGYWN0b3JpZXMgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIHRoaXMgY29udGFpbmVyICh3aGVuIHJlcXVpcmVkKVxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiovXHJcblxyXG52YXIgZmFjdG9yaWVzID0ge307XHJcblxyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoZmFjdG9yaWVzLmhhc093blByb3BlcnR5KGZhY3RvcnkuS0VZKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoZmFjdG9yeS5LRVkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmYWN0b3JpZXNbZmFjdG9yeS5LRVldID0ge1xyXG4gICAgICAgICAgICAgICAgYWRkOiBmYWN0b3J5LmFkZCxcclxuICAgICAgICAgICAgICAgIG1ha2U6IGZhY3RvcnkubWFrZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldFR5cGUgPSBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWN0b3JpZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24gKGRlc3QsIGlzRmFjdG9yeSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBmYWN0b3J5IGluIGZhY3RvcmllcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3JpZXMuaGFzT3duUHJvcGVydHkoZmFjdG9yeSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbZmFjdG9yeV0gPSAoaXNGYWN0b3J5KSA/IGZhY3Rvcmllc1tmYWN0b3J5XS5hZGQgOiBmYWN0b3JpZXNbZmFjdG9yeV0ubWFrZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBbHBoYTogcmVxdWlyZSgnLi9BbHBoYScpLFxyXG4gICAgQW5pbWF0aW9uOiByZXF1aXJlKCcuL0FuaW1hdGlvbicpLFxyXG4gICAgQmxlbmRNb2RlOiByZXF1aXJlKCcuL0JsZW5kTW9kZScpLFxyXG4gICAgQ2hpbGRyZW46IHJlcXVpcmUoJy4vQ2hpbGRyZW4nKSxcclxuICAgIENvbG9yOiByZXF1aXJlKCcuL0NvbG9yJyksXHJcbiAgICBEYXRhOiByZXF1aXJlKCcuL0RhdGEnKSxcclxuICAgIEZsaXA6IHJlcXVpcmUoJy4vRmxpcCcpLFxyXG4gICAgR2V0Qm91bmRzOiByZXF1aXJlKCcuL0dldEJvdW5kcycpLFxyXG4gICAgT3JpZ2luOiByZXF1aXJlKCcuL09yaWdpbicpLFxyXG4gICAgUmVuZGVyVGFyZ2V0OiByZXF1aXJlKCcuL1JlbmRlclRhcmdldCcpLFxyXG4gICAgU2NhbGVNb2RlOiByZXF1aXJlKCcuL1NjYWxlTW9kZScpLFxyXG4gICAgU2Nyb2xsRmFjdG9yOiByZXF1aXJlKCcuL1Njcm9sbEZhY3RvcicpLFxyXG4gICAgU2l6ZTogcmVxdWlyZSgnLi9TaXplJyksXHJcbiAgICBUZXh0dXJlOiByZXF1aXJlKCcuL1RleHR1cmUnKSxcclxuICAgIFRvSlNPTjogcmVxdWlyZSgnLi9Ub0pTT04nKSxcclxuICAgIFRyYW5zZm9ybTogcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcclxuICAgIFRyYW5zZm9ybU1hdHJpeDogcmVxdWlyZSgnLi9UcmFuc2Zvcm1NYXRyaXgnKSxcclxuICAgIFZpc2libGU6IHJlcXVpcmUoJy4vVmlzaWJsZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUpXHJcbntcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgLy8gIFRoZSBlbGVtZW50IHRoYXQgaW5pdGlhdGVkIHRoZSBldmVudC5cclxuICAgIHRoaXMudGFyZ2V0O1xyXG5cclxuICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IHRydWU7XHJcbn07XHJcblxyXG5FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudDtcclxuXHJcbkV2ZW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKHRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZXZlbnRzL0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICBWRVJTSU9OOiAnMy4wLjAnLFxyXG5cclxuICAgIEFVVE86IDAsXHJcbiAgICBDQU5WQVM6IDEsXHJcbiAgICBXRUJHTDogMixcclxuICAgIEhFQURMRVNTOiAzXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgaXMgdGhlIGJhc2UgR2FtZSBPYmplY3QgY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSB3aGVuIGNyZWF0aW5nIHlvdXIgb3duIGV4dGVuZGVkIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG5cclxudmFyIEdhbWVPYmplY3QgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR2FtZU9iamVjdCAoc3RhdGUsIHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgICAgIC8vICAwMDAxIHwgMDAxMCB8IDAxMDAgfCAxMDAwXHJcbiAgICAgICAgLy8gIFdpbGwgUmVuZGVyIGJpdG1hc2sgZmxhZ3MgZm9yIHRoZSBjb21wb25lbnRzIFZpc2libGUsIEFscGhhLCBUcmFuc2Zvcm0gYW5kIFRleHR1cmUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgdGhpcy5yZW5kZXJNYXNrID0gMTU7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGbGFncyA9IDE1O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgVG8gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gR2FtZSBPYmplY3RzXHJcbiAgICBwcmVVcGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gR2FtZSBPYmplY3RzLCBidXQgcHJvdmlkZXMgZGVmYXVsdCBleHBvcnQgZnVuY3Rpb25hbGl0eVxyXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBDb21wb25lbnRzLlRvSlNPTih0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICB0aGlzLnkgPSB5O1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnQ7XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBTbW9vdGhpbmcgPSByZXF1aXJlKCcuL1Ntb290aGluZycpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwb29sIGludG8gd2hpY2ggdGhlIGNhbnZhcyBlbGVtZW50cyBhcmUgcGxhY2VkLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkgcG9vbFxyXG4gKiBAdHlwZSBBcnJheVxyXG4gKi9cclxudmFyIHBvb2wgPSBbXTtcclxuXHJcbi8vICBBdXRvbWF0aWNhbGx5IGFwcGx5IHNtb290aGluZyhmYWxzZSkgdG8gY3JlYXRlZCBDYW52YXMgZWxlbWVudHNcclxudmFyIF9kaXNhYmxlQ29udGV4dFNtb290aGluZyA9IGZhbHNlO1xyXG5cclxuLy8gIFRoaXMgc2luZ2xldG9uIGlzIGluc3RhbnRpYXRlZCBhcyBzb29uIGFzIFBoYXNlciBsb2FkcyxcclxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cclxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIG9uIHRoZSBzYW1lIHBhZ2VcclxuLy8gIGNhbiBzaGFyZSB0aGUgb25lIHNpbmdsZSBwb29sXHJcblxyXG4vKipcclxuKiBUaGUgQ2FudmFzUG9vbCBpcyBhIGdsb2JhbCBzdGF0aWMgb2JqZWN0LCB0aGF0IGFsbG93cyBQaGFzZXIgdG8gcmVjeWNsZSBhbmQgcG9vbCBDYW52YXMgRE9NIGVsZW1lbnRzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5DYW52YXNQb29sXHJcbiogQHN0YXRpY1xyXG4qL1xyXG52YXIgQ2FudmFzUG9vbCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGEgbmV3IENhbnZhcyBET00gZWxlbWVudCwgb3IgcHVsbHMgb25lIGZyb20gdGhlIHBvb2wgaWYgZnJlZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5jcmVhdGVcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAcGFyYW0ge2FueX0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSBjYW52YXMgZWxlbWVudC5cclxuICAgICovXHJcbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodCwgdHlwZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5jcmVhdGUnLCBwYXJlbnQpO1xyXG5cclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMTsgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxyXG5cclxuICAgICAgICB2YXIgY2FudmFzO1xyXG4gICAgICAgIHZhciBjb250YWluZXIgPSBmaXJzdCh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLmNyZWF0ZSBuZXcnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHtcclxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgY2FudmFzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHBvb2wucHVzaChjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhc1Bvb2wuY3JlYXRlIGV4aXN0aW5nJyk7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChfZGlzYWJsZUNvbnRleHRTbW9vdGhpbmcgJiYgdHlwZSA9PT0gQ09OU1QuQ0FOVkFTKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU21vb3RoaW5nLmRpc2FibGUoY2FudmFzLmdldENvbnRleHQoJzJkJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlMkQgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5DQU5WQVMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlV2ViR0wgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5XRUJHTCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBmcmVlIGNhbnZhcyBpbmRleCBmcm9tIHRoZSBwb29sLlxyXG4gICAgKlxyXG4gICAgKiBAc3RhdGljXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhc1Bvb2wuZ2V0Rmlyc3RcclxuICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIHZhciBmaXJzdCA9IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxyXG5cclxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudCAmJiBjb250YWluZXIudHlwZSA9PT0gdHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIExvb2tzIHVwIGEgY2FudmFzIGJhc2VkIG9uIGl0cyBwYXJlbnQsIGFuZCBpZiBmb3VuZCBwdXRzIGl0IGJhY2sgaW4gdGhlIHBvb2wsIGZyZWVpbmcgaXQgdXAgZm9yIHJlLXVzZS5cclxuICAgICogVGhlIGNhbnZhcyBoYXMgaXRzIHdpZHRoIGFuZCBoZWlnaHQgc2V0IHRvIDEsIGFuZCBpdHMgcGFyZW50IGF0dHJpYnV0ZSBudWxsZWQuXHJcbiAgICAqXHJcbiAgICAqIEBzdGF0aWNcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVcclxuICAgICogQHBhcmFtIHthbnl8SFRNTENhbnZhc0VsZW1lbnR9IHBhcmVudCAtIFRoZSBwYXJlbnQgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgKi9cclxuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHBhcmVudCBpcyBhIGNhbnZhcyBvYmplY3RcclxuICAgICAgICB2YXIgaXNDYW52YXMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHJcbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKGlzQ2FudmFzICYmIGNvbnRhaW5lci5jYW52YXMgPT09IHBhcmVudCkgfHwgKCFpc0NhbnZhcyAmJiBjb250YWluZXIucGFyZW50ID09PSBwYXJlbnQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5yZW1vdmUgZm91bmQgYW5kIHJlbW92ZWQnKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy53aWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmhlaWdodCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiB1c2VkIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICpcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldFRvdGFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBpbi11c2UgKHBhcmVudGVkKSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXHJcbiAgICAqL1xyXG4gICAgdmFyIHRvdGFsID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYyA9IDA7XHJcblxyXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmVlIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cclxuICAgICpcclxuICAgICogQHN0YXRpY1xyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldEZyZWVcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZyZWUgKHVuLXBhcmVudGVkKSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXHJcbiAgICAqL1xyXG4gICAgdmFyIGZyZWUgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBwb29sLmxlbmd0aCAtIHRvdGFsKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vICBEaXNhYmxlIGNvbnRleHQgc21vb3RoaW5nIG9uIGFueSBuZXcgQ2FudmFzIGVsZW1lbnQgY3JlYXRlZFxyXG4gICAgdmFyIGRpc2FibGVTbW9vdGhpbmcgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIF9kaXNhYmxlQ29udGV4dFNtb290aGluZyA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vICBFbmFibGUgY29udGV4dCBzbW9vdGhpbmcgb24gYW55IG5ldyBDYW52YXMgZWxlbWVudCBjcmVhdGVkXHJcbiAgICB2YXIgZW5hYmxlU21vb3RoaW5nID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBfZGlzYWJsZUNvbnRleHRTbW9vdGhpbmcgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjcmVhdGUyRDogY3JlYXRlMkQsXHJcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXHJcbiAgICAgICAgY3JlYXRlV2ViR0w6IGNyZWF0ZVdlYkdMLFxyXG4gICAgICAgIGRpc2FibGVTbW9vdGhpbmc6IGRpc2FibGVTbW9vdGhpbmcsXHJcbiAgICAgICAgZW5hYmxlU21vb3RoaW5nOiBlbmFibGVTbW9vdGhpbmcsXHJcbiAgICAgICAgZmlyc3Q6IGZpcnN0LFxyXG4gICAgICAgIGZyZWU6IGZyZWUsXHJcbiAgICAgICAgcG9vbDogcG9vbCxcclxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcclxuICAgICAgICB0b3RhbDogdG90YWxcclxuICAgIH07XHJcbn07XHJcblxyXG4vLyAgSWYgd2UgZXhwb3J0IHRoZSBjYWxsZWQgZnVuY3Rpb24gaGVyZSwgaXQnbGwgb25seSBiZSBpbnZva2VkIG9uY2UgKG5vdCBldmVyeSB0aW1lIGl0J3MgcmVxdWlyZWQpLlxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1Bvb2woKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vQ2FudmFzUG9vbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRklMRV9DT05TVCA9IHtcclxuXHJcbiAgICBMT0FERVJfSURMRTogMCxcclxuICAgIExPQURFUl9MT0FESU5HOiAxLFxyXG4gICAgTE9BREVSX1BST0NFU1NJTkc6IDIsXHJcbiAgICBMT0FERVJfQ09NUExFVEU6IDMsXHJcbiAgICBMT0FERVJfREVTVFJPWUVEOiA0LFxyXG5cclxuICAgIEZJTEVfUEVORElORzogNSwgICAgICAvLyBmaWxlIGlzIGluIHRoZSBsb2FkIHF1ZXVlIGJ1dCBub3QgeWV0IHN0YXJ0ZWRcclxuICAgIEZJTEVfTE9BRElORzogNiwgICAgICAvLyBmaWxlIGhhcyBiZWVuIHN0YXJ0ZWQgdG8gbG9hZCBieSB0aGUgbG9hZGVyIChvbkxvYWQgY2FsbGVkKVxyXG4gICAgRklMRV9MT0FERUQ6IDcsICAgICAgIC8vIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGF3YWl0aW5nIHByb2Nlc3NpbmdcclxuICAgIEZJTEVfRkFJTEVEOiA4LCAgICAgICAvLyBmaWxlIGZhaWxlZCB0byBsb2FkXHJcbiAgICBGSUxFX1BST0NFU1NJTkc6IDksICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfV0FJVElOR19MSU5LRklMRTogMTAsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfRVJST1JFRDogMTEsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcclxuICAgIEZJTEVfQ09NUExFVEU6IDEyLCAgICAgLy8gZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZ1xyXG4gICAgRklMRV9ERVNUUk9ZRUQ6IDEzLCAgICAgLy8gZmlsZSBoYXMgYmVlbiBkZXN0cm95ZWRcclxuXHJcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fQVJSQVk6IDIwLFxyXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0hBU0g6IDIxXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGSUxFX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSB7XHJcblxyXG4gICAgUEkyOiBNYXRoLlBJICogMixcclxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcclxuICAgIEVQU0lMT046IDEuMGUtNixcclxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXHJcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNQVRIX0NPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkJvdW5kc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIChBQUJCKS5cclxuKlxyXG4qIEBjbGFzcyBCb3VuZHNcclxuKi9cclxuXHJcbnZhciBCb3VuZHMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm91bmRzO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IChBQUJCKSBmb3IgdGhlIGdpdmVuIHZlcnRpY2VzLlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcmV0dXJuIHtib3VuZHN9IEEgbmV3IGJvdW5kcyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgQm91bmRzLmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHsgXHJcbiAgICAgICAgICAgIG1pbjogeyB4OiAwLCB5OiAwIH0sIFxyXG4gICAgICAgICAgICBtYXg6IHsgeDogMCwgeTogMCB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHZlcnRpY2VzKVxyXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKGJvdW5kcywgdmVydGljZXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBib3VuZHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBib3VuZHMgdXNpbmcgdGhlIGdpdmVuIHZlcnRpY2VzIGFuZCBleHRlbmRzIHRoZSBib3VuZHMgZ2l2ZW4gYSB2ZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIEJvdW5kcy51cGRhdGUgPSBmdW5jdGlvbihib3VuZHMsIHZlcnRpY2VzLCB2ZWxvY2l0eSkge1xyXG4gICAgICAgIGJvdW5kcy5taW4ueCA9IEluZmluaXR5O1xyXG4gICAgICAgIGJvdW5kcy5tYXgueCA9IC1JbmZpbml0eTtcclxuICAgICAgICBib3VuZHMubWluLnkgPSBJbmZpbml0eTtcclxuICAgICAgICBib3VuZHMubWF4LnkgPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAodmVydGV4LnggPiBib3VuZHMubWF4LngpIGJvdW5kcy5tYXgueCA9IHZlcnRleC54O1xyXG4gICAgICAgICAgICBpZiAodmVydGV4LnggPCBib3VuZHMubWluLngpIGJvdW5kcy5taW4ueCA9IHZlcnRleC54O1xyXG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPiBib3VuZHMubWF4LnkpIGJvdW5kcy5tYXgueSA9IHZlcnRleC55O1xyXG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPCBib3VuZHMubWluLnkpIGJvdW5kcy5taW4ueSA9IHZlcnRleC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAodmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4LnggKz0gdmVsb2NpdHkueDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueCArPSB2ZWxvY2l0eS54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodmVsb2NpdHkueSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueSArPSB2ZWxvY2l0eS55O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1pbi55ICs9IHZlbG9jaXR5Lnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBib3VuZHMgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gICAgICogQG1ldGhvZCBjb250YWluc1xyXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBib3VuZHMgY29udGFpbiB0aGUgcG9pbnQsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBCb3VuZHMuY29udGFpbnMgPSBmdW5jdGlvbihib3VuZHMsIHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gYm91bmRzLm1pbi54ICYmIHBvaW50LnggPD0gYm91bmRzLm1heC54IFxyXG4gICAgICAgICAgICAgICAmJiBwb2ludC55ID49IGJvdW5kcy5taW4ueSAmJiBwb2ludC55IDw9IGJvdW5kcy5tYXgueTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBib3VuZHMgaW50ZXJzZWN0LlxyXG4gICAgICogQG1ldGhvZCBvdmVybGFwc1xyXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc0FcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNCXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBib3VuZHMgb3ZlcmxhcCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIEJvdW5kcy5vdmVybGFwcyA9IGZ1bmN0aW9uKGJvdW5kc0EsIGJvdW5kc0IpIHtcclxuICAgICAgICByZXR1cm4gKGJvdW5kc0EubWluLnggPD0gYm91bmRzQi5tYXgueCAmJiBib3VuZHNBLm1heC54ID49IGJvdW5kc0IubWluLnhcclxuICAgICAgICAgICAgICAgICYmIGJvdW5kc0EubWF4LnkgPj0gYm91bmRzQi5taW4ueSAmJiBib3VuZHNBLm1pbi55IDw9IGJvdW5kc0IubWF4LnkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGJvdW5kcyBieSB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgQm91bmRzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGJvdW5kcywgdmVjdG9yKSB7XHJcbiAgICAgICAgYm91bmRzLm1pbi54ICs9IHZlY3Rvci54O1xyXG4gICAgICAgIGJvdW5kcy5tYXgueCArPSB2ZWN0b3IueDtcclxuICAgICAgICBib3VuZHMubWluLnkgKz0gdmVjdG9yLnk7XHJcbiAgICAgICAgYm91bmRzLm1heC55ICs9IHZlY3Rvci55O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoaWZ0cyB0aGUgYm91bmRzIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAqIEBtZXRob2Qgc2hpZnRcclxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBCb3VuZHMuc2hpZnQgPSBmdW5jdGlvbihib3VuZHMsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhWCA9IGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCxcclxuICAgICAgICAgICAgZGVsdGFZID0gYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBib3VuZHMubWluLnggPSBwb3NpdGlvbi54O1xyXG4gICAgICAgIGJvdW5kcy5tYXgueCA9IHBvc2l0aW9uLnggKyBkZWx0YVg7XHJcbiAgICAgICAgYm91bmRzLm1pbi55ID0gcG9zaXRpb24ueTtcclxuICAgICAgICBib3VuZHMubWF4LnkgPSBwb3NpdGlvbi55ICsgZGVsdGFZO1xyXG4gICAgfTtcclxuICAgIFxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L0JvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuVmVjdG9yYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyB2ZWN0b3JzLlxyXG4qIFZlY3RvcnMgYXJlIHRoZSBiYXNpcyBvZiBhbGwgdGhlIGdlb21ldHJ5IHJlbGF0ZWQgb3BlcmF0aW9ucyBpbiB0aGUgZW5naW5lLlxyXG4qIEEgYE1hdHRlci5WZWN0b3JgIG9iamVjdCBpcyBvZiB0aGUgZm9ybSBgeyB4OiAwLCB5OiAwIH1gLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBWZWN0b3JcclxuKi9cclxuXHJcbi8vIFRPRE86IGNvbnNpZGVyIHBhcmFtcyBmb3IgcmV1c2luZyB2ZWN0b3Igb2JqZWN0c1xyXG5cclxudmFyIFZlY3RvciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3I7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlY3Rvci5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5jcmVhdGUgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCB8fCAwLCB5OiB5IHx8IDAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIGB4YCBhbmQgYHlgIGNvcGllZCBmcm9tIHRoZSBnaXZlbiBgdmVjdG9yYC5cclxuICAgICAqIEBtZXRob2QgY2xvbmVcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgY2xvbmVkIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuY2xvbmUgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCwgeTogdmVjdG9yLnkgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgYSB2ZWN0b3IuXHJcbiAgICAgKiBAbWV0aG9kIG1hZ25pdHVkZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLm1hZ25pdHVkZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgYSB2ZWN0b3IgKHRoZXJlZm9yZSBzYXZpbmcgYSBgc3FydGAgb3BlcmF0aW9uKS5cclxuICAgICAqIEBtZXRob2QgbWFnbml0dWRlU3F1YXJlZFxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiAodmVjdG9yLnggKiB2ZWN0b3IueCkgKyAodmVjdG9yLnkgKiB2ZWN0b3IueSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGUgdmVjdG9yIGFib3V0ICgwLCAwKSBieSBzcGVjaWZpZWQgYW5nbGUuXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciByb3RhdGVkIGFib3V0ICgwLCAwKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3Iucm90YXRlID0gZnVuY3Rpb24odmVjdG9yLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxyXG4gICAgICAgICAgICB5OiB2ZWN0b3IueCAqIHNpbiArIHZlY3Rvci55ICogY29zXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgYSBzcGVjaWZpZWQgcG9pbnQgYnkgc3BlY2lmaWVkIGFuZ2xlLlxyXG4gICAgICogQG1ldGhvZCByb3RhdGVBYm91dFxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbb3V0cHV0XVxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCB0aGUgcG9pbnRcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLnJvdGF0ZUFib3V0ID0gZnVuY3Rpb24odmVjdG9yLCBhbmdsZSwgcG9pbnQsIG91dHB1dCkge1xyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XHJcbiAgICAgICAgdmFyIHggPSBwb2ludC54ICsgKCh2ZWN0b3IueCAtIHBvaW50LngpICogY29zIC0gKHZlY3Rvci55IC0gcG9pbnQueSkgKiBzaW4pO1xyXG4gICAgICAgIG91dHB1dC55ID0gcG9pbnQueSArICgodmVjdG9yLnggLSBwb2ludC54KSAqIHNpbiArICh2ZWN0b3IueSAtIHBvaW50LnkpICogY29zKTtcclxuICAgICAgICBvdXRwdXQueCA9IHg7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpc2VzIGEgdmVjdG9yIChzdWNoIHRoYXQgaXRzIG1hZ25pdHVkZSBpcyBgMWApLlxyXG4gICAgICogQG1ldGhvZCBub3JtYWxpc2VcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIG5vcm1hbGlzZWRcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLm5vcm1hbGlzZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xyXG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBWZWN0b3IubWFnbml0dWRlKHZlY3Rvcik7XHJcbiAgICAgICAgaWYgKG1hZ25pdHVkZSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gbWFnbml0dWRlLCB5OiB2ZWN0b3IueSAvIG1hZ25pdHVkZSB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRvdC1wcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQG1ldGhvZCBkb3RcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5kb3QgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XHJcbiAgICAgICAgcmV0dXJuICh2ZWN0b3JBLnggKiB2ZWN0b3JCLngpICsgKHZlY3RvckEueSAqIHZlY3RvckIueSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqIEBtZXRob2QgY3Jvc3NcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdHdvIHZlY3RvcnNcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmNyb3NzID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xyXG4gICAgICAgIHJldHVybiAodmVjdG9yQS54ICogdmVjdG9yQi55KSAtICh2ZWN0b3JBLnkgKiB2ZWN0b3JCLngpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycy5cclxuICAgICAqIEBtZXRob2QgY3Jvc3MzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JDXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0aHJlZSB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5jcm9zczMgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCB2ZWN0b3JDKSB7XHJcbiAgICAgICAgcmV0dXJuICh2ZWN0b3JCLnggLSB2ZWN0b3JBLngpICogKHZlY3RvckMueSAtIHZlY3RvckEueSkgLSAodmVjdG9yQi55IC0gdmVjdG9yQS55KSAqICh2ZWN0b3JDLnggLSB2ZWN0b3JBLngpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQG1ldGhvZCBhZGRcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBvZiB2ZWN0b3JBIGFuZCB2ZWN0b3JCIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5hZGQgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCBvdXRwdXQpIHtcclxuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XHJcbiAgICAgICAgb3V0cHV0LnggPSB2ZWN0b3JBLnggKyB2ZWN0b3JCLng7XHJcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3JBLnkgKyB2ZWN0b3JCLnk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQG1ldGhvZCBzdWJcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBvZiB2ZWN0b3JBIGFuZCB2ZWN0b3JCIHN1YnRyYWN0ZWRcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLnN1YiA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIG91dHB1dCkge1xyXG4gICAgICAgIGlmICghb3V0cHV0KSBvdXRwdXQgPSB7fTtcclxuICAgICAgICBvdXRwdXQueCA9IHZlY3RvckEueCAtIHZlY3RvckIueDtcclxuICAgICAgICBvdXRwdXQueSA9IHZlY3RvckEueSAtIHZlY3RvckIueTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLlxyXG4gICAgICogQG1ldGhvZCBtdWx0XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBtdWx0aXBsaWVkIGJ5IHNjYWxhclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IubXVsdCA9IGZ1bmN0aW9uKHZlY3Rvciwgc2NhbGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggKiBzY2FsYXIsIHk6IHZlY3Rvci55ICogc2NhbGFyIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBhbmQgYSBzY2FsYXIuXHJcbiAgICAgKiBAbWV0aG9kIGRpdlxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3IgZGl2aWRlZCBieSBzY2FsYXJcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmRpdiA9IGZ1bmN0aW9uKHZlY3Rvciwgc2NhbGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggLyBzY2FsYXIsIHk6IHZlY3Rvci55IC8gc2NhbGFyIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IuIFNldCBgbmVnYXRlYCB0byB0cnVlIGZvciB0aGUgcGVycGVuZGljdWxhciBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG4gICAgICogQG1ldGhvZCBwZXJwXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtuZWdhdGU9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IucGVycCA9IGZ1bmN0aW9uKHZlY3RvciwgbmVnYXRlKSB7XHJcbiAgICAgICAgbmVnYXRlID0gbmVnYXRlID09PSB0cnVlID8gLTEgOiAxO1xyXG4gICAgICAgIHJldHVybiB7IHg6IG5lZ2F0ZSAqIC12ZWN0b3IueSwgeTogbmVnYXRlICogdmVjdG9yLnggfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIGJvdGggY29tcG9uZW50cyBvZiBhIHZlY3RvciBzdWNoIHRoYXQgaXQgcG9pbnRzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiBAbWV0aG9kIG5lZ1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgbmVnYXRlZCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLm5lZyA9IGZ1bmN0aW9uKHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IC12ZWN0b3IueCwgeTogLXZlY3Rvci55IH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB0d28gdmVjdG9ycyByZWxhdGl2ZSB0byB0aGUgeC1heGlzLlxyXG4gICAgICogQG1ldGhvZCBhbmdsZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5hbmdsZSA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih2ZWN0b3JCLnkgLSB2ZWN0b3JBLnksIHZlY3RvckIueCAtIHZlY3RvckEueCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVtcG9yYXJ5IHZlY3RvciBwb29sIChub3QgdGhyZWFkLXNhZmUpLlxyXG4gICAgICogQHByb3BlcnR5IF90ZW1wXHJcbiAgICAgKiBAdHlwZSB7dmVjdG9yW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuX3RlbXAgPSBbXHJcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKCksIFxyXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpLCBcclxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKVxyXG4gICAgXTtcclxuXHJcbn0pKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9WZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuL0dldFZhbHVlJyk7XHJcblxyXG4vLyAgQWxsb3dlZCB0eXBlczpcclxuXHJcbi8vICBJbXBsaWNpdFxyXG4vLyAge1xyXG4vLyAgICAgIHg6IDRcclxuLy8gIH1cclxuLy9cclxuLy8gIEZyb20gZnVuY3Rpb25cclxuLy8gIHtcclxuLy8gICAgICB4OiBmdW5jdGlvbiAoKVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tbHkgcGljayBvbmUgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxyXG4vLyAge1xyXG4vLyAgICAgIHg6IFthLCBiLCBjLCBkLCBlLCBmXVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heDpcclxuLy8gIHtcclxuLy8gICAgICB4OiB7IHJhbmRJbnQ6IFttaW4sIG1heF0gfVxyXG4vLyAgfVxyXG4vL1xyXG4vLyAgUmFuZG9tIGZsb2F0IGJldHdlZW4gbWluIGFuZCBtYXg6XHJcbi8vICB7XHJcbi8vICAgICAgeDogeyByYW5kRmxvYXQ6IFttaW4sIG1heF0gfVxyXG4vLyAgfVxyXG5cclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSlcclxue1xyXG4gICAgdmFyIHZhbHVlID0gR2V0VmFsdWUoc291cmNlLCBrZXksIG51bGwpO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1BVEguUk5ELnBpY2sodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ3JhbmRJbnQnKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVRILlJORC5pbnRlZ2VySW5SYW5nZSh2YWx1ZS5yYW5kSW50WzBdLCB2YWx1ZS5yYW5kSW50WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ3JhbmRGbG9hdCcpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1BVEguUk5ELnJlYWxJblJhbmdlKHZhbHVlLnJhbmRGbG9hdFswXSwgdmFsdWUucmFuZEZsb2F0WzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBZHZhbmNlZFZhbHVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnRCaW5kaW5nID0gcmVxdWlyZSgnLi9FdmVudEJpbmRpbmcnKTtcclxuXHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XHJcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcclxuICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xyXG59O1xyXG5cclxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgZ2V0QmluZGluZzogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3MuaGFzT3duUHJvcGVydHkodHlwZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1t0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5nZXRCaW5kaW5nKHR5cGUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlXSA9IG5ldyBFdmVudEJpbmRpbmcodGhpcywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1t0eXBlXTtcclxuICAgIH0sXHJcblxyXG4gICAgb246IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHsgcHJpb3JpdHkgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5jcmVhdGVCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuYWRkKGxpc3RlbmVyLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uY2U6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHsgcHJpb3JpdHkgPSAwOyB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5jcmVhdGVCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuYWRkKGxpc3RlbmVyLCBwcmlvcml0eSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFkZCBhIGNhbGxiYWNrIHRoYXQgaXMgbm90aWZpZWQgZXZlcnkgdGltZSB0aGlzIEV2ZW50RGlzcGF0Y2hlciBkaXNwYXRjaGVzIGFuIGV2ZW50XHJcbiAgICAvLyAgbm8gbWF0dGVyIHdoYXQgdGhlIGV2ZW50IHR5cGUgaXMuIEZpbHRlcnMgYXJlIGludm9rZWQgZmlyc3QsIGJlZm9yZSBhbnkgYmluZGluZ3MsXHJcbiAgICAvLyAgYW5kIGNhbiBzdG9wIGV2ZW50cyBpZiB0aGV5IHdpc2ggKGluIHdoaWNoIGNhc2UgdGhleSdsbCBuZXZlciByZWFjaCB0aGUgYmluZGluZ3MpXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZmlsdGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKGkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFkZCB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlbW92ZSB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaGFzRmlsdGVycyA9ICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcilcclxuICAgIHtcclxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGJpbmRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy5oYXMobGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0b3RhbDogZnVuY3Rpb24gKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChiaW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcudG90YWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgLy8gIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCB0aGUgRXZlbnREaXNwYXRjaGVyLCBhIGNhbGwgdG8gdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cclxuICAgIG9mZjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcucmVtb3ZlKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZGlzcGF0Y2hIYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnQucmVzZXQodGhpcyk7XHJcblxyXG4gICAgICAgIC8vICBQYXNzIHRoZSBldmVudCB0aHJvdWdoIHRoZSBmaWx0ZXJzIGZpcnN0XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbHRlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBEaWQgdGhlIGZpbHRlciBraWxsIHRoZSBldmVudD8gSWYgc28sIHdlIGNhbiBhYm9ydCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuX3Byb3BhZ2F0ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKGV2ZW50LnR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGlzcGF0Y2goZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEhhbmRsZXIoZXZlbnRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBidXQgcmV0YWlucyB0aGUgZXZlbnQgdHlwZSBlbnRyaWVzXHJcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQWxsRmlsdGVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZpbHRlcnMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uICh0eXBlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoYmluZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbdHlwZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZXRlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGJpbmRpbmcgaW4gdGhpcy5iaW5kaW5ncylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxGaWx0ZXJzKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcclxudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcclxudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xyXG52YXIgbWF0aEFjb3MgPSBNYXRoLmFjb3M7XHJcbnZhciBtYXRoQXRhbiA9IE1hdGguYXRhbjtcclxuXHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgdHgsIHR5KSBcclxue1xyXG4gICAgYSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGEgOiAxO1xyXG4gICAgYiA9IHR5cGVvZiBiID09PSAnbnVtYmVyJyA/IGIgOiAwO1xyXG4gICAgYyA9IHR5cGVvZiBjID09PSAnbnVtYmVyJyA/IGMgOiAwO1xyXG4gICAgZCA9IHR5cGVvZiBkID09PSAnbnVtYmVyJyA/IGQgOiAxO1xyXG4gICAgdHggPSB0eXBlb2YgdHggPT09ICdudW1iZXInID8gdHggOiAwO1xyXG4gICAgdHkgPSB0eXBlb2YgdHkgPT09ICdudW1iZXInID8gdHkgOiAwO1xyXG5cclxuICAgIHRoaXMubWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShbYSwgYiwgYywgZCwgdHgsIHR5LCAwLCAwLCAxXSk7XHJcblxyXG4gICAgdGhpcy5kZWNvbXBvc2VkTWF0cml4ID0ge1xyXG4gICAgICAgIHRyYW5zbGF0ZVg6IDAsXHJcbiAgICAgICAgdHJhbnNsYXRlWTogMCxcclxuICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgIHJvdGF0aW9uOiAwXHJcbiAgICB9O1xyXG59O1xyXG5cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5sb2FkSWRlbnRpdHkgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcbiAgICBcclxuICAgIG1hdHJpeFswXSA9IDE7XHJcbiAgICBtYXRyaXhbMV0gPSAwO1xyXG4gICAgbWF0cml4WzJdID0gMDtcclxuICAgIG1hdHJpeFszXSA9IDE7XHJcbiAgICBtYXRyaXhbNF0gPSAwO1xyXG4gICAgbWF0cml4WzVdID0gMDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICBtYXRyaXhbNF0gPSBtYXRyaXhbMF0gKiB4ICsgbWF0cml4WzJdICogeSArIG1hdHJpeFs0XTtcclxuICAgIG1hdHJpeFs1XSA9IG1hdHJpeFsxXSAqIHggKyBtYXRyaXhbM10gKiB5ICsgbWF0cml4WzVdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgbWF0cml4WzBdID0gbWF0cml4WzBdICogeDtcclxuICAgIG1hdHJpeFsxXSA9IG1hdHJpeFsxXSAqIHg7XHJcbiAgICBtYXRyaXhbMl0gPSBtYXRyaXhbMl0gKiB5O1xyXG4gICAgbWF0cml4WzNdID0gbWF0cml4WzNdICogeTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKHJhZGlhbilcclxue1xyXG4gICAgdmFyIHJhZGlhblNpbiA9IG1hdGhTaW4ocmFkaWFuKTtcclxuICAgIHZhciByYWRpYW5Db3MgPSBtYXRoQ29zKHJhZGlhbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHJhZGlhbkNvcywgLXJhZGlhblNpbiwgcmFkaWFuU2luLCByYWRpYW5Db3MsIDAsIDApO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdGhlck1hdHJpeClcclxue1xyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgIHZhciBhMCA9IG1hdHJpeFswXTtcclxuICAgIHZhciBiMCA9IG1hdHJpeFsxXTtcclxuICAgIHZhciBjMCA9IG1hdHJpeFsyXTtcclxuICAgIHZhciBkMCA9IG1hdHJpeFszXTtcclxuICAgIHZhciB0eDAgPSBtYXRyaXhbNF07XHJcbiAgICB2YXIgdHkwID0gbWF0cml4WzVdO1xyXG5cclxuICAgIHZhciBhMSA9IG90aGVyTWF0cml4WzBdO1xyXG4gICAgdmFyIGIxID0gb3RoZXJNYXRyaXhbMV07XHJcbiAgICB2YXIgYzEgPSBvdGhlck1hdHJpeFsyXTtcclxuICAgIHZhciBkMSA9IG90aGVyTWF0cml4WzNdO1xyXG4gICAgdmFyIHR4MSA9IG90aGVyTWF0cml4WzRdO1xyXG4gICAgdmFyIHR5MSA9IG90aGVyTWF0cml4WzVdO1xyXG5cclxuICAgIG1hdHJpeFswXSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgbWF0cml4WzFdID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICBtYXRyaXhbMl0gPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgIG1hdHJpeFszXSA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgbWF0cml4WzRdID0gdHgxICogYTAgKyB0eTEgKiBjMCArIHR4MDtcclxuICAgIG1hdHJpeFs1XSA9IHR4MSAqIGIwICsgdHkxICogZDAgKyB0eTA7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICB2YXIgYTAgPSBtYXRyaXhbMF07XHJcbiAgICB2YXIgYjAgPSBtYXRyaXhbMV07XHJcbiAgICB2YXIgYzAgPSBtYXRyaXhbMl07XHJcbiAgICB2YXIgZDAgPSBtYXRyaXhbM107XHJcbiAgICB2YXIgdHgwID0gbWF0cml4WzRdO1xyXG4gICAgdmFyIHR5MCA9IG1hdHJpeFs1XTtcclxuXHJcbiAgICBtYXRyaXhbMF0gPSBhICogYTAgKyBiICogYzA7XHJcbiAgICBtYXRyaXhbMV0gPSBhICogYjAgKyBiICogZDA7XHJcbiAgICBtYXRyaXhbMl0gPSBjICogYTAgKyBkICogYzA7XHJcbiAgICBtYXRyaXhbM10gPSBjICogYjAgKyBkICogZDA7XHJcbiAgICBtYXRyaXhbNF0gPSB0eCAqIGEwICsgdHkgKiBjMCArIHR4MDtcclxuICAgIG1hdHJpeFs1XSA9IHR4ICogYjAgKyB0eSAqIGQwICsgdHkwO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBwb2ludClcclxue1xyXG4gICAgaWYgKHBvaW50ID09PSB1bmRlZmluZWQpIHsgcG9pbnQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICB2YXIgYSA9IG1hdHJpeFswXTtcclxuICAgIHZhciBiID0gbWF0cml4WzFdO1xyXG4gICAgdmFyIGMgPSBtYXRyaXhbMl07XHJcbiAgICB2YXIgZCA9IG1hdHJpeFszXTtcclxuICAgIHZhciB0eCA9IG1hdHJpeFs0XTtcclxuICAgIHZhciB0eSA9IG1hdHJpeFs1XTtcclxuXHJcbiAgICBwb2ludC54ID0geCAqIGEgKyB5ICogYyArIHR4O1xyXG4gICAgcG9pbnQueSA9IHggKiBiICsgeSAqIGQgKyB0eTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICB2YXIgYSA9IG1hdHJpeFswXTtcclxuICAgIHZhciBiID0gbWF0cml4WzFdO1xyXG4gICAgdmFyIGMgPSBtYXRyaXhbMl07XHJcbiAgICB2YXIgZCA9IG1hdHJpeFszXTtcclxuICAgIHZhciB0eCA9IG1hdHJpeFs0XTtcclxuICAgIHZhciB0eSA9IG1hdHJpeFs1XTtcclxuXHJcbiAgICB2YXIgbiA9IGEgKiBkIC0gYiAqIGM7XHJcblxyXG4gICAgbWF0cml4WzBdID0gZCAvIG47XHJcbiAgICBtYXRyaXhbMV0gPSAtYiAvIG47XHJcbiAgICBtYXRyaXhbMl0gPSAtYyAvIG47XHJcbiAgICBtYXRyaXhbM10gPSBhIC8gbjtcclxuICAgIG1hdHJpeFs0XSA9IChjICogdHkgLSBkICogdHgpIC8gbjtcclxuICAgIG1hdHJpeFs1XSA9IC0oYSAqIHR5IC0gYiAqIHR4KSAvIG47XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHkpXHJcbntcclxuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcbiAgICBtYXRyaXhbMF0gPSBhO1xyXG4gICAgbWF0cml4WzFdID0gYjtcclxuICAgIG1hdHJpeFsyXSA9IGM7XHJcbiAgICBtYXRyaXhbM10gPSBkO1xyXG4gICAgbWF0cml4WzRdID0gdHg7XHJcbiAgICBtYXRyaXhbNV0gPSB0eTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUuZGVjb21wb3NlTWF0cml4ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdmFyIGRlY29tcG9zZWRNYXRyaXggPSB0aGlzLmRlY29tcG9zZWRNYXRyaXg7XHJcblxyXG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuICAgIHZhciBhID0gbWF0cml4WzBdO1xyXG4gICAgdmFyIGIgPSBtYXRyaXhbMV07XHJcbiAgICB2YXIgYyA9IG1hdHJpeFsyXTtcclxuICAgIHZhciBkID0gbWF0cml4WzNdO1xyXG5cclxuICAgIHZhciBhMiA9IGEgKiBhO1xyXG4gICAgdmFyIGIyID0gYiAqIGI7XHJcbiAgICB2YXIgYzIgPSBjICogYztcclxuICAgIHZhciBkMiA9IGQgKiBkO1xyXG5cclxuICAgIHZhciBzeCA9IG1hdGhTcXJ0KGEyICsgYzIpO1xyXG4gICAgdmFyIHN5ID0gbWF0aFNxcnQoYjIgKyBkMik7XHJcblxyXG4gICAgZGVjb21wb3NlZE1hdHJpeC50cmFuc2xhdGVYID0gbWF0cml4WzRdO1xyXG4gICAgZGVjb21wb3NlZE1hdHJpeC50cmFuc2xhdGVZID0gbWF0cml4WzVdO1xyXG5cclxuICAgIGRlY29tcG9zZWRNYXRyaXguc2NhbGVYID0gc3g7XHJcbiAgICBkZWNvbXBvc2VkTWF0cml4LnNjYWxlWSA9IHN5O1xyXG5cclxuICAgIGRlY29tcG9zZWRNYXRyaXgucm90YXRpb24gPSBtYXRoQWNvcyhhIC8gc3gpICogKG1hdGhBdGFuKC1jIC8gYSkgPCAwID8gLTEgOiAxKTtcclxuXHJcbiAgICByZXR1cm4gZGVjb21wb3NlZE1hdHJpeDtcclxufTtcclxuXHJcbi8qIGlkZW50aXR5ICsgdHJhbnNsYXRlICsgcm90YXRlICsgc2NhbGUgKi9cclxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5hcHBseUlUUlMgPSBmdW5jdGlvbiAoeCwgeSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKVxyXG57XHJcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcblxyXG4gICAgdmFyIGEgPSAxO1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIGMgPSAwO1xyXG4gICAgdmFyIGQgPSAxO1xyXG4gICAgdmFyIHR4ID0gMDtcclxuICAgIHZhciB0eSA9IDA7XHJcblxyXG4gICAgdmFyIHNyID0gbWF0aFNpbihyb3RhdGlvbik7XHJcbiAgICB2YXIgY3IgPSBtYXRoQ29zKHJvdGF0aW9uKTtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGVcclxuICAgIG1hdHJpeFs0XSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcclxuICAgIG1hdHJpeFs1XSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcclxuXHJcbiAgICAvLyBSb3RhdGVcclxuICAgIG1hdHJpeFswXSA9IGNyICogYSArIC1zciAqIGM7XHJcbiAgICBtYXRyaXhbMV0gPSBjciAqIGIgKyAtc3IgKiBkO1xyXG4gICAgbWF0cml4WzJdID0gc3IgKiBhICsgY3IgKiBjO1xyXG4gICAgbWF0cml4WzNdID0gc3IgKiBiICsgY3IgKiBkO1xyXG5cclxuICAgIC8vIFNjYWxlXHJcbiAgICBtYXRyaXhbMF0gPSBtYXRyaXhbMF0gKiBzY2FsZVg7XHJcbiAgICBtYXRyaXhbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVg7XHJcbiAgICBtYXRyaXhbMl0gPSBtYXRyaXhbMl0gKiBzY2FsZVk7XHJcbiAgICBtYXRyaXhbM10gPSBtYXRyaXhbM10gKiBzY2FsZVk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybU1hdHJpeDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0ge1xyXG5cclxuICAgIC8vICBUd2VlbkRhdGE6XHJcblxyXG4gICAgQ1JFQVRFRDogMCxcclxuICAgIElOSVQ6IDEsXHJcbiAgICBERUxBWTogMixcclxuICAgIFBFTkRJTkdfUkVOREVSOiAzLFxyXG4gICAgUExBWUlOR19GT1JXQVJEOiA0LFxyXG4gICAgUExBWUlOR19CQUNLV0FSRDogNSxcclxuICAgIEhPTERfREVMQVk6IDYsXHJcbiAgICBSRVBFQVRfREVMQVk6IDcsXHJcbiAgICBDT01QTEVURTogOCxcclxuXHJcbiAgICAvLyAgVHdlZW4gc3BlY2lmaWMgKHN0YXJ0cyBmcm9tIDIwIHRvIGNsZWFubHkgYWxsb3cgZXh0cmEgVHdlZW5EYXRhIGNvbnN0cyBpbiB0aGUgZnV0dXJlKVxyXG5cclxuICAgIFBFTkRJTkdfQUREOiAyMCxcclxuICAgIFBBVVNFRDogMjEsXHJcbiAgICBMT09QX0RFTEFZOiAyMixcclxuICAgIEFDVElWRTogMjMsXHJcbiAgICBDT01QTEVURV9ERUxBWTogMjQsXHJcbiAgICBQRU5ESU5HX1JFTU9WRTogMjUsXHJcbiAgICBSRU1PVkVEOiAyNlxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVFdFRU5fQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiAoZ2FtZU9iamVjdC55ICsgZ2FtZU9iamVjdC5oZWlnaHQpIC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRCb3R0b20uanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgR2V0TGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC54IC0gKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRMZWZ0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4qL1xyXG5cclxudmFyIEdldFJpZ2h0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiAoZ2FtZU9iamVjdC54ICsgZ2FtZU9iamVjdC53aWR0aCkgLSAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxyXG4qL1xyXG5cclxudmFyIEdldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC55IC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9HZXRUb3AuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XHJcbiovXHJcblxyXG52YXIgU2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxyXG57XHJcbiAgICBnYW1lT2JqZWN0LnkgPSAodmFsdWUgLSBnYW1lT2JqZWN0LmhlaWdodCkgKyAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRCb3R0b207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeCAtIG9mZnNldFhgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcclxuKi9cclxuXHJcbnZhciBTZXRMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxyXG57XHJcbiAgICBnYW1lT2JqZWN0LnggPSB2YWx1ZSArIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0TGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvU2V0TGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeCAtIG9mZnNldFhgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcclxuKi9cclxuXHJcbnZhciBTZXRSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC54ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC53aWR0aCkgKyAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2JvdW5kcy9TZXRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxyXG4qL1xyXG5cclxudmFyIFNldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB2YWx1ZSlcclxue1xyXG4gICAgZ2FtZU9iamVjdC55ID0gdmFsdWUgKyAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRUb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldFRvcC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRlc2t0b3AgLSBJcyBydW5uaW5nIG9uIGEgZGVza3RvcD9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBkZXNrdG9wOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJBcHAgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGFzIGEgV2ViQXBwLCBpLmUuIHdpdGhpbiBhIFdlYlZpZXdcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJBcHA6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlPUyAtIElzIHJ1bm5pbmcgb24gaU9TP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlPUzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpT1NWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBpT1MgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlPU1ZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaVBob25lIC0gSXMgcnVubmluZyBvbiBpUGhvbmU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgaVBob25lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpUGFkIC0gSXMgcnVubmluZyBvbiBpUGFkP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGlQYWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvY29vbkpTIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBDb2Nvb25KUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjb2Nvb25KUzogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvY29vbkpTQXBwIC0gSXMgdGhpcyBnYW1lIHJ1bm5pbmcgd2l0aCBDb2Nvb25KUy5BcHA/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY29jb29uSlNBcHA6IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb3Jkb3ZhIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBBcGFjaGUgQ29yZG92YT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjb3Jkb3ZhOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9kZSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgTm9kZS5qcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBub2RlOiBmYWxzZSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9kZVdlYmtpdCAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgTm9kZS1XZWJraXQ/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbm9kZVdlYmtpdDogZmFsc2UsXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVsZWN0cm9uIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBHaXRIdWIgRWxlY3Ryb24/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWxlY3Ryb246IGZhbHNlLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlamVjdGEgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEVqZWN0YT9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBlamVjdGE6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNyb3Nzd2FsayAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgdGhlIEludGVsIENyb3Nzd2FsayBYREs/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY3Jvc3N3YWxrOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbmRyb2lkIC0gSXMgcnVubmluZyBvbiBhbmRyb2lkP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGFuZHJvaWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZU9TIC0gSXMgcnVubmluZyBvbiBjaHJvbWVPUz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBjaHJvbWVPUzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGludXggLSBJcyBydW5uaW5nIG9uIGxpbnV4P1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGxpbnV4OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtYWNPUyAtIElzIHJ1bm5pbmcgb24gbWFjT1M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbWFjT1M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdpbmRvd3MgLSBJcyBydW5uaW5nIG9uIHdpbmRvd3M/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2luZG93czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2luZG93c1Bob25lIC0gSXMgcnVubmluZyBvbiBhIFdpbmRvd3MgUGhvbmU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2luZG93c1Bob25lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB2aXRhIC0gSXMgcnVubmluZyBvbiBhIFBsYXlTdGF0aW9uIFZpdGE/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdml0YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ga2luZGxlIC0gSXMgcnVubmluZyBvbiBhbiBBbWF6b24gS2luZGxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGtpbmRsZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIC0gUGl4ZWxSYXRpbyBvZiB0aGUgaG9zdCBkZXZpY2U/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgcGl4ZWxSYXRpbzogMVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoL1dpbmRvd3MvLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLndpbmRvd3MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL01hYyBPUy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MubWFjT1MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5saW51eCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuYW5kcm9pZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvaVBbYW9dZHxpUGhvbmUvaS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5pT1MgPSB0cnVlO1xyXG4gICAgICAgIChuYXZpZ2F0b3IuYXBwVmVyc2lvbikubWF0Y2goL09TIChcXGQrKS8pO1xyXG4gICAgICAgIE9TLmlPU1ZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKC9LaW5kbGUvLnRlc3QodWEpIHx8ICgvXFxiS0ZbQS1aXVtBLVpdKy8pLnRlc3QodWEpIHx8ICgvU2lsay4qTW9iaWxlIFNhZmFyaS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmtpbmRsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBOT1QgZGV0ZWN0IGVhcmx5IGdlbmVyYXRpb25zIG9mIEtpbmRsZSBGaXJlLCBJIHRoaW5rIHRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheS4uLlxyXG4gICAgICAgIC8vIEUuZy4gXCJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBVOyBJbnRlbCBNYWMgT1MgWCAxMF82XzM7IGVuLXVzOyBTaWxrLzEuMS4wLTgwKSBBcHBsZVdlYktpdC81MzMuMTYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzUuMCBTYWZhcmkvNTMzLjE2IFNpbGstQWNjZWxlcmF0ZWQ9dHJ1ZVwiXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvQ3JPUy8udGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY2hyb21lT1MgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9QbGF5c3RhdGlvbiBWaXRhLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mudml0YSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1YSkgfHwgKC9JRU1vYmlsZS9pKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBPUy5hbmRyb2lkID0gZmFsc2U7XHJcbiAgICAgICAgT1MuaU9TID0gZmFsc2U7XHJcbiAgICAgICAgT1MubWFjT1MgPSBmYWxzZTtcclxuICAgICAgICBPUy53aW5kb3dzID0gdHJ1ZTtcclxuICAgICAgICBPUy53aW5kb3dzUGhvbmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaWxrID0gKC9TaWxrLykudGVzdCh1YSk7XHJcblxyXG4gICAgaWYgKE9TLndpbmRvd3MgfHwgT1MubWFjT1MgfHwgKE9TLmxpbnV4ICYmICFzaWxrKSB8fCBPUy5jaHJvbWVPUylcclxuICAgIHtcclxuICAgICAgICBPUy5kZXNrdG9wID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgV2luZG93cyBQaG9uZSAvIFRhYmxlIHJlc2V0XHJcbiAgICBpZiAoT1Mud2luZG93c1Bob25lIHx8ICgoL1dpbmRvd3MgTlQvaS50ZXN0KHVhKSkgJiYgKC9Ub3VjaC9pLnRlc3QodWEpKSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuZGVza3RvcCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBXZWJBcHAgbW9kZSBpbiBpT1NcclxuICAgIGlmIChuYXZpZ2F0b3Iuc3RhbmRhbG9uZSlcclxuICAgIHtcclxuICAgICAgICBPUy53ZWJBcHAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBPUy5jb3Jkb3ZhID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJykpXHJcbiAgICB7XHJcbiAgICAgICAgT1Mubm9kZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChPUy5ub2RlICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09PSAnb2JqZWN0JylcclxuICAgIHtcclxuICAgICAgICBPUy5ub2RlV2Via2l0ID0gISFwcm9jZXNzLnZlcnNpb25zWydub2RlLXdlYmtpdCddO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE9TLmVsZWN0cm9uID0gISFwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY29jb29uSlMgPSB0cnVlO1xyXG5cclxuICAgICAgICB0cnlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE9TLmNvY29vbkpTQXBwID0gKHR5cGVvZiBDb2Nvb25KUyAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBPUy5jb2Nvb25KU0FwcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAod2luZG93LmVqZWN0YSAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIE9TLmVqZWN0YSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCgvQ3Jvc3N3YWxrLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgT1MuY3Jvc3N3YWxrID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBPUy5pUGhvbmUgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwaG9uZScpICE9PSAtMTtcclxuICAgIE9TLmlQYWQgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwYWQnKSAhPT0gLTE7XHJcblxyXG4gICAgT1MucGl4ZWxSYXRpbyA9IHdpbmRvd1snZGV2aWNlUGl4ZWxSYXRpbyddIHx8IDE7XHJcblxyXG4gICAgcmV0dXJuIE9TO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZXZpY2UvT1MuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vLyAgRW5jYXBzdWxhdGVzIGEgMkQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvcm5lciBwb2ludCBpbiB0aGUgdG9wLWxlZnRcclxuLy8gIGFuZCBpdHMgZXh0ZW5kcyBpbiB4ICh3aWR0aCkgYW5kIHkgKGhlaWdodClcclxuXHJcbnZhciBSZWN0YW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHsgd2lkdGggPSAwOyB9XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbn07XHJcblxyXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xyXG5cclxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRPUFxyXG4gICAgZ2V0TGluZUE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueCwgeTE6IHRoaXMueSwgeDI6IHRoaXMucmlnaHQsIHkyOiB0aGlzLnkgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJJR0hUXHJcbiAgICBnZXRMaW5lQjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy5yaWdodCwgeTE6IHRoaXMueSwgeDI6IHRoaXMucmlnaHQsIHkyOiB0aGlzLmJvdHRvbSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQk9UVE9NXHJcbiAgICBnZXRMaW5lQzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy5yaWdodCwgeTE6IHRoaXMuYm90dG9tLCB4MjogdGhpcy54LCB5MjogdGhpcy5ib3R0b20gfTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIExFRlRcclxuICAgIGdldExpbmVEOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLngsIHkxOiB0aGlzLmJvdHRvbSwgeDI6IHRoaXMueCwgeTI6IHRoaXMueSB9O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlY3RhbmdsZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5yaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5ib3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5ib3R0b20gLSB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNlbnRlclg6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArICh0aGlzLndpZHRoIC8gMik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSAtICh0aGlzLndpZHRoIC8gMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VudGVyWToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgKHRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZSAtICh0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFVSTCA9IHJlcXVpcmUoJy4vR2V0VVJMJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFhIUkxvYWRlciA9IHJlcXVpcmUoJy4vWEhSTG9hZGVyJyk7XHJcbnZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL01lcmdlWEhSU2V0dGluZ3MnKTtcclxuXHJcbnZhciBGaWxlID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgdXJsLCByZXNwb25zZVR5cGUsIHhoclNldHRpbmdzLCBjb25maWcpXHJcbntcclxuICAgIC8vICBmaWxlIHR5cGUgKGltYWdlLCBqc29uLCBldGMpIGZvciBzb3J0aW5nIHdpdGhpbiB0aGUgTG9hZGVyXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgIC8vICB1bmlxdWUgY2FjaGUga2V5ICh1bmlxdWUgd2l0aGluIGl0cyBmaWxlIHR5cGUpXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAvLyAgVGhlIFVSTCBvZiB0aGUgZmlsZSwgbm90IGluY2x1ZGluZyBiYXNlVVJMXHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuXHJcbiAgICAvLyAgU2V0IHdoZW4gdGhlIExvYWRlciBjYWxscyAnbG9hZCcgb24gdGhpcyBmaWxlXHJcbiAgICB0aGlzLnNyYyA9ICcnO1xyXG5cclxuICAgIHRoaXMueGhyU2V0dGluZ3MgPSBYSFJTZXR0aW5ncyhyZXNwb25zZVR5cGUpO1xyXG5cclxuICAgIGlmICh4aHJTZXR0aW5ncylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnhoclNldHRpbmdzID0gTWVyZ2VYSFJTZXR0aW5ncyh0aGlzLnhoclNldHRpbmdzLCB4aHJTZXR0aW5ncyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy54aHJMb2FkZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BFTkRJTkc7XHJcblxyXG4gICAgLy8gIFNldCBieSBvblByb2dyZXNzIChvbmx5IGlmIGxvYWRpbmcgdmlhIFhIUilcclxuICAgIHRoaXMuYnl0ZXNUb3RhbCA9IDA7XHJcbiAgICB0aGlzLmJ5dGVzTG9hZGVkID0gLTE7XHJcbiAgICB0aGlzLnBlcmNlbnRDb21wbGV0ZSA9IC0xO1xyXG5cclxuICAgIC8vICBGb3IgQ09ScyBiYXNlZCBsb2FkaW5nLlxyXG4gICAgLy8gIElmIHRoaXMgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIEZpbGUgd2lsbCBjaGVjayBCYXNlTG9hZGVyLmNyb3NzT3JpZ2luIGFuZCB1c2UgdGhhdCAoaWYgc2V0KVxyXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyAgVGhlIGFjdHVhbCBwcm9jZXNzZWQgZmlsZSBkYXRhXHJcbiAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gIEEgY29uZmlnIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGZpbGUgdHlwZXMgdG8gc3RvcmUgdHJhbnNpdGlvbmFsIGRhdGFcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgIC8vICBNdWx0aXBhcnQgZmlsZT8gKGkuZS4gYW4gYXRsYXMgYW5kIGl0cyBqc29uIHRvZ2V0aGVyKVxyXG4gICAgdGhpcy5saW5rRmlsZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGlua1R5cGUgPSAnJztcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcclxufTtcclxuXHJcbkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsZTtcclxuXHJcbkZpbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHJlc2V0WEhSOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ubG9hZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhockxvYWRlci5vbmVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ucHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgd2hlbiB0aGUgSW1hZ2UgbG9hZHNcclxuICAgIC8vICBQcm9ncmVzc0V2ZW50XHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzTG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzVG90YWwgPSBldmVudC50b3RhbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGVyY2VudENvbXBsZXRlID0gTWF0aC5taW4oKHRoaXMuYnl0ZXNMb2FkZWQgLyB0aGlzLmJ5dGVzVG90YWwpLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGVyY2VudENvbXBsZXRlICsgJyUgKCcgKyB0aGlzLmJ5dGVzTG9hZGVkICsgJyBieXRlcyknKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Qcm9jZXNzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmtGaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfV0FJVElOR19MSU5LRklMRSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZywgYW5kIGlzIHdhaXRpbmcgZm9yIHRoaXMgZmlsZSwgc28gbGV0J3MgZG8gdGhlbSBib3RoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlua0ZpbGUuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFRoZSBsaW5rZmlsZSBzdGlsbCBoYXNuJ3QgZmluaXNoZWQgbG9hZGluZyBhbmQvb3IgcHJvY2Vzc2luZyB5ZXRcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfQ09NUExFVEU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBMb2FkZXIsIHN0YXJ0cyB0aGUgYWN0dWFsIGZpbGUgZG93bmxvYWRpbmdcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzZVVSTCwgZ2xvYmFsWEhSKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChiYXNlVVJMID09PSB1bmRlZmluZWQpIHsgYmFzZVVSTCA9ICcnOyB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5zcmMgPSBHZXRVUkwodGhpcywgYmFzZVVSTCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNyYy5pbmRleE9mKCdkYXRhOicpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvY2FsIGRhdGEgVVJJJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueGhyTG9hZGVyID0gWEhSTG9hZGVyKHRoaXMsIGdsb2JhbFhIUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9GaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5Db21wb3NpdGVgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbXBvc2l0ZSBib2RpZXMuXHJcbiogQSBjb21wb3NpdGUgYm9keSBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLCB0aGVyZWZvcmUgY29tcG9zaXRlcyBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUuXHJcbiogSXQgaXMgaW1wb3J0YW50IHRvIHVzZSB0aGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHRvIG1vZGlmeSBjb21wb3NpdGVzLCByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgdGhlaXIgcHJvcGVydGllcy5cclxuKiBOb3RlIHRoYXQgdGhlIGBNYXR0ZXIuV29ybGRgIG9iamVjdCBpcyBhbHNvIGEgdHlwZSBvZiBgTWF0dGVyLkNvbXBvc2l0ZWAgYW5kIGFzIHN1Y2ggYWxsIGNvbXBvc2l0ZSBtZXRob2RzIGhlcmUgY2FuIGFsc28gb3BlcmF0ZSBvbiBhIGBNYXR0ZXIuV29ybGRgLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBDb21wb3NpdGVcclxuKi9cclxuXHJcbnZhciBDb21wb3NpdGUgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRlO1xyXG5cclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4uL2NvcmUvRXZlbnRzJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQm9keSA9IHJlcXVpcmUoJy4vQm9keScpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb21wb3NpdGUuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJpdGVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge30gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXHJcbiAgICAgICAgICAgIGlkOiBDb21tb24ubmV4dElkKCksXHJcbiAgICAgICAgICAgIHR5cGU6ICdjb21wb3NpdGUnLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGlzTW9kaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBib2RpZXM6IFtdLCBcclxuICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLCBcclxuICAgICAgICAgICAgY29tcG9zaXRlczogW10sXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQ29tcG9zaXRlJyxcclxuICAgICAgICAgICAgcGx1Z2luOiB7fVxyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbXBvc2l0ZSdzIGBpc01vZGlmaWVkYCBmbGFnLiBcclxuICAgICAqIElmIGB1cGRhdGVQYXJlbnRzYCBpcyB0cnVlLCBhbGwgcGFyZW50cyB3aWxsIGJlIHNldCAoZGVmYXVsdDogZmFsc2UpLlxyXG4gICAgICogSWYgYHVwZGF0ZUNoaWxkcmVuYCBpcyB0cnVlLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBzZXQgKGRlZmF1bHQ6IGZhbHNlKS5cclxuICAgICAqIEBtZXRob2Qgc2V0TW9kaWZpZWRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNb2RpZmllZFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlUGFyZW50cz1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZUNoaWxkcmVuPWZhbHNlXVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGlzTW9kaWZpZWQsIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgY29tcG9zaXRlLmlzTW9kaWZpZWQgPSBpc01vZGlmaWVkO1xyXG5cclxuICAgICAgICBpZiAodXBkYXRlUGFyZW50cyAmJiBjb21wb3NpdGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUucGFyZW50LCBpc01vZGlmaWVkLCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXBkYXRlQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb21wb3NpdGUgPSBjb21wb3NpdGUuY29tcG9zaXRlc1tpXTtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjaGlsZENvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyaWMgYWRkIGZ1bmN0aW9uLiBBZGRzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVBZGRgIGFuZCBgYWZ0ZXJBZGRgIGV2ZW50cyBvbiB0aGUgYGNvbXBvc2l0ZWAuXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIG9iamVjdHMgYWRkZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFkZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBbXS5jb25jYXQob2JqZWN0KTtcclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlQWRkJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFkZGluZyBjb21wb3VuZCBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iai5wYXJlbnQgIT09IG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdDb21wb3NpdGUuYWRkOiBza2lwcGVkIGFkZGluZyBhIGNvbXBvdW5kIGJvZHkgcGFydCAoeW91IG11c3QgYWRkIGl0cyBwYXJlbnQgaW5zdGVhZCknKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjb21wb3NpdGUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY29tcG9zaXRlJzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUoY29tcG9zaXRlLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlQ29uc3RyYWludCc6XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iai5jb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYWZ0ZXJBZGQnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyaWMgcmVtb3ZlIGZ1bmN0aW9uLiBSZW1vdmVzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIE9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cclxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVSZW1vdmVgIGFuZCBgYWZ0ZXJSZW1vdmVgIGV2ZW50cyBvbiB0aGUgYGNvbXBvc2l0ZWAuXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBvYmplY3RzIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJlbW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0LCBkZWVwKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBbXS5jb25jYXQob2JqZWN0KTtcclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlUmVtb3ZlJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQm9keShjb21wb3NpdGUsIG9iaiwgZGVlcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludChjb21wb3NpdGUsIG9iaiwgZGVlcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY29tcG9zaXRlJzpcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUoY29tcG9zaXRlLCBvYmosIGRlZXApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlQ29uc3RyYWludCc6XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludChjb21wb3NpdGUsIG9iai5jb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYWZ0ZXJSZW1vdmUnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjb21wb3NpdGUgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGFkZENvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUFcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGVBIHdpdGggdGhlIG9iamVjdHMgZnJvbSBjb21wb3NpdGVCIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCKSB7XHJcbiAgICAgICAgY29tcG9zaXRlQS5jb21wb3NpdGVzLnB1c2goY29tcG9zaXRlQik7XHJcbiAgICAgICAgY29tcG9zaXRlQi5wYXJlbnQgPSBjb21wb3NpdGVBO1xyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGVBLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNvbXBvc2l0ZSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVBXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZUEgd2l0aCB0aGUgY29tcG9zaXRlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIGNvbXBvc2l0ZUIsIGRlZXApIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBDb21tb24uaW5kZXhPZihjb21wb3NpdGVBLmNvbXBvc2l0ZXMsIGNvbXBvc2l0ZUIpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZUF0KGNvbXBvc2l0ZUEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZUEsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWVwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlQS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUoY29tcG9zaXRlQS5jb21wb3NpdGVzW2ldLCBjb21wb3NpdGVCLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNvbXBvc2l0ZSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb21wb3NpdGVBdFxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29tcG9zaXRlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZUF0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbXBvc2l0ZS5jb21wb3NpdGVzLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGJvZHkgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGFkZEJvZHlcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgYWRkZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFkZEJvZHkgPSBmdW5jdGlvbihjb21wb3NpdGUsIGJvZHkpIHtcclxuICAgICAgICBjb21wb3NpdGUuYm9kaWVzLnB1c2goYm9keSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBhbmQgb3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQm9keVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgYm9keSwgZGVlcCkge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZS5ib2RpZXMsIGJvZHkpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQm9keShjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwgYm9keSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQm9keUF0XHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBib2R5IHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICBjb21wb3NpdGUuYm9kaWVzLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNvbnN0cmFpbnQgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQpIHtcclxuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29uc3RyYWludCBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBjb25zdHJhaW50LCBkZWVwKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50KTtcclxuICAgICAgICBpZiAocG9zaXRpb24gIT09IC0xKSB7XHJcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50QXQoY29tcG9zaXRlLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVlcCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBjb25zdHJhaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50QXRcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludEF0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbXBvc2l0ZS5jb25zdHJhaW50cy5zcGxpY2UocG9zaXRpb24sIDEpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIGNvbXBvc2l0ZXMgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxyXG4gICAgICogT3B0aW9uYWxseSBjbGVhcmluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5jbGVhciA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwga2VlcFN0YXRpYywgZGVlcCkge1xyXG4gICAgICAgIGlmIChkZWVwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmNsZWFyKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBrZWVwU3RhdGljLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoa2VlcFN0YXRpYykge1xyXG4gICAgICAgICAgICBjb21wb3NpdGUuYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcy5maWx0ZXIoZnVuY3Rpb24oYm9keSkgeyByZXR1cm4gYm9keS5pc1N0YXRpYzsgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29tcG9zaXRlLmJvZGllcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUsIGluY2x1ZGluZyBhbGwgYm9kaWVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAbWV0aG9kIGFsbEJvZGllc1xyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBBbGwgdGhlIGJvZGllc1xyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuYWxsQm9kaWVzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuYm9kaWVzKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYm9kaWVzID0gYm9kaWVzLmNvbmNhdChDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBib2RpZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgY29uc3RyYWludHMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb25zdHJhaW50cyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICogQG1ldGhvZCBhbGxDb25zdHJhaW50c1xyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHJldHVybiB7Y29uc3RyYWludFtdfSBBbGwgdGhlIGNvbnN0cmFpbnRzXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29uc3RyYWludHMpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGNvbXBvc2l0ZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb21wb3NpdGVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAbWV0aG9kIGFsbENvbXBvc2l0ZXNcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZVtdfSBBbGwgdGhlIGNvbXBvc2l0ZXNcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcclxuICAgICAgICB2YXIgY29tcG9zaXRlcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29tcG9zaXRlcyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGNvbXBvc2l0ZXMgPSBjb21wb3NpdGVzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyB0aGUgY29tcG9zaXRlIHJlY3Vyc2l2ZWx5IGZvciBhbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHR5cGUgYW5kIGlkIHN1cHBsaWVkLCBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAgICAqIEBtZXRob2QgZ2V0XHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSByZXF1ZXN0ZWQgb2JqZWN0LCBpZiBmb3VuZFxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuZ2V0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBpZCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBvYmplY3RzLFxyXG4gICAgICAgICAgICBvYmplY3Q7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2JvZHknOlxyXG4gICAgICAgICAgICBvYmplY3RzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcclxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyhjb21wb3NpdGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxyXG4gICAgICAgICAgICBvYmplY3RzID0gQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXMoY29tcG9zaXRlKS5jb25jYXQoY29tcG9zaXRlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9iamVjdHMpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBvYmplY3QgPSBvYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHsgXHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuaWQudG9TdHJpbmcoKSA9PT0gaWQudG9TdHJpbmcoKTsgXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmplY3QubGVuZ3RoID09PSAwID8gbnVsbCA6IG9iamVjdFswXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgZ2l2ZW4gb2JqZWN0KHMpIGZyb20gY29tcG9zaXRlQSB0byBjb21wb3NpdGVCIChlcXVhbCB0byBhIHJlbW92ZSBmb2xsb3dlZCBieSBhbiBhZGQpLlxyXG4gICAgICogQG1ldGhvZCBtb3ZlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZUF9IGNvbXBvc2l0ZUFcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IG9iamVjdHNcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlQn0gY29tcG9zaXRlQlxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZUFcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLm1vdmUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBvYmplY3RzLCBjb21wb3NpdGVCKSB7XHJcbiAgICAgICAgQ29tcG9zaXRlLnJlbW92ZShjb21wb3NpdGVBLCBvYmplY3RzKTtcclxuICAgICAgICBDb21wb3NpdGUuYWRkKGNvbXBvc2l0ZUIsIG9iamVjdHMpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbnMgbmV3IGlkcyBmb3IgYWxsIG9iamVjdHMgaW4gdGhlIGNvbXBvc2l0ZSwgcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAbWV0aG9kIHJlYmFzZVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUucmViYXNlID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUpKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHNbaV0uaWQgPSBDb21tb24ubmV4dElkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbXBvc2l0ZSBieSBhIGdpdmVuIHZlY3RvciByZWxhdGl2ZSB0byB0aGVpciBjdXJyZW50IHBvc2l0aW9ucywgXHJcbiAgICAgKiB3aXRob3V0IGltcGFydGluZyBhbnkgdmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtyZWN1cnNpdmU9dHJ1ZV1cclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgdHJhbnNsYXRpb24sIHJlY3Vyc2l2ZSkge1xyXG4gICAgICAgIHZhciBib2RpZXMgPSByZWN1cnNpdmUgPyBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSkgOiBjb21wb3NpdGUuYm9kaWVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShib2RpZXNbaV0sIHRyYW5zbGF0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIGdpdmVuIHBvaW50LCB3aXRob3V0IGltcGFydGluZyBhbnkgYW5ndWxhciB2ZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2Qgcm90YXRlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb25cclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxyXG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZS5yb3RhdGUgPSBmdW5jdGlvbihjb21wb3NpdGUsIHJvdGF0aW9uLCBwb2ludCwgcmVjdXJzaXZlKSB7XHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKSxcclxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocm90YXRpb24pLFxyXG4gICAgICAgICAgICBib2RpZXMgPSByZWN1cnNpdmUgPyBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSkgOiBjb21wb3NpdGUuYm9kaWVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcclxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcclxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcclxuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyAoZHggKiBjb3MgLSBkeSAqIHNpbiksXHJcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgKGR4ICogc2luICsgZHkgKiBjb3MpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgQm9keS5yb3RhdGUoYm9keSwgcm90YXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIHVwZGF0aW5nIHBoeXNpY2FsIHByb3BlcnRpZXMgKG1hc3MsIGFyZWEsIGF4ZXMsIGluZXJ0aWEpLCBmcm9tIGEgd29ybGQtc3BhY2UgcG9pbnQuXHJcbiAgICAgKiBAbWV0aG9kIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW3JlY3Vyc2l2ZT10cnVlXVxyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGUuc2NhbGUgPSBmdW5jdGlvbihjb21wb3NpdGUsIHNjYWxlWCwgc2NhbGVZLCBwb2ludCwgcmVjdXJzaXZlKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgZHkgPSBib2R5LnBvc2l0aW9uLnkgLSBwb2ludC55O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xyXG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCArIGR4ICogc2NhbGVYLFxyXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIGR5ICogc2NhbGVZXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgQm9keS5zY2FsZShib2R5LCBzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICAqXHJcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5hZGRgIGlzIG1hZGUsIGJlZm9yZSBvYmplY3RzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGJlZm9yZUFkZFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0byBiZSBhZGRlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUuYWRkYCBpcyBtYWRlLCBhZnRlciBvYmplY3RzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyQWRkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5yZW1vdmVgIGlzIG1hZGUsIGJlZm9yZSBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVtb3ZlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRvIGJlIHJlbW92ZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLnJlbW92ZWAgaXMgbWFkZSwgYWZ0ZXIgb2JqZWN0cyBoYXZlIGJlZW4gcmVtb3ZlZC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyUmVtb3ZlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qXHJcbiAgICAqXHJcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYENvbXBvc2l0ZS5jcmVhdGVgIGJ5IGBDb21tb24ubmV4dElkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBcImNvbXBvc2l0ZVwiXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJiaXRyYXJ5IGBTdHJpbmdgIG5hbWUgdG8gaGVscCB0aGUgdXNlciBpZGVudGlmeSBhbmQgbWFuYWdlIGNvbXBvc2l0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGxhYmVsXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEBkZWZhdWx0IFwiQ29tcG9zaXRlXCJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbXBvc2l0ZSBoYXMgYmVlbiBtb2RpZmllZCBkdXJpbmcgdGhlIGN1cnJlbnQgc3RlcC5cclxuICAgICAqIE1vc3QgYE1hdHRlci5Db21wb3NpdGVgIG1ldGhvZHMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGlzIGZsYWcgdG8gYHRydWVgIHRvIGluZm9ybSB0aGUgZW5naW5lIG9mIGNoYW5nZXMgdG8gYmUgaGFuZGxlZC5cclxuICAgICAqIElmIHlvdSBuZWVkIHRvIGNoYW5nZSBpdCBtYW51YWxseSwgeW91IHNob3VsZCB1c2UgdGhlIGBDb21wb3NpdGUuc2V0TW9kaWZpZWRgIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaXNNb2RpZmllZFxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBDb21wb3NpdGVgIHRoYXQgaXMgdGhlIHBhcmVudCBvZiB0aGlzIGNvbXBvc2l0ZS4gSXQgaXMgYXV0b21hdGljYWxseSBtYW5hZ2VkIGJ5IHRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XHJcbiAgICAgKiBAdHlwZSBjb21wb3NpdGVcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgYEJvZHlgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxyXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBib2RpZXMgeW91IHNob3VsZCB1c2UgYENvbXBvc2l0ZS5hZGRgIGFuZCBgQ29tcG9zaXRlLnJlbW92ZWAgbWV0aG9kcyByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxCb2RpZXNgIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXHJcbiAgICAgKiBAdHlwZSBib2R5W11cclxuICAgICAqIEBkZWZhdWx0IFtdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGBDb25zdHJhaW50YCB0aGF0IGFyZSBfZGlyZWN0XyBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvc2l0ZS5cclxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgY29uc3RyYWludHMgeW91IHNob3VsZCB1c2UgYENvbXBvc2l0ZS5hZGRgIGFuZCBgQ29tcG9zaXRlLnJlbW92ZWAgbWV0aG9kcyByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxDb25zdHJhaW50c2AgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50c1xyXG4gICAgICogQHR5cGUgY29uc3RyYWludFtdXHJcbiAgICAgKiBAZGVmYXVsdCBbXVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBgQ29tcG9zaXRlYCB0aGF0IGFyZSBfZGlyZWN0XyBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvc2l0ZS5cclxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgY29tcG9zaXRlcyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXNgIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29tcG9zaXRlc1xyXG4gICAgICogQHR5cGUgY29tcG9zaXRlW11cclxuICAgICAqIEBkZWZhdWx0IFtdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXHJcbiAgICAgKiBAdHlwZSB7fVxyXG4gICAgICovXHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5FdmVudHNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIHRvIGZpcmUgYW5kIGxpc3RlbiB0byBldmVudHMgb24gb3RoZXIgb2JqZWN0cy5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgRXZlbnRzXHJcbiovXHJcblxyXG52YXIgRXZlbnRzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcclxuXHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuL0NvbW1vbicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYC5cclxuICAgICAqIEBtZXRob2Qgb25cclxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBFdmVudHMub24gPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIG5hbWVzID0gZXZlbnROYW1lcy5zcGxpdCgnICcpLFxyXG4gICAgICAgICAgICBuYW1lO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgb2JqZWN0LmV2ZW50cyA9IG9iamVjdC5ldmVudHMgfHwge307XHJcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZV0gPSBvYmplY3QuZXZlbnRzW25hbWVdIHx8IFtdO1xyXG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVdLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGV2ZW50IGNhbGxiYWNrLiBJZiBubyBjYWxsYmFjaywgY2xlYXJzIGFsbCBjYWxsYmFja3MgaW4gYGV2ZW50TmFtZXNgLiBJZiBubyBgZXZlbnROYW1lc2AsIGNsZWFycyBhbGwgZXZlbnRzLlxyXG4gICAgICogQG1ldGhvZCBvZmZcclxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBFdmVudHMub2ZmID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghZXZlbnROYW1lcykge1xyXG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzID0ge307XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhhbmRsZSBFdmVudHMub2ZmKG9iamVjdCwgY2FsbGJhY2spXHJcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXZlbnROYW1lcztcclxuICAgICAgICAgICAgZXZlbnROYW1lcyA9IENvbW1vbi5rZXlzKG9iamVjdC5ldmVudHMpLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gb2JqZWN0LmV2ZW50c1tuYW1lc1tpXV0sXHJcbiAgICAgICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tqXSAhPT0gY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrc1tqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZXNbaV1dID0gbmV3Q2FsbGJhY2tzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyBhbGwgdGhlIGNhbGxiYWNrcyBzdWJzY3JpYmVkIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYCwgaW4gdGhlIG9yZGVyIHRoZXkgc3Vic2NyaWJlZCwgaWYgYW55LlxyXG4gICAgICogQG1ldGhvZCB0cmlnZ2VyXHJcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lc1xyXG4gICAgICogQHBhcmFtIHt9IGV2ZW50XHJcbiAgICAgKi9cclxuICAgIEV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBldmVudCkge1xyXG4gICAgICAgIHZhciBuYW1lcyxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgY2FsbGJhY2tzLFxyXG4gICAgICAgICAgICBldmVudENsb25lO1xyXG5cclxuICAgICAgICBpZiAob2JqZWN0LmV2ZW50cykge1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgZXZlbnQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIG5hbWVzID0gZXZlbnROYW1lcy5zcGxpdCgnICcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gb2JqZWN0LmV2ZW50c1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbG9uZSA9IENvbW1vbi5jbG9uZShldmVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbG9uZS5zb3VyY2UgPSBvYmplY3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tqXS5hcHBseShvYmplY3QsIFtldmVudENsb25lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FdmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlZlcnRpY2VzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBzZXRzIG9mIHZlcnRpY2VzLlxyXG4qIEEgc2V0IG9mIHZlcnRpY2VzIGlzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCB3aXRoIGFkZGl0aW9uYWwgaW5kZXhpbmcgcHJvcGVydGllcyBpbnNlcnRlZCBieSBgVmVydGljZXMuY3JlYXRlYC5cclxuKiBBIGBNYXR0ZXIuQm9keWAgbWFpbnRhaW5zIGEgc2V0IG9mIHZlcnRpY2VzIHRvIHJlcHJlc2VudCB0aGUgc2hhcGUgb2YgdGhlIG9iamVjdCAoaXRzIGNvbnZleCBodWxsKS5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgVmVydGljZXNcclxuKi9cclxuXHJcbnZhciBWZXJ0aWNlcyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0aWNlcztcclxuXHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNldCBvZiBgTWF0dGVyLkJvZHlgIGNvbXBhdGlibGUgdmVydGljZXMuXHJcbiAgICAgKiBUaGUgYHBvaW50c2AgYXJndW1lbnQgYWNjZXB0cyBhbiBhcnJheSBvZiBgTWF0dGVyLlZlY3RvcmAgcG9pbnRzIG9yaWVudGF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4gYCgwLCAwKWAsIGZvciBleGFtcGxlOlxyXG4gICAgICpcclxuICAgICAqICAgICBbeyB4OiAwLCB5OiAwIH0sIHsgeDogMjUsIHk6IDUwIH0sIHsgeDogNTAsIHk6IDAgfV1cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYFZlcnRpY2VzLmNyZWF0ZWAgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkgb2YgdmVydGljZXMsIHdoaWNoIGFyZSBzaW1pbGFyIHRvIE1hdHRlci5WZWN0b3Igb2JqZWN0cyxcclxuICAgICAqIGJ1dCB3aXRoIHNvbWUgYWRkaXRpb25hbCByZWZlcmVuY2VzIHJlcXVpcmVkIGZvciBlZmZpY2llbnQgY29sbGlzaW9uIGRldGVjdGlvbiByb3V0aW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBWZXJ0aWNlcyBtdXN0IGJlIHNwZWNpZmllZCBpbiBjbG9ja3dpc2Ugb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBgYm9keWAgYXJndW1lbnQgaXMgbm90IG9wdGlvbmFsLCBhIGBNYXR0ZXIuQm9keWAgcmVmZXJlbmNlIG11c3QgYmUgcHJvdmlkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yW119IHBvaW50c1xyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBvaW50cywgYm9keSkge1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV0sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNJbnRlcm5hbDogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3JkZXJlZCB4IHkgcGFpcnMgc2VwYXJhdGVkIGJ5IHNwYWNlcyAoYW5kIG9wdGlvbmFsbHkgY29tbWFzKSwgXHJcbiAgICAgKiBpbnRvIGEgYE1hdHRlci5WZXJ0aWNlc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gYE1hdHRlci5Cb2R5YC5cclxuICAgICAqIEZvciBwYXJzaW5nIFNWRyBwYXRocywgc2VlIGBTdmcucGF0aFRvVmVydGljZXNgLlxyXG4gICAgICogQG1ldGhvZCBmcm9tUGF0aFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHJldHVybiB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmZyb21QYXRoID0gZnVuY3Rpb24ocGF0aCwgYm9keSkge1xyXG4gICAgICAgIHZhciBwYXRoUGF0dGVybiA9IC9MP1xccyooW1xcLVxcZFxcLmVdKylbXFxzLF0qKFtcXC1cXGRcXC5lXSspKi9pZyxcclxuICAgICAgICAgICAgcG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIHBhdGgucmVwbGFjZShwYXRoUGF0dGVybiwgZnVuY3Rpb24obWF0Y2gsIHgsIHkpIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiBwYXJzZUZsb2F0KHgpLCB5OiBwYXJzZUZsb2F0KHkpIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gVmVydGljZXMuY3JlYXRlKHBvaW50cywgYm9keSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2VudHJlIChjZW50cm9pZCkgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcy5cclxuICAgICAqIEBtZXRob2QgY2VudHJlXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgY2VudHJlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmNlbnRyZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdmFyIGFyZWEgPSBWZXJ0aWNlcy5hcmVhKHZlcnRpY2VzLCB0cnVlKSxcclxuICAgICAgICAgICAgY2VudHJlID0geyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgICAgIGNyb3NzLFxyXG4gICAgICAgICAgICB0ZW1wLFxyXG4gICAgICAgICAgICBqO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGogPSAoaSArIDEpICUgdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjcm9zcyA9IFZlY3Rvci5jcm9zcyh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbal0pO1xyXG4gICAgICAgICAgICB0ZW1wID0gVmVjdG9yLm11bHQoVmVjdG9yLmFkZCh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbal0pLCBjcm9zcyk7XHJcbiAgICAgICAgICAgIGNlbnRyZSA9IFZlY3Rvci5hZGQoY2VudHJlLCB0ZW1wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBWZWN0b3IuZGl2KGNlbnRyZSwgNiAqIGFyZWEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgKG1lYW4pIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXHJcbiAgICAgKiBAbWV0aG9kIG1lYW5cclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBhdmVyYWdlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLm1lYW4gPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgIHZhciBhdmVyYWdlID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXZlcmFnZS54ICs9IHZlcnRpY2VzW2ldLng7XHJcbiAgICAgICAgICAgIGF2ZXJhZ2UueSArPSB2ZXJ0aWNlc1tpXS55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5kaXYoYXZlcmFnZSwgdmVydGljZXMubGVuZ3RoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXHJcbiAgICAgKiBAbWV0aG9kIGFyZWFcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHNpZ25lZFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXJlYVxyXG4gICAgICovXHJcbiAgICBWZXJ0aWNlcy5hcmVhID0gZnVuY3Rpb24odmVydGljZXMsIHNpZ25lZCkge1xyXG4gICAgICAgIHZhciBhcmVhID0gMCxcclxuICAgICAgICAgICAgaiA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJlYSArPSAodmVydGljZXNbal0ueCAtIHZlcnRpY2VzW2ldLngpICogKHZlcnRpY2VzW2pdLnkgKyB2ZXJ0aWNlc1tpXS55KTtcclxuICAgICAgICAgICAgaiA9IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gYXJlYSAvIDI7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKHNlY29uZCBtb21lbnQgb2YgYXJlYSkgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcyBnaXZlbiB0aGUgdG90YWwgbWFzcy5cclxuICAgICAqIEBtZXRob2QgaW5lcnRpYVxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb2x5Z29uJ3MgbW9tZW50IG9mIGluZXJ0aWFcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuaW5lcnRpYSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXNzKSB7XHJcbiAgICAgICAgdmFyIG51bWVyYXRvciA9IDAsXHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gMCxcclxuICAgICAgICAgICAgdiA9IHZlcnRpY2VzLFxyXG4gICAgICAgICAgICBjcm9zcyxcclxuICAgICAgICAgICAgajtcclxuXHJcbiAgICAgICAgLy8gZmluZCB0aGUgcG9seWdvbidzIG1vbWVudCBvZiBpbmVydGlhLCB1c2luZyBzZWNvbmQgbW9tZW50IG9mIGFyZWFcclxuICAgICAgICAvLyBodHRwOi8vd3d3LnBoeXNpY3Nmb3J1bXMuY29tL3Nob3d0aHJlYWQucGhwP3Q9MjUyOTNcclxuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHYubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgaiA9IChuICsgMSkgJSB2Lmxlbmd0aDtcclxuICAgICAgICAgICAgY3Jvc3MgPSBNYXRoLmFicyhWZWN0b3IuY3Jvc3ModltqXSwgdltuXSkpO1xyXG4gICAgICAgICAgICBudW1lcmF0b3IgKz0gY3Jvc3MgKiAoVmVjdG9yLmRvdCh2W2pdLCB2W2pdKSArIFZlY3Rvci5kb3QodltqXSwgdltuXSkgKyBWZWN0b3IuZG90KHZbbl0sIHZbbl0pKTtcclxuICAgICAgICAgICAgZGVub21pbmF0b3IgKz0gY3Jvc3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKG1hc3MgLyA2KSAqIChudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyB0aGUgc2V0IG9mIHZlcnRpY2VzIGluLXBsYWNlLlxyXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyXHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCB2ZWN0b3IsIHNjYWxhcikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzY2FsYXIpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ICs9IHZlY3Rvci54ICogc2NhbGFyO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV0ueSArPSB2ZWN0b3IueSAqIHNjYWxhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV0ueCArPSB2ZWN0b3IueDtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgKz0gdmVjdG9yLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIHRoZSBzZXQgb2YgdmVydGljZXMgaW4tcGxhY2UuXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLnJvdGF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBhbmdsZSwgcG9pbnQpIHtcclxuICAgICAgICBpZiAoYW5nbGUgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlID0gdmVydGljZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBkeCA9IHZlcnRpY2UueCAtIHBvaW50LngsXHJcbiAgICAgICAgICAgICAgICBkeSA9IHZlcnRpY2UueSAtIHBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmVydGljZS54ID0gcG9pbnQueCArIChkeCAqIGNvcyAtIGR5ICogc2luKTtcclxuICAgICAgICAgICAgdmVydGljZS55ID0gcG9pbnQueSArIChkeCAqIHNpbiArIGR5ICogY29zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHBvaW50YCBpcyBpbnNpZGUgdGhlIHNldCBvZiBgdmVydGljZXNgLlxyXG4gICAgICogQG1ldGhvZCBjb250YWluc1xyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVydGljZXMgY29udGFpbnMgcG9pbnQsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBWZXJ0aWNlcy5jb250YWlucyA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBwb2ludCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2UgPSB2ZXJ0aWNlc1tpXSxcclxuICAgICAgICAgICAgICAgIG5leHRWZXJ0aWNlID0gdmVydGljZXNbKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aF07XHJcbiAgICAgICAgICAgIGlmICgocG9pbnQueCAtIHZlcnRpY2UueCkgKiAobmV4dFZlcnRpY2UueSAtIHZlcnRpY2UueSkgKyAocG9pbnQueSAtIHZlcnRpY2UueSkgKiAodmVydGljZS54IC0gbmV4dFZlcnRpY2UueCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGUgdmVydGljZXMgZnJvbSBhIHBvaW50IChkZWZhdWx0IGlzIGNlbnRyZSkgaW4tcGxhY2UuXHJcbiAgICAgKiBAbWV0aG9kIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLnNjYWxlID0gZnVuY3Rpb24odmVydGljZXMsIHNjYWxlWCwgc2NhbGVZLCBwb2ludCkge1xyXG4gICAgICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgIHBvaW50ID0gcG9pbnQgfHwgVmVydGljZXMuY2VudHJlKHZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCxcclxuICAgICAgICAgICAgZGVsdGE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIGRlbHRhID0gVmVjdG9yLnN1Yih2ZXJ0ZXgsIHBvaW50KTtcclxuICAgICAgICAgICAgdmVydGljZXNbaV0ueCA9IHBvaW50LnggKyBkZWx0YS54ICogc2NhbGVYO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ID0gcG9pbnQueSArIGRlbHRhLnkgKiBzY2FsZVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbWZlcnMgYSBzZXQgb2YgdmVydGljZXMgYnkgZ2l2aW5nIHRoZW0gcm91bmRlZCBjb3JuZXJzLCByZXR1cm5zIGEgbmV3IHNldCBvZiB2ZXJ0aWNlcy5cclxuICAgICAqIFRoZSByYWRpdXMgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIG51bWJlciBvciBhbiBhcnJheSB0byBzcGVjaWZ5IHRoZSByYWRpdXMgZm9yIGVhY2ggdmVydGV4LlxyXG4gICAgICogQG1ldGhvZCBjaGFtZmVyXHJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlNaW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5TWF4XHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmNoYW1mZXIgPSBmdW5jdGlvbih2ZXJ0aWNlcywgcmFkaXVzLCBxdWFsaXR5LCBxdWFsaXR5TWluLCBxdWFsaXR5TWF4KSB7XHJcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IFs4XTtcclxuXHJcbiAgICAgICAgaWYgKCFyYWRpdXMubGVuZ3RoKVxyXG4gICAgICAgICAgICByYWRpdXMgPSBbcmFkaXVzXTtcclxuXHJcbiAgICAgICAgLy8gcXVhbGl0eSBkZWZhdWx0cyB0byAtMSwgd2hpY2ggaXMgYXV0b1xyXG4gICAgICAgIHF1YWxpdHkgPSAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSA/IHF1YWxpdHkgOiAtMTtcclxuICAgICAgICBxdWFsaXR5TWluID0gcXVhbGl0eU1pbiB8fCAyO1xyXG4gICAgICAgIHF1YWxpdHlNYXggPSBxdWFsaXR5TWF4IHx8IDE0O1xyXG5cclxuICAgICAgICB2YXIgbmV3VmVydGljZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcHJldlZlcnRleCA9IHZlcnRpY2VzW2kgLSAxID49IDAgPyBpIC0gMSA6IHZlcnRpY2VzLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4ID0gdmVydGljZXNbKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aF0sXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFkaXVzID0gcmFkaXVzW2kgPCByYWRpdXMubGVuZ3RoID8gaSA6IHJhZGl1cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmFkaXVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByZXZOb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXHJcbiAgICAgICAgICAgICAgICB4OiB2ZXJ0ZXgueSAtIHByZXZWZXJ0ZXgueSwgXHJcbiAgICAgICAgICAgICAgICB5OiBwcmV2VmVydGV4LnggLSB2ZXJ0ZXgueFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXh0Tm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxyXG4gICAgICAgICAgICAgICAgeDogbmV4dFZlcnRleC55IC0gdmVydGV4LnksIFxyXG4gICAgICAgICAgICAgICAgeTogdmVydGV4LnggLSBuZXh0VmVydGV4LnhcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSYWRpdXMgPSBNYXRoLnNxcnQoMiAqIE1hdGgucG93KGN1cnJlbnRSYWRpdXMsIDIpKSxcclxuICAgICAgICAgICAgICAgIHJhZGl1c1ZlY3RvciA9IFZlY3Rvci5tdWx0KENvbW1vbi5jbG9uZShwcmV2Tm9ybWFsKSwgY3VycmVudFJhZGl1cyksXHJcbiAgICAgICAgICAgICAgICBtaWROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKFZlY3Rvci5tdWx0KFZlY3Rvci5hZGQocHJldk5vcm1hbCwgbmV4dE5vcm1hbCksIDAuNSkpLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVkVmVydGV4ID0gVmVjdG9yLnN1Yih2ZXJ0ZXgsIFZlY3Rvci5tdWx0KG1pZE5vcm1hbCwgZGlhZ29uYWxSYWRpdXMpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBxdWFsaXR5O1xyXG5cclxuICAgICAgICAgICAgaWYgKHF1YWxpdHkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlY2lkZSBwcmVjaXNpb25cclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgucG93KGN1cnJlbnRSYWRpdXMsIDAuMzIpICogMS43NTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJlY2lzaW9uID0gQ29tbW9uLmNsYW1wKHByZWNpc2lvbiwgcXVhbGl0eU1pbiwgcXVhbGl0eU1heCk7XHJcblxyXG4gICAgICAgICAgICAvLyB1c2UgYW4gZXZlbiB2YWx1ZSBmb3IgcHJlY2lzaW9uLCBtb3JlIGxpa2VseSB0byByZWR1Y2UgYXhlcyBieSB1c2luZyBzeW1tZXRyeVxyXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICUgMiA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiArPSAxO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFscGhhID0gTWF0aC5hY29zKFZlY3Rvci5kb3QocHJldk5vcm1hbCwgbmV4dE5vcm1hbCkpLFxyXG4gICAgICAgICAgICAgICAgdGhldGEgPSBhbHBoYSAvIHByZWNpc2lvbjtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJlY2lzaW9uOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZlcnRpY2VzLnB1c2goVmVjdG9yLmFkZChWZWN0b3Iucm90YXRlKHJhZGl1c1ZlY3RvciwgdGhldGEgKiBqKSwgc2NhbGVkVmVydGV4KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdWZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0cyB0aGUgaW5wdXQgdmVydGljZXMgaW50byBjbG9ja3dpc2Ugb3JkZXIgaW4gcGxhY2UuXHJcbiAgICAgKiBAbWV0aG9kIGNsb2Nrd2lzZVNvcnRcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcmV0dXJuIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuY2xvY2t3aXNlU29ydCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdmFyIGNlbnRyZSA9IFZlcnRpY2VzLm1lYW4odmVydGljZXMpO1xyXG5cclxuICAgICAgICB2ZXJ0aWNlcy5zb3J0KGZ1bmN0aW9uKHZlcnRleEEsIHZlcnRleEIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci5hbmdsZShjZW50cmUsIHZlcnRleEEpIC0gVmVjdG9yLmFuZ2xlKGNlbnRyZSwgdmVydGV4Qik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZlcnRpY2VzIGZvcm0gYSBjb252ZXggc2hhcGUgKHZlcnRpY2VzIG11c3QgYmUgaW4gY2xvY2t3aXNlIG9yZGVyKS5cclxuICAgICAqIEBtZXRob2QgaXNDb252ZXhcclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXHJcbiAgICAgKiBAcmV0dXJuIHtib29sfSBgdHJ1ZWAgaWYgdGhlIGB2ZXJ0aWNlc2AgYXJlIGNvbnZleCwgYGZhbHNlYCBpZiBub3QgKG9yIGBudWxsYCBpZiBub3QgY29tcHV0YWJsZSkuXHJcbiAgICAgKi9cclxuICAgIFZlcnRpY2VzLmlzQ29udmV4ID0gZnVuY3Rpb24odmVydGljZXMpIHtcclxuICAgICAgICAvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9seWdvbm1lc2gvXHJcblxyXG4gICAgICAgIHZhciBmbGFnID0gMCxcclxuICAgICAgICAgICAgbiA9IHZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgayxcclxuICAgICAgICAgICAgejtcclxuXHJcbiAgICAgICAgaWYgKG4gPCAzKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBqID0gKGkgKyAxKSAlIG47XHJcbiAgICAgICAgICAgIGsgPSAoaSArIDIpICUgbjtcclxuICAgICAgICAgICAgeiA9ICh2ZXJ0aWNlc1tqXS54IC0gdmVydGljZXNbaV0ueCkgKiAodmVydGljZXNba10ueSAtIHZlcnRpY2VzW2pdLnkpO1xyXG4gICAgICAgICAgICB6IC09ICh2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSkgKiAodmVydGljZXNba10ueCAtIHZlcnRpY2VzW2pdLngpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmbGFnIHw9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeiA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZsYWcgfD0gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZsYWcgIT09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29udmV4IGh1bGwgb2YgdGhlIGlucHV0IHZlcnRpY2VzIGFzIGEgbmV3IGFycmF5IG9mIHBvaW50cy5cclxuICAgICAqIEBtZXRob2QgaHVsbFxyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4gW3ZlcnRleF0gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgVmVydGljZXMuaHVsbCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vR2VvbWV0cnkvQ29udmV4X2h1bGwvTW9ub3RvbmVfY2hhaW5cclxuXHJcbiAgICAgICAgdmFyIHVwcGVyID0gW10sXHJcbiAgICAgICAgICAgIGxvd2VyID0gW10sIFxyXG4gICAgICAgICAgICB2ZXJ0ZXgsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIC8vIHNvcnQgdmVydGljZXMgb24geC1heGlzICh5LWF4aXMgZm9yIHRpZXMpXHJcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZSgwKTtcclxuICAgICAgICB2ZXJ0aWNlcy5zb3J0KGZ1bmN0aW9uKHZlcnRleEEsIHZlcnRleEIpIHtcclxuICAgICAgICAgICAgdmFyIGR4ID0gdmVydGV4QS54IC0gdmVydGV4Qi54O1xyXG4gICAgICAgICAgICByZXR1cm4gZHggIT09IDAgPyBkeCA6IHZlcnRleEEueSAtIHZlcnRleEIueTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gYnVpbGQgbG93ZXIgaHVsbFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChsb3dlci5sZW5ndGggPj0gMiBcclxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczMobG93ZXJbbG93ZXIubGVuZ3RoIC0gMl0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGxvd2VyLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsb3dlci5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBidWlsZCB1cHBlciBodWxsXHJcbiAgICAgICAgZm9yIChpID0gdmVydGljZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAodXBwZXIubGVuZ3RoID49IDIgXHJcbiAgICAgICAgICAgICAgICAgICAmJiBWZWN0b3IuY3Jvc3MzKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDJdLCB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgdmVydGV4KSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB1cHBlci5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXBwZXIucHVzaCh2ZXJ0ZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uY2F0ZW5hdGlvbiBvZiB0aGUgbG93ZXIgYW5kIHVwcGVyIGh1bGxzIGdpdmVzIHRoZSBjb252ZXggaHVsbFxyXG4gICAgICAgIC8vIG9taXQgbGFzdCBwb2ludHMgYmVjYXVzZSB0aGV5IGFyZSByZXBlYXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBvdGhlciBsaXN0XHJcbiAgICAgICAgdXBwZXIucG9wKCk7XHJcbiAgICAgICAgbG93ZXIucG9wKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB1cHBlci5jb25jYXQobG93ZXIpO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvVmVydGljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvQmxlbmRNb2RlcycpO1xyXG5cclxudmFyIEJ1aWxkR2FtZU9iamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgZ2FtZU9iamVjdCwgY29uZmlnKVxyXG57XHJcbiAgICAvLyAgUG9zaXRpb25cclxuXHJcbiAgICBnYW1lT2JqZWN0LnggPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3gnLCAwKTtcclxuICAgIGdhbWVPYmplY3QueSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneScsIDApO1xyXG4gICAgZ2FtZU9iamVjdC56ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd6JywgMCk7XHJcblxyXG4gICAgLy8gIEZsaXBcclxuXHJcbiAgICBnYW1lT2JqZWN0LmZsaXBYID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmbGlwWCcsIGZhbHNlKTtcclxuICAgIGdhbWVPYmplY3QuZmxpcFkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZsaXBZJywgZmFsc2UpO1xyXG5cclxuICAgIC8vICBTY2FsZVxyXG4gICAgLy8gIEVpdGhlcjogeyBzY2FsZTogMiB9IG9yIHsgc2NhbGU6IHsgeDogMiwgeTogMiB9fVxyXG5cclxuICAgIHZhciBzY2FsZSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnc2NhbGUnLCBudWxsKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHNjYWxlID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0LnNldFNjYWxlKHNjYWxlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjYWxlICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3Quc2NhbGVYID0gR2V0QWR2YW5jZWRWYWx1ZShzY2FsZSwgJ3gnLCAxKTtcclxuICAgICAgICBnYW1lT2JqZWN0LnNjYWxlWSA9IEdldEFkdmFuY2VkVmFsdWUoc2NhbGUsICd5JywgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNjcm9sbEZhY3RvclxyXG4gICAgLy8gIEVpdGhlcjogeyBzY3JvbGxGYWN0b3I6IDIgfSBvciB7IHNjcm9sbEZhY3RvcjogeyB4OiAyLCB5OiAyIH19XHJcblxyXG4gICAgdmFyIHNjcm9sbEZhY3RvciA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnc2Nyb2xsRmFjdG9yJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzY3JvbGxGYWN0b3IgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3Quc2V0U2Nyb2xsRmFjdG9yKHNjcm9sbEZhY3Rvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY3JvbGxGYWN0b3IgIT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYID0gR2V0QWR2YW5jZWRWYWx1ZShzY3JvbGxGYWN0b3IsICd4JywgMSk7XHJcbiAgICAgICAgZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZID0gR2V0QWR2YW5jZWRWYWx1ZShzY3JvbGxGYWN0b3IsICd5JywgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJvdGF0aW9uXHJcblxyXG4gICAgZ2FtZU9iamVjdC5yb3RhdGlvbiA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAncm90YXRpb24nLCAwKTtcclxuXHJcbiAgICB2YXIgYW5nbGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2FuZ2xlJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGFuZ2xlICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWVPYmplY3QuYW5nbGUgPSBhbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWxwaGFcclxuXHJcbiAgICBnYW1lT2JqZWN0LmFscGhhID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdhbHBoYScsIDEpO1xyXG5cclxuICAgIC8vICBPcmlnaW5cclxuICAgIC8vICBFaXRoZXI6IHsgb3JpZ2luOiAwLjUgfSBvciB7IG9yaWdpbjogeyB4OiAwLjUsIHk6IDAuNSB9fVxyXG5cclxuICAgIHZhciBvcmlnaW4gPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ29yaWdpbicsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICBnYW1lT2JqZWN0LnNldE9yaWdpbihvcmlnaW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3JpZ2luICE9PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBveCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDAuNSk7XHJcbiAgICAgICAgdmFyIG95ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd5JywgMC41KTtcclxuXHJcbiAgICAgICAgZ2FtZU9iamVjdC5zZXRPcmlnaW4ob3gsIG95KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgU2NhbGVNb2RlXHJcblxyXG4gICAgZ2FtZU9iamVjdC5zY2FsZU1vZGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3NjYWxlTW9kZScsIFNjYWxlTW9kZXMuREVGQVVMVCk7XHJcblxyXG4gICAgLy8gIEJsZW5kTW9kZVxyXG5cclxuICAgIGdhbWVPYmplY3QuYmxlbmRNb2RlID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdibGVuZE1vZGUnLCBCbGVuZE1vZGVzLk5PUk1BTCk7XHJcblxyXG4gICAgLy8gIFZpc2libGVcclxuXHJcbiAgICBnYW1lT2JqZWN0LnZpc2libGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3Zpc2libGUnLCB0cnVlKTtcclxuXHJcbiAgICAvLyAgQWRkIHRvIFN0YXRlXHJcblxyXG4gICAgdmFyIGFkZCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnYWRkJywgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKGFkZClcclxuICAgIHtcclxuICAgICAgICBzdGF0ZS5jaGlsZHJlbi5hZGQoZ2FtZU9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9CdWlsZEdhbWVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRhQnVmZmVyMzIgPSBmdW5jdGlvbiAoYnl0ZVNpemUpXHJcbntcclxuICAgIHRoaXMuZHdvcmRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5kd29yZENhcGFjaXR5ID0gYnl0ZVNpemUgLyA0O1xyXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xyXG4gICAgdGhpcy5mbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYnVmZmVyKTtcclxuICAgIHRoaXMuaW50VmlldyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcclxuICAgIHRoaXMudWludFZpZXcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5idWZmZXIpO1xyXG59O1xyXG5cclxuRGF0YUJ1ZmZlcjMyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuZHdvcmRMZW5ndGggPSAwO1xyXG59O1xyXG5cclxuRGF0YUJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZHdvcmRMZW5ndGggKiA0O1xyXG59O1xyXG5cclxuRGF0YUJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbn07XHJcblxyXG5EYXRhQnVmZmVyMzIucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gKGR3b3JkU2l6ZSlcclxue1xyXG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLmR3b3JkTGVuZ3RoO1xyXG4gICAgdGhpcy5kd29yZExlbmd0aCArPSBkd29yZFNpemU7XHJcbiAgICByZXR1cm4gY3VycmVudExlbmd0aDtcclxufTtcclxuXHJcbkRhdGFCdWZmZXIzMi5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5mbG9hdFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5EYXRhQnVmZmVyMzIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc0ludCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5EYXRhQnVmZmVyMzIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc1VpbnQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy51aW50Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YUJ1ZmZlcjMyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0RhdGFCdWZmZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBRERfQU5JTUFUSU9OX0VWRU5UOiByZXF1aXJlKCcuL0FkZEFuaW1hdGlvbkV2ZW50JyksXHJcbiAgICBQQVVTRV9BTExfQU5JTUFUSU9OX0VWRU5UOiByZXF1aXJlKCcuL1BhdXNlQWxsQW5pbWF0aW9uRXZlbnQnKSxcclxuICAgIFJFTU9WRV9BTklNQVRJT05fRVZFTlQ6IHJlcXVpcmUoJy4vUmVtb3ZlQW5pbWF0aW9uRXZlbnQnKSxcclxuICAgIFJFU1VNRV9BTExfQU5JTUFUSU9OX0VWRU5UOiByZXF1aXJlKCcuL1Jlc3VtZUFsbEFuaW1hdGlvbkV2ZW50JylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxuXHJcbnZhciBCcm93c2VyID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFyb3JhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBBcm9yYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBhcm9yYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2hyb21lIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBDaHJvbWUuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNocm9tZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIENocm9tZSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2hyb21lVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlcGlwaGFueSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gRXBpcGhhbnkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZXBpcGhhbnk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpcmVmb3ggLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEZpcmVmb3guXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJlZm94VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gRmlyZWZveCB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlyZWZveFZlcnNpb246IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW9iaWxlU2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNb2JpbGUgU2FmYXJpLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1vYmlsZVNhZmFyaTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWUgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGllVmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBCZXlvbmQgSUUxMCB5b3Ugc2hvdWxkIHVzZSBEZXZpY2UudHJpZGVudCBhbmQgRGV2aWNlLnRyaWRlbnRWZXJzaW9uLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGllVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtaWRvcmkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pZG9yaS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtaWRvcmk6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wZXJhIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBPcGVyYS5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBvcGVyYTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2FmYXJpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBTYWZhcmkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNhZmFyaVZlcnNpb24gLSBJZiBydW5uaW5nIGluIFNhZmFyaSB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgc2FmYXJpVmVyc2lvbjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB0cmlkZW50IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBhIFRyaWRlbnQgdmVyc2lvbiBvZiBJbnRlcm5ldCBFeHBsb3JlciAoSUUxMSspXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdHJpZGVudDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmlkZW50VmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLiBTZWUge0BsaW5rIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNzUwMyh2PXZzLjg1KS5hc3B4fVxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRyaWRlbnRWZXJzaW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVkZ2UgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZWRnZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2lsayAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gdGhlIFNpbGsgYnJvd3NlciAoYXMgdXNlZCBvbiB0aGUgQW1hem9uIEtpbmRsZSlcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBzaWxrOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXQgKClcclxue1xyXG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoKC9Bcm9yYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuYXJvcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoL0VkZ2VcXC9cXGQrLy50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVkZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9DaHJvbWVcXC8oXFxkKykvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuY2hyb21lID0gdHJ1ZTtcclxuICAgICAgICBCcm93c2VyLmNocm9tZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRXBpcGhhbnkvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmVwaXBoYW55ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvRmlyZWZveFxcRCsoXFxkKykvKS50ZXN0KHVhKSlcclxuICAgIHtcclxuICAgICAgICBCcm93c2VyLmZpcmVmb3ggPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvQXBwbGVXZWJLaXQvKS50ZXN0KHVhKSAmJiBPUy5pT1MpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5tb2JpbGVTYWZhcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9NU0lFIChcXGQrXFwuXFxkKyk7LykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5pZSA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci5pZVZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvTWlkb3JpLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5taWRvcmkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9PcGVyYS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIub3BlcmEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKC9TYWZhcmkvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgvVHJpZGVudFxcLyhcXGQrXFwuXFxkKykoLiopcnY6KFxcZCtcXC5cXGQrKS8pLnRlc3QodWEpKVxyXG4gICAge1xyXG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xyXG4gICAgICAgIEJyb3dzZXIudHJpZGVudCA9IHRydWU7XHJcbiAgICAgICAgQnJvd3Nlci50cmlkZW50VmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xyXG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQzLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNpbGsgZ2V0cyBpdHMgb3duIGlmIGNsYXVzZSBiZWNhdXNlIGl0cyB1YSBhbHNvIGNvbnRhaW5zICdTYWZhcmknXHJcbiAgICBpZiAoKC9TaWxrLykudGVzdCh1YSkpXHJcbiAgICB7XHJcbiAgICAgICAgQnJvd3Nlci5zaWxrID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQnJvd3NlcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL0Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihsaW5lLnkyIC0gbGluZS55MSwgbGluZS54MiAtIGxpbmUueDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDb2xvciA9IHJlcXVpcmUoJy4vR2V0Q29sb3InKTtcclxudmFyIEdldENvbG9yMzIgPSByZXF1aXJlKCcuL0dldENvbG9yMzInKTtcclxuXHJcbnZhciBDb2xvciA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxue1xyXG4gICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7IHJlZCA9IDA7IH1cclxuICAgIGlmIChncmVlbiA9PT0gdW5kZWZpbmVkKSB7IGdyZWVuID0gMDsgfVxyXG4gICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMDsgfVxyXG4gICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAyNTU7IH1cclxuXHJcbiAgICAvLyAgQWxsIHByaXZhdGVcclxuICAgIHRoaXMuciA9IDA7XHJcbiAgICB0aGlzLmcgPSAwO1xyXG4gICAgdGhpcy5iID0gMDtcclxuICAgIHRoaXMuYSA9IDI1NTtcclxuXHJcbiAgICB0aGlzLmdsID0gWyAwLjAsIDAuMCwgMC4wLCAxLjAgXTtcclxuXHJcbiAgICB0aGlzLl9jb2xvciA9IDA7XHJcbiAgICB0aGlzLl9jb2xvcjMyID0gMDtcclxuICAgIHRoaXMuX3JnYmEgPSAnJztcclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNldFRvKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcclxufTtcclxuXHJcbkNvbG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yO1xyXG5cclxuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHRyYW5zcGFyZW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVkID0gMDtcclxuICAgICAgICB0aGlzLmdyZWVuID0gMDtcclxuICAgICAgICB0aGlzLmJsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBWYWx1ZXMgYXJlIGluIHRoZSByYW5nZSAwIHRvIDI1NVxyXG4gICAgc2V0VG86IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgeyBhbHBoYSA9IDI1NTsgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZCA9IHJlZDtcclxuICAgICAgICB0aGlzLmdyZWVuID0gZ3JlZW47XHJcbiAgICAgICAgdGhpcy5ibHVlID0gYmx1ZTtcclxuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIDAgdG8gMVxyXG4gICAgc2V0R0xUbzogZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZEdMID0gcmVkO1xyXG4gICAgICAgIHRoaXMuZ3JlZW5HTCA9IGdyZWVuO1xyXG4gICAgICAgIHRoaXMuYmx1ZUdMID0gYmx1ZTtcclxuICAgICAgICB0aGlzLmFscGhhR0wgPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGcm9tUkdCOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5yZWQgPSBjb2xvci5yO1xyXG4gICAgICAgIHRoaXMuZ3JlZW4gPSBjb2xvci5nO1xyXG4gICAgICAgIHRoaXMuYmx1ZSA9IGNvbG9yLmI7XHJcblxyXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eSgnYScpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gR2V0Q29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XHJcbiAgICAgICAgdGhpcy5fY29sb3IzMiA9IEdldENvbG9yMzIodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0aGlzLl9yZ2JhID0gJ3JnYmEoJyArIHRoaXMuciArICcsJyArIHRoaXMuZyArICcsJyArIHRoaXMuYiArICcsJyArICgyNTUgLyB0aGlzLmEpICsgJyknO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU2FtZSBhcyBzZXRSR0IgYnV0IHBlcmZvcm1zIHNhZmV0eSBjaGVja3Mgb24gYWxsIHRoZSB2YWx1ZXMgZ2l2ZW5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBjb2xvcjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbG9yMzI6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjMyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJnYmE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZ2JhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMSByYW5nZVxyXG4gICAgcmVkR0w6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbMF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuciA9IE1hdGguZmxvb3IodGhpcy5nbFswXSAqIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbkdMOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzFdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbFsxXSA9IE1hdGgubWluKE1hdGguYWJzKHZhbHVlKSwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLmZsb29yKHRoaXMuZ2xbMV0gKiAyNTUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmx1ZUdMOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nbFsyXSA9IE1hdGgubWluKE1hdGguYWJzKHZhbHVlKSwgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmIgPSBNYXRoLmZsb29yKHRoaXMuZ2xbMl0gKiAyNTUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFHTDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbFszXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hID0gTWF0aC5mbG9vcih0aGlzLmdsWzNdICogMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMjU1IHJhbmdlXHJcbiAgICByZWQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xbMV0gPSB2YWx1ZSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJsdWU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iID0gTWF0aC5taW4odmFsdWUsIDI1NSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdsWzJdID0gdmFsdWUgLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmEgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSB2YWx1ZSAvIDI1NTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgREVGQVVMVDogMCxcclxuICAgIExJTkVBUjogMCxcclxuICAgIE5FQVJFU1Q6IDFcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvU2NhbGVNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGFCdWZmZXIxNiA9IGZ1bmN0aW9uIChieXRlU2l6ZSlcclxue1xyXG4gICAgdGhpcy53b3JkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMud29yZENhcGFjaXR5ID0gYnl0ZVNpemUgLyAyO1xyXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xyXG4gICAgdGhpcy5pbnRWaWV3ID0gbmV3IEludDE2QXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy51aW50VmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbn07XHJcblxyXG5EYXRhQnVmZmVyMTYucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy53b3JkTGVuZ3RoID0gMDtcclxufTtcclxuXHJcbkRhdGFCdWZmZXIxNi5wcm90b3R5cGUuZ2V0Qnl0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLndvcmRMZW5ndGggKiAyO1xyXG59O1xyXG5cclxuRGF0YUJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbn07XHJcblxyXG5EYXRhQnVmZmVyMTYucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gKHdvcmRTaXplKVxyXG57XHJcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMud29yZExlbmd0aDtcclxuICAgIHRoaXMud29yZExlbmd0aCArPSB3b3JkU2l6ZTtcclxuICAgIHJldHVybiBjdXJyZW50TGVuZ3RoO1xyXG59O1xyXG5cclxuRGF0YUJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNTaG9ydCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy53b3JkTGVuZ3RoKTtcclxufTtcclxuXHJcbkRhdGFCdWZmZXIxNi5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzV29yZCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLnVpbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMud29yZExlbmd0aCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFCdWZmZXIxNjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC91dGlscy9EYXRhQnVmZmVyMTYuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbnZhciBHZXRDZW50ZXJYID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiBnYW1lT2JqZWN0LnggLSAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCkgKyAoZ2FtZU9iamVjdC53aWR0aCAqIDAuNSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRlclg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL0dldENlbnRlclguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbnZhciBHZXRDZW50ZXJZID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHJldHVybiBnYW1lT2JqZWN0LnkgLSAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogMC41KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudGVyWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGNlbnRlciB4IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxyXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYCh4IC0gb2Zmc2V0WCkgKyAod2lkdGggLyAyKWAuXHJcbipcclxuKiBAcHJvcGVydHkge251bWJlcn0gY2VudGVyWFxyXG4qL1xyXG5cclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuR2V0Q2VudGVyWChib2IpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlck9uKGJvYiwgeCwgeSlcclxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWChib2IsIHgpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlclkoYm9iLCB4KVxyXG5cclxudmFyIFNldENlbnRlclggPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeClcclxue1xyXG4gICAgdmFyIG9mZnNldFggPSBnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YO1xyXG5cclxuICAgIGdhbWVPYmplY3QueCA9ICh4ICsgb2Zmc2V0WCkgLSAoZ2FtZU9iamVjdC53aWR0aCAqIDAuNSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldENlbnRlclg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldENlbnRlclguanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkdldENlbnRlclgoYm9iKVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJPbihib2IsIHgsIHkpXHJcbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkNlbnRlclgoYm9iLCB4KVxyXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJZKGJvYiwgeClcclxuXHJcbnZhciBTZXRDZW50ZXJZID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHkpXHJcbntcclxuICAgIHZhciBvZmZzZXRZID0gZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblk7XHJcblxyXG4gICAgZ2FtZU9iamVjdC55ID0gKHkgKyBvZmZzZXRZKSAtIChnYW1lT2JqZWN0LmhlaWdodCAqIDAuNSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldENlbnRlclk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL1NldENlbnRlclkuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBJbWFnZUZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzLCBjb25maWcpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5pbWFnZVxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5wbmcnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdpbWFnZScsIGtleSwgdXJsLCAnYmxvYicsIHhoclNldHRpbmdzLCBjb25maWcpO1xyXG59O1xyXG5cclxuSW1hZ2VGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5JbWFnZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VGaWxlO1xyXG5cclxuSW1hZ2VGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICBfdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKF90aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kYXRhLm9uZXJyb3IgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuZGF0YS5zcmMpO1xyXG5cclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfRVJST1JFRDtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnhockxvYWRlci5yZXNwb25zZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQSB0cmlhbmdsZSBpcyBhIHBsYW5lIGNyZWF0ZWQgYnkgY29ubmVjdGluZyB0aHJlZSBwb2ludHMuXHJcbi8vIFRoZSBmaXJzdCB0d28gYXJndW1lbnRzIHNwZWNpZnkgdGhlIGZpcnN0IHBvaW50LCB0aGUgbWlkZGxlIHR3byBhcmd1bWVudHNcclxuLy8gc3BlY2lmeSB0aGUgc2Vjb25kIHBvaW50LCBhbmQgdGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSB0aGlyZCBwb2ludC5cclxuXHJcbnZhciBUcmlhbmdsZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKVxyXG57XHJcbiAgICB0aGlzLngxID0gMDtcclxuICAgIHRoaXMueTEgPSAwO1xyXG5cclxuICAgIHRoaXMueDIgPSAwO1xyXG4gICAgdGhpcy55MiA9IDA7XHJcblxyXG4gICAgdGhpcy54MyA9IDA7XHJcbiAgICB0aGlzLnkzID0gMDtcclxuXHJcbiAgICB0aGlzLnNldFRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xyXG59O1xyXG5cclxuVHJpYW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJpYW5nbGU7XHJcblxyXG5UcmlhbmdsZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7IHgxID0gMDsgfVxyXG4gICAgICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxyXG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxyXG4gICAgICAgIGlmICh5MiA9PT0gdW5kZWZpbmVkKSB7IHkyID0gMDsgfVxyXG4gICAgICAgIGlmICh4MyA9PT0gdW5kZWZpbmVkKSB7IHgzID0gMDsgfVxyXG4gICAgICAgIGlmICh5MyA9PT0gdW5kZWZpbmVkKSB7IHkzID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLngxID0geDE7XHJcbiAgICAgICAgdGhpcy55MSA9IHkxO1xyXG5cclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG5cclxuICAgICAgICB0aGlzLngzID0geDM7XHJcbiAgICAgICAgdGhpcy55MyA9IHkzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGluZUE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDEsIHkxOiB0aGlzLnkxLCB4MjogdGhpcy54MiwgeTI6IHRoaXMueTIgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGluZUI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDIsIHkxOiB0aGlzLnkyLCB4MjogdGhpcy54MywgeTI6IHRoaXMueTMgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGluZUM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDMsIHkxOiB0aGlzLnkzLCB4MjogdGhpcy54MSwgeTI6IHRoaXMueTEgfTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmlhbmdsZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBsZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxIDw9IHRoaXMueDIgJiYgdGhpcy54MSA8PSB0aGlzLngzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueDIgPD0gdGhpcy54MSAmJiB0aGlzLngyIDw9IHRoaXMueDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngyIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MyAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLngxIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy54MyAtPSBkaWZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLngxID49IHRoaXMueDIgJiYgdGhpcy54MSA+PSB0aGlzLngzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueDIgPj0gdGhpcy54MSAmJiB0aGlzLngyID49IHRoaXMueDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngyIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MyAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLngxIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy54MyAtPSBkaWZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy55MSwgdGhpcy55MiwgdGhpcy55Myk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlmZiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy55MSA8PSB0aGlzLnkyICYmIHRoaXMueTEgPD0gdGhpcy55MylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTEgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnkyIDw9IHRoaXMueTEgJiYgdGhpcy55MiA8PSB0aGlzLnkzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy55MiAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTMgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy55MSAtPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLnkyIC09IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMueTMgLT0gZGlmZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBib3R0b206IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueTEsIHRoaXMueTIsIHRoaXMueTMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPj0gdGhpcy55MiAmJiB0aGlzLnkxID49IHRoaXMueTMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkxIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy55MiA+PSB0aGlzLnkxICYmIHRoaXMueTIgPj0gdGhpcy55MylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTIgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkzIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMueTEgLT0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy55MiAtPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLnkzIC09IGRpZmY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL1RyaWFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBib2R5IG1vZGVscy5cclxuKiBBIGBNYXR0ZXIuQm9keWAgaXMgYSByaWdpZCBib2R5IHRoYXQgY2FuIGJlIHNpbXVsYXRlZCBieSBhIGBNYXR0ZXIuRW5naW5lYC5cclxuKiBGYWN0b3JpZXMgZm9yIGNvbW1vbmx5IHVzZWQgYm9keSBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucykgY2FuIGJlIGZvdW5kIGluIHRoZSBtb2R1bGUgYE1hdHRlci5Cb2RpZXNgLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuXHJcbiogQGNsYXNzIEJvZHlcclxuKi9cclxuXHJcbnZhciBCb2R5ID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XHJcblxyXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xyXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XHJcbnZhciBTbGVlcGluZyA9IHJlcXVpcmUoJy4uL2NvcmUvU2xlZXBpbmcnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9BeGVzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgQm9keS5faW5lcnRpYVNjYWxlID0gNDtcclxuICAgIEJvZHkuX25leHRDb2xsaWRpbmdHcm91cElkID0gMTtcclxuICAgIEJvZHkuX25leHROb25Db2xsaWRpbmdHcm91cElkID0gLTE7XHJcbiAgICBCb2R5Ll9uZXh0Q2F0ZWdvcnkgPSAweDAwMDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cclxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge2JvZHl9IGJvZHlcclxuICAgICAqL1xyXG4gICAgQm9keS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBpZDogQ29tbW9uLm5leHRJZCgpLFxyXG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQm9keScsXHJcbiAgICAgICAgICAgIHBhcnRzOiBbXSxcclxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcclxuICAgICAgICAgICAgYW5nbGU6IDAsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzOiBWZXJ0aWNlcy5mcm9tUGF0aCgnTCAwIDAgTCA0MCAwIEwgNDAgNDAgTCAwIDQwJyksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICAgICAgZm9yY2U6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgICAgICB0b3JxdWU6IDAsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZTogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRJbXB1bHNlOiB7IHg6IDAsIHk6IDAsIGFuZ2xlOiAwIH0sXHJcbiAgICAgICAgICAgIHRvdGFsQ29udGFjdHM6IDAsXHJcbiAgICAgICAgICAgIHNwZWVkOiAwLFxyXG4gICAgICAgICAgICBhbmd1bGFyU3BlZWQ6IDAsXHJcbiAgICAgICAgICAgIHZlbG9jaXR5OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwLFxyXG4gICAgICAgICAgICBpc1NlbnNvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vdGlvbjogMCxcclxuICAgICAgICAgICAgc2xlZXBUaHJlc2hvbGQ6IDYwLFxyXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAwMSxcclxuICAgICAgICAgICAgcmVzdGl0dXRpb246IDAsXHJcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjEsXHJcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiAwLjUsXHJcbiAgICAgICAgICAgIGZyaWN0aW9uQWlyOiAwLjAxLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25GaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXHJcbiAgICAgICAgICAgICAgICBtYXNrOiAweEZGRkZGRkZGLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2xvcDogMC4wNSxcclxuICAgICAgICAgICAgdGltZVNjYWxlOiAxLFxyXG4gICAgICAgICAgICByZW5kZXI6IHtcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcclxuICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHlPZmZzZXQ6IDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBib2R5ID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIF9pbml0UHJvcGVydGllcyhib2R5LCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgZ3JvdXAgaW5kZXggZm9yIHdoaWNoIGJvZGllcyB3aWxsIGNvbGxpZGUuXHJcbiAgICAgKiBJZiBgaXNOb25Db2xsaWRpbmdgIGlzIGB0cnVlYCwgcmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgZ3JvdXAgaW5kZXggZm9yIHdoaWNoIGJvZGllcyB3aWxsIF9ub3RfIGNvbGxpZGUuXHJcbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZXRob2QgbmV4dEdyb3VwXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtpc05vbkNvbGxpZGluZz1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIGdyb3VwIGluZGV4XHJcbiAgICAgKi9cclxuICAgIEJvZHkubmV4dEdyb3VwID0gZnVuY3Rpb24oaXNOb25Db2xsaWRpbmcpIHtcclxuICAgICAgICBpZiAoaXNOb25Db2xsaWRpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Tm9uQ29sbGlkaW5nR3JvdXBJZC0tO1xyXG5cclxuICAgICAgICByZXR1cm4gQm9keS5fbmV4dENvbGxpZGluZ0dyb3VwSWQrKztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZCAoc3RhcnRpbmcgYWZ0ZXIgdGhlIGluaXRpYWwgZGVmYXVsdCBjYXRlZ29yeSBgMHgwMDAxYCkuXHJcbiAgICAgKiBUaGVyZSBhcmUgMzIgYXZhaWxhYmxlLiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZXRob2QgbmV4dENhdGVnb3J5XHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZFxyXG4gICAgICovXHJcbiAgICBCb2R5Lm5leHRDYXRlZ29yeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIEJvZHkuX25leHRDYXRlZ29yeSA9IEJvZHkuX25leHRDYXRlZ29yeSA8PCAxO1xyXG4gICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Q2F0ZWdvcnk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGlzZXMgYm9keSBwcm9wZXJ0aWVzLlxyXG4gICAgICogQG1ldGhvZCBfaW5pdFByb3BlcnRpZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cclxuICAgICAqL1xyXG4gICAgdmFyIF9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gaW5pdCByZXF1aXJlZCBwcm9wZXJ0aWVzIChvcmRlciBpcyBpbXBvcnRhbnQpXHJcbiAgICAgICAgQm9keS5zZXQoYm9keSwge1xyXG4gICAgICAgICAgICBib3VuZHM6IGJvZHkuYm91bmRzIHx8IEJvdW5kcy5jcmVhdGUoYm9keS52ZXJ0aWNlcyksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uUHJldjogYm9keS5wb3NpdGlvblByZXYgfHwgVmVjdG9yLmNsb25lKGJvZHkucG9zaXRpb24pLFxyXG4gICAgICAgICAgICBhbmdsZVByZXY6IGJvZHkuYW5nbGVQcmV2IHx8IGJvZHkuYW5nbGUsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzOiBib2R5LnZlcnRpY2VzLFxyXG4gICAgICAgICAgICBwYXJ0czogYm9keS5wYXJ0cyB8fCBbYm9keV0sXHJcbiAgICAgICAgICAgIGlzU3RhdGljOiBib2R5LmlzU3RhdGljLFxyXG4gICAgICAgICAgICBpc1NsZWVwaW5nOiBib2R5LmlzU2xlZXBpbmcsXHJcbiAgICAgICAgICAgIHBhcmVudDogYm9keS5wYXJlbnQgfHwgYm9keVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBWZXJ0aWNlcy5yb3RhdGUoYm9keS52ZXJ0aWNlcywgYm9keS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgQXhlcy5yb3RhdGUoYm9keS5heGVzLCBib2R5LmFuZ2xlKTtcclxuICAgICAgICBCb3VuZHMudXBkYXRlKGJvZHkuYm91bmRzLCBib2R5LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuXHJcbiAgICAgICAgLy8gYWxsb3cgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHByb3BlcnRpZXNcclxuICAgICAgICBCb2R5LnNldChib2R5LCB7XHJcbiAgICAgICAgICAgIGF4ZXM6IG9wdGlvbnMuYXhlcyB8fCBib2R5LmF4ZXMsXHJcbiAgICAgICAgICAgIGFyZWE6IG9wdGlvbnMuYXJlYSB8fCBib2R5LmFyZWEsXHJcbiAgICAgICAgICAgIG1hc3M6IG9wdGlvbnMubWFzcyB8fCBib2R5Lm1hc3MsXHJcbiAgICAgICAgICAgIGluZXJ0aWE6IG9wdGlvbnMuaW5lcnRpYSB8fCBib2R5LmluZXJ0aWFcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIHByb3BlcnRpZXNcclxuICAgICAgICB2YXIgZGVmYXVsdEZpbGxTdHlsZSA9IChib2R5LmlzU3RhdGljID8gJyMyZTJiNDQnIDogQ29tbW9uLmNob29zZShbJyMwMDZCQTYnLCAnIzA0OTZGRicsICcjRkZCQzQyJywgJyNEODExNTknLCAnIzhGMkQ1NiddKSksXHJcbiAgICAgICAgICAgIGRlZmF1bHRTdHJva2VTdHlsZSA9IENvbW1vbi5zaGFkZUNvbG9yKGRlZmF1bHRGaWxsU3R5bGUsIC0yMCk7XHJcbiAgICAgICAgYm9keS5yZW5kZXIuZmlsbFN0eWxlID0gYm9keS5yZW5kZXIuZmlsbFN0eWxlIHx8IGRlZmF1bHRGaWxsU3R5bGU7XHJcbiAgICAgICAgYm9keS5yZW5kZXIuc3Ryb2tlU3R5bGUgPSBib2R5LnJlbmRlci5zdHJva2VTdHlsZSB8fCBkZWZhdWx0U3Ryb2tlU3R5bGU7XHJcbiAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnhPZmZzZXQgKz0gLShib2R5LmJvdW5kcy5taW4ueCAtIGJvZHkucG9zaXRpb24ueCkgLyAoYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueCk7XHJcbiAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnlPZmZzZXQgKz0gLShib2R5LmJvdW5kcy5taW4ueSAtIGJvZHkucG9zaXRpb24ueSkgLyAoYm9keS5ib3VuZHMubWF4LnkgLSBib2R5LmJvdW5kcy5taW4ueSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBwcm9wZXJ0eSBhbmQgYSB2YWx1ZSAob3IgbWFwIG9mKSwgc2V0cyB0aGUgcHJvcGVydHkocykgb24gdGhlIGJvZHksIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXR0ZXIgZnVuY3Rpb25zIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgKiBQcmVmZXIgdG8gdXNlIHRoZSBhY3R1YWwgc2V0dGVyIGZ1bmN0aW9ucyBpbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBzaXR1YXRpb25zLlxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt9IHNldHRpbmdzIEEgcHJvcGVydHkgbmFtZSAob3IgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcykgdG8gc2V0IG9uIHRoZSBib2R5LlxyXG4gICAgICogQHBhcmFtIHt9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgaWYgYHNldHRpbmdzYCBpcyBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBCb2R5LnNldCA9IGZ1bmN0aW9uKGJvZHksIHNldHRpbmdzLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkgPSBzZXR0aW5ncztcclxuICAgICAgICAgICAgc2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgc2V0dGluZ3NbcHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3NbcHJvcGVydHldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2lzU3RhdGljJzpcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0U3RhdGljKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpc1NsZWVwaW5nJzpcclxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWFzcyc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RlbnNpdHknOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXREZW5zaXR5KGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpbmVydGlhJzpcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmVydGljZXMnOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZXJ0aWNlcyhib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYW5nbGUnOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmVsb2NpdHknOlxyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZWxvY2l0eShib2R5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYW5ndWxhclZlbG9jaXR5JzpcclxuICAgICAgICAgICAgICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdwYXJ0cyc6XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldFBhcnRzKGJvZHksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYm9keVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9keSBhcyBzdGF0aWMsIGluY2x1ZGluZyBpc1N0YXRpYyBmbGFnIGFuZCBzZXR0aW5nIG1hc3MgYW5kIGluZXJ0aWEgdG8gSW5maW5pdHkuXHJcbiAgICAgKiBAbWV0aG9kIHNldFN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGlzU3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0U3RhdGljID0gZnVuY3Rpb24oYm9keSwgaXNTdGF0aWMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xyXG4gICAgICAgICAgICBwYXJ0LmlzU3RhdGljID0gaXNTdGF0aWM7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIHBhcnQuX29yaWdpbmFsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3RpdHV0aW9uOiBwYXJ0LnJlc3RpdHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uOiBwYXJ0LmZyaWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc3M6IHBhcnQubWFzcyxcclxuICAgICAgICAgICAgICAgICAgICBpbmVydGlhOiBwYXJ0LmluZXJ0aWEsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eTogcGFydC5kZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VNYXNzOiBwYXJ0LmludmVyc2VNYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VJbmVydGlhOiBwYXJ0LmludmVyc2VJbmVydGlhXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnQucmVzdGl0dXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICBwYXJ0Lm1hc3MgPSBwYXJ0LmluZXJ0aWEgPSBwYXJ0LmRlbnNpdHkgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZU1hc3MgPSBwYXJ0LmludmVyc2VJbmVydGlhID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi54ID0gcGFydC5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvblByZXYueSA9IHBhcnQucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIHBhcnQuYW5nbGVQcmV2ID0gcGFydC5hbmdsZTtcclxuICAgICAgICAgICAgICAgIHBhcnQuYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgICAgIHBhcnQuc3BlZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGFydC5hbmd1bGFyU3BlZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGFydC5tb3Rpb24gPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQuX29yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnJlc3RpdHV0aW9uID0gcGFydC5fb3JpZ2luYWwucmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmZyaWN0aW9uID0gcGFydC5fb3JpZ2luYWwuZnJpY3Rpb247XHJcbiAgICAgICAgICAgICAgICBwYXJ0Lm1hc3MgPSBwYXJ0Ll9vcmlnaW5hbC5tYXNzO1xyXG4gICAgICAgICAgICAgICAgcGFydC5pbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW5lcnRpYTtcclxuICAgICAgICAgICAgICAgIHBhcnQuZGVuc2l0eSA9IHBhcnQuX29yaWdpbmFsLmRlbnNpdHk7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VNYXNzID0gcGFydC5fb3JpZ2luYWwuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VJbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW52ZXJzZUluZXJ0aWE7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcnQuX29yaWdpbmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hc3Mgb2YgdGhlIGJvZHkuIEludmVyc2UgbWFzcyBhbmQgZGVuc2l0eSBhcmUgYXV0b21hdGljYWxseSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIGNoYW5nZS5cclxuICAgICAqIEBtZXRob2Qgc2V0TWFzc1xyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFzc1xyXG4gICAgICovXHJcbiAgICBCb2R5LnNldE1hc3MgPSBmdW5jdGlvbihib2R5LCBtYXNzKSB7XHJcbiAgICAgICAgYm9keS5tYXNzID0gbWFzcztcclxuICAgICAgICBib2R5LmludmVyc2VNYXNzID0gMSAvIGJvZHkubWFzcztcclxuICAgICAgICBib2R5LmRlbnNpdHkgPSBib2R5Lm1hc3MgLyBib2R5LmFyZWE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZGVuc2l0eSBvZiB0aGUgYm9keS4gTWFzcyBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxyXG4gICAgICogQG1ldGhvZCBzZXREZW5zaXR5XHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5XHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uKGJvZHksIGRlbnNpdHkpIHtcclxuICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgZGVuc2l0eSAqIGJvZHkuYXJlYSk7XHJcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gZGVuc2l0eTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtb21lbnQgb2YgaW5lcnRpYSAoaS5lLiBzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBib2R5IG9mIHRoZSBib2R5LiBcclxuICAgICAqIEludmVyc2UgaW5lcnRpYSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLiBNYXNzIGlzIG5vdCBjaGFuZ2VkLlxyXG4gICAgICogQG1ldGhvZCBzZXRJbmVydGlhXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmVydGlhXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0SW5lcnRpYSA9IGZ1bmN0aW9uKGJvZHksIGluZXJ0aWEpIHtcclxuICAgICAgICBib2R5LmluZXJ0aWEgPSBpbmVydGlhO1xyXG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvZHkncyB2ZXJ0aWNlcyBhbmQgdXBkYXRlcyBib2R5IHByb3BlcnRpZXMgYWNjb3JkaW5nbHksIGluY2x1ZGluZyBpbmVydGlhLCBhcmVhIGFuZCBtYXNzICh3aXRoIHJlc3BlY3QgdG8gYGJvZHkuZGVuc2l0eWApLlxyXG4gICAgICogVmVydGljZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybWVkIHRvIGJlIG9yaWVudGF0ZWQgYXJvdW5kIHRoZWlyIGNlbnRyZSBvZiBtYXNzIGFzIHRoZSBvcmlnaW4uXHJcbiAgICAgKiBUaGV5IGFyZSB0aGVuIGF1dG9tYXRpY2FsbHkgdHJhbnNsYXRlZCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBgYm9keS5wb3NpdGlvbmAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGB2ZXJ0aWNlc2AgYXJndW1lbnQgc2hvdWxkIGJlIHBhc3NlZCBhcyBhbiBhcnJheSBvZiBgTWF0dGVyLlZlY3RvcmAgcG9pbnRzIChvciBhIGBNYXR0ZXIuVmVydGljZXNgIGFycmF5KS5cclxuICAgICAqIFZlcnRpY2VzIG11c3QgZm9ybSBhIGNvbnZleCBodWxsLCBjb25jYXZlIGh1bGxzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2Qgc2V0VmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3JbXX0gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgQm9keS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uKGJvZHksIHZlcnRpY2VzKSB7XHJcbiAgICAgICAgLy8gY2hhbmdlIHZlcnRpY2VzXHJcbiAgICAgICAgaWYgKHZlcnRpY2VzWzBdLmJvZHkgPT09IGJvZHkpIHtcclxuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvZHkudmVydGljZXMgPSBWZXJ0aWNlcy5jcmVhdGUodmVydGljZXMsIGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHByb3BlcnRpZXNcclxuICAgICAgICBib2R5LmF4ZXMgPSBBeGVzLmZyb21WZXJ0aWNlcyhib2R5LnZlcnRpY2VzKTtcclxuICAgICAgICBib2R5LmFyZWEgPSBWZXJ0aWNlcy5hcmVhKGJvZHkudmVydGljZXMpO1xyXG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBib2R5LmRlbnNpdHkgKiBib2R5LmFyZWEpO1xyXG5cclxuICAgICAgICAvLyBvcmllbnQgdmVydGljZXMgYXJvdW5kIHRoZSBjZW50cmUgb2YgbWFzcyBhdCBvcmlnaW4gKDAsIDApXHJcbiAgICAgICAgdmFyIGNlbnRyZSA9IFZlcnRpY2VzLmNlbnRyZShib2R5LnZlcnRpY2VzKTtcclxuICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUoYm9keS52ZXJ0aWNlcywgY2VudHJlLCAtMSk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBpbmVydGlhIHdoaWxlIHZlcnRpY2VzIGFyZSBhdCBvcmlnaW4gKDAsIDApXHJcbiAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIEJvZHkuX2luZXJ0aWFTY2FsZSAqIFZlcnRpY2VzLmluZXJ0aWEoYm9keS52ZXJ0aWNlcywgYm9keS5tYXNzKSk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeVxyXG4gICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICBCb3VuZHMudXBkYXRlKGJvZHkuYm91bmRzLCBib2R5LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwYXJ0cyBvZiB0aGUgYGJvZHlgIGFuZCB1cGRhdGVzIG1hc3MsIGluZXJ0aWEgYW5kIGNlbnRyb2lkLlxyXG4gICAgICogRWFjaCBwYXJ0IHdpbGwgaGF2ZSBpdHMgcGFyZW50IHNldCB0byBgYm9keWAuXHJcbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBjb252ZXggaHVsbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgYW5kIHNldCBvbiBgYm9keWAsIHVubGVzcyBgYXV0b0h1bGxgIGlzIHNldCB0byBgZmFsc2UuYFxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGZpcnN0IHBhcnQgaW4gYGJvZHkucGFydHNgIHdpbGwgYWx3YXlzIGJlIHRoZSBgYm9keWAuXHJcbiAgICAgKiBAbWV0aG9kIHNldFBhcnRzXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSBbYm9keV0gcGFydHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2F1dG9IdWxsPXRydWVdXHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0UGFydHMgPSBmdW5jdGlvbihib2R5LCBwYXJ0cywgYXV0b0h1bGwpIHtcclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGFsbCB0aGUgcGFydHMsIGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0IHBhcnQgaXMgYWx3YXlzIHRoZSBwYXJlbnQgYm9keVxyXG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCk7XHJcbiAgICAgICAgYm9keS5wYXJ0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGJvZHkucGFydHMucHVzaChib2R5KTtcclxuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGFydCAhPT0gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcGFydC5wYXJlbnQgPSBib2R5O1xyXG4gICAgICAgICAgICAgICAgYm9keS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYm9keS5wYXJ0cy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgYXV0b0h1bGwgPSB0eXBlb2YgYXV0b0h1bGwgIT09ICd1bmRlZmluZWQnID8gYXV0b0h1bGwgOiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRoZSBjb252ZXggaHVsbCBvZiBhbGwgcGFydHMgdG8gc2V0IG9uIHRoZSBwYXJlbnQgYm9keVxyXG4gICAgICAgIGlmIChhdXRvSHVsbCkge1xyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdChwYXJ0c1tpXS52ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzLmNsb2Nrd2lzZVNvcnQodmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGh1bGwgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKSxcclxuICAgICAgICAgICAgICAgIGh1bGxDZW50cmUgPSBWZXJ0aWNlcy5jZW50cmUoaHVsbCk7XHJcblxyXG4gICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIGh1bGwpO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUoYm9keS52ZXJ0aWNlcywgaHVsbENlbnRyZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdW0gdGhlIHByb3BlcnRpZXMgb2YgYWxsIGNvbXBvdW5kIHBhcnRzIG9mIHRoZSBwYXJlbnQgYm9keVxyXG4gICAgICAgIHZhciB0b3RhbCA9IF90b3RhbFByb3BlcnRpZXMoYm9keSk7XHJcblxyXG4gICAgICAgIGJvZHkuYXJlYSA9IHRvdGFsLmFyZWE7XHJcbiAgICAgICAgYm9keS5wYXJlbnQgPSBib2R5O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb24ueCA9IHRvdGFsLmNlbnRyZS54O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb24ueSA9IHRvdGFsLmNlbnRyZS55O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSB0b3RhbC5jZW50cmUueDtcclxuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gdG90YWwuY2VudHJlLnk7XHJcblxyXG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCB0b3RhbC5tYXNzKTtcclxuICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdG90YWwuaW5lcnRpYSk7XHJcbiAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB0b3RhbC5jZW50cmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IGluc3RhbnRseS4gVmVsb2NpdHksIGFuZ2xlLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuXHJcbiAgICAgKiBAbWV0aG9kIHNldFBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBCb2R5LnNldFBvc2l0aW9uID0gZnVuY3Rpb24oYm9keSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvc2l0aW9uLCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ICs9IGRlbHRhLng7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSArPSBkZWx0YS55O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xyXG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gZGVsdGEueDtcclxuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGRlbHRhLnk7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmdsZSBvZiB0aGUgYm9keSBpbnN0YW50bHkuIEFuZ3VsYXIgdmVsb2NpdHksIHBvc2l0aW9uLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuXHJcbiAgICAgKiBAbWV0aG9kIHNldEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBCb2R5LnNldEFuZ2xlID0gZnVuY3Rpb24oYm9keSwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZGVsdGEgPSBhbmdsZSAtIGJvZHkuYW5nbGU7XHJcbiAgICAgICAgYm9keS5hbmdsZVByZXYgKz0gZGVsdGE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XHJcbiAgICAgICAgICAgIHBhcnQuYW5nbGUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzLnJvdGF0ZShwYXJ0LnZlcnRpY2VzLCBkZWx0YSwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgZGVsdGEpO1xyXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgZGVsdGEsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSBpbnN0YW50bHkuIFBvc2l0aW9uLCBhbmdsZSwgZm9yY2UgZXRjLiBhcmUgdW5jaGFuZ2VkLiBTZWUgYWxzbyBgQm9keS5hcHBseUZvcmNlYC5cclxuICAgICAqIEBtZXRob2Qgc2V0VmVsb2NpdHlcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0VmVsb2NpdHkgPSBmdW5jdGlvbihib2R5LCB2ZWxvY2l0eSkge1xyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLnggLSB2ZWxvY2l0eS54O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnkgLSB2ZWxvY2l0eS55O1xyXG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9IHZlbG9jaXR5Lng7XHJcbiAgICAgICAgYm9keS52ZWxvY2l0eS55ID0gdmVsb2NpdHkueTtcclxuICAgICAgICBib2R5LnNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShib2R5LnZlbG9jaXR5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5IGluc3RhbnRseS4gUG9zaXRpb24sIGFuZ2xlLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxyXG4gICAgICogQG1ldGhvZCBzZXRBbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSwgdmVsb2NpdHkpIHtcclxuICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGUgLSB2ZWxvY2l0eTtcclxuICAgICAgICBib2R5LmFuZ3VsYXJWZWxvY2l0eSA9IHZlbG9jaXR5O1xyXG4gICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gTWF0aC5hYnMoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIGEgYm9keSBieSBhIGdpdmVuIHZlY3RvciByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvbiwgd2l0aG91dCBpbXBhcnRpbmcgYW55IHZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIEJvZHkudHJhbnNsYXRlID0gZnVuY3Rpb24oYm9keSwgdHJhbnNsYXRpb24pIHtcclxuICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIFZlY3Rvci5hZGQoYm9keS5wb3NpdGlvbiwgdHJhbnNsYXRpb24pKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIGEgYm9keSBieSBhIGdpdmVuIGFuZ2xlIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IGFuZ2xlLCB3aXRob3V0IGltcGFydGluZyBhbnkgYW5ndWxhciB2ZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2Qgcm90YXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvblxyXG4gICAgICovXHJcbiAgICBCb2R5LnJvdGF0ZSA9IGZ1bmN0aW9uKGJvZHksIHJvdGF0aW9uKSB7XHJcbiAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCBib2R5LmFuZ2xlICsgcm90YXRpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGUgYm9keSwgaW5jbHVkaW5nIHVwZGF0aW5nIHBoeXNpY2FsIHByb3BlcnRpZXMgKG1hc3MsIGFyZWEsIGF4ZXMsIGluZXJ0aWEpLCBmcm9tIGEgd29ybGQtc3BhY2UgcG9pbnQgKGRlZmF1bHQgaXMgYm9keSBjZW50cmUpLlxyXG4gICAgICogQG1ldGhvZCBzY2FsZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BvaW50XVxyXG4gICAgICovXHJcbiAgICBCb2R5LnNjYWxlID0gZnVuY3Rpb24oYm9keSwgc2NhbGVYLCBzY2FsZVksIHBvaW50KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNjYWxlIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIFZlcnRpY2VzLnNjYWxlKHBhcnQudmVydGljZXMsIHNjYWxlWCwgc2NhbGVZLCBib2R5LnBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIHBhcnQuYXhlcyA9IEF4ZXMuZnJvbVZlcnRpY2VzKHBhcnQudmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmFyZWEgPSBWZXJ0aWNlcy5hcmVhKHBhcnQudmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgQm9keS5zZXRNYXNzKHBhcnQsIGJvZHkuZGVuc2l0eSAqIHBhcnQuYXJlYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgKHJlcXVpcmVzIHZlcnRpY2VzIHRvIGJlIGF0IG9yaWdpbilcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCB7IHg6IC1wYXJ0LnBvc2l0aW9uLngsIHk6IC1wYXJ0LnBvc2l0aW9uLnkgfSk7XHJcbiAgICAgICAgICAgICAgICBCb2R5LnNldEluZXJ0aWEocGFydCwgVmVydGljZXMuaW5lcnRpYShwYXJ0LnZlcnRpY2VzLCBwYXJ0Lm1hc3MpKTtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCB7IHg6IHBhcnQucG9zaXRpb24ueCwgeTogcGFydC5wb3NpdGlvbi55IH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm91bmRzXHJcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGNpcmNsZXNcclxuICAgICAgICBpZiAoYm9keS5jaXJjbGVSYWRpdXMpIHsgXHJcbiAgICAgICAgICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xyXG4gICAgICAgICAgICAgICAgYm9keS5jaXJjbGVSYWRpdXMgKj0gc2NhbGVYO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYm9keSBpcyBubyBsb25nZXIgYSBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGJvZHkuY2lyY2xlUmFkaXVzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFib2R5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IF90b3RhbFByb3BlcnRpZXMoYm9keSk7XHJcbiAgICAgICAgICAgIGJvZHkuYXJlYSA9IHRvdGFsLmFyZWE7XHJcbiAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCB0b3RhbC5tYXNzKTtcclxuICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIHRvdGFsLmluZXJ0aWEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHNpbXVsYXRpb24gc3RlcCBmb3IgdGhlIGdpdmVuIGBib2R5YCwgaW5jbHVkaW5nIHVwZGF0aW5nIHBvc2l0aW9uIGFuZCBhbmdsZSB1c2luZyBWZXJsZXQgaW50ZWdyYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29ycmVjdGlvblxyXG4gICAgICovXHJcbiAgICBCb2R5LnVwZGF0ZSA9IGZ1bmN0aW9uKGJvZHksIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhVGltZVNxdWFyZWQgPSBNYXRoLnBvdyhkZWx0YVRpbWUgKiB0aW1lU2NhbGUgKiBib2R5LnRpbWVTY2FsZSwgMik7XHJcblxyXG4gICAgICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcclxuICAgICAgICB2YXIgZnJpY3Rpb25BaXIgPSAxIC0gYm9keS5mcmljdGlvbkFpciAqIHRpbWVTY2FsZSAqIGJvZHkudGltZVNjYWxlLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eVByZXZYID0gYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCxcclxuICAgICAgICAgICAgdmVsb2NpdHlQcmV2WSA9IGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2Lnk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB2ZWxvY2l0eSB3aXRoIFZlcmxldCBpbnRlZ3JhdGlvblxyXG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9ICh2ZWxvY2l0eVByZXZYICogZnJpY3Rpb25BaXIgKiBjb3JyZWN0aW9uKSArIChib2R5LmZvcmNlLnggLyBib2R5Lm1hc3MpICogZGVsdGFUaW1lU3F1YXJlZDtcclxuICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSAodmVsb2NpdHlQcmV2WSAqIGZyaWN0aW9uQWlyICogY29ycmVjdGlvbikgKyAoYm9keS5mb3JjZS55IC8gYm9keS5tYXNzKSAqIGRlbHRhVGltZVNxdWFyZWQ7XHJcblxyXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XHJcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueTtcclxuICAgICAgICBib2R5LnBvc2l0aW9uLnggKz0gYm9keS52ZWxvY2l0eS54O1xyXG4gICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBhbmd1bGFyIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXHJcbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSAoKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkudG9ycXVlIC8gYm9keS5pbmVydGlhKSAqIGRlbHRhVGltZVNxdWFyZWQ7XHJcbiAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlO1xyXG4gICAgICAgIGJvZHkuYW5nbGUgKz0gYm9keS5hbmd1bGFyVmVsb2NpdHk7XHJcblxyXG4gICAgICAgIC8vIHRyYWNrIHNwZWVkIGFuZCBhY2NlbGVyYXRpb25cclxuICAgICAgICBib2R5LnNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IE1hdGguYWJzKGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcclxuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSBib2R5IGdlb21ldHJ5XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkudmVsb2NpdHkueDtcclxuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmFuZ3VsYXJWZWxvY2l0eSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMucm90YXRlKHBhcnQudmVydGljZXMsIGJvZHkuYW5ndWxhclZlbG9jaXR5LCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGJvZHkuYW5ndWxhclZlbG9jaXR5LCBib2R5LnBvc2l0aW9uLCBwYXJ0LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBmb3JjZSB0byBhIGJvZHkgZnJvbSBhIGdpdmVuIHdvcmxkLXNwYWNlIHBvc2l0aW9uLCBpbmNsdWRpbmcgcmVzdWx0aW5nIHRvcnF1ZS5cclxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBmb3JjZVxyXG4gICAgICovXHJcbiAgICBCb2R5LmFwcGx5Rm9yY2UgPSBmdW5jdGlvbihib2R5LCBwb3NpdGlvbiwgZm9yY2UpIHtcclxuICAgICAgICBib2R5LmZvcmNlLnggKz0gZm9yY2UueDtcclxuICAgICAgICBib2R5LmZvcmNlLnkgKz0gZm9yY2UueTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0geyB4OiBwb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XHJcbiAgICAgICAgYm9keS50b3JxdWUgKz0gb2Zmc2V0LnggKiBmb3JjZS55IC0gb2Zmc2V0LnkgKiBmb3JjZS54O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bXMgb2YgdGhlIHByb3BlcnRpZXMgb2YgYWxsIGNvbXBvdW5kIHBhcnRzIG9mIHRoZSBwYXJlbnQgYm9keS5cclxuICAgICAqIEBtZXRob2QgX3RvdGFsUHJvcGVydGllc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxyXG4gICAgICogQHJldHVybiB7fVxyXG4gICAgICovXHJcbiAgICB2YXIgX3RvdGFsUHJvcGVydGllcyA9IGZ1bmN0aW9uKGJvZHkpIHtcclxuICAgICAgICAvLyBodHRwczovL2Vjb3Vyc2VzLm91LmVkdS9jZ2ktYmluL2Vib29rLmNnaT9kb2M9JnRvcGljPXN0JmNoYXBfc2VjPTA3LjImcGFnZT10aGVvcnlcclxuICAgICAgICAvLyBodHRwOi8vb3V0cHV0LnRvL3NpZGV3YXkvZGVmYXVsdC5hc3A/cW5vPTEyMTEwMDA4N1xyXG5cclxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgbWFzczogMCxcclxuICAgICAgICAgICAgYXJlYTogMCxcclxuICAgICAgICAgICAgaW5lcnRpYTogMCxcclxuICAgICAgICAgICAgY2VudHJlOiB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHN1bSB0aGUgcHJvcGVydGllcyBvZiBhbGwgY29tcG91bmQgcGFydHMgb2YgdGhlIHBhcmVudCBib2R5XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGJvZHkucGFydHMubGVuZ3RoID09PSAxID8gMCA6IDE7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcclxuICAgICAgICAgICAgcHJvcGVydGllcy5tYXNzICs9IHBhcnQubWFzcztcclxuICAgICAgICAgICAgcHJvcGVydGllcy5hcmVhICs9IHBhcnQuYXJlYTtcclxuICAgICAgICAgICAgcHJvcGVydGllcy5pbmVydGlhICs9IHBhcnQuaW5lcnRpYTtcclxuICAgICAgICAgICAgcHJvcGVydGllcy5jZW50cmUgPSBWZWN0b3IuYWRkKHByb3BlcnRpZXMuY2VudHJlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3Rvci5tdWx0KHBhcnQucG9zaXRpb24sIHBhcnQubWFzcyAhPT0gSW5maW5pdHkgPyBwYXJ0Lm1hc3MgOiAxKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9wZXJ0aWVzLmNlbnRyZSA9IFZlY3Rvci5kaXYocHJvcGVydGllcy5jZW50cmUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLm1hc3MgIT09IEluZmluaXR5ID8gcHJvcGVydGllcy5tYXNzIDogYm9keS5wYXJ0cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgYm9keSBzdGFydHMgc2xlZXBpbmcgKHdoZXJlIGB0aGlzYCBpcyB0aGUgYm9keSkuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBzbGVlcFN0YXJ0XHJcbiAgICAqIEB0aGlzIHtib2R5fSBUaGUgYm9keSB0aGF0IGhhcyBzdGFydGVkIHNsZWVwaW5nXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgYm9keSBlbmRzIHNsZWVwaW5nICh3aGVyZSBgdGhpc2AgaXMgdGhlIGJvZHkpLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgc2xlZXBFbmRcclxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIGVuZGVkIHNsZWVwaW5nXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qXHJcbiAgICAqXHJcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYEJvZHkuY3JlYXRlYCBieSBgQ29tbW9uLm5leHRJZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJib2R5XCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBsYWJlbFxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBcIkJvZHlcIlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBib2RpZXMgdGhhdCBtYWtlIHVwIHRoaXMgYm9keS4gXHJcbiAgICAgKiBUaGUgZmlyc3QgYm9keSBpbiB0aGUgYXJyYXkgbXVzdCBhbHdheXMgYmUgYSBzZWxmIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBib2R5IGluc3RhbmNlLlxyXG4gICAgICogQWxsIGJvZGllcyBpbiB0aGUgYHBhcnRzYCBhcnJheSB0b2dldGhlciBmb3JtIGEgc2luZ2xlIHJpZ2lkIGNvbXBvdW5kIGJvZHkuXHJcbiAgICAgKiBQYXJ0cyBhcmUgYWxsb3dlZCB0byBvdmVybGFwLCBoYXZlIGdhcHMgb3IgaG9sZXMgb3IgZXZlbiBmb3JtIGNvbmNhdmUgYm9kaWVzLlxyXG4gICAgICogUGFydHMgdGhlbXNlbHZlcyBzaG91bGQgbmV2ZXIgYmUgYWRkZWQgdG8gYSBgV29ybGRgLCBvbmx5IHRoZSBwYXJlbnQgYm9keSBzaG91bGQgYmUuXHJcbiAgICAgKiBVc2UgYEJvZHkuc2V0UGFydHNgIHdoZW4gc2V0dGluZyBwYXJ0cyB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIG9mIGFsbCBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwYXJ0c1xyXG4gICAgICogQHR5cGUgYm9keVtdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXHJcbiAgICAgKiBAdHlwZSB7fVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNlbGYgcmVmZXJlbmNlIGlmIHRoZSBib2R5IGlzIF9ub3RfIGEgcGFydCBvZiBhbm90aGVyIGJvZHkuXHJcbiAgICAgKiBPdGhlcndpc2UgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgYm9keSB0aGF0IHRoaXMgaXMgYSBwYXJ0IG9mLlxyXG4gICAgICogU2VlIGBib2R5LnBhcnRzYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XHJcbiAgICAgKiBAdHlwZSBib2R5XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgc3BlY2lmeWluZyB0aGUgYW5nbGUgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgYFZlY3RvcmAgb2JqZWN0cyB0aGF0IHNwZWNpZnkgdGhlIGNvbnZleCBodWxsIG9mIHRoZSByaWdpZCBib2R5LlxyXG4gICAgICogVGhlc2Ugc2hvdWxkIGJlIHByb3ZpZGVkIGFib3V0IHRoZSBvcmlnaW4gYCgwLCAwKWAuIEUuZy5cclxuICAgICAqXHJcbiAgICAgKiAgICAgW3sgeDogMCwgeTogMCB9LCB7IHg6IDI1LCB5OiA1MCB9LCB7IHg6IDUwLCB5OiAwIH1dXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBwYXNzZWQgdmlhIGBCb2R5LmNyZWF0ZWAsIHRoZSB2ZXJ0aWNlcyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byBgYm9keS5wb3NpdGlvbmAgKGkuZS4gd29ybGQtc3BhY2UsIGFuZCBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgc2ltdWxhdGlvbikuXHJcbiAgICAgKiBUaGUgYFZlY3RvcmAgb2JqZWN0cyBhcmUgYWxzbyBhdWdtZW50ZWQgd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcmVxdWlyZWQgZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uLiBcclxuICAgICAqXHJcbiAgICAgKiBPdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgYGluZXJ0aWFgIGFuZCBgYm91bmRzYCBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIHBhc3NlZCB2ZXJ0aWNlcyAodW5sZXNzIHByb3ZpZGVkIHZpYSBgb3B0aW9uc2ApLlxyXG4gICAgICogQ29uY2F2ZSBodWxscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuIFRoZSBtb2R1bGUgYE1hdHRlci5WZXJ0aWNlc2AgY29udGFpbnMgdXNlZnVsIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB2ZXJ0aWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcclxuICAgICAqIEB0eXBlIHZlY3RvcltdXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIGN1cnJlbnQgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXHJcbiAgICAgKiBAdHlwZSB2ZWN0b3JcclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIGZvcmNlIHRvIGFwcGx5IGluIHRoZSBjdXJyZW50IHN0ZXAuIEl0IGlzIHplcm9lZCBhZnRlciBldmVyeSBgQm9keS51cGRhdGVgLiBTZWUgYWxzbyBgQm9keS5hcHBseUZvcmNlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcclxuICAgICAqIEB0eXBlIHZlY3RvclxyXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdG9ycXVlICh0dXJuaW5nIGZvcmNlKSB0byBhcHBseSBpbiB0aGUgY3VycmVudCBzdGVwLiBJdCBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEJvZHkudXBkYXRlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdG9ycXVlXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgc3BlZWQgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5IGFuZCBhbHdheXMgcG9zaXRpdmUgKGl0J3MgdGhlIG1hZ25pdHVkZSBvZiBgYm9keS52ZWxvY2l0eWApLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHByb3BlcnR5IHNwZWVkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgYW5ndWxhciBzcGVlZCBvZiB0aGUgYm9keSBhZnRlciB0aGUgbGFzdCBgQm9keS51cGRhdGVgLiBJdCBpcyByZWFkLW9ubHkgYW5kIGFsd2F5cyBwb3NpdGl2ZSAoaXQncyB0aGUgbWFnbml0dWRlIG9mIGBib2R5LmFuZ3VsYXJWZWxvY2l0eWApLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJTcGVlZFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBjdXJyZW50IHZlbG9jaXR5IG9mIHRoZSBib2R5IGFmdGVyIHRoZSBsYXN0IGBCb2R5LnVwZGF0ZWAuIEl0IGlzIHJlYWQtb25seS4gXHJcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBtb2RpZnkgYSBib2R5J3MgdmVsb2NpdHkgZGlyZWN0bHksIHlvdSBzaG91bGQgZWl0aGVyIGFwcGx5IGEgZm9yY2Ugb3Igc2ltcGx5IGNoYW5nZSB0aGUgYm9keSdzIGBwb3NpdGlvbmAgKGFzIHRoZSBlbmdpbmUgdXNlcyBwb3NpdGlvbi1WZXJsZXQgaW50ZWdyYXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XHJcbiAgICAgKiBAdHlwZSB2ZWN0b3JcclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBjdXJyZW50IGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcclxuICAgICAqIElmIHlvdSBuZWVkIHRvIG1vZGlmeSBhIGJvZHkncyBhbmd1bGFyIHZlbG9jaXR5IGRpcmVjdGx5LCB5b3Ugc2hvdWxkIGFwcGx5IGEgdG9ycXVlIG9yIHNpbXBseSBjaGFuZ2UgdGhlIGJvZHkncyBgYW5nbGVgIChhcyB0aGUgZW5naW5lIHVzZXMgcG9zaXRpb24tVmVybGV0IGludGVncmF0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGJvZHkgaXMgY29uc2lkZXJlZCBzdGF0aWMuIEEgc3RhdGljIGJvZHkgY2FuIG5ldmVyIGNoYW5nZSBwb3NpdGlvbiBvciBhbmdsZSBhbmQgaXMgY29tcGxldGVseSBmaXhlZC5cclxuICAgICAqIElmIHlvdSBuZWVkIHRvIHNldCBhIGJvZHkgYXMgc3RhdGljIGFmdGVyIGl0cyBjcmVhdGlvbiwgeW91IHNob3VsZCB1c2UgYEJvZHkuc2V0U3RhdGljYCBhcyB0aGlzIHJlcXVpcmVzIG1vcmUgdGhhbiBqdXN0IHNldHRpbmcgdGhpcyBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc1N0YXRpY1xyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBib2R5IGlzIGEgc2Vuc29yLiBTZW5zb3IgdHJpZ2dlcnMgY29sbGlzaW9uIGV2ZW50cywgYnV0IGRvZXNuJ3QgcmVhY3Qgd2l0aCBjb2xsaWRpbmcgYm9keSBwaHlzaWNhbGx5LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc1NlbnNvclxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcGluZy4gQSBzbGVlcGluZyBib2R5IGFjdHMgc2ltaWxhciB0byBhIHN0YXRpYyBib2R5LCBleGNlcHQgaXQgaXMgb25seSB0ZW1wb3JhcnkgYW5kIGNhbiBiZSBhd29rZW4uXHJcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBzZXQgYSBib2R5IGFzIHNsZWVwaW5nLCB5b3Ugc2hvdWxkIHVzZSBgU2xlZXBpbmcuc2V0YCBhcyB0aGlzIHJlcXVpcmVzIG1vcmUgdGhhbiBqdXN0IHNldHRpbmcgdGhpcyBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc1NsZWVwaW5nXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgYW1vdW50IG9mIG1vdmVtZW50IGEgYm9keSBjdXJyZW50bHkgaGFzIChhIGNvbWJpbmF0aW9uIG9mIGBzcGVlZGAgYW5kIGBhbmd1bGFyU3BlZWRgKS4gSXQgaXMgcmVhZC1vbmx5IGFuZCBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgKiBJdCBpcyB1c2VkIGFuZCB1cGRhdGVkIGJ5IHRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUgZHVyaW5nIHNpbXVsYXRpb24gdG8gZGVjaWRlIGlmIGEgYm9keSBoYXMgY29tZSB0byByZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHByb3BlcnR5IG1vdGlvblxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBudW1iZXIgb2YgdXBkYXRlcyBpbiB3aGljaCB0aGlzIGJvZHkgbXVzdCBoYXZlIG5lYXItemVybyB2ZWxvY2l0eSBiZWZvcmUgaXQgaXMgc2V0IGFzIHNsZWVwaW5nIGJ5IHRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUgKGlmIHNsZWVwaW5nIGlzIGVuYWJsZWQgYnkgdGhlIGVuZ2luZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGhyZXNob2xkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDYwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LCB0aGF0IGlzIGl0cyBtYXNzIHBlciB1bml0IGFyZWEuXHJcbiAgICAgKiBJZiB5b3UgcGFzcyB0aGUgZGVuc2l0eSB2aWEgYEJvZHkuY3JlYXRlYCB0aGUgYG1hc3NgIHByb3BlcnR5IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmb3IgeW91IGJhc2VkIG9uIHRoZSBzaXplIChhcmVhKSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogVGhpcyBpcyBnZW5lcmFsbHkgcHJlZmVyYWJsZSB0byBzaW1wbHkgc2V0dGluZyBtYXNzIGFuZCBhbGxvd3MgZm9yIG1vcmUgaW50dWl0aXZlIGRlZmluaXRpb24gb2YgbWF0ZXJpYWxzIChlLmcuIHJvY2sgaGFzIGEgaGlnaGVyIGRlbnNpdHkgdGhhbiB3b29kKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZGVuc2l0eVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbWFzcyBvZiB0aGUgYm9keSwgYWx0aG91Z2ggaXQgbWF5IGJlIG1vcmUgYXBwcm9wcmlhdGUgdG8gc3BlY2lmeSB0aGUgYGRlbnNpdHlgIHByb3BlcnR5IGluc3RlYWQuXHJcbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbnZlcnNlTWFzc2AgcHJvcGVydHkgKGAxIC8gbWFzc2ApLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBtYXNzXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keSAoYDEgLyBtYXNzYCkuXHJcbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5tYXNzYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZU1hc3NcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKGkuZS4gc2Vjb25kIG1vbWVudCBvZiBhcmVhKSBvZiB0aGUgYm9keS5cclxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgYW5kIGRlbnNpdHkgaW4gYEJvZHkuY3JlYXRlYC5cclxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5LmludmVyc2VJbmVydGlhYCBwcm9wZXJ0eSAoYDEgLyBpbmVydGlhYCkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgaW52ZXJzZSBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgYm9keSAoYDEgLyBpbmVydGlhYCkuXHJcbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbmVydGlhYCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZUluZXJ0aWFcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgcmVzdGl0dXRpb24gKGVsYXN0aWNpdHkpIG9mIHRoZSBib2R5LiBUaGUgdmFsdWUgaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYCgwLCAxKWAuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyBjb2xsaXNpb25zIG1heSBiZSBwZXJmZWN0bHkgaW5lbGFzdGljIGFuZCBubyBib3VuY2luZyBtYXkgb2NjdXIuIFxyXG4gICAgICogQSB2YWx1ZSBvZiBgMC44YCBtZWFucyB0aGUgYm9keSBtYXkgYm91bmNlIGJhY2sgd2l0aCBhcHByb3hpbWF0ZWx5IDgwJSBvZiBpdHMga2luZXRpYyBlbmVyZ3kuXHJcbiAgICAgKiBOb3RlIHRoYXQgY29sbGlzaW9uIHJlc3BvbnNlIGlzIGJhc2VkIG9uIF9wYWlyc18gb2YgYm9kaWVzLCBhbmQgdGhhdCBgcmVzdGl0dXRpb25gIHZhbHVlcyBhcmUgX2NvbWJpbmVkXyB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybXVsYTpcclxuICAgICAqXHJcbiAgICAgKiAgICAgTWF0aC5tYXgoYm9keUEucmVzdGl0dXRpb24sIGJvZHlCLnJlc3RpdHV0aW9uKVxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBmcmljdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZhbHVlIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGAoMCwgMSlgLlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgdGhhdCB0aGUgYm9keSBtYXkgc2xpZGUgaW5kZWZpbml0ZWx5LlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGJvZHkgbWF5IGNvbWUgdG8gYSBzdG9wIGFsbW9zdCBpbnN0YW50bHkgYWZ0ZXIgYSBmb3JjZSBpcyBhcHBsaWVkLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBlZmZlY3RzIG9mIHRoZSB2YWx1ZSBtYXkgYmUgbm9uLWxpbmVhci4gXHJcbiAgICAgKiBIaWdoIHZhbHVlcyBtYXkgYmUgdW5zdGFibGUgZGVwZW5kaW5nIG9uIHRoZSBib2R5LlxyXG4gICAgICogVGhlIGVuZ2luZSB1c2VzIGEgQ291bG9tYiBmcmljdGlvbiBtb2RlbCBpbmNsdWRpbmcgc3RhdGljIGFuZCBraW5ldGljIGZyaWN0aW9uLlxyXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYGZyaWN0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XHJcbiAgICAgKlxyXG4gICAgICogICAgIE1hdGgubWluKGJvZHlBLmZyaWN0aW9uLCBib2R5Qi5mcmljdGlvbilcclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25cclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBzdGF0aWMgZnJpY3Rpb24gb2YgdGhlIGJvZHkgKGluIHRoZSBDb3Vsb21iIGZyaWN0aW9uIG1vZGVsKS4gXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGUgYm9keSB3aWxsIG5ldmVyICdzdGljaycgd2hlbiBpdCBpcyBuZWFybHkgc3RhdGlvbmFyeSBhbmQgb25seSBkeW5hbWljIGBmcmljdGlvbmAgaXMgdXNlZC5cclxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlIChlLmcuIGAxMGApLCB0aGUgbW9yZSBmb3JjZSBpdCB3aWxsIHRha2UgdG8gaW5pdGlhbGx5IGdldCB0aGUgYm9keSBtb3Zpbmcgd2hlbiBuZWFybHkgc3RhdGlvbmFyeS5cclxuICAgICAqIFRoaXMgdmFsdWUgaXMgbXVsdGlwbGllZCB3aXRoIHRoZSBgZnJpY3Rpb25gIHByb3BlcnR5IHRvIG1ha2UgaXQgZWFzaWVyIHRvIGNoYW5nZSBgZnJpY3Rpb25gIGFuZCBtYWludGFpbiBhbiBhcHByb3ByaWF0ZSBhbW91bnQgb2Ygc3RhdGljIGZyaWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0YXRpY1xyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGFpciBmcmljdGlvbiBvZiB0aGUgYm9keSAoYWlyIHJlc2lzdGFuY2UpLiBcclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgc2xvdyBhcyBpdCBtb3ZlcyB0aHJvdWdoIHNwYWNlLlxyXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBmYXN0ZXIgYSBib2R5IHNsb3dzIHdoZW4gbW92aW5nIHRocm91Z2ggc3BhY2UuXHJcbiAgICAgKiBUaGUgZWZmZWN0cyBvZiB0aGUgdmFsdWUgYXJlIG5vbi1saW5lYXIuIFxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkFpclxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyaW5nIHByb3BlcnRpZXMgb2YgdGhpcyBib2R5LlxyXG4gICAgICpcclxuICAgICAqIENvbGxpc2lvbnMgYmV0d2VlbiB0d28gYm9kaWVzIHdpbGwgb2JleSB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4gICAgICogLSBJZiB0aGUgdHdvIGJvZGllcyBoYXZlIHRoZSBzYW1lIG5vbi16ZXJvIHZhbHVlIG9mIGBjb2xsaXNpb25GaWx0ZXIuZ3JvdXBgLFxyXG4gICAgICogICB0aGV5IHdpbGwgYWx3YXlzIGNvbGxpZGUgaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlLCBhbmQgdGhleSB3aWxsIG5ldmVyIGNvbGxpZGVcclxuICAgICAqICAgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogLSBJZiB0aGUgdHdvIGJvZGllcyBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgb2YgYGNvbGxpc2lvbkZpbHRlci5ncm91cGAgb3IgaWYgb25lXHJcbiAgICAgKiAgIChvciBib3RoKSBvZiB0aGUgYm9kaWVzIGhhcyBhIHZhbHVlIG9mIDAsIHRoZW4gdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMgYXBwbHkgYXMgZm9sbG93czpcclxuICAgICAqXHJcbiAgICAgKiBFYWNoIGJvZHkgYmVsb25ncyB0byBhIGNvbGxpc2lvbiBjYXRlZ29yeSwgZ2l2ZW4gYnkgYGNvbGxpc2lvbkZpbHRlci5jYXRlZ29yeWAuIFRoaXNcclxuICAgICAqIHZhbHVlIGlzIHVzZWQgYXMgYSBiaXQgZmllbGQgYW5kIHRoZSBjYXRlZ29yeSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBtZWFuaW5nIHRoYXRcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIGEgcG93ZXIgb2YgdHdvIGluIHRoZSByYW5nZSBbMSwgMl4zMV0uIFRodXMsIHRoZXJlIGFyZSAzMlxyXG4gICAgICogZGlmZmVyZW50IGNvbGxpc2lvbiBjYXRlZ29yaWVzIGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBFYWNoIGJvZHkgYWxzbyBkZWZpbmVzIGEgY29sbGlzaW9uIGJpdG1hc2ssIGdpdmVuIGJ5IGBjb2xsaXNpb25GaWx0ZXIubWFza2Agd2hpY2ggc3BlY2lmaWVzXHJcbiAgICAgKiB0aGUgY2F0ZWdvcmllcyBpdCBjb2xsaWRlcyB3aXRoICh0aGUgdmFsdWUgaXMgdGhlIGJpdHdpc2UgQU5EIHZhbHVlIG9mIGFsbCB0aGVzZSBjYXRlZ29yaWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBVc2luZyB0aGUgY2F0ZWdvcnkvbWFzayBydWxlcywgdHdvIGJvZGllcyBgQWAgYW5kIGBCYCBjb2xsaWRlIGlmIGVhY2ggaW5jbHVkZXMgdGhlIG90aGVyJ3NcclxuICAgICAqIGNhdGVnb3J5IGluIGl0cyBtYXNrLCBpLmUuIGAoY2F0ZWdvcnlBICYgbWFza0IpICE9PSAwYCBhbmQgYChjYXRlZ29yeUIgJiBtYXNrQSkgIT09IDBgXHJcbiAgICAgKiBhcmUgYm90aCB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXJcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJbnRlZ2VyIGBOdW1iZXJgLCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGdyb3VwIHRoaXMgYm9keSBiZWxvbmdzIHRvLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5ncm91cFxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYml0IGZpZWxkIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gY2F0ZWdvcnkgdGhpcyBib2R5IGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBUaGUgY2F0ZWdvcnkgdmFsdWUgc2hvdWxkIGhhdmUgb25seSBvbmUgYml0IHNldCwgZm9yIGV4YW1wbGUgYDB4MDAwMWAuXHJcbiAgICAgKiBUaGlzIG1lYW5zIHRoZXJlIGFyZSB1cCB0byAzMiB1bmlxdWUgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5jYXRlZ29yeVxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYml0IG1hc2sgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBjYXRlZ29yaWVzIHRoaXMgYm9keSBtYXkgY29sbGlkZSB3aXRoLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5tYXNrXHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqIEBkZWZhdWx0IC0xXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgYSB0b2xlcmFuY2Ugb24gaG93IGZhciBhIGJvZHkgaXMgYWxsb3dlZCB0byAnc2luaycgb3Igcm90YXRlIGludG8gb3RoZXIgYm9kaWVzLlxyXG4gICAgICogQXZvaWQgY2hhbmdpbmcgdGhpcyB2YWx1ZSB1bmxlc3MgeW91IHVuZGVyc3RhbmQgdGhlIHB1cnBvc2Ugb2YgYHNsb3BgIGluIHBoeXNpY3MgZW5naW5lcy5cclxuICAgICAqIFRoZSBkZWZhdWx0IHNob3VsZCBnZW5lcmFsbHkgc3VmZmljZSwgYWx0aG91Z2ggdmVyeSBsYXJnZSBib2RpZXMgbWF5IHJlcXVpcmUgbGFyZ2VyIHZhbHVlcyBmb3Igc3RhYmxlIHN0YWNraW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBzbG9wXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDAuMDVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGFsbG93cyBwZXItYm9keSB0aW1lIHNjYWxpbmcsIGUuZy4gYSBmb3JjZS1maWVsZCB3aGVyZSBib2RpZXMgaW5zaWRlIGFyZSBpbiBzbG93LW1vdGlvbiwgd2hpbGUgb3RoZXJzIGFyZSBhdCBmdWxsIHNwZWVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB0aW1lU2NhbGVcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGJvZHkgc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIHJlbmRlcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLm9wYWNpdHlcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgZGVmaW5lcyB0aGUgc3ByaXRlIHByb3BlcnRpZXMgdG8gdXNlIHdoZW4gcmVuZGVyaW5nLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGVcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgc3ByaXRlIHRleHR1cmUsIGlmIGFueS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZS50ZXh0dXJlXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgc2NhbGluZyBpbiB0aGUgeC1heGlzIGZvciB0aGUgc3ByaXRlLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueFNjYWxlXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnlTY2FsZVxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgeC1heGlzIGZvciB0aGUgc3ByaXRlIChub3JtYWxpc2VkIGJ5IHRleHR1cmUgd2lkdGgpLlxyXG4gICAgICAqXHJcbiAgICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueE9mZnNldFxyXG4gICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgeS1heGlzIGZvciB0aGUgc3ByaXRlIChub3JtYWxpc2VkIGJ5IHRleHR1cmUgaGVpZ2h0KS5cclxuICAgICAgKlxyXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnlPZmZzZXRcclxuICAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbGluZSB3aWR0aCB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgbm8gb3V0bGluZSB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIubGluZVdpZHRoXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDEuNVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgKGlmIGEgc3ByaXRlIGlzIG5vdCBkZWZpbmVkKS5cclxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmZpbGxTdHlsZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxyXG4gICAgICogSXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB1c2luZyBhIGNhbnZhcywgc28gaXQgYWNjZXB0cyBDU1Mgc3R5bGUgcHJvcGVydHkgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3Ryb2tlU3R5bGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgYSByYW5kb20gY29sb3VyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHVuaXF1ZSBheGlzIHZlY3RvcnMgKGVkZ2Ugbm9ybWFscykgdXNlZCBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cclxuICAgICAqIFRoZXNlIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSB0aGUgZ2l2ZW4gY29udmV4IGh1bGwgKGB2ZXJ0aWNlc2AgYXJyYXkpIGluIGBCb2R5LmNyZWF0ZWAuXHJcbiAgICAgKiBUaGV5IGFyZSBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgdGhlIHNpbXVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGF4ZXNcclxuICAgICAqIEB0eXBlIHZlY3RvcltdXHJcbiAgICAgKi9cclxuICAgICBcclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IF9tZWFzdXJlc18gdGhlIGFyZWEgb2YgdGhlIGJvZHkncyBjb252ZXggaHVsbCwgY2FsY3VsYXRlZCBhdCBjcmVhdGlvbiBieSBgQm9keS5jcmVhdGVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBhcmVhXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEBkZWZhdWx0IFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIEFBQkIgcmVnaW9uIGZvciB0aGUgYm9keS5cclxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgaW4gYEJvZHkuY3JlYXRlYCBhbmQgY29uc3RhbnRseSB1cGRhdGVkIGJ5IGBCb2R5LnVwZGF0ZWAgZHVyaW5nIHNpbXVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xyXG4gICAgICogQHR5cGUgYm91bmRzXHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5Db25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb25zdHJhaW50cy5cclxuKiBDb25zdHJhaW50cyBhcmUgdXNlZCBmb3Igc3BlY2lmeWluZyB0aGF0IGEgZml4ZWQgZGlzdGFuY2UgbXVzdCBiZSBtYWludGFpbmVkIGJldHdlZW4gdHdvIGJvZGllcyAob3IgYSBib2R5IGFuZCBhIGZpeGVkIHdvcmxkLXNwYWNlIHBvc2l0aW9uKS5cclxuKiBUaGUgc3RpZmZuZXNzIG9mIGNvbnN0cmFpbnRzIGNhbiBiZSBtb2RpZmllZCB0byBjcmVhdGUgc3ByaW5ncyBvciBlbGFzdGljLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBDb25zdHJhaW50XHJcbiovXHJcblxyXG4vLyBUT0RPOiBmaXggaW5zdGFiaWxpdHkgaXNzdWVzIHdpdGggdG9ycXVlXHJcbi8vIFRPRE86IGxpbmtlZCBjb25zdHJhaW50c1xyXG4vLyBUT0RPOiBicmVha2FibGUgY29uc3RyYWludHNcclxuLy8gVE9ETzogY29sbGlzaW9uIGNvbnN0cmFpbnRzXHJcbi8vIFRPRE86IGFsbG93IGNvbnN0cmFpbmVkIGJvZGllcyB0byBzbGVlcFxyXG4vLyBUT0RPOiBoYW5kbGUgMCBsZW5ndGggY29uc3RyYWludHMgcHJvcGVybHlcclxuLy8gVE9ETzogaW1wdWxzZSBjYWNoaW5nIGFuZCB3YXJtaW5nXHJcblxyXG52YXIgQ29uc3RyYWludCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgU2xlZXBpbmcgPSByZXF1aXJlKCcuLi9jb3JlL1NsZWVwaW5nJyk7XHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9BeGVzJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBfbWluTGVuZ3RoID0gMC4wMDAwMDEsXHJcbiAgICAgICAgX21pbkRpZmZlcmVuY2UgPSAwLjAwMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uc3RyYWludC5cclxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50fSBjb25zdHJhaW50XHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gb3B0aW9ucztcclxuXHJcbiAgICAgICAgLy8gaWYgYm9kaWVzIGRlZmluZWQgYnV0IG5vIHBvaW50cywgdXNlIGJvZHkgY2VudHJlXHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUEgJiYgIWNvbnN0cmFpbnQucG9pbnRBKVxyXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50LmJvZHlCICYmICFjb25zdHJhaW50LnBvaW50QilcclxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHN0YXRpYyBsZW5ndGggdXNpbmcgaW5pdGlhbCB3b3JsZCBzcGFjZSBwb2ludHNcclxuICAgICAgICB2YXIgaW5pdGlhbFBvaW50QSA9IGNvbnN0cmFpbnQuYm9keUEgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKSA6IGNvbnN0cmFpbnQucG9pbnRBLFxyXG4gICAgICAgICAgICBpbml0aWFsUG9pbnRCID0gY29uc3RyYWludC5ib2R5QiA/IFZlY3Rvci5hZGQoY29uc3RyYWludC5ib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpIDogY29uc3RyYWludC5wb2ludEIsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1Yihpbml0aWFsUG9pbnRBLCBpbml0aWFsUG9pbnRCKSk7XHJcbiAgICBcclxuICAgICAgICBjb25zdHJhaW50Lmxlbmd0aCA9IGNvbnN0cmFpbnQubGVuZ3RoIHx8IGxlbmd0aCB8fCBfbWluTGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICB2YXIgcmVuZGVyID0ge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZidcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0cmFpbnQucmVuZGVyID0gQ29tbW9uLmV4dGVuZChyZW5kZXIsIGNvbnN0cmFpbnQucmVuZGVyKTtcclxuXHJcbiAgICAgICAgLy8gb3B0aW9uIGRlZmF1bHRzXHJcbiAgICAgICAgY29uc3RyYWludC5pZCA9IGNvbnN0cmFpbnQuaWQgfHwgQ29tbW9uLm5leHRJZCgpO1xyXG4gICAgICAgIGNvbnN0cmFpbnQubGFiZWwgPSBjb25zdHJhaW50LmxhYmVsIHx8ICdDb25zdHJhaW50JztcclxuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSAnY29uc3RyYWludCc7XHJcbiAgICAgICAgY29uc3RyYWludC5zdGlmZm5lc3MgPSBjb25zdHJhaW50LnN0aWZmbmVzcyB8fCAxO1xyXG4gICAgICAgIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyA9IGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyB8fCAwO1xyXG4gICAgICAgIGNvbnN0cmFpbnQuYW5nbGVBID0gY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEuYW5nbGUgOiBjb25zdHJhaW50LmFuZ2xlQTtcclxuICAgICAgICBjb25zdHJhaW50LmFuZ2xlQiA9IGNvbnN0cmFpbnQuYm9keUIgPyBjb25zdHJhaW50LmJvZHlCLmFuZ2xlIDogY29uc3RyYWludC5hbmdsZUI7XHJcbiAgICAgICAgY29uc3RyYWludC5wbHVnaW4gPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29sdmVzIGFsbCBjb25zdHJhaW50cyBpbiBhIGxpc3Qgb2YgY29sbGlzaW9ucy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHNvbHZlQWxsXHJcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnRbXX0gY29uc3RyYWludHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgQ29uc3RyYWludC5zb2x2ZUFsbCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmUoY29uc3RyYWludHNbaV0sIHRpbWVTY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvbHZlcyBhIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2Qgc29sdmVcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnNvbHZlID0gZnVuY3Rpb24oY29uc3RyYWludCwgdGltZVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxyXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcclxuICAgICAgICAgICAgcG9pbnRCID0gY29uc3RyYWludC5wb2ludEI7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSByZWZlcmVuY2UgYW5nbGVcclxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gVmVjdG9yLnJvdGF0ZShwb2ludEEsIGJvZHlBLmFuZ2xlIC0gY29uc3RyYWludC5hbmdsZUEpO1xyXG4gICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQSA9IGJvZHlBLmFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyB1cGRhdGUgcmVmZXJlbmNlIGFuZ2xlXHJcbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IFZlY3Rvci5yb3RhdGUocG9pbnRCLCBib2R5Qi5hbmdsZSAtIGNvbnN0cmFpbnQuYW5nbGVCKTtcclxuICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5Qi5hbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwb2ludEFXb3JsZCA9IHBvaW50QSxcclxuICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBwb2ludEI7XHJcblxyXG4gICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBwb2ludEEpO1xyXG4gICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBwb2ludEIpO1xyXG5cclxuICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvaW50QVdvcmxkLCBwb2ludEJXb3JsZCksXHJcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBWZWN0b3IubWFnbml0dWRlKGRlbHRhKTtcclxuXHJcbiAgICAgICAgLy8gcHJldmVudCBzaW5ndWxhcml0eVxyXG4gICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gX21pbkxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gc29sdmUgZGlzdGFuY2UgY29uc3RyYWludCB3aXRoIEdhdXNzLVNpZWRlbCBtZXRob2RcclxuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IChjdXJyZW50TGVuZ3RoIC0gY29uc3RyYWludC5sZW5ndGgpIC8gY3VycmVudExlbmd0aCxcclxuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLmRpdihkZWx0YSwgY3VycmVudExlbmd0aCksXHJcbiAgICAgICAgICAgIGZvcmNlID0gVmVjdG9yLm11bHQoZGVsdGEsIGRpZmZlcmVuY2UgKiAwLjUgKiBjb25zdHJhaW50LnN0aWZmbmVzcyAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gaWYgZGlmZmVyZW5jZSBpcyB2ZXJ5IHNtYWxsLCB3ZSBjYW4gc2tpcFxyXG4gICAgICAgIGlmIChNYXRoLmFicygxIC0gKGN1cnJlbnRMZW5ndGggLyBjb25zdHJhaW50Lmxlbmd0aCkpIDwgX21pbkRpZmZlcmVuY2UgKiB0aW1lU2NhbGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHZlbG9jaXR5UG9pbnRBLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eVBvaW50QixcclxuICAgICAgICAgICAgb2Zmc2V0QSxcclxuICAgICAgICAgICAgb2Zmc2V0QixcclxuICAgICAgICAgICAgb0FuLFxyXG4gICAgICAgICAgICBvQm4sXHJcbiAgICAgICAgICAgIGJvZHlBRGVub20sXHJcbiAgICAgICAgICAgIGJvZHlCRGVub207XHJcbiAgICBcclxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIC8vIHBvaW50IGJvZHkgb2Zmc2V0XHJcbiAgICAgICAgICAgIG9mZnNldEEgPSB7IFxyXG4gICAgICAgICAgICAgICAgeDogcG9pbnRBV29ybGQueCAtIGJvZHlBLnBvc2l0aW9uLnggKyBmb3JjZS54LCBcclxuICAgICAgICAgICAgICAgIHk6IHBvaW50QVdvcmxkLnkgLSBib2R5QS5wb3NpdGlvbi55ICsgZm9yY2UueVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlBLmFuZ2xlIC0gYm9keUEuYW5nbGVQcmV2O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gZmluZCBwb2ludCB2ZWxvY2l0eSBhbmQgYm9keSBtYXNzXHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRBID0gVmVjdG9yLmFkZChib2R5QS52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QSksIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSkpO1xyXG4gICAgICAgICAgICBvQW4gPSBWZWN0b3IuZG90KG9mZnNldEEsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGJvZHlBRGVub20gPSBib2R5QS5pbnZlcnNlTWFzcyArIGJvZHlBLmludmVyc2VJbmVydGlhICogb0FuICogb0FuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRBID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGJvZHlBRGVub20gPSBib2R5QSA/IGJvZHlBLmludmVyc2VNYXNzIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgLy8gcG9pbnQgYm9keSBvZmZzZXRcclxuICAgICAgICAgICAgb2Zmc2V0QiA9IHsgXHJcbiAgICAgICAgICAgICAgICB4OiBwb2ludEJXb3JsZC54IC0gYm9keUIucG9zaXRpb24ueCAtIGZvcmNlLngsIFxyXG4gICAgICAgICAgICAgICAgeTogcG9pbnRCV29ybGQueSAtIGJvZHlCLnBvc2l0aW9uLnkgLSBmb3JjZS55IFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUIucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnkgPSBib2R5Qi5wb3NpdGlvbi55IC0gYm9keUIucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlCLmFuZ2xlIC0gYm9keUIuYW5nbGVQcmV2O1xyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBwb2ludCB2ZWxvY2l0eSBhbmQgYm9keSBtYXNzXHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0gVmVjdG9yLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QiksIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSkpO1xyXG4gICAgICAgICAgICBvQm4gPSBWZWN0b3IuZG90KG9mZnNldEIsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGJvZHlCRGVub20gPSBib2R5Qi5pbnZlcnNlTWFzcyArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JuICogb0JuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGJvZHlCRGVub20gPSBib2R5QiA/IGJvZHlCLmludmVyc2VNYXNzIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKHZlbG9jaXR5UG9pbnRCLCB2ZWxvY2l0eVBvaW50QSksXHJcbiAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgPSBWZWN0b3IuZG90KG5vcm1hbCwgcmVsYXRpdmVWZWxvY2l0eSkgLyAoYm9keUFEZW5vbSArIGJvZHlCRGVub20pO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKG5vcm1hbEltcHVsc2UgPiAwKSBub3JtYWxJbXB1bHNlID0gMDtcclxuICAgIFxyXG4gICAgICAgIHZhciBub3JtYWxWZWxvY2l0eSA9IHtcclxuICAgICAgICAgICAgeDogbm9ybWFsLnggKiBub3JtYWxJbXB1bHNlLCBcclxuICAgICAgICAgICAgeTogbm9ybWFsLnkgKiBub3JtYWxJbXB1bHNlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRvcnF1ZTtcclxuIFxyXG4gICAgICAgIGlmIChib2R5QSAmJiAhYm9keUEuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgdG9ycXVlID0gVmVjdG9yLmNyb3NzKG9mZnNldEEsIG5vcm1hbFZlbG9jaXR5KSAqIGJvZHlBLmludmVyc2VJbmVydGlhICogKDEgLSBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhcHBsaWVkIGltcHVsc2VzIGZvciBwb3N0IHNvbHZpbmdcclxuICAgICAgICAgICAgYm9keUEuY29uc3RyYWludEltcHVsc2UueCAtPSBmb3JjZS54O1xyXG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS55IC09IGZvcmNlLnk7XHJcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlICs9IHRvcnF1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IGZvcmNlc1xyXG4gICAgICAgICAgICBib2R5QS5wb3NpdGlvbi54IC09IGZvcmNlLng7XHJcbiAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uLnkgLT0gZm9yY2UueTtcclxuICAgICAgICAgICAgYm9keUEuYW5nbGUgKz0gdG9ycXVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICB0b3JxdWUgPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0Qiwgbm9ybWFsVmVsb2NpdHkpICogYm9keUIuaW52ZXJzZUluZXJ0aWEgKiAoMSAtIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFwcGxpZWQgaW1wdWxzZXMgZm9yIHBvc3Qgc29sdmluZ1xyXG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS54ICs9IGZvcmNlLng7XHJcbiAgICAgICAgICAgIGJvZHlCLmNvbnN0cmFpbnRJbXB1bHNlLnkgKz0gZm9yY2UueTtcclxuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UuYW5nbGUgLT0gdG9ycXVlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gYXBwbHkgZm9yY2VzXHJcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnggKz0gZm9yY2UueDtcclxuICAgICAgICAgICAgYm9keUIucG9zaXRpb24ueSArPSBmb3JjZS55O1xyXG4gICAgICAgICAgICBib2R5Qi5hbmdsZSAtPSB0b3JxdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBib2R5IHVwZGF0ZXMgcmVxdWlyZWQgYWZ0ZXIgc29sdmluZyBjb25zdHJhaW50cy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIHBvc3RTb2x2ZUFsbFxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbCA9IGZ1bmN0aW9uKGJvZGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IGJvZHkuY29uc3RyYWludEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1wdWxzZS54ID09PSAwICYmIGltcHVsc2UueSA9PT0gMCAmJiBpbXB1bHNlLmFuZ2xlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeSBhbmQgcmVzZXRcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBpbXB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gaW1wdWxzZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBpbXB1bHNlLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGltcHVsc2UuYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBpbXB1bHNlLmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGltcHVsc2UuYW5nbGUsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW1wdWxzZS5hbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIGltcHVsc2UueCA9IDA7XHJcbiAgICAgICAgICAgIGltcHVsc2UueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBDb21wb3NpdGUuY3JlYXRlYCBieSBgQ29tbW9uLm5leHRJZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBsYWJlbFxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBcIkNvbnN0cmFpbnRcIlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbGluZSB3aWR0aCB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGNvbnN0cmFpbnQgb3V0bGluZS5cclxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmxpbmVXaWR0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBjb25zdHJhaW50IG91dGxpbmUuXHJcbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zdHJva2VTdHlsZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpcnN0IHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcclxuICAgICAqIEB0eXBlIGJvZHlcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlY29uZCBwb3NzaWJsZSBgQm9keWAgdGhhdCB0aGlzIGNvbnN0cmFpbnQgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvZHlCXHJcbiAgICAgKiBAdHlwZSBib2R5XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgY29uc3RyYWludCBmcm9tIGNlbnRlciBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGlmIGRlZmluZWQsIG90aGVyd2lzZSBhIHdvcmxkLXNwYWNlIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwb2ludEFcclxuICAgICAqIEB0eXBlIHZlY3RvclxyXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBjb25zdHJhaW50IGZyb20gY2VudGVyIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QWAgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGEgd29ybGQtc3BhY2UgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBvaW50QlxyXG4gICAgICogQHR5cGUgdmVjdG9yXHJcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBzdGlmZm5lc3Mgb2YgdGhlIGNvbnN0cmFpbnQsIGkuZS4gdGhlIHJhdGUgYXQgd2hpY2ggaXQgcmV0dXJucyB0byBpdHMgcmVzdGluZyBgY29uc3RyYWludC5sZW5ndGhgLlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHZlcnkgc3RpZmYuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwLjJgIG1lYW5zIHRoZSBjb25zdHJhaW50IGFjdHMgbGlrZSBhIHNvZnQgc3ByaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0YXJnZXQgcmVzdGluZyBsZW5ndGggb2YgdGhlIGNvbnN0cmFpbnQuIFxyXG4gICAgICogSXQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGluIGBDb25zdHJhaW50LmNyZWF0ZWAgZnJvbSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGFuZCBgY29uc3RyYWludC5ib2R5QmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGxlbmd0aFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXHJcbiAgICAgKiBAdHlwZSB7fVxyXG4gICAgICovXHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvQ29uc3RyYWludC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIHRvIG1hbmFnZSB0aGUgc2xlZXBpbmcgc3RhdGUgb2YgYm9kaWVzLlxyXG4qXHJcbiogQGNsYXNzIFNsZWVwaW5nXHJcbiovXHJcblxyXG52YXIgU2xlZXBpbmcgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2xlZXBpbmc7XHJcblxyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi9FdmVudHMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICBTbGVlcGluZy5fbW90aW9uV2FrZVRocmVzaG9sZCA9IDAuMTg7XHJcbiAgICBTbGVlcGluZy5fbW90aW9uU2xlZXBUaHJlc2hvbGQgPSAwLjA4O1xyXG4gICAgU2xlZXBpbmcuX21pbkJpYXMgPSAwLjk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXRzIGJvZGllcyB0byBzbGVlcCBvciB3YWtlcyB0aGVtIHVwIGRlcGVuZGluZyBvbiB0aGVpciBtb3Rpb24uXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBTbGVlcGluZy51cGRhdGUgPSBmdW5jdGlvbihib2RpZXMsIHRpbWVTY2FsZSkge1xyXG4gICAgICAgIHZhciB0aW1lRmFjdG9yID0gdGltZVNjYWxlICogdGltZVNjYWxlICogdGltZVNjYWxlO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgYm9kaWVzIHNsZWVwaW5nIHN0YXR1c1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgbW90aW9uID0gYm9keS5zcGVlZCAqIGJvZHkuc3BlZWQgKyBib2R5LmFuZ3VsYXJTcGVlZCAqIGJvZHkuYW5ndWxhclNwZWVkO1xyXG5cclxuICAgICAgICAgICAgLy8gd2FrZSB1cCBib2RpZXMgaWYgdGhleSBoYXZlIGEgZm9yY2UgYXBwbGllZFxyXG4gICAgICAgICAgICBpZiAoYm9keS5mb3JjZS54ICE9PSAwIHx8IGJvZHkuZm9yY2UueSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWluTW90aW9uID0gTWF0aC5taW4oYm9keS5tb3Rpb24sIG1vdGlvbiksXHJcbiAgICAgICAgICAgICAgICBtYXhNb3Rpb24gPSBNYXRoLm1heChib2R5Lm1vdGlvbiwgbW90aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gYmlhc2VkIGF2ZXJhZ2UgbW90aW9uIGVzdGltYXRpb24gYmV0d2VlbiBmcmFtZXNcclxuICAgICAgICAgICAgYm9keS5tb3Rpb24gPSBTbGVlcGluZy5fbWluQmlhcyAqIG1pbk1vdGlvbiArICgxIC0gU2xlZXBpbmcuX21pbkJpYXMpICogbWF4TW90aW9uO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGJvZHkuc2xlZXBUaHJlc2hvbGQgPiAwICYmIGJvZHkubW90aW9uIDwgU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkICogdGltZUZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgKz0gMTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuc2xlZXBDb3VudGVyID49IGJvZHkuc2xlZXBUaHJlc2hvbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvZHkuc2xlZXBDb3VudGVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBjb2xsaWRpbmcgcGFpcnMsIHdha2VzIHRoZSBzbGVlcGluZyBib2RpZXMgaW52b2x2ZWQuXHJcbiAgICAgKiBAbWV0aG9kIGFmdGVyQ29sbGlzaW9uc1xyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXHJcbiAgICAgKi9cclxuICAgIFNsZWVwaW5nLmFmdGVyQ29sbGlzaW9ucyA9IGZ1bmN0aW9uKHBhaXJzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICB2YXIgdGltZUZhY3RvciA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgLy8gd2FrZSB1cCBib2RpZXMgaW52b2x2ZWQgaW4gY29sbGlzaW9uc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGRvbid0IHdha2UgaW5hY3RpdmUgcGFpcnNcclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QS5wYXJlbnQsIFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUIucGFyZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBkb24ndCB3YWtlIGlmIGF0IGxlYXN0IG9uZSBib2R5IGlzIHN0YXRpY1xyXG4gICAgICAgICAgICBpZiAoKGJvZHlBLmlzU2xlZXBpbmcgJiYgYm9keUIuaXNTbGVlcGluZykgfHwgYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU2xlZXBpbmcgfHwgYm9keUIuaXNTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsZWVwaW5nQm9keSA9IChib2R5QS5pc1NsZWVwaW5nICYmICFib2R5QS5pc1N0YXRpYykgPyBib2R5QSA6IGJvZHlCLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmluZ0JvZHkgPSBzbGVlcGluZ0JvZHkgPT09IGJvZHlBID8gYm9keUIgOiBib2R5QTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNsZWVwaW5nQm9keS5pc1N0YXRpYyAmJiBtb3ZpbmdCb2R5Lm1vdGlvbiA+IFNsZWVwaW5nLl9tb3Rpb25XYWtlVGhyZXNob2xkICogdGltZUZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChzbGVlcGluZ0JvZHksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGJvZHkgYXMgc2xlZXBpbmcgb3IgYXdha2UuXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2xlZXBpbmdcclxuICAgICAqL1xyXG4gICAgU2xlZXBpbmcuc2V0ID0gZnVuY3Rpb24oYm9keSwgaXNTbGVlcGluZykge1xyXG4gICAgICAgIHZhciB3YXNTbGVlcGluZyA9IGJvZHkuaXNTbGVlcGluZztcclxuXHJcbiAgICAgICAgaWYgKGlzU2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgYm9keS5pc1NsZWVwaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgPSBib2R5LnNsZWVwVGhyZXNob2xkO1xyXG5cclxuICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCA9IDA7XHJcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnkgPSAwO1xyXG5cclxuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueTtcclxuXHJcbiAgICAgICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZTtcclxuICAgICAgICAgICAgYm9keS5zcGVlZCA9IDA7XHJcbiAgICAgICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gMDtcclxuICAgICAgICAgICAgYm9keS5tb3Rpb24gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF3YXNTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoYm9keSwgJ3NsZWVwU3RhcnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvZHkuaXNTbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAod2FzU2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGJvZHksICdzbGVlcEVuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9TbGVlcGluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB2ZXJ0OiBbXHJcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhfY29vcmQ7JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzMgYV9jb2xvcjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbHBoYTsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWMzIHZfY29sb3I7JyxcclxuICAgICAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB1X3ZpZXdfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjAsIDEuMCk7JyxcclxuICAgICAgICAnICAgdl90ZXhfY29vcmQgPSBhX3RleF9jb29yZDsnLFxyXG4gICAgICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICcgICB2X2FscGhhID0gYV9hbHBoYTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKSxcclxuICAgIGZyYWc6IFtcclxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxyXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfc2FtcGxlcjJELCB2X3RleF9jb29yZCkgKiB2ZWM0KHZfY29sb3IsIHZfYWxwaGEpOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBNZXNoUmVuZGVyID0gcmVxdWlyZSgnLi9NZXNoUmVuZGVyJyk7XHJcblxyXG52YXIgTWVzaCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBNZXNoUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gTWVzaCAoc3RhdGUsIHgsIHksIHZlcnRpY2VzLCB1diwgaW5kaWNlcywgY29sb3JzLCBhbHBoYXMsIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ01lc2gnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZVRvRnJhbWUoKTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xyXG5cclxuICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoICE9PSB1di5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BoYXNlcjogVmVydGV4IGNvdW50IG11c3QgbWF0Y2ggVVYgY291bnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID4gMCAmJiBjb2xvcnMubGVuZ3RoIDwgKHZlcnRpY2VzLmxlbmd0aCAvIDIpfDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BoYXNlcjogQ29sb3IgY291bnQgbXVzdCBtYXRjaCBWZXJ0ZXggY291bnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbHBoYXMubGVuZ3RoID4gMCAmJiBhbHBoYXMubGVuZ3RoIDwgKHZlcnRpY2VzLmxlbmd0aCAvIDIpfDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BoYXNlcjogQWxwaGEgY291bnQgbXVzdCBtYXRjaCBWZXJ0ZXggY291bnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAodmVydGljZXMubGVuZ3RoIC8gMil8MDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSAweEZGRkZGRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFscGhhcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgKHZlcnRpY2VzLmxlbmd0aCAvIDIpfDA7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWxwaGFzW2ldID0gMS4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgdGhpcy51diA9IG5ldyBGbG9hdDMyQXJyYXkodXYpO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzKTtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBVaW50MzJBcnJheShjb2xvcnMpO1xyXG4gICAgICAgIHRoaXMuYWxwaGFzID0gbmV3IEZsb2F0MzJBcnJheShhbHBoYXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbWVzaC9NZXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgU3ByaXRlUmVuZGVyID0gcmVxdWlyZSgnLi9TcHJpdGVSZW5kZXInKTtcclxuXHJcbnZhciBTcHJpdGUgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgU3ByaXRlUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gU3ByaXRlIChzdGF0ZSwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlLCAnU3ByaXRlJyk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbXMgPSBuZXcgQ29tcG9uZW50cy5BbmltYXRpb24odGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldFNpemVUb0ZyYW1lKCk7XHJcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oKTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJlVXBkYXRlOiBmdW5jdGlvbiAodGltZXN0YW1wLCBmcmFtZURlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYW5pbXMudXBkYXRlKHRpbWVzdGFtcCwgZnJhbWVEZWx0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYXk6IGZ1bmN0aW9uIChrZXksIHN0YXJ0RnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbXMucGxheShrZXksIHN0YXJ0RnJhbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBDb21wb25lbnRzLlRvSlNPTih0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gIEV4dHJhIFNwcml0ZSBkYXRhIGlzIGFkZGVkIGhlcmVcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXHJcbntcclxuICAgIC8vICBDaGVjayBpZiB4L3kgYXJlIHdpdGhpbiB0aGUgYm91bmRzIGZpcnN0XHJcbiAgICBpZiAoY2lyY2xlLnJhZGl1cyA+IDAgJiYgeCA+PSBjaXJjbGUubGVmdCAmJiB4IDw9IGNpcmNsZS5yaWdodCAmJiB5ID49IGNpcmNsZS50b3AgJiYgeSA8PSBjaXJjbGUuYm90dG9tKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkeCA9IChjaXJjbGUueCAtIHgpICogKGNpcmNsZS54IC0geCk7XHJcbiAgICAgICAgdmFyIGR5ID0gKGNpcmNsZS55IC0geSkgKiAoY2lyY2xlLnkgLSB5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChkeCArIGR5KSA8PSAoY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGJhc2VkIG9mZiBhbiBleHBsYW5hdGlvbiBhbmQgZXhwYW5kZWQgbWF0aCBwcmVzZW50ZWQgYnkgUGF1bCBCb3Vya2U6XHJcbi8vICBTZWUgaHR0cDonbG9jYWwud2FzcC51d2EuZWR1LmF1L35wYm91cmtlL2dlb21ldHJ5L2xpbmVsaW5lMmQvXHJcblxyXG52YXIgTGluZVRvTGluZSA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgdmFyIHgxID0gbGluZTEueDE7XHJcbiAgICB2YXIgeTEgPSBsaW5lMS55MTtcclxuICAgIHZhciB4MiA9IGxpbmUxLngyO1xyXG4gICAgdmFyIHkyID0gbGluZTEueTI7XHJcblxyXG4gICAgdmFyIHgzID0gbGluZTIueDE7XHJcbiAgICB2YXIgeTMgPSBsaW5lMi55MTtcclxuICAgIHZhciB4NCA9IGxpbmUyLngyO1xyXG4gICAgdmFyIHk0ID0gbGluZTIueTI7XHJcblxyXG4gICAgdmFyIG51bUEgPSAoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4Myk7XHJcbiAgICB2YXIgbnVtQiA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcclxuICAgIHZhciBkZU5vbSA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcclxuXHJcbiAgICAvLyAgTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhIGRpdmlzaW9uIGJ5IHplcm8gLSB0aGlzIGFsc28gaW5kaWNhdGVzIHRoYXQgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbC5cclxuICAgIC8vICBJZiBudW1BIGFuZCBudW1CIHdlcmUgYm90aCBlcXVhbCB0byB6ZXJvIHRoZSBsaW5lcyB3b3VsZCBiZSBvbiB0b3Agb2YgZWFjaCBvdGhlciAoY29pbmNpZGVudGFsKS5cclxuICAgIC8vICBUaGlzIGNoZWNrIGlzIG5vdCBkb25lIGJlY2F1c2UgaXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhpcyBpbXBsZW1lbnRhdGlvbiAodGhlIHBhcmFsbGVsIGNoZWNrIGFjY291bnRzIGZvciB0aGlzKS5cclxuXHJcbiAgICBpZiAoZGVOb20gPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBDYWxjdWxhdGUgdGhlIGludGVybWVkaWF0ZSBmcmFjdGlvbmFsIHBvaW50IHRoYXQgdGhlIGxpbmVzIHBvdGVudGlhbGx5IGludGVyc2VjdC5cclxuXHJcbiAgICB2YXIgdUEgPSBudW1BIC8gZGVOb207XHJcbiAgICB2YXIgdUIgPSBudW1CIC8gZGVOb207XHJcblxyXG4gICAgLy8gIFRoZSBmcmFjdGlvbmFsIHBvaW50IHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZSBpZiB0aGUgbGluZXMgaW50ZXJzZWN0LlxyXG4gICAgLy8gIElmIHRoZSBmcmFjdGlvbmFsIGNhbGN1bGF0aW9uIGlzIGxhcmdlciB0aGFuIDEgb3Igc21hbGxlciB0aGFuIDAgdGhlIGxpbmVzIHdvdWxkIG5lZWQgdG8gYmUgbG9uZ2VyIHRvIGludGVyc2VjdC5cclxuXHJcbiAgICBpZiAodUEgPj0gMCAmJiB1QSA8PSAxICYmIHVCID49IDAgJiYgdUIgPD0gMSlcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IHgxICsgKHVBICogKHgyIC0geDEpKTtcclxuICAgICAgICBvdXQueSA9IHkxICsgKHVBICogKHkyIC0geTEpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9MaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L1xyXG5cclxudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5KVxyXG57XHJcbiAgICB2YXIgdjB4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2MHkgPSB0cmlhbmdsZS55MyAtIHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIHZhciB2MXggPSB0cmlhbmdsZS54MiAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHYxeSA9IHRyaWFuZ2xlLnkyIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHYyeCA9IHggLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2MnkgPSB5IC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIGRvdDAwID0gKHYweCAqIHYweCkgKyAodjB5ICogdjB5KTtcclxuICAgIHZhciBkb3QwMSA9ICh2MHggKiB2MXgpICsgKHYweSAqIHYxeSk7XHJcbiAgICB2YXIgZG90MDIgPSAodjB4ICogdjJ4KSArICh2MHkgKiB2MnkpO1xyXG4gICAgdmFyIGRvdDExID0gKHYxeCAqIHYxeCkgKyAodjF5ICogdjF5KTtcclxuICAgIHZhciBkb3QxMiA9ICh2MXggKiB2MngpICsgKHYxeSAqIHYyeSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xyXG4gICAgdmFyIGIgPSAoKGRvdDAwICogZG90MTEpIC0gKGRvdDAxICogZG90MDEpKTtcclxuICAgIHZhciBpbnYgPSAoYiA9PT0gMCkgPyAwIDogKDEgLyBiKTtcclxuICAgIHZhciB1ID0gKChkb3QxMSAqIGRvdDAyKSAtIChkb3QwMSAqIGRvdDEyKSkgKiBpbnY7XHJcbiAgICB2YXIgdiA9ICgoZG90MDAgKiBkb3QxMikgLSAoZG90MDEgKiBkb3QwMikpICogaW52O1xyXG5cclxuICAgIHJldHVybiAodSA+PSAwICYmIHYgPj0gMCAmJiAodSArIHYgPCAxKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEZvcmNlIGEgdmFsdWUgd2l0aGluIHRoZSBib3VuZGFyaWVzIGJ5IGNsYW1waW5nIGl0IHRvIHRoZSByYW5nZSBgbWluYCwgYG1heGAuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI2NsYW1wXHJcbiogQHBhcmFtIHtmbG9hdH0gdiAtIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkLlxyXG4qIEBwYXJhbSB7ZmxvYXR9IG1pbiAtIFRoZSBtaW5pbXVtIGJvdW5kcy5cclxuKiBAcGFyYW0ge2Zsb2F0fSBtYXggLSBUaGUgbWF4aW11bSBib3VuZHMuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCB2YWx1ZS5cclxuKi9cclxudmFyIENsYW1wID0gZnVuY3Rpb24gKHYsIG1pbiwgbWF4KVxyXG57XHJcbiAgICBpZiAodiA8IG1pbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobWF4IDwgdilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbGFtcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0NsYW1wLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpXHJcbntcclxuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbjtcclxuXHJcbiAgICByZXR1cm4gKG1pbiArICgoKCh2YWx1ZSAtIG1pbikgJSByYW5nZSkgKyByYW5nZSkgJSByYW5nZSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvV3JhcC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29sbGlzaW9uIFR5cGVzIC0gRGV0ZXJtaW5lIGlmIGFuZCBob3cgZW50aXRpZXMgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXJcclxuXHJcbi8vIEluIEFDVElWRSB2cy4gTElURSBvciBGSVhFRCB2cy4gQU5ZIGNvbGxpc2lvbnMsIG9ubHkgdGhlIFwid2Vha1wiIGVudGl0eSBtb3ZlcyxcclxuLy8gd2hpbGUgdGhlIG90aGVyIG9uZSBzdGF5cyBmaXhlZC4gSW4gQUNUSVZFIHZzLiBBQ1RJVkUgYW5kIEFDVElWRSB2cy4gUEFTU0lWRVxyXG4vLyBjb2xsaXNpb25zLCBib3RoIGVudGl0aWVzIGFyZSBtb3ZlZC4gTElURSBvciBQQVNTSVZFIGVudGl0aWVzIGRvbid0IGNvbGxpZGVcclxuLy8gd2l0aCBvdGhlciBMSVRFIG9yIFBBU1NJVkUgZW50aXRpZXMgYXQgYWxsLiBUaGUgYmVoYWl2aW91ciBmb3IgRklYRUQgdnMuXHJcbi8vIEZJWEVEIGNvbGxpc2lvbnMgaXMgdW5kZWZpbmVkLlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTkVWRVI6IDAsXHJcbiAgICBMSVRFOiAxLFxyXG4gICAgUEFTU0lWRTogMixcclxuICAgIEFDVElWRTogNCxcclxuICAgIEZJWEVEOiA4XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L0NPTExJREVTLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5QYWlyYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpcnMuXHJcbipcclxuKiBAY2xhc3MgUGFpclxyXG4qL1xyXG5cclxudmFyIFBhaXIgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFpcjtcclxuXHJcbnZhciBDb250YWN0ID0gcmVxdWlyZSgnLi9Db250YWN0Jyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBhaXIuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb259IGNvbGxpc2lvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICogQHJldHVybiB7cGFpcn0gQSBuZXcgcGFpclxyXG4gICAgICovXHJcbiAgICBQYWlyLmNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxpc2lvbiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBLFxyXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QixcclxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxyXG4gICAgICAgICAgICBwYXJlbnRCID0gY29sbGlzaW9uLnBhcmVudEI7XHJcblxyXG4gICAgICAgIHZhciBwYWlyID0ge1xyXG4gICAgICAgICAgICBpZDogUGFpci5pZChib2R5QSwgYm9keUIpLFxyXG4gICAgICAgICAgICBib2R5QTogYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCOiBib2R5QixcclxuICAgICAgICAgICAgY29udGFjdHM6IHt9LFxyXG4gICAgICAgICAgICBhY3RpdmVDb250YWN0czogW10sXHJcbiAgICAgICAgICAgIHNlcGFyYXRpb246IDAsXHJcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBpc1NlbnNvcjogYm9keUEuaXNTZW5zb3IgfHwgYm9keUIuaXNTZW5zb3IsXHJcbiAgICAgICAgICAgIHRpbWVDcmVhdGVkOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIHRpbWVVcGRhdGVkOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGludmVyc2VNYXNzOiBwYXJlbnRBLmludmVyc2VNYXNzICsgcGFyZW50Qi5pbnZlcnNlTWFzcyxcclxuICAgICAgICAgICAgZnJpY3Rpb246IE1hdGgubWluKHBhcmVudEEuZnJpY3Rpb24sIHBhcmVudEIuZnJpY3Rpb24pLFxyXG4gICAgICAgICAgICBmcmljdGlvblN0YXRpYzogTWF0aC5tYXgocGFyZW50QS5mcmljdGlvblN0YXRpYywgcGFyZW50Qi5mcmljdGlvblN0YXRpYyksXHJcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiBNYXRoLm1heChwYXJlbnRBLnJlc3RpdHV0aW9uLCBwYXJlbnRCLnJlc3RpdHV0aW9uKSxcclxuICAgICAgICAgICAgc2xvcDogTWF0aC5tYXgocGFyZW50QS5zbG9wLCBwYXJlbnRCLnNsb3ApXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUGFpci51cGRhdGUocGFpciwgY29sbGlzaW9uLCB0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICByZXR1cm4gcGFpcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGEgcGFpciBnaXZlbiBhIGNvbGxpc2lvbi5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcclxuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9ufSBjb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcclxuICAgICAqL1xyXG4gICAgUGFpci51cGRhdGUgPSBmdW5jdGlvbihwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCkge1xyXG4gICAgICAgIHZhciBjb250YWN0cyA9IHBhaXIuY29udGFjdHMsXHJcbiAgICAgICAgICAgIHN1cHBvcnRzID0gY29sbGlzaW9uLnN1cHBvcnRzLFxyXG4gICAgICAgICAgICBhY3RpdmVDb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHMsXHJcbiAgICAgICAgICAgIHBhcmVudEEgPSBjb2xsaXNpb24ucGFyZW50QSxcclxuICAgICAgICAgICAgcGFyZW50QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHBhaXIuY29sbGlzaW9uID0gY29sbGlzaW9uO1xyXG4gICAgICAgIHBhaXIuaW52ZXJzZU1hc3MgPSBwYXJlbnRBLmludmVyc2VNYXNzICsgcGFyZW50Qi5pbnZlcnNlTWFzcztcclxuICAgICAgICBwYWlyLmZyaWN0aW9uID0gTWF0aC5taW4ocGFyZW50QS5mcmljdGlvbiwgcGFyZW50Qi5mcmljdGlvbik7XHJcbiAgICAgICAgcGFpci5mcmljdGlvblN0YXRpYyA9IE1hdGgubWF4KHBhcmVudEEuZnJpY3Rpb25TdGF0aWMsIHBhcmVudEIuZnJpY3Rpb25TdGF0aWMpO1xyXG4gICAgICAgIHBhaXIucmVzdGl0dXRpb24gPSBNYXRoLm1heChwYXJlbnRBLnJlc3RpdHV0aW9uLCBwYXJlbnRCLnJlc3RpdHV0aW9uKTtcclxuICAgICAgICBwYWlyLnNsb3AgPSBNYXRoLm1heChwYXJlbnRBLnNsb3AsIHBhcmVudEIuc2xvcCk7XHJcbiAgICAgICAgYWN0aXZlQ29udGFjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0ID0gc3VwcG9ydHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdElkID0gQ29udGFjdC5pZChzdXBwb3J0KSxcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0ID0gY29udGFjdHNbY29udGFjdElkXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzLnB1c2goY29udGFjdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzLnB1c2goY29udGFjdHNbY29udGFjdElkXSA9IENvbnRhY3QuY3JlYXRlKHN1cHBvcnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFpci5zZXBhcmF0aW9uID0gY29sbGlzaW9uLmRlcHRoO1xyXG4gICAgICAgICAgICBQYWlyLnNldEFjdGl2ZShwYWlyLCB0cnVlLCB0aW1lc3RhbXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgUGFpci5zZXRBY3RpdmUocGFpciwgZmFsc2UsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBwYWlyIGFzIGFjdGl2ZSBvciBpbmFjdGl2ZS5cclxuICAgICAqIEBtZXRob2Qgc2V0QWN0aXZlXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gaXNBY3RpdmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcclxuICAgICAqL1xyXG4gICAgUGFpci5zZXRBY3RpdmUgPSBmdW5jdGlvbihwYWlyLCBpc0FjdGl2ZSwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBwYWlyLnRpbWVVcGRhdGVkID0gdGltZXN0YW1wO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGlkIGZvciB0aGUgZ2l2ZW4gcGFpci5cclxuICAgICAqIEBtZXRob2QgaWRcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVW5pcXVlIHBhaXJJZFxyXG4gICAgICovXHJcbiAgICBQYWlyLmlkID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgaWYgKGJvZHlBLmlkIDwgYm9keUIuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdBJyArIGJvZHlBLmlkICsgJ0InICsgYm9keUIuaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdBJyArIGJvZHlCLmlkICsgJ0InICsgYm9keUEuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1BhaXIuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE5PUk1BTDogMCxcclxuICAgIEFERDogMSxcclxuICAgIE1VTFRJUExZOiAyLFxyXG4gICAgU0NSRUVOOiAzLFxyXG4gICAgT1ZFUkxBWTogNCxcclxuICAgIERBUktFTjogNSxcclxuICAgIExJR0hURU46IDYsXHJcbiAgICBDT0xPUl9ET0RHRTogNyxcclxuICAgIENPTE9SX0JVUk46IDgsXHJcbiAgICBIQVJEX0xJR0hUOiA5LFxyXG4gICAgU09GVF9MSUdIVDogMTAsXHJcbiAgICBESUZGRVJFTkNFOiAxMSxcclxuICAgIEVYQ0xVU0lPTjogMTIsXHJcbiAgICBIVUU6IDEzLFxyXG4gICAgU0FUVVJBVElPTjogMTQsXHJcbiAgICBDT0xPUjogMTUsXHJcbiAgICBMVU1JTk9TSVRZOiAxNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9CbGVuZE1vZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvLyAgTk9PUCAoTm8gT3BlcmF0aW9uKSBDYWxsYmFja1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOT09QO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL05PT1AuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSTkQgPSByZXF1aXJlKCcuL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAvLyAgQ09OU1RzIChtYWtlcyB0aGVtIHZpc2libGUgdW5kZXIgUGhhc2VyLk1hdGgpXHJcbiAgICBQSTI6IE1hdGguUEkgKiAyLFxyXG4gICAgVEFVOiBNYXRoLlBJICogMC41LFxyXG4gICAgRVBTSUxPTjogMS4wZS02LFxyXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcclxuICAgIFJBRF9UT19ERUc6IDE4MCAvIE1hdGguUEksXHJcblxyXG4gICAgLy8gIENvbGxlY3Rpb25zIG9mIGZ1bmN0aW9uc1xyXG4gICAgQW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUvJyksXHJcbiAgICBEaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZS8nKSxcclxuICAgIEVhc2luZzogcmVxdWlyZSgnLi9lYXNpbmcvJyksXHJcbiAgICBGdXp6eTogcmVxdWlyZSgnLi9mdXp6eS8nKSxcclxuICAgIEludGVycG9sYXRpb246IHJlcXVpcmUoJy4vaW50ZXJwb2xhdGlvbi8nKSxcclxuICAgIFBvdzI6IHJlcXVpcmUoJy4vcG93Mi8nKSxcclxuICAgIFNuYXA6IHJlcXVpcmUoJy4vc25hcC8nKSxcclxuXHJcbiAgICAvLyAgUmFuZG9tIERhdGEgR2VuZXJhdG9yXHJcbiAgICBSTkQ6IG5ldyBSTkQoKSxcclxuXHJcbiAgICAvLyAgU2luZ2xlIGZ1bmN0aW9uc1xyXG4gICAgQXZlcmFnZTogcmVxdWlyZSgnLi9BdmVyYWdlJyksXHJcbiAgICBCZXJuc3RlaW46IHJlcXVpcmUoJy4vQmVybnN0ZWluJyksXHJcbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0JldHdlZW4nKSxcclxuICAgIENhdG11bGxSb206IHJlcXVpcmUoJy4vQ2F0bXVsbFJvbScpLFxyXG4gICAgQ2VpbFRvOiByZXF1aXJlKCcuL0NlaWxUbycpLFxyXG4gICAgQ2xhbXA6IHJlcXVpcmUoJy4vQ2xhbXAnKSxcclxuICAgIERlZ1RvUmFkOiByZXF1aXJlKCcuL0RlZ1RvUmFkJyksXHJcbiAgICBEaWZmZXJlbmNlOiByZXF1aXJlKCcuL0RpZmZlcmVuY2UnKSxcclxuICAgIEZhY3RvcmlhbDogcmVxdWlyZSgnLi9GYWN0b3JpYWwnKSxcclxuICAgIEZsb2F0QmV0d2VlbjogcmVxdWlyZSgnLi9GbG9hdEJldHdlZW4nKSxcclxuICAgIEZsb29yVG86IHJlcXVpcmUoJy4vRmxvb3JUbycpLFxyXG4gICAgR2V0U3BlZWQ6IHJlcXVpcmUoJy4vR2V0U3BlZWQnKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcclxuICAgIE1heEFkZDogcmVxdWlyZSgnLi9NYXhBZGQnKSxcclxuICAgIE1pblN1YjogcmVxdWlyZSgnLi9NaW5TdWInKSxcclxuICAgIFBlcmNlbnQ6IHJlcXVpcmUoJy4vUGVyY2VudCcpLFxyXG4gICAgUmFkVG9EZWc6IHJlcXVpcmUoJy4vUmFkVG9EZWcnKSxcclxuICAgIFJvdGF0ZTogcmVxdWlyZSgnLi9Sb3RhdGUnKSxcclxuICAgIFJvdGF0ZUFyb3VuZDogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmQnKSxcclxuICAgIFJvdGF0ZUFyb3VuZERpc3RhbmNlOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZERpc3RhbmNlJyksXHJcbiAgICBSb3VuZEF3YXlGcm9tWmVybzogcmVxdWlyZSgnLi9Sb3VuZEF3YXlGcm9tWmVybycpLFxyXG4gICAgUm91bmRUbzogcmVxdWlyZSgnLi9Sb3VuZFRvJyksXHJcbiAgICBTaW5Db3NUYWJsZUdlbmVyYXRvcjogcmVxdWlyZSgnLi9TaW5Db3NUYWJsZUdlbmVyYXRvcicpLFxyXG4gICAgU21vb3RoZXJTdGVwOiByZXF1aXJlKCcuL1Ntb290aGVyU3RlcCcpLFxyXG4gICAgU21vb3RoU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhTdGVwJyksXHJcbiAgICBXaXRoaW46IHJlcXVpcmUoJy4vV2l0aGluJyksXHJcbiAgICBXcmFwOiByZXF1aXJlKCcuL1dyYXAnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpO1xyXG5cclxuLyoqXHJcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5leHRlbmQvXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMuZXh0ZW5kXHJcbiogQHBhcmFtIHtib29sZWFufSBkZWVwIC0gUGVyZm9ybSBhIGRlZXAgY29weT9cclxuKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cclxuKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXHJcbiovXHJcbnZhciBFeHRlbmQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXHJcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIilcclxuICAgIHtcclxuICAgICAgICBkZWVwID0gdGFyZ2V0O1xyXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgaSA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0ZW5kIFBoYXNlciBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgIGlmIChsZW5ndGggPT09IGkpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAtLWk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKElzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBJc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IEV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzSW50ZXJwb2xhdGlvbiA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgQ1NTIGltYWdlLXJlbmRlcmluZyBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gY2FudmFzIHRvIGJlICdjcmlzcCcgKGFrYSAnb3B0aW1pemUgY29udHJhc3QnIG9uIHdlYmtpdCkuXHJcbiAgICAqIE5vdGUgdGhhdCBpZiB0aGlzIGRvZXNuJ3QgZ2l2ZW4gdGhlIGRlc2lyZWQgcmVzdWx0IHRoZW4gc2VlIHRoZSBzZXRTbW9vdGhpbmdFbmFibGVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0SW1hZ2VSZW5kZXJpbmdDcmlzcFxyXG4gICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIHRvIHNldCBpbWFnZS1yZW5kZXJpbmcgY3Jpc3Agb24uXHJcbiAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIHRoZSBzb3VyY2UgY2FudmFzLlxyXG4gICAgKi9cclxuICAgIHNldENyaXNwOiBmdW5jdGlvbiAoY2FudmFzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0eXBlcyA9IFsgJ29wdGltaXplU3BlZWQnLCAnY3Jpc3AtZWRnZXMnLCAnLW1vei1jcmlzcC1lZGdlcycsICctd2Via2l0LW9wdGltaXplLWNvbnRyYXN0JywgJ29wdGltaXplLWNvbnRyYXN0JywgJ3BpeGVsYXRlZCcgXTtcclxuXHJcbiAgICAgICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FudmFzLnN0eWxlWydpbWFnZS1yZW5kZXJpbmcnXSA9IHR5cGU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5tc0ludGVycG9sYXRpb25Nb2RlID0gJ25lYXJlc3QtbmVpZ2hib3InO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgQ1NTIGltYWdlLXJlbmRlcmluZyBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gY2FudmFzIHRvIGJlICdiaWN1YmljJyAoYWthICdhdXRvJykuXHJcbiAgICAqIE5vdGUgdGhhdCBpZiB0aGlzIGRvZXNuJ3QgZ2l2ZW4gdGhlIGRlc2lyZWQgcmVzdWx0IHRoZW4gc2VlIHRoZSBDYW52YXNVdGlscy5zZXRTbW9vdGhpbmdFbmFibGVkIG1ldGhvZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzLnNldEltYWdlUmVuZGVyaW5nQmljdWJpY1xyXG4gICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0byBzZXQgaW1hZ2UtcmVuZGVyaW5nIGJpY3ViaWMgb24uXHJcbiAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIHRoZSBzb3VyY2UgY2FudmFzLlxyXG4gICAgKi9cclxuICAgIHNldEJpY3ViaWM6IGZ1bmN0aW9uIChjYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlWydpbWFnZS1yZW5kZXJpbmcnXSA9ICdhdXRvJztcclxuICAgICAgICBjYW52YXMuc3R5bGUubXNJbnRlcnBvbGF0aW9uTW9kZSA9ICdiaWN1YmljJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0ludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vLyAgQnJvd3NlciBzcGVjaWZpYyBwcmVmaXgsIHNvIG5vdCBnb2luZyB0byBjaGFuZ2UgYmV0d2VlbiBjb250ZXh0cywgb25seSBiZXR3ZWVuIGJyb3dzZXJzXHJcbnZhciBwcmVmaXggPSAnJztcclxuXHJcbnZhciBTbW9vdGhpbmcgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgU21vb3RoaW5nIEVuYWJsZWQgdmVuZG9yIHByZWZpeCBiZWluZyB1c2VkIG9uIHRoZSBnaXZlbiBjb250ZXh0LCBvciBudWxsIGlmIG5vdCBzZXQuXHJcbiAgICAqIGlpZmVcclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzLmdldFNtb290aGluZ1ByZWZpeFxyXG4gICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBpbWFnZSBzbW9vdGhpbmcgb24uXHJcbiAgICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSBSZXR1cm5zIHRoZSBzbW9vdGhpbmdFbmFibGVkIHZlbmRvciBwcmVmaXgsIG9yIG51bGwgaWYgbm90IHNldCBvbiB0aGUgY29udGV4dC5cclxuICAgICovXHJcbiAgICB2YXIgZ2V0UHJlZml4ID0gZnVuY3Rpb24gKGNvbnRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHZlbmRvcnMgPSBbICdpJywgJ3dlYmtpdEknLCAnbXNJJywgJ21vekknLCAnb0knIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdmVuZG9yc1tpXSArICdtYWdlU21vb3RoaW5nRW5hYmxlZCc7XHJcblxyXG4gICAgICAgICAgICBpZiAocyBpbiBjb250ZXh0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBJbWFnZSBTbW9vdGhpbmcgcHJvcGVydHkgb24gdGhlIGdpdmVuIGNvbnRleHQuIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGltYWdlIHNtb290aGluZy5cclxuICAgICogQnkgZGVmYXVsdCBicm93c2VycyBoYXZlIGltYWdlIHNtb290aGluZyBlbmFibGVkLCB3aGljaCBpc24ndCBhbHdheXMgd2hhdCB5b3UgdmlzdWFsbHkgd2FudCwgZXNwZWNpYWxseVxyXG4gICAgKiB3aGVuIHVzaW5nIHBpeGVsIGFydCBpbiBhIGdhbWUuIE5vdGUgdGhhdCB0aGlzIHNldHMgdGhlIHByb3BlcnR5IG9uIHRoZSBjb250ZXh0IGl0c2VsZiwgc28gdGhhdCBhbnkgaW1hZ2VcclxuICAgICogZHJhd24gdG8gdGhlIGNvbnRleHQgd2lsbCBiZSBhZmZlY3RlZC4gVGhpcyBzZXRzIHRoZSBwcm9wZXJ0eSBhY3Jvc3MgYWxsIGN1cnJlbnQgYnJvd3NlcnMgYnV0IHN1cHBvcnQgaXNcclxuICAgICogcGF0Y2h5IG9uIGVhcmxpZXIgYnJvd3NlcnMsIGVzcGVjaWFsbHkgb24gbW9iaWxlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0U21vb3RoaW5nRW5hYmxlZFxyXG4gICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBpbWFnZSBzbW9vdGhpbmcgb24uXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBJZiBzZXQgdG8gdHJ1ZSBpdCB3aWxsIGVuYWJsZSBpbWFnZSBzbW9vdGhpbmcsIGZhbHNlIHdpbGwgZGlzYWJsZSBpdC5cclxuICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29udGV4dC5cclxuICAgICovXHJcbiAgICB2YXIgZW5hYmxlID0gZnVuY3Rpb24gKGNvbnRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcmVmaXggPSBnZXRQcmVmaXgoY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJlZml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGV4dFtwcmVmaXhdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgSW1hZ2UgU21vb3RoaW5nIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBjb250ZXh0LiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBpbWFnZSBzbW9vdGhpbmcuXHJcbiAgICAqIEJ5IGRlZmF1bHQgYnJvd3NlcnMgaGF2ZSBpbWFnZSBzbW9vdGhpbmcgZW5hYmxlZCwgd2hpY2ggaXNuJ3QgYWx3YXlzIHdoYXQgeW91IHZpc3VhbGx5IHdhbnQsIGVzcGVjaWFsbHlcclxuICAgICogd2hlbiB1c2luZyBwaXhlbCBhcnQgaW4gYSBnYW1lLiBOb3RlIHRoYXQgdGhpcyBzZXRzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgY29udGV4dCBpdHNlbGYsIHNvIHRoYXQgYW55IGltYWdlXHJcbiAgICAqIGRyYXduIHRvIHRoZSBjb250ZXh0IHdpbGwgYmUgYWZmZWN0ZWQuIFRoaXMgc2V0cyB0aGUgcHJvcGVydHkgYWNyb3NzIGFsbCBjdXJyZW50IGJyb3dzZXJzIGJ1dCBzdXBwb3J0IGlzXHJcbiAgICAqIHBhdGNoeSBvbiBlYXJsaWVyIGJyb3dzZXJzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzLnNldFNtb290aGluZ0VuYWJsZWRcclxuICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgaW1hZ2Ugc21vb3RoaW5nIG9uLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gSWYgc2V0IHRvIHRydWUgaXQgd2lsbCBlbmFibGUgaW1hZ2Ugc21vb3RoaW5nLCBmYWxzZSB3aWxsIGRpc2FibGUgaXQuXHJcbiAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gUmV0dXJucyB0aGUgc291cmNlIGNvbnRleHQuXHJcbiAgICAqL1xyXG4gICAgdmFyIGRpc2FibGUgPSBmdW5jdGlvbiAoY29udGV4dClcclxuICAgIHtcclxuICAgICAgICBpZiAocHJlZml4ID09PSAnJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IGdldFByZWZpeChjb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmVmaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250ZXh0W3ByZWZpeF0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBjb250ZXh0IGhhcyBpbWFnZSBzbW9vdGhpbmcgZW5hYmxlZCwgb3RoZXJ3aXNlIHJldHVybnMgYGZhbHNlYC5cclxuICAgICAqIFJldHVybnMgbnVsbCBpZiBubyBzbW9vdGhpbmcgcHJlZml4IGlzIGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuZ2V0U21vb3RoaW5nRW5hYmxlZFxyXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byBjaGVjayBmb3Igc21vb3RoaW5nIG9uLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gY29udGV4dCBoYXMgaW1hZ2Ugc21vb3RoaW5nIGVuYWJsZWQsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgdmFyIGlzRW5hYmxlZCA9IGZ1bmN0aW9uIChjb250ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAocHJlZml4ICE9PSBudWxsKSA/IGNvbnRleHRbcHJlZml4XSA6IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGlzYWJsZTogZGlzYWJsZSxcclxuICAgICAgICBlbmFibGU6IGVuYWJsZSxcclxuICAgICAgICBnZXRQcmVmaXg6IGdldFByZWZpeCxcclxuICAgICAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoaW5nKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL1Ntb290aGluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9FZmZlY3RMYXllclJlbmRlcicpO1xyXG52YXIgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInKTtcclxuXHJcbi8vICBFZmZlY3RMYXllciByZW5kZXJzIGFsbCBlbGVtZW50cyBvbiB0aGUgbGF5ZXIgdG8gYW4gb2Zmc2NyZWVuIHJlbmRlciB0YXJnZXRcclxuLy8gIGFuZCB0aGVuIHdoZW4gcmVuZGVyaW5nIHRoZSBjb2xvciBidWZmZXIgb2YgdGhhdCByZW5kZXIgdGFyZ2V0IHRvIHRoZSBtYWluIHNjcmVlblxyXG4vLyAgaXQgYXBwbGllcyB0aGUgZWZmZWN0IGxheWVyIHNoYWRlci5cclxuXHJcbnZhciBFZmZlY3RMYXllciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIFJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdExheWVyIChzdGF0ZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZWZmZWN0TmFtZSwgZnJhZ21lbnRTaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlLCAnRWZmZWN0TGF5ZXInKTtcclxuICAgICAgIFxyXG4gICAgICAgIHZhciBwb3QgPSAoKHdpZHRoICYgKHdpZHRoIC0gMSkpID09IDAgJiYgKGhlaWdodCAmIChoZWlnaHQgLSAxKSkgPT0gMCk7XHJcbiAgICAgICAgdmFyIHJlc291cmNlTWFuYWdlciA9IHN0YXRlLmdhbWUucmVuZGVyZXIucmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB3cmFwO1xyXG4gICAgICAgIHZhciBnbDtcclxuXHJcbiAgICAgICAgdGhpcy5kc3RSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kc3RTaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKHJlc291cmNlTWFuYWdlciAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wgPSBzdGF0ZS5nYW1lLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgICAgICB3cmFwID0gcG90ID8gZ2wuUkVQRUFUIDogZ2wuQ0xBTVBfVE9fRURHRTtcclxuICAgICAgICAgICAgdGhpcy5kc3RTaGFkZXIgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKGVmZmVjdE5hbWUsIHtcclxuICAgICAgICAgICAgICAgIHZlcnQ6IFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlci52ZXJ0LFxyXG4gICAgICAgICAgICAgICAgZnJhZzogZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICBnbC5MSU5FQVIsIGdsLkxJTkVBUixcclxuICAgICAgICAgICAgICAgIHdyYXAsIHdyYXAsXHJcbiAgICAgICAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgbnVsbCwgd2lkdGgsIGhlaWdodFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kc3RSZW5kZXJUYXJnZXQgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHRoaXMucmVuZGVyVGV4dHVyZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHN0YXRlLmdhbWUucmVuZGVyZXIuY3VycmVudFRleHR1cmUgPSBudWxsOyAvLyBmb3JjZSByZWJpbmRpbmcgb2YgcHJldiB0ZXh0dXJlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZsaXBZID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyT2ZmU2NyZWVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gdGhpcy5kc3RSZW5kZXJUYXJnZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlck9uU2NyZWVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxuICAgIHtcclxuICAgICAgICBpZiAoZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0ID0gdGhpcy5kc3RSZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChnYW1lT2JqZWN0LnJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uO1xyXG5cclxuICAgICAgICBpZiAodW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbG9jYXRpb24gPSBkc3RTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybU5hbWVdID0gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50RmxvYXQxKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgZHN0U2hhZGVyID0gdGhpcy5kc3RTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChkc3RTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkc3RTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDModGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxvYXQ0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50RmxvYXQ0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSwgeiwgdyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEludDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDIodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MzogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDModGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6LCB3KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudEludDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4MngyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgZHN0U2hhZGVyID0gdGhpcy5kc3RTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChkc3RTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkc3RTaGFkZXIuc2V0Q29uc3RhbnRNYXRyaXgyeDIodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCBtYXRyaXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNYXRyaXgzeDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgbWF0cml4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkc3RTaGFkZXIgPSB0aGlzLmRzdFNoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKGRzdFNoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRzdFNoYWRlci5zZXRDb25zdGFudE1hdHJpeDN4Myh0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIG1hdHJpeCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1hdHJpeDR4NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCBtYXRyaXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRzdFNoYWRlciA9IHRoaXMuZHN0U2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAoZHN0U2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHN0U2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMYXllcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBUkM6IDAsXHJcbiAgICBCRUdJTl9QQVRIOiAxLFxyXG4gICAgQ0xPU0VfUEFUSDogMixcclxuICAgIEZJTExfUkVDVDogMyxcclxuICAgIExJTkVfVE86IDQsXHJcbiAgICBNT1ZFX1RPOiA1LFxyXG4gICAgTElORV9TVFlMRTogNixcclxuICAgIEZJTExfU1RZTEU6IDcsXHJcbiAgICBGSUxMX1BBVEg6IDgsXHJcbiAgICBTVFJPS0VfUEFUSDogOSxcclxuICAgIEZJTExfVFJJQU5HTEU6IDEwLFxyXG4gICAgU1RST0tFX1RSSUFOR0xFOiAxMSxcclxuICAgIExJTkVfRlhfVE86IDEyLFxyXG4gICAgTU9WRV9GWF9UTzogMTMsXHJcbiAgICBTQVZFOiAxNCxcclxuICAgIFJFU1RPUkU6IDE1LFxyXG4gICAgVFJBTlNMQVRFOiAxNixcclxuICAgIFNDQUxFOiAxNyxcclxuICAgIFJPVEFURTogMThcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9Db21tYW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIEltYWdlUmVuZGVyID0gcmVxdWlyZSgnLi9JbWFnZVJlbmRlcicpO1xyXG5cclxudmFyIEltYWdlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIEltYWdlUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gSW1hZ2UgKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsICdJbWFnZScpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgTWVzaCA9IHJlcXVpcmUoJy4uL21lc2gvTWVzaCcpO1xyXG5cclxudmFyIFF1YWQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IE1lc2gsXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBRdWFkIChzdGF0ZSwgeCwgeSwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIDAtLS0tM1xyXG4gICAgICAgIC8vICB8XFwgIEJ8XHJcbiAgICAgICAgLy8gIHwgXFwgIHxcclxuICAgICAgICAvLyAgfCAgXFwgfFxyXG4gICAgICAgIC8vICB8IEEgXFx8XHJcbiAgICAgICAgLy8gIHwgICAgXFxcclxuICAgICAgICAvLyAgMS0tLS0yXHJcblxyXG4gICAgICAgIC8vICBBcnJheSBzZXF1ZW5jZTogdGwsIGJsLCBiciwgdHJcclxuICAgICAgICB2YXIgdmVydGljZXMgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXTtcclxuICAgICAgICB2YXIgdXYgPSBbIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDAgXTtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IFsgMCwgMSwgMiwgMCwgMiwgMyBdO1xyXG4gICAgICAgIHZhciBjb2xvcnMgPSBbIDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmZmYsIDB4ZmZmZmZmIF07XHJcbiAgICAgICAgdmFyIGFscGhhcyA9IFsgMSwgMSwgMSwgMSBdO1xyXG5cclxuICAgICAgICBNZXNoLmNhbGwodGhpcywgc3RhdGUsIHgsIHksIHZlcnRpY2VzLCB1diwgaW5kaWNlcywgY29sb3JzLCBhbHBoYXMsIHRleHR1cmUsIGZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvcExlZnRYOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLnZlcnRpY2VzWzBdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1swXSA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcExlZnRZOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLnZlcnRpY2VzWzFdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHZhbHVlIC0gdGhpcy55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcFJpZ2h0WDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy52ZXJ0aWNlc1s2XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbNl0gPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3BSaWdodFk6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMudmVydGljZXNbN107XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzWzddID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tTGVmdFg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMudmVydGljZXNbMl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzWzJdID0gdmFsdWUgLSB0aGlzLng7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tTGVmdFk6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMudmVydGljZXNbM107XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzWzNdID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tUmlnaHRYOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLnZlcnRpY2VzWzRdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1s0XSA9IHZhbHVlIC0gdGhpcy54O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbVJpZ2h0WToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy52ZXJ0aWNlc1s1XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbNV0gPSB2YWx1ZSAtIHRoaXMueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAgICAgLy8gIHRsLCBibCwgYnIsIHRyXHJcblxyXG4gICAgdG9wTGVmdEFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFscGhhc1swXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGFzWzBdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdG9wUmlnaHRBbHBoYToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHBoYXNbM107XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhc1szXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbUxlZnRBbHBoYToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHBoYXNbMV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhc1sxXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJvdHRvbVJpZ2h0QWxwaGE6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGFzWzJdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYXNbMl0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3BMZWZ0Q29sb3I6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzWzBdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvcnNbMF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3BSaWdodENvbG9yOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1szXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzWzNdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tTGVmdENvbG9yOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1sxXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzWzFdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tUmlnaHRDb2xvcjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbMl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yc1syXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRvcExlZnQ6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudG9wTGVmdFggPSB4O1xyXG4gICAgICAgIHRoaXMudG9wTGVmdFkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudG9wUmlnaHRYID0geDtcclxuICAgICAgICB0aGlzLnRvcFJpZ2h0WSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvdHRvbUxlZnRYID0geDtcclxuICAgICAgICB0aGlzLmJvdHRvbUxlZnRZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SaWdodFkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICB2YXIgaGFsZldpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMik7XHJcbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VG9wTGVmdCh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZXRUb3BSaWdodCh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zZXRCb3R0b21MZWZ0KHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldEJvdHRvbVJpZ2h0KHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0QWxwaGE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFscGhhcyA9IHRoaXMuYWxwaGFzO1xyXG5cclxuICAgICAgICBhbHBoYXNbMF0gPSAxO1xyXG4gICAgICAgIGFscGhhc1sxXSA9IDE7XHJcbiAgICAgICAgYWxwaGFzWzJdID0gMTtcclxuICAgICAgICBhbHBoYXNbM10gPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRDb2xvcnM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG5cclxuICAgICAgICBjb2xvcnNbMF0gPSAweGZmZmZmZjtcclxuICAgICAgICBjb2xvcnNbMV0gPSAweGZmZmZmZjtcclxuICAgICAgICBjb2xvcnNbMl0gPSAweGZmZmZmZjtcclxuICAgICAgICBjb2xvcnNbM10gPSAweGZmZmZmZjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMucmVzZXRBbHBoYSgpO1xyXG4gICAgICAgIHRoaXMucmVzZXRDb2xvcnMoKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWFkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3F1YWQvUXVhZC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi8uLi8uLi9kb20vQ2FudmFzUG9vbCcpO1xyXG52YXIgVGV4dFJlbmRlciA9IHJlcXVpcmUoJy4vVGV4dFJlbmRlcicpO1xyXG52YXIgVGV4dFN0eWxlID0gcmVxdWlyZSgnLi4vVGV4dFN0eWxlJyk7XHJcbnZhciBHZXRUZXh0U2l6ZSA9IHJlcXVpcmUoJy4uL0dldFRleHRTaXplJyk7XHJcblxyXG52YXIgVGV4dCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgVGV4dFJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRleHQgKHN0YXRlLCB4LCB5LCB0ZXh0LCBzdHlsZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHsgdGV4dCA9ICcnOyB9XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ1RleHQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgdGhlIHRleHQgaXMgcmVuZGVyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtIVE1MQ2FudmFzRWxlbWVudH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHRoZSB0ZXh0IGlzIHJlbmRlcmVkIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgVGV4dFN0eWxlKHRoaXMsIHN0eWxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hdXRvUm91bmQgPSB0cnVlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHRoYXQgaXMgdXNlZCB0byBzcGxpdCB0aGUgdGV4dCB1cCBpbnRvIGxpbmVzLCBpblxyXG4gICAgICAgICAqIG11bHRpLWxpbmUgdGV4dC4gQnkgZGVmYXVsdCB0aGlzIGlzIGAvKD86XFxyXFxufFxccnxcXG4pL2AuXHJcbiAgICAgICAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBSZWdFeHAgdG8gYmUgYW55dGhpbmcgZWxzZSB0aGF0IHlvdSBtYXkgbmVlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc3BsaXRSZWdFeHBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNwbGl0UmVnRXhwID0gLyg/OlxcclxcbnxcXHJ8XFxuKS87XHJcblxyXG4gICAgICAgIHRoaXMudGV4dCA9IChBcnJheS5pc0FycmF5KHRleHQpKSA/IHRleHQuam9pbignXFxuJykgOiB0ZXh0O1xyXG5cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFNwZWNpZnkgYSBwYWRkaW5nIHZhbHVlIHdoaWNoIGlzIGFkZGVkIHRvIHRoZSBsaW5lIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBjYWxjdWxhdGluZyB0aGUgVGV4dCBzaXplLlxyXG4gICAgICAgICogQWxsb3dzIHlvdSB0byBhZGQgZXh0cmEgc3BhY2luZyBpZiBQaGFzZXIgaXMgdW5hYmxlIHRvIGFjY3VyYXRlbHkgZGV0ZXJtaW5lIHRoZSB0cnVlIGZvbnQgZGltZW5zaW9ucy5cclxuICAgICAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlBvaW50fSBwYWRkaW5nXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhc1RleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJldldpZHRoID0gMDtcclxuICAgICAgICB0aGlzLnByZXZIZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRleHQgIT09ICcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy50ZXh0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWUudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U3R5bGUoc3R5bGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGb250OiBmdW5jdGlvbiAoZm9udClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRGb250KGZvbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaXhlZFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldEZpeGVkU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmlsbDogZnVuY3Rpb24gKGNvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldEZpbGwoY29sb3IpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTdHJva2U6IGZ1bmN0aW9uIChjb2xvciwgdGhpY2tuZXNzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFN0cm9rZShjb2xvciwgdGhpY2tuZXNzKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93OiBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGJsdXIsIHNoYWRvd1N0cm9rZSwgc2hhZG93RmlsbClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTaGFkb3coeCwgeSwgY29sb3IsIGJsdXIsIHNoYWRvd1N0cm9rZSwgc2hhZG93RmlsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd09mZnNldDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U2hhZG93T2Zmc2V0KHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24gKGNvbG9yKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd0NvbG9yKGNvbG9yKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93Qmx1cjogZnVuY3Rpb24gKGJsdXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U2hhZG93Qmx1cihibHVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93U3Ryb2tlOiBmdW5jdGlvbiAoZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTaGFkb3dTdHJva2UoZW5hYmxlZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0ZpbGw6IGZ1bmN0aW9uIChlbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd0ZpbGwoZW5hYmxlZCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFsaWduOiBmdW5jdGlvbiAoYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0QWxpZ24oYWxpZ24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNYXhMaW5lczogZnVuY3Rpb24gKG1heClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRNYXhMaW5lcyhtYXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUZXh0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgIHZhciBzaXplID0gc3R5bGUubWV0cmljcztcclxuXHJcbiAgICAgICAgdmFyIG91dHB1dFRleHQgPSB0aGlzLnRleHQ7XHJcblxyXG4gICAgICAgIC8vIGlmIChzdHlsZS53b3JkV3JhcClcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIG91dHB1dFRleHQgPSB0aGlzLnJ1bldvcmRXcmFwKHRoaXMudGV4dCk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyAgU3BsaXQgdGV4dCBpbnRvIGxpbmVzXHJcbiAgICAgICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCh0aGlzLnNwbGl0UmVnRXhwKTtcclxuXHJcbiAgICAgICAgdmFyIHRleHRTaXplID0gR2V0VGV4dFNpemUodGhpcywgc2l6ZSwgbGluZXMpO1xyXG5cclxuICAgICAgICBpZiAoIXN0eWxlLmZpeGVkV2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGV4dFNpemUud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXN0eWxlLmZpeGVkSGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbigpO1xyXG5cclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMucGFkZGluZztcclxuXHJcbiAgICAgICAgdmFyIHcgPSAodGV4dFNpemUud2lkdGggKyAocGFkZGluZy54ICogMikpICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBoID0gKHRleHRTaXplLmhlaWdodCArIChwYWRkaW5nLnkgKiAyKSkgKiB0aGlzLnJlc29sdXRpb247XHJcblxyXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IHcgfHwgY2FudmFzLmhlaWdodCAhPT0gaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHlsZS5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0eWxlLnN5bmNGb250KGNhbnZhcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xyXG5cclxuICAgICAgICAvLyAgQXBwbHkgcGFkZGluZ1xyXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBhZGRpbmcueCwgcGFkZGluZy55KTtcclxuXHJcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblg7XHJcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblk7XHJcblxyXG4gICAgICAgIC8vICBEcmF3IHRleHQgbGluZSBieSBsaW5lXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0U2l6ZS5saW5lczsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDI7XHJcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSAoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkgKiB0ZXh0U2l6ZS5saW5lSGVpZ2h0KSArIHNpemUuYXNjZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKGkgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZICs9ICh0ZXh0U2l6ZS5saW5lU3BhY2luZyAqIGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gdGV4dFNpemUud2lkdGggLSB0ZXh0U2l6ZS5saW5lV2lkdGhzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAodGV4dFNpemUud2lkdGggLSB0ZXh0U2l6ZS5saW5lV2lkdGhzW2ldKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9Sb3VuZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IE1hdGgucm91bmQobGluZVBvc2l0aW9uWCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gTWF0aC5yb3VuZChsaW5lUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZVRoaWNrbmVzcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zeW5jU2hhZG93KGNvbnRleHQsIHN0eWxlLnNoYWRvd1N0cm9rZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc3luY1NoYWRvdyhjb250ZXh0LCBzdHlsZS5zaGFkb3dGaWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUZXh0TWV0cmljczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRUZXh0TWV0cmljcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dCA9IENvbXBvbmVudHMuVG9KU09OKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyAgRXh0cmEgVGV4dCBkYXRhIGlzIGFkZGVkIGhlcmVcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGF1dG9Sb3VuZDogdGhpcy5hdXRvUm91bmQsXHJcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGUudG9KU09OKCksXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcclxuICAgICAgICAgICAgcGFkZGluZzoge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5wYWRkaW5nLngsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnBhZGRpbmcueVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgb3V0LmRhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgVGlsZW1hcFJlbmRlciA9IHJlcXVpcmUoJy4vVGlsZW1hcFJlbmRlcicpO1xyXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vVGlsZScpO1xyXG5cclxudmFyIFRpbGVtYXAgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLkZsaXAsXHJcbiAgICAgICAgQ29tcG9uZW50cy5HZXRCb3VuZHMsXHJcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXHJcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJUYXJnZXQsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgVGlsZW1hcFJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRpbGVtYXAgKHN0YXRlLCBtYXBEYXRhLCB4LCB5LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIG1hcFdpZHRoLCBtYXBIZWlnaHQsIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ1RpbGVtYXAnKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gbWFwRGF0YSAhPT0gbnVsbCA/IG5ldyBVaW50MzJBcnJheShtYXBEYXRhKSA6IG5ldyBVaW50MzJBcnJheShtYXBXaWR0aCAqIG1hcEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy50aWxlV2lkdGggPSB0aWxlV2lkdGg7XHJcbiAgICAgICAgdGhpcy50aWxlSGVpZ2h0ID0gdGlsZUhlaWdodDtcclxuICAgICAgICB0aGlzLm1hcFdpZHRoID0gbWFwV2lkdGg7XHJcbiAgICAgICAgdGhpcy5tYXBIZWlnaHQgPSBtYXBIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy50aWxlQXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLmN1bGxlZFRpbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZVRvRnJhbWUoKTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh0aWxlV2lkdGggKiBtYXBXaWR0aCwgdGlsZUhlaWdodCAqIG1hcEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5idWlsZFRpbGVtYXAoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG90YWxUaWxlQ291bnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZUFycmF5Lmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VmlzaWJsZVRpbGVDb3VudDogZnVuY3Rpb24gKGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdWxsKGNhbWVyYSkubGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZFRpbGVtYXA6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRpbGVBcnJheSA9IHRoaXMudGlsZUFycmF5O1xyXG4gICAgICAgIHZhciBtYXBEYXRhID0gdGhpcy5tYXBEYXRhO1xyXG4gICAgICAgIC8vIHZhciBmcmFtZSA9IHRoaXMuZnJhbWU7XHJcbiAgICAgICAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xyXG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dHVyZS5zb3VyY2VbMF0ud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dHVyZS5zb3VyY2VbMF0uaGVpZ2h0O1xyXG4gICAgICAgIHZhciBtYXBXaWR0aCA9IHRoaXMubWFwV2lkdGg7XHJcbiAgICAgICAgdmFyIG1hcEhlaWdodCA9IHRoaXMubWFwSGVpZ2h0O1xyXG4gICAgICAgIHZhciBzZXRXaWR0aCA9IHdpZHRoIC8gdGlsZVdpZHRoO1xyXG5cclxuICAgICAgICB0aWxlQXJyYXkubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXBIZWlnaHQ7ICsreSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWFwV2lkdGg7ICsreClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVJZCA9IG1hcERhdGFbeSAqIG1hcFdpZHRoICsgeF07XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRpbGVXaWR0aCA9ICh0aWxlV2lkdGgpICogMC41O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaWxlSGVpZ2h0ID0gKHRpbGVIZWlnaHQpICogMC41O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3R4ID0gKCgodGlsZUlkICUgc2V0V2lkdGgpfDApICogdGlsZVdpZHRoKSArIGhhbGZUaWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdHkgPSAoKCh0aWxlSWQgLyBzZXRXaWR0aCl8MCkgKiB0aWxlSGVpZ2h0KSArIGhhbGZUaWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4ID0geCAqIHRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB0eSA9IHkgKiB0aWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aWxlQXJyYXkucHVzaChuZXcgVGlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHggKyB5LFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdHksXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRpbGVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpbGVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVYOiByZWN0eCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZVk6IHJlY3R5LFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lV2lkdGg6IHRpbGVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZUhlaWdodDogdGlsZUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVIZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjdWxsOiBmdW5jdGlvbiAoY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjdWxsZWRUaWxlcyA9IHRoaXMuY3VsbGVkVGlsZXM7XHJcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy50aWxlQXJyYXk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRpbGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgc2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogdGhpcy5zY3JvbGxGYWN0b3JYO1xyXG4gICAgICAgIHZhciBzY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiB0aGlzLnNjcm9sbEZhY3Rvclk7XHJcbiAgICAgICAgdmFyIGNhbWVyYVcgPSBjYW1lcmEud2lkdGg7XHJcbiAgICAgICAgdmFyIGNhbWVyYUggPSBjYW1lcmEuaGVpZ2h0O1xyXG5cclxuICAgICAgICBjdWxsZWRUaWxlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aWxlc1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhciB0aWxlWCA9IHRpbGUueCAtIHNjcm9sbFg7XHJcbiAgICAgICAgICAgIHZhciB0aWxlWSA9IHRpbGUueSAtIHNjcm9sbFk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlVyA9IHRpbGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSCA9IHRpbGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY3VsbFcgPSBjYW1lcmFXICsgdGlsZVc7XHJcbiAgICAgICAgICAgIHZhciBjdWxsSCA9IGNhbWVyYUggKyB0aWxlSDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUgJiZcclxuICAgICAgICAgICAgICAgIHRpbGVYID4gLXRpbGVIICYmIHRpbGVZID4gLXRpbGVXICYmXHJcbiAgICAgICAgICAgICAgICB0aWxlWCA8IGN1bGxXICYmIHRpbGVZIDwgY3VsbEgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN1bGxlZFRpbGVzLnB1c2godGlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjdWxsZWRUaWxlcztcclxuICAgIH0sXHJcblxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGlsZUFycmF5LmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUmV0dXJucyBPYmplY3QgY29udGFpbmluZzpcclxuICAgIC8vICB7XHJcbiAgICAvLyAgICAgIGFscGhhXHJcbiAgICAvLyAgICAgIGZyYW1lV2lkdGgsXHJcbiAgICAvLyAgICAgIGZyYW1lSGVpZ2h0LFxyXG4gICAgLy8gICAgICBmcmFtZVhcclxuICAgIC8vICAgICAgZnJhbWVZXHJcbiAgICAvLyAgICAgIGlkXHJcbiAgICAvLyAgICAgIGluZGV4ID0gdGhlIHRpbGUgaW4gdGhlIHRpbHNldCB0byByZW5kZXJcclxuICAgIC8vICAgICAgdGV4dHVyZVdpZHRoID0gdGlsZXNldCB0ZXh0dXJlIHNpemVcclxuICAgIC8vICAgICAgdGV4dHVyZUhlaWdodFxyXG4gICAgLy8gICAgICB0aW50XHJcbiAgICAvLyAgICAgIHZpc2libGVcclxuICAgIC8vICAgICAgd2lkdGhcclxuICAgIC8vICAgICAgeFxyXG4gICAgLy8gICAgICB5XHJcbiAgICAvLyAgfVxyXG5cclxuICAgIGdldFRpbGVBdDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl4ID0gKHh8MCk7XHJcbiAgICAgICAgdmFyIGl5ID0gKHl8MCk7XHJcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy50aWxlQXJyYXk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaXkgKiB0aGlzLm1hcFdpZHRoICsgaXg7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA8IHRpbGVzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aWxlc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGlsZUF0SW5kZXg6IGZ1bmN0aW9uIChpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLnRpbGVBcnJheTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4IDwgdGlsZXMubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbGVzW2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVtYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL1RpbGVtYXAuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBTdGF0aWNUaWxlbWFwUmVuZGVyID0gcmVxdWlyZSgnLi9TdGF0aWNUaWxlbWFwUmVuZGVyJyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy90aWxlbWFwcmVuZGVyZXIvY29uc3QnKTtcclxuXHJcbnZhciBTdGF0aWNUaWxlbWFwID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIFN0YXRpY1RpbGVtYXBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBTdGF0aWNUaWxlbWFwIChzdGF0ZSwgbWFwRGF0YSwgeCwgeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBtYXBXaWR0aCwgbWFwSGVpZ2h0LCB0ZXh0dXJlLCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsICdTdGF0aWNUaWxlbWFwJyk7XHJcblxyXG4gICAgICAgIHRoaXMudmJvID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdsID0gc3RhdGUuZ2FtZS5yZW5kZXJlci5nbCA/IHN0YXRlLmdhbWUucmVuZGVyZXIuZ2wgOiBudWxsO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gc3RhdGUuZ2FtZS5yZW5kZXJlci50aWxlbWFwUmVuZGVyZXIgPyBzdGF0ZS5nYW1lLnJlbmRlcmVyLnRpbGVtYXBSZW5kZXJlciA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSB0aGlzLmdsID8gc3RhdGUuZ2FtZS5yZW5kZXJlci5yZXNvdXJjZU1hbmFnZXIgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gbWFwRGF0YTtcclxuICAgICAgICB0aGlzLnRpbGVXaWR0aCA9IHRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLnRpbGVIZWlnaHQgPSB0aWxlSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMubWFwV2lkdGggPSBtYXBXaWR0aDtcclxuICAgICAgICB0aGlzLm1hcEhlaWdodCA9IG1hcEhlaWdodDtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmN1bGxTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdWxsRW5kID0gMDtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKHRpbGVXaWR0aCAqIG1hcFdpZHRoLCB0aWxlSGVpZ2h0ICogbWFwSGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBsb2FkOiBmdW5jdGlvbiAoY2FtZXJhKSBcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5nbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZibyA9IHRoaXMudmJvO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcFdpZHRoID0gdGhpcy5tYXBXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXBIZWlnaHQgPSB0aGlzLm1hcEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlV2lkdGggPSB0aGlzLnRpbGVXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSB0aGlzLmJ1ZmZlckRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRjMyLCBidWZmZXJVMzI7XHJcbiAgICAgICAgICAgICAgICB2YXIgdm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlLnNvdXJjZVswXS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmUuc291cmNlWzBdLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBzZXRXaWR0aCA9IHdpZHRoIC8gdGlsZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcERhdGEgPSB0aGlzLm1hcERhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmJvID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZibyA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsICg0ICogNiAqIChtYXBXaWR0aCAqIG1hcEhlaWdodCkpICogNCwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZiby5hZGRBdHRyaWJ1dGUodGhpcy50aWxlbWFwUmVuZGVyZXIuc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3Bvc2l0aW9uJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZiby5hZGRBdHRyaWJ1dGUodGhpcy50aWxlbWFwUmVuZGVyZXIuc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX3RleF9jb29yZCcpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCA4KTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gdGhpcy5idWZmZXJEYXRhID0gbmV3IEFycmF5QnVmZmVyKCg0ICogNiAqIChtYXBXaWR0aCAqIG1hcEhlaWdodCkpICogNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52Ym8gPSB2Ym87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyRjMyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJEYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG1hcEhlaWdodDsgKyt5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWFwV2lkdGg7ICsreClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWxlSWQgPSBtYXBEYXRhW3kgKiBtYXBXaWR0aCArIHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRpbGVXaWR0aCA9ICAodGlsZVdpZHRoKSAqIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZUaWxlSGVpZ2h0ID0gICh0aWxlSGVpZ2h0KSAqIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3R4ID0gKCgodGlsZUlkICUgc2V0V2lkdGgpfDApICogdGlsZVdpZHRoKSArIGhhbGZUaWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0eSA9ICgoKHRpbGVJZCAvIHNldFdpZHRoKXwwKSAqIHRpbGVIZWlnaHQpICsgaGFsZlRpbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IHggKiB0aWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eSA9IHkgKiB0aWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHh3ID0gdHggKyB0aWxlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eWggPSB0eSArIHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1MCA9IChyZWN0eCAtIChoYWxmVGlsZVdpZHRoIC0gMC41KSkgLyB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYwID0gKHJlY3R5IC0gKGhhbGZUaWxlSGVpZ2h0IC0gMC41KSkgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1MSA9IChyZWN0eCArIChoYWxmVGlsZVdpZHRoIC0gMC41KSkgLyB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gKHJlY3R5ICsgKGhhbGZUaWxlSGVpZ2h0IC0gMC41KSkgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eDAgPSB0eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5MCA9IHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHgxID0gdHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eTEgPSB0eWg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eDIgPSB0eHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eTIgPSB0eWg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eDMgPSB0eHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eTMgPSB0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMF0gPSB0eDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMV0gPSB0eTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMl0gPSB1MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAzXSA9IHYwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyA0XSA9IHR4MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyA1XSA9IHR5MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyA2XSA9IHUwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDddID0gdjE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDhdID0gdHgyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDldID0gdHkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDEwXSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDExXSA9IHYxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAxMl0gPSB0eDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTNdID0gdHkwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDE0XSA9IHUwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDE1XSA9IHYwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAxNl0gPSB0eDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMTddID0gdHkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDE4XSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDE5XSA9IHYxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRjMyW3ZvZmZzZXQgKyAyMF0gPSB0eDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckYzMlt2b2Zmc2V0ICsgMjFdID0gdHkzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDIyXSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJGMzJbdm9mZnNldCArIDIzXSA9IHYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9mZnNldCArPSAyNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4Q291bnQgKz0gNjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XHJcbiAgICAgICAgICAgICAgICB2Ym8udXBkYXRlUmVzb3VyY2UoYnVmZmVyRGF0YSwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnNoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLnRpbGVtYXBSZW5kZXJlci5zY3JvbGxMb2NhdGlvbiwgLWNhbWVyYS5zY3JvbGxYLCAtY2FtZXJhLnNjcm9sbFkpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5zaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDIodGhpcy50aWxlbWFwUmVuZGVyZXIuc2Nyb2xsRmFjdG9yTG9jYXRpb24sIHRoaXMuc2Nyb2xsRmFjdG9yWCwgdGhpcy5zY3JvbGxGYWN0b3JZKTtcclxuICAgICAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2hhZGVyLnNldENvbnN0YW50RmxvYXQyKHRoaXMudGlsZW1hcFJlbmRlcmVyLnRpbGVtYXBQb3NpdGlvbkxvY2F0aW9uLCB0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3RhbFRpbGVDb3VudDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEYXRhLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VmlzaWJsZVRpbGVDb3VudDogZnVuY3Rpb24gKGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1bGwoY2FtZXJhKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuY3VsbEVuZCAtIHRoaXMuY3VsbFN0YXJ0KSAvIDY7XHJcbiAgICB9LFxyXG5cclxuICAgIGN1bGw6IGZ1bmN0aW9uIChjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdWxsU3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VsbEVuZCA9IDA7XHJcbiAgICAgICAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoO1xyXG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0O1xyXG4gICAgICAgIHZhciBwaXhlbFggPSB0aGlzLnggLSAoY2FtZXJhLnNjcm9sbFggKiB0aGlzLnNjcm9sbEZhY3RvclgpO1xyXG4gICAgICAgIHZhciBwaXhlbFkgPSB0aGlzLnkgLSAoY2FtZXJhLnNjcm9sbFkgKiB0aGlzLnNjcm9sbEZhY3RvclkpO1xyXG4gICAgICAgIHZhciBwaXhlbFdpZHRoID0gdGhpcy5tYXBXaWR0aCAqIHRpbGVXaWR0aDtcclxuICAgICAgICB2YXIgcGl4ZWxIZWlnaHQgPSB0aGlzLm1hcEhlaWdodCAqIHRpbGVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChwaXhlbFggPCBjYW1lcmEueCArIGNhbWVyYS53aWR0aCArICh0aWxlV2lkdGggKiAyKSAmJlxyXG4gICAgICAgICAgICBwaXhlbFggKyBwaXhlbFdpZHRoID4gY2FtZXJhLnggKyAtKHRpbGVXaWR0aCAqIDIpICYmXHJcbiAgICAgICAgICAgIHBpeGVsWSA8IGNhbWVyYS55ICsgY2FtZXJhLmhlaWdodCArICh0aWxlSGVpZ2h0ICogMikgJiZcclxuICAgICAgICAgICAgcGl4ZWxZICsgcGl4ZWxIZWlnaHQgPiBjYW1lcmEueSArIC0odGlsZUhlaWdodCAqIDIpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGludGVyWCA9IE1hdGgubWF4KHBpeGVsWCwgY2FtZXJhLnggKyAtKHRpbGVXaWR0aCAqIDIpKTtcclxuICAgICAgICAgICAgdmFyIGludGVyWSA9IE1hdGgubWF4KHBpeGVsWSwgY2FtZXJhLnkgKyAtKHRpbGVIZWlnaHQgKiAyKSk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcldpZHRoID0gTWF0aC5taW4ocGl4ZWxYICsgcGl4ZWxXaWR0aCwgY2FtZXJhLnggKyBjYW1lcmEud2lkdGggKyAodGlsZVdpZHRoICogMikpIC0gaW50ZXJYO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJIZWlnaHQgPSBNYXRoLm1pbihwaXhlbFkgKyBwaXhlbEhlaWdodCwgY2FtZXJhLnkgKyBjYW1lcmEuaGVpZ2h0ICsgKHRpbGVIZWlnaHQgKiAyKSkgLSBpbnRlclk7XHJcblxyXG4gICAgICAgICAgICBpbnRlclggPSAoKGludGVyWCArIChjYW1lcmEuc2Nyb2xsWCAqIHRoaXMuc2Nyb2xsRmFjdG9yWCkpIC8gdGlsZVdpZHRoKXwwO1xyXG4gICAgICAgICAgICBpbnRlclkgPSAoKGludGVyWSArIChjYW1lcmEuc2Nyb2xsWSAqIHRoaXMuc2Nyb2xsRmFjdG9yWSkpIC8gdGlsZUhlaWdodCl8MDtcclxuICAgICAgICAgICAgaW50ZXJXaWR0aCA9IChpbnRlcldpZHRoIC8gdGlsZVdpZHRoKXwwO1xyXG4gICAgICAgICAgICBpbnRlckhlaWdodCA9IChpbnRlckhlaWdodCAvIHRpbGVIZWlnaHQpfDA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1bGxTdGFydCA9IChpbnRlclkgKiB0aGlzLm1hcFdpZHRoICsgaW50ZXJYKSAqIDY7XHJcbiAgICAgICAgICAgIHRoaXMuY3VsbEVuZCA9ICgoaW50ZXJZICsgaW50ZXJIZWlnaHQpICogdGhpcy5tYXBXaWR0aCArIGludGVyWCkgKiA2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNUaWxlbWFwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXAuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcblxyXG52YXIgWm9uZSA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gWm9uZSAoc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlLCAnWm9uZScpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBab25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3pvbmUvWm9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKGVsbGlwc2UsIHgsIHkpXHJcbntcclxuICAgIGlmIChlbGxpcHNlLndpZHRoIDw9IDAgfHwgZWxsaXBzZS5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiBcclxuICAgIC8vICBOb3JtYWxpemUgdGhlIGNvb3JkcyB0byBhbiBlbGxpcHNlIHdpdGggY2VudGVyIDAsMCBhbmQgYSByYWRpdXMgb2YgMC41XHJcbiAgICB2YXIgbm9ybXggPSAoKHggLSBlbGxpcHNlLngpIC8gZWxsaXBzZS53aWR0aCkgLSAwLjU7XHJcbiAgICB2YXIgbm9ybXkgPSAoKHkgLSBlbGxpcHNlLnkpIC8gZWxsaXBzZS5oZWlnaHQpIC0gMC41O1xyXG4gXHJcbiAgICBub3JteCAqPSBub3JteDtcclxuICAgIG5vcm15ICo9IG5vcm15O1xyXG4gXHJcbiAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPCAwLjI1KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBVc2luZyBCcmVzZW5oYW0ncyBsaW5lIGFsZ29yaXRobSB0aGlzIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcyBvbiB0aGlzIGxpbmUuXHJcbiogVGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSByb3VuZGVkIGJlZm9yZSB0aGlzIHJ1bnMgYXMgdGhlIGFsZ29yaXRobSB3b3JrcyBvbiBpbnRlZ2Vycy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUjY29vcmRpbmF0ZXNPbkxpbmVcclxuKiBAcGFyYW0ge251bWJlcn0gW3N0ZXBSYXRlPTFdIC0gSG93IG1hbnkgc3RlcHMgd2lsbCB3ZSByZXR1cm4/IDEgPSBldmVyeSBjb29yZGluYXRlIG9uIHRoZSBsaW5lLCAyID0gZXZlcnkgb3RoZXIgY29vcmRpbmF0ZSwgZXRjLlxyXG4qIEBwYXJhbSB7YXJyYXl9IFtyZXN1bHRzXSAtIFRoZSBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9uZSB3aWxsIGJlIGdlbmVyYXRlZC5cclxuKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMuXHJcbiovXHJcbnZhciBHZXRQb2ludHNPbkxpbmUgPSBmdW5jdGlvbiAobGluZSwgc3RlcFJhdGUsIHJlc3VsdHMpXHJcbntcclxuICAgIGlmIChzdGVwUmF0ZSA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBSYXRlID0gMTsgfVxyXG4gICAgaWYgKHJlc3VsdHMgPT09IHVuZGVmaW5lZCkgeyByZXN1bHRzID0gW107IH1cclxuXHJcbiAgICB2YXIgeDEgPSBNYXRoLnJvdW5kKGxpbmUueDEpO1xyXG4gICAgdmFyIHkxID0gTWF0aC5yb3VuZChsaW5lLnkxKTtcclxuICAgIHZhciB4MiA9IE1hdGgucm91bmQobGluZS54Mik7XHJcbiAgICB2YXIgeTIgPSBNYXRoLnJvdW5kKGxpbmUueTIpO1xyXG5cclxuICAgIHZhciBkeCA9IE1hdGguYWJzKHgyIC0geDEpO1xyXG4gICAgdmFyIGR5ID0gTWF0aC5hYnMoeTIgLSB5MSk7XHJcbiAgICB2YXIgc3ggPSAoeDEgPCB4MikgPyAxIDogLTE7XHJcbiAgICB2YXIgc3kgPSAoeTEgPCB5MikgPyAxIDogLTE7XHJcbiAgICB2YXIgZXJyID0gZHggLSBkeTtcclxuXHJcbiAgICByZXN1bHRzLnB1c2goWyB4MSwgeTEgXSk7XHJcblxyXG4gICAgdmFyIGkgPSAxO1xyXG5cclxuICAgIHdoaWxlICghKCh4MSA9PT0geDIpICYmICh5MSA9PT0geTIpKSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZTIgPSBlcnIgPDwgMTtcclxuXHJcbiAgICAgICAgaWYgKGUyID4gLWR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXJyIC09IGR5O1xyXG4gICAgICAgICAgICB4MSArPSBzeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlMiA8IGR4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXJyICs9IGR4O1xyXG4gICAgICAgICAgICB5MSArPSBzeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpICUgc3RlcFJhdGUgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goWyB4MSwgeTEgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvaW50c09uTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFJvdGF0ZUFyb3VuZFhZID0gZnVuY3Rpb24gKGxpbmUsIHgsIHksIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgIHZhciB0eCA9IGxpbmUueDEgLSB4O1xyXG4gICAgdmFyIHR5ID0gbGluZS55MSAtIHk7XHJcblxyXG4gICAgbGluZS54MSA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICBsaW5lLnkxID0gdHggKiBzICsgdHkgKiBjICsgeTtcclxuXHJcbiAgICB0eCA9IGxpbmUueDIgLSB4O1xyXG4gICAgdHkgPSBsaW5lLnkyIC0geTtcclxuXHJcbiAgICBsaW5lLngyID0gdHggKiBjIC0gdHkgKiBzICsgeDtcclxuICAgIGxpbmUueTIgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRYWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLngpICsgKHBvaW50QS55ICogcG9pbnRCLnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRG90O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvRG90LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHJlY3QueCA8PSB4ICYmIHJlY3QueCArIHJlY3Qud2lkdGggPj0geCAmJiByZWN0LnkgPD0geSAmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB5KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKHJlY3QuaGVpZ2h0ID09PSAwKSA/IE5hTiA6IHJlY3Qud2lkdGggLyByZWN0LmhlaWdodDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QXNwZWN0UmF0aW87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvXHJcblxyXG4vLyAgcG9pbnRzIGlzIGFuIGFycmF5IG9mIFBvaW50LWxpa2Ugb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG4vLyAgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBwb2ludHMgdGhhdCBhcmUgd2l0aGluIHRoZSB0cmlhbmdsZSwgb3IgYW4gZW1wdHkgYXJyYXkgaWYgbm9uZVxyXG4vLyAgaWYgJ3JldHVybkZpcnN0JyBpcyB0cnVlIGl0IHdpbGwgcmV0dXJuIGFmdGVyIHRoZSBmaXJzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlIGlzIGZvdW5kXHJcblxyXG52YXIgQ29udGFpbnNBcnJheSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgcG9pbnRzLCByZXR1cm5GaXJzdCwgb3V0KVxyXG57XHJcbiAgICBpZiAocmV0dXJuRmlyc3QgPT09IHVuZGVmaW5lZCkgeyByZXR1cm5GaXJzdCA9IGZhbHNlOyB9XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gW107IH1cclxuXHJcbiAgICB2YXIgdjB4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB2MHkgPSB0cmlhbmdsZS55MyAtIHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIHZhciB2MXggPSB0cmlhbmdsZS54MiAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHYxeSA9IHRyaWFuZ2xlLnkyIC0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIGRvdDAwID0gKHYweCAqIHYweCkgKyAodjB5ICogdjB5KTtcclxuICAgIHZhciBkb3QwMSA9ICh2MHggKiB2MXgpICsgKHYweSAqIHYxeSk7XHJcbiAgICB2YXIgZG90MTEgPSAodjF4ICogdjF4KSArICh2MXkgKiB2MXkpO1xyXG5cclxuICAgIC8vIENvbXB1dGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuICAgIHZhciBiID0gKChkb3QwMCAqIGRvdDExKSAtIChkb3QwMSAqIGRvdDAxKSk7XHJcbiAgICB2YXIgaW52ID0gKGIgPT09IDApID8gMCA6ICgxIC8gYik7XHJcblxyXG4gICAgdmFyIHU7XHJcbiAgICB2YXIgdjtcclxuICAgIHZhciB2Mng7XHJcbiAgICB2YXIgdjJ5O1xyXG4gICAgdmFyIGRvdDAyO1xyXG4gICAgdmFyIGRvdDEyO1xyXG5cclxuICAgIHZhciB4MSA9IHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdjJ4ID0gcG9pbnRzW2ldLnggLSB4MTtcclxuICAgICAgICB2MnkgPSBwb2ludHNbaV0ueSAtIHkxO1xyXG5cclxuICAgICAgICBkb3QwMiA9ICh2MHggKiB2MngpICsgKHYweSAqIHYyeSk7XHJcbiAgICAgICAgZG90MTIgPSAodjF4ICogdjJ4KSArICh2MXkgKiB2MnkpO1xyXG5cclxuICAgICAgICB1ID0gKChkb3QxMSAqIGRvdDAyKSAtIChkb3QwMSAqIGRvdDEyKSkgKiBpbnY7XHJcbiAgICAgICAgdiA9ICgoZG90MDAgKiBkb3QxMikgLSAoZG90MDEgKiBkb3QwMikpICogaW52O1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHUgPj0gMCAmJiB2ID49IDAgJiYgKHUgKyB2IDwgMSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXQucHVzaCh7IHg6IHBvaW50c1tpXS54LCB5OiBwb2ludHNbaV0ueSB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0NvbnRhaW5zQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgUm90YXRlQXJvdW5kWFkgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHgsIHksIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgIHZhciB0eCA9IHRyaWFuZ2xlLngxIC0geDtcclxuICAgIHZhciB0eSA9IHRyaWFuZ2xlLnkxIC0geTtcclxuXHJcbiAgICB0cmlhbmdsZS54MSA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICB0cmlhbmdsZS55MSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgdHggPSB0cmlhbmdsZS54MiAtIHg7XHJcbiAgICB0eSA9IHRyaWFuZ2xlLnkyIC0geTtcclxuXHJcbiAgICB0cmlhbmdsZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICB0cmlhbmdsZS55MiA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgdHggPSB0cmlhbmdsZS54MyAtIHg7XHJcbiAgICB0eSA9IHRyaWFuZ2xlLnkzIC0geTtcclxuXHJcbiAgICB0cmlhbmdsZS54MyA9IHR4ICogYyAtIHR5ICogcyArIHg7XHJcbiAgICB0cmlhbmdsZS55MyA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgcmV0dXJuIHRyaWFuZ2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRYWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL1JvdGF0ZUFyb3VuZFhZLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogR2l2ZW4gMyBjb2xvciB2YWx1ZXMgdGhpcyB3aWxsIHJldHVybiBhbiBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGdldENvbG9yXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gciAtIFRoZSByZWQgY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGcgLSBUaGUgZ3JlZW4gY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmx1ZSBjb2xvciBjb21wb25lbnQgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXHJcbiAqIEByZXR1cm4ge2ludGVnZXJ9IEEgbmF0aXZlIGNvbG9yIHZhbHVlIGludGVnZXIgKGZvcm1hdDogMHhSUkdHQkIpLlxyXG4gKi9cclxudmFyIEdldENvbG9yID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpXHJcbntcclxuICAgIHJldHVybiByZWQgPDwgMTYgfCBncmVlbiA8PCA4IHwgYmx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQkFDS1NQQUNFOiA4LFxyXG4gICAgVEFCOiA5LFxyXG4gICAgRU5URVI6IDEzLFxyXG5cclxuICAgIFNISUZUOiAxNixcclxuICAgIENUUkw6IDE3LFxyXG4gICAgQUxUOiAxOCxcclxuXHJcbiAgICBQQVVTRTogMTksXHJcbiAgICBDQVBTX0xPQ0s6IDIwLFxyXG4gICAgRVNDOiAyNyxcclxuICAgIFNQQUNFOiAzMixcclxuXHJcbiAgICBQQUdFX1VQOiAzMyxcclxuICAgIFBBR0VfRE9XTjogMzQsXHJcbiAgICBFTkQ6IDM1LFxyXG4gICAgSE9NRTogMzYsXHJcblxyXG4gICAgTEVGVDogMzcsXHJcbiAgICBVUDogMzgsXHJcbiAgICBSSUdIVDogMzksXHJcbiAgICBET1dOOiA0MCxcclxuXHJcbiAgICBQUklOVF9TQ1JFRU46IDQyLFxyXG4gICAgSU5TRVJUOiA0NSxcclxuICAgIERFTEVURTogNDYsXHJcblxyXG4gICAgWkVSTzogNDgsXHJcbiAgICBPTkU6IDQ5LFxyXG4gICAgVFdPOiA1MCxcclxuICAgIFRIUkVFOiA1MSxcclxuICAgIEZPVVI6IDUyLFxyXG4gICAgRklWRTogNTMsXHJcbiAgICBTSVg6IDU0LFxyXG4gICAgU0VWRU46IDU1LFxyXG4gICAgRUlHSFQ6IDU2LFxyXG4gICAgTklORTogNTcsXHJcblxyXG4gICAgQTogNjUsXHJcbiAgICBCOiA2NixcclxuICAgIEM6IDY3LFxyXG4gICAgRDogNjgsXHJcbiAgICBFOiA2OSxcclxuICAgIEY6IDcwLFxyXG4gICAgRzogNzEsXHJcbiAgICBIOiA3MixcclxuICAgIEk6IDczLFxyXG4gICAgSjogNzQsXHJcbiAgICBLOiA3NSxcclxuICAgIEw6IDc2LFxyXG4gICAgTTogNzcsXHJcbiAgICBOOiA3OCxcclxuICAgIE86IDc5LFxyXG4gICAgUDogODAsXHJcbiAgICBROiA4MSxcclxuICAgIFI6IDgyLFxyXG4gICAgUzogODMsXHJcbiAgICBUOiA4NCxcclxuICAgIFU6IDg1LFxyXG4gICAgVjogODYsXHJcbiAgICBXOiA4NyxcclxuICAgIFg6IDg4LFxyXG4gICAgWTogODksXHJcbiAgICBaOiA5MCxcclxuXHJcbiAgICBGMTogMTEyLFxyXG4gICAgRjI6IDExMyxcclxuICAgIEYzOiAxMTQsXHJcbiAgICBGNDogMTE1LFxyXG4gICAgRjU6IDExNixcclxuICAgIEY2OiAxMTcsXHJcbiAgICBGNzogMTE4LFxyXG4gICAgRjg6IDExOSxcclxuICAgIEY5OiAxMjAsXHJcbiAgICBGMTA6IDEyMSxcclxuICAgIEYxMTogMTIyLFxyXG4gICAgRjEyOiAxMjMsXHJcblxyXG4gICAgU0VNSUNPTE9OOiAxODYsXHJcbiAgICBQTFVTOiAxODcsXHJcbiAgICBDT01NQTogMTg4LFxyXG4gICAgTUlOVVM6IDE4OSxcclxuICAgIFBFUklPRDogMTkwLFxyXG4gICAgRk9SV0FEX1NMQVNIOiAxOTEsXHJcbiAgICBCQUNLX1NMQVNIOiAyMjAsXHJcbiAgICBRVU9URVM6IDIyMlxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvS2V5Q29kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDcmVhdGVzIGFuIFhIUlNldHRpbmdzIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblxyXG52YXIgWEhSU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUeXBlLCBhc3luYywgdXNlciwgcGFzc3dvcmQsIHRpbWVvdXQpXHJcbntcclxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgeyByZXNwb25zZVR5cGUgPSAnJzsgfVxyXG4gICAgaWYgKGFzeW5jID09PSB1bmRlZmluZWQpIHsgYXN5bmMgPSB0cnVlOyB9XHJcbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkKSB7IHVzZXIgPSAnJzsgfVxyXG4gICAgaWYgKHBhc3N3b3JkID09PSB1bmRlZmluZWQpIHsgcGFzc3dvcmQgPSAnJzsgfVxyXG4gICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkgeyB0aW1lb3V0ID0gMDsgfVxyXG5cclxuICAgIC8vIEJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCwgc2V0IHRoZSB4aHIucmVzcG9uc2VUeXBlIHRvIFwidGV4dFwiLCBcclxuICAgIC8vIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIG9yIFwiZG9jdW1lbnRcIiwgZGVwZW5kaW5nIG9uIHlvdXIgZGF0YSBuZWVkcy4gXHJcbiAgICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIElnbm9yZWQgYnkgdGhlIExvYWRlciwgb25seSB1c2VkIGJ5IEZpbGUuXHJcbiAgICAgICAgcmVzcG9uc2VUeXBlOiByZXNwb25zZVR5cGUsXHJcblxyXG4gICAgICAgIGFzeW5jOiBhc3luYyxcclxuXHJcbiAgICAgICAgLy8gIGNyZWRlbnRpYWxzXHJcbiAgICAgICAgdXNlcjogdXNlcixcclxuICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcblxyXG4gICAgICAgIC8vICB0aW1lb3V0IGluIG1zICgwID0gbm8gdGltZW91dClcclxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxyXG5cclxuICAgICAgICAvLyAgc2V0UmVxdWVzdEhlYWRlclxyXG4gICAgICAgIGhlYWRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlYWRlclZhbHVlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgIC8vICBvdmVycmlkZU1pbWVUeXBlXHJcbiAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogdW5kZWZpbmVkXHJcblxyXG4gICAgfTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYSFJTZXR0aW5ncztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvWEhSU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBKU09ORmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5qc29uXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLmpzb24nO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdqc29uJywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuSlNPTkZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcbkpTT05GaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpTT05GaWxlO1xyXG5cclxuSlNPTkZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dCk7XHJcblxyXG4gICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05GaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0JldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllcywgdGhlIGl0ZW0gdG8gYmUgcm90YXRlZFxyXG4vLyAgeC95ID0gdGhlIGNvb3JkaW5hdGUgdG8gcm90YXRlIGFyb3VuZFxyXG4vLyAgYW5nbGUgPSByYWRpYW5zXHJcbi8vICBkaXN0YW5jZSA9IGluIHB4XHJcblxyXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSlcclxue1xyXG4gICAgdmFyIHQgPSBhbmdsZSArIE1hdGguYXRhbjIocG9pbnQueSAtIHksIHBvaW50LnggLSB4KTtcclxuXHJcbiAgICBwb2ludC54ID0geCArIChkaXN0YW5jZSAqIE1hdGguY29zKHQpKTtcclxuICAgIHBvaW50LnkgPSB5ICsgKGRpc3RhbmNlICogTWF0aC5zaW4odCkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kRGlzdGFuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlQmV0d2VlbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgdmFyIGR4ID0geDEgLSB4MjtcclxuICAgIHZhciBkeSA9IHkxIC0geTI7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29sbGlzaW9uIFR5cGVzIC0gRGV0ZXJtaW5lIGlmIGFuZCBob3cgZW50aXRpZXMgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXJcclxuXHJcbi8vIEluIEFDVElWRSB2cy4gTElURSBvciBGSVhFRCB2cy4gQU5ZIGNvbGxpc2lvbnMsIG9ubHkgdGhlIFwid2Vha1wiIGVudGl0eSBtb3ZlcyxcclxuLy8gd2hpbGUgdGhlIG90aGVyIG9uZSBzdGF5cyBmaXhlZC4gSW4gQUNUSVZFIHZzLiBBQ1RJVkUgYW5kIEFDVElWRSB2cy4gUEFTU0lWRVxyXG4vLyBjb2xsaXNpb25zLCBib3RoIGVudGl0aWVzIGFyZSBtb3ZlZC4gTElURSBvciBQQVNTSVZFIGVudGl0aWVzIGRvbid0IGNvbGxpZGVcclxuLy8gd2l0aCBvdGhlciBMSVRFIG9yIFBBU1NJVkUgZW50aXRpZXMgYXQgYWxsLiBUaGUgYmVoYWl2aW91ciBmb3IgRklYRUQgdnMuXHJcbi8vIEZJWEVEIGNvbGxpc2lvbnMgaXMgdW5kZWZpbmVkLlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTk9ORTogMCxcclxuICAgIEE6IDEsXHJcbiAgICBCOiAyLFxyXG4gICAgQk9USDogM1xyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9UWVBFLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5EZXRlY3RvcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGRldGVjdGluZyBjb2xsaXNpb25zIGdpdmVuIGEgc2V0IG9mIHBhaXJzLlxyXG4qXHJcbiogQGNsYXNzIERldGVjdG9yXHJcbiovXHJcblxyXG4vLyBUT0RPOiBzcGVjdWxhdGl2ZSBjb250YWN0c1xyXG5cclxudmFyIERldGVjdG9yID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERldGVjdG9yO1xyXG5cclxudmFyIFNBVCA9IHJlcXVpcmUoJy4vU0FUJyk7XHJcbnZhciBQYWlyID0gcmVxdWlyZSgnLi9QYWlyJyk7XHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGFsbCBjb2xsaXNpb25zIGdpdmVuIGEgbGlzdCBvZiBwYWlycy5cclxuICAgICAqIEBtZXRob2QgY29sbGlzaW9uc1xyXG4gICAgICogQHBhcmFtIHtwYWlyW119IGJyb2FkcGhhc2VQYWlyc1xyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICogQHJldHVybiB7YXJyYXl9IGNvbGxpc2lvbnNcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IuY29sbGlzaW9ucyA9IGZ1bmN0aW9uKGJyb2FkcGhhc2VQYWlycywgZW5naW5lKSB7XHJcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBbXSxcclxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IGVuZ2luZS5wYWlycy50YWJsZTtcclxuXHJcbiAgICAgICAgLy8gQGlmIERFQlVHXHJcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBlbmdpbmUubWV0cmljcztcclxuICAgICAgICAvLyBAZW5kaWZcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb2FkcGhhc2VQYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBicm9hZHBoYXNlUGFpcnNbaV1bMF0sIFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBicm9hZHBoYXNlUGFpcnNbaV1bMV07XHJcblxyXG4gICAgICAgICAgICBpZiAoKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpICYmIChib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHlBLmNvbGxpc2lvbkZpbHRlciwgYm9keUIuY29sbGlzaW9uRmlsdGVyKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gQGlmIERFQlVHXHJcbiAgICAgICAgICAgIG1ldHJpY3MubWlkcGhhc2VUZXN0cyArPSAxO1xyXG4gICAgICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgICAgIC8vIG1pZCBwaGFzZVxyXG4gICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKGJvZHlBLmJvdW5kcywgYm9keUIuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHlBLnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IGJvZHlBLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gYm9keUEucGFydHNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBib2R5Qi5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5Qi5wYXJ0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEIgPSBib2R5Qi5wYXJ0c1trXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGFydEEgPT09IGJvZHlBICYmIHBhcnRCID09PSBib2R5QikgfHwgQm91bmRzLm92ZXJsYXBzKHBhcnRBLmJvdW5kcywgcGFydEIuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBhIHByZXZpb3VzIGNvbGxpc2lvbiB3ZSBjb3VsZCByZXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJJZCA9IFBhaXIuaWQocGFydEEsIHBhcnRCKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyID0gcGFpcnNUYWJsZVtwYWlySWRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29sbGlzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyICYmIHBhaXIuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbGxpc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmFycm93IHBoYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gU0FULmNvbGxpZGVzKHBhcnRBLCBwYXJ0QiwgcHJldmlvdXNDb2xsaXNpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBpZiBERUJVR1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dwaGFzZVRlc3RzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLnJldXNlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLm5hcnJvd1JldXNlQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uY29sbGlkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zLnB1c2goY29sbGlzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnMgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAZW5kaWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBzdXBwbGllZCBjb2xsaXNpb24gZmlsdGVycyB3aWxsIGFsbG93IGEgY29sbGlzaW9uIHRvIG9jY3VyLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIGNhbkNvbGxpZGVcclxuICAgICAqIEBwYXJhbSB7fSBmaWx0ZXJBXHJcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQlxyXG4gICAgICogQHJldHVybiB7Ym9vbH0gYHRydWVgIGlmIGNvbGxpc2lvbiBjYW4gb2NjdXJcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IuY2FuQ29sbGlkZSA9IGZ1bmN0aW9uKGZpbHRlckEsIGZpbHRlckIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyQS5ncm91cCA9PT0gZmlsdGVyQi5ncm91cCAmJiBmaWx0ZXJBLmdyb3VwICE9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyQS5ncm91cCA+IDA7XHJcblxyXG4gICAgICAgIHJldHVybiAoZmlsdGVyQS5tYXNrICYgZmlsdGVyQi5jYXRlZ29yeSkgIT09IDAgJiYgKGZpbHRlckIubWFzayAmIGZpbHRlckEuY2F0ZWdvcnkpICE9PSAwO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0RldGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5HcmlkYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gYnJvYWRwaGFzZSBncmlkIHN0cnVjdHVyZXMuXHJcbipcclxuKiBAY2xhc3MgR3JpZFxyXG4qL1xyXG5cclxudmFyIEdyaWQgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcclxuXHJcbnZhciBQYWlyID0gcmVxdWlyZSgnLi9QYWlyJyk7XHJcbnZhciBEZXRlY3RvciA9IHJlcXVpcmUoJy4vRGV0ZWN0b3InKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGdyaWQuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge2dyaWR9IEEgbmV3IGdyaWRcclxuICAgICAqL1xyXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyOiBHcmlkLFxyXG4gICAgICAgICAgICBkZXRlY3RvcjogRGV0ZWN0b3IuY29sbGlzaW9ucyxcclxuICAgICAgICAgICAgYnVja2V0czoge30sXHJcbiAgICAgICAgICAgIHBhaXJzOiB7fSxcclxuICAgICAgICAgICAgcGFpcnNMaXN0OiBbXSxcclxuICAgICAgICAgICAgYnVja2V0V2lkdGg6IDQ4LFxyXG4gICAgICAgICAgICBidWNrZXRIZWlnaHQ6IDQ4XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYnVja2V0V2lkdGhcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgNDhcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYnVja2V0SGVpZ2h0XHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDQ4XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdyaWQuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEdyaWQudXBkYXRlID0gZnVuY3Rpb24oZ3JpZCwgYm9kaWVzLCBlbmdpbmUsIGZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIGksIGNvbCwgcm93LFxyXG4gICAgICAgICAgICB3b3JsZCA9IGVuZ2luZS53b3JsZCxcclxuICAgICAgICAgICAgYnVja2V0cyA9IGdyaWQuYnVja2V0cyxcclxuICAgICAgICAgICAgYnVja2V0LFxyXG4gICAgICAgICAgICBidWNrZXRJZCxcclxuICAgICAgICAgICAgZ3JpZENoYW5nZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gQGlmIERFQlVHXHJcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBlbmdpbmUubWV0cmljcztcclxuICAgICAgICBtZXRyaWNzLmJyb2FkcGhhc2VUZXN0cyA9IDA7XHJcbiAgICAgICAgLy8gQGVuZGlmXHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5pc1NsZWVwaW5nICYmICFmb3JjZVVwZGF0ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIG91dCBvZiB3b3JsZCBib2RpZXNcclxuICAgICAgICAgICAgaWYgKGJvZHkuYm91bmRzLm1heC54IDwgd29ybGQuYm91bmRzLm1pbi54IHx8IGJvZHkuYm91bmRzLm1pbi54ID4gd29ybGQuYm91bmRzLm1heC54XHJcbiAgICAgICAgICAgICAgICB8fCBib2R5LmJvdW5kcy5tYXgueSA8IHdvcmxkLmJvdW5kcy5taW4ueSB8fCBib2R5LmJvdW5kcy5taW4ueSA+IHdvcmxkLmJvdW5kcy5tYXgueSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1JlZ2lvbiA9IF9nZXRSZWdpb24oZ3JpZCwgYm9keSk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgYm9keSBoYXMgY2hhbmdlZCBncmlkIHJlZ2lvblxyXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IG5ld1JlZ2lvbi5pZCAhPT0gYm9keS5yZWdpb24uaWQgfHwgZm9yY2VVcGRhdGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAgICAgICAgIG1ldHJpY3MuYnJvYWRwaGFzZVRlc3RzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IGZvcmNlVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkucmVnaW9uID0gbmV3UmVnaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IF9yZWdpb25VbmlvbihuZXdSZWdpb24sIGJvZHkucmVnaW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZ3JpZCBidWNrZXRzIGFmZmVjdGVkIGJ5IHJlZ2lvbiBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgdW5pb24gb2YgYm90aCByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IHVuaW9uLnN0YXJ0Q29sOyBjb2wgPD0gdW5pb24uZW5kQ29sOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gdW5pb24uc3RhcnRSb3c7IHJvdyA8PSB1bmlvbi5lbmRSb3c7IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldElkID0gX2dldEJ1Y2tldElkKGNvbCwgcm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gYnVja2V0c1tidWNrZXRJZF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJbnNpZGVOZXdSZWdpb24gPSAoY29sID49IG5ld1JlZ2lvbi5zdGFydENvbCAmJiBjb2wgPD0gbmV3UmVnaW9uLmVuZENvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByb3cgPj0gbmV3UmVnaW9uLnN0YXJ0Um93ICYmIHJvdyA8PSBuZXdSZWdpb24uZW5kUm93KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luc2lkZU9sZFJlZ2lvbiA9IChjb2wgPj0gYm9keS5yZWdpb24uc3RhcnRDb2wgJiYgY29sIDw9IGJvZHkucmVnaW9uLmVuZENvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByb3cgPj0gYm9keS5yZWdpb24uc3RhcnRSb3cgJiYgcm93IDw9IGJvZHkucmVnaW9uLmVuZFJvdyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBvbGQgcmVnaW9uIGJ1Y2tldHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0luc2lkZU5ld1JlZ2lvbiAmJiBpc0luc2lkZU9sZFJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5zaWRlT2xkUmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Y2tldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2J1Y2tldFJlbW92ZUJvZHkoZ3JpZCwgYnVja2V0LCBib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRvIG5ldyByZWdpb24gYnVja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5yZWdpb24gPT09IG5ld1JlZ2lvbiB8fCAoaXNJbnNpZGVOZXdSZWdpb24gJiYgIWlzSW5zaWRlT2xkUmVnaW9uKSB8fCBmb3JjZVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidWNrZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX2NyZWF0ZUJ1Y2tldChidWNrZXRzLCBidWNrZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYnVja2V0QWRkQm9keShncmlkLCBidWNrZXQsIGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbmV3IHJlZ2lvblxyXG4gICAgICAgICAgICAgICAgYm9keS5yZWdpb24gPSBuZXdSZWdpb247XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGFuZ2VzIHNvIHdlIGNhbiB1cGRhdGUgcGFpcnNcclxuICAgICAgICAgICAgICAgIGdyaWRDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHBhaXJzIGxpc3Qgb25seSBpZiBwYWlycyBjaGFuZ2VkIChpLmUuIGEgYm9keSBjaGFuZ2VkIHJlZ2lvbilcclxuICAgICAgICBpZiAoZ3JpZENoYW5nZWQpXHJcbiAgICAgICAgICAgIGdyaWQucGFpcnNMaXN0ID0gX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdChncmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGdyaWQuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKiBAcGFyYW0ge2dyaWR9IGdyaWRcclxuICAgICAqL1xyXG4gICAgR3JpZC5jbGVhciA9IGZ1bmN0aW9uKGdyaWQpIHtcclxuICAgICAgICBncmlkLmJ1Y2tldHMgPSB7fTtcclxuICAgICAgICBncmlkLnBhaXJzID0ge307XHJcbiAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBbXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgdW5pb24gb2YgdHdvIHJlZ2lvbnMuXHJcbiAgICAgKiBAbWV0aG9kIF9yZWdpb25VbmlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSByZWdpb25BXHJcbiAgICAgKiBAcGFyYW0ge30gcmVnaW9uQlxyXG4gICAgICogQHJldHVybiB7fSByZWdpb25cclxuICAgICAqL1xyXG4gICAgdmFyIF9yZWdpb25VbmlvbiA9IGZ1bmN0aW9uKHJlZ2lvbkEsIHJlZ2lvbkIpIHtcclxuICAgICAgICB2YXIgc3RhcnRDb2wgPSBNYXRoLm1pbihyZWdpb25BLnN0YXJ0Q29sLCByZWdpb25CLnN0YXJ0Q29sKSxcclxuICAgICAgICAgICAgZW5kQ29sID0gTWF0aC5tYXgocmVnaW9uQS5lbmRDb2wsIHJlZ2lvbkIuZW5kQ29sKSxcclxuICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLm1pbihyZWdpb25BLnN0YXJ0Um93LCByZWdpb25CLnN0YXJ0Um93KSxcclxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5tYXgocmVnaW9uQS5lbmRSb3csIHJlZ2lvbkIuZW5kUm93KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSZWdpb24oc3RhcnRDb2wsIGVuZENvbCwgc3RhcnRSb3csIGVuZFJvdyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcmVnaW9uIGEgZ2l2ZW4gYm9keSBmYWxscyBpbiBmb3IgYSBnaXZlbiBncmlkLlxyXG4gICAgICogQG1ldGhvZCBfZ2V0UmVnaW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGdyaWRcclxuICAgICAqIEBwYXJhbSB7fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICB2YXIgX2dldFJlZ2lvbiA9IGZ1bmN0aW9uKGdyaWQsIGJvZHkpIHtcclxuICAgICAgICB2YXIgYm91bmRzID0gYm9keS5ib3VuZHMsXHJcbiAgICAgICAgICAgIHN0YXJ0Q29sID0gTWF0aC5mbG9vcihib3VuZHMubWluLnggLyBncmlkLmJ1Y2tldFdpZHRoKSxcclxuICAgICAgICAgICAgZW5kQ29sID0gTWF0aC5mbG9vcihib3VuZHMubWF4LnggLyBncmlkLmJ1Y2tldFdpZHRoKSxcclxuICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSAvIGdyaWQuYnVja2V0SGVpZ2h0KSxcclxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLyBncmlkLmJ1Y2tldEhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY3JlYXRlUmVnaW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByZWdpb24uXHJcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVSZWdpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gc3RhcnRDb2xcclxuICAgICAqIEBwYXJhbSB7fSBlbmRDb2xcclxuICAgICAqIEBwYXJhbSB7fSBzdGFydFJvd1xyXG4gICAgICogQHBhcmFtIHt9IGVuZFJvd1xyXG4gICAgICogQHJldHVybiB7fSByZWdpb25cclxuICAgICAqL1xyXG4gICAgdmFyIF9jcmVhdGVSZWdpb24gPSBmdW5jdGlvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgIGlkOiBzdGFydENvbCArICcsJyArIGVuZENvbCArICcsJyArIHN0YXJ0Um93ICsgJywnICsgZW5kUm93LFxyXG4gICAgICAgICAgICBzdGFydENvbDogc3RhcnRDb2wsIFxyXG4gICAgICAgICAgICBlbmRDb2w6IGVuZENvbCwgXHJcbiAgICAgICAgICAgIHN0YXJ0Um93OiBzdGFydFJvdywgXHJcbiAgICAgICAgICAgIGVuZFJvdzogZW5kUm93IFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYnVja2V0IGlkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAqIEBtZXRob2QgX2dldEJ1Y2tldElkXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGNvbHVtblxyXG4gICAgICogQHBhcmFtIHt9IHJvd1xyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBidWNrZXQgaWRcclxuICAgICAqL1xyXG4gICAgdmFyIF9nZXRCdWNrZXRJZCA9IGZ1bmN0aW9uKGNvbHVtbiwgcm93KSB7XHJcbiAgICAgICAgcmV0dXJuICdDJyArIGNvbHVtbiArICdSJyArIHJvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYnVja2V0LlxyXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQnVja2V0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldHNcclxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRJZFxyXG4gICAgICogQHJldHVybiB7fSBidWNrZXRcclxuICAgICAqL1xyXG4gICAgdmFyIF9jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbihidWNrZXRzLCBidWNrZXRJZCkge1xyXG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBidWNrZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGJvZHkgdG8gYSBidWNrZXQuXHJcbiAgICAgKiBAbWV0aG9kIF9idWNrZXRBZGRCb2R5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGdyaWRcclxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcclxuICAgICAqIEBwYXJhbSB7fSBib2R5XHJcbiAgICAgKi9cclxuICAgIHZhciBfYnVja2V0QWRkQm9keSA9IGZ1bmN0aW9uKGdyaWQsIGJ1Y2tldCwgYm9keSkge1xyXG4gICAgICAgIC8vIGFkZCBuZXcgcGFpcnNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keUIgPSBidWNrZXRbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5pZCA9PT0gYm9keUIuaWQgfHwgKGJvZHkuaXNTdGF0aWMgJiYgYm9keUIuaXNTdGF0aWMpKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBHcmlkLnVwZGF0ZSB0byB3b3JrXHJcbiAgICAgICAgICAgIHZhciBwYWlySWQgPSBQYWlyLmlkKGJvZHksIGJvZHlCKSxcclxuICAgICAgICAgICAgICAgIHBhaXIgPSBncmlkLnBhaXJzW3BhaXJJZF07XHJcblxyXG4gICAgICAgICAgICBpZiAocGFpcikge1xyXG4gICAgICAgICAgICAgICAgcGFpclsyXSArPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ3JpZC5wYWlyc1twYWlySWRdID0gW2JvZHksIGJvZHlCLCAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIHRvIGJvZGllcyAoYWZ0ZXIgcGFpcnMsIG90aGVyd2lzZSBwYWlycyB3aXRoIHNlbGYpXHJcbiAgICAgICAgYnVja2V0LnB1c2goYm9keSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSBhIGJ1Y2tldC5cclxuICAgICAqIEBtZXRob2QgX2J1Y2tldFJlbW92ZUJvZHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxyXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldFxyXG4gICAgICogQHBhcmFtIHt9IGJvZHlcclxuICAgICAqL1xyXG4gICAgdmFyIF9idWNrZXRSZW1vdmVCb2R5ID0gZnVuY3Rpb24oZ3JpZCwgYnVja2V0LCBib2R5KSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gYnVja2V0XHJcbiAgICAgICAgYnVja2V0LnNwbGljZShDb21tb24uaW5kZXhPZihidWNrZXQsIGJvZHkpLCAxKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHBhaXIgY291bnRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGJ1Y2tldHMgdGhlIHBhaXIgZXhpc3RzIGluXHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCB0byB3b3JrXHJcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGJ1Y2tldFtpXSxcclxuICAgICAgICAgICAgICAgIHBhaXJJZCA9IFBhaXIuaWQoYm9keSwgYm9keUIpLFxyXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcklkXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYWlyKVxyXG4gICAgICAgICAgICAgICAgcGFpclsyXSAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHRoZSBhY3RpdmUgcGFpcnMgaW4gdGhlIGdyaWQuXHJcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVBY3RpdmVQYWlyc0xpc3RcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxyXG4gICAgICogQHJldHVybiBbXSBwYWlyc1xyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCA9IGZ1bmN0aW9uKGdyaWQpIHtcclxuICAgICAgICB2YXIgcGFpcktleXMsXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIHBhaXJzID0gW107XHJcblxyXG4gICAgICAgIC8vIGdyaWQucGFpcnMgaXMgdXNlZCBhcyBhIGhhc2htYXBcclxuICAgICAgICBwYWlyS2V5cyA9IENvbW1vbi5rZXlzKGdyaWQucGFpcnMpO1xyXG5cclxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgZ3JpZC5wYWlyc1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpcktleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcktleXNba11dO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgcGFpciBleGlzdHMgaW4gYXQgbGVhc3Qgb25lIGJ1Y2tldFxyXG4gICAgICAgICAgICAvLyBpdCBpcyBhIHBhaXIgdGhhdCBuZWVkcyBmdXJ0aGVyIGNvbGxpc2lvbiB0ZXN0aW5nIHNvIHB1c2ggaXRcclxuICAgICAgICAgICAgaWYgKHBhaXJbMl0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdyaWQucGFpcnNbcGFpcktleXNba11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFpcnM7XHJcbiAgICB9O1xyXG4gICAgXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlNBVGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGRldGVjdGluZyBjb2xsaXNpb25zIHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbS5cclxuKlxyXG4qIEBjbGFzcyBTQVRcclxuKi9cclxuXHJcbi8vIFRPRE86IHRydWUgY2lyY2xlcyBhbmQgY3VydmVzXHJcblxyXG52YXIgU0FUID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNBVDtcclxuXHJcbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVjdCBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzIHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbS5cclxuICAgICAqIEBtZXRob2QgY29sbGlkZXNcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9ufSBwcmV2aW91c0NvbGxpc2lvblxyXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9ufSBjb2xsaXNpb25cclxuICAgICAqL1xyXG4gICAgU0FULmNvbGxpZGVzID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBwcmV2aW91c0NvbGxpc2lvbikge1xyXG4gICAgICAgIHZhciBvdmVybGFwQUIsXHJcbiAgICAgICAgICAgIG92ZXJsYXBCQSwgXHJcbiAgICAgICAgICAgIG1pbk92ZXJsYXAsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgY2FuUmV1c2VQcmV2Q29sID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChwcmV2aW91c0NvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAvLyBlc3RpbWF0ZSB0b3RhbCBtb3Rpb25cclxuICAgICAgICAgICAgdmFyIHBhcmVudEEgPSBib2R5QS5wYXJlbnQsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRCID0gYm9keUIucGFyZW50LFxyXG4gICAgICAgICAgICAgICAgbW90aW9uID0gcGFyZW50QS5zcGVlZCAqIHBhcmVudEEuc3BlZWQgKyBwYXJlbnRBLmFuZ3VsYXJTcGVlZCAqIHBhcmVudEEuYW5ndWxhclNwZWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgKyBwYXJlbnRCLnNwZWVkICogcGFyZW50Qi5zcGVlZCArIHBhcmVudEIuYW5ndWxhclNwZWVkICogcGFyZW50Qi5hbmd1bGFyU3BlZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyB3ZSBtYXkgYmUgYWJsZSB0byAocGFydGlhbGx5KSByZXVzZSBjb2xsaXNpb24gcmVzdWx0IFxyXG4gICAgICAgICAgICAvLyBidXQgb25seSBzYWZlIGlmIGNvbGxpc2lvbiB3YXMgcmVzdGluZ1xyXG4gICAgICAgICAgICBjYW5SZXVzZVByZXZDb2wgPSBwcmV2aW91c0NvbGxpc2lvbiAmJiBwcmV2aW91c0NvbGxpc2lvbi5jb2xsaWRlZCAmJiBtb3Rpb24gPCAwLjI7XHJcblxyXG4gICAgICAgICAgICAvLyByZXVzZSBjb2xsaXNpb24gb2JqZWN0XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHByZXZpb3VzQ29sbGlzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHsgY29sbGlkZWQ6IGZhbHNlLCBib2R5QTogYm9keUEsIGJvZHlCOiBib2R5QiB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ29sbGlzaW9uICYmIGNhblJldXNlUHJldkNvbCkge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4gcmV1c2UgdGhlIGNvbGxpc2lvbiByZXN1bHRcclxuICAgICAgICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHRlc3QgdGhlIHByZXZpb3VzbHkgZm91bmQgYXhpc1xyXG4gICAgICAgICAgICB2YXIgYXhpc0JvZHlBID0gY29sbGlzaW9uLmF4aXNCb2R5LFxyXG4gICAgICAgICAgICAgICAgYXhpc0JvZHlCID0gYXhpc0JvZHlBID09PSBib2R5QSA/IGJvZHlCIDogYm9keUEsXHJcbiAgICAgICAgICAgICAgICBheGVzID0gW2F4aXNCb2R5QS5heGVzW3ByZXZpb3VzQ29sbGlzaW9uLmF4aXNOdW1iZXJdXTtcclxuXHJcbiAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBfb3ZlcmxhcEF4ZXMoYXhpc0JvZHlBLnZlcnRpY2VzLCBheGlzQm9keUIudmVydGljZXMsIGF4ZXMpO1xyXG4gICAgICAgICAgICBjb2xsaXNpb24ucmV1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtaW5PdmVybGFwLm92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgcmV1c2UgYSByZXN1bHQsIHBlcmZvcm0gYSBmdWxsIFNBVCB0ZXN0XHJcblxyXG4gICAgICAgICAgICBvdmVybGFwQUIgPSBfb3ZlcmxhcEF4ZXMoYm9keUEudmVydGljZXMsIGJvZHlCLnZlcnRpY2VzLCBib2R5QS5heGVzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwQUIub3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG92ZXJsYXBCQSA9IF9vdmVybGFwQXhlcyhib2R5Qi52ZXJ0aWNlcywgYm9keUEudmVydGljZXMsIGJvZHlCLmF4ZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBCQS5vdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbi5jb2xsaWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBBQi5vdmVybGFwIDwgb3ZlcmxhcEJBLm92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwQUI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uYXhpc0JvZHkgPSBib2R5QTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwQkE7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uYXhpc0JvZHkgPSBib2R5QjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciByZXVzZSBsYXRlclxyXG4gICAgICAgICAgICBjb2xsaXNpb24uYXhpc051bWJlciA9IG1pbk92ZXJsYXAuYXhpc051bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbGxpc2lvbi5ib2R5QSA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QSA6IGJvZHlCO1xyXG4gICAgICAgIGNvbGxpc2lvbi5ib2R5QiA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QiA6IGJvZHlBO1xyXG4gICAgICAgIGNvbGxpc2lvbi5jb2xsaWRlZCA9IHRydWU7XHJcbiAgICAgICAgY29sbGlzaW9uLmRlcHRoID0gbWluT3ZlcmxhcC5vdmVybGFwO1xyXG4gICAgICAgIGNvbGxpc2lvbi5wYXJlbnRBID0gY29sbGlzaW9uLmJvZHlBLnBhcmVudDtcclxuICAgICAgICBjb2xsaXNpb24ucGFyZW50QiA9IGNvbGxpc2lvbi5ib2R5Qi5wYXJlbnQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUE7XHJcbiAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUI7XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSBub3JtYWwgaXMgZmFjaW5nIGF3YXkgZnJvbSBib2R5QVxyXG4gICAgICAgIGlmIChWZWN0b3IuZG90KG1pbk92ZXJsYXAuYXhpcywgVmVjdG9yLnN1Yihib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pKSA8IDApIHtcclxuICAgICAgICAgICAgY29sbGlzaW9uLm5vcm1hbCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IG1pbk92ZXJsYXAuYXhpcy54LFxyXG4gICAgICAgICAgICAgICAgeTogbWluT3ZlcmxhcC5heGlzLnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xsaXNpb24ubm9ybWFsID0ge1xyXG4gICAgICAgICAgICAgICAgeDogLW1pbk92ZXJsYXAuYXhpcy54LFxyXG4gICAgICAgICAgICAgICAgeTogLW1pbk92ZXJsYXAuYXhpcy55XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2xsaXNpb24udGFuZ2VudCA9IFZlY3Rvci5wZXJwKGNvbGxpc2lvbi5ub3JtYWwpO1xyXG5cclxuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24gPSBjb2xsaXNpb24ucGVuZXRyYXRpb24gfHwge307XHJcbiAgICAgICAgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnggPSBjb2xsaXNpb24ubm9ybWFsLnggKiBjb2xsaXNpb24uZGVwdGg7XHJcbiAgICAgICAgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnkgPSBjb2xsaXNpb24ubm9ybWFsLnkgKiBjb2xsaXNpb24uZGVwdGg7IFxyXG5cclxuICAgICAgICAvLyBmaW5kIHN1cHBvcnQgcG9pbnRzLCB0aGVyZSBpcyBhbHdheXMgZWl0aGVyIGV4YWN0bHkgb25lIG9yIHR3b1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlc0IgPSBfZmluZFN1cHBvcnRzKGJvZHlBLCBib2R5QiwgY29sbGlzaW9uLm5vcm1hbCksXHJcbiAgICAgICAgICAgIHN1cHBvcnRzID0gW107XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHN1cHBvcnRzIGZyb20gYm9keUIgdGhhdCBhcmUgaW5zaWRlIGJvZHlBXHJcbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCB2ZXJ0aWNlc0JbMF0pKVxyXG4gICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQlswXSk7XHJcblxyXG4gICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5QS52ZXJ0aWNlcywgdmVydGljZXNCWzFdKSlcclxuICAgICAgICAgICAgc3VwcG9ydHMucHVzaCh2ZXJ0aWNlc0JbMV0pO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRoZSBzdXBwb3J0cyBmcm9tIGJvZHlBIHRoYXQgYXJlIGluc2lkZSBib2R5QlxyXG4gICAgICAgIGlmIChzdXBwb3J0cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlc0EgPSBfZmluZFN1cHBvcnRzKGJvZHlCLCBib2R5QSwgVmVjdG9yLm5lZyhjb2xsaXNpb24ubm9ybWFsKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlCLnZlcnRpY2VzLCB2ZXJ0aWNlc0FbMF0pKVxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydHMucHVzaCh2ZXJ0aWNlc0FbMF0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzLmxlbmd0aCA8IDIgJiYgVmVydGljZXMuY29udGFpbnMoYm9keUIudmVydGljZXMsIHZlcnRpY2VzQVsxXSkpXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgZWRnZSBjYXNlIG9mIG92ZXJsYXBwaW5nIGJ1dCBubyB2ZXJ0ZXggY29udGFpbm1lbnRcclxuICAgICAgICBpZiAoc3VwcG9ydHMubGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAgc3VwcG9ydHMgPSBbdmVydGljZXNCWzBdXTtcclxuICAgICAgICBcclxuICAgICAgICBjb2xsaXNpb24uc3VwcG9ydHMgPSBzdXBwb3J0cztcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBvdmVybGFwIGJldHdlZW4gdHdvIHNldHMgb2YgdmVydGljZXMuXHJcbiAgICAgKiBAbWV0aG9kIF9vdmVybGFwQXhlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSB2ZXJ0aWNlc0FcclxuICAgICAqIEBwYXJhbSB7fSB2ZXJ0aWNlc0JcclxuICAgICAqIEBwYXJhbSB7fSBheGVzXHJcbiAgICAgKiBAcmV0dXJuIHJlc3VsdFxyXG4gICAgICovXHJcbiAgICB2YXIgX292ZXJsYXBBeGVzID0gZnVuY3Rpb24odmVydGljZXNBLCB2ZXJ0aWNlc0IsIGF4ZXMpIHtcclxuICAgICAgICB2YXIgcHJvamVjdGlvbkEgPSBWZWN0b3IuX3RlbXBbMF0sIFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uQiA9IFZlY3Rvci5fdGVtcFsxXSxcclxuICAgICAgICAgICAgcmVzdWx0ID0geyBvdmVybGFwOiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgIG92ZXJsYXAsXHJcbiAgICAgICAgICAgIGF4aXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBheGlzID0gYXhlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIF9wcm9qZWN0VG9BeGlzKHByb2plY3Rpb25BLCB2ZXJ0aWNlc0EsIGF4aXMpO1xyXG4gICAgICAgICAgICBfcHJvamVjdFRvQXhpcyhwcm9qZWN0aW9uQiwgdmVydGljZXNCLCBheGlzKTtcclxuXHJcbiAgICAgICAgICAgIG92ZXJsYXAgPSBNYXRoLm1pbihwcm9qZWN0aW9uQS5tYXggLSBwcm9qZWN0aW9uQi5taW4sIHByb2plY3Rpb25CLm1heCAtIHByb2plY3Rpb25BLm1pbik7XHJcblxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQub3ZlcmxhcCA9IG92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IHJlc3VsdC5vdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQub3ZlcmxhcCA9IG92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXhpcyA9IGF4aXM7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXhpc051bWJlciA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdHMgdmVydGljZXMgb24gYW4gYXhpcyBhbmQgcmV0dXJucyBhbiBpbnRlcnZhbC5cclxuICAgICAqIEBtZXRob2QgX3Byb2plY3RUb0F4aXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge30gcHJvamVjdGlvblxyXG4gICAgICogQHBhcmFtIHt9IHZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge30gYXhpc1xyXG4gICAgICovXHJcbiAgICB2YXIgX3Byb2plY3RUb0F4aXMgPSBmdW5jdGlvbihwcm9qZWN0aW9uLCB2ZXJ0aWNlcywgYXhpcykge1xyXG4gICAgICAgIHZhciBtaW4gPSBWZWN0b3IuZG90KHZlcnRpY2VzWzBdLCBheGlzKSxcclxuICAgICAgICAgICAgbWF4ID0gbWluO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBkb3QgPSBWZWN0b3IuZG90KHZlcnRpY2VzW2ldLCBheGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkb3QgPiBtYXgpIHsgXHJcbiAgICAgICAgICAgICAgICBtYXggPSBkb3Q7IFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvdCA8IG1pbikgeyBcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRvdDsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb2plY3Rpb24ubWluID0gbWluO1xyXG4gICAgICAgIHByb2plY3Rpb24ubWF4ID0gbWF4O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyBzdXBwb3J0aW5nIHZlcnRpY2VzIGdpdmVuIHR3byBib2RpZXMgYWxvbmcgYSBnaXZlbiBkaXJlY3Rpb24gdXNpbmcgaGlsbC1jbGltYmluZy5cclxuICAgICAqIEBtZXRob2QgX2ZpbmRTdXBwb3J0c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHt9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge30gbm9ybWFsXHJcbiAgICAgKiBAcmV0dXJuIFt2ZWN0b3JdXHJcbiAgICAgKi9cclxuICAgIHZhciBfZmluZFN1cHBvcnRzID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBub3JtYWwpIHtcclxuICAgICAgICB2YXIgbmVhcmVzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgdmVydGV4VG9Cb2R5ID0gVmVjdG9yLl90ZW1wWzBdLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IGJvZHlCLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICBib2R5QVBvc2l0aW9uID0gYm9keUEucG9zaXRpb24sXHJcbiAgICAgICAgICAgIGRpc3RhbmNlLFxyXG4gICAgICAgICAgICB2ZXJ0ZXgsXHJcbiAgICAgICAgICAgIHZlcnRleEEsXHJcbiAgICAgICAgICAgIHZlcnRleEI7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgY2xvc2VzdCB2ZXJ0ZXggb24gYm9keUJcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhUb0JvZHkueCA9IHZlcnRleC54IC0gYm9keUFQb3NpdGlvbi54O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhUb0JvZHkueSA9IHZlcnRleC55IC0gYm9keUFQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhBID0gdmVydGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaW5kIG5leHQgY2xvc2VzdCB2ZXJ0ZXggdXNpbmcgdGhlIHR3byBjb25uZWN0ZWQgdG8gaXRcclxuICAgICAgICB2YXIgcHJldkluZGV4ID0gdmVydGV4QS5pbmRleCAtIDEgPj0gMCA/IHZlcnRleEEuaW5kZXggLSAxIDogdmVydGljZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1twcmV2SW5kZXhdO1xyXG4gICAgICAgIHZlcnRleFRvQm9keS54ID0gdmVydGV4LnggLSBib2R5QVBvc2l0aW9uLng7XHJcbiAgICAgICAgdmVydGV4VG9Cb2R5LnkgPSB2ZXJ0ZXgueSAtIGJvZHlBUG9zaXRpb24ueTtcclxuICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSAtVmVjdG9yLmRvdChub3JtYWwsIHZlcnRleFRvQm9keSk7XHJcbiAgICAgICAgdmVydGV4QiA9IHZlcnRleDtcclxuXHJcbiAgICAgICAgdmFyIG5leHRJbmRleCA9ICh2ZXJ0ZXhBLmluZGV4ICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbbmV4dEluZGV4XTtcclxuICAgICAgICB2ZXJ0ZXhUb0JvZHkueCA9IHZlcnRleC54IC0gYm9keUFQb3NpdGlvbi54O1xyXG4gICAgICAgIHZlcnRleFRvQm9keS55ID0gdmVydGV4LnkgLSBib2R5QVBvc2l0aW9uLnk7XHJcbiAgICAgICAgZGlzdGFuY2UgPSAtVmVjdG9yLmRvdChub3JtYWwsIHZlcnRleFRvQm9keSk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZlcnRleEIgPSB2ZXJ0ZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW3ZlcnRleEEsIHZlcnRleEJdO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1NBVC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuTW91c2VgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIG1vdXNlIGlucHV0cy5cclxuKlxyXG4qIEBjbGFzcyBNb3VzZVxyXG4qL1xyXG5cclxudmFyIE1vdXNlID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlO1xyXG5cclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbW91c2UgaW5wdXQuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICogQHJldHVybiB7bW91c2V9IEEgbmV3IG1vdXNlXHJcbiAgICAgKi9cclxuICAgIE1vdXNlLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgbW91c2UgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIENvbW1vbi5sb2coJ01vdXNlLmNyZWF0ZTogZWxlbWVudCB3YXMgdW5kZWZpbmVkLCBkZWZhdWx0aW5nIHRvIGRvY3VtZW50LmJvZHknLCAnd2FybicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBtb3VzZS5lbGVtZW50ID0gZWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgIG1vdXNlLmFic29sdXRlID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgbW91c2UucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIG1vdXNlLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIG1vdXNlLnNjYWxlID0geyB4OiAxLCB5OiAxIH07XHJcbiAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IDA7XHJcbiAgICAgICAgbW91c2UuYnV0dG9uID0gLTE7XHJcbiAgICAgICAgbW91c2UucGl4ZWxSYXRpbyA9IG1vdXNlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJykgfHwgMTtcclxuXHJcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtb3VzZW1vdmU6IG51bGwsXHJcbiAgICAgICAgICAgIG1vdXNlZG93bjogbnVsbCxcclxuICAgICAgICAgICAgbW91c2V1cDogbnVsbCxcclxuICAgICAgICAgICAgbW91c2V3aGVlbDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW91c2UubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHsgXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24oZXZlbnQsIG1vdXNlLmVsZW1lbnQsIG1vdXNlLnBpeGVsUmF0aW8pLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcclxuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xyXG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcclxuICAgICAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZSA9IGV2ZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW91c2UubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbihldmVudCwgbW91c2UuZWxlbWVudCwgbW91c2UucGl4ZWxSYXRpbyksXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAodG91Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSBldmVudC5idXR0b247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcclxuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XHJcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xyXG4gICAgICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbi54ID0gbW91c2UucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24ueSA9IG1vdXNlLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBldmVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1vdXNlLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcclxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBtb3VzZS5idXR0b24gPSAtMTtcclxuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcclxuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbi54ID0gbW91c2UucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgbW91c2UubW91c2V1cFBvc2l0aW9uLnkgPSBtb3VzZS5wb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IGV2ZW50O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1vdXNlLm1vdXNld2hlZWwgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGV2ZW50LndoZWVsRGVsdGEgfHwgLWV2ZW50LmRldGFpbCkpO1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIE1vdXNlLnNldEVsZW1lbnQobW91c2UsIG1vdXNlLmVsZW1lbnQpO1xyXG5cclxuICAgICAgICByZXR1cm4gbW91c2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudCB0aGUgbW91c2UgaXMgYm91bmQgdG8gKGFuZCByZWxhdGl2ZSB0bykuXHJcbiAgICAgKiBAbWV0aG9kIHNldEVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIE1vdXNlLnNldEVsZW1lbnQgPSBmdW5jdGlvbihtb3VzZSwgZWxlbWVudCkge1xyXG4gICAgICAgIG1vdXNlLmVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlLm1vdXNlbW92ZSk7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZS5tb3VzZWRvd24pO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlLm1vdXNldXApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG1vdXNlLm1vdXNld2hlZWwpO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBtb3VzZS5tb3VzZXdoZWVsKTtcclxuXHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3VzZS5tb3VzZW1vdmUpO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG1vdXNlLm1vdXNlZG93bik7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlLm1vdXNldXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgY2FwdHVyZWQgc291cmNlIGV2ZW50cy5cclxuICAgICAqIEBtZXRob2QgY2xlYXJTb3VyY2VFdmVudHNcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXHJcbiAgICAgKi9cclxuICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzID0gZnVuY3Rpb24obW91c2UpIHtcclxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2Vtb3ZlID0gbnVsbDtcclxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2Vkb3duID0gbnVsbDtcclxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IG51bGw7XHJcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNld2hlZWwgPSBudWxsO1xyXG4gICAgICAgIG1vdXNlLndoZWVsRGVsdGEgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1vdXNlIHBvc2l0aW9uIG9mZnNldC5cclxuICAgICAqIEBtZXRob2Qgc2V0T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IG9mZnNldFxyXG4gICAgICovXHJcbiAgICBNb3VzZS5zZXRPZmZzZXQgPSBmdW5jdGlvbihtb3VzZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgbW91c2Uub2Zmc2V0LnggPSBvZmZzZXQueDtcclxuICAgICAgICBtb3VzZS5vZmZzZXQueSA9IG9mZnNldC55O1xyXG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xyXG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1vdXNlIHBvc2l0aW9uIHNjYWxlLlxyXG4gICAgICogQG1ldGhvZCBzZXRTY2FsZVxyXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBzY2FsZVxyXG4gICAgICovXHJcbiAgICBNb3VzZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKG1vdXNlLCBzY2FsZSkge1xyXG4gICAgICAgIG1vdXNlLnNjYWxlLnggPSBzY2FsZS54O1xyXG4gICAgICAgIG1vdXNlLnNjYWxlLnkgPSBzY2FsZS55O1xyXG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xyXG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBhbiBlbGVtZW50IGdpdmVuIGEgc2NyZWVuIHBpeGVsIHJhdGlvLlxyXG4gICAgICogQG1ldGhvZCBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHt9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW9cclxuICAgICAqIEByZXR1cm4ge31cclxuICAgICAqL1xyXG4gICAgdmFyIF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWxlbWVudCwgcGl4ZWxSYXRpbykge1xyXG4gICAgICAgIHZhciBlbGVtZW50Qm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgcm9vdE5vZGUgPSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KSxcclxuICAgICAgICAgICAgc2Nyb2xsWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICBzY3JvbGxZID0gKHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkKSA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHJvb3ROb2RlLnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxyXG4gICAgICAgICAgICB4LCB5O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgIHggPSB0b3VjaGVzWzBdLnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcclxuICAgICAgICAgICAgeSA9IHRvdWNoZXNbMF0ucGFnZVkgLSBlbGVtZW50Qm91bmRzLnRvcCAtIHNjcm9sbFk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IGV2ZW50LnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcclxuICAgICAgICAgICAgeSA9IGV2ZW50LnBhZ2VZIC0gZWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgIHg6IHggLyAoZWxlbWVudC5jbGllbnRXaWR0aCAvIChlbGVtZW50LndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGgpICogcGl4ZWxSYXRpbyksXHJcbiAgICAgICAgICAgIHk6IHkgLyAoZWxlbWVudC5jbGllbnRIZWlnaHQgLyAoZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQpICogcGl4ZWxSYXRpbylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Nb3VzZS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQm9kaWVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyByaWdpZCBib2R5IG1vZGVscyBcclxuKiB3aXRoIGNvbW1vbmx5IHVzZWQgYm9keSBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucykuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIEJvZGllc1xyXG4qL1xyXG5cclxuLy8gVE9ETzogdHJ1ZSBjaXJjbGUgYm9kaWVzXHJcblxyXG52YXIgQm9kaWVzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvZGllcztcclxuXHJcbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcclxudmFyIGRlY29tcCA9IHJlcXVpcmUoJy4uLy4uL3BvbHktZGVjb21wLycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWN0YW5nbGUgaHVsbC4gXHJcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyByZWN0YW5nbGUgYm9keVxyXG4gICAgICovXHJcbiAgICBCb2RpZXMucmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICB2YXIgcmVjdGFuZ2xlID0geyBcclxuICAgICAgICAgICAgbGFiZWw6ICdSZWN0YW5nbGUgQm9keScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcclxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMICcgKyB3aWR0aCArICcgMCBMICcgKyB3aWR0aCArICcgJyArIGhlaWdodCArICcgTCAwICcgKyBoZWlnaHQpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbWZlcikge1xyXG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcclxuICAgICAgICAgICAgcmVjdGFuZ2xlLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihyZWN0YW5nbGUudmVydGljZXMsIGNoYW1mZXIucmFkaXVzLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgcmVjdGFuZ2xlLCBvcHRpb25zKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbCB3aXRoIGEgdHJhcGV6b2lkIGh1bGwuIFxyXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgdHJhcGV6b2lkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3BlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyB0cmFwZXpvaWQgYm9keVxyXG4gICAgICovXHJcbiAgICBCb2RpZXMudHJhcGV6b2lkID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2xvcGUsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgc2xvcGUgKj0gMC41O1xyXG4gICAgICAgIHZhciByb29mID0gKDEgLSAoc2xvcGUgKiAyKSkgKiB3aWR0aDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgeDEgPSB3aWR0aCAqIHNsb3BlLFxyXG4gICAgICAgICAgICB4MiA9IHgxICsgcm9vZixcclxuICAgICAgICAgICAgeDMgPSB4MiArIHgxLFxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGg7XHJcblxyXG4gICAgICAgIGlmIChzbG9wZSA8IDAuNSkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDEgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmVydGljZXNQYXRoID0gJ0wgMCAwIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdHJhcGV6b2lkID0geyBcclxuICAgICAgICAgICAgbGFiZWw6ICdUcmFwZXpvaWQgQm9keScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcclxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKHZlcnRpY2VzUGF0aClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWQudmVydGljZXMgPSBWZXJ0aWNlcy5jaGFtZmVyKHRyYXBlem9pZC52ZXJ0aWNlcywgY2hhbWZlci5yYWRpdXMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCB0cmFwZXpvaWQsIG9wdGlvbnMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIGNpcmNsZSBodWxsLiBcclxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNpZGVzXVxyXG4gICAgICogQHJldHVybiB7Ym9keX0gQSBuZXcgY2lyY2xlIGJvZHlcclxuICAgICAqL1xyXG4gICAgQm9kaWVzLmNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgb3B0aW9ucywgbWF4U2lkZXMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHtcclxuICAgICAgICAgICAgbGFiZWw6ICdDaXJjbGUgQm9keScsXHJcbiAgICAgICAgICAgIGNpcmNsZVJhZGl1czogcmFkaXVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjaXJjbGVzIHdpdGggcG9seWdvbnMgdW50aWwgdHJ1ZSBjaXJjbGVzIGltcGxlbWVudGVkIGluIFNBVFxyXG4gICAgICAgIG1heFNpZGVzID0gbWF4U2lkZXMgfHwgMjU7XHJcbiAgICAgICAgdmFyIHNpZGVzID0gTWF0aC5jZWlsKE1hdGgubWF4KDEwLCBNYXRoLm1pbihtYXhTaWRlcywgcmFkaXVzKSkpO1xyXG5cclxuICAgICAgICAvLyBvcHRpbWlzYXRpb246IGFsd2F5cyB1c2UgZXZlbiBudW1iZXIgb2Ygc2lkZXMgKGhhbGYgdGhlIG51bWJlciBvZiB1bmlxdWUgYXhlcylcclxuICAgICAgICBpZiAoc2lkZXMgJSAyID09PSAxKVxyXG4gICAgICAgICAgICBzaWRlcyArPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gQm9kaWVzLnBvbHlnb24oeCwgeSwgc2lkZXMsIHJhZGl1cywgQ29tbW9uLmV4dGVuZCh7fSwgY2lyY2xlLCBvcHRpb25zKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWd1bGFyIHBvbHlnb24gaHVsbCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygc2lkZXMuIFxyXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgcG9seWdvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lkZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHJlZ3VsYXIgcG9seWdvbiBib2R5XHJcbiAgICAgKi9cclxuICAgIEJvZGllcy5wb2x5Z29uID0gZnVuY3Rpb24oeCwgeSwgc2lkZXMsIHJhZGl1cywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAoc2lkZXMgPCAzKVxyXG4gICAgICAgICAgICByZXR1cm4gQm9kaWVzLmNpcmNsZSh4LCB5LCByYWRpdXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIHNpZGVzLFxyXG4gICAgICAgICAgICBwYXRoID0gJycsXHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoZXRhICogMC41O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gb2Zmc2V0ICsgKGkgKiB0aGV0YSksXHJcbiAgICAgICAgICAgICAgICB4eCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcclxuICAgICAgICAgICAgICAgIHl5ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgcGF0aCArPSAnTCAnICsgeHgudG9GaXhlZCgzKSArICcgJyArIHl5LnRvRml4ZWQoMykgKyAnICc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcG9seWdvbiA9IHsgXHJcbiAgICAgICAgICAgIGxhYmVsOiAnUG9seWdvbiBCb2R5JyxcclxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxyXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgocGF0aClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihwb2x5Z29uLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHBvbHlnb24sIG9wdGlvbnMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYm9keSB1c2luZyB0aGUgc3VwcGxpZWQgdmVydGljZXMgKG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbXVsdGlwbGUgc2V0cyBvZiB2ZXJ0aWNlcykuXHJcbiAgICAgKiBJZiB0aGUgdmVydGljZXMgYXJlIGNvbnZleCwgdGhleSB3aWxsIHBhc3MgdGhyb3VnaCBhcyBzdXBwbGllZC5cclxuICAgICAqIE90aGVyd2lzZSBpZiB0aGUgdmVydGljZXMgYXJlIGNvbmNhdmUsIHRoZXkgd2lsbCBiZSBkZWNvbXBvc2VkIGlmIFtwb2x5LWRlY29tcC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBpcyBhdmFpbGFibGUuXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9jZXNzIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1cHBvcnQgY29tcGxleCBzZXRzIG9mIHZlcnRpY2VzIChlLmcuIHRob3NlIHdpdGggaG9sZXMgbWF5IGZhaWwpLlxyXG4gICAgICogQnkgZGVmYXVsdCB0aGUgZGVjb21wb3NpdGlvbiB3aWxsIGRpc2NhcmQgY29sbGluZWFyIGVkZ2VzICh0byBpbXByb3ZlIHBlcmZvcm1hbmNlKS5cclxuICAgICAqIEl0IGNhbiBhbHNvIG9wdGlvbmFsbHkgZGlzY2FyZCBhbnkgcGFydHMgdGhhdCBoYXZlIGFuIGFyZWEgbGVzcyB0aGFuIGBtaW5pbXVtQXJlYWAuXHJcbiAgICAgKiBJZiB0aGUgdmVydGljZXMgY2FuIG5vdCBiZSBkZWNvbXBvc2VkLCB0aGUgcmVzdWx0IHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBjb252ZXggaHVsbC5cclxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IGBNYXR0ZXIuQm9keWAgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgZnJvbVZlcnRpY2VzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSBbW3ZlY3Rvcl1dIHZlcnRleFNldHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2ZsYWdJbnRlcm5hbD1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtb3ZlQ29sbGluZWFyPTAuMDFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbmltdW1BcmVhPTEwXVxyXG4gICAgICogQHJldHVybiB7Ym9keX1cclxuICAgICAqL1xyXG4gICAgQm9kaWVzLmZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKHgsIHksIHZlcnRleFNldHMsIG9wdGlvbnMsIGZsYWdJbnRlcm5hbCwgcmVtb3ZlQ29sbGluZWFyLCBtaW5pbXVtQXJlYSkge1xyXG4gICAgICAgIHZhciBib2R5LFxyXG4gICAgICAgICAgICBwYXJ0cyxcclxuICAgICAgICAgICAgaXNDb252ZXgsXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICB6O1xyXG5cclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBwYXJ0cyA9IFtdO1xyXG5cclxuICAgICAgICBmbGFnSW50ZXJuYWwgPSB0eXBlb2YgZmxhZ0ludGVybmFsICE9PSAndW5kZWZpbmVkJyA/IGZsYWdJbnRlcm5hbCA6IGZhbHNlO1xyXG4gICAgICAgIHJlbW92ZUNvbGxpbmVhciA9IHR5cGVvZiByZW1vdmVDb2xsaW5lYXIgIT09ICd1bmRlZmluZWQnID8gcmVtb3ZlQ29sbGluZWFyIDogMC4wMTtcclxuICAgICAgICBtaW5pbXVtQXJlYSA9IHR5cGVvZiBtaW5pbXVtQXJlYSAhPT0gJ3VuZGVmaW5lZCcgPyBtaW5pbXVtQXJlYSA6IDEwO1xyXG5cclxuICAgICAgICBpZiAoIWRlY29tcCkge1xyXG4gICAgICAgICAgICBDb21tb24ud2FybignQm9kaWVzLmZyb21WZXJ0aWNlczogcG9seS1kZWNvbXAuanMgcmVxdWlyZWQuIENvdWxkIG5vdCBkZWNvbXBvc2UgdmVydGljZXMuIEZhbGxiYWNrIHRvIGNvbnZleCBodWxsLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHZlcnRleFNldHMgaXMgYW4gYXJyYXkgb2YgYXJyYXlzXHJcbiAgICAgICAgaWYgKCFDb21tb24uaXNBcnJheSh2ZXJ0ZXhTZXRzWzBdKSkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTZXRzID0gW3ZlcnRleFNldHNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IHZlcnRleFNldHMubGVuZ3RoOyB2ICs9IDEpIHtcclxuICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0ZXhTZXRzW3ZdO1xyXG4gICAgICAgICAgICBpc0NvbnZleCA9IFZlcnRpY2VzLmlzQ29udmV4KHZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0NvbnZleCB8fCAhZGVjb21wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb252ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IFZlcnRpY2VzLmNsb2Nrd2lzZVNvcnQodmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBjb252ZXggaHVsbCB3aGVuIGRlY29tcG9zaXRpb24gaXMgbm90IHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYSBkZWNvbXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgY29uY2F2ZSA9IHZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3ZlcnRleC54LCB2ZXJ0ZXgueV07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNlcyBhcmUgY29uY2F2ZSBhbmQgc2ltcGxlLCB3ZSBjYW4gZGVjb21wb3NlIGludG8gcGFydHNcclxuICAgICAgICAgICAgICAgIGRlY29tcC5tYWtlQ0NXKGNvbmNhdmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUNvbGxpbmVhciAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wLnJlbW92ZUNvbGxpbmVhclBvaW50cyhjb25jYXZlLCByZW1vdmVDb2xsaW5lYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcXVpY2sgZGVjb21wb3NpdGlvbiBhbGdvcml0aG0gKEJheWF6aXQpXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb21wb3NlZCA9IGRlY29tcC5xdWlja0RlY29tcChjb25jYXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBkZWNvbXBvc2VkIGNodW5rXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVjb21wb3NlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IGRlY29tcG9zZWRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmVydGljZXMgaW50byB0aGUgY29ycmVjdCBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtWZXJ0aWNlcyA9IGNodW5rLm1hcChmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1sxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHNtYWxsIGNodW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtQXJlYSA+IDAgJiYgVmVydGljZXMuYXJlYShjaHVua1ZlcnRpY2VzKSA8IG1pbmltdW1BcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29tcG91bmQgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogVmVydGljZXMuY2VudHJlKGNodW5rVmVydGljZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogY2h1bmtWZXJ0aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYm9keSBwYXJ0c1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXJ0c1tpXSA9IEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQocGFydHNbaV0sIG9wdGlvbnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZsYWcgaW50ZXJuYWwgZWRnZXMgKGNvaW5jaWRlbnQgcGFydCBlZGdlcylcclxuICAgICAgICBpZiAoZmxhZ0ludGVybmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2luY2lkZW50X21heF9kaXN0ID0gNTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gcGFydHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IHBhcnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKHBhcnRBLmJvdW5kcywgcGFydEIuYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF2ID0gcGFydEEudmVydGljZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYnYgPSBwYXJ0Qi52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdmVydGljZXMgb2YgYm90aCBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydEEudmVydGljZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IDA7IHogPCBwYXJ0Qi52ZXJ0aWNlcy5sZW5ndGg7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhID0gVmVjdG9yLm1hZ25pdHVkZVNxdWFyZWQoVmVjdG9yLnN1YihwYXZbKGsgKyAxKSAlIHBhdi5sZW5ndGhdLCBwYnZbel0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIgPSBWZWN0b3IubWFnbml0dWRlU3F1YXJlZChWZWN0b3Iuc3ViKHBhdltrXSwgcGJ2Wyh6ICsgMSkgJSBwYnYubGVuZ3RoXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBib3RoIHZlcnRpY2VzIGFyZSB2ZXJ5IGNsb3NlLCBjb25zaWRlciB0aGUgZWRnZSBjb25jaWRlbnQgKGludGVybmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYSA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QgJiYgZGIgPCBjb2luY2lkZW50X21heF9kaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdltrXS5pc0ludGVybmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJ2W3pdLmlzSW50ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyZW50IGJvZHkgdG8gYmUgcmV0dXJuZWQsIHRoYXQgY29udGFpbnMgZ2VuZXJhdGVkIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgICAgIGJvZHkgPSBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgcGFydHM6IHBhcnRzLnNsaWNlKDApIH0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB7IHg6IHgsIHk6IHkgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Cb2RpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkF4ZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgYXhlcy5cclxuKlxyXG4qIEBjbGFzcyBBeGVzXHJcbiovXHJcblxyXG52YXIgQXhlcyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBeGVzO1xyXG5cclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXMuXHJcbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcclxuICAgICAqIEByZXR1cm4ge2F4ZXN9IEEgbmV3IGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgQXhlcy5mcm9tVmVydGljZXMgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xyXG4gICAgICAgIHZhciBheGVzID0ge307XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHVuaXF1ZSBheGVzLCB1c2luZyBlZGdlIG5vcm1hbCBncmFkaWVudHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aCwgXHJcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXHJcbiAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbal0ueSAtIHZlcnRpY2VzW2ldLnksIFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHZlcnRpY2VzW2ldLnggLSB2ZXJ0aWNlc1tqXS54XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gKG5vcm1hbC55ID09PSAwKSA/IEluZmluaXR5IDogKG5vcm1hbC54IC8gbm9ybWFsLnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbGltaXQgcHJlY2lzaW9uXHJcbiAgICAgICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQudG9GaXhlZCgzKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBheGVzW2dyYWRpZW50XSA9IG5vcm1hbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDb21tb24udmFsdWVzKGF4ZXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgYSBzZXQgb2YgYXhlcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxyXG4gICAgICogQHBhcmFtIHtheGVzfSBheGVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQXhlcy5yb3RhdGUgPSBmdW5jdGlvbihheGVzLCBhbmdsZSkge1xyXG4gICAgICAgIGlmIChhbmdsZSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXHJcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpXSxcclxuICAgICAgICAgICAgICAgIHh4O1xyXG4gICAgICAgICAgICB4eCA9IGF4aXMueCAqIGNvcyAtIGF4aXMueSAqIHNpbjtcclxuICAgICAgICAgICAgYXhpcy55ID0gYXhpcy54ICogc2luICsgYXhpcy55ICogY29zO1xyXG4gICAgICAgICAgICBheGlzLnggPSB4eDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9BeGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5SZW5kZXJgIG1vZHVsZSBpcyBhIHNpbXBsZSBIVE1MNSBjYW52YXMgYmFzZWQgcmVuZGVyZXIgZm9yIHZpc3VhbGlzaW5nIGluc3RhbmNlcyBvZiBgTWF0dGVyLkVuZ2luZWAuXHJcbiogSXQgaXMgaW50ZW5kZWQgZm9yIGRldmVsb3BtZW50IGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMsIGJ1dCBtYXkgYWxzbyBiZSBzdWl0YWJsZSBmb3Igc2ltcGxlIGdhbWVzLlxyXG4qIEl0IGluY2x1ZGVzIGEgbnVtYmVyIG9mIGRyYXdpbmcgb3B0aW9ucyBpbmNsdWRpbmcgd2lyZWZyYW1lLCB2ZWN0b3Igd2l0aCBzdXBwb3J0IGZvciBzcHJpdGVzIGFuZCB2aWV3cG9ydHMuXHJcbipcclxuKiBAY2xhc3MgUmVuZGVyXHJcbiovXHJcblxyXG52YXIgUmVuZGVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcjtcclxuXHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi4vY29yZS9FdmVudHMnKTtcclxudmFyIEdyaWQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xyXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uL2NvcmUvTW91c2UnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbihjYWxsYmFjayl7IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhDb21tb24ubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG4gICBcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyZXIuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHJldHVybiB7cmVuZGVyfSBBIG5ldyByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgY29udHJvbGxlcjogUmVuZGVyLFxyXG4gICAgICAgICAgICBlbmdpbmU6IG51bGwsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGNhbnZhczogbnVsbCxcclxuICAgICAgICAgICAgbW91c2U6IG51bGwsXHJcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogODAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXHJcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyMxODE4MWQnLFxyXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lQmFja2dyb3VuZDogJyMwZjBmMTMnLFxyXG4gICAgICAgICAgICAgICAgaGFzQm91bmRzOiAhIW9wdGlvbnMuYm91bmRzLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93U2xlZXBpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93RGVidWc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0Jyb2FkcGhhc2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0JvdW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0NvbGxpc2lvbnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1NlcGFyYXRpb25zOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dBeGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dQb3NpdGlvbnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0FuZ2xlSW5kaWNhdG9yOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dJZHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1NoYWRvd3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1ZlcnRleE51bWJlcnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0NvbnZleEh1bGxzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dJbnRlcm5hbEVkZ2VzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dNb3VzZVBvc2l0aW9uOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlbmRlciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyLmNhbnZhcykge1xyXG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLndpZHRoID0gcmVuZGVyLm9wdGlvbnMud2lkdGggfHwgcmVuZGVyLmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgcmVuZGVyLmNhbnZhcy5oZWlnaHQgPSByZW5kZXIub3B0aW9ucy5oZWlnaHQgfHwgcmVuZGVyLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXIubW91c2UgPSBvcHRpb25zLm1vdXNlO1xyXG4gICAgICAgIHJlbmRlci5lbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcclxuICAgICAgICByZW5kZXIuY2FudmFzID0gcmVuZGVyLmNhbnZhcyB8fCBfY3JlYXRlQ2FudmFzKHJlbmRlci5vcHRpb25zLndpZHRoLCByZW5kZXIub3B0aW9ucy5oZWlnaHQpO1xyXG4gICAgICAgIHJlbmRlci5jb250ZXh0ID0gcmVuZGVyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHJlbmRlci50ZXh0dXJlcyA9IHt9O1xyXG5cclxuICAgICAgICByZW5kZXIuYm91bmRzID0gcmVuZGVyLmJvdW5kcyB8fCB7IFxyXG4gICAgICAgICAgICBtaW46IHsgXHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICB9LCBcclxuICAgICAgICAgICAgbWF4OiB7IFxyXG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIHk6IHJlbmRlci5jYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gMSkge1xyXG4gICAgICAgICAgICBSZW5kZXIuc2V0UGl4ZWxSYXRpbyhyZW5kZXIsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKENvbW1vbi5pc0VsZW1lbnQocmVuZGVyLmVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJlbmRlci5lbGVtZW50LmFwcGVuZENoaWxkKHJlbmRlci5jYW52YXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENvbW1vbi5sb2coJ1JlbmRlci5jcmVhdGU6IG9wdGlvbnMuZWxlbWVudCB3YXMgdW5kZWZpbmVkLCByZW5kZXIuY2FudmFzIHdhcyBjcmVhdGVkIGJ1dCBub3QgYXBwZW5kZWQnLCAnd2FybicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51b3VzbHkgdXBkYXRlcyB0aGUgcmVuZGVyIGNhbnZhcyBvbiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgZXZlbnQuXHJcbiAgICAgKiBAbWV0aG9kIHJ1blxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICovXHJcbiAgICBSZW5kZXIucnVuID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AodGltZSl7XHJcbiAgICAgICAgICAgIHJlbmRlci5mcmFtZVJlcXVlc3RJZCA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcbiAgICAgICAgICAgIFJlbmRlci53b3JsZChyZW5kZXIpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5kcyBleGVjdXRpb24gb2YgYFJlbmRlci5ydW5gIG9uIHRoZSBnaXZlbiBgcmVuZGVyYCwgYnkgY2FuY2VsaW5nIHRoZSBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBldmVudCBsb29wLlxyXG4gICAgICogQG1ldGhvZCBzdG9wXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lKHJlbmRlci5mcmFtZVJlcXVlc3RJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyIGFuZCB1cGRhdGVzIHRoZSBjYW52YXMuXHJcbiAgICAgKiBUbyBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgY29ycmVjdCByYXRpbywgcGFzcyB0aGUgc3RyaW5nIGAnYXV0bydgIGZvciBgcGl4ZWxSYXRpb2AuXHJcbiAgICAgKiBAbWV0aG9kIHNldFBpeGVsUmF0aW9cclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24ocmVuZGVyLCBwaXhlbFJhdGlvKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgY2FudmFzID0gcmVuZGVyLmNhbnZhcztcclxuXHJcbiAgICAgICAgaWYgKHBpeGVsUmF0aW8gPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gX2dldFBpeGVsUmF0aW8oY2FudmFzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XHJcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnZGF0YS1waXhlbC1yYXRpbycsIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3B0aW9ucy53aWR0aCArICdweCc7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICByZW5kZXIuY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbnMgYW5kIHNpemVzIHRoZSB2aWV3cG9ydCBhcm91bmQgdGhlIGdpdmVuIG9iamVjdCBib3VuZHMuXHJcbiAgICAgKiBPYmplY3RzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogLSBgb2JqZWN0LmJvdW5kc2BcclxuICAgICAqIC0gYG9iamVjdC5wb3NpdGlvbmBcclxuICAgICAqIC0gYG9iamVjdC5taW5gIGFuZCBgb2JqZWN0Lm1heGBcclxuICAgICAqIC0gYG9iamVjdC54YCBhbmQgYG9iamVjdC55YFxyXG4gICAgICogQG1ldGhvZCBsb29rQXRcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IG9iamVjdHNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbcGFkZGluZ11cclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2NlbnRlcj10cnVlXVxyXG4gICAgICovXHJcbiAgICBSZW5kZXIubG9va0F0ID0gZnVuY3Rpb24ocmVuZGVyLCBvYmplY3RzLCBwYWRkaW5nLCBjZW50ZXIpIHtcclxuICAgICAgICBjZW50ZXIgPSB0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJyA/IGNlbnRlciA6IHRydWU7XHJcbiAgICAgICAgb2JqZWN0cyA9IENvbW1vbi5pc0FycmF5KG9iamVjdHMpID8gb2JqZWN0cyA6IFtvYmplY3RzXTtcclxuICAgICAgICBwYWRkaW5nID0gcGFkZGluZyB8fCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBmaW5kIGJvdW5kcyBvZiBhbGwgb2JqZWN0c1xyXG4gICAgICAgIHZhciBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pbjogeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHkgfSxcclxuICAgICAgICAgICAgbWF4OiB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5IH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNbaV0sXHJcbiAgICAgICAgICAgICAgICBtaW4gPSBvYmplY3QuYm91bmRzID8gb2JqZWN0LmJvdW5kcy5taW4gOiAob2JqZWN0Lm1pbiB8fCBvYmplY3QucG9zaXRpb24gfHwgb2JqZWN0KSxcclxuICAgICAgICAgICAgICAgIG1heCA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1heCA6IChvYmplY3QubWF4IHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpOyBcclxuXHJcbiAgICAgICAgICAgIGlmIChtaW4gJiYgbWF4KSB7IFxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbi54IDwgYm91bmRzLm1pbi54KSBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWluLnggPSBtaW4ueDtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChtYXgueCA+IGJvdW5kcy5tYXgueCkgXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1heC54ID0gbWF4Lng7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbi55IDwgYm91bmRzLm1pbi55KSBcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWluLnkgPSBtaW4ueTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWF4LnkgPiBib3VuZHMubWF4LnkpIFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueSA9IG1heC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaW5kIHJhdGlvc1xyXG4gICAgICAgIHZhciB3aWR0aCA9IChib3VuZHMubWF4LnggLSBib3VuZHMubWluLngpICsgMiAqIHBhZGRpbmcueCxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSkgKyAyICogcGFkZGluZy55LFxyXG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gcmVuZGVyLmNhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IHJlbmRlci5jYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgIG91dGVyUmF0aW8gPSB2aWV3V2lkdGggLyB2aWV3SGVpZ2h0LFxyXG4gICAgICAgICAgICBpbm5lclJhdGlvID0gd2lkdGggLyBoZWlnaHQsXHJcbiAgICAgICAgICAgIHNjYWxlWCA9IDEsXHJcbiAgICAgICAgICAgIHNjYWxlWSA9IDE7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgc2NhbGUgZmFjdG9yXHJcbiAgICAgICAgaWYgKGlubmVyUmF0aW8gPiBvdXRlclJhdGlvKSB7XHJcbiAgICAgICAgICAgIHNjYWxlWSA9IGlubmVyUmF0aW8gLyBvdXRlclJhdGlvO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNjYWxlWCA9IG91dGVyUmF0aW8gLyBpbm5lclJhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZW5hYmxlIGJvdW5kc1xyXG4gICAgICAgIHJlbmRlci5vcHRpb25zLmhhc0JvdW5kcyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCA9IGJvdW5kcy5taW4ueDtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1heC54ID0gYm91bmRzLm1pbi54ICsgd2lkdGggKiBzY2FsZVg7XHJcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueSA9IGJvdW5kcy5taW4ueTtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1heC55ID0gYm91bmRzLm1pbi55ICsgaGVpZ2h0ICogc2NhbGVZO1xyXG5cclxuICAgICAgICAvLyBjZW50ZXJcclxuICAgICAgICBpZiAoY2VudGVyKSB7XHJcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggKz0gd2lkdGggKiAwLjUgLSAod2lkdGggKiBzY2FsZVgpICogMC41O1xyXG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1heC54ICs9IHdpZHRoICogMC41IC0gKHdpZHRoICogc2NhbGVYKSAqIDAuNTtcclxuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueSArPSBoZWlnaHQgKiAwLjUgLSAoaGVpZ2h0ICogc2NhbGVZKSAqIDAuNTtcclxuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSArPSBoZWlnaHQgKiAwLjUgLSAoaGVpZ2h0ICogc2NhbGVZKSAqIDAuNTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBhZGRpbmdcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54IC09IHBhZGRpbmcueDtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1heC54IC09IHBhZGRpbmcueDtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55IC09IHBhZGRpbmcueTtcclxuICAgICAgICByZW5kZXIuYm91bmRzLm1heC55IC09IHBhZGRpbmcueTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIG1vdXNlXHJcbiAgICAgICAgaWYgKHJlbmRlci5tb3VzZSkge1xyXG4gICAgICAgICAgICBNb3VzZS5zZXRTY2FsZShyZW5kZXIubW91c2UsIHtcclxuICAgICAgICAgICAgICAgIHg6IChyZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCkgLyByZW5kZXIuY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgeTogKHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55KSAvIHJlbmRlci5jYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgTW91c2Uuc2V0T2Zmc2V0KHJlbmRlci5tb3VzZSwgcmVuZGVyLmJvdW5kcy5taW4pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHZpZXdwb3J0IHRyYW5zZm9ybXMgYmFzZWQgb24gYHJlbmRlci5ib3VuZHNgIHRvIGEgcmVuZGVyIGNvbnRleHQuXHJcbiAgICAgKiBAbWV0aG9kIHN0YXJ0Vmlld1RyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuc3RhcnRWaWV3VHJhbnNmb3JtID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kc1dpZHRoID0gcmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngsXHJcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxyXG4gICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBib3VuZHNTY2FsZVkgPSBib3VuZHNIZWlnaHQgLyByZW5kZXIub3B0aW9ucy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnNjYWxlKDEgLyBib3VuZHNTY2FsZVgsIDEgLyBib3VuZHNTY2FsZVkpO1xyXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnRyYW5zbGF0ZSgtcmVuZGVyLmJvdW5kcy5taW4ueCwgLXJlbmRlci5ib3VuZHMubWluLnkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBhbGwgdHJhbnNmb3JtcyBvbiB0aGUgcmVuZGVyIGNvbnRleHQuXHJcbiAgICAgKiBAbWV0aG9kIGVuZFZpZXdUcmFuc2Zvcm1cclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0gPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICByZW5kZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0ocmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgZ2l2ZW4gYGVuZ2luZWAncyBgTWF0dGVyLldvcmxkYCBvYmplY3QuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIHJlbmRlcmluZyBhbmQgc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBzY2VuZSBjaGFuZ2VzLlxyXG4gICAgICogQG1ldGhvZCB3b3JsZFxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICovXHJcbiAgICBSZW5kZXIud29ybGQgPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcclxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXHJcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlci5jYW52YXMsXHJcbiAgICAgICAgICAgIGNvbnRleHQgPSByZW5kZXIuY29udGV4dCxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcclxuICAgICAgICAgICAgYWxsQ29uc3RyYWludHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMod29ybGQpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kID0gb3B0aW9ucy53aXJlZnJhbWVzID8gb3B0aW9ucy53aXJlZnJhbWVCYWNrZ3JvdW5kIDogb3B0aW9ucy5iYWNrZ3JvdW5kLFxyXG4gICAgICAgICAgICBib2RpZXMgPSBbXSxcclxuICAgICAgICAgICAgY29uc3RyYWludHMgPSBbXSxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGVuZ2luZS50aW1pbmcudGltZXN0YW1wXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocmVuZGVyLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBhcHBseSBiYWNrZ3JvdW5kIGlmIGl0IGhhcyBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZClcclxuICAgICAgICAgICAgX2FwcGx5QmFja2dyb3VuZChyZW5kZXIsIGJhY2tncm91bmQpO1xyXG5cclxuICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzIHdpdGggYSB0cmFuc3BhcmVudCBmaWxsLCB0byBhbGxvdyB0aGUgY2FudmFzIGJhY2tncm91bmQgdG8gc2hvd1xyXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1pbic7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInRyYW5zcGFyZW50XCI7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGJvdW5kc1xyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcykge1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGJvZGllcyB0aGF0IGFyZSBub3QgaW4gdmlld1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGFsbEJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIHJlbmRlci5ib3VuZHMpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZGllcy5wdXNoKGJvZHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGNvbnN0cmFpbnRzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBhbGxDb25zdHJhaW50c1tpXSxcclxuICAgICAgICAgICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QVdvcmxkID0gY29uc3RyYWludC5wb2ludEEsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBjb25zdHJhaW50LnBvaW50QjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEpIHBvaW50QVdvcmxkID0gVmVjdG9yLmFkZChib2R5QS5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSBwb2ludEJXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKHJlbmRlci5ib3VuZHMsIHBvaW50QVdvcmxkKSB8fCBCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRCV29ybGQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgdmlld1xyXG4gICAgICAgICAgICBSZW5kZXIuc3RhcnRWaWV3VHJhbnNmb3JtKHJlbmRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbW91c2VcclxuICAgICAgICAgICAgaWYgKHJlbmRlci5tb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgTW91c2Uuc2V0U2NhbGUocmVuZGVyLm1vdXNlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogKHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54KSAvIHJlbmRlci5jYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55KSAvIHJlbmRlci5jYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBNb3VzZS5zZXRPZmZzZXQocmVuZGVyLm1vdXNlLCByZW5kZXIuYm91bmRzLm1pbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGFsbENvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICBib2RpZXMgPSBhbGxCb2RpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMud2lyZWZyYW1lcyB8fCAoZW5naW5lLmVuYWJsZVNsZWVwaW5nICYmIG9wdGlvbnMuc2hvd1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBmdWxseSBmZWF0dXJlZCByZW5kZXJpbmcgb2YgYm9kaWVzXHJcbiAgICAgICAgICAgIFJlbmRlci5ib2RpZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dDb252ZXhIdWxscylcclxuICAgICAgICAgICAgICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gb3B0aW1pc2VkIG1ldGhvZCBmb3Igd2lyZWZyYW1lcyBvbmx5XHJcbiAgICAgICAgICAgIFJlbmRlci5ib2R5V2lyZWZyYW1lcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Qm91bmRzKVxyXG4gICAgICAgICAgICBSZW5kZXIuYm9keUJvdW5kcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dBeGVzIHx8IG9wdGlvbnMuc2hvd0FuZ2xlSW5kaWNhdG9yKVxyXG4gICAgICAgICAgICBSZW5kZXIuYm9keUF4ZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dQb3NpdGlvbnMpXHJcbiAgICAgICAgICAgIFJlbmRlci5ib2R5UG9zaXRpb25zKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1ZlbG9jaXR5KVxyXG4gICAgICAgICAgICBSZW5kZXIuYm9keVZlbG9jaXR5KHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0lkcylcclxuICAgICAgICAgICAgUmVuZGVyLmJvZHlJZHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93U2VwYXJhdGlvbnMpXHJcbiAgICAgICAgICAgIFJlbmRlci5zZXBhcmF0aW9ucyhyZW5kZXIsIGVuZ2luZS5wYWlycy5saXN0LCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0NvbGxpc2lvbnMpXHJcbiAgICAgICAgICAgIFJlbmRlci5jb2xsaXNpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93VmVydGV4TnVtYmVycylcclxuICAgICAgICAgICAgUmVuZGVyLnZlcnRleE51bWJlcnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93TW91c2VQb3NpdGlvbilcclxuICAgICAgICAgICAgUmVuZGVyLm1vdXNlUG9zaXRpb24ocmVuZGVyLCByZW5kZXIubW91c2UsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBSZW5kZXIuY29uc3RyYWludHMoY29uc3RyYWludHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93QnJvYWRwaGFzZSAmJiBlbmdpbmUuYnJvYWRwaGFzZS5jb250cm9sbGVyID09PSBHcmlkKVxyXG4gICAgICAgICAgICBSZW5kZXIuZ3JpZChyZW5kZXIsIGVuZ2luZS5icm9hZHBoYXNlLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0RlYnVnKVxyXG4gICAgICAgICAgICBSZW5kZXIuZGVidWcocmVuZGVyLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XHJcbiAgICAgICAgICAgIC8vIHJldmVydCB2aWV3IHRyYW5zZm9ybXNcclxuICAgICAgICAgICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0ocmVuZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJlbmRlciwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBkZWJ1Z1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5kZWJ1ZyA9IGZ1bmN0aW9uKHJlbmRlciwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcclxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXHJcbiAgICAgICAgICAgIG1ldHJpY3MgPSBlbmdpbmUubWV0cmljcyxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcclxuICAgICAgICAgICAgc3BhY2UgPSBcIiAgICBcIjtcclxuXHJcbiAgICAgICAgaWYgKGVuZ2luZS50aW1pbmcudGltZXN0YW1wIC0gKHJlbmRlci5kZWJ1Z1RpbWVzdGFtcCB8fCAwKSA+PSA1MDApIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1ldHJpY3MudGltaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiZnBzOiBcIiArIE1hdGgucm91bmQobWV0cmljcy50aW1pbmcuZnBzKSArIHNwYWNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAgICAgaWYgKG1ldHJpY3MuZXh0ZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRyaWNzLnRpbWluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJkZWx0YTogXCIgKyBtZXRyaWNzLnRpbWluZy5kZWx0YS50b0ZpeGVkKDMpICsgc3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImNvcnJlY3Rpb246IFwiICsgbWV0cmljcy50aW1pbmcuY29ycmVjdGlvbi50b0ZpeGVkKDMpICsgc3BhY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcImJvZGllczogXCIgKyBib2RpZXMubGVuZ3RoICsgc3BhY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5icm9hZHBoYXNlLmNvbnRyb2xsZXIgPT09IEdyaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImJ1Y2tldHM6IFwiICsgbWV0cmljcy5idWNrZXRzICsgc3BhY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIlxcblwiO1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJjb2xsaXNpb25zOiBcIiArIG1ldHJpY3MuY29sbGlzaW9ucyArIHNwYWNlO1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcInBhaXJzOiBcIiArIGVuZ2luZS5wYWlycy5saXN0Lmxlbmd0aCArIHNwYWNlO1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcImJyb2FkOiBcIiArIG1ldHJpY3MuYnJvYWRFZmYgKyBzcGFjZTtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJtaWQ6IFwiICsgbWV0cmljcy5taWRFZmYgKyBzcGFjZTtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJuYXJyb3c6IFwiICsgbWV0cmljcy5uYXJyb3dFZmYgKyBzcGFjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBAZW5kaWYgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIHJlbmRlci5kZWJ1Z1N0cmluZyA9IHRleHQ7XHJcbiAgICAgICAgICAgIHJlbmRlci5kZWJ1Z1RpbWVzdGFtcCA9IGVuZ2luZS50aW1pbmcudGltZXN0YW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlbmRlci5kZWJ1Z1N0cmluZykge1xyXG4gICAgICAgICAgICBjLmZvbnQgPSBcIjEycHggQXJpYWxcIjtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC41KSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNSknO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSByZW5kZXIuZGVidWdTdHJpbmcuc3BsaXQoJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYy5maWxsVGV4dChzcGxpdFtpXSwgNTAsIDUwICsgaSAqIDE4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgY29uc3RyYWludHNcclxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludFtdfSBjb25zdHJhaW50c1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5jb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQucmVuZGVyLnZpc2libGUgfHwgIWNvbnN0cmFpbnQucG9pbnRBIHx8ICFjb25zdHJhaW50LnBvaW50QilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QjtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5QSkge1xyXG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGMubW92ZVRvKGJvZHlBLnBvc2l0aW9uLnggKyBjb25zdHJhaW50LnBvaW50QS54LCBib2R5QS5wb3NpdGlvbi55ICsgY29uc3RyYWludC5wb2ludEEueSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oY29uc3RyYWludC5wb2ludEEueCwgY29uc3RyYWludC5wb2ludEEueSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgYy5saW5lVG8oYm9keUIucG9zaXRpb24ueCArIGNvbnN0cmFpbnQucG9pbnRCLngsIGJvZHlCLnBvc2l0aW9uLnkgKyBjb25zdHJhaW50LnBvaW50Qi55KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMubGluZVRvKGNvbnN0cmFpbnQucG9pbnRCLngsIGNvbnN0cmFpbnQucG9pbnRCLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IGNvbnN0cmFpbnQucmVuZGVyLmxpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSBjb25zdHJhaW50LnJlbmRlci5zdHJva2VTdHlsZTtcclxuICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBib2R5U2hhZG93c1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5U2hhZG93cyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkuY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgYy5hcmMoYm9keS5wb3NpdGlvbi54LCBib2R5LnBvc2l0aW9uLnksIGJvZHkuY2lyY2xlUmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGMubW92ZVRvKGJvZHkudmVydGljZXNbMF0ueCwgYm9keS52ZXJ0aWNlc1swXS55KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYm9keS52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMubGluZVRvKGJvZHkudmVydGljZXNbal0ueCwgYm9keS52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBib2R5LnBvc2l0aW9uLnggLSByZW5kZXIub3B0aW9ucy53aWR0aCAqIDAuNSxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlWSA9IGJvZHkucG9zaXRpb24ueSAtIHJlbmRlci5vcHRpb25zLmhlaWdodCAqIDAuMixcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2VYKSArIE1hdGguYWJzKGRpc3RhbmNlWSk7XHJcblxyXG4gICAgICAgICAgICBjLnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC4xNSknO1xyXG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFggPSAwLjA1ICogZGlzdGFuY2VYO1xyXG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFkgPSAwLjA1ICogZGlzdGFuY2VZO1xyXG4gICAgICAgICAgICBjLnNoYWRvd0JsdXIgPSAxICsgMTIgKiBNYXRoLm1pbigxLCBkaXN0YW5jZSAvIDEwMDApO1xyXG5cclxuICAgICAgICAgICAgYy5maWxsKCk7XHJcblxyXG4gICAgICAgICAgICBjLnNoYWRvd0NvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgYy5zaGFkb3dPZmZzZXRYID0gbnVsbDtcclxuICAgICAgICAgICAgYy5zaGFkb3dPZmZzZXRZID0gbnVsbDtcclxuICAgICAgICAgICAgYy5zaGFkb3dCbHVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2RpZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IG9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMgfHwgIW9wdGlvbnMud2lyZWZyYW1lcyxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgcGFydCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaztcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcclxuICAgICAgICAgICAgZm9yIChrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQucmVuZGVyLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1NsZWVwaW5nICYmIGJvZHkuaXNTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAwLjUgKiBwYXJ0LnJlbmRlci5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnJlbmRlci5vcGFjaXR5ICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IHBhcnQucmVuZGVyLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQucmVuZGVyLnNwcml0ZSAmJiBwYXJ0LnJlbmRlci5zcHJpdGUudGV4dHVyZSAmJiAhb3B0aW9ucy53aXJlZnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBzcHJpdGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gcGFydC5yZW5kZXIuc3ByaXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gX2dldFRleHR1cmUocmVuZGVyLCBzcHJpdGUudGV4dHVyZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTsgXHJcbiAgICAgICAgICAgICAgICAgICAgYy5yb3RhdGUocGFydC5hbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoICogLXNwcml0ZS54T2Zmc2V0ICogc3ByaXRlLnhTY2FsZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ICogLXNwcml0ZS55T2Zmc2V0ICogc3ByaXRlLnlTY2FsZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUud2lkdGggKiBzcHJpdGUueFNjYWxlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgKiBzcHJpdGUueVNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IHRyYW5zbGF0aW9uLCBob3BlZnVsbHkgZmFzdGVyIHRoYW4gc2F2ZSAvIHJlc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICBjLnJvdGF0ZSgtcGFydC5hbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy50cmFuc2xhdGUoLXBhcnQucG9zaXRpb24ueCwgLXBhcnQucG9zaXRpb24ueSk7IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5hcmMocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnksIHBhcnQuY2lyY2xlUmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhwYXJ0LnZlcnRpY2VzW2pdLngsIHBhcnQudmVydGljZXNbal0ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC52ZXJ0aWNlc1tqXS5pc0ludGVybmFsICYmICFzaG93SW50ZXJuYWxFZGdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS54LCBwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gcGFydC5yZW5kZXIuZmlsbFN0eWxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQucmVuZGVyLmxpbmVXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSBwYXJ0LnJlbmRlci5saW5lV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gcGFydC5yZW5kZXIuc3Ryb2tlU3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmZpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnI2JiYic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBib2R5V2lyZWZyYW1lc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5V2lyZWZyYW1lcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IHJlbmRlci5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzLFxyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBwYXJ0LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBrO1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgYWxsIGJvZGllc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgICAgIGZvciAoayA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XHJcblxyXG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnZlcnRpY2VzW2ogLSAxXS5pc0ludGVybmFsIHx8IHNob3dJbnRlcm5hbEVkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzW2pdLngsIHBhcnQudmVydGljZXNbal0ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydC52ZXJ0aWNlc1tqXS5pc0ludGVybmFsICYmICFzaG93SW50ZXJuYWxFZGdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueCwgcGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9ICcjYmJiJztcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSBjb252ZXggaHVsbCB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBib2R5Q29udmV4SHVsbHNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuYm9keUNvbnZleEh1bGxzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIHBhcnQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgIGs7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBjb252ZXggaHVsbHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUgfHwgYm9keS5wYXJ0cy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHkudmVydGljZXNbMF0ueCwgYm9keS52ZXJ0aWNlc1swXS55KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBib2R5LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzW2pdLngsIGJvZHkudmVydGljZXNbal0ueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHkudmVydGljZXNbMF0ueCwgYm9keS52ZXJ0aWNlc1swXS55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKSc7XHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGJvZHkgdmVydGV4IG51bWJlcnMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCB2ZXJ0ZXhOdW1iZXJzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLnZlcnRleE51bWJlcnMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgaztcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBib2RpZXNbaV0ucGFydHM7XHJcbiAgICAgICAgICAgIGZvciAoayA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IHBhcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2tdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMiknO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuZmlsbFRleHQoaSArICdfJyArIGosIHBhcnQucG9zaXRpb24ueCArIChwYXJ0LnZlcnRpY2VzW2pdLnggLSBwYXJ0LnBvc2l0aW9uLngpICogMC44LCBwYXJ0LnBvc2l0aW9uLnkgKyAocGFydC52ZXJ0aWNlc1tqXS55IC0gcGFydC5wb3NpdGlvbi55KSAqIDAuOCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBtb3VzZSBwb3NpdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIG1vdXNlUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLm1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihyZW5kZXIsIG1vdXNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0O1xyXG4gICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC44KSc7XHJcbiAgICAgICAgYy5maWxsVGV4dChtb3VzZS5wb3NpdGlvbi54ICsgJyAgJyArIG1vdXNlLnBvc2l0aW9uLnksIG1vdXNlLnBvc2l0aW9uLnggKyA1LCBtb3VzZS5wb3NpdGlvbi55IC0gNSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYm9keSBib3VuZHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlCb3VuZHNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuYm9keUJvdW5kcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkucmVuZGVyLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgYy5yZWN0KHBhcnQuYm91bmRzLm1pbi54LCBwYXJ0LmJvdW5kcy5taW4ueSwgcGFydC5ib3VuZHMubWF4LnggLSBwYXJ0LmJvdW5kcy5taW4ueCwgcGFydC5ib3VuZHMubWF4LnkgLSBwYXJ0LmJvdW5kcy5taW4ueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDgpJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMC4xKSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBib2R5IGFuZ2xlIGluZGljYXRvcnMgYW5kIGF4ZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlBeGVzXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgUmVuZGVyLmJvZHlBeGVzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgcGFydCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgaztcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcclxuICAgICAgICAgICAgICAgIHBhcnRzID0gYm9keS5wYXJ0cztcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0F4ZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhbGwgYXhlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnQuYXhlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBhcnQuYXhlc1trXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhwYXJ0LnBvc2l0aW9uLnggKyBheGlzLnggKiAyMCwgcGFydC5wb3NpdGlvbi55ICsgYXhpcy55ICogMjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBwYXJ0LmF4ZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGEgc2luZ2xlIGF4aXMgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8oKHBhcnQudmVydGljZXNbMF0ueCArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueCkgLyAyLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnQudmVydGljZXNbMF0ueSArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdpbmRpYW5yZWQnO1xyXG4gICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCknO1xyXG4gICAgICAgICAgICBjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdvdmVybGF5JztcclxuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgICAgICBjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYm9keSBwb3NpdGlvbnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlQb3NpdGlvbnNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuYm9keVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIHBhcnQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGs7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBjdXJyZW50IHBvc2l0aW9uc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcclxuICAgICAgICAgICAgICAgIGMuYXJjKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55LCAzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xyXG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdpbmRpYW5yZWQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC41KSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGMuZmlsbCgpO1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgcHJldmlvdXMgcG9zaXRpb25zXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYm9keS5yZW5kZXIudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgYy5hcmMoYm9keS5wb3NpdGlvblByZXYueCwgYm9keS5wb3NpdGlvblByZXYueSwgMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuOCknO1xyXG4gICAgICAgIGMuZmlsbCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGJvZHkgdmVsb2NpdHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGJvZHlWZWxvY2l0eVxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5VmVsb2NpdHkgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dDtcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgYy5saW5lVG8oYm9keS5wb3NpdGlvbi54ICsgKGJvZHkucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb25QcmV2LngpICogMiwgYm9keS5wb3NpdGlvbi55ICsgKGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2LnkpICogMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLmxpbmVXaWR0aCA9IDM7XHJcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdjb3JuZmxvd2VyYmx1ZSc7XHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBib2R5IGlkc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYm9keUlkc1xyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ib2R5SWRzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGo7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFib2RpZXNbaV0ucmVuZGVyLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcclxuICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbal07XHJcbiAgICAgICAgICAgICAgICBjLmZvbnQgPSBcIjEycHggQXJpYWxcIjtcclxuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC41KSc7XHJcbiAgICAgICAgICAgICAgICBjLmZpbGxUZXh0KHBhcnQuaWQsIHBhcnQucG9zaXRpb24ueCArIDEwLCBwYXJ0LnBvc2l0aW9uLnkgLSAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGNvbGxpc2lvbnNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5jb2xsaXNpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBwYWlycywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjID0gY29udGV4dCxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBwYWlyLFxyXG4gICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgIGNvcnJlY3RlZCxcclxuICAgICAgICAgICAgYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBqO1xyXG5cclxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xyXG5cclxuICAgICAgICAvLyByZW5kZXIgY29sbGlzaW9uIHBvc2l0aW9uc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzW2pdLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IGNvbnRhY3QudmVydGV4O1xyXG4gICAgICAgICAgICAgICAgYy5yZWN0KHZlcnRleC54IC0gMS41LCB2ZXJ0ZXgueSAtIDEuNSwgMy41LCAzLjUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC43KSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnb3JhbmdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYy5maWxsKCk7XHJcblxyXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIHJlbmRlciBjb2xsaXNpb24gbm9ybWFsc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbFBvc1ggPSBwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC54LFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1kgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC55O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1ggPSAocGFpci5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCArIHBhaXIuYWN0aXZlQ29udGFjdHNbMV0udmVydGV4LngpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxQb3NZID0gKHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4LnkgKyBwYWlyLmFjdGl2ZUNvbnRhY3RzWzFdLnZlcnRleC55KSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUIgPT09IGNvbGxpc2lvbi5zdXBwb3J0c1swXS5ib2R5IHx8IGNvbGxpc2lvbi5ib2R5QS5pc1N0YXRpYyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKG5vcm1hbFBvc1ggLSBjb2xsaXNpb24ubm9ybWFsLnggKiA4LCBub3JtYWxQb3NZIC0gY29sbGlzaW9uLm5vcm1hbC55ICogOCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKG5vcm1hbFBvc1ggKyBjb2xsaXNpb24ubm9ybWFsLnggKiA4LCBub3JtYWxQb3NZICsgY29sbGlzaW9uLm5vcm1hbC55ICogOCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYy5saW5lVG8obm9ybWFsUG9zWCwgbm9ybWFsUG9zWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjcpJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ29yYW5nZSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgYy5zdHJva2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2Qgc2VwYXJhdGlvbnNcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5zZXBhcmF0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgcGFpcnMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcclxuICAgICAgICAgICAgcGFpcixcclxuICAgICAgICAgICAgY29sbGlzaW9uLFxyXG4gICAgICAgICAgICBjb3JyZWN0ZWQsXHJcbiAgICAgICAgICAgIGJvZHlBLFxyXG4gICAgICAgICAgICBib2R5QixcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgajtcclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIHNlcGFyYXRpb25zXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XHJcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBO1xyXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QjtcclxuXHJcbiAgICAgICAgICAgIHZhciBrID0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9keUIuaXNTdGF0aWMgJiYgIWJvZHlBLmlzU3RhdGljKSBrID0gMC41O1xyXG4gICAgICAgICAgICBpZiAoYm9keUIuaXNTdGF0aWMpIGsgPSAwO1xyXG5cclxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keUIucG9zaXRpb24ueCwgYm9keUIucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlCLnBvc2l0aW9uLnkgLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xyXG5cclxuICAgICAgICAgICAgayA9IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJvZHlCLmlzU3RhdGljICYmICFib2R5QS5pc1N0YXRpYykgayA9IDAuNTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU3RhdGljKSBrID0gMDtcclxuXHJcbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHlBLnBvc2l0aW9uLngsIGJvZHlBLnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5QS5wb3NpdGlvbi54ICsgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnggKiBrLCBib2R5QS5wb3NpdGlvbi55ICsgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnkgKiBrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjUpJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ29yYW5nZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGMuc3Ryb2tlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWV0aG9kIGdyaWRcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7Z3JpZH0gZ3JpZFxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlbmRlci5ncmlkID0gZnVuY3Rpb24ocmVuZGVyLCBncmlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxODAsMCwwLjEpJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE4MCwwLDAuNSknO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAgICAgdmFyIGJ1Y2tldEtleXMgPSBDb21tb24ua2V5cyhncmlkLmJ1Y2tldHMpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1Y2tldElkID0gYnVja2V0S2V5c1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChncmlkLmJ1Y2tldHNbYnVja2V0SWRdLmxlbmd0aCA8IDIpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWdpb24gPSBidWNrZXRJZC5zcGxpdCgvQ3xSLyk7XHJcbiAgICAgICAgICAgIGMucmVjdCgwLjUgKyBwYXJzZUludChyZWdpb25bMV0sIDEwKSAqIGdyaWQuYnVja2V0V2lkdGgsIFxyXG4gICAgICAgICAgICAgICAgICAgIDAuNSArIHBhcnNlSW50KHJlZ2lvblsyXSwgMTApICogZ3JpZC5idWNrZXRIZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgICAgIGdyaWQuYnVja2V0V2lkdGgsIFxyXG4gICAgICAgICAgICAgICAgICAgIGdyaWQuYnVja2V0SGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjLnN0cm9rZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBpbnNwZWN0b3JcclxuICAgICAqIEBwYXJhbSB7aW5zcGVjdG9yfSBpbnNwZWN0b3JcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZW5kZXIuaW5zcGVjdG9yID0gZnVuY3Rpb24oaW5zcGVjdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGVuZ2luZSA9IGluc3BlY3Rvci5lbmdpbmUsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gaW5zcGVjdG9yLnNlbGVjdGVkLFxyXG4gICAgICAgICAgICByZW5kZXIgPSBpbnNwZWN0b3IucmVuZGVyLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGJvdW5kcztcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZHNXaWR0aCA9IHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54LFxyXG4gICAgICAgICAgICAgICAgYm91bmRzSGVpZ2h0ID0gcmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnksXHJcbiAgICAgICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgYm91bmRzU2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcclxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLXJlbmRlci5ib3VuZHMubWluLngsIC1yZW5kZXIuYm91bmRzLm1pbi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZWxlY3RlZFtpXS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC45KSc7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsMl0pO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBib2R5IHNlbGVjdGlvbnNcclxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IGl0ZW0uYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAtIDMpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSAtIDMpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCArIDYpLCBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSArIDYpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGNvbnN0cmFpbnQgc2VsZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gaXRlbS5wb2ludEE7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5ib2R5QSlcclxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGl0ZW0ucG9pbnRCO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHBvaW50LngsIHBvaW50LnksIDEwLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtMC41LCAtMC41KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBzZWxlY3Rpb24gcmVnaW9uXHJcbiAgICAgICAgaWYgKGluc3BlY3Rvci5zZWxlY3RTdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjYpJztcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC4xKSc7XHJcbiAgICAgICAgICAgIGJvdW5kcyA9IGluc3BlY3Rvci5zZWxlY3RCb3VuZHM7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVjdChNYXRoLmZsb29yKGJvdW5kcy5taW4ueCksIE1hdGguZmxvb3IoYm91bmRzLm1pbi55KSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCksIE1hdGguZmxvb3IoYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtMC41LCAtMC41KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcylcclxuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUNhbnZhc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7fSB3aWR0aFxyXG4gICAgICogQHBhcmFtIHt9IGhlaWdodFxyXG4gICAgICogQHJldHVybiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgdmFyIF9jcmVhdGVDYW52YXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgICAgIGNhbnZhcy5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAbWV0aG9kIF9nZXRQaXhlbFJhdGlvXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FudmFzXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXHJcbiAgICAgKi9cclxuICAgIHZhciBfZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXHJcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxyXG4gICAgICAgICAgICBiYWNraW5nU3RvcmVQaXhlbFJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVQaXhlbFJhdGlvO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJlcXVlc3RlZCB0ZXh0dXJlIChhbiBJbWFnZSkgdmlhIGl0cyBwYXRoXHJcbiAgICAgKiBAbWV0aG9kIF9nZXRUZXh0dXJlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlUGF0aFxyXG4gICAgICogQHJldHVybiB7SW1hZ2V9IHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgdmFyIF9nZXRUZXh0dXJlID0gZnVuY3Rpb24ocmVuZGVyLCBpbWFnZVBhdGgpIHtcclxuICAgICAgICB2YXIgaW1hZ2UgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXTtcclxuXHJcbiAgICAgICAgaWYgKGltYWdlKVxyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcblxyXG4gICAgICAgIGltYWdlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF0gPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVBhdGg7XHJcblxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBiYWNrZ3JvdW5kIHRvIHRoZSBjYW52YXMgdXNpbmcgQ1NTLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUJhY2tncm91bmRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxyXG4gICAgICovXHJcbiAgICB2YXIgX2FwcGx5QmFja2dyb3VuZCA9IGZ1bmN0aW9uKHJlbmRlciwgYmFja2dyb3VuZCkge1xyXG4gICAgICAgIHZhciBjc3NCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuXHJcbiAgICAgICAgaWYgKC8oanBnfGdpZnxwbmcpJC8udGVzdChiYWNrZ3JvdW5kKSlcclxuICAgICAgICAgICAgY3NzQmFja2dyb3VuZCA9ICd1cmwoJyArIGJhY2tncm91bmQgKyAnKSc7XHJcblxyXG4gICAgICAgIHJlbmRlci5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IGNzc0JhY2tncm91bmQ7XHJcbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiY29udGFpblwiO1xyXG4gICAgICAgIHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICAqXHJcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYmVmb3JlIHJlbmRlcmluZ1xyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVuZGVyXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBhZnRlclJlbmRlclxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYmFjay1yZWZlcmVuY2UgdG8gdGhlIGBNYXR0ZXIuUmVuZGVyYCBtb2R1bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbnRyb2xsZXJcclxuICAgICAqIEB0eXBlIHJlbmRlclxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYE1hdHRlci5FbmdpbmVgIGluc3RhbmNlIHRvIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGVuZ2luZVxyXG4gICAgICogQHR5cGUgZW5naW5lXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBjYW52YXMgaXMgdG8gYmUgaW5zZXJ0ZWQgKGlmIGByZW5kZXIuY2FudmFzYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkKVxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBlbGVtZW50XHJcbiAgICAgKiBAdHlwZSBIVE1MRWxlbWVudFxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdG8gcmVuZGVyIHRvLiBJZiBub3Qgc3BlY2lmaWVkLCBvbmUgd2lsbCBiZSBjcmVhdGVkIGlmIGByZW5kZXIuZWxlbWVudGAgaGFzIGJlZW4gc3BlY2lmaWVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjYW52YXNcclxuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7fVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0IHdpZHRoIGluIHBpeGVscyBvZiB0aGUgYHJlbmRlci5jYW52YXNgIHRvIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMud2lkdGhcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgODAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgYHJlbmRlci5jYW52YXNgIHRvIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuaGVpZ2h0XHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDYwMFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgaWYgYHJlbmRlci5ib3VuZHNgIHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLmhhc0JvdW5kc1xyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgQm91bmRzYCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgdGhlIGRyYXdpbmcgdmlldyByZWdpb24uIFxyXG4gICAgICogUmVuZGVyaW5nIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cmFuc2Zvcm1lZCBhbmQgc2NhbGVkIHRvIGZpdCB3aXRoaW4gdGhlIGNhbnZhcyBzaXplIChgcmVuZGVyLm9wdGlvbnMud2lkdGhgIGFuZCBgcmVuZGVyLm9wdGlvbnMuaGVpZ2h0YCkuXHJcbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgY3JlYXRpbmcgdmlld3MgdGhhdCBjYW4gcGFuIG9yIHpvb20gYXJvdW5kIHRoZSBzY2VuZS5cclxuICAgICAqIFlvdSBtdXN0IGFsc28gc2V0IGByZW5kZXIub3B0aW9ucy5oYXNCb3VuZHNgIHRvIGB0cnVlYCB0byBlbmFibGUgYm91bmRlZCByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xyXG4gICAgICogQHR5cGUgYm91bmRzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSAyZCByZW5kZXJpbmcgY29udGV4dCBmcm9tIHRoZSBgcmVuZGVyLmNhbnZhc2AgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxyXG4gICAgICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcHJpdGUgdGV4dHVyZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZXNcclxuICAgICAqIEB0eXBlIHt9XHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQSBTZXQgaXMgYSBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cclxuXHJcbnZhciBTZXQgPSBmdW5jdGlvbiAoZWxlbWVudHMpXHJcbntcclxuICAgIHRoaXMuZW50cmllcyA9IFtdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoZWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XHJcblxyXG5TZXQucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyeVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkdW1wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ1NldCcpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZW50cnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gIEZvciB3aGVuIHlvdSBrbm93IHRoaXMgU2V0IHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBpdGVyYXRpb25cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZW50cmllcy5zbGljZSgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGVtcFtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBGb3Igd2hlbiB5b3UgYWJzb2x1dGVseSBrbm93IHRoaXMgU2V0IHdvbid0IGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXHJcbiAgICBpdGVyYXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGhpcy5lbnRyaWVzW2ldLCBpKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb250YWluczogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpID4gLTEpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmlvbjogZnVuY3Rpb24gKHNldClcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICBzZXQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfSxcclxuXHJcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFzZXQuY29udGFpbnModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNldC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBzaXplOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGggPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHJ1Y3RzL1NldC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNoYWxsb3cgT2JqZWN0IENsb25lLiBXaWxsIG5vdCBjbG9uZSBuZXN0ZWQgb2JqZWN0cy5cclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChvYmopXHJcbntcclxuICAgIHZhciBjbG9uZSA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xvbmVba2V5XSA9IG9ialtrZXldLnNsaWNlKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbG9uZVtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuQWN0aW9uc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQW5nbGU6IHJlcXVpcmUoJy4vQW5nbGUnKSxcclxuICAgIENhbGw6IHJlcXVpcmUoJy4vQ2FsbCcpLFxyXG4gICAgR2V0Rmlyc3Q6IHJlcXVpcmUoJy4vR2V0Rmlyc3QnKSxcclxuICAgIEdyaWRBbGlnbjogcmVxdWlyZSgnLi9HcmlkQWxpZ24nKSxcclxuICAgIEluY0FscGhhOiByZXF1aXJlKCcuL0luY0FscGhhJyksXHJcbiAgICBJbmNYOiByZXF1aXJlKCcuL0luY1gnKSxcclxuICAgIEluY1hZOiByZXF1aXJlKCcuL0luY1hZJyksXHJcbiAgICBJbmNZOiByZXF1aXJlKCcuL0luY1knKSxcclxuICAgIFBsYWNlT25DaXJjbGU6IHJlcXVpcmUoJy4vUGxhY2VPbkNpcmNsZScpLFxyXG4gICAgUGxhY2VPbkxpbmU6IHJlcXVpcmUoJy4vUGxhY2VPbkxpbmUnKSxcclxuICAgIFBsYWNlT25SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUGxhY2VPblJlY3RhbmdsZScpLFxyXG4gICAgUGxhY2VPblRyaWFuZ2xlOiByZXF1aXJlKCcuL1BsYWNlT25UcmlhbmdsZScpLFxyXG4gICAgUGxheUFuaW1hdGlvbjogcmVxdWlyZSgnLi9QbGF5QW5pbWF0aW9uJyksXHJcbiAgICBSYW5kb21DaXJjbGU6IHJlcXVpcmUoJy4vUmFuZG9tQ2lyY2xlJyksXHJcbiAgICBSYW5kb21FbGxpcHNlOiByZXF1aXJlKCcuL1JhbmRvbUVsbGlwc2UnKSxcclxuICAgIFJhbmRvbUxpbmU6IHJlcXVpcmUoJy4vUmFuZG9tTGluZScpLFxyXG4gICAgUmFuZG9tUmVjdGFuZ2xlOiByZXF1aXJlKCcuL1JhbmRvbVJlY3RhbmdsZScpLFxyXG4gICAgUmFuZG9tVHJpYW5nbGU6IHJlcXVpcmUoJy4vUmFuZG9tVHJpYW5nbGUnKSxcclxuICAgIFJvdGF0ZTogcmVxdWlyZSgnLi9Sb3RhdGUnKSxcclxuICAgIFJvdGF0ZUFyb3VuZDogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmQnKSxcclxuICAgIFJvdGF0ZUFyb3VuZERpc3RhbmNlOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZERpc3RhbmNlJyksXHJcbiAgICBTY2FsZVg6IHJlcXVpcmUoJy4vU2NhbGVYJyksXHJcbiAgICBTY2FsZVhZOiByZXF1aXJlKCcuL1NjYWxlWFknKSxcclxuICAgIFNjYWxlWTogcmVxdWlyZSgnLi9TY2FsZVknKSxcclxuICAgIFNldEFscGhhOiByZXF1aXJlKCcuL1NldEFscGhhJyksXHJcbiAgICBTZXRPcmlnaW46IHJlcXVpcmUoJy4vU2V0T3JpZ2luJyksXHJcbiAgICBTZXRSb3RhdGlvbjogcmVxdWlyZSgnLi9TZXRSb3RhdGlvbicpLFxyXG4gICAgU2V0U2NhbGU6IHJlcXVpcmUoJy4vU2V0U2NhbGUnKSxcclxuICAgIFNldFNjYWxlWDogcmVxdWlyZSgnLi9TZXRTY2FsZVgnKSxcclxuICAgIFNldFNjYWxlWTogcmVxdWlyZSgnLi9TZXRTY2FsZVknKSxcclxuICAgIFNldFZpc2libGU6IHJlcXVpcmUoJy4vU2V0VmlzaWJsZScpLFxyXG4gICAgU2V0WDogcmVxdWlyZSgnLi9TZXRYJyksXHJcbiAgICBTZXRYWTogcmVxdWlyZSgnLi9TZXRYWScpLFxyXG4gICAgU2V0WTogcmVxdWlyZSgnLi9TZXRZJyksXHJcbiAgICBTaGlmdFBvc2l0aW9uOiByZXF1aXJlKCcuL1NoaWZ0UG9zaXRpb24nKSxcclxuICAgIFNtb290aGVyU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhlclN0ZXAnKSxcclxuICAgIFNtb290aFN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoU3RlcCcpLFxyXG4gICAgU3ByZWFkOiByZXF1aXJlKCcuL1NwcmVhZCcpLFxyXG4gICAgVG9nZ2xlVmlzaWJsZTogcmVxdWlyZSgnLi9Ub2dnbGVWaXNpYmxlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcclxuXHJcbi8qKlxyXG4qIEEgQmFzZSBTdGF0ZSBDbGFzcy5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuU3RhdGVcclxuKiBAY29uc3RydWN0b3JcclxuKi9cclxudmFyIFN0YXRlID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgLy8gIFRoZSBTdGF0ZSBTeXN0ZW1zLiBZb3UgbXVzdCBuZXZlciBvdmVyd3JpdGUgdGhpcyBwcm9wZXJ0eSwgb3IgYWxsIGhlbGwgd2lsbCBicmVhayBsb3NlLlxyXG4gICAgdGhpcy5zeXMgPSBuZXcgU3lzdGVtcyh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnN5cy5zZXR0aW5ncztcclxufTtcclxuXHJcblN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXRlO1xyXG5cclxuU3RhdGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8vICBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhbWUgPSByZXF1aXJlKCcuL0ZyYW1lJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIEdldEZyYW1lcyA9IGZ1bmN0aW9uICh0ZXh0dXJlTWFuYWdlciwgZnJhbWVzKVxyXG57XHJcbiAgICAvLyAgICAgIGZyYW1lczogW1xyXG4gICAgLy8gICAgICAgICAgeyBrZXk6IHRleHR1cmVLZXksIGZyYW1lOiB0ZXh0dXJlRnJhbWUgfSxcclxuICAgIC8vICAgICAgICAgIHsga2V5OiB0ZXh0dXJlS2V5LCBmcmFtZTogdGV4dHVyZUZyYW1lLCBkdXJhdGlvbjogZmxvYXQgfSxcclxuICAgIC8vICAgICAgICAgIHsga2V5OiB0ZXh0dXJlS2V5LCBmcmFtZTogdGV4dHVyZUZyYW1lLCBvblVwZGF0ZTogZnVuY3Rpb24gfVxyXG4gICAgLy8gICAgICAgICAgeyBrZXk6IHRleHR1cmVLZXksIGZyYW1lOiB0ZXh0dXJlRnJhbWUsIHZpc2libGU6IGJvb2xlYW4gfVxyXG4gICAgLy8gICAgICBdLFxyXG5cclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIHZhciBwcmV2O1xyXG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lO1xyXG4gICAgdmFyIGluZGV4ID0gMTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHRleHR1cmVLZXk7XHJcblxyXG4gICAgLy8gIGlmIGZyYW1lcyBpcyBhIHN0cmluZywgd2UnbGwgZ2V0IGFsbCB0aGUgZnJhbWVzIGZyb20gdGhlIHRleHR1cmUgbWFuYWdlciBhcyBpZiBpdCdzIGEgc3ByaXRlIHNoZWV0XHJcbiAgICBpZiAodHlwZW9mIGZyYW1lcyA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgdGV4dHVyZUtleSA9IGZyYW1lcztcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlTWFuYWdlci5nZXQodGV4dHVyZUtleSk7XHJcbiAgICAgICAgdmFyIGZyYW1lS2V5cyA9IHRleHR1cmUuZ2V0RnJhbWVOYW1lcygpO1xyXG5cclxuICAgICAgICBmcmFtZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZnJhbWVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGlkeCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgZnJhbWVzLnB1c2goeyBrZXk6IHRleHR1cmVLZXksIGZyYW1lOiB2YWx1ZSB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zb2xlLnRhYmxlKGZyYW1lcyk7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYW1lcykgfHwgZnJhbWVzLmxlbmd0aCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBmcmFtZXNbaV07XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSBHZXRWYWx1ZShpdGVtLCAna2V5JywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmICgha2V5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSBHZXRWYWx1ZShpdGVtLCAnZnJhbWUnLCAwKTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmVGcmFtZSA9IHRleHR1cmVNYW5hZ2VyLmdldEZyYW1lKGtleSwgZnJhbWUpO1xyXG5cclxuICAgICAgICBhbmltYXRpb25GcmFtZSA9IG5ldyBGcmFtZShrZXksIGZyYW1lLCBpbmRleCwgdGV4dHVyZUZyYW1lKTtcclxuXHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUuZHVyYXRpb24gPSBHZXRWYWx1ZShpdGVtLCAnZHVyYXRpb24nLCAwKTtcclxuICAgICAgICBhbmltYXRpb25GcmFtZS5vblVwZGF0ZSA9IEdldFZhbHVlKGl0ZW0sICdvblVwZGF0ZScsIG51bGwpO1xyXG5cclxuICAgICAgICB2YXIgdmlzaWJsZSA9IEdldFZhbHVlKGl0ZW0sICd2aXNpYmxlJywgbnVsbCk7XHJcblxyXG4gICAgICAgIGlmICh2aXNpYmxlICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uRnJhbWUuc2V0VmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lLnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUuaXNGaXJzdCA9ICghcHJldik7XHJcblxyXG4gICAgICAgIC8vICBUaGUgcHJldmlvdXNseSBjcmVhdGVkIGFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgaWYgKHByZXYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcmV2Lm5leHRGcmFtZSA9IGFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgICAgICAgYW5pbWF0aW9uRnJhbWUucHJldkZyYW1lID0gcHJldjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dC5wdXNoKGFuaW1hdGlvbkZyYW1lKTtcclxuXHJcbiAgICAgICAgcHJldiA9IGFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvdXQubGVuZ3RoID4gMClcclxuICAgIHtcclxuICAgICAgICBhbmltYXRpb25GcmFtZS5pc0xhc3QgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyAgTGluayB0aGVtIGVuZC10by1lbmQsIHNvIHRoZXkgbG9vcFxyXG4gICAgICAgIGFuaW1hdGlvbkZyYW1lLm5leHRGcmFtZSA9IG91dFswXTtcclxuXHJcbiAgICAgICAgb3V0WzBdLnByZXZGcmFtZSA9IGFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgICAvLyAgR2VuZXJhdGUgdGhlIHByb2dyZXNzIGRhdGFcclxuXHJcbiAgICAgICAgdmFyIHNsaWNlID0gMSAvIChvdXQubGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRbaV0ucHJvZ3Jlc3MgPSBpICogc2xpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEZyYW1lcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvR2V0RnJhbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxuXHJcbnZhciBDYW1lcmEgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XHJcbiAgICB0aGlzLnVzZUJvdW5kcyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbFggPSAwLjA7XHJcbiAgICB0aGlzLnNjcm9sbFkgPSAwLjA7XHJcbiAgICB0aGlzLnpvb20gPSAxLjA7XHJcbiAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xyXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cclxuICAgIC8vIHNoYWtlXHJcbiAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMC4wO1xyXG4gICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSAwLjA7XHJcbiAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAwLjA7XHJcbiAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAwLjA7XHJcblxyXG4gICAgLy8gZmFkZVxyXG4gICAgdGhpcy5fZmFkZUR1cmF0aW9uID0gMC4wO1xyXG4gICAgdGhpcy5fZmFkZVJlZCA9IDAuMDtcclxuICAgIHRoaXMuX2ZhZGVHcmVlbiA9IDAuMDtcclxuICAgIHRoaXMuX2ZhZGVCbHVlID0gMC4wO1xyXG4gICAgdGhpcy5fZmFkZUFscGhhID0gMC4wO1xyXG5cclxuICAgIC8vIGZsYXNoXHJcbiAgICB0aGlzLl9mbGFzaER1cmF0aW9uID0gMC4wO1xyXG4gICAgdGhpcy5fZmxhc2hSZWQgPSAxLjA7XHJcbiAgICB0aGlzLl9mbGFzaEdyZWVuID0gMS4wO1xyXG4gICAgdGhpcy5fZmxhc2hCbHVlID0gMS4wO1xyXG4gICAgdGhpcy5fZmxhc2hBbHBoYSA9IDAuMDtcclxuXHJcbiAgICAvLyBvcmlnaW5cclxuICAgIHRoaXMuX2ZvbGxvdyA9IG51bGw7XHJcbn07XHJcblxyXG5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FtZXJhO1xyXG5cclxuQ2FtZXJhLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICByZW1vdmVCb3VuZHM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy51c2VCb3VuZHMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fYm91bmRzLnNldEVtcHR5KCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5zZXRUbyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy51c2VCb3VuZHMgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Vmlld3BvcnQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZmxhc2hBbHBoYSA+IDAuMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgLT0gZGVsdGEgLyB0aGlzLl9mbGFzaER1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYXNoQWxwaGEgPCAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mYWRlQWxwaGEgPiAwLjAgJiYgdGhpcy5fZmFkZUFscGhhIDwgMS4wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZmFkZUFscGhhICs9IGRlbHRhIC8gdGhpcy5fZmFkZUR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZhZGVBbHBoYSA+PSAxLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGVBbHBoYSA9IDEuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NoYWtlRHVyYXRpb24gPiAwLjApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gdGhpcy5fc2hha2VJbnRlbnNpdHk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NoYWtlRHVyYXRpb24gPD0gMC4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAwLjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMud2lkdGggKiAyIC0gaW50ZW5zaXR5ICogdGhpcy53aWR0aCkgKiB0aGlzLnpvb207XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMuaGVpZ2h0ICogMiAtIGludGVuc2l0eSAqIHRoaXMuaGVpZ2h0KSAqIHRoaXMuem9vbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRGb2xsb3c6IGZ1bmN0aW9uIChnYW1lT2JqZWN0T3JQb2ludCwgcm91bmRQeClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9sbG93ICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wRm9sbG93KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mb2xsb3cgPSBnYW1lT2JqZWN0T3JQb2ludDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kUHggIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSByb3VuZFB4O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc3RvcEZvbGxvdzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvKiBkbyB1bmZvbGxvdyB3b3JrIGhlcmUgKi9cclxuICAgICAgICB0aGlzLl9mb2xsb3cgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBmbGFzaDogZnVuY3Rpb24gKGR1cmF0aW9uLCByZWQsIGdyZWVuLCBibHVlLCBmb3JjZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXMuX2ZsYXNoQWxwaGEgPiAwLjApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVkID09PSB1bmRlZmluZWQpIHsgcmVkID0gMS4wOyB9XHJcbiAgICAgICAgaWYgKGdyZWVuID09PSB1bmRlZmluZWQpIHsgZ3JlZW4gPSAxLjA7IH1cclxuICAgICAgICBpZiAoYmx1ZSA9PT0gdW5kZWZpbmVkKSB7IGJsdWUgPSAxLjA7IH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmxhc2hSZWQgPSByZWQ7XHJcbiAgICAgICAgdGhpcy5fZmxhc2hHcmVlbiA9IGdyZWVuO1xyXG4gICAgICAgIHRoaXMuX2ZsYXNoQmx1ZSA9IGJsdWU7XHJcblxyXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuTUlOX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmxhc2hEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAxLjA7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhZGU6IGZ1bmN0aW9uIChkdXJhdGlvbiwgcmVkLCBncmVlbiwgYmx1ZSwgZm9yY2UpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7IHJlZCA9IDAuMDsgfVxyXG4gICAgICAgIGlmIChncmVlbiA9PT0gdW5kZWZpbmVkKSB7IGdyZWVuID0gMC4wOyB9XHJcbiAgICAgICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMC4wOyB9XHJcblxyXG4gICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5fZmFkZUFscGhhID4gMC4wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmFkZVJlZCA9IHJlZDtcclxuICAgICAgICB0aGlzLl9mYWRlR3JlZW4gPSBncmVlbjtcclxuICAgICAgICB0aGlzLl9mYWRlQmx1ZSA9IGJsdWU7XHJcblxyXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuTUlOX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmFkZUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fZmFkZUFscGhhID0gTnVtYmVyLk1JTl9WQUxVRTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hha2U6IGZ1bmN0aW9uIChkdXJhdGlvbiwgaW50ZW5zaXR5LCBmb3JjZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoaW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgaW50ZW5zaXR5ID0gMC4wNTsgfVxyXG5cclxuICAgICAgICBpZiAoIWZvcmNlICYmICh0aGlzLl9zaGFrZU9mZnNldFggIT09IDAuMCB8fCB0aGlzLl9zaGFrZU9mZnNldFkgIT09IDAuMCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSBpbnRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRYID0gMDtcclxuICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFkgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmVSZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLnpvb207XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgIHZhciBvcmlnaW5YID0gd2lkdGggLyAyO1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gaGVpZ2h0IC8gMjtcclxuICAgICAgICB2YXIgZm9sbG93ID0gdGhpcy5fZm9sbG93O1xyXG5cclxuICAgICAgICBpZiAoZm9sbG93ICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JpZ2luWCA9IGZvbGxvdy54O1xyXG4gICAgICAgICAgICBvcmlnaW5ZID0gZm9sbG93Lnk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFggPSBvcmlnaW5YIC0gd2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsWSA9IG9yaWdpblkgLSBoZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy51c2VCb3VuZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzWCA9IGJvdW5kcy54O1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzWSA9IGJvdW5kcy55O1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzUiA9IE1hdGgubWF4KGJvdW5kcy5yaWdodCAtIHdpZHRoLCB3aWR0aCk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZHNCID0gTWF0aC5tYXgoYm91bmRzLmJvdHRvbSAtIGhlaWdodCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFggPCBib3VuZHNYKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFggPSBib3VuZHNYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFggPiBib3VuZHNSKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFggPSBib3VuZHNSO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxZIDwgYm91bmRzWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxZID0gYm91bmRzWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxZID4gYm91bmRzQilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxZID0gYm91bmRzQjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucm91bmRQaXhlbHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFggPSBNYXRoLnJvdW5kKHRoaXMuc2Nyb2xsWCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsWSA9IE1hdGgucm91bmQodGhpcy5zY3JvbGxZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdHJpeC5sb2FkSWRlbnRpdHkoKTtcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHRoaXMueCArIG9yaWdpblgsIHRoaXMueSArIG9yaWdpblkpO1xyXG4gICAgICAgIG1hdHJpeC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHpvb20sIHpvb20pO1xyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUoLW9yaWdpblgsIC1vcmlnaW5ZKTtcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHRoaXMuX3NoYWtlT2Zmc2V0WCwgdGhpcy5fc2hha2VPZmZzZXRZKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9DYW1lcmEuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjYW52YXMsIG9wdGlvbnMpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJywgb3B0aW9ucykgfHwgXHJcbiAgICAgICAgbnVsbFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q29udGV4dDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYW52YXMvR2V0Q29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudCcpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG5cclxuLyoqXHJcbiogVGhlIERhdGEgQ29tcG9uZW50IGZlYXR1cmVzIGEgbWVhbnMgdG8gc3RvcmUgcGllY2VzIG9mIGRhdGEgc3BlY2lmaWMgdG8gYSBHYW1lIE9iamVjdCxcclxuKiBzZWFyY2ggaXQsIHF1ZXJ5IGl0LCBhbmQgcmV0cmlldmUgaXQuXHJcbipcclxuKiBAY2xhc3NcclxuKi9cclxudmFyIERhdGEgPSBmdW5jdGlvbiAocGFyZW50KVxyXG57XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSB7fTtcclxuXHJcbiAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3MgPSB7fTtcclxuICAgIHRoaXMuX2FmdGVyQ2FsbGJhY2tzID0ge307XHJcblxyXG4gICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbn07XHJcblxyXG5EYXRhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGE7XHJcblxyXG5EYXRhLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvLyAgUmV0cmlldmVzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoc2VhcmNoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHNlYXJjaCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHRoaXMubGlzdFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9mcm96ZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYmVmb3JlJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcclxuICAgICAgICBpZiAodGhpcy5fYmVmb3JlQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5MT0FERVJfU1RBUlRfRVZFTlQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGVyZSBpcyBhICdhZnRlcicgY2FsbGJhY2ssIHRoZW4gY2hlY2sgaXQgZm9yIGEgcmVzdWx0XHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBzY29wZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBSZW1vdmUgZW50cnlcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaywgc2NvcGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHNjb3BlOiBzY29wZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBhc3NlcyBhbGwgZGF0YSBlbnRyaWVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay4gU3RvcmVzIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGVhY2hcclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICogQHBhcmFtIHtvYmplY3R9IFtzY29wZV0gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBnYW1lIG9iamVjdCwga2V5LCBhbmQgZGF0YS5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyB0aGlzLnBhcmVudCwgbnVsbCwgdW5kZWZpbmVkIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJnc1sxXSA9IGtleTtcclxuICAgICAgICAgICAgYXJnc1syXSA9IHRoaXMubGlzdFtrZXldO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIChkYXRhLCBvdmVyd3JpdGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJ3cml0ZSA9IHRydWU7IH1cclxuXHJcbiAgICAgICAgLy8gIE1lcmdlIGRhdGEgZnJvbSBhbm90aGVyIGNvbXBvbmVudCBpbnRvIHRoaXMgb25lXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlIHx8ICghb3ZlcndyaXRlICYmICF0aGlzLmhhcyhrZXkpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2tleV0gPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBHZXRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gJ2tleScsIGRlbGV0ZXMgaXQgZnJvbSB0aGlzIERhdGEgc3RvcmUsIHRoZW4gcmV0dXJucyBpdC5cclxuICAgIHBvcDogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4gJiYgdGhpcy5oYXMoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2JlZm9yZUNhbGxiYWNrcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2FmdGVyQ2FsbGJhY2tzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEYXRhLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGcmVlemUgdGhpcyBEYXRhIGNvbXBvbmVudCwgc28gbm8gY2hhbmdlcyBjYW4gYmUgd3JpdHRlbiB0byBpdC5cclxuICAgICpcclxuICAgICogQG5hbWUgZnJlZXplXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZnJlZXplXHJcbiAgICAqL1xyXG4gICAgZnJlZXplOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm96ZW47XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9mcm96ZW4gPSAodmFsdWUpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNvdW50OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgQXJuZTE2ID0gcmVxdWlyZSgnLi9wYWxldHRlcy9Bcm5lMTYnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG5cclxudmFyIEdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBkYXRhID0gR2V0VmFsdWUoY29uZmlnLCAnZGF0YScsIFtdKTtcclxuICAgIHZhciBjYW52YXMgPSBHZXRWYWx1ZShjb25maWcsICdjYW52YXMnLCBudWxsKTtcclxuICAgIHZhciBwYWxldHRlID0gR2V0VmFsdWUoY29uZmlnLCAncGFsZXR0ZScsIEFybmUxNik7XHJcbiAgICB2YXIgcGl4ZWxXaWR0aCA9IEdldFZhbHVlKGNvbmZpZywgJ3BpeGVsV2lkdGgnLCAxKTtcclxuICAgIHZhciBwaXhlbEhlaWdodCA9IEdldFZhbHVlKGNvbmZpZywgJ3BpeGVsSGVpZ2h0JywgcGl4ZWxXaWR0aCk7XHJcbiAgICB2YXIgcmVzaXplQ2FudmFzID0gR2V0VmFsdWUoY29uZmlnLCAncmVzaXplQ2FudmFzJywgdHJ1ZSk7XHJcbiAgICB2YXIgY2xlYXJDYW52YXMgPSBHZXRWYWx1ZShjb25maWcsICdjbGVhckNhbnZhcycsIHRydWUpO1xyXG4gICAgdmFyIHByZVJlbmRlciA9IEdldFZhbHVlKGNvbmZpZywgJ3ByZVJlbmRlcicsIG51bGwpO1xyXG4gICAgdmFyIHBvc3RSZW5kZXIgPSBHZXRWYWx1ZShjb25maWcsICdwb3N0UmVuZGVyJywgbnVsbCk7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihNYXRoLmFicyhkYXRhWzBdLmxlbmd0aCAqIHBpeGVsV2lkdGgpKTtcclxuICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKE1hdGguYWJzKGRhdGEubGVuZ3RoICogcGl4ZWxIZWlnaHQpKTtcclxuXHJcbiAgICBpZiAoIWNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZTJEKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJlc2l6ZUNhbnZhcyA9IGZhbHNlO1xyXG4gICAgICAgIGNsZWFyQ2FudmFzID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlc2l6ZUNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBpZiAoY2xlYXJDYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgcHJlUmVuZGVyIENhbGxiYWNrP1xyXG4gICAgaWYgKHByZVJlbmRlcilcclxuICAgIHtcclxuICAgICAgICBwcmVSZW5kZXIoY2FudmFzLCBjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBEcmF3IGl0XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGRhdGEubGVuZ3RoOyB5KyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJvdyA9IGRhdGFbeV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcm93Lmxlbmd0aDsgeCsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGQgPSByb3dbeF07XHJcblxyXG4gICAgICAgICAgICBpZiAoZCAhPT0gJy4nICYmIGQgIT09ICcgJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhbGV0dGVbZF07XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAqIHBpeGVsV2lkdGgsIHkgKiBwaXhlbEhlaWdodCwgcGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBwb3N0UmVuZGVyIENhbGxiYWNrP1xyXG4gICAgaWYgKHBvc3RSZW5kZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcG9zdFJlbmRlcihjYW52YXMsIGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2VuZXJhdGVUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NyZWF0ZS9HZW5lcmF0ZVRleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIDE2IGNvbG9yIHBhbGV0dGUgYnkgW0FybmVdKGh0dHA6Ly9hbmRyb2lkYXJ0cy5jb20vcGFsZXR0ZS8xNnBhbC5odG0pXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge0FycmF5fVxyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAwOiAnIzAwMCcsIFxyXG4gICAgMTogJyM5RDlEOUQnLCBcclxuICAgIDI6ICcjRkZGJywgXHJcbiAgICAzOiAnI0JFMjYzMycsIFxyXG4gICAgNDogJyNFMDZGOEInLCBcclxuICAgIDU6ICcjNDkzQzJCJywgXHJcbiAgICA2OiAnI0E0NjQyMicsIFxyXG4gICAgNzogJyNFQjg5MzEnLCBcclxuICAgIDg6ICcjRjdFMjZCJywgXHJcbiAgICA5OiAnIzJGNDg0RScsIFxyXG4gICAgQTogJyM0NDg5MUEnLCBcclxuICAgIEI6ICcjQTNDRTI3JywgXHJcbiAgICBDOiAnIzFCMjYzMicsIFxyXG4gICAgRDogJyMwMDU3ODQnLCBcclxuICAgIEU6ICcjMzFBMkYyJywgXHJcbiAgICBGOiAnI0IyRENFRidcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jcmVhdGUvcGFsZXR0ZXMvQXJuZTE2LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG5cclxudmFyIENhbnZhc0ZlYXR1cmVzID0ge1xyXG5cclxuICAgIHN1cHBvcnROZXdCbGVuZE1vZGVzOiBmYWxzZSxcclxuXHJcbiAgICBzdXBwb3J0SW52ZXJzZUFscGhhOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrQmxlbmRNb2RlICgpXHJcbntcclxuICAgIHZhciBwbmdIZWFkID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVFBQUFBQkFRTUFBQUREOHAyT0FBQUFBMUJNVkVYLyc7XHJcbiAgICB2YXIgcG5nRW5kID0gJ0FBQUFDa2xFUVZRSTEyTmdBQUFBQWdBQjRpRzhNd0FBQUFCSlJVNUVya0pnZ2c9PSc7XHJcblxyXG4gICAgdmFyIG1hZ2VudGEgPSBuZXcgSW1hZ2UoKTtcclxuICAgIG1hZ2VudGEuc3JjID0gcG5nSGVhZCArICdBUDgwNE9hNicgKyBwbmdFbmQ7XHJcblxyXG4gICAgdmFyIHllbGxvdyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgeWVsbG93LnNyYyA9IHBuZ0hlYWQgKyAnL3dDS3h2UkYnICsgcG5nRW5kO1xyXG5cclxuICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzLCA2LCAxKTtcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UobWFnZW50YSwgMCwgMCk7XHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh5ZWxsb3csIDIsIDApO1xyXG5cclxuICAgIGlmICghY29udGV4dC5nZXRJbWFnZURhdGEoMiwgMCwgMSwgMSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMiwgMCwgMSwgMSkuZGF0YTtcclxuXHJcbiAgICBDYW52YXNQb29sLnJlbW92ZSh0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gKGRhdGFbMF0gPT09IDI1NSAmJiBkYXRhWzFdID09PSAwICYmIGRhdGFbMl0gPT09IDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0ludmVyc2VBbHBoYSAoKVxyXG57XHJcbiAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcywgMiwgMSk7XHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMTAsIDIwLCAzMCwgMC41KSc7XHJcblxyXG4gICAgLy8gIERyYXcgYSBzaW5nbGUgcGl4ZWxcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMSwgMSk7XHJcblxyXG4gICAgLy8gIEdldCB0aGUgY29sb3IgdmFsdWVzXHJcbiAgICB2YXIgczEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcclxuXHJcbiAgICBpZiAoczEgPT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBQbG90IHRoZW0gdG8geDJcclxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKHMxLCAxLCAwKTtcclxuXHJcbiAgICAvLyAgR2V0IHRob3NlIHZhbHVlc1xyXG4gICAgdmFyIHMyID0gY29udGV4dC5nZXRJbWFnZURhdGEoMSwgMCwgMSwgMSk7XHJcblxyXG4gICAgLy8gIENvbXBhcmUgYW5kIHJldHVyblxyXG4gICAgcmV0dXJuIChzMi5kYXRhWzBdID09PSBzMS5kYXRhWzBdICYmIHMyLmRhdGFbMV0gPT09IHMxLmRhdGFbMV0gJiYgczIuZGF0YVsyXSA9PT0gczEuZGF0YVsyXSAmJiBzMi5kYXRhWzNdID09PSBzMS5kYXRhWzNdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBpZiAoZG9jdW1lbnQgIT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcyA9IGNoZWNrQmxlbmRNb2RlKCk7XHJcbiAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydEludmVyc2VBbHBoYSA9IGNoZWNrSW52ZXJzZUFscGhhKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIENhbnZhc0ZlYXR1cmVzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbnZhciBGZWF0dXJlcyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjYW52YXMgLSBJcyBjYW52YXMgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNhbnZhczogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGNhbnZhc0JpdEJsdFNoaWZ0IC0gVHJ1ZSBpZiBjYW52YXMgc3VwcG9ydHMgYSAnY29weScgYml0Ymx0IG9udG8gaXRzZWxmIHdoZW4gdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcmVnaW9ucyBvdmVybGFwLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGNhbnZhc0JpdEJsdFNoaWZ0OiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYkdMIC0gSXMgd2ViR0wgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYkdMOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaWxlIC0gSXMgZmlsZSBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgZmlsZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZVN5c3RlbSAtIElzIGZpbGVTeXN0ZW0gYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGZpbGVTeXN0ZW06IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxvY2FsU3RvcmFnZSAtIElzIGxvY2FsU3RvcmFnZSBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbG9jYWxTdG9yYWdlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3b3JrZXIgLSBJcyB3b3JrZXIgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdvcmtlcjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcG9pbnRlckxvY2sgLSBJcyBQb2ludGVyIExvY2sgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHBvaW50ZXJMb2NrOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB2aWJyYXRpb24gLSBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0aGUgVmlicmF0aW9uIEFQST9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB2aWJyYXRpb246IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGdldFVzZXJNZWRpYSAtIERvZXMgdGhlIGRldmljZSBzdXBwb3J0IHRoZSBnZXRVc2VyTWVkaWEgQVBJP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGdldFVzZXJNZWRpYTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsaXR0bGVFbmRpYW4gLSBJcyB0aGUgZGV2aWNlIGJpZyBvciBsaXR0bGUgZW5kaWFuPyAob25seSBkZXRlY3RlZCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBUeXBlZEFycmF5cylcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBsaXR0bGVFbmRpYW46IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN1cHBvcnQzMmJpdCAtIERvZXMgdGhlIGRldmljZSBjb250ZXh0IHN1cHBvcnQgMzJiaXQgcGl4ZWwgbWFuaXB1bGF0aW9uIHVzaW5nIGFycmF5IGJ1ZmZlciB2aWV3cz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBzdXBwb3J0MzJiaXQ6IGZhbHNlXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiogQ2hlY2sgTGl0dGxlIG9yIEJpZyBFbmRpYW4gc3lzdGVtLlxyXG4qXHJcbiogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXHJcbiovXHJcbmZ1bmN0aW9uIGNoZWNrSXNMaXR0bGVFbmRpYW4gKClcclxue1xyXG4gICAgdmFyIGEgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XHJcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xyXG4gICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7XHJcblxyXG4gICAgYlswXSA9IDB4YTE7XHJcbiAgICBiWzFdID0gMHhiMjtcclxuICAgIGJbMl0gPSAweGMzO1xyXG4gICAgYlszXSA9IDB4ZDQ7XHJcblxyXG4gICAgaWYgKGNbMF0gPT09IDB4ZDRjM2IyYTEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNbMF0gPT09IDB4YTFiMmMzZDQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDb3VsZCBub3QgZGV0ZXJtaW5lIGVuZGlhbm5lc3NcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdCAoKVxyXG57XHJcbiAgICBGZWF0dXJlcy5jYW52YXMgPSAhIXdpbmRvd1snQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEJ10gfHwgT1MuY29jb29uSlM7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMubG9jYWxTdG9yYWdlID0gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcilcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBGZWF0dXJlcy5maWxlID0gISF3aW5kb3dbJ0ZpbGUnXSAmJiAhIXdpbmRvd1snRmlsZVJlYWRlciddICYmICEhd2luZG93WydGaWxlTGlzdCddICYmICEhd2luZG93WydCbG9iJ107XHJcbiAgICBGZWF0dXJlcy5maWxlU3lzdGVtID0gISF3aW5kb3dbJ3JlcXVlc3RGaWxlU3lzdGVtJ107XHJcblxyXG4gICAgdmFyIGlzVWludDggPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgdGVzdFdlYkdMID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAod2luZG93WydXZWJHTFJlbmRlcmluZ0NvbnRleHQnXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGVXZWJHTCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT1MuY29jb29uSlMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNjcmVlbmNhbnZhcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhczJEID0gQ2FudmFzUG9vbC5jcmVhdGUyRCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4MkQgPSBjYW52YXMyRC5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBDYW4ndCBiZSBkb25lIG9uIGEgd2ViZ2wgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gY3R4MkQuY3JlYXRlSW1hZ2VEYXRhKDEsIDEpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICogVGVzdCB0byBzZWUgaWYgSW1hZ2VEYXRhIHVzZXMgQ2FudmFzUGl4ZWxBcnJheSBvciBVaW50OENsYW1wZWRBcnJheS5cclxuICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaXNVaW50OCA9IGltYWdlLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzMkQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoY3R4ICE9PSBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgRmVhdHVyZXMud2ViR0wgPSB0cnVlOy8vdGVzdFdlYkdMKCk7XHJcblxyXG4gICAgRmVhdHVyZXMud29ya2VyID0gISF3aW5kb3dbJ1dvcmtlciddO1xyXG5cclxuICAgIEZlYXR1cmVzLnBvaW50ZXJMb2NrID0gJ3BvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ21velBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ3dlYmtpdFBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQ7XHJcblxyXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iub0dldFVzZXJNZWRpYTtcclxuXHJcbiAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xyXG5cclxuICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IEZlYXR1cmVzLmdldFVzZXJNZWRpYSAmJiAhIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgISF3aW5kb3cuVVJMO1xyXG5cclxuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGZpcmVmb3ggKDwgMjEpIGFwcGFyZW50bHkgY2xhaW0gc3VwcG9ydCBidXQgdXNlciBtZWRpYSBkb2VzIG5vdCBhY3R1YWxseSB3b3JrXHJcbiAgICBpZiAoQnJvd3Nlci5maXJlZm94ICYmIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPCAyMSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGNsdWRlcyBpT1MgdmVyc2lvbnMgYXMgdGhleSBnZW5lcmFsbHkgd3JhcCBVSVdlYlZpZXcgKGVnLiBTYWZhcmkgV2ViS2l0KSBhbmQgaXRcclxuICAgIC8vIGlzIHNhZmVyIHRvIG5vdCB0cnkgYW5kIHVzZSB0aGUgZmFzdCBjb3B5LW92ZXIgbWV0aG9kLlxyXG4gICAgaWYgKCFPUy5pT1MgJiYgKEJyb3dzZXIuaWUgfHwgQnJvd3Nlci5maXJlZm94IHx8IEJyb3dzZXIuY2hyb21lKSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS25vd24gbm90IHRvIHdvcmtcclxuICAgIGlmIChCcm93c2VyLnNhZmFyaSB8fCBCcm93c2VyLm1vYmlsZVNhZmFyaSlcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHwgbmF2aWdhdG9yLndlYmtpdFZpYnJhdGUgfHwgbmF2aWdhdG9yLm1velZpYnJhdGUgfHwgbmF2aWdhdG9yLm1zVmlicmF0ZTtcclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLnZpYnJhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgRmVhdHVyZXMudmlicmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJylcclxuICAgIHtcclxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gPSBjaGVja0lzTGl0dGxlRW5kaWFuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmVhdHVyZXMuc3VwcG9ydDMyYml0ID0gKFxyXG4gICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgRmVhdHVyZXMubGl0dGxlRW5kaWFuICE9PSBudWxsICYmXHJcbiAgICAgICAgaXNVaW50OFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZXM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9GZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBZGRUb0RPTSA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQsIG92ZXJmbG93SGlkZGVuKVxyXG57XHJcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gPT09IHVuZGVmaW5lZCkgeyBvdmVyZmxvd0hpZGRlbiA9IHRydWU7IH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0O1xyXG5cclxuICAgIGlmIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEhvcGVmdWxseSBhbiBlbGVtZW50IElEXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayB0ZXN0IGZvciBhIEhUTUxlbGVtZW50XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZhbGxiYWNrLCBjb3ZlcnMgYW4gaW52YWxpZCBJRCBhbmQgYSBub24gSFRNTGVsZW1lbnQgb2JqZWN0XHJcbiAgICBpZiAoIXRhcmdldClcclxuICAgIHtcclxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiAmJiB0YXJnZXQuc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRUb0RPTTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vQWRkVG9ET00uanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgT1MgPSByZXF1aXJlKCcuLi9kZXZpY2UvT1MnKTtcclxuXHJcbnZhciBpc0Jvb3RlZCA9IGZhbHNlO1xyXG5cclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIGlmIChpc0Jvb3RlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJylcclxuICAgIHtcclxuICAgICAgICBpc0Jvb3RlZCA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCB0cnVlKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG5cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkpXHJcbiAgICB7XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2ssIDIwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKE9TLmNvcmRvdmEgJiYgIU9TLmNvY29vbkpTKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZWYuIGh0dHA6Ly9kb2NzLnBob25lZ2FwLmNvbS9lbi8zLjUuMC9jb3Jkb3ZhX2V2ZW50c19ldmVudHMubWQuaHRtbCNkZXZpY2VyZWFkeVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgY2hlY2ssIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01Db250ZW50TG9hZGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvbS9ET01Db250ZW50TG9hZGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhcnNlWE1MID0gZnVuY3Rpb24gKGRhdGEpXHJcbntcclxuICAgIHZhciB4bWwgPSAnJztcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBpZiAod2luZG93WydET01QYXJzZXInXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIHhtbCA9IGRvbXBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgJ3RleHQveG1sJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XHJcbiAgICAgICAgICAgIHhtbC5sb2FkWE1MKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIHhtbCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geG1sO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVhNTDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vUGFyc2VYTUwuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgTk9PUCA9IHJlcXVpcmUoJy4uL3V0aWxzL05PT1AnKTtcclxuXHJcbi8qKlxyXG4qIEFic3RyYWN0cyBhd2F5IHRoZSB1c2Ugb2YgUkFGIG9yIHNldFRpbWVPdXQgZm9yIHRoZSBjb3JlIGdhbWUgdXBkYXRlIGxvb3AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlU2V0VGltZU91dD1mYWxzZV0gLSBUZWxsIFBoYXNlciB0byB1c2Ugc2V0VGltZU91dCBldmVuIGlmIHJhZiBpcyBhdmFpbGFibGUuXHJcbiovXHJcbnZhciBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1J1bm5pbmcgLSB0cnVlIGlmIFJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBydW5uaW5nLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrID0gTk9PUDtcclxuXHJcbiAgICB0aGlzLnRpY2sgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU2V0VGltZU91dCAgLSBUcnVlIGlmIHRoZSBicm93c2VyIGlzIHVzaW5nIHNldFRpbWVvdXQgaW5zdGVhZCBvZiByQWYuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5pc1NldFRpbWVPdXQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVPdXRJRCAtIFRoZSBjYWxsYmFjayBzZXRUaW1lb3V0IG9yIHJBZiBjYWxsYmFjayBJRCB1c2VkIHdoZW4gY2FsbGluZyBjYW5jZWwuXHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lT3V0SUQgPSBudWxsO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcclxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcclxuICAgIHtcclxuICAgICAgICBfdGhpcy50aWNrID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICBfdGhpcy5jYWxsYmFjayh0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RlcFRpbWVvdXQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgX3RoaXMudGljayA9IGQ7XHJcblxyXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKGQpO1xyXG5cclxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgX3RoaXMudGltZVRvQ2FsbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3RlcCA9IHN0ZXA7XHJcbiAgICB0aGlzLnN0ZXBUaW1lb3V0ID0gc3RlcFRpbWVvdXQ7XHJcbn07XHJcblxyXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuUmVxdWVzdEFuaW1hdGlvbkZyYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogU3RhcnRzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcnVubmluZyBvciBzZXRUaW1lb3V0IGlmIHVuYXZhaWxhYmxlIGluIGJyb3dzZXJcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmVxdWVzdEFuaW1hdGlvbkZyYW1lI3N0YXJ0XHJcbiAgICAqL1xyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgZm9yY2VTZXRUaW1lT3V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5pc1NldFRpbWVPdXQgPSBmb3JjZVNldFRpbWVPdXQ7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy50aW1lT3V0SUQgPSAoZm9yY2VTZXRUaW1lT3V0KSA/IHdpbmRvdy5zZXRUaW1lb3V0KF90aGlzLnN0ZXBUaW1lb3V0LCAwKSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuc3RlcCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTdG9wcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gcnVubmluZy5cclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmVxdWVzdEFuaW1hdGlvbkZyYW1lI3N0b3BcclxuICAgICovXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzU2V0VGltZU91dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXRJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnRpbWVPdXRJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gTk9PUDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVWRU5UX0NPTlNUID0ge1xyXG5cclxuICAgIERJU1BBVENIRVJfSURMRTogMCxcclxuICAgIERJU1BBVENIRVJfRElTUEFUQ0hJTkc6IDEsXHJcbiAgICBESVNQQVRDSEVSX1JFTU9WSU5HOiAyLFxyXG4gICAgRElTUEFUQ0hFUl9ERVNUUk9ZRUQ6IDMsXHJcblxyXG4gICAgTElTVEVORVJfUEVORElORzogNCxcclxuICAgIExJU1RFTkVSX0FDVElWRTogNSxcclxuICAgIExJU1RFTkVSX1JFTU9WSU5HOiA2XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFVkVOVF9DT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ldmVudHMvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEdldEJpdG1hcFRleHRTaXplID0gZnVuY3Rpb24gKHNyYylcclxue1xyXG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgdmFyIGJ4ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHZhciBieSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB2YXIgYncgPSAwO1xyXG4gICAgdmFyIGJoID0gMDtcclxuICAgIFxyXG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcclxuXHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuXHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG5cclxuICAgIHZhciBnbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgZ2x5cGhXID0gMDtcclxuICAgIHZhciBnbHlwaEggPSAwO1xyXG5cclxuICAgIHZhciB4ID0gMDtcclxuICAgIHZhciB5ID0gMDtcclxuXHJcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcclxuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHlBZHZhbmNlICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGlmICghZ2x5cGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuXHJcbiAgICAgICAgeCA9IGluZGV4Q291bnQgKyBnbHlwaC54T2Zmc2V0ICsgeEFkdmFuY2U7XHJcbiAgICAgICAgeSA9IGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZTtcclxuXHJcbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXJuaW5nT2Zmc2V0ID0gZ2x5cGgua2VybmluZ1tsYXN0Q2hhckNvZGVdO1xyXG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYnggPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYnggPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJ5ID4geSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJ5ID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBndyA9IHggKyBnbHlwaFcgLSBieDtcclxuICAgICAgICB2YXIgZ2ggPSB5ICsgZ2x5cGhIIC0gYnk7XHJcblxyXG4gICAgICAgIGlmIChidyA8IGd3KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYncgPSBndztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJoIDwgZ2gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiaCA9IGdoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XHJcbiAgICB2YXIgc3ggPSBzY2FsZSAqIHNyYy5zY2FsZVg7XHJcbiAgICB2YXIgc3kgPSBzY2FsZSAqIHNyYy5zY2FsZVk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsb2NhbDoge1xyXG4gICAgICAgICAgICB4OiBieCAqIHNjYWxlLFxyXG4gICAgICAgICAgICB5OiBieSAqIHNjYWxlLFxyXG4gICAgICAgICAgICB3aWR0aDogYncgKiBzY2FsZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBiaCAqIHNjYWxlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnbG9iYWw6IHtcclxuICAgICAgICAgICAgeDogc3JjLnggKyAoYnggKiBzeCksXHJcbiAgICAgICAgICAgIHk6IHNyYy55ICsgKGJ5ICogc3kpLFxyXG4gICAgICAgICAgICB3aWR0aDogYncgKiBzeCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBiaCAqIHN5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qml0bWFwVGV4dFNpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9HZXRCaXRtYXBUZXh0U2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRSZW5kZXInKTtcclxudmFyIEdldEJpdG1hcFRleHRTaXplID0gcmVxdWlyZSgnLi4vR2V0Qml0bWFwVGV4dFNpemUnKTtcclxuXHJcbnZhciBEeW5hbWljQml0bWFwVGV4dCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gRHluYW1pY0JpdG1hcFRleHQgKHN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcclxuICAgIHtcclxuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7IHRleHQgPSAnJzsgfVxyXG4gICAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7IGFsaWduID0gJ2xlZnQnOyB9XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ0R5bmFtaWNCaXRtYXBUZXh0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udERhdGEgPSB0aGlzLnN0YXRlLnN5cy5jYWNoZS5iaXRtYXBGb250LmdldChmb250KTtcclxuXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gKEFycmF5LmlzQXJyYXkodGV4dCkpID8gdGV4dC5qb2luKCdcXG4nKSA6IHRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBzaXplIHx8IHRoaXMuZm9udERhdGEuc2l6ZTtcclxuXHJcbiAgICAgICAgdGhpcy5zY3JvbGxYID0gMDtcclxuICAgICAgICB0aGlzLnNjcm9sbFkgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGxheUNhbGxiYWNrO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZm9udCk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RGlzcGxheUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZvbnRTaXplOiBmdW5jdGlvbiAoc2l6ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHQ6IGZ1bmN0aW9uICh0ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY3JvbGxYOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxYID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY3JvbGxZOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxZID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB7XHJcbiAgICAvLyAgICAgbG9jYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH0sXHJcbiAgICAvLyAgICAgZ2xvYmFsOiB7XHJcbiAgICAvLyAgICAgICAgIHgsXHJcbiAgICAvLyAgICAgICAgIHksXHJcbiAgICAvLyAgICAgICAgIHdpZHRoLFxyXG4gICAgLy8gICAgICAgICBoZWlnaHRcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgbG9jYWwgPSB0aGUgQml0bWFwVGV4dCBiYXNlZCBvbiBmb250U2l6ZSBhbmQgMHgwIGNvb3Jkc1xyXG4gICAgICAgIC8vICBnbG9iYWwgPSB0aGUgQml0bWFwVGV4dCwgdGFraW5nIGludG8gYWNjb3VudCBzY2FsZSBhbmQgd29ybGQgcG9zaXRpb25cclxuXHJcbiAgICAgICAgcmV0dXJuIEdldEJpdG1hcFRleHRTaXplKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNCaXRtYXBUZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vQml0bWFwVGV4dFJlbmRlcicpO1xyXG52YXIgR2V0Qml0bWFwVGV4dFNpemUgPSByZXF1aXJlKCcuLi9HZXRCaXRtYXBUZXh0U2l6ZScpO1xyXG52YXIgUGFyc2VSZXRyb0ZvbnQgPSByZXF1aXJlKCcuLi9QYXJzZVJldHJvRm9udCcpO1xyXG5cclxudmFyIEJpdG1hcFRleHQgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBCaXRtYXBUZXh0IChzdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgeyB0ZXh0ID0gJyc7IH1cclxuICAgICAgICBpZiAoYWxpZ24gPT09IHVuZGVmaW5lZCkgeyBhbGlnbiA9ICdsZWZ0JzsgfVxyXG5cclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsICdCaXRtYXBUZXh0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgdGhpcy5mb250RGF0YSA9IHRoaXMuc3RhdGUuc3lzLmNhY2hlLmJpdG1hcEZvbnQuZ2V0KGZvbnQpO1xyXG5cclxuICAgICAgICB0aGlzLnRleHQgPSAoQXJyYXkuaXNBcnJheSh0ZXh0KSkgPyB0ZXh0LmpvaW4oJ1xcbicpIDogdGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IHNpemUgfHwgdGhpcy5mb250RGF0YS5zaXplO1xyXG5cclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZm9udCk7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rm9udFNpemU6IGZ1bmN0aW9uIChzaXplKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBzaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dDogZnVuY3Rpb24gKHRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHtcclxuICAgIC8vICAgICBsb2NhbDoge1xyXG4gICAgLy8gICAgICAgICB4LFxyXG4gICAgLy8gICAgICAgICB5LFxyXG4gICAgLy8gICAgICAgICB3aWR0aCxcclxuICAgIC8vICAgICAgICAgaGVpZ2h0XHJcbiAgICAvLyAgICAgfSxcclxuICAgIC8vICAgICBnbG9iYWw6IHtcclxuICAgIC8vICAgICAgICAgeCxcclxuICAgIC8vICAgICAgICAgeSxcclxuICAgIC8vICAgICAgICAgd2lkdGgsXHJcbiAgICAvLyAgICAgICAgIGhlaWdodFxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBnZXRUZXh0Qm91bmRzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBsb2NhbCA9IHRoZSBCaXRtYXBUZXh0IGJhc2VkIG9uIGZvbnRTaXplIGFuZCAweDAgY29vcmRzXHJcbiAgICAgICAgLy8gIGdsb2JhbCA9IHRoZSBCaXRtYXBUZXh0LCB0YWtpbmcgaW50byBhY2NvdW50IHNjYWxlIGFuZCB3b3JsZCBwb3NpdGlvblxyXG5cclxuICAgICAgICByZXR1cm4gR2V0Qml0bWFwVGV4dFNpemUodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0ID0gQ29tcG9uZW50cy5Ub0pTT04odGhpcyk7XHJcblxyXG4gICAgICAgIC8vICBFeHRyYSBkYXRhIGlzIGFkZGVkIGhlcmVcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcclxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxyXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG91dC5kYXRhID0gZGF0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuQml0bWFwVGV4dC5QYXJzZVJldHJvRm9udCA9IFBhcnNlUmV0cm9Gb250O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgQmxpdHRlclJlbmRlciA9IHJlcXVpcmUoJy4vQmxpdHRlclJlbmRlcicpO1xyXG52YXIgQm9iID0gcmVxdWlyZSgnLi9Cb2InKTtcclxuXHJcbi8qKlxyXG4qIEEgQmxpdHRlciBHYW1lIE9iamVjdC5cclxuKlxyXG4qIFRoZSBCbGl0dGVyIEdhbWUgT2JqZWN0IGlzIGEgc3BlY2lhbCB0eXBlIG9mIENvbnRhaW5lciwgdGhhdCBjb250YWlucyBCbGl0dGVyLkJvYiBvYmplY3RzLlxyXG4qIFRoZXNlIG9iamVjdHMgY2FuIGJlIHRob3VnaHQgb2YgYXMganVzdCB0ZXh0dXJlIGZyYW1lcyB3aXRoIGEgcG9zaXRpb24gYW5kIG5vdGhpbmcgbW9yZS5cclxuKiBCb2JzIGRvbid0IGhhdmUgYW55IHVwZGF0ZSBtZXRob2RzLCBvciB0aGUgYWJpbGl0eSB0byBoYXZlIGNoaWxkcmVuLCBvciBhbnkga2luZCBvZiBzcGVjaWFsIGVmZmVjdHMuXHJcbiogVGhleSBhcmUgZXNzZW50aWFsbHkganVzdCBzdXBlci1mYXN0IHRleHR1cmUgZnJhbWUgcmVuZGVyZXJzLCBhbmQgdGhlIEJsaXR0ZXIgb2JqZWN0IGNyZWF0ZXMgYW5kIG1hbmFnZXMgdGhlbS5cclxuKlxyXG4qIEBjbGFzcyBCbGl0dGVyXHJcbiogQGV4dGVuZHMgUGhhc2VyLkdhbWVPYmplY3RcclxuKiBAY29uc3RydWN0b3JcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gLSBUaGUgdGV4dHVyZSB1c2VkIGJ5IHRoZSBJbWFnZSBkdXJpbmcgcmVuZGVyaW5nLiBJdCBjYW4gYmUgYSBzdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gdGhlIENhY2hlIGVudHJ5LCBvciBhbiBpbnN0YW5jZSBvZiBhIFJlbmRlclRleHR1cmUsIEJpdG1hcERhdGEgb3IgUElYSS5UZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIHRoaXMgSW1hZ2UgaXMgdXNpbmcgcGFydCBvZiBhIHNwcml0ZSBzaGVldCBvciB0ZXh0dXJlIGF0bGFzIHlvdSBjYW4gc3BlY2lmeSB0aGUgZXhhY3QgZnJhbWUgdG8gdXNlIGJ5IGdpdmluZyBhIHN0cmluZyBvciBudW1lcmljIGluZGV4LlxyXG4qL1xyXG5cclxudmFyIEJsaXR0ZXIgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxyXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxyXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcclxuICAgICAgICBDb21wb25lbnRzLlNjcm9sbEZhY3RvcixcclxuICAgICAgICBCbGl0dGVyUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQmxpdHRlciAoc3RhdGUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ0JsaXR0ZXInKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENvbXBvbmVudHMuQ2hpbGRyZW4odGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSwgZnJhbWUsIHZpc2libGUsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxyXG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cclxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZnJhbWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnJhbWUgPSB0aGlzLnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib2IgPSBuZXcgQm9iKHRoaXMsIHgsIHksIGZyYW1lLCB2aXNpYmxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5hZGRBdChib2IsIGluZGV4LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gYm9iO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcclxuICAgIGNyZWF0ZUZyb21DYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBxdWFudGl0eSwgZnJhbWUsIHZpc2libGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGJvYnMgPSB0aGlzLmNyZWF0ZU11bHRpcGxlKHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9icy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBib2IgPSBib2JzW2ldO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBib2IsIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJvYnM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxyXG4gICAgY3JlYXRlTXVsdGlwbGU6IGZ1bmN0aW9uIChxdWFudGl0eSwgZnJhbWUsIHZpc2libGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZyYW1lID09PSB1bmRlZmluZWQpIHsgZnJhbWUgPSB0aGlzLmZyYW1lOyB9XHJcbiAgICAgICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkgeyB2aXNpYmxlID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhbWUpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZnJhbWUgPSBbIGZyYW1lIF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm9icyA9IFtdO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIGZyYW1lLmZvckVhY2goZnVuY3Rpb24gKHNpbmdsZUZyYW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFudGl0eTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2JzLnB1c2goX3RoaXMuY3JlYXRlKDAsIDAsIHNpbmdsZUZyYW1lLCB2aXNpYmxlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvYnM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoaWxkQ2FuUmVuZGVyOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIChjaGlsZC52aXNpYmxlICYmIGNoaWxkLmFscGhhID4gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlbmRlckxpc3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QgPSB0aGlzLmNoaWxkcmVuLmxpc3QuZmlsdGVyKHRoaXMuY2hpbGRDYW5SZW5kZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJMaXN0O1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsaXR0ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcclxudmFyIENvbnRhaW5lclJlbmRlciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyUmVuZGVyJyk7XHJcblxyXG52YXIgQ29udGFpbmVyID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29udGFpbmVyUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENvbXBvbmVudHMuQ2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0dyYXBoaWNzUmVuZGVyJyk7XHJcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBDYW1lcmEgPSByZXF1aXJlKCcuLi8uLi9jYW1lcmEvQ2FtZXJhLmpzJyk7XHJcblxyXG52YXIgR3JhcGhpY3MgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIEV4dGVuZHM6IEdhbWVPYmplY3QsXHJcblxyXG4gICAgTWl4aW5zOiBbXHJcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcclxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5TY3JvbGxGYWN0b3IsXHJcbiAgICAgICAgUmVuZGVyXHJcbiAgICBdLFxyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gR3JhcGhpY3MgKHN0YXRlLCBvcHRpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gR2V0VmFsdWUob3B0aW9ucywgJ3gnLCAwKTtcclxuICAgICAgICB2YXIgeSA9IEdldFZhbHVlKG9wdGlvbnMsICd5JywgMCk7XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgJ0dyYXBoaWNzJyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlciA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmRlZmF1bHRGaWxsQ29sb3IgPSAtMTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRGaWxsQWxwaGEgPSAxO1xyXG5cclxuICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlQ29sb3IgPSAtMTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VBbHBoYSA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0RGVmYXVsdFN0eWxlcyhvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc291cmNlTWFuYWdlciA9IHN0YXRlLmdhbWUucmVuZGVyZXIucmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgICAgICBpZiAocmVzb3VyY2VNYW5hZ2VyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHJlc291cmNlTWFuYWdlcjtcclxuICAgICAgICAgICAgdGhpcy5nbCA9IHN0YXRlLmdhbWUucmVuZGVyZXIuZ2w7ICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU1RZTEVTXHJcblxyXG4gICAgc2V0RGVmYXVsdFN0eWxlczogZnVuY3Rpb24gKG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEdldFZhbHVlKG9wdGlvbnMsICdsaW5lU3R5bGUnLCBudWxsKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZVdpZHRoID0gR2V0VmFsdWUob3B0aW9ucywgJ2xpbmVTdHlsZS53aWR0aCcsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VDb2xvciA9IEdldFZhbHVlKG9wdGlvbnMsICdsaW5lU3R5bGUuY29sb3InLCAweGZmZmZmZik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZUFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ2xpbmVTdHlsZS5hbHBoYScsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saW5lU3R5bGUodGhpcy5kZWZhdWx0U3Ryb2tlV2lkdGgsIHRoaXMuZGVmYXVsdFN0cm9rZUNvbG9yLCB0aGlzLmRlZmF1bHRTdHJva2VBbHBoYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZScsIG51bGwpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0RmlsbENvbG9yID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZS5jb2xvcicsIDB4ZmZmZmZmKTtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0RmlsbEFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZS5hbHBoYScsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5kZWZhdWx0RmlsbENvbG9yLCB0aGlzLmRlZmF1bHRGaWxsQWxwaGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVTdHlsZTogZnVuY3Rpb24gKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTElORV9TVFlMRSxcclxuICAgICAgICAgICAgbGluZVdpZHRoLCBjb2xvciwgYWxwaGFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFN0eWxlOiBmdW5jdGlvbiAoY29sb3IsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9TVFlMRSxcclxuICAgICAgICAgICAgY29sb3IsIGFscGhhXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBQQVRIXHJcblxyXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5CRUdJTl9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuQ0xPU0VfUEFUSFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsUGF0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVBhdGg6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlNUUk9LRV9QQVRIXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDSVJDTEVcclxuXHJcbiAgICBmaWxsQ2lyY2xlU2hhcGU6IGZ1bmN0aW9uIChjaXJjbGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbENpcmNsZShjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VDaXJjbGVTaGFwZTogZnVuY3Rpb24gKGNpcmNsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VDaXJjbGUoY2lyY2xlLngsIGNpcmNsZS55LCBjaXJjbGUucmFkaXVzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbENpcmNsZTogZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuYXJjKHgsIHksIHJhZGl1cywgMCwgTUFUSF9DT05TVC5QSTIpO1xyXG4gICAgICAgIHRoaXMuZmlsbFBhdGgoKTtcclxuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3Ryb2tlQ2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNQVRIX0NPTlNULlBJMik7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLnN0cm9rZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSRUNUQU5HTEVcclxuXHJcbiAgICBmaWxsUmVjdFNoYXBlOiBmdW5jdGlvbiAocmVjdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxsUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VSZWN0U2hhcGU6IGZ1bmN0aW9uIChyZWN0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cm9rZVJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1JFQ1QsXHJcbiAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3Ryb2tlUmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5zdHJva2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBQT0lOVFxyXG5cclxuICAgIGZpbGxQb2ludFNoYXBlOiBmdW5jdGlvbiAocG9pbnQsIHNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbFBvaW50KHBvaW50LngsIHBvaW50LnksIHNpemUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsUG9pbnQ6IGZ1bmN0aW9uICh4LCB5LCBzaXplKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1JFQ1QsXHJcbiAgICAgICAgICAgIHgsIHksIHNpemUsIHNpemVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRSSUFOR0xFXHJcblxyXG4gICAgZmlsbFRyaWFuZ2xlU2hhcGU6IGZ1bmN0aW9uICh0cmlhbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxsVHJpYW5nbGUodHJpYW5nbGUueDEsIHRyaWFuZ2xlLnkxLCB0cmlhbmdsZS54MiwgdHJpYW5nbGUueTIsIHRyaWFuZ2xlLngzLCB0cmlhbmdsZS55Myk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0cm9rZVRyaWFuZ2xlU2hhcGU6IGZ1bmN0aW9uICh0cmlhbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VUcmlhbmdsZSh0cmlhbmdsZS54MSwgdHJpYW5nbGUueTEsIHRyaWFuZ2xlLngyLCB0cmlhbmdsZS55MiwgdHJpYW5nbGUueDMsIHRyaWFuZ2xlLnkzKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmlsbFRyaWFuZ2xlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9UUklBTkdMRSxcclxuICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHJva2VUcmlhbmdsZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLlNUUk9LRV9UUklBTkdMRSxcclxuICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgTElORVxyXG5cclxuICAgIHN0cm9rZUxpbmVTaGFwZTogZnVuY3Rpb24gKGxpbmUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUJldHdlZW4obGluZS54MSwgbGluZS55MSwgbGluZS54MiwgbGluZS55Mik7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVCZXR3ZWVuOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgdGhpcy5zdHJva2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkxJTkVfVE8sXHJcbiAgICAgICAgICAgIHgsIHlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuTU9WRV9UTyxcclxuICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lRnhUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCByZ2IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXHJcbiAgICAgICAgICAgIENvbW1hbmRzLkxJTkVfRlhfVE8sXHJcbiAgICAgICAgICAgIHgsIHksIHdpZHRoLCByZ2IsIDFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUZ4VG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgcmdiKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5NT1ZFX0ZYX1RPLFxyXG4gICAgICAgICAgICB4LCB5LCB3aWR0aCwgcmdiLCAxXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBUkNcclxuXHJcbiAgICBhcmM6IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5BUkMsXHJcbiAgICAgICAgICAgIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2VcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2F2ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5TQVZFXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5SRVNUT1JFXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxyXG4gICAgICAgICAgICBDb21tYW5kcy5UUkFOU0xBVEUsXHJcbiAgICAgICAgICAgIHgsIHlcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZTogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuU0NBTEUsXHJcbiAgICAgICAgICAgIHgsIHlcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChyYWRpYW4pIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcclxuICAgICAgICAgICAgQ29tbWFuZHMuUk9UQVRFLFxyXG4gICAgICAgICAgICByYWRpYW5cclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEZpbGxDb2xvciA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5kZWZhdWx0RmlsbENvbG9yLCB0aGlzLmRlZmF1bHRGaWxsQWxwaGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFN0cm9rZUNvbG9yID4gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVTdHlsZSh0aGlzLmRlZmF1bHRTdHJva2VXaWR0aCwgdGhpcy5kZWZhdWx0U3Ryb2tlQ29sb3IsIHRoaXMuZGVmYXVsdFN0cm9rZUFscGhhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZW5lcmF0ZVRleHR1cmU6IGZ1bmN0aW9uIChrZXksIHdpZHRoLCBoZWlnaHQpIFxyXG4gICAge1xyXG4gICAgICAgIHZhciBzY3JlZW5XaWR0aCA9IHRoaXMuc3RhdGUuZ2FtZS5jb25maWcud2lkdGg7XHJcbiAgICAgICAgdmFyIHNjcmVlbkhlaWdodCA9IHRoaXMuc3RhdGUuZ2FtZS5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgIHdpZHRoID0gKHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicpID8gd2lkdGggOiBzY3JlZW5XaWR0aDtcclxuICAgICAgICBoZWlnaHQgPSAodHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicpID8gaGVpZ2h0IDogc2NyZWVuSGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIEdyYXBoaWNzLlRhcmdldENhbWVyYS5zZXRWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBHcmFwaGljcy5UYXJnZXRDYW1lcmEuc2Nyb2xsWCA9IHRoaXMueDtcclxuICAgICAgICBHcmFwaGljcy5UYXJnZXRDYW1lcmEuc2Nyb2xsWSA9IHRoaXMueTtcclxuXHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLnN0YXRlLmdhbWUudGV4dHVyZXMuY3JlYXRlQ2FudmFzKGtleSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRleHR1cmUuc291cmNlWzBdLmltYWdlLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRoaXMuc3RhdGUuZ2FtZS5yZW5kZXJlciwgdGhpcywgMCwgR3JhcGhpY3MuVGFyZ2V0Q2FtZXJhLCBjdHgpO1xyXG4gICAgICAgIGlmICh0aGlzLmdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5nYW1lLnJlbmRlcmVyLnVwbG9hZENhbnZhc1RvR1BVKGN0eC5jYW52YXMsIHRleHR1cmUuc291cmNlWzBdLmdsVGV4dHVyZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5HcmFwaGljcy5UYXJnZXRDYW1lcmEgPSBuZXcgQ2FtZXJhKDAsIDAsIDAsIDApO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vLi4vc3RydWN0cy9TZXQnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5L1JhbmdlJyk7XHJcbnZhciBBY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vYWN0aW9ucy8nKTtcclxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4uL3Nwcml0ZS9TcHJpdGUnKTtcclxuXHJcbnZhciBMYXllciA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBMYXllciAoc3RhdGUsIGNoaWxkcmVuKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoY2hpbGRyZW4pO1xyXG5cclxuICAgICAgICB0aGlzLmNsYXNzVHlwZSA9IFNwcml0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIExheWVyIG1hbmFnZW1lbnQgbWV0aG9kczpcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRNdWx0aXBsZTogZnVuY3Rpb24gKGNoaWxkcmVuKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUsIHZpc2libGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkgeyB2aXNpYmxlID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5hZGQobmV3IHRoaXMuY2xhc3NUeXBlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcclxuXHJcbiAgICAgICAgY2hpbGQudmlzaWJsZSA9IHZpc2libGU7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkKGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVGcm9tQ29uZmlnOiBmdW5jdGlvbiAob3B0aW9ucylcclxuICAgIHtcclxuICAgICAgICB2YXIga2V5ID0gR2V0VmFsdWUob3B0aW9ucywgJ2tleScsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZyYW1lJywgbnVsbCk7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSBHZXRWYWx1ZShvcHRpb25zLCAndmlzaWJsZScsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyAgQ2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCBhdCBsZWFzdCBhIGtleVxyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gWyBrZXkgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYW1lKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSBbIGZyYW1lIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBCdWlsZCBhbiBhcnJheSBvZiBrZXkgZnJhbWUgcGFpcnMgdG8gbG9vcCB0aHJvdWdoXHJcblxyXG4gICAgICAgIHZhciByZXBlYXQgPSBHZXRWYWx1ZShvcHRpb25zLCAncmVwZWF0JywgMCk7XHJcbiAgICAgICAgdmFyIHJhbmRvbUtleSA9IEdldFZhbHVlKG9wdGlvbnMsICdyYW5kb21LZXknLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHJhbmRvbUZyYW1lID0gR2V0VmFsdWUob3B0aW9ucywgJ3JhbmRvbUZyYW1lJywgZmFsc2UpO1xyXG4gICAgICAgIHZhciB5b3lvID0gR2V0VmFsdWUob3B0aW9ucywgJ3lveW8nLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHF1YW50aXR5ID0gR2V0VmFsdWUob3B0aW9ucywgJ2ZyYW1lUXVhbnRpdHknLCAxKTtcclxuICAgICAgICB2YXIgbWF4ID0gR2V0VmFsdWUob3B0aW9ucywgJ21heCcsIDApO1xyXG5cclxuICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZShrZXksIGZyYW1lLCB7XHJcbiAgICAgICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgICAgICBxdHk6IHF1YW50aXR5LFxyXG4gICAgICAgICAgICByYW5kb206IHJhbmRvbUtleSxcclxuICAgICAgICAgICAgcmFuZG9tQjogcmFuZG9tRnJhbWUsXHJcbiAgICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxyXG4gICAgICAgICAgICB5b3lvOiB5b3lvXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcmFuZ2UubGVuZ3RoOyBjKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy5jcmVhdGUoMCwgMCwgcmFuZ2VbY10uYSwgcmFuZ2VbY10uYiwgdmlzaWJsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFBvc3QtY3JlYXRpb24gb3B0aW9ucyAoYXBwbGllZCBvbmx5IHRvIHRob3NlIGl0ZW1zIGNyZWF0ZWQgaW4gdGhpcyBjYWxsKTpcclxuXHJcbiAgICAgICAgdmFyIHggPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkueCcsIDApO1xyXG4gICAgICAgIHZhciB5ID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFhZLnknLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFggPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkuc3RlcFgnLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFkgPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0WFkuc3RlcFknLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRYWShlbnRyaWVzLCB4LCB5LCBzdGVwWCwgc3RlcFkpO1xyXG5cclxuICAgICAgICB2YXIgcm90YXRpb24gPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0Um90YXRpb24udmFsdWUnLCAwKTtcclxuICAgICAgICB2YXIgc3RlcFJvdGF0aW9uID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFJvdGF0aW9uLnN0ZXAnLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRSb3RhdGlvbihlbnRyaWVzLCByb3RhdGlvbiwgc3RlcFJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS54JywgMSk7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS55Jywgc2NhbGVYKTtcclxuICAgICAgICB2YXIgc3RlcFNjYWxlWCA9IEdldFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS5zdGVwWCcsIDApO1xyXG4gICAgICAgIHZhciBzdGVwU2NhbGVZID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldFNjYWxlLnN0ZXBZJywgMCk7XHJcblxyXG4gICAgICAgIEFjdGlvbnMuU2V0U2NhbGUoZW50cmllcywgc2NhbGVYLCBzY2FsZVksIHN0ZXBTY2FsZVgsIHN0ZXBTY2FsZVkpO1xyXG5cclxuICAgICAgICB2YXIgYWxwaGEgPSBHZXRWYWx1ZShvcHRpb25zLCAnc2V0QWxwaGEudmFsdWUnLCAxKTtcclxuICAgICAgICB2YXIgc3RlcEFscGhhID0gR2V0VmFsdWUob3B0aW9ucywgJ3NldEFscGhhLnN0ZXAnLCAwKTtcclxuXHJcbiAgICAgICAgQWN0aW9ucy5TZXRBbHBoYShlbnRyaWVzLCBhbHBoYSwgc3RlcEFscGhhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU11bHRpcGxlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uZmlnID0gWyBjb25maWcgXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuY3JlYXRlRnJvbUNvbmZpZyhjb25maWdbaV0pO1xyXG5cclxuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChlbnRyaWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2xlYXIoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmVudHJpZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zaXplO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGaXJzdDogZnVuY3Rpb24gKGNvbXBhcmUsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxyXG5cclxuICAgICAgICByZXR1cm4gQWN0aW9ucy5HZXRGaXJzdCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGNvbXBhcmUsIGluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENoaWxkIHJlbGF0ZWQgbWV0aG9kc1xyXG5cclxuICAgIGFuZ2xlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5BbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdyaWRBbGlnbjogZnVuY3Rpb24gKG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5HcmlkQWxpZ24odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGluY0FscGhhOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5JbmNBbHBoYSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGluY1g6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLkluY1godGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbmNYWTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5JbmNYWSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHgsIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW5jWTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuSW5jWSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYWNlT25DaXJjbGU6IGZ1bmN0aW9uIChjaXJjbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUGxhY2VPbkNpcmNsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGNpcmNsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcGxhY2VPbkxpbmU6IGZ1bmN0aW9uIChsaW5lKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUGxhY2VPbkxpbmUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBsaW5lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBsYWNlT25SZWN0YW5nbGU6IGZ1bmN0aW9uIChyZWN0LCBzaGlmdClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlBsYWNlT25SZWN0YW5nbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCByZWN0LCBzaGlmdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBwbGFjZU9uVHJpYW5nbGU6IGZ1bmN0aW9uICh0cmlhbmdsZSwgc3RlcFJhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5QbGFjZU9uVHJpYW5nbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB0cmlhbmdsZSwgc3RlcFJhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcGxheUFuaW1hdGlvbjogZnVuY3Rpb24gKGtleSwgc3RhcnRGcmFtZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlBsYXlBbmltYXRpb24odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBrZXksIHN0YXJ0RnJhbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmFuZG9tQ2lyY2xlOiBmdW5jdGlvbiAoY2lyY2xlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUmFuZG9tQ2lyY2xlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgY2lyY2xlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJhbmRvbUVsbGlwc2U6IGZ1bmN0aW9uIChlbGxpcHNlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUmFuZG9tRWxsaXBzZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGVsbGlwc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmFuZG9tTGluZTogZnVuY3Rpb24gKGxpbmUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5SYW5kb21MaW5lKHRoaXMuY2hpbGRyZW4uZW50cmllcywgbGluZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByYW5kb21SZWN0YW5nbGU6IGZ1bmN0aW9uIChyZWN0KVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUmFuZG9tUmVjdGFuZ2xlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgcmVjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByYW5kb21UcmlhbmdsZTogZnVuY3Rpb24gKHRyaWFuZ2xlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuUmFuZG9tVHJpYW5nbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB0cmlhbmdsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlJvdGF0ZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKHBvaW50LCBhbmdsZSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlJvdGF0ZUFyb3VuZCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHBvaW50LCBhbmdsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGVBcm91bmREaXN0YW5jZTogZnVuY3Rpb24gKHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5Sb3RhdGVBcm91bmREaXN0YW5jZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldEFscGhhKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0T3JpZ2luOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldE9yaWdpbih0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHgsIHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVYOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TY2FsZVgodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzY2FsZVhZOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNjYWxlWFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2NhbGVZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFJvdGF0aW9uKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2NhbGU6IGZ1bmN0aW9uICh4LCB5LCBzdGVwWCwgc3RlcFkpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TZXRTY2FsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHgsIHksIHN0ZXBYLCBzdGVwWSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY2FsZVg6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFNjYWxlWCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlWTogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0U2NhbGVZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuU2V0VmlzaWJsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFg6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFgodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRYWTogZnVuY3Rpb24gKHgsIHksIHN0ZXBYLCBzdGVwWSlcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFhZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgeCwgeSwgc3RlcFgsIHN0ZXBZKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFk6IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcclxuICAgIHtcclxuICAgICAgICBBY3Rpb25zLlNldFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaGlmdFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSwgZGlyZWN0aW9uLCBvdXRwdXQpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TaGlmdFBvc2l0aW9uKHRoaXMuY2hpbGRyZW4uZW50cmllcywgeCwgeSwgZGlyZWN0aW9uLCBvdXRwdXQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc21vb3RoZXJTdGVwOiBmdW5jdGlvbiAocHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TbW9vdGhlclN0ZXAodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzbW9vdGhTdGVwOiBmdW5jdGlvbiAocHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TbW9vdGhTdGVwKHRoaXMuY2hpbGRyZW4uZW50cmllcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc3ByZWFkOiBmdW5jdGlvbiAocHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgQWN0aW9ucy5TcHJlYWQodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b2dnbGVWaXNpYmxlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIEFjdGlvbnMuVG9nZ2xlVmlzaWJsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9sYXllci9MYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFJlbmRlclBhc3MgV2lsbCBvbmx5IHdvcmsgd2l0aCBTcHJpdGUgYW5kIEltYWdlIEdhbWVPYmplY3RzLlxyXG5cclxudmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvQ2xhc3MnKTtcclxudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xyXG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9SZW5kZXJQYXNzUmVuZGVyJyk7XHJcbnZhciBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcicpO1xyXG5cclxuLy8gICBSZW5kZXJQYXNzIC0gdGhlIHVzZXIgaGFzIGEgaGlnaGVyIGNvbnRyb2wgb24gdGhlIHJlbmRlcmluZyBzaW5jZSB5b3UgZXhwbGljaXRseVxyXG4vLyAgIGluZGljYXRlIHdoYXQgaXMgcmVuZGVyZWQuIFJlbmRlclBhc3MgYWxzbyBoYXMgYSByZW5kZXIgdGFyZ2V0IGJ1dCB0aGUgZGlmZmVyZW5jZVxyXG4vLyAgIGlzIHRoYXQgd2hlbiBleHBsaWNpdGx5IHJlbmRlcmluZyBhbiBvYmplY3QgdG8gdGhlIHJlbmRlciBwYXNzIHRoZSBzaGFkZXIgZnJvbSB0aGF0XHJcbi8vICAgcmVuZGVyIHBhc3MgaXMgYXBwbGllZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGFkZGl0aXZlIHBhc3NlcyBhbmQgc3BlY2lmaWMgb2JqZWN0IGVmZmVjdHMuXHJcblxyXG52YXIgUmVuZGVyUGFzcyA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgRXh0ZW5kczogR2FtZU9iamVjdCxcclxuXHJcbiAgICBNaXhpbnM6IFtcclxuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxyXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcclxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcclxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcclxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclRhcmdldCxcclxuICAgICAgICBDb21wb25lbnRzLlNjYWxlTW9kZSxcclxuICAgICAgICBDb21wb25lbnRzLlNpemUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIFJlbmRlclxyXG4gICAgXSxcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFJlbmRlclBhc3MgKHN0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzaGFkZXJOYW1lLCBmcmFnbWVudFNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsICdSZW5kZXJQYXNzJyk7XHJcbiAgICAgICBcclxuICAgICAgICB2YXIgcmVzb3VyY2VNYW5hZ2VyID0gc3RhdGUuZ2FtZS5yZW5kZXJlci5yZXNvdXJjZU1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHBvdCA9ICgod2lkdGggJiAod2lkdGggLSAxKSkgPT0gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PSAwKTtcclxuICAgICAgICB2YXIgZ2w7XHJcbiAgICAgICAgdmFyIHdyYXA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHN0YXRlLmdhbWUucmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFzc1NoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAocmVzb3VyY2VNYW5hZ2VyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbCA9IHN0YXRlLmdhbWUucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgICAgIHdyYXAgPSBwb3QgPyBnbC5SRVBFQVQgOiBnbC5DTEFNUF9UT19FREdFO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NTaGFkZXIgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKHNoYWRlck5hbWUsIHt2ZXJ0OiBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIudmVydCwgZnJhZzogZnJhZ21lbnRTaGFkZXJ9KTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gcmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVRleHR1cmUoMCwgZ2wuTElORUFSLCBnbC5MSU5FQVIsIHdyYXAsIHdyYXAsIGdsLlJHQkEsIG51bGwsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NSZW5kZXJUYXJnZXQgPSByZXNvdXJjZU1hbmFnZXIuY3JlYXRlUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHRoaXMucmVuZGVyVGV4dHVyZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHN0YXRlLmdhbWUucmVuZGVyZXIuY3VycmVudFRleHR1cmUgPSBudWxsOyAvLyBmb3JjZSByZWJpbmRpbmcgb2YgcHJldiB0ZXh0dXJlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZsaXBZID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJDb2xvckJ1ZmZlcjogZnVuY3Rpb24gKHIsIGcsIGIsIGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuXHJcbiAgICAgICAgaWYgKGdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnBhc3NSZW5kZXJUYXJnZXQuZnJhbWVidWZmZXJPYmplY3QpO1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyRGVwdGhTdGVuY2lsQnVmZmVyczogZnVuY3Rpb24gKGRlcHRoLCBzdGVuY2lsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wuY2xlYXJEZXB0aChkZXB0aCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyU3RlbmNpbChzdGVuY2lsKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhckFsbEJ1ZmZlcnM6IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBkZXB0aCwgc3RlbmNpbClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMucGFzc1JlbmRlclRhcmdldC5mcmFtZWJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyRGVwdGgoZGVwdGgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoc3RlbmNpbCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICBpZiAoZ2wpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFJlbmRlcmVyKHRoaXMucmVuZGVyZXIuc3ByaXRlQmF0Y2gsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZFNwcml0ZShnYW1lT2JqZWN0LCBjYW1lcmEpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNwcml0ZUJhdGNoLmZsdXNoKHRoaXMucGFzc1NoYWRlciwgdGhpcy5wYXNzUmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFJlbmRlclRleHR1cmVBdDogZnVuY3Rpb24gKHJlbmRlclRleHR1cmUsIHNhbXBsZXJOYW1lLCB1bml0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8qIFRleHR1cmUgMSBpcyByZXNlcnZlZCBmb3IgUGhhc2VycyBNYWluIFJlbmRlcmVyICovXHJcbiAgICAgICAgICAgIHVuaXQgPSAodW5pdCA+IDApID8gdW5pdCA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SW50KHNhbXBsZXJOYW1lLCB1bml0KTtcclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCByZW5kZXJUZXh0dXJlLnRleHR1cmUpO1xyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuaWZvcm1Mb2NhdGlvbjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uO1xyXG5cclxuICAgICAgICBpZiAodW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbG9jYXRpb24gPSBwYXNzU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IGxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxvYXQyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEZsb2F0Mih0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGbG9hdDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50RmxvYXQzKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSwgeik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsb2F0NDogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5LCB6LCB3KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRGbG9hdDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEludDEodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW50MjogZnVuY3Rpb24gKHVuaWZvcm1OYW1lLCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwYXNzU2hhZGVyID0gdGhpcy5wYXNzU2hhZGVyO1xyXG5cclxuICAgICAgICBpZiAocGFzc1NoYWRlciA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhc3NTaGFkZXIuc2V0Q29uc3RhbnRJbnQyKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgeCwgeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEludDM6IGZ1bmN0aW9uICh1bmlmb3JtTmFtZSwgeCwgeSwgeilcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50SW50Myh0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSksIHgsIHksIHopO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbnQ0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIHgsIHksIHosIHcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHBhc3NTaGFkZXIgPSB0aGlzLnBhc3NTaGFkZXI7XHJcblxyXG4gICAgICAgIGlmIChwYXNzU2hhZGVyID09PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFzc1NoYWRlci5zZXRDb25zdGFudEludDQodGhpcy5nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpLCB4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4MngyOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4MngyKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4M3gzOiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4M3gzKHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TWF0cml4NHg0OiBmdW5jdGlvbiAodW5pZm9ybU5hbWUsIG1hdHJpeClcclxuICAgIHtcclxuICAgICAgICB2YXIgcGFzc1NoYWRlciA9IHRoaXMucGFzc1NoYWRlcjtcclxuXHJcbiAgICAgICAgaWYgKHBhc3NTaGFkZXIgPT09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXNzU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKSwgbWF0cml4KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJQYXNzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcclxudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzJyk7XHJcbnZhciBUaWxlU3ByaXRlUmVuZGVyID0gcmVxdWlyZSgnLi9UaWxlU3ByaXRlUmVuZGVyJyk7XHJcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxuXHJcbnZhciBUaWxlU3ByaXRlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBFeHRlbmRzOiBHYW1lT2JqZWN0LFxyXG5cclxuICAgIE1peGluczogW1xyXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXHJcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxyXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxyXG4gICAgICAgIENvbXBvbmVudHMuT3JpZ2luLFxyXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyVGFyZ2V0LFxyXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcclxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXHJcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXHJcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxyXG4gICAgICAgIENvbXBvbmVudHMuU2Nyb2xsRmFjdG9yLFxyXG4gICAgICAgIFRpbGVTcHJpdGVSZW5kZXJcclxuICAgIF0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBUaWxlU3ByaXRlIChzdGF0ZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHJlc291cmNlTWFuYWdlciA9IHN0YXRlLmdhbWUucmVuZGVyZXIucmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsICdUaWxlU3ByaXRlJyk7XHJcblxyXG4gICAgICAgIHRoaXMudGlsZVBvc2l0aW9uWCA9IDA7XHJcbiAgICAgICAgdGhpcy50aWxlUG9zaXRpb25ZID0gMDtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRpbGVUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcclxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZVRvRnJhbWUoKTtcclxuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3RXaWR0aCA9IHRoaXMuZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdGhpcy5wb3RIZWlnaHQgPSB0aGlzLmZyYW1lLmhlaWdodDtcclxuICAgICAgICB0aGlzLmNhbnZhc1BhdHRlcm4gPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAocmVzb3VyY2VNYW5hZ2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3RXaWR0aC0tO1xyXG4gICAgICAgICAgICB0aGlzLnBvdFdpZHRoIHw9IHRoaXMucG90V2lkdGggPj4gMTtcclxuICAgICAgICAgICAgdGhpcy5wb3RXaWR0aCB8PSB0aGlzLnBvdFdpZHRoID4+IDI7XHJcbiAgICAgICAgICAgIHRoaXMucG90V2lkdGggfD0gdGhpcy5wb3RXaWR0aCA+PiA0O1xyXG4gICAgICAgICAgICB0aGlzLnBvdFdpZHRoIHw9IHRoaXMucG90V2lkdGggPj4gODtcclxuICAgICAgICAgICAgdGhpcy5wb3RXaWR0aCB8PSB0aGlzLnBvdFdpZHRoID4+IDE2O1xyXG4gICAgICAgICAgICB0aGlzLnBvdFdpZHRoKys7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodC0tO1xyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodCB8PSB0aGlzLnBvdEhlaWdodCA+PiAxO1xyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodCB8PSB0aGlzLnBvdEhlaWdodCA+PiAyO1xyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodCB8PSB0aGlzLnBvdEhlaWdodCA+PiA0O1xyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodCB8PSB0aGlzLnBvdEhlaWdodCA+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnBvdEhlaWdodCB8PSB0aGlzLnBvdEhlaWdodCA+PiAxNjtcclxuICAgICAgICAgICAgdGhpcy5wb3RIZWlnaHQrKztcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBzdGF0ZS5nYW1lLnJlbmRlcmVyO1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSBzdGF0ZS5nYW1lLnJlbmRlcmVyLmdsO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aWxlVGV4dHVyZSA9IHJlc291cmNlTWFuYWdlci5jcmVhdGVUZXh0dXJlKDAsIGdsLkxJTkVBUiwgZ2wuTElORUFSLCBnbC5SRVBFQVQsIGdsLlJFUEVBVCwgZ2wuUkdCQSwgdGhpcy5jYW52YXNCdWZmZXIsIHRoaXMucG90V2lkdGgsIHRoaXMucG90SGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyID0gQ2FudmFzUG9vbC5jcmVhdGUyRChudWxsLCB0aGlzLnBvdFdpZHRoLCB0aGlzLnBvdEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNCdWZmZXJDdHggPSB0aGlzLmNhbnZhc0J1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbGVUZXh0dXJlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVRpbGVUZXh0dXJlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyLndpZHRoID0gdGhpcy5jYW52YXNCdWZmZXIud2lkdGg7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyQ3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgdGhpcy5mcmFtZS5zb3VyY2UuaW1hZ2UsXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWUuY3V0WCwgdGhpcy5mcmFtZS5jdXRZLFxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lLmN1dFdpZHRoLCB0aGlzLmZyYW1lLmN1dEhlaWdodCxcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgdGhpcy5wb3RXaWR0aCwgdGhpcy5wb3RIZWlnaHRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBsb2FkQ2FudmFzVG9HUFUodGhpcy5jYW52YXNCdWZmZXIsIHRoaXMudGlsZVRleHR1cmUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1BhdHRlcm4gPSB0aGlzLmNhbnZhc0J1ZmZlckN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuY2FudmFzQnVmZmVyLCAncmVwZWF0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50aWxlVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDYW52YXNQb29sLnJlbW92ZSh0aGlzLmNhbnZhc0J1ZmZlcik7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzUGF0dGVybiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYW52YXNCdWZmZXJDdHggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FudmFzQnVmZmVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVNwcml0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlc3ByaXRlL1RpbGVTcHJpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY2xlID0gZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcclxue1xyXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgaWYgKHJhZGl1cyA9PT0gdW5kZWZpbmVkKSB7IHJhZGl1cyA9IDA7IH1cclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xyXG4gICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG59O1xyXG5cclxuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcclxuXHJcbkNpcmNsZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHJhZGl1cyAqIDI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRUbygwLCAwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3JhZGl1cyA8PSAwKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaXJjbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgcmFkaXVzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSB2YWx1ZSAqIDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlhbWV0ZXI6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpYW1ldGVyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWUgKiAwLjU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWUgKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55IC0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUgKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLl9yYWRpdXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZSAtIHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyBhIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gcG9pbnQgZnJvbSBhbnl3aGVyZSB3aXRoaW4gdGhpcyBDaXJjbGUuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI3JhbmRvbVxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fG9iamVjdH0gW291dF0gLSBBIFBoYXNlci5Qb2ludCwgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllcywgdGhhdCB0aGUgdmFsdWVzIHdpbGwgYmUgc2V0IGluLlxyXG4qICAgICBJZiBubyBvYmplY3QgaXMgcHJvdmlkZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuIEluIGhpZ2ggcGVyZm9ybWFuY2UgYXJlYXMgYXZvaWQgdGhpcyBieSByZS11c2luZyBhbiBleGlzdGluZyBvYmplY3QuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmFuZG9tIHBvaW50IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgdCA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciB1ID0gTWF0aC5yYW5kb20oKSArIE1hdGgucmFuZG9tKCk7XHJcbiAgICB2YXIgciA9ICh1ID4gMSkgPyAyIC0gdSA6IHU7XHJcbiAgICB2YXIgeCA9IHIgKiBNYXRoLmNvcyh0KTtcclxuICAgIHZhciB5ID0gciAqIE1hdGguc2luKHQpO1xyXG5cclxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoeCAqIGNpcmNsZS5yYWRpdXMpO1xyXG4gICAgb3V0LnkgPSBjaXJjbGUueSArICh5ICogY2lyY2xlLnJhZGl1cyk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cclxuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMDsgfVxyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDA7IH1cclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59O1xyXG5cclxuRWxsaXBzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlO1xyXG5cclxuRWxsaXBzZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRUbygwLCAwLCAwLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBBS0EgU2VtaSBNaW5vciBBeGlzXHJcbiAgICBnZXRNaW5vclJhZGl1czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIC8gMjtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIEFLQSBTZW1pIE1ham9yIEF4aXNcclxuICAgIGdldE1ham9yUmFkaXVzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsbGlwc2UucHJvdG90eXBlLCB7XHJcblxyXG4gICAgbGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRvcDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uIChlbGxpcHNlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciBwID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoTWF0aC5yYW5kb20oKSk7XHJcblxyXG4gICAgb3V0LnggPSBlbGxpcHNlLnggKyAoKHMgKiBNYXRoLmNvcyhwKSkgKiBlbGxpcHNlLndpZHRoIC8gMik7XHJcbiAgICBvdXQueSA9IGVsbGlwc2UueSArICgocyAqIE1hdGguc2luKHApKSAqIGVsbGlwc2UuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQmFzZWQgb24gY29kZSBieSBNYXR0IERlc0xhdXJpZXJzXHJcbi8vICBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvbGluZS1jaXJjbGUtY29sbGlzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcclxuXHJcbnZhciBDb250YWlucyA9IHJlcXVpcmUoJy4uL2NpcmNsZS9Db250YWlucycpO1xyXG5cclxudmFyIHRtcCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxudmFyIExpbmVUb0NpcmNsZSA9IGZ1bmN0aW9uIChsaW5lLCBjaXJjbGUsIG5lYXJlc3QpXHJcbntcclxuICAgIGlmIChuZWFyZXN0ID09PSB1bmRlZmluZWQpIHsgbmVhcmVzdCA9IHRtcDsgfVxyXG5cclxuICAgIGlmIChDb250YWlucyhjaXJjbGUsIGxpbmUueDEsIGxpbmUueTEpKVxyXG4gICAge1xyXG4gICAgICAgIG5lYXJlc3QueCA9IGxpbmUueDE7XHJcbiAgICAgICAgbmVhcmVzdC55ID0gbGluZS55MTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKENvbnRhaW5zKGNpcmNsZSwgbGluZS54MiwgbGluZS55MikpXHJcbiAgICB7XHJcbiAgICAgICAgbmVhcmVzdC54ID0gbGluZS54MjtcclxuICAgICAgICBuZWFyZXN0LnkgPSBsaW5lLnkyO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHggPSBsaW5lLngyIC0gbGluZS54MTtcclxuICAgIHZhciBkeSA9IGxpbmUueTIgLSBsaW5lLnkxO1xyXG5cclxuICAgIHZhciBsY3ggPSBjaXJjbGUueCAtIGxpbmUueDE7XHJcbiAgICB2YXIgbGN5ID0gY2lyY2xlLnkgLSBsaW5lLnkxO1xyXG5cclxuICAgIC8vICBwcm9qZWN0IGxjIG9udG8gZCwgcmVzdWx0aW5nIGluIHZlY3RvciBwXHJcbiAgICB2YXIgZExlbjIgPSAoZHggKiBkeCkgKyAoZHkgKiBkeSk7XHJcbiAgICB2YXIgcHggPSBkeDtcclxuICAgIHZhciBweSA9IGR5O1xyXG5cclxuICAgIGlmIChkTGVuMiA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRwID0gKChsY3ggKiBkeCkgKyAobGN5ICogZHkpKSAvIGRMZW4yO1xyXG5cclxuICAgICAgICBweCAqPSBkcDtcclxuICAgICAgICBweSAqPSBkcDtcclxuICAgIH1cclxuXHJcbiAgICBuZWFyZXN0LnggPSBsaW5lLngxICsgcHg7XHJcbiAgICBuZWFyZXN0LnkgPSBsaW5lLnkxICsgcHk7XHJcbiAgICBcclxuICAgIC8vICBsZW4yIG9mIHBcclxuICAgIHZhciBwTGVuMiA9IChweCAqIHB4KSArIChweSAqIHB5KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBwTGVuMiA8PSBkTGVuMiAmJlxyXG4gICAgICAgICgocHggKiBkeCkgKyAocHkgKiBkeSkpID49IDAgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIG5lYXJlc3QueCwgbmVhcmVzdC55KVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZVRvQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnRUb0xpbmUgPSBmdW5jdGlvbiAocG9pbnQsIGxpbmUpXHJcbntcclxuICAgIHJldHVybiAoKHBvaW50LnggLSBsaW5lLngxKSAqIChsaW5lLnkyIC0gbGluZS55MSkgPT09IChsaW5lLngyIC0gbGluZS54MSkgKiAocG9pbnQueSAtIGxpbmUueTEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qilcclxue1xyXG4gICAgaWYgKHJlY3RBLndpZHRoIDw9IDAgfHwgcmVjdEEuaGVpZ2h0IDw9IDAgfHwgcmVjdEIud2lkdGggPD0gMCB8fCByZWN0Qi5oZWlnaHQgPD0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEocmVjdEEucmlnaHQgPCByZWN0Qi54IHx8IHJlY3RBLmJvdHRvbSA8IHJlY3RCLnkgfHwgcmVjdEEueCA+IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLnkgPiByZWN0Qi5ib3R0b20pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgRGVmaW5lcyBhIExpbmUgc2VnbWVudCwgYSBwYXJ0IG9mIGEgbGluZSBiZXR3ZWVuIHR3byBlbmRwb2ludHNcclxuXHJcbnZhciBMaW5lID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICB0aGlzLngxID0gMDtcclxuICAgIHRoaXMueTEgPSAwO1xyXG4gICAgdGhpcy54MiA9IDA7XHJcbiAgICB0aGlzLnkyID0gMDtcclxuXHJcbiAgICB0aGlzLnNldFRvKHgxLCB5MSwgeDIsIHkyKTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcclxuXHJcbkxpbmUucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldFRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHgxID09PSB1bmRlZmluZWQpIHsgeDEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XHJcbiAgICAgICAgaWYgKHgyID09PSB1bmRlZmluZWQpIHsgeDIgPSAwOyB9XHJcbiAgICAgICAgaWYgKHkyID09PSB1bmRlZmluZWQpIHsgeTIgPSAwOyB9XHJcblxyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcblxyXG4gICAgICAgIHRoaXMueDIgPSB4MjtcclxuICAgICAgICB0aGlzLnkyID0geTI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQb2ludEE6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDEsIHkxOiB0aGlzLnkxIH07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvaW50QjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MiwgeTE6IHRoaXMueTIgfTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMaW5lLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGxlZnQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPD0gdGhpcy54MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueDEsIHRoaXMueDIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueDEgPiB0aGlzLngyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0b3A6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPD0gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYm90dG9tOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnkxLCB0aGlzLnkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnkxID4gdGhpcy55MilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9XcmFwJyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxuXHJcbnZhciBOb3JtYWxBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xyXG5cclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbEFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XHJcblxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIHQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuICAgIG91dC54ID0gbGluZS54MSArIHQgKiAobGluZS54MiAtIGxpbmUueDEpO1xyXG4gICAgb3V0LnkgPSBsaW5lLnkxICsgdCAqIChsaW5lLnkyIC0gbGluZS55MSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChwb2ludC54ICogcG9pbnQueCkgKyAocG9pbnQueSAqIHBvaW50LnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWFnbml0dWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldE1hZ25pdHVkZVNxID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gKHBvaW50LnggKiBwb2ludC54KSArIChwb2ludC55ICogcG9pbnQueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1hZ25pdHVkZVNxO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTXVsdGlwbHkgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHkpXHJcbntcclxuICAgIHBvaW50LnggKj0geDtcclxuICAgIHBvaW50LnkgKj0geTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpcGx5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGUnKTtcclxuXHJcbnZhciBOb3JtYWxpemUgPSBmdW5jdGlvbiAocG9pbnQpXHJcbntcclxuICAgIGlmIChwb2ludC54ICE9PSAwICYmIHBvaW50LnkgIT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG0gPSBHZXRNYWduaXR1ZGUocG9pbnQpO1xyXG5cclxuICAgICAgICBwb2ludC54IC89IG07XHJcbiAgICAgICAgcG9pbnQueSAvPSBtO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNjb250YWluc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb24sIG90aGVyd2lzZSBmYWxzZS5cclxuKi9cclxudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHBvbHlnb24sIHgsIHkpXHJcbntcclxuICAgIC8vICBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbCBieSBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmFcclxuXHJcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IC0xLCBqID0gcG9seWdvbi5wb2ludHMubGVuZ3RoIC0gMTsgKytpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBqID0gaSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaXggPSBwb2x5Z29uLnBvaW50c1tpXS54O1xyXG4gICAgICAgIHZhciBpeSA9IHBvbHlnb24ucG9pbnRzW2ldLnk7XHJcblxyXG4gICAgICAgIHZhciBqeCA9IHBvbHlnb24ucG9pbnRzW2pdLng7XHJcbiAgICAgICAgdmFyIGp5ID0gcG9seWdvbi5wb2ludHNbal0ueTtcclxuXHJcbiAgICAgICAgaWYgKCgoaXkgPD0geSAmJiB5IDwgankpIHx8IChqeSA8PSB5ICYmIHkgPCBpeSkpICYmICh4IDwgKGp4IC0gaXgpICogKHkgLSBpeSkgLyAoankgLSBpeSkgKyBpeCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zaWRlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gYXJlYSAtIFRoZSBhcmVhIG9mIHRoaXMgUG9seWdvbi5cclxuICAgICovXHJcbiAgICB0aGlzLmFyZWEgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXIgcGFpciBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGlzIHBvbHlnb24uIEkuZS4gWyB7eCx5fSwge3gseX0sIHt4LHl9IF1cclxuICAgICovXHJcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuICAgIGlmIChwb2ludHMpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zZXRUbyhwb2ludHMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5Z29uO1xyXG5cclxuUG9seWdvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgUG9seWdvbiB0byB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwb2ludHMgY2FuIGJlIHNldCBmcm9tIGEgdmFyaWV0eSBvZiBmb3JtYXRzOlxyXG4gICAgICpcclxuICAgICAqIC0gQW4gYXJyYXkgb2YgUG9pbnQgb2JqZWN0czogYFtuZXcgUGhhc2VyLlBvaW50KHgxLCB5MSksIC4uLl1gXHJcbiAgICAgKiAtIEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXM6IGBbb2JqMSwgb2JqMiwgLi4uXWBcclxuICAgICAqIC0gQW4gYXJyYXkgb2YgcGFpcmVkIG51bWJlcnMgdGhhdCByZXByZXNlbnQgcG9pbnQgY29vcmRpbmF0ZXM6IGBbeDEseTEsIHgyLHkyLCAuLi5dYFxyXG4gICAgICogLSBBbiBhcnJheSBvZiBhcnJheXMgd2l0aCB0d28gZWxlbWVudHMgcmVwcmVzZW50aW5nIHgveSBjb29yZGluYXRlczogYFtbeDEsIHkxXSwgW3gyLCB5Ml0sIC4uLl1gXHJcbiAgICAgKlxyXG4gICAgICogYHNldFRvYCBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzIHRvIHJlbW92ZSBhbGwgcG9pbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jc2V0VG9cclxuICAgICAqIEBwYXJhbSB7UGhhc2VyLlBvaW50W118bnVtYmVyW118Li4uUGhhc2VyLlBvaW50fC4uLm51bWJlcn0gcG9pbnRzIC0gVGhlIHBvaW50cyB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJuIHtQaGFzZXIuUG9seWdvbn0gVGhpcyBQb2x5Z29uIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBzZXRUbzogZnVuY3Rpb24gKHBvaW50cylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZW50cnk7XHJcbiAgICAgICAgdmFyIHkwID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgcDtcclxuXHJcbiAgICAgICAgLy8gIFRoZSBwb2ludHMgYXJndW1lbnQgaXMgYW4gYXJyYXksIHNvIGl0ZXJhdGUgdGhyb3VnaCBpdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludHNbaV0gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwLnggPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwb2ludHNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgQW4gYXJyYXkgb2YgYXJyYXlzP1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChwKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBMb3dlc3QgYm91bmRhcnlcclxuICAgICAgICAgICAgaWYgKHAueSA8IHkwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB5MCA9IHAueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBcmVhKHkwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYXJlYSBvZiB0aGUgUG9seWdvbi4gVGhpcyBpcyBhdmFpbGFibGUgaW4gdGhlIHByb3BlcnR5IFBvbHlnb24uYXJlYVxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY2FsY3VsYXRlQXJlYVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBsb3dlc3QgYm91bmRhcnlcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZUFyZWE6IGZ1bmN0aW9uICh5MClcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoIDwgMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgdmFyIHAxO1xyXG4gICAgICAgIHZhciBwMjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xyXG4gICAgICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIHN1bSArPSAocDIueCAtIHAxLngpICogKHAxLnkgKyBwMi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbMF07XHJcbiAgICAgICAgcDIgPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgc3VtICs9IChwMS54IC0gcDIueCkgKiAocDIueSArIHAxLnkpO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWEgPSAtc3VtICogMC41O1xyXG5cclxuICAgICAgICAvLyB2YXIgcDE7XHJcbiAgICAgICAgLy8gdmFyIHAyO1xyXG4gICAgICAgIC8vIHZhciBhdmdIZWlnaHQ7XHJcbiAgICAgICAgLy8gdmFyIHdpZHRoO1xyXG5cclxuICAgICAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAvLyAgICAgaWYgKGkgPT09IGxlbiAtIDEpXHJcbiAgICAgICAgLy8gICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIHAyID0gdGhpcy5wb2ludHNbMF07XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgZWxzZVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAvLyAgICAgfVxyXG5cclxuICAgICAgICAvLyAgICAgYXZnSGVpZ2h0ID0gKChwMS55IC0geTApICsgKHAyLnkgLSB5MCkpIC8gMjtcclxuICAgICAgICAvLyAgICAgd2lkdGggPSBwMS54IC0gcDIueDtcclxuICAgICAgICAvLyAgICAgdGhpcy5hcmVhICs9IGF2Z0hlaWdodCAqIHdpZHRoO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVjb21wb3NlID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IFtdOyB9XHJcblxyXG4gICAgb3V0LnB1c2goeyB4OiByZWN0LngsIHk6IHJlY3QueSB9KTtcclxuICAgIG91dC5wdXNoKHsgeDogcmVjdC5yaWdodCwgeTogcmVjdC55IH0pO1xyXG4gICAgb3V0LnB1c2goeyB4OiByZWN0LnJpZ2h0LCB5OiByZWN0LmJvdHRvbSB9KTtcclxuICAgIG91dC5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LmJvdHRvbSB9KTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWNvbXBvc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvRGVjb21wb3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBlcmltZXRlciA9IHJlcXVpcmUoJy4vUGVyaW1ldGVyJyk7XHJcblxyXG4vLyAgUmV0dXJuIGFuIGFycmF5IG9mIHBvaW50cyBmcm9tIHRoZSBwZXJpbWV0ZXIgb2YgdGhlIHJlY3RhbmdsZVxyXG4vLyAgZWFjaCBzcGFjZWQgb3V0IGJhc2VkIG9uIHRoZSBxdWFudGl0eSBvciBzdGVwIHJlcXVpcmVkXHJcblxyXG52YXIgTWFyY2hpbmdBbnRzID0gZnVuY3Rpb24gKHJlY3QsIHN0ZXAsIHF1YW50aXR5LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxyXG5cclxuICAgIGlmICghc3RlcCAmJiAhcXVhbnRpdHkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEJhaWwgb3V0XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgSWYgc3RlcCBpcyBhIGZhbHNleSB2YWx1ZSAoZmFsc2UsIG51bGwsIDAsIHVuZGVmaW5lZCwgZXRjKSB0aGVuIHdlIGNhbGN1bGF0ZVxyXG4gICAgLy8gIGl0IGJhc2VkIG9uIHRoZSBxdWFudGl0eSBpbnN0ZWFkLCBvdGhlcndpc2Ugd2UgYWx3YXlzIHVzZSB0aGUgc3RlcCB2YWx1ZVxyXG4gICAgaWYgKCFzdGVwKVxyXG4gICAge1xyXG4gICAgICAgIHN0ZXAgPSBQZXJpbWV0ZXIocmVjdCkgLyBxdWFudGl0eTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBxdWFudGl0eSA9IE1hdGgucm91bmQoUGVyaW1ldGVyKHJlY3QpIC8gc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSByZWN0Lng7XHJcbiAgICB2YXIgeSA9IHJlY3QueTtcclxuICAgIHZhciBmYWNlID0gMDtcclxuXHJcbiAgICAvLyAgTG9vcCBhY3Jvc3MgZWFjaCBmYWNlIG9mIHRoZSByZWN0YW5nbGVcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YW50aXR5OyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnB1c2goeyB4OiB4LCB5OiB5IH0pO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGZhY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVG9wIGZhY2VcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgeCArPSBzdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IHJlY3QucmlnaHQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSAoeCAtIHJlY3QucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSByZWN0LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyAgUmlnaHQgZmFjZVxyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICB5ICs9IHN0ZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPj0gcmVjdC5ib3R0b20pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeCAtPSAoeSAtIHJlY3QuYm90dG9tKTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gcmVjdC5ib3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vICBCb3R0b20gZmFjZVxyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICB4IC09IHN0ZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHggPD0gcmVjdC5sZWZ0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgLT0gKHJlY3QubGVmdCAtIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vICBMZWZ0IGZhY2VcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgeSAtPSBzdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh5IDw9IHJlY3QudG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSByZWN0LnRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXJjaGluZ0FudHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvTWFyY2hpbmdBbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBlcmltZXRlciA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZXR1cm4gMiAqIChyZWN0LndpZHRoICsgcmVjdC5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJpbWV0ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICBvdXQueCA9IHJlY3QueCArIChNYXRoLnJhbmRvbSgpICogcmVjdC53aWR0aCk7XHJcbiAgICBvdXQueSA9IHJlY3QueSArIChNYXRoLnJhbmRvbSgpICogcmVjdC5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIHRocmVlIG1lZGlhbnMgKHRoZSBsaW5lcyBkcmF3biBmcm9tIHRoZSB2ZXJ0aWNlcyB0byB0aGUgYmlzZWN0b3JzIG9mIHRoZSBvcHBvc2l0ZSBzaWRlcylcclxuLy8gIG1lZXQgaW4gdGhlIGNlbnRyb2lkIG9yIGNlbnRlciBvZiBtYXNzIChjZW50ZXIgb2YgZ3Jhdml0eSkuXHJcbi8vICBUaGUgY2VudHJvaWQgZGl2aWRlcyBlYWNoIG1lZGlhbiBpbiBhIHJhdGlvIG9mIDI6MVxyXG5cclxudmFyIENlbnRyb2lkID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gKHRyaWFuZ2xlLngxICsgdHJpYW5nbGUueDIgKyB0cmlhbmdsZS54MykgLyAzO1xyXG4gICAgb3V0LnkgPSAodHJpYW5nbGUueTEgKyB0cmlhbmdsZS55MiArIHRyaWFuZ2xlLnkzKSAvIDM7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudHJvaWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9DZW50cm9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEZWNvbXBvc2UgPSBmdW5jdGlvbiAodHJpYW5nbGUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IFtdOyB9XHJcblxyXG4gICAgb3V0LnB1c2goeyB4OiB0cmlhbmdsZS54MSwgeTogdHJpYW5nbGUueTEgfSk7XHJcbiAgICBvdXQucHVzaCh7IHg6IHRyaWFuZ2xlLngyLCB5OiB0cmlhbmdsZS55MiB9KTtcclxuICAgIG91dC5wdXNoKHsgeDogdHJpYW5nbGUueDMsIHk6IHRyaWFuZ2xlLnkzIH0pO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlY29tcG9zZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0RlY29tcG9zZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSB0aHJlZSBhbmdsZSBiaXNlY3RvcnMgb2YgYSB0cmlhbmdsZSBtZWV0IGluIG9uZSBwb2ludCBjYWxsZWQgdGhlIGluY2VudGVyLlxyXG4vLyBJdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBpbmNpcmNsZSwgdGhlIGNpcmNsZSBpbnNjcmliZWQgaW4gdGhlIHRyaWFuZ2xlLlxyXG5cclxuZnVuY3Rpb24gZ2V0TGVuZ3RoICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgdmFyIHggPSB4MSAtIHgyO1xyXG4gICAgdmFyIHkgPSB5MSAtIHkyO1xyXG4gICAgdmFyIG1hZ25pdHVkZSA9ICh4ICogeCkgKyAoeSAqIHkpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQobWFnbml0dWRlKTtcclxufVxyXG5cclxudmFyIEluQ2VudGVyID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIHZhciB4MSA9IHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XHJcblxyXG4gICAgdmFyIHgyID0gdHJpYW5nbGUueDI7XHJcbiAgICB2YXIgeTIgPSB0cmlhbmdsZS55MjtcclxuXHJcbiAgICB2YXIgeDMgPSB0cmlhbmdsZS54MztcclxuICAgIHZhciB5MyA9IHRyaWFuZ2xlLnkzO1xyXG5cclxuICAgIHZhciBkMSA9IGdldExlbmd0aCh4MywgeTMsIHgyLCB5Mik7XHJcbiAgICB2YXIgZDIgPSBnZXRMZW5ndGgoeDEsIHkxLCB4MywgeTMpO1xyXG4gICAgdmFyIGQzID0gZ2V0TGVuZ3RoKHgyLCB5MiwgeDEsIHkxKTtcclxuXHJcbiAgICB2YXIgcCA9IGQxICsgZDIgKyBkMztcclxuXHJcbiAgICBvdXQueCA9ICh4MSAqIGQxICsgeDIgKiBkMiArIHgzICogZDMpIC8gcDtcclxuICAgIG91dC55ID0gKHkxICogZDEgKyB5MiAqIGQyICsgeTMgKiBkMykgLyBwO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluQ2VudGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvSW5DZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5KVxyXG57XHJcbiAgICB0cmlhbmdsZS54MSArPSB4O1xyXG4gICAgdHJpYW5nbGUueTEgKz0geTtcclxuXHJcbiAgICB0cmlhbmdsZS54MiArPSB4O1xyXG4gICAgdHJpYW5nbGUueTIgKz0geTtcclxuXHJcbiAgICB0cmlhbmdsZS54MyArPSB4O1xyXG4gICAgdHJpYW5nbGUueTMgKz0geTtcclxuXHJcbiAgICByZXR1cm4gdHJpYW5nbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIC8vICBCYXNpcyB2ZWN0b3JzXHJcbiAgICB2YXIgdXggPSB0cmlhbmdsZS54MiAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHV5ID0gdHJpYW5nbGUueTIgLSB0cmlhbmdsZS55MTtcclxuXHJcbiAgICB2YXIgdnggPSB0cmlhbmdsZS54MyAtIHRyaWFuZ2xlLngxO1xyXG4gICAgdmFyIHZ5ID0gdHJpYW5nbGUueTMgLSB0cmlhbmdsZS55MTtcclxuXHJcbiAgICAvLyAgUmFuZG9tIHBvaW50IHdpdGhpbiB0aGUgdW5pdCBzcXVhcmVcclxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKTtcclxuICAgIHZhciBzID0gTWF0aC5yYW5kb20oKTtcclxuXHJcbiAgICAvLyAgUG9pbnQgb3V0c2lkZSB0aGUgdHJpYW5nbGU/IFJlbWFwIGl0LlxyXG4gICAgaWYgKHIgKyBzID49IDEpXHJcbiAgICB7XHJcbiAgICAgICAgciA9IDEgLSByO1xyXG4gICAgICAgIHMgPSAxIC0gcztcclxuICAgIH1cclxuXHJcbiAgICBvdXQueCA9IHRyaWFuZ2xlLngxICsgKCh1eCAqIHIpICsgKHZ4ICogcykpO1xyXG4gICAgb3V0LnkgPSB0cmlhbmdsZS55MSArICgodXkgKiByKSArICh2eSAqIHMpKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBZGRzIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgdmFsdWUsIHVwIHRvIGEgbWF4aW11bSBvZiAyNTUuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQWRkXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIEFkZCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5taW4oMjU1LCBhICsgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIERhcmtlbnMgdGhlIGJhY2tkcm9wIGNvbG9yIHRvIHJlZmxlY3QgdGhlIHNvdXJjZSBjb2xvci5cclxuKiBQYWludGluZyB3aXRoIHdoaXRlIHByb2R1Y2VzIG5vIGNoYW5nZS4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQ29sb3JCdXJuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIENvbG9yQnVybiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPT09IDApID8gYiA6IE1hdGgubWF4KDAsICgyNTUgLSAoKDI1NSAtIGEpIDw8IDgpIC8gYikpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvckJ1cm47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Db2xvckJ1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBCcmlnaHRlbnMgdGhlIGJhY2tkcm9wIGNvbG9yIHRvIHJlZmxlY3QgdGhlIHNvdXJjZSBjb2xvci4gXHJcbiogUGFpbnRpbmcgd2l0aCBibGFjayBwcm9kdWNlcyBubyBjaGFuZ2UuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQ29sb3JEb2RnZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBDb2xvckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA9PT0gMjU1KSA/IGIgOiBNYXRoLm1pbigyNTUsICgoYSA8PCA4KSAvICgyNTUgLSBiKSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xvckRvZGdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvQ29sb3JEb2RnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFNlbGVjdHMgdGhlIGRhcmtlciBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvcnMuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRGFya2VuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIERhcmtlbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPiBhKSA/IGEgOiBiO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXJrZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9EYXJrZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBTZWxlY3RzIHRoZSBsaWdodGVyIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9ycy5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRMaWdodGVuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIExpZ2h0ZW4gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID4gYSkgPyBiIDogYTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlnaHRlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpZ2h0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3VidHJhY3QgPSByZXF1aXJlKCcuL1N1YnRyYWN0Jyk7XHJcblxyXG4vKipcclxuKiBBbiBhbGlhcyBmb3IgYmxlbmRTdWJ0cmFjdCwgaXQgc2ltcGx5IHN1bXMgdGhlIHZhbHVlcyBvZiB0aGUgdHdvIGNvbG9ycyBhbmQgc3VidHJhY3RzIDI1NS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRMaW5lYXJCdXJuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIExpbmVhckJ1cm4gPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIFN1YnRyYWN0KGEsIGIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJCdXJuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBZGQgPSByZXF1aXJlKCcuL0FkZCcpO1xyXG5cclxuLyoqXHJcbiogQW4gYWxpYXMgZm9yIGJsZW5kQWRkLCBpdCBzaW1wbHkgc3VtcyB0aGUgdmFsdWVzIG9mIHRoZSB0d28gY29sb3JzLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckRvZGdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIExpbmVhckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBBZGQoYSwgYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckRvZGdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyRG9kZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBNdWx0aXBsaWVzIG9yIHNjcmVlbnMgdGhlIGNvbG9ycywgZGVwZW5kaW5nIG9uIHRoZSBiYWNrZHJvcCBjb2xvci5cclxuKiBTb3VyY2UgY29sb3JzIG92ZXJsYXkgdGhlIGJhY2tkcm9wIHdoaWxlIHByZXNlcnZpbmcgaXRzIGhpZ2hsaWdodHMgYW5kIHNoYWRvd3MuIFxyXG4qIFRoZSBiYWNrZHJvcCBjb2xvciBpcyBub3QgcmVwbGFjZWQsIGJ1dCBpcyBtaXhlZCB3aXRoIHRoZSBzb3VyY2UgY29sb3IgdG8gcmVmbGVjdCB0aGUgbGlnaHRuZXNzIG9yIGRhcmtuZXNzIG9mIHRoZSBiYWNrZHJvcC5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRPdmVybGF5XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIE92ZXJsYXkgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiIDwgMTI4KSA/ICgyICogYSAqIGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYSkgKiAoMjU1IC0gYikgLyAyNTUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvT3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJlZmxlY3QgYmxlbmQgbW9kZS4gVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIGFkZGluZyBzaGluaW5nIG9iamVjdHMgb3IgbGlnaHQgem9uZXMgdG8gaW1hZ2VzLiBcclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRSZWZsZWN0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFJlZmxlY3QgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKGEgKiBhIC8gKDI1NSAtIGIpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9SZWZsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ29tYmluZXMgdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzIGFuZCByZXR1cm5zIHRoZWlyIHZhbHVlIG1pbnVzIDI1NS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRTdWJ0cmFjdFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBTdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgYSArIGIgLSAyNTUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdWJ0cmFjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL1N1YnRyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yQnVybiA9IHJlcXVpcmUoJy4vQ29sb3JCdXJuJyk7XHJcbnZhciBDb2xvckRvZGdlID0gcmVxdWlyZSgnLi9Db2xvckRvZGdlJyk7XHJcblxyXG4vKipcclxuKiBUaGlzIGJsZW5kIG1vZGUgY29tYmluZXMgQ29sb3IgRG9kZ2UgYW5kIENvbG9yIEJ1cm4gKHJlc2NhbGVkIHNvIHRoYXQgbmV1dHJhbCBjb2xvcnMgYmVjb21lIG1pZGRsZSBncmF5KS5cclxuKiBEb2RnZSBhcHBsaWVzIHdoZW4gdmFsdWVzIGluIHRoZSB0b3AgbGF5ZXIgYXJlIGxpZ2h0ZXIgdGhhbiBtaWRkbGUgZ3JheSwgYW5kIGJ1cm4gdG8gZGFya2VyIHZhbHVlcy5cclxuKiBUaGUgbWlkZGxlIGdyYXkgaXMgdGhlIG5ldXRyYWwgY29sb3IuIFdoZW4gY29sb3IgaXMgbGlnaHRlciB0aGFuIHRoaXMsIHRoaXMgZWZmZWN0aXZlbHkgbW92ZXMgdGhlIHdoaXRlIHBvaW50IG9mIHRoZSBib3R0b20gXHJcbiogbGF5ZXIgZG93biBieSB0d2ljZSB0aGUgZGlmZmVyZW5jZTsgd2hlbiBpdCBpcyBkYXJrZXIsIHRoZSBibGFjayBwb2ludCBpcyBtb3ZlZCB1cCBieSB0d2ljZSB0aGUgZGlmZmVyZW5jZS4gVGhlIHBlcmNlaXZlZCBjb250cmFzdCBpbmNyZWFzZXMuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kVml2aWRMaWdodFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBWaXZpZExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA8IDEyOCkgPyBDb2xvckJ1cm4oYSwgMiAqIGIpIDogQ29sb3JEb2RnZShhLCAoMiAqIChiIC0gMTI4KSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWaXZpZExpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvVml2aWRMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybiBhIHN0cmluZyBjb250YWluaW5nIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBjb2xvciBjb21wb25lbnQuXHJcbipcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGNvbG9yIC0gVGhlIGNvbG9yIGNoYW5uZWwgdG8gZ2V0IHRoZSBoZXggdmFsdWUgZm9yLCBtdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUuXHJcbiogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBvZiBsZW5ndGggMiBjaGFyYWN0ZXJzLCBpLmUuIDI1NSA9IGZmLCAxMDAgPSA2NC5cclxuKi9cclxudmFyIENvbXBvbmVudFRvSGV4ID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICB2YXIgaGV4ID0gY29sb3IudG9TdHJpbmcoMTYpO1xyXG5cclxuICAgIHJldHVybiAoaGV4Lmxlbmd0aCA9PT0gMSkgPyAnMCcgKyBoZXggOiBoZXg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudFRvSGV4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0NvbXBvbmVudFRvSGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEdpdmVuIGFuIGFscGhhIGFuZCAzIGNvbG9yIHZhbHVlcyB0aGlzIHdpbGwgcmV0dXJuIGFuIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgaXQuXHJcbiAqXHJcbiAqIEBtZXRob2QgZ2V0Q29sb3IzMlxyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHIgLSBUaGUgcmVkIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuICogQHBhcmFtIHtpbnRlZ2VyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuICogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJsdWUgY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBBIG5hdGl2ZSBjb2xvciB2YWx1ZSBpbnRlZ2VyIChmb3JtYXQ6IDB4UlJHR0JCKS5cclxuICovXHJcbnZhciBHZXRDb2xvcjMyID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG57XHJcbiAgICByZXR1cm4gYWxwaGEgPDwgMjQgfCByZWQgPDwgMTYgfCBncmVlbiA8PCA4IHwgYmx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Q29sb3IzMjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9HZXRDb2xvcjMyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENvbG9yID0gcmVxdWlyZSgnLi9HZXRDb2xvcicpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIEhTViAoaHVlLCBzYXR1cmF0aW9uIGFuZCB2YWx1ZSkgY29sb3IgdmFsdWUgdG8gUkdCLlxyXG4gKiBDb252ZXJzaW9uIGZvcm11bGEgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuICogQXNzdW1lcyBIU1YgdmFsdWVzIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMV0gYW5kIHJldHVybnMgciwgZyBhbmQgYiB2YWx1ZXMgaW4gdGhlIHNldCBbMCwgMjU1XS5cclxuICogQmFzZWQgb24gY29kZSBieSBNaWNoYWVsIEphY2tzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uKVxyXG4gKlxyXG4gKiBAbWV0aG9kIGZyb21IU1ZcclxuICogQHBhcmFtIHtudW1iZXJ9IGggLSBUaGUgaHVlLCBpbiB0aGUgcmFuZ2UgMCAtIDEuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNhdHVyYXRpb24sIGluIHRoZSByYW5nZSAwIC0gMS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHYgLSBUaGUgdmFsdWUsIGluIHRoZSByYW5nZSAwIC0gMS5cclxuICogQHJldHVybiB7QmFzZUNvbG9yfSBUaGlzXHJcbiAqL1xyXG52YXIgSFNWVG9SR0IgPSBmdW5jdGlvbiAoaCwgcywgdilcclxue1xyXG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgeyBzID0gMTsgfVxyXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgeyB2ID0gMTsgfVxyXG5cclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XHJcbiAgICB2YXIgZiA9IGggKiA2IC0gaTtcclxuXHJcbiAgICB2YXIgcCA9IE1hdGguZmxvb3IoKHYgKiAoMSAtIHMpKSAqIDI1NSk7XHJcbiAgICB2YXIgcSA9IE1hdGguZmxvb3IoKHYgKiAoMSAtIGYgKiBzKSkgKiAyNTUpO1xyXG4gICAgdmFyIHQgPSBNYXRoLmZsb29yKCh2ICogKDEgLSAoMSAtIGYpICogcykpICogMjU1KTtcclxuXHJcbiAgICB2ID0gTWF0aC5mbG9vcih2ICo9IDI1NSk7XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IHsgcjogdiwgZzogdiwgYjogdiwgY29sb3I6IDAgfTtcclxuXHJcbiAgICB2YXIgciA9IGkgJSA2O1xyXG5cclxuICAgIGlmIChyID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5nID0gdDtcclxuICAgICAgICBvdXRwdXQuYiA9IHA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5yID0gcTtcclxuICAgICAgICBvdXRwdXQuYiA9IHA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyID09PSAyKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5yID0gcDtcclxuICAgICAgICBvdXRwdXQuYiA9IHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyID09PSAzKVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5yID0gcDtcclxuICAgICAgICBvdXRwdXQuZyA9IHE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyID09PSA0KVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5yID0gdDtcclxuICAgICAgICBvdXRwdXQuZyA9IHA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyID09PSA1KVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5nID0gcDtcclxuICAgICAgICBvdXRwdXQuYiA9IHE7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0LmNvbG9yID0gR2V0Q29sb3Iob3V0cHV0LnIsIG91dHB1dC5nLCBvdXRwdXQuYik7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSFNWVG9SR0I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSFNWVG9SR0IuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XHJcblxyXG4vKipcclxuKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhIFBoYXNlciBDb2xvciBvYmplY3QuXHJcbipcclxuKiBUaGUgaGV4IHN0cmluZyBjYW4gc3VwcGxpZWQgYXMgYCcjMDAzM2ZmJ2Agb3IgdGhlIHNob3J0LWhhbmQgZm9ybWF0IG9mIGAnIzAzZidgOyBpdCBjYW4gYmVnaW4gd2l0aCBhbiBvcHRpb25hbCBcIiNcIiBvciBcIjB4XCIsIG9yIGJlIHVucHJlZml4ZWQuICAgIFxyXG4qXHJcbiogQW4gYWxwaGEgY2hhbm5lbCBpcyBfbm90XyBzdXBwb3J0ZWQuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5Db2xvci5oZXhUb0NvbG9yXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7c3RyaW5nfSBoZXggLSBUaGUgY29sb3Igc3RyaW5nIGluIGEgaGV4IGZvcm1hdC5cclxuKiBAcGFyYW0ge29iamVjdH0gW291dF0gLSBBbiBvYmplY3QgaW50byB3aGljaCAzIHByb3BlcnRpZXMgd2lsbCBiZSBjcmVhdGVkIG9yIHNldDogciwgZyBhbmQgYi4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgc2V0IGluIHRoZSByLCBnIGFuZCBiIHByb3BlcnRpZXMuXHJcbiovXHJcbnZhciBIZXhTdHJpbmdUb0NvbG9yID0gZnVuY3Rpb24gKGhleClcclxue1xyXG4gICAgdmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblxyXG4gICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxyXG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14oPzojfDB4KT8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2ksIGZ1bmN0aW9uKG0sIHIsIGcsIGIpIHtcclxuICAgICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IC9eKD86I3wweCk/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcclxuXHJcbiAgICBpZiAocmVzdWx0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciByID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxNik7XHJcbiAgICAgICAgdmFyIGcgPSBwYXJzZUludChyZXN1bHRbMl0sIDE2KTtcclxuICAgICAgICB2YXIgYiA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpO1xyXG5cclxuICAgICAgICBjb2xvci5zZXRUbyhyLCBnLCBiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhleFN0cmluZ1RvQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSGV4U3RyaW5nVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvbnZlcnRzIGEgaHVlIHRvIGFuIFJHQiBjb2xvci5cclxuKiBCYXNlZCBvbiBjb2RlIGJ5IE1pY2hhZWwgSmFja3NvbiAoaHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb24pXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmh1ZVRvQ29sb3JcclxuKiBAcGFyYW0ge251bWJlcn0gcFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBxXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRcclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2xvciBjb21wb25lbnQgdmFsdWUuXHJcbiovXHJcbnZhciBIdWVUb0NvbXBvbmVudCA9IGZ1bmN0aW9uIChwLCBxLCB0KVxyXG57XHJcbiAgICBpZiAodCA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgdCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0ID4gMSlcclxuICAgIHtcclxuICAgICAgICB0IC09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHQgPCAxIC8gNilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA8IDEgLyAyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0IDwgMiAvIDMpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydCA9IEh1ZVRvQ29tcG9uZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0h1ZVRvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG52YXIgSW50ZWdlclRvUkdCID0gcmVxdWlyZSgnLi9JbnRlZ2VyVG9SR0InKTtcclxuXHJcbnZhciBJbnRlZ2VyVG9Db2xvciA9IGZ1bmN0aW9uIChpbnB1dClcclxue1xyXG4gICAgdmFyIHJnYiA9IEludGVnZXJUb1JHQihpbnB1dCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IuciwgcmdiLmcsIHJnYi5iLCByZ2IuYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXJUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUmV0dXJuIHRoZSBjb21wb25lbnQgcGFydHMgb2YgYSBjb2xvciBhcyBhbiBPYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBhbHBoYSwgcmVkLCBncmVlbiwgYmx1ZS5cclxuKlxyXG4qIEFscGhhIHdpbGwgb25seSBiZSBzZXQgaWYgaXQgZXhpc3QgaW4gdGhlIGdpdmVuIGNvbG9yICgweEFBUlJHR0JCKVxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQ29sb3IuZ2V0UkdCXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7bnVtYmVyfSBjb2xvciAtIENvbG9yIGluIFJHQiAoMHhSUkdHQkIpIG9yIEFSR0IgZm9ybWF0ICgweEFBUlJHR0JCKS5cclxuKiBAcmV0dXJuIHtvYmplY3R9IEFuIE9iamVjdCB3aXRoIHByb3BlcnRpZXM6IGFscGhhLCByZWQsIGdyZWVuLCBibHVlIChhbHNvIHIsIGcsIGIgYW5kIGEpLiBBbHBoYSB3aWxsIG9ubHkgYmUgcHJlc2VudCBpZiBhIGNvbG9yIHZhbHVlID4gMTY3NzcyMTUgd2FzIGdpdmVuLlxyXG4qL1xyXG52YXIgSW50ZWdlclRvUkdCID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICBpZiAoY29sb3IgPiAxNjc3NzIxNSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhlIGNvbG9yIHZhbHVlIGhhcyBhbiBhbHBoYSBjb21wb25lbnRcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhOiBjb2xvciA+Pj4gMjQsXHJcbiAgICAgICAgICAgIHI6IGNvbG9yID4+IDE2ICYgMHhGRixcclxuICAgICAgICAgICAgZzogY29sb3IgPj4gOCAmIDB4RkYsXHJcbiAgICAgICAgICAgIGI6IGNvbG9yICYgMHhGRlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYTogMjU1LFxyXG4gICAgICAgICAgICByOiBjb2xvciA+PiAxNiAmIDB4RkYsXHJcbiAgICAgICAgICAgIGc6IGNvbG9yID4+IDggJiAweEZGLFxyXG4gICAgICAgICAgICBiOiBjb2xvciAmIDB4RkZcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyVG9SR0I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSW50ZWdlclRvUkdCLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG5cclxuLyoqXHJcbiogQ29udmVydHMgYSBDU1MgJ3dlYicgc3RyaW5nIGludG8gYSBQaGFzZXIgQ29sb3Igb2JqZWN0LlxyXG4qXHJcbiogVGhlIHdlYiBzdHJpbmcgY2FuIGJlIGluIHRoZSBmb3JtYXQgYCdyZ2IocixnLGIpJ2Agb3IgYCdyZ2JhKHIsZyxiLGEpJ2Agd2hlcmUgci9nL2IgYXJlIGluIHRoZSByYW5nZSBbMC4uMjU1XSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAuLjFdLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQ29sb3Iud2ViVG9Db2xvclxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge3N0cmluZ30gd2ViIC0gVGhlIGNvbG9yIHN0cmluZyBpbiBDU1MgJ3dlYicgZm9ybWF0LlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBbb3V0XSAtIEFuIG9iamVjdCBpbnRvIHdoaWNoIDQgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQ6IHIsIGcsIGIgYW5kIGEuIElmIG5vdCBwcm92aWRlZCBhIG5ldyBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkLlxyXG4qIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIHZhbHVlcyBzZXQgaW4gdGhlIHIsIGcsIGIgYW5kIGEgcHJvcGVydGllcy5cclxuKi9cclxudmFyIFJHQlN0cmluZ1RvQ29sb3IgPSBmdW5jdGlvbiAocmdiKVxyXG57XHJcbiAgICB2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gL15yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xccypcXCkkLy5leGVjKHJnYi50b0xvd2VyQ2FzZSgpKTtcclxuXHJcbiAgICBpZiAocmVzdWx0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciByID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxMCk7XHJcbiAgICAgICAgdmFyIGcgPSBwYXJzZUludChyZXN1bHRbMl0sIDEwKTtcclxuICAgICAgICB2YXIgYiA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTApO1xyXG4gICAgICAgIHZhciBhID0gKHJlc3VsdFs0XSAhPT0gdW5kZWZpbmVkKSA/IHBhcnNlRmxvYXQocmVzdWx0WzRdKSA6IDE7XHJcblxyXG4gICAgICAgIGNvbG9yLnNldFRvKHIsIGcsIGIsIGEgKiAyNTUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUkdCU3RyaW5nVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9SR0JTdHJpbmdUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJHQlN0cmluZ1RvQ29sb3IgPSByZXF1aXJlKCcuL1JHQlN0cmluZ1RvQ29sb3InKTtcclxudmFyIEhleFN0cmluZ1RvQ29sb3IgPSByZXF1aXJlKCcuL0hleFN0cmluZ1RvQ29sb3InKTtcclxudmFyIEludGVnZXJUb0NvbG9yID0gcmVxdWlyZSgnLi9JbnRlZ2VyVG9Db2xvcicpO1xyXG5cclxudmFyIFZhbHVlVG9Db2xvciA9IGZ1bmN0aW9uIChpbnB1dClcclxue1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cigwLCAzKS50b0xvd2VyQ2FzZSgpID09PSAncmdiJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBSR0JTdHJpbmdUb0NvbG9yKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhleFN0cmluZ1RvQ29sb3IoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIEludGVnZXJUb0NvbG9yKGlucHV0KTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmFsdWVUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XHJcbnZhciBLZXlDb2RlcyA9IHJlcXVpcmUoJy4va2V5cy9LZXlDb2RlcycpO1xyXG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXlzL0tleScpO1xyXG52YXIgS2V5Q29tYm8gPSByZXF1aXJlKCcuL2NvbWJvL0tleUNvbWJvJyk7XHJcbnZhciBQcm9jZXNzS2V5Q29tYm8gPSByZXF1aXJlKCcuL2NvbWJvL1Byb2Nlc3NLZXlDb21ibycpO1xyXG52YXIgUHJvY2Vzc0tleURvd24gPSByZXF1aXJlKCcuL2tleXMvUHJvY2Vzc0tleURvd24nKTtcclxudmFyIFByb2Nlc3NLZXlVcCA9IHJlcXVpcmUoJy4va2V5cy9Qcm9jZXNzS2V5VXAnKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBLZXlib2FyZCBjbGFzcyBtb25pdG9ycyBrZXlib2FyZCBpbnB1dCBhbmQgZGlzcGF0Y2hlcyBrZXlib2FyZCBldmVudHMuXHJcbipcclxuKiBfTm90ZV86IG1hbnkga2V5Ym9hcmRzIGFyZSB1bmFibGUgdG8gcHJvY2VzcyBjZXJ0YWluIGNvbWJpbmF0aW9ucyBvZiBrZXlzIGR1ZSB0byBoYXJkd2FyZSBsaW1pdGF0aW9ucyBrbm93biBhcyBnaG9zdGluZy5cclxuKiBTZWUgaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy80ODc2LWltcG9zc2libGUtdG8tdXNlLW1vcmUtdGhhbi0yLWtleWJvYXJkLWlucHV0LWJ1dHRvbnMtYXQtdGhlLXNhbWUtdGltZS8gZm9yIG1vcmUgZGV0YWlscy5cclxuKlxyXG4qIEFsc28gcGxlYXNlIGJlIGF3YXJlIHRoYXQgY2VydGFpbiBicm93c2VyIGV4dGVuc2lvbnMgY2FuIGRpc2FibGUgb3Igb3ZlcnJpZGUgUGhhc2VyIGtleWJvYXJkIGhhbmRsaW5nLlxyXG4qIEZvciBleGFtcGxlIHRoZSBDaHJvbWUgZXh0ZW5zaW9uIHZpbWl1bSBpcyBrbm93biB0byBkaXNhYmxlIFBoYXNlciBmcm9tIHVzaW5nIHRoZSBEIGtleS4gQW5kIHRoZXJlIGFyZSBvdGhlcnMuXHJcbiogU28gcGxlYXNlIGNoZWNrIHlvdXIgZXh0ZW5zaW9ucyBiZWZvcmUgb3BlbmluZyBQaGFzZXIgaXNzdWVzLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5LZXlib2FyZFxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxudmFyIEtleWJvYXJkTWFuYWdlciA9IGZ1bmN0aW9uIChpbnB1dE1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMubWFuYWdlciA9IGlucHV0TWFuYWdlcjtcclxuXHJcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnRhcmdldDtcclxuXHJcbiAgICB0aGlzLmtleXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmNvbWJvcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuY2FwdHVyZXMgPSBbXTtcclxuXHJcbiAgICAvLyAgIFN0YW5kYXJkIEZJRk8gcXVldWVcclxuICAgIHRoaXMucXVldWUgPSBbXTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZXI7XHJcbn07XHJcblxyXG5LZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5Ym9hcmRNYW5hZ2VyO1xyXG5cclxuS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXHJcbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5JbnB1dC5LZXlib2FyZE1hbmFnZXIjYm9vdFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMubWFuYWdlci5nYW1lQ29uZmlnO1xyXG5cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBjb25maWcuaW5wdXRLZXlib2FyZDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGNvbmZpZy5pbnB1dEtleWJvYXJkRXZlbnRUYXJnZXQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydExpc3RlbmVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xyXG4gICAgICAgIHZhciBjYXB0dXJlcyA9IHRoaXMuY2FwdHVyZXM7XHJcblxyXG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZXZlbnQgYWxyZWFkeSBoYW5kbGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVzW2V2ZW50LmtleUNvZGVdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcExpc3RlbmVyczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVyKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIDQgaG90a2V5cyBmb3IgVXAsIERvd24sIExlZnQgYW5kIFJpZ2h0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5LZXlib2FyZCNjcmVhdGVDdXJzb3JLZXlzXHJcbiAgICAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllczogYHVwYCwgYGRvd25gLCBgbGVmdGAgYW5kIGByaWdodGAgb2Yge0BsaW5rIFBoYXNlci5LZXl9IG9iamVjdHMuXHJcbiAgICAqL1xyXG4gICAgY3JlYXRlQ3Vyc29yS2V5czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRLZXlzKHtcclxuICAgICAgICAgICAgdXA6IEtleUNvZGVzLlVQLFxyXG4gICAgICAgICAgICBkb3duOiBLZXlDb2Rlcy5ET1dOLFxyXG4gICAgICAgICAgICBsZWZ0OiBLZXlDb2Rlcy5MRUZULFxyXG4gICAgICAgICAgICByaWdodDogS2V5Q29kZXMuUklHSFRcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgcHJhY3RpY2FsIHdheSB0byBjcmVhdGUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdXNlciBzZWxlY3RlZCBob3RrZXlzLlxyXG4gICAgKlxyXG4gICAgKiBGb3IgZXhhbXBsZSxcclxuICAgICpcclxuICAgICogICAgIGFkZEtleXMoIHsgJ3VwJzogUGhhc2VyLktleUNvZGUuVywgJ2Rvd24nOiBQaGFzZXIuS2V5Q29kZS5TLCAnbGVmdCc6IFBoYXNlci5LZXlDb2RlLkEsICdyaWdodCc6IFBoYXNlci5LZXlDb2RlLkQgfSApO1xyXG4gICAgKlxyXG4gICAgKiB3b3VsZCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyAoYHVwYCwgYGRvd25gLCBgbGVmdGAgYW5kIGByaWdodGApIHJlZmVycmluZyB0byB7QGxpbmsgUGhhc2VyLktleX0gb2JqZWN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5LZXlib2FyZCNhZGRLZXlzXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBrZXlzIC0gQSBrZXkgbWFwcGluZyBvYmplY3QsIGkuZS4gYHsgJ3VwJzogUGhhc2VyLktleUNvZGUuVywgJ2Rvd24nOiBQaGFzZXIuS2V5Q29kZS5TIH1gIG9yIGB7ICd1cCc6IDUyLCAnZG93bic6IDUzIH1gLlxyXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG1hcHBlZCB0byB7QGxpbmsgUGhhc2VyLktleX0gdmFsdWVzLlxyXG4gICAgKi9cclxuICAgIGFkZEtleXM6IGZ1bmN0aW9uIChrZXlzKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IHRoaXMuYWRkS2V5KGtleXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogSWYgeW91IG5lZWQgbW9yZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIGEgS2V5IHlvdSBjYW4gY3JlYXRlIGEgbmV3IFBoYXNlci5LZXkgb2JqZWN0IHZpYSB0aGlzIG1ldGhvZC5cclxuICAgICogVGhlIEtleSBvYmplY3QgY2FuIHRoZW4gYmUgcG9sbGVkLCBoYXZlIGV2ZW50cyBhdHRhY2hlZCB0byBpdCwgZXRjLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5LZXlib2FyZCNhZGRLZXlcclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBrZXljb2RlIC0gVGhlIHtAbGluayBQaGFzZXIuS2V5Q29kZSBrZXljb2RlfSBvZiB0aGUga2V5LlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuS2V5fSBUaGUgS2V5IG9iamVjdCB3aGljaCB5b3UgY2FuIHN0b3JlIGxvY2FsbHkgYW5kIHJlZmVyZW5jZSBkaXJlY3RseS5cclxuICAgICovXHJcbiAgICBhZGRLZXk6IGZ1bmN0aW9uIChrZXlDb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xyXG5cclxuICAgICAgICBpZiAoIWtleXNba2V5Q29kZV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlzW2tleUNvZGVdID0gbmV3IEtleShrZXlDb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2RlXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ga2V5c1trZXlDb2RlXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgYSBLZXkgb2JqZWN0IGZyb20gdGhlIEtleWJvYXJkIG1hbmFnZXIuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI3JlbW92ZUtleVxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IGtleWNvZGUgLSBUaGUge0BsaW5rIFBoYXNlci5LZXlDb2RlIGtleWNvZGV9IG9mIHRoZSBrZXkgdG8gcmVtb3ZlLlxyXG4gICAgKi9cclxuICAgIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleUNvZGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1trZXlDb2RlXSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5c1trZXlDb2RlXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2RlXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkS2V5Q2FwdHVyZTogZnVuY3Rpb24gKGtleUNvZGVzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlDb2RlcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlDb2RlcyA9IFsga2V5Q29kZXMgXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Q29kZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVzW2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVLZXlDYXB0dXJlOiBmdW5jdGlvbiAoa2V5Q29kZXMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNvZGVzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleUNvZGVzID0gWyBrZXlDb2RlcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb2Rlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZXNba2V5Q29kZXNbaV1dID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVDb21ibzogZnVuY3Rpb24gKGtleXMsIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEtleUNvbWJvKHRoaXMsIGtleXMsIGNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9LZXlib2FyZEV2ZW50XHJcbiAgICAvLyAgdHlwZSA9ICdrZXlkb3duJywgJ2tleXVwJ1xyXG4gICAgLy8gIGtleUNvZGUgPSBpbnRlZ2VyXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnF1ZXVlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgbGVuID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENsZWFycyB0aGUgcXVldWUgYXJyYXksIGFuZCBhbHNvIG1lYW5zIHdlIGRvbid0IHdvcmsgb24gYXJyYXkgZGF0YSB0aGF0IGNvdWxkIHBvdGVudGlhbGx5XHJcbiAgICAgICAgLy8gIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBwaGFzZVxyXG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWUuc3BsaWNlKDAsIGxlbik7XHJcblxyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xyXG4gICAgICAgIHZhciBzaW5nbGVLZXk7XHJcblxyXG4gICAgICAgIC8vICBQcm9jZXNzIHRoZSBldmVudCBxdWV1ZSwgZGlzcGF0Y2hpbmcgYWxsIG9mIHRoZSBldmVudHMgdGhhdCBoYXZlIHN0b3JlZCB1cFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBxdWV1ZVtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LktFWV9ET1dOX0VWRU5UKGV2ZW50KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2luZ2xlS2V5ID0gRXZlbnQuX0RPV05bZXZlbnQua2V5Q29kZV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUtleSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLmRpc3BhdGNoKG5ldyBzaW5nbGVLZXkoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tldmVudC5rZXlDb2RlXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzS2V5RG93bihrZXlzW2V2ZW50LmtleUNvZGVdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5LRVlfVVBfRVZFTlQoZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVLZXkgPSBFdmVudC5fVVBbZXZlbnQua2V5Q29kZV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUtleSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLmRpc3BhdGNoKG5ldyBzaW5nbGVLZXkoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tldmVudC5rZXlDb2RlXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzS2V5VXAoa2V5c1tldmVudC5rZXlDb2RlXSwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgUmVzZXRLZXlDb21ibyA9IHJlcXVpcmUoJy4vUmVzZXRLZXlDb21ibycpO1xyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gcmVxdWlyZSgnLi9Qcm9jZXNzS2V5Q29tYm8nKTtcclxudmFyIEtleUNvbWJvTWF0Y2hFdmVudCA9IHJlcXVpcmUoJy4vS2V5Q29tYm9NYXRjaEV2ZW50Jyk7XHJcblxyXG4vLyAgS2V5cyBjYW4gYmUgZWl0aGVyOlxyXG4vL1xyXG4vLyAgQSBzdHJpbmcgKEFUQVJJKVxyXG4vLyAgQW4gYXJyYXkgb2YgZWl0aGVyIGludGVnZXJzIChrZXkgY29kZXMpIG9yIHN0cmluZ3MsIG9yIGEgbWl4dHVyZSBvZiBib3RoXHJcbi8vICBBbiBhcnJheSBvZiBvYmplY3RzIChzdWNoIGFzIEtleSBvYmplY3RzKSB3aXRoIGEgcHVibGljICdrZXlDb2RlJyBwcm9wZXJ0eVxyXG5cclxudmFyIEtleUNvbWJvID0gZnVuY3Rpb24gKGtleWJvYXJkTWFuYWdlciwga2V5cywgY29uZmlnKVxyXG57XHJcbiAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHsgY29uZmlnID0ge307IH1cclxuXHJcbiAgICAvLyAgQ2FuJ3QgaGF2ZSBhIHplcm8gb3Igc2luZ2xlIGxlbmd0aCBjb21ibyAoc3RyaW5nIG9yIGFycmF5IGJhc2VkKVxyXG4gICAgaWYgKGtleXMubGVuZ3RoIDwgMilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0ga2V5Ym9hcmRNYW5hZ2VyO1xyXG5cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5rZXlDb2RlcyA9IFtdO1xyXG5cclxuICAgIC8vICBpZiAna2V5cycgaXMgYSBzdHJpbmcgd2UgbmVlZCB0byBnZXQgdGhlIGtleWNvZGUgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gaXRcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoYXIgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNoYXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoYXIgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFyLmhhc093blByb3BlcnR5KCdrZXlDb2RlJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmtleUNvZGVzLnB1c2goY2hhci5rZXlDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoZSBjdXJyZW50IGtleUNvZGUgdGhlIGNvbWJvIGlzIHdhaXRpbmcgZm9yXHJcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmtleUNvZGVzWzBdO1xyXG5cclxuICAgIC8vICBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUga2V5IGJlaW5nIHdhaXRlZCBmb3IgaW4gdGhlICdrZXlzJyBzdHJpbmdcclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgIC8vICBUaGUgbGVuZ3RoIG9mIHRoaXMgY29tYm8gKGluIGtleWNvZGVzKVxyXG4gICAgdGhpcy5zaXplID0gdGhpcy5rZXlDb2Rlcy5sZW5ndGg7XHJcblxyXG4gICAgLy8gIFRoZSB0aW1lIHRoZSBwcmV2aW91cyBrZXkgaW4gdGhlIGNvbWJvIHdhcyBtYXRjaGVkXHJcbiAgICB0aGlzLnRpbWVMYXN0TWF0Y2hlZCA9IDA7XHJcblxyXG4gICAgLy8gIEhhcyB0aGlzIEtleSBDb21ibyBiZWVuIG1hdGNoZWQgeWV0P1xyXG4gICAgdGhpcy5tYXRjaGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIFRoZSB0aW1lIHRoZSBlbnRpcmUgY29tYm8gd2FzIG1hdGNoZWRcclxuICAgIHRoaXMudGltZU1hdGNoZWQgPSAwO1xyXG5cclxuICAgIC8vICBDdXN0b20gb3B0aW9ucyAuLi5cclxuXHJcbiAgICAvLyAgSWYgdGhleSBwcmVzcyB0aGUgd3Jvbmcga2V5IGRvIHdlIHJlc2V0IHRoZSBjb21ibz9cclxuICAgIHRoaXMucmVzZXRPbldyb25nS2V5ID0gR2V0VmFsdWUoY29uZmlnLCAncmVzZXRPbldyb25nS2V5JywgdHJ1ZSk7XHJcblxyXG4gICAgLy8gIFRoZSBtYXggZGVsYXkgaW4gbXMgYmV0d2VlbiBlYWNoIGtleSBwcmVzcy4gQWJvdmUgdGhpcyB0aGUgY29tYm8gaXMgcmVzZXQuIDAgbWVhbnMgZGlzYWJsZWQuXHJcbiAgICB0aGlzLm1heEtleURlbGF5ID0gR2V0VmFsdWUoY29uZmlnLCAnbWF4S2V5RGVsYXknLCAwKTtcclxuXHJcbiAgICAvLyAgSWYgcHJldmlvdXNseSBtYXRjaGVkIGFuZCB0aGV5IHByZXNzIEtleSAxIGFnYWluLCB3aWxsIGl0IHJlc2V0P1xyXG4gICAgdGhpcy5yZXNldE9uTWF0Y2ggPSBHZXRWYWx1ZShjb25maWcsICdyZXNldE9uTWF0Y2gnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIElmIHRoZSBjb21ibyBtYXRjaGVzLCB3aWxsIGl0IGRlbGV0ZSBpdHNlbGY/XHJcbiAgICB0aGlzLmRlbGV0ZU9uTWF0Y2ggPSBHZXRWYWx1ZShjb25maWcsICdkZWxldGVPbk1hdGNoJywgZmFsc2UpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdmFyIG9uS2V5RG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKF90aGlzLm1hdGNoZWQgfHwgIV90aGlzLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFByb2Nlc3NLZXlDb21ibyhldmVudC5kYXRhLCBfdGhpcyk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RoaXMubWFuYWdlci5ldmVudHMuZGlzcGF0Y2gobmV3IEtleUNvbWJvTWF0Y2hFdmVudChfdGhpcywgZXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNldE9uTWF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFJlc2V0S2V5Q29tYm8oX3RoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmRlbGV0ZU9uTWF0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5vbktleURvd24gPSBvbktleURvd25IYW5kbGVyO1xyXG5cclxuICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ0tFWV9ET1dOX0VWRU5UJywgb25LZXlEb3duSGFuZGxlcik7XHJcbn07XHJcblxyXG5LZXlDb21iby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlDb21ibztcclxuXHJcbktleUNvbWJvLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMua2V5Q29kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmV2ZW50cy5vZmYoJ0tFWV9ET1dOJywgdGhpcy5vbktleURvd24pO1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhLZXlDb21iby5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBwcm9ncmVzczoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICAvLyAgSG93IGZhciBjb21wbGV0ZSBpcyB0aGlzIGNvbWJvPyBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCAvIHRoaXMuc2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFkdmFuY2VLZXlDb21ibyA9IHJlcXVpcmUoJy4vQWR2YW5jZUtleUNvbWJvJyk7XHJcblxyXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcclxue1xyXG4gICAgaWYgKGNvbWJvLm1hdGNoZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbWJvTWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGtleU1hdGNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gY29tYm8uY3VycmVudClcclxuICAgIHtcclxuICAgICAgICAvLyAgS2V5IHdhcyBjb3JyZWN0XHJcblxyXG4gICAgICAgIGlmIChjb21iby5pbmRleCA+IDAgJiYgY29tYm8ubWF4S2V5RGVsYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWxheSBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vICB0aGUgbmV3IGtleSBhbmQgdGhlIG9sZCBvbmUgd2FzIHRvbyBsb25nIChpZiBlbmFibGVkKVxyXG5cclxuICAgICAgICAgICAgdmFyIHRpbWVMaW1pdCA9IGNvbWJvLnRpbWVMYXN0TWF0Y2hlZCArIGNvbWJvLm1heEtleURlbGF5O1xyXG5cclxuICAgICAgICAgICAgLy8gIENoZWNrIGlmIHRoZXkgcHJlc3NlZCBpdCBpbiB0aW1lIG9yIG5vdFxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGltZVN0YW1wIDw9IHRpbWVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5TWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb21ib01hdGNoZWQgPSBBZHZhbmNlS2V5Q29tYm8oZXZlbnQsIGNvbWJvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXlNYXRjaGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vICBXZSBkb24ndCBjaGVjayB0aGUgdGltZSBmb3IgdGhlIGZpcnN0IGtleSBwcmVzc2VkLCBzbyBqdXN0IGFkdmFuY2UgaXRcclxuICAgICAgICAgICAgY29tYm9NYXRjaGVkID0gQWR2YW5jZUtleUNvbWJvKGV2ZW50LCBjb21ibyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgha2V5TWF0Y2hlZCAmJiBjb21iby5yZXNldE9uV3JvbmdLZXkpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFdyb25nIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICAgIGNvbWJvLmluZGV4ID0gMDtcclxuICAgICAgICBjb21iby5jdXJyZW50ID0gY29tYm8ua2V5Q29kZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbWJvTWF0Y2hlZClcclxuICAgIHtcclxuICAgICAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICAgICAgY29tYm8ubWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgY29tYm8udGltZU1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbWJvTWF0Y2hlZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleUNvbWJvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2NvbWJvL1Byb2Nlc3NLZXlDb21iby5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBBIGdlbmVyaWMgS2V5IG9iamVjdCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBQcm9jZXNzIGZ1bmN0aW9ucyAoYW5kIHNvIG9uKVxyXG5cclxuLy8gIGtleWNvZGUgbXVzdCBiZSBhbiBpbnRlZ2VyXHJcblxyXG52YXIgS2V5ID0gZnVuY3Rpb24gKGtleUNvZGUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGtleUNvZGUgLSBUaGUga2V5Y29kZSBvZiB0aGlzIGtleS5cclxuICAgICovXHJcbiAgICB0aGlzLmtleUNvZGUgPSBrZXlDb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge0tleWJvYXJkRXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBwcmV2ZW50RGVmYXVsdCAtIFNob3VsZCB0aGlzIEtleSBwcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMucHJldmVudERlZmF1bHQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWQgLSBDYW4gdGhpcyBLZXkgYmUgcHJvY2Vzc2VkP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNEb3duIC0gVGhlIFwiZG93blwiIHN0YXRlIG9mIHRoZSBrZXkuIFRoaXMgd2lsbCByZW1haW4gYHRydWVgIGZvciBhcyBsb25nIGFzIHRoZSBrZXlib2FyZCB0aGlua3MgdGhpcyBrZXkgaXMgaGVsZCBkb3duLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNVcCAtIFRoZSBcInVwXCIgc3RhdGUgb2YgdGhlIGtleS4gVGhpcyB3aWxsIHJlbWFpbiBgdHJ1ZWAgZm9yIGFzIGxvbmcgYXMgdGhlIGtleWJvYXJkIHRoaW5rcyB0aGlzIGtleSBpcyB1cC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmlzVXAgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsdEtleSAtIFRoZSBkb3duIHN0YXRlIG9mIHRoZSBBTFQga2V5LCBpZiBwcmVzc2VkIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhpcyBrZXkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5hbHRLZXkgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjdHJsS2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIENUUkwga2V5LCBpZiBwcmVzc2VkIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhpcyBrZXkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdHJsS2V5ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hpZnRLZXkgLSBUaGUgZG93biBzdGF0ZSBvZiB0aGUgU0hJRlQga2V5LCBpZiBwcmVzc2VkIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhpcyBrZXkuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIG9mIHRoZSBtb2RpZmllciBrZXkuIDAgZm9yIHN0YW5kYXJkIChvciB1bmtub3duKSwgMSBmb3IgbGVmdCwgMiBmb3IgcmlnaHQsIDMgZm9yIG51bXBhZC5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLmxvY2F0aW9uID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVEb3duIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBrZXkgd2FzIGxhc3QgcHJlc3NlZCBkb3duLiBUaGlzIGlzIGJhc2VkIG9uIEdhbWUudGltZS5ub3cuXHJcbiAgICAqL1xyXG4gICAgdGhpcy50aW1lRG93biA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIElmIHRoZSBrZXkgaXMgZG93biB0aGlzIHZhbHVlIGhvbGRzIHRoZSBkdXJhdGlvbiBvZiB0aGF0IGtleSBwcmVzcyBhbmQgaXMgY29uc3RhbnRseSB1cGRhdGVkLlxyXG4gICAgKiBJZiB0aGUga2V5IGlzIHVwIGl0IGhvbGRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgcHJldmlvdXMgZG93biBzZXNzaW9uLlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb24gLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGlzIGtleSBoYXMgYmVlbiBoZWxkIGRvd24gZm9yLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZVVwIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBrZXkgd2FzIGxhc3QgcmVsZWFzZWQuIFRoaXMgaXMgYmFzZWQgb24gR2FtZS50aW1lLm5vdy5cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnRpbWVVcCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBlYXRzIC0gSWYgYSBrZXkgaXMgaGVsZCBkb3duIHRoaXMgaG9sZHMgZG93biB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgaGFzICdyZXBlYXRlZCcuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZXBlYXRzID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gX2p1c3REb3duIC0gVHJ1ZSBpZiB0aGUga2V5IGhhcyBqdXN0IGJlZW4gcHJlc3NlZCAoTk9URTogcmVxdWlyZXMgdG8gYmUgcmVzZXQsIHNlZSBqdXN0RG93biBnZXR0ZXIpXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9qdXN0RG93biA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBfanVzdFVwIC0gVHJ1ZSBpZiB0aGUga2V5IGhhcyBqdXN0IGJlZW4gcHJlc3NlZCAoTk9URTogcmVxdWlyZXMgdG8gYmUgcmVzZXQsIHNlZSBqdXN0RG93biBnZXR0ZXIpXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9qdXN0VXAgPSBmYWxzZTtcclxufTtcclxuXHJcbktleS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9rZXlzL0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudFxyXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcclxuXHJcbnZhciBNb3VzZU1hbmFnZXIgPSBmdW5jdGlvbiAoaW5wdXRNYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBpbnB1dE1hbmFnZXI7XHJcblxyXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgdGhpcy5oYW5kbGVyO1xyXG59O1xyXG5cclxuTW91c2VNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlTWFuYWdlcjtcclxuXHJcbk1vdXNlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tYW5hZ2VyLmdhbWVDb25maWc7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGNvbmZpZy5pbnB1dE1vdXNlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gY29uZmlnLmlucHV0TW91c2VFdmVudFRhcmdldDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5tYW5hZ2VyLmdhbWUuY2FudmFzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0TGlzdGVuZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMubWFuYWdlci5xdWV1ZTtcclxuXHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBldmVudCBhbHJlYWR5IGhhbmRsZWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcXVldWUucHVzaChldmVudCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wTGlzdGVuZXJzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVyKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVyKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL01vdXNlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcclxuXHJcbi8vICBUYWtlcyB0d28gWEhSIE9iamVjdHMgYW5kIGNyZWF0ZXMgYSBuZXcgb2JqZWN0XHJcblxyXG4vLyAgVGhlIG5ldyBvYmplY3QgaXMgYmFzZWQgb24gZ2xvYmFsIGluaXRpYWxseSwgYnV0IGFueSBzZXR0aW5nIGluXHJcbi8vICBsb2NhbCBvdmVycmlkZXMgdGhlIGdsb2JhbCB2YWx1ZS5cclxuXHJcbnZhciBNZXJnZVhIUlNldHRpbmdzID0gZnVuY3Rpb24gKGdsb2JhbCwgbG9jYWwpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSAoZ2xvYmFsID09PSB1bmRlZmluZWQpID8gWEhSU2V0dGluZ3MoKSA6IE9iamVjdC5hc3NpZ24oZ2xvYmFsKTtcclxuXHJcbiAgICBpZiAobG9jYWwpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgc2V0dGluZyBpbiBsb2NhbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbFtzZXR0aW5nXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRbc2V0dGluZ10gPSBsb2NhbFtzZXR0aW5nXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG52YXIgUGFyc2VYTUwgPSByZXF1aXJlKCcuLi8uLi9kb20vUGFyc2VYTUwnKTtcclxuXHJcbnZhciBYTUxGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnhtbFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXVybClcclxuICAgIHtcclxuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy54bWwnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICd4bWwnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5YTUxGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhNTEZpbGU7XHJcblxyXG5YTUxGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gUGFyc2VYTUwodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWE1MRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gcmVxdWlyZSgnLi9GYWN0b3JpYWwnKTtcclxuXHJcbnZhciBCZXJuc3RlaW4gPSBmdW5jdGlvbiAobiwgaSlcclxue1xyXG4gICAgcmV0dXJuIEZhY3RvcmlhbChuKSAvIEZhY3RvcmlhbChpKSAvIEZhY3RvcmlhbChuIC0gaSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJlcm5zdGVpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0Jlcm5zdGVpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYXRtdWxsUm9tID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KVxyXG57XHJcbiAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjUsIHYxID0gKHAzIC0gcDEpICogMC41LCB0MiA9IHQgKiB0LCB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhdG11bGxSb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9DYXRtdWxsUm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZhY3RvcmlhbCA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXMgPSB2YWx1ZTtcclxuXHJcbiAgICB3aGlsZSAoLS12YWx1ZSlcclxuICAgIHtcclxuICAgICAgICByZXMgKj0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yaWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvRmFjdG9yaWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmVhciA9IGZ1bmN0aW9uIChwMCwgcDEsIHQpXHJcbntcclxuICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0xpbmVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZEF3YXlGcm9tWmVybyA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgLy8gXCJPcHBvc2l0ZVwiIG9mIHRydW5jYXRlLlxyXG4gICAgcmV0dXJuICh2YWx1ZSA+IDApID8gTWF0aC5jZWlsKHZhbHVlKSA6IE1hdGguZmxvb3IodmFsdWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3VuZEF3YXlGcm9tWmVybztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aFN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXHJcbntcclxuICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIG1pbikgLyAobWF4IC0gbWluKSkpO1xyXG5cclxuICAgIHJldHVybiB4ICogeCAqICgzIC0gMiAqIHgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvU21vb3RoU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhlclN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXHJcbntcclxuICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIG1pbikgLyAobWF4IC0gbWluKSkpO1xyXG5cclxuICAgIHJldHVybiB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoZXJTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChhbmdsZSlcclxue1xyXG4gICAgYW5nbGUgPSBhbmdsZSAlICgyICogTWF0aC5QSSk7XHJcblxyXG4gICAgaWYgKGFuZ2xlID49IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhbmdsZSArIDIgKiBNYXRoLlBJO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWF0aFdyYXAgPSByZXF1aXJlKCcuLi9XcmFwJyk7XHJcblxyXG52YXIgV3JhcCA9IGZ1bmN0aW9uIChhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGhXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9XcmFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdyYXAgPSByZXF1aXJlKCcuLi9XcmFwJyk7XHJcblxyXG52YXIgV3JhcERlZ3JlZXMgPSBmdW5jdGlvbiAoYW5nbGUpXHJcbntcclxuICAgIHJldHVybiBXcmFwKGFuZ2xlLCAtMTgwLCAxODApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcmFwRGVncmVlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICByZXR1cm4gdiAqIHYgKiAoKG92ZXJzaG9vdCArIDEpICogdiAtIG92ZXJzaG9vdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodiwgb3ZlcnNob290KVxyXG57XHJcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxyXG5cclxuICAgIHJldHVybiAtLXYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgKyBvdmVyc2hvb3QpICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYsIG92ZXJzaG9vdClcclxue1xyXG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cclxuXHJcbiAgICB2YXIgcyA9IG92ZXJzaG9vdCAqIDEuNTI1O1xyXG5cclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICh2ICogdiAqICgocyArIDEpICogdiAtIHMpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqICgocyArIDEpICogdiArIHMpICsgMik7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL0JhY2suanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgdiA9IDEgLSB2O1xyXG5cclxuICAgIGlmICh2IDwgMSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogdiAqIHYpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogKHYgLT0gMi4yNSAvIDIuNzUpICogdiArIDAuOTM3NSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gNy41NjI1ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMi4yNSAvIDIuNzUpICogdiArIDAuOTM3NTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIHZhciByZXZlcnNlID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHYgPCAwLjUpXHJcbiAgICB7XHJcbiAgICAgICAgdiA9IDEgLSAodiAqIDIpO1xyXG4gICAgICAgIHJldmVyc2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHYgPSAodiAqIDIpIC0gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSA3LjU2MjUgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcclxuICAgIHtcclxuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxyXG4gICAge1xyXG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXZlcnNlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoMSAtIHYpICogMC41O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2ICogMC41ICsgMC41O1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9Cb3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHYgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gT3V0ICh2KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS12ICogdikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHYgKiB2KSAtIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodiAtPSAyKSAqIHYpICsgMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEluOiBJbixcclxuICAgIE91dDogT3V0LFxyXG4gICAgSW5PdXQ6IEluT3V0XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXHJcbntcclxuICAgIHJldHVybiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdjtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvQ3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXHJcbntcclxuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cclxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cclxuXHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xyXG5cclxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIC0oYW1wbGl0dWRlICogTWF0aC5wb3coMiwgMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxyXG57XHJcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XHJcbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XHJcblxyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogdikgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkgKyAxKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxyXG57XHJcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XHJcbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XHJcblxyXG4gICAgaWYgKHYgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkgKiAwLjUgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvRWxhc3RpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodiAtIDEpKSAtIDAuMDAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogdik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluT3V0ICh2KVxyXG57XHJcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqICh2IC0gMSkpKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvRXhwby5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIExpbmVhciBFYXNpbmcgKG5vIHZhcmlhdGlvbikuXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkVhc2luZy5MaW5lYXIjTm9uZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSB2IC0gVGhlIHZhbHVlIHRvIGJlIHR3ZWVuZWQuXHJcbiogQHJldHVybnMge251bWJlcn0gdi5cclxuKi9cclxudmFyIExpbmVhciA9IGZ1bmN0aW9uICh2KVxyXG57XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZWFzaW5nL0xpbmVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiAoMiAtIHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS12ICogKHYgLSAyKSAtIDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9RdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcclxue1xyXG4gICAgcmV0dXJuIHYgKiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIDEgLSAoLS12ICogdiAqIHYgKiB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICgodiAqPSAyKSA8IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoKHYgLT0gMikgKiB2ICogdiAqIHYgLSAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdiAqIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE91dCAodilcclxue1xyXG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICogdiAqIHYgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbk91dCAodilcclxue1xyXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdiAqIHY7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAqIHYgKyAyKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW46IEluLFxyXG4gICAgT3V0OiBPdXQsXHJcbiAgICBJbk91dDogSW5PdXRcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvUXVpbnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxyXG57XHJcbiAgICBpZiAodiA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHYgPT09IDEpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh2ICogTWF0aC5QSSAvIDIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBPdXQgKHYpXHJcbntcclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4odiAqIE1hdGguUEkgLyAyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSW5PdXQgKHYpXHJcbntcclxuICAgIGlmICh2ID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodiA9PT0gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogdikpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbjogSW4sXHJcbiAgICBPdXQ6IE91dCxcclxuICAgIEluT3V0OiBJbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9TaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmVhciA9IHJlcXVpcmUoJy4uL0xpbmVhcicpO1xyXG5cclxudmFyIExpbmVhckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcclxue1xyXG4gICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgZiA9IG0gKiBrO1xyXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xyXG5cclxuICAgIGlmIChrIDwgMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTGluZWFyKHZbMF0sIHZbMV0sIGYpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrID4gMSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gTGluZWFyKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIExpbmVhcih2W2ldLCB2WyhpICsgMSA+IG0pID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJJbnRlcnBvbGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkaW1lbnNpb25zIG1ha2UgYSBwb3dlciBvZiB0d28gdGV4dHVyZS5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI2lzUG93ZXJPZlR3b1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byBjaGVjay5cclxuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBjaGVjay5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIHR3by5cclxuKi9cclxudmFyIElzU2l6ZVBvd2VyT2ZUd28gPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgcmV0dXJuICh3aWR0aCA+IDAgJiYgKHdpZHRoICYgKHdpZHRoIC0gMSkpID09PSAwICYmIGhlaWdodCA+IDAgJiYgKGhlaWdodCAmIChoZWlnaHQgLSAxKSkgPT09IDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc1NpemVQb3dlck9mVHdvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5QaHlzaWNzLkltcGFjdC5Cb2R5XHJcblxyXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xyXG52YXIgR2V0VmVsb2NpdHkgPSByZXF1aXJlKCcuL0dldFZlbG9jaXR5Jyk7XHJcbnZhciBVcGRhdGVNb3Rpb24gPSByZXF1aXJlKCcuL1VwZGF0ZU1vdGlvbicpO1xyXG52YXIgQ09MTElERVMgPSByZXF1aXJlKCcuL0NPTExJREVTJyk7XHJcbnZhciBUWVBFID0gcmVxdWlyZSgnLi9UWVBFJyk7XHJcblxyXG4vKipcclxuKiBBbiBJbXBhY3QuanMgY29tcGF0aWJsZSBwaHlzaWNzIGJvZHkuXHJcbiogVGhpcyByZS1jcmVhdGVzIHRoZSBwcm9wZXJ0aWVzIHlvdSdkIGdldCBvbiBhbiBFbnRpdHkgYW5kIHRoZSBtYXRoIG5lZWRlZCB0byB1cGRhdGUgdGhlbS5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG5cclxudmFyIEJvZHkgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQm9keSAod29ybGQsIHgsIHksIHN4LCBzeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoc3ggPT09IHVuZGVmaW5lZCkgeyBzeCA9IDE2OyB9XHJcbiAgICAgICAgaWYgKHN5ID09PSB1bmRlZmluZWQpIHsgc3kgPSAxNjsgfVxyXG5cclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHsgeDogc3gsIHk6IHN5IH07XHJcbiAgICAgICAgdGhpcy5wb3MgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLmxhc3QgPSB7IHg6IHgsIHk6IHkgfTtcclxuICAgICAgICB0aGlzLnZlbCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHRoaXMuYWNjZWwgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLmZyaWN0aW9uID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSB7IHg6IDEwMCwgeTogMTAwIH07XHJcbiAgICAgICAgdGhpcy5ncmF2aXR5RmFjdG9yID0gMTtcclxuICAgICAgICB0aGlzLnN0YW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ib3VuY2luZXNzID0gMDtcclxuICAgICAgICB0aGlzLm1pbkJvdW5jZVZlbG9jaXR5ID0gNDA7XHJcblxyXG4gICAgICAgIHRoaXMuYWNjZWxHcm91bmQgPSAwO1xyXG4gICAgICAgIHRoaXMuYWNjZWxBaXIgPSAwO1xyXG4gICAgICAgIHRoaXMuanVtcFNwZWVkID0gMDtcclxuICAgIFxyXG4gICAgICAgIHRoaXMudHlwZSA9IFRZUEUuTk9ORTtcclxuICAgICAgICB0aGlzLmNoZWNrQWdhaW5zdCA9IFRZUEUuTk9ORTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVzID0gQ09MTElERVMuTkVWRVI7XHJcbiAgICBcclxuICAgICAgICAvLyAgbWluIDQ0IGRlZywgbWF4IDEzNiBkZWdcclxuICAgICAgICB0aGlzLnNsb3BlU3RhbmRpbmcgPSB7IG1pbjogMC43Njc5NDQ4NzA4Nzc1MDUsIG1heDogMi4zNzM2NDc3ODI3MTIyODg0IH07XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUT0RPXHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubGFzdC54ID0gdGhpcy5wb3MueDtcclxuICAgICAgICB0aGlzLmxhc3QueSA9IHRoaXMucG9zLnk7XHJcblxyXG4gICAgICAgIHRoaXMudmVsLnkgKz0gdGhpcy53b3JsZC5ncmF2aXR5ICogZGVsdGEgKiB0aGlzLmdyYXZpdHlGYWN0b3I7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52ZWwueCA9IEdldFZlbG9jaXR5KGRlbHRhLCB0aGlzLnZlbC54LCB0aGlzLmFjY2VsLngsIHRoaXMuZnJpY3Rpb24ueCwgdGhpcy5tYXhWZWwueCk7XHJcbiAgICAgICAgdGhpcy52ZWwueSA9IEdldFZlbG9jaXR5KGRlbHRhLCB0aGlzLnZlbC55LCB0aGlzLmFjY2VsLnksIHRoaXMuZnJpY3Rpb24ueSwgdGhpcy5tYXhWZWwueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHdpbmRvdy5kdW1waXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVUERBVEU6IHBvcycsIHRoaXMucG9zLngsIHRoaXMucG9zLnksICd2ZWwnLCB0aGlzLnZlbC54LCB0aGlzLnZlbC55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBteCA9IHRoaXMudmVsLnggKiBkZWx0YTtcclxuICAgICAgICB2YXIgbXkgPSB0aGlzLnZlbC55ICogZGVsdGE7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLndvcmxkLmNvbGxpc2lvbk1hcC50cmFjZSh0aGlzLnBvcy54LCB0aGlzLnBvcy55LCBteCwgbXksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XHJcblxyXG4gICAgICAgIFVwZGF0ZU1vdGlvbih0aGlzLCByZXMpO1xyXG5cclxuICAgICAgICBpZiAod2luZG93LmR1bXBpdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFTkQgcmVzJywgcmVzLnBvcy54LCByZXMucG9zLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2tpcEhhc2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5lbmFibGVkIHx8ICh0aGlzLnR5cGUgPT09IDAgJiYgdGhpcy5jaGVja0FnYWluc3QgPT09IDAgJiYgdGhpcy5jb2xsaWRlcyA9PT0gMCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b3VjaGVzOiBmdW5jdGlvbiAob3RoZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICEoXHJcbiAgICAgICAgICAgIHRoaXMucG9zLnggPj0gb3RoZXIucG9zLnggKyBvdGhlci5zaXplLnggfHxcclxuICAgICAgICAgICAgdGhpcy5wb3MueCArIHRoaXMuc2l6ZS54IDw9IG90aGVyLnBvcy54IHx8XHJcbiAgICAgICAgICAgIHRoaXMucG9zLnkgPj0gb3RoZXIucG9zLnkgKyBvdGhlci5zaXplLnkgfHxcclxuICAgICAgICAgICAgdGhpcy5wb3MueSArIHRoaXMuc2l6ZS55IDw9IG90aGVyLnBvcy55XHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Qm91bmNlOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ib3VuY2luZXNzID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWZWxvY2l0eVg6IGZ1bmN0aW9uICh4KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmVsLnggPSB4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VmVsb2NpdHlZOiBmdW5jdGlvbiAoeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZlbC55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFZlbG9jaXR5OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnZlbC54ID0geDtcclxuICAgICAgICB0aGlzLnZlbC55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE1heFZlbG9jaXR5OiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMubWF4VmVsLnggPSB4O1xyXG4gICAgICAgIHRoaXMubWF4VmVsLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWNjZWxlcmF0aW9uWDogZnVuY3Rpb24gKHgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY2NlbC54ID0geDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFjY2VsZXJhdGlvblk6IGZ1bmN0aW9uICh5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWNjZWwueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBY2NlbGVyYXRpb246IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWNjZWwueCA9IHg7XHJcbiAgICAgICAgdGhpcy5hY2NlbC55ID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFR5cGVOb25lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFRZUEUuTk9ORTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFR5cGVBOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFRZUEUuQTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFR5cGVCOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFRZUEUuQjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENoZWNrQWdhaW5zdE5vbmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FnYWluc3QgPSBUWVBFLk5PTkU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRDaGVja0FnYWluc3RBOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2hlY2tBZ2FpbnN0ID0gVFlQRS5BO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Q2hlY2tBZ2FpbnN0QjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNoZWNrQWdhaW5zdCA9IFRZUEUuQjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldENvbGxpZGVzTmV2ZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlcyA9IENPTExJREVTLk5FVkVSO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TGl0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNvbGxpZGVzID0gQ09MTElERVMuTElURTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFBhc3NpdmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlcyA9IENPTExJREVTLlBBU1NJVkU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBY3RpdmU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlcyA9IENPTExJREVTLkFDVElWRTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZpeGVkOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXMgPSBDT0xMSURFUy5GSVhFRDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrOiBmdW5jdGlvbiAob3RoZXIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE92ZXJyaWRkZW4gYnkgdXNlciBjb2RlXHJcbiAgICB9LFxyXG5cclxuICAgIGNvbGxpZGVXaXRoOiBmdW5jdGlvbiAob3RoZXIsIGF4aXMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE92ZXJyaWRkZW4gYnkgdXNlciBjb2RlXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9Cb2R5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5QaHlzaWNzLkltcGFjdC5Db2xsaXNpb25NYXBcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBEZWZhdWx0RGVmcyA9IHJlcXVpcmUoJy4vRGVmYXVsdERlZnMnKTtcclxuXHJcbnZhciBDb2xsaXNpb25NYXAgPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQ29sbGlzaW9uTWFwICh0aWxlc2l6ZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnRpbGVzaXplID0gdGlsZXNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSAoQXJyYXkuaXNBcnJheShkYXRhKSkgPyBkYXRhWzBdLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAoQXJyYXkuaXNBcnJheShkYXRhKSkgPyBkYXRhLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFNsb3BlID0gNTU7XHJcblxyXG4gICAgICAgIHRoaXMudGlsZWRlZiA9IERlZmF1bHREZWZzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFjZTogZnVuY3Rpb24gKHgsIHksIHZ4LCB2eSwgb2JqZWN0V2lkdGgsIG9iamVjdEhlaWdodClcclxuICAgIHtcclxuICAgICAgICAvLyBTZXQgdXAgdGhlIHRyYWNlLXJlc3VsdFxyXG4gICAgICAgIHZhciByZXMgPSB7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbjogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHNsb3BlOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICBwb3M6IHsgeDogeCwgeTogeSB9LFxyXG4gICAgICAgICAgICB0aWxlOiB7IHg6IDAsIHk6IDAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzLnBvcy54ICs9IHZ4O1xyXG4gICAgICAgICAgICByZXMucG9zLnkgKz0gdnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RlcHMgPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5hYnModngpLCBNYXRoLmFicyh2eSkpIC8gdGhpcy50aWxlc2l6ZSk7XHJcblxyXG4gICAgICAgIGlmIChzdGVwcyA+IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3ggPSB2eCAvIHN0ZXBzO1xyXG4gICAgICAgICAgICB2YXIgc3kgPSB2eSAvIHN0ZXBzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwcyAmJiAoc3ggfHwgc3kpOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcChyZXMsIHgsIHksIHN4LCBzeSwgb2JqZWN0V2lkdGgsIG9iamVjdEhlaWdodCwgdngsIHZ5LCBpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgeCA9IHJlcy5wb3MueDtcclxuICAgICAgICAgICAgICAgIHkgPSByZXMucG9zLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5jb2xsaXNpb24ueClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdnggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXMuY29sbGlzaW9uLnkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZ5ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLmNvbGxpc2lvbi5zbG9wZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXAocmVzLCB4LCB5LCB2eCwgdnksIG9iamVjdFdpZHRoLCBvYmplY3RIZWlnaHQsIHZ4LCB2eSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uIChyZXMsIHgsIHksIHZ4LCB2eSwgd2lkdGgsIGhlaWdodCwgcnZ4LCBydnksIHN0ZXApXHJcbiAgICB7XHJcbiAgICAgICAgcmVzLnBvcy54ICs9IHZ4O1xyXG4gICAgICAgIHJlcy5wb3MueSArPSB2eTtcclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5kdW1waXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU1RFUCcsIHJlcy5wb3MueCwgcmVzLnBvcy55LCAnVlgnLCB2eCwgJ1ZZJywgdnksICdzdGVwJywgc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0ID0gMDtcclxuICAgICAgICB2YXIgdGlsZXNpemUgPSB0aGlzLnRpbGVzaXplO1xyXG4gICAgICAgIHZhciBtYXBXaWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdmFyIG1hcEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBIb3Jpem9udGFsXHJcbiAgICAgICAgaWYgKHZ4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHB4T2Zmc2V0WCA9ICh2eCA+IDAgPyB3aWR0aCA6IDApO1xyXG4gICAgICAgICAgICB2YXIgdGlsZU9mZnNldFggPSAodnggPCAwID8gdGlsZXNpemUgOiAwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBmaXJzdFRpbGVZID0gTWF0aC5tYXgoTWF0aC5mbG9vcih5IC8gdGlsZXNpemUpLCAwKTtcclxuICAgICAgICAgICAgdmFyIGxhc3RUaWxlWSA9IE1hdGgubWluKE1hdGguY2VpbCgoeSArIGhlaWdodCkgLyB0aWxlc2l6ZSksIG1hcEhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlWCA9IE1hdGguZmxvb3IoKHJlcy5wb3MueCArIHB4T2Zmc2V0WCkgLyB0aWxlc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJldlRpbGVYID0gTWF0aC5mbG9vcigoeCArIHB4T2Zmc2V0WCkgLyB0aWxlc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RlcCA+IDAgfHwgdGlsZVggPT09IHByZXZUaWxlWCB8fCBwcmV2VGlsZVggPCAwIHx8IHByZXZUaWxlWCA+PSBtYXBXaWR0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJldlRpbGVYID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZGVidWdzbG9wZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoJ1ZYJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHhPZmZzZXRYJywgcHhPZmZzZXRYKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxlT2Zmc2V0WCcsIHRpbGVPZmZzZXRYKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaXJzdFRpbGVZJywgZmlyc3RUaWxlWSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbGFzdFRpbGVZJywgbGFzdFRpbGVZKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxlWCcsIHRpbGVYKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcmV2VGlsZVgnLCBwcmV2VGlsZVgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGlsZVggPj0gMCAmJiB0aWxlWCA8IG1hcFdpZHRoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWDonLCB0aWxlWCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGlsZVkgPSBmaXJzdFRpbGVZOyB0aWxlWSA8IGxhc3RUaWxlWTsgdGlsZVkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWTonLCB0aWxlWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VGlsZVggIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuZGF0YVt0aWxlWV1bcHJldlRpbGVYXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0MScsIHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiAxICYmIHQgPD0gdGhpcy5sYXN0U2xvcGUgJiYgdGhpcy5jaGVja0RlZihyZXMsIHQsIHgsIHksIHJ2eCwgcnZ5LCB3aWR0aCwgaGVpZ2h0LCBwcmV2VGlsZVgsIHRpbGVZKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3QxIGJyZWFrJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5kYXRhW3RpbGVZXVt0aWxlWF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmRlYnVnc2xvcGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGlsZSBhdCcsIHRpbGVYLCAneCcsIHRpbGVZLCAnPScsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSAxIHx8IHQgPiB0aGlzLmxhc3RTbG9wZSB8fCAodCA+IDEgJiYgdGhpcy5jaGVja0RlZihyZXMsIHQsIHgsIHksIHJ2eCwgcnZ5LCB3aWR0aCwgaGVpZ2h0LCB0aWxlWCwgdGlsZVkpKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID4gMSAmJiB0IDw9IHRoaXMubGFzdFNsb3BlICYmIHJlcy5jb2xsaXNpb24uc2xvcGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0MiBicmVhaycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5jb2xsaXNpb24ueCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy50aWxlLnggPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9zLnggPSAodGlsZVggKiB0aWxlc2l6ZSkgLSBweE9mZnNldFggKyB0aWxlT2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJlcy5wb3MueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnZ4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZGVidWdzbG9wZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4gSGl0IHNvbGlkIHRpbGUgPDw8Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGVYJywgdGlsZVgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzaXplJywgdGlsZXNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3B4T2Zmc2V0WCcsIHB4T2Zmc2V0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGlsZU9mZnNldFgnLCB0aWxlT2Zmc2V0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPScsIHJlcy5wb3MueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICA5ICogMzIgPSAyODhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIC0gMTYgPSAyNzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICsgMCA9IDI3MlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFdoZXJlIGRvZXMgdGhlIDE2IGNvbWUgZnJvbT9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5kZWJ1Z3Nsb3BlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBWZXJ0aWNhbFxyXG4gICAgICAgIGlmICh2eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBweE9mZnNldFkgPSAodnkgPiAwID8gaGVpZ2h0IDogMCk7XHJcbiAgICAgICAgICAgIHZhciB0aWxlT2Zmc2V0WSA9ICh2eSA8IDAgPyB0aWxlc2l6ZSA6IDApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGZpcnN0VGlsZVggPSBNYXRoLm1heChNYXRoLmZsb29yKHJlcy5wb3MueCAvIHRpbGVzaXplKSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBsYXN0VGlsZVggPSBNYXRoLm1pbihNYXRoLmNlaWwoKHJlcy5wb3MueCArIHdpZHRoKSAvIHRpbGVzaXplKSwgbWFwV2lkdGgpO1xyXG4gICAgICAgICAgICB2YXIgdGlsZVkgPSBNYXRoLmZsb29yKChyZXMucG9zLnkgKyBweE9mZnNldFkpIC8gdGlsZXNpemUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHByZXZUaWxlWSA9IE1hdGguZmxvb3IoKHkgKyBweE9mZnNldFkpIC8gdGlsZXNpemUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0ZXAgPiAwIHx8IHRpbGVZID09PSBwcmV2VGlsZVkgfHwgcHJldlRpbGVZIDwgMCB8fCBwcmV2VGlsZVkgPj0gbWFwSGVpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGlsZVkgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRpbGVZID49IDAgJiYgdGlsZVkgPCBtYXBIZWlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRpbGVYID0gZmlyc3RUaWxlWDsgdGlsZVggPCBsYXN0VGlsZVg7IHRpbGVYKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZUaWxlWSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5kYXRhW3ByZXZUaWxlWV1bdGlsZVhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiAxICYmIHQgPD0gdGhpcy5sYXN0U2xvcGUgJiYgdGhpcy5jaGVja0RlZihyZXMsIHQsIHgsIHksIHJ2eCwgcnZ5LCB3aWR0aCwgaGVpZ2h0LCB0aWxlWCwgcHJldlRpbGVZKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRoaXMuZGF0YVt0aWxlWV1bdGlsZVhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gMSB8fCB0ID4gdGhpcy5sYXN0U2xvcGUgfHwgKHQgPiAxICYmIHRoaXMuY2hlY2tEZWYocmVzLCB0LCB4LCB5LCBydngsIHJ2eSwgd2lkdGgsIGhlaWdodCwgdGlsZVgsIHRpbGVZKSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEgJiYgdCA8PSB0aGlzLmxhc3RTbG9wZSAmJiByZXMuY29sbGlzaW9uLnNsb3BlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmNvbGxpc2lvbi55ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnRpbGUueSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wb3MueSA9IHRpbGVZICogdGlsZXNpemUgLSBweE9mZnNldFkgKyB0aWxlT2Zmc2V0WTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNoZWNrRGVmOiBmdW5jdGlvbiAocmVzLCB0LCB4LCB5LCB2eCwgdnksIHdpZHRoLCBoZWlnaHQsIHRpbGVYLCB0aWxlWSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZGVmID0gdGhpcy50aWxlZGVmW3RdO1xyXG5cclxuICAgICAgICBpZiAoIWRlZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0aWxlc2l6ZSA9IHRoaXMudGlsZXNpemU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGx4ID0gKHRpbGVYICsgZGVmWzBdKSAqIHRpbGVzaXplO1xyXG4gICAgICAgIHZhciBseSA9ICh0aWxlWSArIGRlZlsxXSkgKiB0aWxlc2l6ZTtcclxuICAgICAgICB2YXIgbHZ4ID0gKGRlZlsyXSAtIGRlZlswXSkgKiB0aWxlc2l6ZTtcclxuICAgICAgICB2YXIgbHZ5ID0gKGRlZlszXSAtIGRlZlsxXSkgKiB0aWxlc2l6ZTtcclxuICAgICAgICB2YXIgc29saWQgPSBkZWZbNF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHR4ID0geCArIHZ4ICsgKGx2eSA8IDAgPyB3aWR0aCA6IDApIC0gbHg7XHJcbiAgICAgICAgdmFyIHR5ID0geSArIHZ5ICsgKGx2eCA+IDAgPyBoZWlnaHQgOiAwKSAtIGx5O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsdnggKiB0eSAtIGx2eSAqIHR4ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2eCAqIC1sdnkgKyB2eSAqIGx2eCA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb2xpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChsdnggKiBsdnggKyBsdnkgKiBsdnkpO1xyXG4gICAgICAgICAgICB2YXIgbnggPSBsdnkgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBueSA9IC1sdnggLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcHJvaiA9IHR4ICogbnggKyB0eSAqIG55O1xyXG4gICAgICAgICAgICB2YXIgcHggPSBueCAqIHByb2o7XHJcbiAgICAgICAgICAgIHZhciBweSA9IG55ICogcHJvajtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChweCAqIHB4ICsgcHkgKiBweSA+PSB2eCAqIHZ4ICsgdnkgKiB2eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbGlkIHx8IChsdnggKiAodHkgLSB2eSkgLSBsdnkgKiAodHggLSB2eCkgPCAwLjUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXMucG9zLnggPSB4ICsgdnggLSBweDtcclxuICAgICAgICAgICAgcmVzLnBvcy55ID0geSArIHZ5IC0gcHk7XHJcbiAgICAgICAgICAgIHJlcy5jb2xsaXNpb24uc2xvcGUgPSB7IHg6IGx2eCwgeTogbHZ5LCBueDogbngsIG55OiBueSB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25NYXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbXBhY3QvQ29sbGlzaW9uTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuV29ybGRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHRoZSB3b3JsZCBjb21wb3NpdGUuXHJcbiogQSBgTWF0dGVyLldvcmxkYCBpcyBhIGBNYXR0ZXIuQ29tcG9zaXRlYCBib2R5LCB3aGljaCBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLlxyXG4qIEEgYE1hdHRlci5Xb3JsZGAgaGFzIGEgZmV3IGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRpbmcgYGdyYXZpdHlgIGFuZCBgYm91bmRzYC5cclxuKiBJdCBpcyBpbXBvcnRhbnQgdG8gdXNlIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGBNYXR0ZXIuQ29tcG9zaXRlYCBtb2R1bGUgdG8gbW9kaWZ5IHRoZSB3b3JsZCBjb21wb3NpdGUsIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyBpdHMgcHJvcGVydGllcy5cclxuKiBUaGVyZSBhcmUgYWxzbyBhIGZldyBtZXRob2RzIGhlcmUgdGhhdCBhbGlhcyB0aG9zZSBpbiBgTWF0dGVyLkNvbXBvc2l0ZWAgZm9yIGVhc2llciByZWFkYWJpbGl0eS5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgV29ybGRcclxuKiBAZXh0ZW5kcyBDb21wb3NpdGVcclxuKi9cclxuXHJcbnZhciBXb3JsZCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcclxuXHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuL0NvbXBvc2l0ZScpO1xyXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgd29ybGQgY29tcG9zaXRlLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7d29ybGR9IEEgbmV3IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY29tcG9zaXRlID0gQ29tcG9zaXRlLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnV29ybGQnLFxyXG4gICAgICAgICAgICBncmF2aXR5OiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMSxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLjAwMVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib3VuZHM6IHsgXHJcbiAgICAgICAgICAgICAgICBtaW46IHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHkgfSwgXHJcbiAgICAgICAgICAgICAgICBtYXg6IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKGNvbXBvc2l0ZSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyYXZpdHkgdG8gYXBwbHkgb24gdGhlIHdvcmxkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyYXZpdHkgeCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueFxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBncmF2aXR5IHkgY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnlcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3Jhdml0eSBzY2FsZSBmYWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkuc2NhbGVcclxuICAgICAqIEB0eXBlIG9iamVjdFxyXG4gICAgICogQGRlZmF1bHQgMC4wMDFcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgQm91bmRzYCBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSB3b3JsZCBib3VuZHMgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xyXG4gICAgICogQHR5cGUgYm91bmRzXHJcbiAgICAgKiBAZGVmYXVsdCB7IG1pbjogeyB4OiAtSW5maW5pdHksIHk6IC1JbmZpbml0eSB9LCBtYXg6IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0gfVxyXG4gICAgICovXHJcblxyXG4gICAgLy8gV29ybGQgaXMgYSBDb21wb3NpdGUgYm9keVxyXG4gICAgLy8gc2VlIHNyYy9tb2R1bGUvT3V0cm8uanMgZm9yIHRoZXNlIGFsaWFzZXM6XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5jbGVhclxyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN0YXRpY1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhbGlhcyBmb3IgQ29tcG9zaXRlLmFkZFxyXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7d29ybGR9IHdvcmxkXHJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXHJcbiAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIG9iamVjdHMgZnJvbSBjb21wb3NpdGUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgXHJcbiAgICAgLyoqXHJcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRCb2R5XHJcbiAgICAgICogQG1ldGhvZCBhZGRCb2R5XHJcbiAgICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIGJvZHkgYWRkZWRcclxuICAgICAgKi9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50XHJcbiAgICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XHJcbiAgICAgICogQHBhcmFtIHt3b3JsZH0gd29ybGRcclxuICAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcclxuICAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Xb3JsZC5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLkNvbnRhY3RgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBjb250YWN0cy5cclxuKlxyXG4qIEBjbGFzcyBDb250YWN0XHJcbiovXHJcblxyXG52YXIgQ29udGFjdCA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250YWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7dmVydGV4fSB2ZXJ0ZXhcclxuICAgICAqIEByZXR1cm4ge2NvbnRhY3R9IEEgbmV3IGNvbnRhY3RcclxuICAgICAqL1xyXG4gICAgQ29udGFjdC5jcmVhdGUgPSBmdW5jdGlvbih2ZXJ0ZXgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogQ29udGFjdC5pZCh2ZXJ0ZXgpLFxyXG4gICAgICAgICAgICB2ZXJ0ZXg6IHZlcnRleCxcclxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZTogMCxcclxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2U6IDBcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBjb250YWN0IGlkLlxyXG4gICAgICogQG1ldGhvZCBpZFxyXG4gICAgICogQHBhcmFtIHt2ZXJ0ZXh9IHZlcnRleFxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBVbmlxdWUgY29udGFjdElEXHJcbiAgICAgKi9cclxuICAgIENvbnRhY3QuaWQgPSBmdW5jdGlvbih2ZXJ0ZXgpIHtcclxuICAgICAgICByZXR1cm4gdmVydGV4LmJvZHkuaWQgKyAnXycgKyB2ZXJ0ZXguaW5kZXg7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vQ29udGFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlBhaXJzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpciBzZXRzLlxyXG4qXHJcbiogQGNsYXNzIFBhaXJzXHJcbiovXHJcblxyXG52YXIgUGFpcnMgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFpcnM7XHJcblxyXG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgdmFyIF9wYWlyTWF4SWRsZUxpZmUgPSAxMDAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYWlycyBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge3BhaXJzfSBBIG5ldyBwYWlycyBzdHJ1Y3R1cmVcclxuICAgICAqL1xyXG4gICAgUGFpcnMuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXHJcbiAgICAgICAgICAgIHRhYmxlOiB7fSxcclxuICAgICAgICAgICAgbGlzdDogW10sXHJcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0OiBbXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlOiBbXSxcclxuICAgICAgICAgICAgY29sbGlzaW9uRW5kOiBbXVxyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgcGFpcnMgZ2l2ZW4gYSBsaXN0IG9mIGNvbGxpc2lvbnMuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhaXJzXHJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbltdfSBjb2xsaXNpb25zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXHJcbiAgICAgKi9cclxuICAgIFBhaXJzLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhaXJzLCBjb2xsaXNpb25zLCB0aW1lc3RhbXApIHtcclxuICAgICAgICB2YXIgcGFpcnNMaXN0ID0gcGFpcnMubGlzdCxcclxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IHBhaXJzLnRhYmxlLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25TdGFydCA9IHBhaXJzLmNvbGxpc2lvblN0YXJ0LFxyXG4gICAgICAgICAgICBjb2xsaXNpb25FbmQgPSBwYWlycy5jb2xsaXNpb25FbmQsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZSA9IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSxcclxuICAgICAgICAgICAgYWN0aXZlUGFpcklkcyA9IFtdLFxyXG4gICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgIHBhaXJJZCxcclxuICAgICAgICAgICAgcGFpcixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgY29sbGlzaW9uIHN0YXRlIGFycmF5cywgYnV0IG1haW50YWluIG9sZCByZWZlcmVuY2VcclxuICAgICAgICBjb2xsaXNpb25TdGFydC5sZW5ndGggPSAwO1xyXG4gICAgICAgIGNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xyXG4gICAgICAgIGNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5jb2xsaWRlZCkge1xyXG4gICAgICAgICAgICAgICAgcGFpcklkID0gUGFpci5pZChjb2xsaXNpb24uYm9keUEsIGNvbGxpc2lvbi5ib2R5Qik7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVQYWlySWRzLnB1c2gocGFpcklkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYWlyID0gcGFpcnNUYWJsZVtwYWlySWRdO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocGFpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgYWxyZWFkeSBleGlzdHMgKGJ1dCBtYXkgb3IgbWF5IG5vdCBiZSBhY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFpciBleGlzdHMgYW5kIGlzIGFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25BY3RpdmUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGV4aXN0cyBidXQgd2FzIGluYWN0aXZlLCBzbyBhIGNvbGxpc2lvbiBoYXMganVzdCBzdGFydGVkIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0LnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBQYWlyLnVwZGF0ZShwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgZGlkIG5vdCBleGlzdCwgY3JlYXRlIGEgbmV3IHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyID0gUGFpci5jcmVhdGUoY29sbGlzaW9uLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzVGFibGVbcGFpcklkXSA9IHBhaXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIG5ldyBwYWlyXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyc0xpc3QucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBwcmV2aW91c2x5IGFjdGl2ZSBwYWlycyB0aGF0IGFyZSBub3cgaW5hY3RpdmVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XHJcbiAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlICYmIENvbW1vbi5pbmRleE9mKGFjdGl2ZVBhaXJJZHMsIHBhaXIuaWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgUGFpci5zZXRBY3RpdmUocGFpciwgZmFsc2UsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25FbmQucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYW5kIHJlbW92ZXMgcGFpcnMgdGhhdCBoYXZlIGJlZW4gaW5hY3RpdmUgZm9yIGEgc2V0IGFtb3VudCBvZiB0aW1lLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVPbGRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxyXG4gICAgICovXHJcbiAgICBQYWlycy5yZW1vdmVPbGQgPSBmdW5jdGlvbihwYWlycywgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdmFyIHBhaXJzTGlzdCA9IHBhaXJzLmxpc3QsXHJcbiAgICAgICAgICAgIHBhaXJzVGFibGUgPSBwYWlycy50YWJsZSxcclxuICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlID0gW10sXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbixcclxuICAgICAgICAgICAgcGFpckluZGV4LFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbmV2ZXIgcmVtb3ZlIHNsZWVwaW5nIHBhaXJzXHJcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUEuaXNTbGVlcGluZyB8fCBjb2xsaXNpb24uYm9keUIuaXNTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgcGFpci50aW1lVXBkYXRlZCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGlzIGluYWN0aXZlIGZvciB0b28gbG9uZywgbWFyayBpdCB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgLSBwYWlyLnRpbWVVcGRhdGVkID4gX3BhaXJNYXhJZGxlTGlmZSkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBtYXJrZWQgcGFpcnNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXhlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IGluZGV4ZXNUb1JlbW92ZVtpXSAtIGk7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbcGFpckluZGV4XTtcclxuICAgICAgICAgICAgZGVsZXRlIHBhaXJzVGFibGVbcGFpci5pZF07XHJcbiAgICAgICAgICAgIHBhaXJzTGlzdC5zcGxpY2UocGFpckluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBnaXZlbiBwYWlycyBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJzfSBwYWlyc1xyXG4gICAgICogQHJldHVybiB7cGFpcnN9IHBhaXJzXHJcbiAgICAgKi9cclxuICAgIFBhaXJzLmNsZWFyID0gZnVuY3Rpb24ocGFpcnMpIHtcclxuICAgICAgICBwYWlycy50YWJsZSA9IHt9O1xyXG4gICAgICAgIHBhaXJzLmxpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICBwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBwYWlycztcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlycy5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlJlc29sdmVyYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgcmVzb2x2aW5nIGNvbGxpc2lvbiBwYWlycy5cclxuKlxyXG4qIEBjbGFzcyBSZXNvbHZlclxyXG4qL1xyXG5cclxudmFyIFJlc29sdmVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc29sdmVyO1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29yZS9Db21tb24nKTtcclxudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoID0gNDtcclxuICAgIFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCA9IDY7XHJcbiAgICBSZXNvbHZlci5fcG9zaXRpb25EYW1wZW4gPSAwLjk7XHJcbiAgICBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nID0gMC44O1xyXG4gICAgUmVzb2x2ZXIuX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciBwb3NpdGlvbiBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCBwcmVTb2x2ZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZXIucHJlU29sdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKHBhaXJzKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvdW50O1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRvdGFsIGNvbnRhY3RzIG9uIGVhY2ggYm9keVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvdW50ID0gcGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEEudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcclxuICAgICAgICAgICAgcGFpci5jb2xsaXNpb24ucGFyZW50Qi50b3RhbENvbnRhY3RzICs9IGFjdGl2ZUNvdW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGEgc29sdXRpb24gZm9yIHBhaXIgcG9zaXRpb25zLlxyXG4gICAgICogQG1ldGhvZCBzb2x2ZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZXIuc29sdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKHBhaXJzLCB0aW1lU2NhbGUpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgcGFpcixcclxuICAgICAgICAgICAgY29sbGlzaW9uLFxyXG4gICAgICAgICAgICBib2R5QSxcclxuICAgICAgICAgICAgYm9keUIsXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAgYm9keUJ0b0EsXHJcbiAgICAgICAgICAgIGNvbnRhY3RTaGFyZSxcclxuICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlLFxyXG4gICAgICAgICAgICBjb250YWN0Q291bnQgPSB7fSxcclxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMF0sXHJcbiAgICAgICAgICAgIHRlbXBCID0gVmVjdG9yLl90ZW1wWzFdLFxyXG4gICAgICAgICAgICB0ZW1wQyA9IFZlY3Rvci5fdGVtcFsyXSxcclxuICAgICAgICAgICAgdGVtcEQgPSBWZWN0b3IuX3RlbXBbM107XHJcblxyXG4gICAgICAgIC8vIGZpbmQgaW1wdWxzZXMgcmVxdWlyZWQgdG8gcmVzb2x2ZSBwZW5ldHJhdGlvblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XHJcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEE7XHJcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEI7XHJcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgY3VycmVudCBzZXBhcmF0aW9uIGJldHdlZW4gYm9keSBlZGdlcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25cclxuICAgICAgICAgICAgYm9keUJ0b0EgPSBWZWN0b3Iuc3ViKFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb25JbXB1bHNlLCBib2R5Qi5wb3NpdGlvbiwgdGVtcEEpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLmFkZChib2R5QS5wb3NpdGlvbkltcHVsc2UsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnN1Yihib2R5Qi5wb3NpdGlvbiwgY29sbGlzaW9uLnBlbmV0cmF0aW9uLCB0ZW1wQiksIHRlbXBDKSwgdGVtcEQpO1xyXG5cclxuICAgICAgICAgICAgcGFpci5zZXBhcmF0aW9uID0gVmVjdG9yLmRvdChub3JtYWwsIGJvZHlCdG9BKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSB8fCBwYWlyLmlzU2Vuc29yIHx8IHBhaXIuc2VwYXJhdGlvbiA8IDApXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xyXG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xyXG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgPSAocGFpci5zZXBhcmF0aW9uIC0gcGFpci5zbG9wKSAqIHRpbWVTY2FsZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5QS5pc1N0YXRpYyB8fCBib2R5Qi5pc1N0YXRpYylcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSAqPSAyO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiAvIGJvZHlBLnRvdGFsQ29udGFjdHM7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvbkltcHVsc2UueCArPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uSW1wdWxzZS55ICs9IG5vcm1hbC55ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuIC8gYm9keUIudG90YWxDb250YWN0cztcclxuICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uSW1wdWxzZS54IC09IG5vcm1hbC54ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xyXG4gICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25JbXB1bHNlLnkgLT0gbm9ybWFsLnkgKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgcG9zaXRpb24gcmVzb2x1dGlvbi5cclxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihib2RpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGNvbnRhY3QgY291bnRcclxuICAgICAgICAgICAgYm9keS50b3RhbENvbnRhY3RzID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LnBvc2l0aW9uSW1wdWxzZS54ICE9PSAwIHx8IGJvZHkucG9zaXRpb25JbXB1bHNlLnkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBib2R5IGdlb21ldHJ5XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGJvZHkucG9zaXRpb25JbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBib2R5IHdpdGhvdXQgY2hhbmdpbmcgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueDtcclxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yLmRvdChib2R5LnBvc2l0aW9uSW1wdWxzZSwgYm9keS52ZWxvY2l0eSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgY2FjaGVkIGltcHVsc2UgaWYgdGhlIGJvZHkgaGFzIHZlbG9jaXR5IGFsb25nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm0gdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCAqPSBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnkgKj0gUmVzb2x2ZXIuX3Bvc2l0aW9uV2FybWluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciB2ZWxvY2l0eSBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCBwcmVTb2x2ZVZlbG9jaXR5XHJcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZXIucHJlU29sdmVWZWxvY2l0eSA9IGZ1bmN0aW9uKHBhaXJzKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgIHBhaXIsXHJcbiAgICAgICAgICAgIGNvbnRhY3RzLFxyXG4gICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgIGJvZHlBLFxyXG4gICAgICAgICAgICBib2R5QixcclxuICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICB0YW5nZW50LFxyXG4gICAgICAgICAgICBjb250YWN0LFxyXG4gICAgICAgICAgICBjb250YWN0VmVydGV4LFxyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlLFxyXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZSxcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjdG9yLl90ZW1wWzBdLFxyXG4gICAgICAgICAgICB0ZW1wQSA9IFZlY3Rvci5fdGVtcFsxXTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cztcclxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XHJcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEE7XHJcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEI7XHJcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XHJcbiAgICAgICAgICAgIHRhbmdlbnQgPSBjb2xsaXNpb24udGFuZ2VudDtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgZWFjaCBjb250YWN0XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb250YWN0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdCA9IGNvbnRhY3RzW2pdO1xyXG4gICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4O1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSA9IGNvbnRhY3Qubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsSW1wdWxzZSAhPT0gMCB8fCB0YW5nZW50SW1wdWxzZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdGFsIGltcHVsc2UgZnJvbSBjb250YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS54ID0gKG5vcm1hbC54ICogbm9ybWFsSW1wdWxzZSkgKyAodGFuZ2VudC54ICogdGFuZ2VudEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2UueSA9IChub3JtYWwueSAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueSAqIHRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBpbXB1bHNlIGZyb20gY29udGFjdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFZlY3Rvci5zdWIoY29udGFjdFZlcnRleCwgYm9keUEucG9zaXRpb24sIHRlbXBBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggKz0gaW1wdWxzZS54ICogYm9keUEuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2UueSAqIGJvZHlBLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gVmVjdG9yLmNyb3NzKG9mZnNldCwgaW1wdWxzZSkgKiBib2R5QS5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFZlY3Rvci5zdWIoY29udGFjdFZlcnRleCwgYm9keUIucG9zaXRpb24sIHRlbXBBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZS54ICogYm9keUIuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hbmdsZVByZXYgLT0gVmVjdG9yLmNyb3NzKG9mZnNldCwgaW1wdWxzZSkgKiBib2R5Qi5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBhIHNvbHV0aW9uIGZvciBwYWlyIHZlbG9jaXRpZXMuXHJcbiAgICAgKiBAbWV0aG9kIHNvbHZlVmVsb2NpdHlcclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlci5zb2x2ZVZlbG9jaXR5ID0gZnVuY3Rpb24ocGFpcnMsIHRpbWVTY2FsZSkge1xyXG4gICAgICAgIHZhciB0aW1lU2NhbGVTcXVhcmVkID0gdGltZVNjYWxlICogdGltZVNjYWxlLFxyXG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjdG9yLl90ZW1wWzBdLFxyXG4gICAgICAgICAgICB0ZW1wQSA9IFZlY3Rvci5fdGVtcFsxXSxcclxuICAgICAgICAgICAgdGVtcEIgPSBWZWN0b3IuX3RlbXBbMl0sXHJcbiAgICAgICAgICAgIHRlbXBDID0gVmVjdG9yLl90ZW1wWzNdLFxyXG4gICAgICAgICAgICB0ZW1wRCA9IFZlY3Rvci5fdGVtcFs0XSxcclxuICAgICAgICAgICAgdGVtcEUgPSBWZWN0b3IuX3RlbXBbNV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbixcclxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEEsXHJcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCLFxyXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbCxcclxuICAgICAgICAgICAgICAgIHRhbmdlbnQgPSBjb2xsaXNpb24udGFuZ2VudCxcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cyxcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IDEgLyBjb250YWN0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm9keSB2ZWxvY2l0aWVzXHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUIucG9zaXRpb25QcmV2Lng7XHJcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnkgPSBib2R5Qi5wb3NpdGlvbi55IC0gYm9keUIucG9zaXRpb25QcmV2Lnk7XHJcbiAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlBLmFuZ2xlIC0gYm9keUEuYW5nbGVQcmV2O1xyXG4gICAgICAgICAgICBib2R5Qi5hbmd1bGFyVmVsb2NpdHkgPSBib2R5Qi5hbmdsZSAtIGJvZHlCLmFuZ2xlUHJldjtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgZWFjaCBjb250YWN0XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29udGFjdHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdHNbal0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEEgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlBLnBvc2l0aW9uLCB0ZW1wQSksXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QiA9IFZlY3Rvci5zdWIoY29udGFjdFZlcnRleCwgYm9keUIucG9zaXRpb24sIHRlbXBCKSxcclxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eVBvaW50QSA9IFZlY3Rvci5hZGQoYm9keUEudmVsb2NpdHksIFZlY3Rvci5tdWx0KFZlY3Rvci5wZXJwKG9mZnNldEEpLCBib2R5QS5hbmd1bGFyVmVsb2NpdHkpLCB0ZW1wQyksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHlQb2ludEIgPSBWZWN0b3IuYWRkKGJvZHlCLnZlbG9jaXR5LCBWZWN0b3IubXVsdChWZWN0b3IucGVycChvZmZzZXRCKSwgYm9keUIuYW5ndWxhclZlbG9jaXR5KSwgdGVtcEQpLCBcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVZlbG9jaXR5ID0gVmVjdG9yLnN1Yih2ZWxvY2l0eVBvaW50QSwgdmVsb2NpdHlQb2ludEIsIHRlbXBFKSxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxWZWxvY2l0eSA9IFZlY3Rvci5kb3Qobm9ybWFsLCByZWxhdGl2ZVZlbG9jaXR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFuZ2VudFZlbG9jaXR5ID0gVmVjdG9yLmRvdCh0YW5nZW50LCByZWxhdGl2ZVZlbG9jaXR5KSxcclxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50U3BlZWQgPSBNYXRoLmFicyh0YW5nZW50VmVsb2NpdHkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRWZWxvY2l0eURpcmVjdGlvbiA9IENvbW1vbi5zaWduKHRhbmdlbnRWZWxvY2l0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmF3IGltcHVsc2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsSW1wdWxzZSA9ICgxICsgcGFpci5yZXN0aXR1dGlvbikgKiBub3JtYWxWZWxvY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxGb3JjZSA9IENvbW1vbi5jbGFtcChwYWlyLnNlcGFyYXRpb24gKyBub3JtYWxWZWxvY2l0eSwgMCwgMSkgKiBSZXNvbHZlci5fZnJpY3Rpb25Ob3JtYWxNdWx0aXBsaWVyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvdWxvbWIgZnJpY3Rpb25cclxuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50SW1wdWxzZSA9IHRhbmdlbnRWZWxvY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhGcmljdGlvbiA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YW5nZW50U3BlZWQgPiBwYWlyLmZyaWN0aW9uICogcGFpci5mcmljdGlvblN0YXRpYyAqIG5vcm1hbEZvcmNlICogdGltZVNjYWxlU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heEZyaWN0aW9uID0gdGFuZ2VudFNwZWVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gQ29tbW9uLmNsYW1wKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmZyaWN0aW9uICogdGFuZ2VudFZlbG9jaXR5RGlyZWN0aW9uICogdGltZVNjYWxlU3F1YXJlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbW9kaWZ5IGltcHVsc2VzIGFjY291bnRpbmcgZm9yIG1hc3MsIGluZXJ0aWEgYW5kIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgdmFyIG9BY04gPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0QSwgbm9ybWFsKSxcclxuICAgICAgICAgICAgICAgICAgICBvQmNOID0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIG5vcm1hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcmUgPSBjb250YWN0U2hhcmUgLyAoYm9keUEuaW52ZXJzZU1hc3MgKyBib2R5Qi5pbnZlcnNlTWFzcyArIGJvZHlBLmludmVyc2VJbmVydGlhICogb0FjTiAqIG9BY04gICsgYm9keUIuaW52ZXJzZUluZXJ0aWEgKiBvQmNOICogb0JjTik7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSAqPSBzaGFyZTtcclxuICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlICo9IHNoYXJlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbFZlbG9jaXR5IDwgMCAmJiBub3JtYWxWZWxvY2l0eSAqIG5vcm1hbFZlbG9jaXR5ID4gUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2ggKiB0aW1lU2NhbGVTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCBub3JtYWwgdmVsb2NpdHkgc28gY2xlYXIgY2FjaGVkIGNvbnRhY3Qgbm9ybWFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZSByZXN0aW5nIGNvbGxpc2lvbiBjb25zdHJhaW50cyB1c2luZyBFcmluIENhdHRvJ3MgbWV0aG9kIChHREMwOClcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbXB1bHNlIGNvbnN0cmFpbnQgdGVuZHMgdG8gMFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0Tm9ybWFsSW1wdWxzZSA9IGNvbnRhY3Qubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgPSBNYXRoLm1pbihjb250YWN0Lm5vcm1hbEltcHVsc2UgKyBub3JtYWxJbXB1bHNlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlIC0gY29udGFjdE5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGhpZ2ggdmVsb2NpdHkgYW5kIHJlc3RpbmcgY29sbGlzaW9ucyBzZXBhcmF0ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAodGFuZ2VudFZlbG9jaXR5ICogdGFuZ2VudFZlbG9jaXR5ID4gUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2hUYW5nZW50ICogdGltZVNjYWxlU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggdGFuZ2VudCB2ZWxvY2l0eSBzbyBjbGVhciBjYWNoZWQgY29udGFjdCB0YW5nZW50IGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc29sdmUgcmVzdGluZyBjb2xsaXNpb24gY29uc3RyYWludHMgdXNpbmcgRXJpbiBDYXR0bydzIG1ldGhvZCAoR0RDMDgpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBpbXB1bHNlIHRlbmRzIHRvIC10YW5nZW50U3BlZWQgb3IgK3RhbmdlbnRTcGVlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0VGFuZ2VudEltcHVsc2UgPSBjb250YWN0LnRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QudGFuZ2VudEltcHVsc2UgPSBDb21tb24uY2xhbXAoY29udGFjdC50YW5nZW50SW1wdWxzZSArIHRhbmdlbnRJbXB1bHNlLCAtbWF4RnJpY3Rpb24sIG1heEZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2UgLSBjb250YWN0VGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdG90YWwgaW1wdWxzZSBmcm9tIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIGltcHVsc2UueCA9IChub3JtYWwueCAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueCAqIHRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UueSA9IChub3JtYWwueSAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueSAqIHRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggKz0gaW1wdWxzZS54ICogYm9keUEuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnkgKz0gaW1wdWxzZS55ICogYm9keUEuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuYW5nbGVQcmV2ICs9IFZlY3Rvci5jcm9zcyhvZmZzZXRBLCBpbXB1bHNlKSAqIGJvZHlBLmludmVyc2VJbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZS54ICogYm9keUIuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnkgLT0gaW1wdWxzZS55ICogYm9keUIuaW52ZXJzZU1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuYW5nbGVQcmV2IC09IFZlY3Rvci5jcm9zcyhvZmZzZXRCLCBpbXB1bHNlKSAqIGJvZHlCLmludmVyc2VJbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1Jlc29sdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuRW5naW5lYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBlbmdpbmVzLlxyXG4qIEFuIGVuZ2luZSBpcyBhIGNvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIHVwZGF0aW5nIHRoZSBzaW11bGF0aW9uIG9mIHRoZSB3b3JsZC5cclxuKiBTZWUgYE1hdHRlci5SdW5uZXJgIGZvciBhbiBvcHRpb25hbCBnYW1lIGxvb3AgdXRpbGl0eS5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgRW5naW5lXHJcbiovXHJcblxyXG52YXIgRW5naW5lID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcclxuXHJcbnZhciBXb3JsZCA9IHJlcXVpcmUoJy4uL2JvZHkvV29ybGQnKTtcclxudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi9TbGVlcGluZycpO1xyXG52YXIgUmVzb2x2ZXIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmVzb2x2ZXInKTtcclxudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcclxudmFyIFBhaXJzID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1BhaXJzJyk7XHJcbnZhciBNZXRyaWNzID0gcmVxdWlyZSgnLi9NZXRyaWNzJyk7XHJcbnZhciBHcmlkID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0dyaWQnKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vRXZlbnRzJyk7XHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xyXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9ib2R5L0JvZHknKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW5naW5lLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEByZXR1cm4ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gb3B0aW9ucyBtYXkgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCAoYW5kIG9ubHkpIGFyZ3VtZW50XHJcbiAgICAgICAgb3B0aW9ucyA9IENvbW1vbi5pc0VsZW1lbnQoZWxlbWVudCkgPyBvcHRpb25zIDogZWxlbWVudDtcclxuICAgICAgICBlbGVtZW50ID0gQ29tbW9uLmlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudCB8fCBvcHRpb25zLnJlbmRlcikge1xyXG4gICAgICAgICAgICBDb21tb24ud2FybignRW5naW5lLmNyZWF0ZTogZW5naW5lLnJlbmRlciBpcyBkZXByZWNhdGVkIChzZWUgZG9jcyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb25JdGVyYXRpb25zOiA2LFxyXG4gICAgICAgICAgICB2ZWxvY2l0eUl0ZXJhdGlvbnM6IDQsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRJdGVyYXRpb25zOiAyLFxyXG4gICAgICAgICAgICBlbmFibGVTbGVlcGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGV2ZW50czogW10sXHJcbiAgICAgICAgICAgIHBsdWdpbjoge30sXHJcbiAgICAgICAgICAgIHRpbWluZzoge1xyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxyXG4gICAgICAgICAgICAgICAgdGltZVNjYWxlOiAxXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2U6IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IEdyaWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBlbmdpbmUgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgICAgICBpZiAoZWxlbWVudCB8fCBlbmdpbmUucmVuZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJEZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZW5kZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIgPSBDb21tb24uZXh0ZW5kKHJlbmRlckRlZmF1bHRzLCBlbmdpbmUucmVuZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICAgICAgaWYgKGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIgPSBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIuY3JlYXRlKGVuZ2luZS5yZW5kZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgICAgICBpZiAoZW5naW5lLnJlbmRlcikge1xyXG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVuZ2luZS53b3JsZCA9IG9wdGlvbnMud29ybGQgfHwgV29ybGQuY3JlYXRlKGVuZ2luZS53b3JsZCk7XHJcbiAgICAgICAgZW5naW5lLnBhaXJzID0gUGFpcnMuY3JlYXRlKCk7XHJcbiAgICAgICAgZW5naW5lLmJyb2FkcGhhc2UgPSBlbmdpbmUuYnJvYWRwaGFzZS5jb250cm9sbGVyLmNyZWF0ZShlbmdpbmUuYnJvYWRwaGFzZSk7XHJcbiAgICAgICAgZW5naW5lLm1ldHJpY3MgPSBlbmdpbmUubWV0cmljcyB8fCB7IGV4dGVuZGVkOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICBlbmdpbmUubWV0cmljcyA9IE1ldHJpY3MuY3JlYXRlKGVuZ2luZS5tZXRyaWNzKTtcclxuICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgcmV0dXJuIGVuZ2luZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgc2ltdWxhdGlvbiBmb3J3YXJkIGluIHRpbWUgYnkgYGRlbHRhYCBtcy5cclxuICAgICAqIFRoZSBgY29ycmVjdGlvbmAgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIHRpbWUgY29ycmVjdGlvbiBmYWN0b3IgdG8gYXBwbHkgdG8gdGhlIHVwZGF0ZS5cclxuICAgICAqIFRoaXMgY2FuIGhlbHAgaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgdGhlIHNpbXVsYXRpb24gaW4gY2FzZXMgd2hlcmUgYGRlbHRhYCBpcyBjaGFuZ2luZyBiZXR3ZWVuIHVwZGF0ZXMuXHJcbiAgICAgKiBUaGUgdmFsdWUgb2YgYGNvcnJlY3Rpb25gIGlzIGRlZmluZWQgYXMgYGRlbHRhIC8gbGFzdERlbHRhYCwgaS5lLiB0aGUgcGVyY2VudGFnZSBjaGFuZ2Ugb2YgYGRlbHRhYCBvdmVyIHRoZSBsYXN0IHN0ZXAuXHJcbiAgICAgKiBUaGVyZWZvcmUgdGhlIHZhbHVlIGlzIGFsd2F5cyBgMWAgKG5vIGNvcnJlY3Rpb24pIHdoZW4gYGRlbHRhYCBjb25zdGFudCAob3Igd2hlbiBubyBjb3JyZWN0aW9uIGlzIGRlc2lyZWQsIHdoaWNoIGlzIHRoZSBkZWZhdWx0KS5cclxuICAgICAqIFNlZSB0aGUgcGFwZXIgb24gPGEgaHJlZj1cImh0dHA6Ly9sb25lc29jay5uZXQvYXJ0aWNsZS92ZXJsZXQuaHRtbFwiPlRpbWUgQ29ycmVjdGVkIFZlcmxldDwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVVwZGF0ZWAgYW5kIGBhZnRlclVwZGF0ZWAgZXZlbnRzLlxyXG4gICAgICogVHJpZ2dlcnMgYGNvbGxpc2lvblN0YXJ0YCwgYGNvbGxpc2lvbkFjdGl2ZWAgYW5kIGBjb2xsaXNpb25FbmRgIGV2ZW50cy5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhPTE2LjY2Nl1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29ycmVjdGlvbj0xXVxyXG4gICAgICovXHJcbiAgICBFbmdpbmUudXBkYXRlID0gZnVuY3Rpb24oZW5naW5lLCBkZWx0YSwgY29ycmVjdGlvbikge1xyXG4gICAgICAgIGRlbHRhID0gZGVsdGEgfHwgMTAwMCAvIDYwO1xyXG4gICAgICAgIGNvcnJlY3Rpb24gPSBjb3JyZWN0aW9uIHx8IDE7XHJcblxyXG4gICAgICAgIHZhciB3b3JsZCA9IGVuZ2luZS53b3JsZCxcclxuICAgICAgICAgICAgdGltaW5nID0gZW5naW5lLnRpbWluZyxcclxuICAgICAgICAgICAgYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlLFxyXG4gICAgICAgICAgICBicm9hZHBoYXNlUGFpcnMgPSBbXSxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gaW5jcmVtZW50IHRpbWVzdGFtcFxyXG4gICAgICAgIHRpbWluZy50aW1lc3RhbXAgKz0gZGVsdGEgKiB0aW1pbmcudGltZVNjYWxlO1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYW4gZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWluZy50aW1lc3RhbXBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdiZWZvcmVVcGRhdGUnLCBldmVudCk7XHJcblxyXG4gICAgICAgIC8vIGdldCBsaXN0cyBvZiBhbGwgYm9kaWVzIGFuZCBjb25zdHJhaW50cywgbm8gbWF0dGVyIHdoYXQgY29tcG9zaXRlcyB0aGV5IGFyZSBpblxyXG4gICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcclxuICAgICAgICAgICAgYWxsQ29uc3RyYWludHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMod29ybGQpO1xyXG5cclxuICAgICAgICAvLyBAaWYgREVCVUdcclxuICAgICAgICAvLyByZXNldCBtZXRyaWNzIGxvZ2dpbmdcclxuICAgICAgICBNZXRyaWNzLnJlc2V0KGVuZ2luZS5tZXRyaWNzKTtcclxuICAgICAgICAvLyBAZW5kaWZcclxuXHJcbiAgICAgICAgLy8gaWYgc2xlZXBpbmcgZW5hYmxlZCwgY2FsbCB0aGUgc2xlZXBpbmcgY29udHJvbGxlclxyXG4gICAgICAgIGlmIChlbmdpbmUuZW5hYmxlU2xlZXBpbmcpXHJcbiAgICAgICAgICAgIFNsZWVwaW5nLnVwZGF0ZShhbGxCb2RpZXMsIHRpbWluZy50aW1lU2NhbGUpO1xyXG5cclxuICAgICAgICAvLyBhcHBsaWVzIGdyYXZpdHkgdG8gYWxsIGJvZGllc1xyXG4gICAgICAgIF9ib2RpZXNBcHBseUdyYXZpdHkoYWxsQm9kaWVzLCB3b3JsZC5ncmF2aXR5KTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGFsbCBib2R5IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBieSBpbnRlZ3JhdGlvblxyXG4gICAgICAgIF9ib2RpZXNVcGRhdGUoYWxsQm9kaWVzLCBkZWx0YSwgdGltaW5nLnRpbWVTY2FsZSwgY29ycmVjdGlvbiwgd29ybGQuYm91bmRzKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGFsbCBjb25zdHJhaW50c1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUuY29uc3RyYWludEl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlQWxsKGFsbENvbnN0cmFpbnRzLCB0aW1pbmcudGltZVNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29uc3RyYWludC5wb3N0U29sdmVBbGwoYWxsQm9kaWVzKTtcclxuXHJcbiAgICAgICAgLy8gYnJvYWRwaGFzZSBwYXNzOiBmaW5kIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICBpZiAoYnJvYWRwaGFzZS5jb250cm9sbGVyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB3b3JsZCBpcyBkaXJ0eSwgd2UgbXVzdCBmbHVzaCB0aGUgd2hvbGUgZ3JpZFxyXG4gICAgICAgICAgICBpZiAod29ybGQuaXNNb2RpZmllZClcclxuICAgICAgICAgICAgICAgIGJyb2FkcGhhc2UuY29udHJvbGxlci5jbGVhcihicm9hZHBoYXNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JpZCBidWNrZXRzIGJhc2VkIG9uIGN1cnJlbnQgYm9kaWVzXHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2UuY29udHJvbGxlci51cGRhdGUoYnJvYWRwaGFzZSwgYWxsQm9kaWVzLCBlbmdpbmUsIHdvcmxkLmlzTW9kaWZpZWQpO1xyXG4gICAgICAgICAgICBicm9hZHBoYXNlUGFpcnMgPSBicm9hZHBoYXNlLnBhaXJzTGlzdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgbm8gYnJvYWRwaGFzZSBzZXQsIHdlIGp1c3QgcGFzcyBhbGwgYm9kaWVzXHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IGFsbEJvZGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGFsbCBjb21wb3NpdGUgbW9kaWZpZWQgZmxhZ3NcclxuICAgICAgICBpZiAod29ybGQuaXNNb2RpZmllZCkge1xyXG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQod29ybGQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBuYXJyb3dwaGFzZSBwYXNzOiBmaW5kIGFjdHVhbCBjb2xsaXNpb25zLCB0aGVuIGNyZWF0ZSBvciB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBicm9hZHBoYXNlLmRldGVjdG9yKGJyb2FkcGhhc2VQYWlycywgZW5naW5lKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgIHZhciBwYWlycyA9IGVuZ2luZS5wYWlycyxcclxuICAgICAgICAgICAgdGltZXN0YW1wID0gdGltaW5nLnRpbWVzdGFtcDtcclxuICAgICAgICBQYWlycy51cGRhdGUocGFpcnMsIGNvbGxpc2lvbnMsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgUGFpcnMucmVtb3ZlT2xkKHBhaXJzLCB0aW1lc3RhbXApO1xyXG5cclxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXHJcbiAgICAgICAgaWYgKGVuZ2luZS5lbmFibGVTbGVlcGluZylcclxuICAgICAgICAgICAgU2xlZXBpbmcuYWZ0ZXJDb2xsaXNpb25zKHBhaXJzLmxpc3QsIHRpbWluZy50aW1lU2NhbGUpO1xyXG5cclxuICAgICAgICAvLyB0cmlnZ2VyIGNvbGxpc2lvbiBldmVudHNcclxuICAgICAgICBpZiAocGFpcnMuY29sbGlzaW9uU3RhcnQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uU3RhcnQnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25TdGFydCB9KTtcclxuXHJcbiAgICAgICAgLy8gaXRlcmF0aXZlbHkgcmVzb2x2ZSBwb3NpdGlvbiBiZXR3ZWVuIGNvbGxpc2lvbnNcclxuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUucG9zaXRpb25JdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgUmVzb2x2ZXIuc29sdmVQb3NpdGlvbihwYWlycy5saXN0LCB0aW1pbmcudGltZVNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24oYWxsQm9kaWVzKTtcclxuXHJcbiAgICAgICAgLy8gaXRlcmF0aXZlbHkgcmVzb2x2ZSB2ZWxvY2l0eSBiZXR3ZWVuIGNvbGxpc2lvbnNcclxuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUudmVsb2NpdHlJdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgUmVzb2x2ZXIuc29sdmVWZWxvY2l0eShwYWlycy5saXN0LCB0aW1pbmcudGltZVNjYWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRyaWdnZXIgY29sbGlzaW9uIGV2ZW50c1xyXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25BY3RpdmUubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uQWN0aXZlJywgeyBwYWlyczogcGFpcnMuY29sbGlzaW9uQWN0aXZlIH0pO1xyXG5cclxuICAgICAgICBpZiAocGFpcnMuY29sbGlzaW9uRW5kLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2NvbGxpc2lvbkVuZCcsIHsgcGFpcnM6IHBhaXJzLmNvbGxpc2lvbkVuZCB9KTtcclxuXHJcbiAgICAgICAgLy8gQGlmIERFQlVHXHJcbiAgICAgICAgLy8gdXBkYXRlIG1ldHJpY3MgbG9nXHJcbiAgICAgICAgTWV0cmljcy51cGRhdGUoZW5naW5lLm1ldHJpY3MsIGVuZ2luZSk7XHJcbiAgICAgICAgLy8gQGVuZGlmXHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGZvcmNlIGJ1ZmZlcnNcclxuICAgICAgICBfYm9kaWVzQ2xlYXJGb3JjZXMoYWxsQm9kaWVzKTtcclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbmdpbmU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyB0d28gZW5naW5lcyBieSBrZWVwaW5nIHRoZSBjb25maWd1cmF0aW9uIG9mIGBlbmdpbmVBYCBidXQgcmVwbGFjaW5nIHRoZSB3b3JsZCB3aXRoIHRoZSBvbmUgZnJvbSBgZW5naW5lQmAuXHJcbiAgICAgKiBAbWV0aG9kIG1lcmdlXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQVxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZUJcclxuICAgICAqL1xyXG4gICAgRW5naW5lLm1lcmdlID0gZnVuY3Rpb24oZW5naW5lQSwgZW5naW5lQikge1xyXG4gICAgICAgIENvbW1vbi5leHRlbmQoZW5naW5lQSwgZW5naW5lQik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGVuZ2luZUIud29ybGQpIHtcclxuICAgICAgICAgICAgZW5naW5lQS53b3JsZCA9IGVuZ2luZUIud29ybGQ7XHJcblxyXG4gICAgICAgICAgICBFbmdpbmUuY2xlYXIoZW5naW5lQSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhlbmdpbmVBLndvcmxkKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBib2R5LmlkID0gQ29tbW9uLm5leHRJZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgZW5naW5lIGluY2x1ZGluZyB0aGUgd29ybGQsIHBhaXJzIGFuZCBicm9hZHBoYXNlLlxyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBFbmdpbmUuY2xlYXIgPSBmdW5jdGlvbihlbmdpbmUpIHtcclxuICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgUGFpcnMuY2xlYXIoZW5naW5lLnBhaXJzKTtcclxuXHJcbiAgICAgICAgdmFyIGJyb2FkcGhhc2UgPSBlbmdpbmUuYnJvYWRwaGFzZTtcclxuICAgICAgICBpZiAoYnJvYWRwaGFzZS5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKTtcclxuICAgICAgICAgICAgYnJvYWRwaGFzZS5jb250cm9sbGVyLmNsZWFyKGJyb2FkcGhhc2UpO1xyXG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIudXBkYXRlKGJyb2FkcGhhc2UsIGJvZGllcywgZW5naW5lLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogWmVyb2VzIHRoZSBgYm9keS5mb3JjZWAgYW5kIGBib2R5LnRvcnF1ZWAgZm9yY2UgYnVmZmVycy5cclxuICAgICAqIEBtZXRob2QgYm9kaWVzQ2xlYXJGb3JjZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKi9cclxuICAgIHZhciBfYm9kaWVzQ2xlYXJGb3JjZXMgPSBmdW5jdGlvbihib2RpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlIGJ1ZmZlcnNcclxuICAgICAgICAgICAgYm9keS5mb3JjZS54ID0gMDtcclxuICAgICAgICAgICAgYm9keS5mb3JjZS55ID0gMDtcclxuICAgICAgICAgICAgYm9keS50b3JxdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseXMgYSBtYXNzIGRlcGVuZGFudCBmb3JjZSB0byBhbGwgZ2l2ZW4gYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBib2RpZXNBcHBseUdyYXZpdHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZ3Jhdml0eVxyXG4gICAgICovXHJcbiAgICB2YXIgX2JvZGllc0FwcGx5R3Jhdml0eSA9IGZ1bmN0aW9uKGJvZGllcywgZ3Jhdml0eSkge1xyXG4gICAgICAgIHZhciBncmF2aXR5U2NhbGUgPSB0eXBlb2YgZ3Jhdml0eS5zY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBncmF2aXR5LnNjYWxlIDogMC4wMDE7XHJcblxyXG4gICAgICAgIGlmICgoZ3Jhdml0eS54ID09PSAwICYmIGdyYXZpdHkueSA9PT0gMCkgfHwgZ3Jhdml0eVNjYWxlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IGdyYXZpdHlcclxuICAgICAgICAgICAgYm9keS5mb3JjZS55ICs9IGJvZHkubWFzcyAqIGdyYXZpdHkueSAqIGdyYXZpdHlTY2FsZTtcclxuICAgICAgICAgICAgYm9keS5mb3JjZS54ICs9IGJvZHkubWFzcyAqIGdyYXZpdHkueCAqIGdyYXZpdHlTY2FsZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHlzIGBCb2R5LnVwZGF0ZWAgdG8gYWxsIGdpdmVuIGBib2RpZXNgLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVBbGxcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIFxyXG4gICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGVsYXBzZWQgYmV0d2VlbiB1cGRhdGVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29ycmVjdGlvbiBcclxuICAgICAqIFRoZSBWZXJsZXQgY29ycmVjdGlvbiBmYWN0b3IgKGRlbHRhVGltZSAvIGxhc3REZWx0YVRpbWUpXHJcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gd29ybGRCb3VuZHNcclxuICAgICAqL1xyXG4gICAgdmFyIF9ib2RpZXNVcGRhdGUgPSBmdW5jdGlvbihib2RpZXMsIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uLCB3b3JsZEJvdW5kcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgYm9keS5pc1NsZWVwaW5nKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBCb2R5LnVwZGF0ZShib2R5LCBkZWx0YVRpbWUsIHRpbWVTY2FsZSwgY29ycmVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFsaWFzIGZvciBgUnVubmVyLnJ1bmAsIHNlZSBgTWF0dGVyLlJ1bm5lcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHJ1blxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGFuIHVwZGF0ZVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlVXBkYXRlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSBhbmQgYWxsIGNvbGxpc2lvbiBldmVudHNcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyVXBkYXRlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgc3RhcnRlZCB0byBjb2xsaWRlIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcclxuICAgICpcclxuICAgICogQGV2ZW50IGNvbGxpc2lvblN0YXJ0XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnBhaXJzIExpc3Qgb2YgYWZmZWN0ZWQgcGFpcnNcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGFyZSBjb2xsaWRpbmcgaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uQWN0aXZlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnBhaXJzIExpc3Qgb2YgYWZmZWN0ZWQgcGFpcnNcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgZW5kZWQgY29sbGlzaW9uIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcclxuICAgICpcclxuICAgICogQGV2ZW50IGNvbGxpc2lvbkVuZFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXHJcbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGhpZ2hlciBxdWFsaXR5IHRoZSBzaW11bGF0aW9uIHdpbGwgYmUgYXQgdGhlIGV4cGVuc2Ugb2YgcGVyZm9ybWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uSXRlcmF0aW9uc1xyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCA2XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXHJcbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGhpZ2hlciBxdWFsaXR5IHRoZSBzaW11bGF0aW9uIHdpbGwgYmUgYXQgdGhlIGV4cGVuc2Ugb2YgcGVyZm9ybWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5SXRlcmF0aW9uc1xyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCA0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjb25zdHJhaW50IGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cclxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHF1YWxpdHkgdGhlIHNpbXVsYXRpb24gd2lsbCBiZSBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cclxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAyYCBpcyB1c3VhbGx5IHZlcnkgYWRlcXVhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRJdGVyYXRpb25zXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgYWxsb3cgc2xlZXBpbmcgdmlhIHRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUuXHJcbiAgICAgKiBTbGVlcGluZyBjYW4gaW1wcm92ZSBzdGFiaWxpdHkgYW5kIHBlcmZvcm1hbmNlLCBidXQgb2Z0ZW4gYXQgdGhlIGV4cGVuc2Ugb2YgYWNjdXJhY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGVuYWJsZVNsZWVwaW5nXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBgT2JqZWN0YCBjb250YWluaW5nIHByb3BlcnRpZXMgcmVnYXJkaW5nIHRoZSB0aW1pbmcgc3lzdGVtcyBvZiB0aGUgZW5naW5lLiBcclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nXHJcbiAgICAgKiBAdHlwZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgZ2xvYmFsIHNjYWxpbmcgZmFjdG9yIG9mIHRpbWUgZm9yIGFsbCBib2RpZXMuXHJcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBmcmVlemVzIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgICogQSB2YWx1ZSBvZiBgMC4xYCBnaXZlcyBhIHNsb3ctbW90aW9uIGVmZmVjdC5cclxuICAgICAqIEEgdmFsdWUgb2YgYDEuMmAgZ2l2ZXMgYSBzcGVlZC11cCBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHRpbWluZy50aW1lU2NhbGVcclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBjdXJyZW50IHNpbXVsYXRpb24tdGltZSBpbiBtaWxsaXNlY29uZHMgc3RhcnRpbmcgZnJvbSBgMGAuIFxyXG4gICAgICogSXQgaXMgaW5jcmVtZW50ZWQgb24gZXZlcnkgYEVuZ2luZS51cGRhdGVgIGJ5IHRoZSBnaXZlbiBgZGVsdGFgIGFyZ3VtZW50LiBcclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nLnRpbWVzdGFtcFxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluc3RhbmNlIG9mIGEgYFJlbmRlcmAgY29udHJvbGxlci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBgTWF0dGVyLlJlbmRlcmAgaW5zdGFuY2UgY3JlYXRlZCBieSBgRW5naW5lLmNyZWF0ZWAuXHJcbiAgICAgKiBPbmUgbWF5IGFsc28gZGV2ZWxvcCBhIGN1c3RvbSByZW5kZXJlciBtb2R1bGUgYmFzZWQgb24gYE1hdHRlci5SZW5kZXJgIGFuZCBwYXNzIGFuIGluc3RhbmNlIG9mIGl0IHRvIGBFbmdpbmUuY3JlYXRlYCB2aWEgYG9wdGlvbnMucmVuZGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBBIG1pbmltYWwgY3VzdG9tIHJlbmRlcmVyIG9iamVjdCBtdXN0IGRlZmluZSBhdCBsZWFzdCB0aHJlZSBmdW5jdGlvbnM6IGBjcmVhdGVgLCBgY2xlYXJgIGFuZCBgd29ybGRgIChzZWUgYE1hdHRlci5SZW5kZXJgKS5cclxuICAgICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gaW5zdGVhZCBwYXNzIHRoZSBfbW9kdWxlXyByZWZlcmVuY2UgdmlhIGBvcHRpb25zLnJlbmRlci5jb250cm9sbGVyYCBhbmQgYEVuZ2luZS5jcmVhdGVgIHdpbGwgaW5zdGFudGlhdGUgb25lIGZvciB5b3UuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHJlbmRlclxyXG4gICAgICogQHR5cGUgcmVuZGVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBzZWUgRGVtby5qcyBmb3IgYW4gZXhhbXBsZSBvZiBjcmVhdGluZyBhIHJlbmRlcmVyXHJcbiAgICAgKiBAZGVmYXVsdCBhIE1hdHRlci5SZW5kZXIgaW5zdGFuY2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBicm9hZHBoYXNlIGNvbnRyb2xsZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgYE1hdHRlci5HcmlkYCBpbnN0YW5jZSBjcmVhdGVkIGJ5IGBFbmdpbmUuY3JlYXRlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgYnJvYWRwaGFzZVxyXG4gICAgICogQHR5cGUgZ3JpZFxyXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBXb3JsZGAgY29tcG9zaXRlIG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBhbGwgc2ltdWxhdGVkIGJvZGllcyBhbmQgY29uc3RyYWludHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHdvcmxkXHJcbiAgICAgKiBAdHlwZSB3b3JsZFxyXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuV29ybGQgaW5zdGFuY2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cclxuICAgICAqIEB0eXBlIHt9XHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FbmdpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAaWYgREVCVUdcclxuLyoqXHJcbiogX0ludGVybmFsIENsYXNzXywgbm90IGdlbmVyYWxseSB1c2VkIG91dHNpZGUgb2YgdGhlIGVuZ2luZSdzIGludGVybmFscy5cclxuKlxyXG4qL1xyXG5cclxudmFyIE1ldHJpY3MgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWV0cmljcztcclxuXHJcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWV0cmljcy5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7bWV0cmljc30gQSBuZXcgbWV0cmljc1xyXG4gICAgICovXHJcbiAgICBNZXRyaWNzLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGV4dGVuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgbmFycm93RGV0ZWN0aW9uczogMCxcclxuICAgICAgICAgICAgbmFycm93cGhhc2VUZXN0czogMCxcclxuICAgICAgICAgICAgbmFycm93UmV1c2U6IDAsXHJcbiAgICAgICAgICAgIG5hcnJvd1JldXNlQ291bnQ6IDAsXHJcbiAgICAgICAgICAgIG1pZHBoYXNlVGVzdHM6IDAsXHJcbiAgICAgICAgICAgIGJyb2FkcGhhc2VUZXN0czogMCxcclxuICAgICAgICAgICAgbmFycm93RWZmOiAwLjAwMDEsXHJcbiAgICAgICAgICAgIG1pZEVmZjogMC4wMDAxLFxyXG4gICAgICAgICAgICBicm9hZEVmZjogMC4wMDAxLFxyXG4gICAgICAgICAgICBjb2xsaXNpb25zOiAwLFxyXG4gICAgICAgICAgICBidWNrZXRzOiAwLFxyXG4gICAgICAgICAgICBib2RpZXM6IDAsXHJcbiAgICAgICAgICAgIHBhaXJzOiAwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIGZhbHNlLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgbWV0cmljcy5cclxuICAgICAqIEBtZXRob2QgcmVzZXRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge21ldHJpY3N9IG1ldHJpY3NcclxuICAgICAqL1xyXG4gICAgTWV0cmljcy5yZXNldCA9IGZ1bmN0aW9uKG1ldHJpY3MpIHtcclxuICAgICAgICBpZiAobWV0cmljcy5leHRlbmRlZCkge1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnMgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd3BoYXNlVGVzdHMgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd1JldXNlID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dSZXVzZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5taWRwaGFzZVRlc3RzID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5icm9hZHBoYXNlVGVzdHMgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd0VmZiA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MubWlkRWZmID0gMDtcclxuICAgICAgICAgICAgbWV0cmljcy5icm9hZEVmZiA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MuY29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MuYnVja2V0cyA9IDA7XHJcbiAgICAgICAgICAgIG1ldHJpY3MucGFpcnMgPSAwO1xyXG4gICAgICAgICAgICBtZXRyaWNzLmJvZGllcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgbWV0cmljcy5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHttZXRyaWNzfSBtZXRyaWNzXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuICAgIE1ldHJpY3MudXBkYXRlID0gZnVuY3Rpb24obWV0cmljcywgZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKG1ldHJpY3MuZXh0ZW5kZWQpIHtcclxuICAgICAgICAgICAgdmFyIHdvcmxkID0gZW5naW5lLndvcmxkLFxyXG4gICAgICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCk7XHJcblxyXG4gICAgICAgICAgICBtZXRyaWNzLmNvbGxpc2lvbnMgPSBtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnM7XHJcbiAgICAgICAgICAgIG1ldHJpY3MucGFpcnMgPSBlbmdpbmUucGFpcnMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIG1ldHJpY3MuYm9kaWVzID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgbWV0cmljcy5taWRFZmYgPSAobWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zIC8gKG1ldHJpY3MubWlkcGhhc2VUZXN0cyB8fCAxKSkudG9GaXhlZCgyKTtcclxuICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dFZmYgPSAobWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zIC8gKG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyB8fCAxKSkudG9GaXhlZCgyKTtcclxuICAgICAgICAgICAgbWV0cmljcy5icm9hZEVmZiA9ICgxIC0gKG1ldHJpY3MuYnJvYWRwaGFzZVRlc3RzIC8gKGJvZGllcy5sZW5ndGggfHwgMSkpKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd1JldXNlID0gKG1ldHJpY3MubmFycm93UmV1c2VDb3VudCAvIChtZXRyaWNzLm5hcnJvd3BoYXNlVGVzdHMgfHwgMSkpLnRvRml4ZWQoMik7XHJcbiAgICAgICAgICAgIC8vdmFyIGJyb2FkcGhhc2UgPSBlbmdpbmUuYnJvYWRwaGFzZVtlbmdpbmUuYnJvYWRwaGFzZS5jdXJyZW50XTtcclxuICAgICAgICAgICAgLy9pZiAoYnJvYWRwaGFzZS5pbnN0YW5jZSlcclxuICAgICAgICAgICAgLy8gICAgbWV0cmljcy5idWNrZXRzID0gQ29tbW9uLmtleXMoYnJvYWRwaGFzZS5pbnN0YW5jZS5idWNrZXRzKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcbi8vIEBlbmRpZlxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWV0cmljcy5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlBsdWdpbmAgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyBmb3IgcmVnaXN0ZXJpbmcgYW5kIGluc3RhbGxpbmcgcGx1Z2lucyBvbiBtb2R1bGVzLlxyXG4qXHJcbiogQGNsYXNzIFBsdWdpblxyXG4qL1xyXG5cclxudmFyIFBsdWdpbiA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW47XHJcblxyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICBQbHVnaW4uX3JlZ2lzdHJ5ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gb2JqZWN0IHNvIGl0IGNhbiBiZSByZXNvbHZlZCBsYXRlciBieSBuYW1lLlxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHBsdWdpbiB7fSBUaGUgcGx1Z2luIHRvIHJlZ2lzdGVyLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcGx1Z2luLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4ucmVnaXN0ZXIgPSBmdW5jdGlvbihwbHVnaW4pIHtcclxuICAgICAgICBpZiAoIVBsdWdpbi5pc1BsdWdpbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdkb2VzIG5vdCBpbXBsZW1lbnQgYWxsIHJlcXVpcmVkIGZpZWxkcy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwbHVnaW4ubmFtZSBpbiBQbHVnaW4uX3JlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkID0gUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0sXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5WZXJzaW9uID0gUGx1Z2luLnZlcnNpb25QYXJzZShwbHVnaW4udmVyc2lvbikubnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHJlZ2lzdGVyZWQudmVyc2lvbikubnVtYmVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBsdWdpblZlcnNpb24gPiByZWdpc3RlcmVkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocmVnaXN0ZXJlZCksICd3YXMgdXBncmFkZWQgdG8nLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XHJcbiAgICAgICAgICAgICAgICBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW5WZXJzaW9uIDwgcmVnaXN0ZXJlZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHJlZ2lzdGVyZWQpLCAnY2FuIG5vdCBiZSBkb3duZ3JhZGVkIHRvJywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAhPT0gcmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGFscmVhZHkgcmVnaXN0ZXJlZCB0byBkaWZmZXJlbnQgcGx1Z2luIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGEgZGVwZW5kZW5jeSB0byBhIHBsdWdpbiBvYmplY3QgZnJvbSB0aGUgcmVnaXN0cnkgaWYgaXQgZXhpc3RzLiBcclxuICAgICAqIFRoZSBgZGVwZW5kZW5jeWAgbWF5IGNvbnRhaW4gYSB2ZXJzaW9uLCBidXQgb25seSB0aGUgbmFtZSBtYXR0ZXJzIHdoZW4gcmVzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCByZXNvbHZlXHJcbiAgICAgKiBAcGFyYW0gZGVwZW5kZW5jeSB7c3RyaW5nfSBUaGUgZGVwZW5kZW5jeS5cclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHBsdWdpbiBpZiByZXNvbHZlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4ucmVzb2x2ZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICByZXR1cm4gUGx1Z2luLl9yZWdpc3RyeVtQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKGRlcGVuZGVuY3kpLm5hbWVdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgcHJpbnRlZCBwbHVnaW4gbmFtZSBhbmQgdmVyc2lvbi5cclxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbi5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUHJldHR5IHByaW50ZWQgcGx1Z2luIG5hbWUgYW5kIHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIFBsdWdpbi50b1N0cmluZyA9IGZ1bmN0aW9uKHBsdWdpbikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IHBsdWdpbiA6IChwbHVnaW4ubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnQCcgKyAocGx1Z2luLnZlcnNpb24gfHwgcGx1Z2luLnJhbmdlIHx8ICcwLjAuMCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWVldHMgdGhlIG1pbmltdW0gc3RhbmRhcmQgdG8gYmUgY29uc2lkZXJlZCBhIHBsdWdpbi5cclxuICAgICAqIFRoaXMgbWVhbnMgaXQgbXVzdCBkZWZpbmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogLSBgbmFtZWBcclxuICAgICAqIC0gYHZlcnNpb25gXHJcbiAgICAgKiAtIGBpbnN0YWxsYFxyXG4gICAgICogQG1ldGhvZCBpc1BsdWdpblxyXG4gICAgICogQHBhcmFtIG9iaiB7fSBUaGUgb2JqIHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBjYW4gYmUgY29uc2lkZXJlZCBhIHBsdWdpbiBvdGhlcndpc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLmlzUGx1Z2luID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubmFtZSAmJiBvYmoudmVyc2lvbiAmJiBvYmouaW5zdGFsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhIHBsdWdpbiB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgYmVlbiBpbnN0YWxsZWQgb24gYG1vZHVsZWAuXHJcbiAgICAgKiBAbWV0aG9kIGlzVXNlZFxyXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxyXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIHBsdWdpbiBuYW1lLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIFBsdWdpbi5pc1VzZWQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlLnVzZWQuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGBwbHVnaW4uZm9yYCBpcyBhcHBsaWNhYmxlIHRvIGBtb2R1bGVgIGJ5IGNvbXBhcmluZyBhZ2FpbnN0IGBtb2R1bGUubmFtZWAgYW5kIGBtb2R1bGUudmVyc2lvbmAuXHJcbiAgICAgKiBJZiBgcGx1Z2luLmZvcmAgaXMgbm90IHNwZWNpZmllZCB0aGVuIGl0IGlzIGFzc3VtZWQgdG8gYmUgYXBwbGljYWJsZS5cclxuICAgICAqIFRoZSB2YWx1ZSBvZiBgcGx1Z2luLmZvcmAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXHJcbiAgICAgKiBAbWV0aG9kIGlzRm9yXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4uXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHBsdWdpbi5mb3JgIGlzIGFwcGxpY2FibGUgdG8gYG1vZHVsZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4uaXNGb3IgPSBmdW5jdGlvbihwbHVnaW4sIG1vZHVsZSkge1xyXG4gICAgICAgIHZhciBwYXJzZWQgPSBwbHVnaW4uZm9yICYmIFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UocGx1Z2luLmZvcik7XHJcbiAgICAgICAgcmV0dXJuICFwbHVnaW4uZm9yIHx8IChtb2R1bGUubmFtZSA9PT0gcGFyc2VkLm5hbWUgJiYgUGx1Z2luLnZlcnNpb25TYXRpc2ZpZXMobW9kdWxlLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbGxzIHRoZSBwbHVnaW5zIGJ5IGNhbGxpbmcgYHBsdWdpbi5pbnN0YWxsYCBvbiBlYWNoIHBsdWdpbiBzcGVjaWZpZWQgaW4gYHBsdWdpbnNgIGlmIHBhc3NlZCwgb3RoZXJ3aXNlIGBtb2R1bGUudXNlc2AuXHJcbiAgICAgKiBGb3IgaW5zdGFsbGluZyBwbHVnaW5zIG9uIGBNYXR0ZXJgIHNlZSB0aGUgY29udmVuaWVuY2UgZnVuY3Rpb24gYE1hdHRlci51c2VgLlxyXG4gICAgICogUGx1Z2lucyBtYXkgYmUgc3BlY2lmaWVkIGVpdGhlciBieSB0aGVpciBuYW1lIG9yIGEgcmVmZXJlbmNlIHRvIHRoZSBwbHVnaW4gb2JqZWN0LlxyXG4gICAgICogUGx1Z2lucyB0aGVtc2VsdmVzIG1heSBzcGVjaWZ5IGZ1cnRoZXIgZGVwZW5kZW5jaWVzLCBidXQgZWFjaCBwbHVnaW4gaXMgaW5zdGFsbGVkIG9ubHkgb25jZS5cclxuICAgICAqIE9yZGVyIGlzIGltcG9ydGFudCwgYSB0b3BvbG9naWNhbCBzb3J0IGlzIHBlcmZvcm1lZCB0byBmaW5kIHRoZSBiZXN0IHJlc3VsdGluZyBvcmRlciBvZiBpbnN0YWxsYXRpb24uXHJcbiAgICAgKiBUaGlzIHNvcnRpbmcgYXR0ZW1wdHMgdG8gc2F0aXNmeSBldmVyeSBkZXBlbmRlbmN5J3MgcmVxdWVzdGVkIG9yZGVyaW5nLCBidXQgbWF5IG5vdCBiZSBleGFjdCBpbiBhbGwgY2FzZXMuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGxvZ3MgdGhlIHJlc3VsdGluZyBzdGF0dXMgb2YgZWFjaCBkZXBlbmRlbmN5IGluIHRoZSBjb25zb2xlLCBhbG9uZyB3aXRoIGFueSB3YXJuaW5ncy5cclxuICAgICAqIC0gQSBncmVlbiB0aWNrIOKchSBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IHdhcyByZXNvbHZlZCBhbmQgaW5zdGFsbGVkLlxyXG4gICAgICogLSBBbiBvcmFuZ2UgZGlhbW9uZCDwn5S2IGluZGljYXRlcyBhIGRlcGVuZGVuY3kgd2FzIHJlc29sdmVkIGJ1dCBhIHdhcm5pbmcgd2FzIHRocm93biBmb3IgaXQgb3Igb25lIGlmIGl0cyBkZXBlbmRlbmNpZXMuXHJcbiAgICAgKiAtIEEgcmVkIGNyb3NzIOKdjCBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IGNvdWxkIG5vdCBiZSByZXNvbHZlZC5cclxuICAgICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBtb2R1bGUgdW5sZXNzIHlvdSBpbnRlbmQgdG8gbWFudWFsbHkgY29udHJvbCBpbnN0YWxsYXRpb24gb3JkZXIuXHJcbiAgICAgKiBAbWV0aG9kIHVzZVxyXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlIGluc3RhbGwgcGx1Z2lucyBvbi5cclxuICAgICAqIEBwYXJhbSBbcGx1Z2lucz1tb2R1bGUudXNlc10ge30gVGhlIHBsdWdpbnMgdG8gaW5zdGFsbCBvbiBtb2R1bGUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBgbW9kdWxlLnVzZXNgKS5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLnVzZSA9IGZ1bmN0aW9uKG1vZHVsZSwgcGx1Z2lucykge1xyXG4gICAgICAgIG1vZHVsZS51c2VzID0gKG1vZHVsZS51c2VzIHx8IFtdKS5jb25jYXQocGx1Z2lucyB8fCBbXSk7XHJcblxyXG4gICAgICAgIGlmIChtb2R1bGUudXNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi51c2U6JywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSksICdkb2VzIG5vdCBzcGVjaWZ5IGFueSBkZXBlbmRlbmNpZXMgdG8gaW5zdGFsbC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFBsdWdpbi5kZXBlbmRlbmNpZXMobW9kdWxlKSxcclxuICAgICAgICAgICAgc29ydGVkRGVwZW5kZW5jaWVzID0gQ29tbW9uLnRvcG9sb2dpY2FsU29ydChkZXBlbmRlbmNpZXMpLFxyXG4gICAgICAgICAgICBzdGF0dXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKHNvcnRlZERlcGVuZGVuY2llc1tpXSA9PT0gbW9kdWxlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gUGx1Z2luLnJlc29sdmUoc29ydGVkRGVwZW5kZW5jaWVzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn4p2MICcgKyBzb3J0ZWREZXBlbmRlbmNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChQbHVnaW4uaXNVc2VkKG1vZHVsZSwgcGx1Z2luLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFQbHVnaW4uaXNGb3IocGx1Z2luLCBtb2R1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2lzIGZvcicsIHBsdWdpbi5mb3IsICdidXQgaW5zdGFsbGVkIG9uJywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSkgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luLl93YXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKG1vZHVsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2RvZXMgbm90IHNwZWNpZnkgYW4gaW5zdGFsbCBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5fd2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHBsdWdpbi5fd2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn8J+UtiAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5fd2FybmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goJ+KchSAnICsgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtb2R1bGUudXNlZC5wdXNoKHBsdWdpbi5uYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGF0dXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBDb21tb24uaW5mbyhzdGF0dXMuam9pbignICAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGZpbmRzIGFsbCBvZiBhIG1vZHVsZSdzIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJucyBhIGZsYXQgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jaWVzXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgICAqL1xyXG4gICAgUGx1Z2luLmRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKG1vZHVsZSwgdHJhY2tlZCkge1xyXG4gICAgICAgIHZhciBwYXJzZWRCYXNlID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShtb2R1bGUpLFxyXG4gICAgICAgICAgICBuYW1lID0gcGFyc2VkQmFzZS5uYW1lO1xyXG5cclxuICAgICAgICB0cmFja2VkID0gdHJhY2tlZCB8fCB7fTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgaW4gdHJhY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb2R1bGUgPSBQbHVnaW4ucmVzb2x2ZShtb2R1bGUpIHx8IG1vZHVsZTtcclxuXHJcbiAgICAgICAgdHJhY2tlZFtuYW1lXSA9IENvbW1vbi5tYXAobW9kdWxlLnVzZXMgfHwgW10sIGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICAgICAgaWYgKFBsdWdpbi5pc1BsdWdpbihkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgUGx1Z2luLnJlZ2lzdGVyKGRlcGVuZGVuY3kpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KSxcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gUGx1Z2luLnJlc29sdmUoZGVwZW5kZW5jeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgJiYgIVBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzKHJlc29sdmVkLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKFxyXG4gICAgICAgICAgICAgICAgICAgICdQbHVnaW4uZGVwZW5kZW5jaWVzOicsIFBsdWdpbi50b1N0cmluZyhyZXNvbHZlZCksICdkb2VzIG5vdCBzYXRpc2Z5JyxcclxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkKSwgJ3VzZWQgYnknLCBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSkgKyAnLidcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcclxuICAgICAgICAgICAgICAgICAgICAnUGx1Z2luLmRlcGVuZGVuY2llczonLCBQbHVnaW4udG9TdHJpbmcoZGVwZW5kZW5jeSksICd1c2VkIGJ5JyxcclxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSksICdjb3VsZCBub3QgYmUgcmVzb2x2ZWQuJ1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQubmFtZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja2VkW25hbWVdLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIFBsdWdpbi5kZXBlbmRlbmNpZXModHJhY2tlZFtuYW1lXVtpXSwgdHJhY2tlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJhY2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBkZXBlbmRlbmN5IHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICogVGhlIGBkZXBlbmRlbmN5YCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybWF0IGAnbW9kdWxlLW5hbWUnYCBvciBgJ21vZHVsZS1uYW1lQHZlcnNpb24nYC5cclxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gaGFuZGxlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBhbHJlYWR5IHJlc29sdmVkIChlLmcuIGEgbW9kdWxlIG9iamVjdCkuXHJcbiAgICAgKiBAbWV0aG9kIGRlcGVuZGVuY3lQYXJzZVxyXG4gICAgICogQHBhcmFtIGRlcGVuZGVuY3kge3N0cmluZ30gVGhlIGRlcGVuZGVuY3kgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBkZXBlbmRlbmN5IHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xyXG4gICAgICAgIGlmIChDb21tb24uaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSAvXltcXHctXSsoQChcXCp8W1xcXn5dP1xcZCtcXC5cXGQrXFwuXFxkKygtWzAtOUEtWmEtei1dKyk/KSk/JC87XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5kZXBlbmRlbmN5UGFyc2U6JywgZGVwZW5kZW5jeSwgJ2lzIG5vdCBhIHZhbGlkIGRlcGVuZGVuY3kgc3RyaW5nLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzBdLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGRlcGVuZGVuY3kuc3BsaXQoJ0AnKVsxXSB8fCAnKidcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kubmFtZSxcclxuICAgICAgICAgICAgcmFuZ2U6IGRlcGVuZGVuY3kucmFuZ2UgfHwgZGVwZW5kZW5jeS52ZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLiAgXHJcbiAgICAgKiBWZXJzaW9ucyBhcmUgc3RyaWN0bHkgb2YgdGhlIGZvcm1hdCBgeC55LnpgIChhcyBpbiBbc2VtdmVyXShodHRwOi8vc2VtdmVyLm9yZy8pKS5cclxuICAgICAqIFZlcnNpb25zIG1heSBvcHRpb25hbGx5IGhhdmUgYSBwcmVyZWxlYXNlIHRhZyBpbiB0aGUgZm9ybWF0IGB4Lnkuei1hbHBoYWAuXHJcbiAgICAgKiBSYW5nZXMgYXJlIGEgc3RyaWN0IHN1YnNldCBvZiBbbnBtIHJhbmdlc10oaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3NlbXZlciNhZHZhbmNlZC1yYW5nZS1zeW50YXgpLlxyXG4gICAgICogT25seSB0aGUgZm9sbG93aW5nIHJhbmdlIHR5cGVzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAgICAgKiAtIFRpbGRlIHJhbmdlcyBlLmcuIGB+MS4yLjNgXHJcbiAgICAgKiAtIENhcmV0IHJhbmdlcyBlLmcuIGBeMS4yLjNgXHJcbiAgICAgKiAtIEV4YWN0IHZlcnNpb24gZS5nLiBgMS4yLjNgXHJcbiAgICAgKiAtIEFueSB2ZXJzaW9uIGAqYFxyXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uUGFyc2VcclxuICAgICAqIEBwYXJhbSByYW5nZSB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSB2ZXJzaW9uIHJhbmdlIHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4udmVyc2lvblBhcnNlID0gZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IC9eXFwqfFtcXF5+XT9cXGQrXFwuXFxkK1xcLlxcZCsoLVswLTlBLVphLXotXSspPyQvO1xyXG5cclxuICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChyYW5nZSkpIHtcclxuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi52ZXJzaW9uUGFyc2U6JywgcmFuZ2UsICdpcyBub3QgYSB2YWxpZCB2ZXJzaW9uIG9yIHJhbmdlLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gcmFuZ2Uuc3BsaXQoJy0nKTtcclxuICAgICAgICByYW5nZSA9IGlkZW50aWZpZXJzWzBdO1xyXG5cclxuICAgICAgICB2YXIgaXNSYW5nZSA9IGlzTmFOKE51bWJlcihyYW5nZVswXSkpLFxyXG4gICAgICAgICAgICB2ZXJzaW9uID0gaXNSYW5nZSA/IHJhbmdlLnN1YnN0cigxKSA6IHJhbmdlLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IENvbW1vbi5tYXAodmVyc2lvbi5zcGxpdCgnLicpLCBmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHBhcnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNSYW5nZTogaXNSYW5nZSxcclxuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcclxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgICBvcGVyYXRvcjogaXNSYW5nZSA/IHJhbmdlWzBdIDogJycsXHJcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0cyxcclxuICAgICAgICAgICAgcHJlcmVsZWFzZTogaWRlbnRpZmllcnNbMV0sXHJcbiAgICAgICAgICAgIG51bWJlcjogcGFydHNbMF0gKiAxZTggKyBwYXJ0c1sxXSAqIDFlNCArIHBhcnRzWzJdXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIHRoZSBnaXZlbiBgcmFuZ2VgLlxyXG4gICAgICogU2VlIGRvY3VtZW50YXRpb24gZm9yIGBQbHVnaW4udmVyc2lvblBhcnNlYCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZm9ybWF0LlxyXG4gICAgICogSWYgYSB2ZXJzaW9uIG9yIHJhbmdlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gYW55IHZlcnNpb24gKGAqYCkgaXMgYXNzdW1lZCB0byBzYXRpc2Z5LlxyXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uU2F0aXNmaWVzXHJcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gcmFuZ2Uge3N0cmluZ30gVGhlIHJhbmdlIHN0cmluZy5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIGByYW5nZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBQbHVnaW4udmVyc2lvblNhdGlzZmllcyA9IGZ1bmN0aW9uKHZlcnNpb24sIHJhbmdlKSB7XHJcbiAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCAnKic7XHJcblxyXG4gICAgICAgIHZhciByYW5nZVBhcnNlZCA9IFBsdWdpbi52ZXJzaW9uUGFyc2UocmFuZ2UpLFxyXG4gICAgICAgICAgICByYW5nZVBhcnRzID0gcmFuZ2VQYXJzZWQucGFydHMsXHJcbiAgICAgICAgICAgIHZlcnNpb25QYXJzZWQgPSBQbHVnaW4udmVyc2lvblBhcnNlKHZlcnNpb24pLFxyXG4gICAgICAgICAgICB2ZXJzaW9uUGFydHMgPSB2ZXJzaW9uUGFyc2VkLnBhcnRzO1xyXG5cclxuICAgICAgICBpZiAocmFuZ2VQYXJzZWQuaXNSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICcqJyB8fCB2ZXJzaW9uID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2VQYXJzZWQub3BlcmF0b3IgPT09ICd+Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25QYXJ0c1swXSA9PT0gcmFuZ2VQYXJ0c1swXSAmJiB2ZXJzaW9uUGFydHNbMV0gPT09IHJhbmdlUGFydHNbMV0gJiYgdmVyc2lvblBhcnRzWzJdID49IHJhbmdlUGFydHNbMl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZVBhcnNlZC5vcGVyYXRvciA9PT0gJ14nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0c1swXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzBdID09PSByYW5nZVBhcnRzWzBdICYmIHZlcnNpb25QYXJzZWQubnVtYmVyID49IHJhbmdlUGFyc2VkLm51bWJlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0c1sxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzFdID09PSByYW5nZVBhcnRzWzFdICYmIHZlcnNpb25QYXJ0c1syXSA+PSByYW5nZVBhcnRzWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uUGFydHNbMl0gPT09IHJhbmdlUGFydHNbMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ZXJzaW9uID09PSByYW5nZSB8fCB2ZXJzaW9uID09PSAnKic7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxyXG4gICAgcXVpY2tEZWNvbXA6IHBvbHlnb25RdWlja0RlY29tcCxcclxuICAgIGlzU2ltcGxlOiBwb2x5Z29uSXNTaW1wbGUsXHJcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXHJcbiAgICBtYWtlQ0NXOiBwb2x5Z29uTWFrZUNDV1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGxpbmVJbnRcclxuICogQHBhcmFtICB7QXJyYXl9ICBsMSAgICAgICAgICBMaW5lIHZlY3RvciAxXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGludGVyc2VjdGlvbiBwb2ludC5cclxuICovXHJcbmZ1bmN0aW9uIGxpbmVJbnQobDEsbDIscHJlY2lzaW9uKXtcclxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xyXG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcclxuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyLCBkZXQ7IC8vIHNjYWxhcnNcclxuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcclxuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcclxuICAgIGMxID0gYTEgKiBsMVswXVswXSArIGIxICogbDFbMF1bMV07XHJcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XHJcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XHJcbiAgICBjMiA9IGEyICogbDJbMF1bMF0gKyBiMiAqIGwyWzBdWzFdO1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xyXG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcclxuICAgICAgICBpWzBdID0gKGIyICogYzEgLSBiMSAqIGMyKSAvIGRldDtcclxuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcclxuICAgIH1cclxuICAgIHJldHVybiBpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXHJcbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcclxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBsaW5lU2VnbWVudHNJbnRlcnNlY3QocDEsIHAyLCBxMSwgcTIpe1xyXG5cdHZhciBkeCA9IHAyWzBdIC0gcDFbMF07XHJcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcclxuXHR2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xyXG5cdHZhciBkYiA9IHEyWzFdIC0gcTFbMV07XHJcblxyXG5cdC8vIHNlZ21lbnRzIGFyZSBwYXJhbGxlbFxyXG5cdGlmKChkYSpkeSAtIGRiKmR4KSA9PT0gMCl7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XHJcblx0dmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpO1xyXG5cclxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBhcmVhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XHJcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMZWZ0KGEsYixjKXtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSxiLGMpID4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMZWZ0T24oYSxiLGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUmlnaHRPbihhLGIsYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8PSAwO1xyXG59XHJcblxyXG52YXIgdG1wUG9pbnQxID0gW10sXHJcbiAgICB0bXBQb2ludDIgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0wXSBUaHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB2ZWN0b3JzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgcmVzdWx0aW5nIHZlY3RvcnMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUuIFVzZSB6ZXJvIGZvciBtYXggcHJlY2lzaW9uLlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGluZWFyKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XHJcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPT09IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcclxuICAgICAgICAgICAgYmMgPSB0bXBQb2ludDI7XHJcblxyXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xyXG4gICAgICAgIGFiWzFdID0gYlsxXS1hWzFdO1xyXG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xyXG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xyXG5cclxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcclxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcclxuICAgICAgICAgICAgbWFnQiA9IE1hdGguc3FydChiY1swXSpiY1swXSArIGJjWzFdKmJjWzFdKSxcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcclxuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3FkaXN0KGEsYil7XHJcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcclxuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xyXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxyXG4gKiBAbWV0aG9kIGF0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BdChwb2x5Z29uLCBpKXtcclxuICAgIHZhciBzID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBwb2x5Z29uIGRhdGFcclxuICogQG1ldGhvZCBjbGVhclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DbGVhcihwb2x5Z29uKXtcclxuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXHJcbiAqIEBtZXRob2QgYXBwZW5kXHJcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BcHBlbmQocG9seWdvbiwgcG9seSwgZnJvbSwgdG8pe1xyXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XHJcbiAgICAgICAgcG9seWdvbi5wdXNoKHBvbHlbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXHJcbiAqIEBtZXRob2QgbWFrZUNDV1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XHJcbiAgICB2YXIgYnIgPSAwLFxyXG4gICAgICAgIHYgPSBwb2x5Z29uO1xyXG5cclxuICAgIC8vIGZpbmQgYm90dG9tIHJpZ2h0IHBvaW50XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XHJcbiAgICAgICAgICAgIGJyID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxyXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xyXG4gICAgICAgIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cclxuICogQG1ldGhvZCByZXZlcnNlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcclxuICAgIHZhciB0bXAgPSBbXTtcclxuICAgIHZhciBOID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcbiAgICAgICAgdG1wLnB1c2gocG9seWdvbi5wb3AoKSk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XHJcblx0XHRwb2x5Z29uW2ldID0gdG1wW2ldO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxyXG4gKiBAbWV0aG9kIGlzUmVmbGV4XHJcbiAqIEBwYXJhbSAge051bWJlcn0gIGlcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25Jc1JlZmxleChwb2x5Z29uLCBpKXtcclxuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XHJcbn1cclxuXHJcbnZhciB0bXBMaW5lMT1bXSxcclxuICAgIHRtcExpbmUyPVtdO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWVcclxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLGIpIHtcclxuICAgIHZhciBwLCBkaXN0LCBsMT10bXBMaW5lMSwgbDI9dG1wTGluZTI7XHJcblxyXG4gICAgaWYgKGlzTGVmdE9uKHBvbHlnb25BdChwb2x5Z29uLCBhICsgMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHlnb24sIGEgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZGlzdCA9IHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gcG9seWdvbi5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxyXG4gICAgICAgICAgICBsMVswXSA9IHBvbHlnb25BdChwb2x5Z29uLCBhKTtcclxuICAgICAgICAgICAgbDFbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgYik7XHJcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xyXG4gICAgICAgICAgICBsMlsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSk7XHJcbiAgICAgICAgICAgIHAgPSBsaW5lSW50KGwxLGwyKTtcclxuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLGosdGFyZ2V0UG9seSl7XHJcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgW107XHJcbiAgICBwb2x5Z29uQ2xlYXIocCk7XHJcbiAgICBpZiAoaSA8IGopIHtcclxuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXHJcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKyl7XHJcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxyXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1qOyBrKyspe1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcclxuICAgICAgICBmb3IodmFyIGs9aTsgazxwb2x5Z29uLmxlbmd0aDsgaysrKXtcclxuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxyXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcclxuICAgIHZhciBtaW49W10sIHRtcDE9W10sIHRtcDI9W10sIHRtcFBvbHkgPSBbXTtcclxuICAgIHZhciBuRGlhZ3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNhblNlZShwb2x5Z29uLCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHRtcDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxyXG4gKiBAbWV0aG9kIGRlY29tcFxyXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb3IgUG9seWdvbiBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkRlY29tcChwb2x5Z29uKXtcclxuICAgIHZhciBlZGdlcyA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKTtcclxuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIHJldHVybiBwb2x5Z29uU2xpY2UocG9seWdvbiwgZWRnZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxyXG4gKiBAbWV0aG9kIHNsaWNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpe1xyXG4gICAgaWYoY3V0RWRnZXMubGVuZ3RoID09PSAwKXtcclxuXHRcdHJldHVybiBbcG9seWdvbl07XHJcbiAgICB9XHJcbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09PTIgJiYgY3V0RWRnZXNbMF1bMF0gaW5zdGFuY2VvZiBBcnJheSl7XHJcblxyXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBDdXQgYWxsIHBvbHlzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcG9seWdvblNsaWNlKHBvbHksIGN1dEVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcclxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xyXG4gICAgICAgIHZhciBpID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF0pO1xyXG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMV0pO1xyXG5cclxuICAgICAgICBpZihpICE9PSAtMSAmJiBqICE9PSAtMSl7XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9seWdvbkNvcHkocG9seWdvbiwgaSxqKSxcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQ29weShwb2x5Z29uLCBqLGkpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cclxuICogQG1ldGhvZCBpc1NpbXBsZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pe1xyXG4gICAgdmFyIHBhdGggPSBwb2x5Z29uLCBpO1xyXG4gICAgLy8gQ2hlY2tcclxuICAgIGZvcihpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xyXG4gICAgZm9yKGk9MTsgaTxwYXRoLmxlbmd0aC0yOyBpKyspe1xyXG4gICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XHJcblx0ZGVsdGEgPSBkZWx0YSB8fCAwO1xyXG5cdHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XHJcblx0dmFyIGIxID0gcDFbMF0gLSBwMlswXTtcclxuXHR2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XHJcblx0dmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcclxuXHR2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xyXG5cdHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcclxuXHR2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xyXG5cclxuXHRpZighc2NhbGFyX2VxKGRldCwwLGRlbHRhKSl7XHJcblx0XHRyZXR1cm4gWygoYjIgKiBjMSkgLSAoYjEgKiBjMikpIC8gZGV0LCAoKGExICogYzIpIC0gKGEyICogYzEpKSAvIGRldF07XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBbMCwwXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFF1aWNrbHkgZGVjb21wb3NlIHRoZSBQb2x5Z29uIGludG8gY29udmV4IHN1Yi1wb2x5Z29ucy5cclxuICogQG1ldGhvZCBxdWlja0RlY29tcFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XHJcbiAqIEBwYXJhbSAge0FycmF5fSBbcmVmbGV4VmVydGljZXNdXHJcbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cclxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW21heGxldmVsXVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUXVpY2tEZWNvbXAocG9seWdvbiwgcmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xyXG4gICAgbWF4bGV2ZWwgPSBtYXhsZXZlbCB8fCAxMDA7XHJcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XHJcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xyXG4gICAgcmVzdWx0ID0gdHlwZW9mKHJlc3VsdCkhPT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XHJcbiAgICByZWZsZXhWZXJ0aWNlcyA9IHJlZmxleFZlcnRpY2VzIHx8IFtdO1xyXG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XHJcblxyXG4gICAgdmFyIHVwcGVySW50PVswLDBdLCBsb3dlckludD1bMCwwXSwgcD1bMCwwXTsgLy8gUG9pbnRzXHJcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcclxuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXHJcbiAgICB2YXIgbG93ZXJQb2x5PVtdLCB1cHBlclBvbHk9W107IC8vIHBvbHlnb25zXHJcbiAgICB2YXIgcG9seSA9IHBvbHlnb24sXHJcbiAgICAgICAgdiA9IHBvbHlnb247XHJcblxyXG4gICAgaWYodi5sZW5ndGggPCAzKXtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV2ZWwrKztcclxuICAgIGlmKGxldmVsID4gbWF4bGV2ZWwpe1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcclxuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcclxuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb24ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXHJcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09PSAodXBwZXJJbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4KzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgscG9seS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwwLGkrMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LGkscG9seS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLHVwcGVySW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgsaSsxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVxcblwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHVwcGVySW5kZXggPCBsb3dlckluZGV4KXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaiAlIHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksaSxjbG9zZXN0SW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGNsb3Nlc3RJbmRleCx2Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksMCxjbG9zZXN0SW5kZXgrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcclxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS5sZW5ndGggPCB1cHBlclBvbHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHkscmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xyXG4gICAgdmFyIG51bSA9IDA7XHJcbiAgICBmb3IodmFyIGk9cG9seWdvbi5sZW5ndGgtMTsgcG9seWdvbi5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xyXG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGklcG9seWdvbi5sZW5ndGgsMSk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudW07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGVxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJcclxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xyXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvcG9seS1kZWNvbXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjMilcclxuICAgIFZFUlRFWF9TSVpFOiAxNixcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBUSUxFTUFQX1ZFUlRFWF9DT1VOVDogNCxcclxuICAgIFRJTEVNQVBfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBUSUxFTUFQX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDQsXHJcbiAgICBNQVhfVElMRU1BUDogMjAwMCxcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy90aWxlbWFwcmVuZGVyZXIvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBJbmRleEJ1ZmZlcjogcmVxdWlyZSgnLi9JbmRleEJ1ZmZlcicpLFxyXG4gICAgUmVuZGVyVGFyZ2V0OiByZXF1aXJlKCcuL1JlbmRlclRhcmdldCcpLFxyXG4gICAgU2hhZGVyOiByZXF1aXJlKCcuL1NoYWRlcicpLFxyXG4gICAgVGV4dHVyZTogcmVxdWlyZSgnLi9UZXh0dXJlJyksXHJcbiAgICBWZXJ0ZXhCdWZmZXI6IHJlcXVpcmUoJy4vVmVydGV4QnVmZmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDYW52YXNTbmFwc2hvdDogcmVxdWlyZSgnLi9DYW52YXNTbmFwc2hvdCcpLFxyXG4gICAgV2ViR0xTbmFwc2hvdDogcmVxdWlyZSgnLi9XZWJHTFNuYXBzaG90JylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zbmFwc2hvdC9TbmFwc2hvdC5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2FtZXJhTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9DYW1lcmFNYW5hZ2VyJyk7XHJcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnknKTtcclxudmFyIExvYWRlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9Mb2FkZXInKTtcclxudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9TZXR0aW5ncycpO1xyXG52YXIgU3RhYmxlU29ydCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycmF5L1N0YWJsZVNvcnQnKTtcclxudmFyIFN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9TdGF0ZU1hbmFnZXInKTtcclxudmFyIFVwZGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvVXBkYXRlTWFuYWdlcicpO1xyXG52YXIgVHdlZW5NYW5hZ2VyID0gcmVxdWlyZSgnLi4vdHdlZW4vVHdlZW5NYW5hZ2VyJyk7XHJcblxyXG52YXIgU3lzdGVtcyA9IGZ1bmN0aW9uIChzdGF0ZSwgY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB0aGlzLnNldHRpbmdzID0gU2V0dGluZ3MuY3JlYXRlKGNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy54ID0gdGhpcy5zZXR0aW5ncy54O1xyXG4gICAgdGhpcy55ID0gdGhpcy5zZXR0aW5ncy55O1xyXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuc2V0dGluZ3Mud2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuc2V0dGluZ3MuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuc29ydENoaWxkcmVuRmxhZyA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBTZXQgYnkgdGhlIEdsb2JhbFN0YXRlTWFuYWdlclxyXG4gICAgdGhpcy5tYXNrID0gbnVsbDtcclxuICAgIHRoaXMuY2FudmFzO1xyXG4gICAgdGhpcy5jb250ZXh0O1xyXG5cclxuICAgIC8vICBDT1JFIChHTE9CQUwpIFNZU1RFTVMgLyBQUk9QRVJUSUVTXHJcblxyXG4gICAgdGhpcy5nYW1lO1xyXG5cclxuICAgIHRoaXMuYW5pbXM7XHJcbiAgICB0aGlzLmNhY2hlO1xyXG4gICAgdGhpcy5pbnB1dDtcclxuICAgIHRoaXMudGV4dHVyZXM7XHJcblxyXG4gICAgLy8gIFJlZmVyZW5jZSB0byBTdGF0ZSBzcGVjaWZpYyBtYW5hZ2VycyAoRmFjdG9yeSwgVHdlZW5zLCBMb2FkZXIsIFBoeXNpY3MsIGV0YylcclxuICAgIHRoaXMuYWRkO1xyXG4gICAgdGhpcy5jYW1lcmFzO1xyXG4gICAgdGhpcy5ldmVudHM7XHJcbiAgICB0aGlzLmxvYWQ7XHJcbiAgICB0aGlzLm1ha2U7XHJcbiAgICB0aGlzLnN0YXRlTWFuYWdlcjtcclxuICAgIHRoaXMudXBkYXRlcztcclxuICAgIHRoaXMudHdlZW5zO1xyXG5cclxuICAgIC8vICBTdGF0ZSBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLmNoaWxkcmVuO1xyXG4gICAgdGhpcy5jb2xvcjtcclxuICAgIHRoaXMuZGF0YTtcclxufTtcclxuXHJcblN5c3RlbXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3lzdGVtcztcclxuXHJcblN5c3RlbXMucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgICAgIFNldHRpbmdzLmluaXQodGhpcy5zZXR0aW5ncywgdGhpcy5nYW1lLmNvbmZpZyk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnNldHRpbmdzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5zZXR0aW5ncy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbXMgPSB0aGlzLmdhbWUuYW5pbXM7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuZ2FtZS5jYWNoZTtcclxuICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nYW1lLmlucHV0O1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLmdhbWUudGV4dHVyZXM7XHJcblxyXG4gICAgICAgIC8vICBTdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzICh0cmFuc2Zvcm0sIGRhdGEsIGNoaWxkcmVuLCBldGMpXHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ29tcG9uZW50LkNoaWxkcmVuKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIG1hbmFnZXJzIChGYWN0b3J5LCBUd2VlbnMsIExvYWRlciwgUGh5c2ljcywgZXRjKVxyXG5cclxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBHYW1lT2JqZWN0RmFjdG9yeSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLmNhbWVyYXMgPSBuZXcgQ2FtZXJhTWFuYWdlcih0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgICAgICB0aGlzLmxvYWQgPSBuZXcgTG9hZGVyKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMubWFrZSA9IG5ldyBHYW1lT2JqZWN0Q3JlYXRvcih0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLnN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSwgZ2FtZSk7XHJcbiAgICAgICAgdGhpcy50d2VlbnMgPSBuZXcgVHdlZW5NYW5hZ2VyKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlcyA9IG5ldyBVcGRhdGVNYW5hZ2VyKHRoaXMuc3RhdGUpO1xyXG5cclxuICAgICAgICB0aGlzLmluamVjdCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbmplY3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIERlZmF1bHRzIHByb3BlcnRpZXMgaW5qZWN0ZWQgaW50byB0aGUgU3RhdGVcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmFuaW1zID0gdGhpcy5hbmltcztcclxuICAgICAgICB0aGlzLnN0YXRlLmNhY2hlID0gdGhpcy5jYWNoZTtcclxuICAgICAgICB0aGlzLnN0YXRlLmlucHV0ID0gdGhpcy5pbnB1dDtcclxuICAgICAgICB0aGlzLnN0YXRlLnRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5hZGQgPSB0aGlzLmFkZDtcclxuICAgICAgICB0aGlzLnN0YXRlLm1ha2UgPSB0aGlzLm1ha2U7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW1lcmFzID0gdGhpcy5jYW1lcmFzO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuZXZlbnRzID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5sb2FkID0gdGhpcy5sb2FkO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xyXG4gICAgICAgIHRoaXMuc3RhdGUuc3RhdGUgPSB0aGlzLnN0YXRlTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnN0YXRlLnR3ZWVucyA9IHRoaXMudHdlZW5zO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICB0aGlzLnN0YXRlLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB0aGlzLnN0YXRlLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnR3ZWVucy5iZWdpbih0aW1lKTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLmxpc3Q7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpc3RbaV0ucHJlVXBkYXRlKHRpbWUsIGRlbHRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5zLnVwZGF0ZSh0aW1lLCBkZWx0YSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhcy51cGRhdGUodGltZSwgZGVsdGEpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZS5jYWxsKHRoaXMuc3RhdGUsIHRpbWUsIGRlbHRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIENhbGxlZCBqdXN0IG9uY2UgcGVyIGZyYW1lLCByZWdhcmRsZXNzIG9mIHNwZWVkXHJcblxyXG4gICAgLypcclxuICAgIGJlZ2luOiBmdW5jdGlvbiAodGltZXN0YW1wLCBmcmFtZURlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5jaGlsZHJlbi5saXN0O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsaXN0W2ldLnByZVVwZGF0ZSh0aW1lc3RhbXAsIGZyYW1lRGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFBvdGVudGlhbGx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUgKG9uIHN1cGVyLWZhc3Qgc3lzdGVtcylcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwLCBwaHlzaWNzU3RlcClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbWVyYXMudXBkYXRlKHRpbWVzdGVwKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUuY2FsbCh0aGlzLnN0YXRlLCB0aW1lc3RlcCwgcGh5c2ljc1N0ZXApO1xyXG4gICAgfSxcclxuICAgICovXHJcblxyXG4gICAgLy8gIENhbGxlZCBqdXN0IG9uY2UgcGVyIGZyYW1lXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uLCByZW5kZXJlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmlzaWJsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNvcnRDaGlsZHJlbkZsYWcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdGFibGVTb3J0LmlucGxhY2UodGhpcy5jaGlsZHJlbi5saXN0LCB0aGlzLnNvcnRaKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc29ydENoaWxkcmVuRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5jaGlsZHJlbiwgaW50ZXJwb2xhdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnRaOiBmdW5jdGlvbiAoY2hpbGRBLCBjaGlsZEIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkQS5feiAtIGNoaWxkQi5fejtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdGF0ZS9TeXN0ZW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21DZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcclxuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRCb3R0b20oY29udGFpbmVyKSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbkJvdHRvbUNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIEluQm90dG9tTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluQm90dG9tTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgSW5Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkJvdHRvbVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XHJcbnZhciBDZW50ZXJPbiA9IHJlcXVpcmUoJy4uL2JvdW5kcy9DZW50ZXJPbicpO1xyXG5cclxudmFyIEluQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIENlbnRlck9uKGdhbWVPYmplY3QsIEdldENlbnRlclgoY29udGFpbmVyKSArIG9mZnNldFgsIEdldENlbnRlclkoY29udGFpbmVyKSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbkNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRMZWZ0Jyk7XHJcbnZhciBTZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclknKTtcclxuXHJcbnZhciBJbkxlZnRDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRMZWZ0KGNvbnRhaW5lcikgLSBvZmZzZXRYKTtcclxuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShjb250YWluZXIpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluTGVmdENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JbkxlZnRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIEluUmlnaHRDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0UmlnaHQoY29udGFpbmVyKSArIG9mZnNldFgpO1xyXG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5SaWdodENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcclxuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRUb3AoY29udGFpbmVyKSAtIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJblRvcENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIEluVG9wTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xyXG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChjb250YWluZXIpIC0gb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluVG9wTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgSW5Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKGNvbnRhaW5lcikgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1sZWZ0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIFRPUF9MRUZUOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgVE9QX0NFTlRFUjogMSxcclxuXHJcbiAgICAvKipcclxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSB0b3AtcmlnaHQgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgVE9QX1JJR0hUOiAyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtdG9wIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfVE9QOiAzLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtY2VudGVyIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfQ0VOVEVSOiA0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtYm90dG9tIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIExFRlRfQk9UVE9NOiA1LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXHJcbiAgICAqIEBjb25zdGFudFxyXG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgICBDRU5URVI6IDYsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgcmlnaHQtdG9wIGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIFJJR0hUX1RPUDogNyxcclxuXHJcbiAgICAvKipcclxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSByaWdodC1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgUklHSFRfQ0VOVEVSOiA4LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHJpZ2h0LWJvdHRvbSBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXHJcbiAgICAqIEBjb25zdGFudFxyXG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgICBSSUdIVF9CT1RUT006IDksXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLWxlZnQgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgQk9UVE9NX0xFRlQ6IDEwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGJvdHRvbS1jZW50ZXIgYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxyXG4gICAgKiBAY29uc3RhbnRcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgQk9UVE9NX0NFTlRFUjogMTEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cclxuICAgICogQGNvbnN0YW50XHJcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxyXG4gICAgKi9cclxuICAgIEJPVFRPTV9SSUdIVDogMTJcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQ3JlYXRlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgbnVtYmVycyAodXN1YWxseSBpbnRlZ2VycyksIGJldHdlZW4sIGFuZCBpbmNsdXNpdmUgb2YsXHJcbiogdGhlIGdpdmVuIGBzdGFydGAgYW5kIGBlbmRgIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGU6XHJcbipcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoMiwgNCk7IC8vIGFycmF5ID0gWzIsIDMsIDRdYFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgwLCA5KTsgLy8gYXJyYXkgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1gXHJcbiogXHJcbiogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBudW1iZXJBcnJheVN0ZXAoc3RhcnQsIGVuZCwgMSlgLlxyXG4qIFxyXG4qIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgcHJlZml4IGFuZCAvIG9yIHN1ZmZpeCBzdHJpbmcuIElmIGdpdmVuIHRoZSBhcnJheSB3aWxsIGNvbnRhaW5cclxuKiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuIEZvciBleGFtcGxlOlxyXG4qIFxyXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgxLCA0LCAnTGV2ZWwgJyk7IC8vIGFycmF5ID0gW1wiTGV2ZWwgMVwiLCBcIkxldmVsIDJcIiwgXCJMZXZlbCAzXCIsIFwiTGV2ZWwgNFwiXWBcclxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoNSwgNywgJ0hELScsICcucG5nJyk7IC8vIGFycmF5ID0gW1wiSEQtNS5wbmdcIiwgXCJIRC02LnBuZ1wiLCBcIkhELTcucG5nXCJdYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBhcnJheSBzdGFydHMgd2l0aC5cclxuKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGFycmF5IGNvbnRhaW5zLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSAtIE9wdGlvbmFsIHByZWZpeCB0byBwbGFjZSBiZWZvcmUgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXHJcbiogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXhdIC0gT3B0aW9uYWwgc3VmZml4IHRvIHBsYWNlIGFmdGVyIHRoZSBudW1iZXIuIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gc3RyaW5ncywgbm90IGludGVnZXJzLlxyXG4qIEByZXR1cm4ge251bWJlcltdfHN0cmluZ1tdfSBUaGUgYXJyYXkgb2YgbnVtYmVyIHZhbHVlcywgb3Igc3RyaW5ncyBpZiBhIHByZWZpeCBvciBzdWZmaXggd2FzIHByb3ZpZGVkLlxyXG4qL1xyXG52YXIgTnVtYmVyQXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcHJlZml4LCBzdWZmaXgpXHJcbntcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gKHByZWZpeCkgPyBwcmVmaXggKyBpLnRvU3RyaW5nKCkgOiBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3VmZml4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuY29uY2F0KHN1ZmZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTaHVmZmxlID0gcmVxdWlyZSgnLi9TaHVmZmxlJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIEJ1aWxkQ2h1bmsgPSBmdW5jdGlvbiAoYSwgYiwgcXR5KVxyXG57XHJcbiAgICB2YXIgb3V0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYUluZGV4ID0gMDsgYUluZGV4IDwgYS5sZW5ndGg7IGFJbmRleCsrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGJJbmRleCA9IDA7IGJJbmRleCA8IGIubGVuZ3RoOyBiSW5kZXgrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXR5OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsgYTogYVthSW5kZXhdLCBiOiBiW2JJbmRleF0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8vICBvcHRpb25zID0gcmVwZWF0LCByYW5kb20sIHJhbmRvbUIsIHlveW8sIG1heCwgcXR5XHJcblxyXG4vLyAgUmFuZ2UgKFthLGIsY10sIFsxLDIsM10pID1cclxuLy8gIGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGMxLCBjMiwgYzNcclxuXHJcbi8vICBSYW5nZSAoW2EsYl0sIFsxLDIsM10sIHF0eSA9IDMpID1cclxuLy8gIGExLCBhMSwgYTEsIGEyLCBhMiwgYTIsIGEzLCBhMywgYTMsIGIxLCBiMSwgYjEsIGIyLCBiMiwgYjIsIGIzLCBiMywgYjNcclxuXHJcbi8vICBSYW5nZSAoW2EsYixjXSwgWzEsMiwzXSwgcmVwZWF0IHgxKSA9XHJcbi8vICBhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBjMSwgYzIsIGMzLCBhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBjMSwgYzIsIGMzXHJcblxyXG4vLyAgUmFuZ2UgKFthLGJdLCBbMSwyXSwgcmVwZWF0IC0xID0gZW5kbGVzcywgbWF4ID0gMTQpID1cclxuLy8gIE1heWJlIGlmIG1heCBpcyBzZXQgdGhlbiByZXBlYXQgZ29lcyB0byAtMSBhdXRvbWF0aWNhbGx5P1xyXG4vLyAgYTEsIGEyLCBiMSwgYjIsIGExLCBhMiwgYjEsIGIyLCBhMSwgYTIsIGIxLCBiMiwgYTEsIGEyIChjYXBwZWQgYXQgMTQgZWxlbWVudHMpXHJcblxyXG4vLyAgUmFuZ2UgKFthXSwgWzEsMiwzLDQsNV0sIHJhbmRvbSA9IHRydWUpID1cclxuLy8gIGE0LCBhMSwgYTUsIGEyLCBhM1xyXG5cclxuLy8gIFJhbmdlIChbYSwgYl0sIFsxLDIsM10sIHJhbmRvbSA9IHRydWUpID1cclxuLy8gIGIzLCBhMiwgYTEsIGIxLCBhMywgYjJcclxuXHJcbi8vICBSYW5nZSAoW2EsIGIsIGNdLCBbMSwyLDNdLCByYW5kb21CID0gdHJ1ZSkgPVxyXG4vLyAgYTMsIGExLCBhMiwgYjIsIGIzLCBiMSwgYzEsIGMzLCBjMlxyXG5cclxuLy8gIFJhbmdlIChbYV0sIFsxLDIsMyw0LDVdLCB5b3lvID0gdHJ1ZSkgPVxyXG4vLyAgYTEsIGEyLCBhMywgYTQsIGE1LCBhNSwgYTQsIGEzLCBhMiwgYTFcclxuXHJcbi8vICBSYW5nZSAoW2EsIGJdLCBbMSwyLDNdLCB5b3lvID0gdHJ1ZSkgPVxyXG4vLyAgYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYjMsIGIyLCBiMSwgYTMsIGEyLCBhMVxyXG5cclxudmFyIFJhbmdlID0gZnVuY3Rpb24gKGEsIGIsIG9wdGlvbnMpXHJcbntcclxuICAgIHZhciBtYXggPSBHZXRWYWx1ZShvcHRpb25zLCAnbWF4JywgMCk7XHJcbiAgICB2YXIgcXR5ID0gR2V0VmFsdWUob3B0aW9ucywgJ3F0eScsIDEpO1xyXG4gICAgdmFyIHJhbmRvbSA9IEdldFZhbHVlKG9wdGlvbnMsICdyYW5kb20nLCBmYWxzZSk7XHJcbiAgICB2YXIgcmFuZG9tQiA9IEdldFZhbHVlKG9wdGlvbnMsICdyYW5kb21CJywgZmFsc2UpO1xyXG4gICAgdmFyIHJlcGVhdCA9IEdldFZhbHVlKG9wdGlvbnMsICdyZXBlYXQnLCAwKTtcclxuICAgIHZhciB5b3lvID0gR2V0VmFsdWUob3B0aW9ucywgJ3lveW8nLCBmYWxzZSk7XHJcblxyXG4gICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgIGlmIChyYW5kb21CKVxyXG4gICAge1xyXG4gICAgICAgIFNodWZmbGUoYik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEVuZGxlc3MgcmVwZWF0LCBzbyBsaW1pdCBieSBtYXhcclxuICAgIGlmIChyZXBlYXQgPT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChtYXggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXBlYXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgV29yayBvdXQgaG93IG1hbnkgcmVwZWF0cyB3ZSBuZWVkXHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IChhLmxlbmd0aCAqIGIubGVuZ3RoKSAqIHF0eTtcclxuXHJcbiAgICAgICAgICAgIGlmICh5b3lvKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXBlYXQgPSBNYXRoLmNlaWwobWF4IC8gdG90YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSByZXBlYXQ7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2h1bmsgPSBCdWlsZENodW5rKGEsIGIsIHF0eSk7XHJcblxyXG4gICAgICAgIGlmIChyYW5kb20pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaHVmZmxlKGNodW5rKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG91dCA9IG91dC5jb25jYXQoY2h1bmspO1xyXG5cclxuICAgICAgICBpZiAoeW95bylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNodW5rLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobWF4KVxyXG4gICAge1xyXG4gICAgICAgIG91dC5zcGxpY2UobWF4KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9SYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgYXJyYXkgdG8gdGhlIGVuZCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxyXG4qIFRoZSBcInJvdGF0aW9uXCIgaGFwcGVucyB0byB0aGUgbGVmdC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMucm90YXRlXHJcbiogQHBhcmFtIHthbnlbXX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2hpZnQvcm90YXRlLiBUaGUgYXJyYXkgaXMgbW9kaWZpZWQuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXHJcbiogQHJldHVybiB7YW55fSBUaGUgc2hpZnRlZCB2YWx1ZS5cclxuKi9cclxudmFyIFJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxyXG57XHJcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5zaGlmdCgpO1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUxlZnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYXJyYXkvUm90YXRlTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIHRoZSBzdGFydCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxyXG4qIFRoZSBcInJvdGF0aW9uXCIgaGFwcGVucyB0byB0aGUgcmlnaHQuXHJcbipcclxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbD0xXSAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gc2hpZnQgdGhlIGFycmF5LiBPbmx5IHRoZSBtb3N0IHJlY2VudGx5IHNoaWZ0ZWQgZWxlbWVudCBpcyByZXR1cm5lZC5cclxuKiBAcmV0dXJuIHthbnl9IFRoZSBzaGlmdGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgUm90YXRlUmlnaHQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxyXG57XHJcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5wb3AoKTtcclxuICAgICAgICBhcnJheS51bnNoaWZ0KGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9Sb3RhdGVSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEEgc3RhbmRhcmQgRmlzaGVyLVlhdGVzIEFycmF5IHNodWZmbGUgaW1wbGVtZW50YXRpb24gd2hpY2ggbW9kaWZpZXMgdGhlIGFycmF5IGluIHBsYWNlLlxyXG4qXHJcbiogQG1ldGhvZFxyXG4qIEBwYXJhbSB7YW55W119IGFycmF5IC0gVGhlIGFycmF5IHRvIHNodWZmbGUuXHJcbiogQHJldHVybiB7YW55W119IFRoZSBvcmlnaW5hbCBhcnJheSwgbm93IHNodWZmbGVkLlxyXG4qL1xyXG52YXIgU2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcclxuICAgICAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xyXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XHJcbiAgICAgICAgYXJyYXlbal0gPSB0ZW1wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2h1ZmZsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9TaHVmZmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFJlbW92ZXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIGl0XHJcbi8vICB3aXRob3V0IGNyZWF0aW5nIGdjIChsaWtlIHRoZSBuYXRpdmUgc3BsaWNlIGRvZXMpXHJcbi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1pa2UgUmVpbnN0ZWluXHJcblxyXG52YXIgU3BsaWNlT25lID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleClcclxue1xyXG4gICAgaWYgKGluZGV4ID49IGFycmF5Lmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgdmFyIGl0ZW0gPSBhcnJheVtpbmRleF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGVuOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgYXJyYXkubGVuZ3RoID0gbGVuO1xyXG5cclxuICAgIHJldHVybiBpdGVtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGxpY2VPbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYXJyYXkvU3BsaWNlT25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuL1NldENlbnRlclgnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuL1NldENlbnRlclknKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cclxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxyXG4qXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcclxuKi9cclxuXHJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG57XHJcbiAgICBTZXRDZW50ZXJYKGdhbWVPYmplY3QsIHgpO1xyXG5cclxuICAgIHJldHVybiBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIHkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvQ2VudGVyT24uanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkuaXNQbGFpbk9iamVjdC5cclxuKiBBIHBsYWluIG9iamVjdCBpcyBhbiBvYmplY3Qgd2hvc2UgaW50ZXJuYWwgY2xhc3MgcHJvcGVydHkgaXMgW29iamVjdCBPYmplY3RdLlxyXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLmlzUGxhaW5PYmplY3RcclxuKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHBsYWluLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBJc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKG9iailcclxue1xyXG4gICAgLy8gTm90IHBsYWluIG9iamVjdHM6XHJcbiAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXHJcbiAgICAvLyAtIERPTSBub2Rlc1xyXG4gICAgLy8gLSB3aW5kb3dcclxuICAgIGlmICh0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcgfHwgb2JqLm5vZGVUeXBlIHx8IG9iaiA9PT0gb2JqLndpbmRvdylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogRmlyZWZveCA8MjBcclxuICAgIC8vIFRoZSB0cnkvY2F0Y2ggc3VwcHJlc3NlcyBleGNlcHRpb25zIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYWNjZXNzXHJcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxNDYyMlxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcclxuICAgIC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElzUGxhaW5PYmplY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUYWtlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBwYWRzIGl0IG91dCwgdG8gdGhlIGxlbmd0aCByZXF1aXJlZCwgdXNpbmcgdGhlIGNoYXJhY3RlclxyXG4qIHNwZWNpZmllZC4gRm9yIGV4YW1wbGUgaWYgeW91IG5lZWQgYSBzdHJpbmcgdG8gYmUgNiBjaGFyYWN0ZXJzIGxvbmcsIHlvdSBjYW4gY2FsbDpcclxuKlxyXG4qIGBwYWQoJ2JvYicsIDYsICctJywgMilgXHJcbipcclxuKiBUaGlzIHdvdWxkIHJldHVybjogYGJvYi0tLWAgYXMgaXQgaGFzIHBhZGRlZCBpdCBvdXQgdG8gNiBjaGFyYWN0ZXJzLCB1c2luZyB0aGUgYC1gIG9uIHRoZSByaWdodC5cclxuKlxyXG4qIFlvdSBjYW4gYWxzbyB1c2UgaXQgdG8gcGFkIG51bWJlcnMgKHRoZXkgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBzdHJpbmdzKTpcclxuKiBcclxuKiBgcGFkKDUxMiwgNiwgJzAnLCAxKWBcclxuKlxyXG4qIFdvdWxkIHJldHVybjogYDAwMDUxMmAgd2l0aCB0aGUgc3RyaW5nIHBhZGRlZCB0byB0aGUgbGVmdC5cclxuKlxyXG4qIElmIHlvdSBkb24ndCBzcGVjaWZ5IGEgZGlyZWN0aW9uIGl0J2xsIHBhZCB0byBib3RoIHNpZGVzOlxyXG4qIFxyXG4qIGBwYWQoJ2M2NCcsIDcsICcqJylgXHJcbipcclxuKiBXb3VsZCByZXR1cm46IGAqKmM2NCoqYFxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMucGFkXHJcbiogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0YXJnZXQgc3RyaW5nLiBgdG9TdHJpbmcoKWAgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHN0cmluZywgd2hpY2ggbWVhbnMgeW91IGNhbiBhbHNvIHBhc3MgaW4gY29tbW9uIGRhdGEgdHlwZXMgbGlrZSBudW1iZXJzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBiZSBhZGRlZC5cclxuKiBAcGFyYW0ge3N0cmluZ30gW3BhZD1cIiBcIl0gLSBUaGUgc3RyaW5nIHRvIHBhZCBpdCBvdXQgd2l0aCAoZGVmYXVsdHMgdG8gYSBzcGFjZSkuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBbZGlyPTNdIC0gVGhlIGRpcmVjdGlvbiBkaXIgPSAxIChsZWZ0KSwgMiAocmlnaHQpLCAzIChib3RoKS5cclxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkZWQgc3RyaW5nLlxyXG4qL1xyXG52YXIgUGFkID0gZnVuY3Rpb24gKHN0ciwgbGVuLCBwYWQsIGRpcilcclxue1xyXG4gICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7IGxlbiA9IDA7IH1cclxuICAgIGlmIChwYWQgPT09IHVuZGVmaW5lZCkgeyBwYWQgPSAnICc7IH1cclxuICAgIGlmIChkaXIgPT09IHVuZGVmaW5lZCkgeyBkaXIgPSAzOyB9XHJcblxyXG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgdmFyIHBhZGxlbiA9IDA7XHJcblxyXG4gICAgaWYgKGxlbiArIDEgPj0gc3RyLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICBzd2l0Y2ggKGRpcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHN0ciA9IG5ldyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLmNlaWwoKHBhZGxlbiA9IGxlbiAtIHN0ci5sZW5ndGgpIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhZGxlbiAtIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc3RyID0gbmV3IEFycmF5KGxlZnQgKyAxKS5qb2luKHBhZCkgKyBzdHIgKyBuZXcgQXJyYXkocmlnaHQgKyAxKS5qb2luKHBhZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIgKyBuZXcgQXJyYXkobGVuICsgMSAtIHN0ci5sZW5ndGgpLmpvaW4ocGFkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvc3RyaW5nL1BhZC5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ29uZmlnID0gcmVxdWlyZSgnLi9Db25maWcnKTtcclxudmFyIERlYnVnSGVhZGVyID0gcmVxdWlyZSgnLi9EZWJ1Z0hlYWRlcicpO1xyXG52YXIgRGV2aWNlID0gcmVxdWlyZSgnLi4vZGV2aWNlJyk7XHJcblxyXG52YXIgQWRkVG9ET00gPSByZXF1aXJlKCcuLi9kb20vQWRkVG9ET00nKTtcclxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSByZXF1aXJlKCcuLi9kb20vRE9NQ29udGVudExvYWRlZCcpO1xyXG52YXIgVmlzaWJpbGl0eUhhbmRsZXIgPSByZXF1aXJlKCcuL1Zpc2liaWxpdHlIYW5kbGVyJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcblxyXG52YXIgVGltZVN0ZXAgPSByZXF1aXJlKCcuL1RpbWVTdGVwJyk7XHJcbnZhciBDcmVhdGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ3JlYXRlUmVuZGVyZXInKTtcclxudmFyIEdsb2JhbElucHV0TWFuYWdlciA9IHJlcXVpcmUoJy4uL2lucHV0L0dsb2JhbElucHV0TWFuYWdlcicpO1xyXG52YXIgR2xvYmFsU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vc3RhdGUvR2xvYmFsU3RhdGVNYW5hZ2VyJyk7XHJcbnZhciBBbmltYXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL21hbmFnZXIvQW5pbWF0aW9uTWFuYWdlcicpO1xyXG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlcicpO1xyXG52YXIgRGF0YSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGF0YScpO1xyXG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZS9DYWNoZScpO1xyXG5cclxudmFyIEdhbWUgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcoY29uZmlnKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5pc0Jvb3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtFdmVudERpc3BhdGNoZXJ9IGV2ZW50cyAtIEdsb2JhbCAvIEdsb2JhbCBHYW1lIFN5c3RlbSBFdmVudHNcclxuICAgICovXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuQW5pbWF0aW9uTWFuYWdlcn0gYW5pbXMgLSBSZWZlcmVuY2UgdG8gdGhlIFBoYXNlciBBbmltYXRpb24gTWFuYWdlci5cclxuICAgICovXHJcbiAgICB0aGlzLmFuaW1zID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmVNYW5hZ2VyfSB0ZXh0dXJlcyAtIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIFRleHR1cmUgTWFuYWdlci5cclxuICAgICovXHJcbiAgICB0aGlzLnRleHR1cmVzID0gbmV3IFRleHR1cmVNYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5DYWNoZX0gY2FjaGUgLSBSZWZlcmVuY2UgdG8gdGhlIGFzc2V0cyBjYWNoZS5cclxuICAgICovXHJcbiAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkRhdGF9IHJlZ2lzdHJ5IC0gR2FtZSB3aWRlIGRhdGEgc3RvcmUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBEYXRhKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5JbnB1dH0gaW5wdXQgLSBSZWZlcmVuY2UgdG8gdGhlIGlucHV0IG1hbmFnZXJcclxuICAgICovXHJcbiAgICB0aGlzLmlucHV0ID0gbmV3IEdsb2JhbElucHV0TWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlcn0gc3RhdGUgLSBUaGUgU3RhdGVNYW5hZ2VyLiBQaGFzZXIgaW5zdGFuY2Ugc3BlY2lmaWMuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBHbG9iYWxTdGF0ZU1hbmFnZXIodGhpcywgdGhpcy5jb25maWcuc3RhdGVDb25maWcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5EZXZpY2V9IGRldmljZSAtIENvbnRhaW5zIGRldmljZSBpbmZvcm1hdGlvbiBhbmQgY2FwYWJpbGl0aWVzIChzaW5nbGV0b24pXHJcbiAgICAqL1xyXG4gICAgdGhpcy5kZXZpY2UgPSBEZXZpY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLk1haW5Mb29wfSBtYWlubG9vcCAtIE1haW4gTG9vcCBoYW5kbGVyLlxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgdGhpcy5sb29wID0gbmV3IFRpbWVTdGVwKHRoaXMsIHRoaXMuY29uZmlnLmZwcyk7XHJcblxyXG4gICAgLy8gIFdhaXQgZm9yIHRoZSBET00gUmVhZHkgZXZlbnQsIHRoZW4gY2FsbCBib290LlxyXG4gICAgRE9NQ29udGVudExvYWRlZCh0aGlzLmJvb3QuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgLy8gIEZvciBkZWJ1Z2dpbmcgb25seVxyXG4gICAgd2luZG93LmdhbWUgPSB0aGlzO1xyXG59O1xyXG5cclxuR2FtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYW1lO1xyXG5cclxuR2FtZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmlzQm9vdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcucHJlQm9vdCgpO1xyXG5cclxuICAgICAgICBEZWJ1Z0hlYWRlcih0aGlzKTtcclxuXHJcbiAgICAgICAgQ3JlYXRlUmVuZGVyZXIodGhpcyk7XHJcblxyXG4gICAgICAgIEFkZFRvRE9NKHRoaXMuY2FudmFzLCB0aGlzLmNvbmZpZy5wYXJlbnQpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zLmJvb3QodGhpcy50ZXh0dXJlcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUuYm9vdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmlucHV0LmJvb3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZy5wb3N0Qm9vdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvb3Auc3RhcnQodGhpcy5zdGVwLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBWaXNpYmlsaXR5SGFuZGxlcih0aGlzLmV2ZW50cyk7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdISURERU4nLCB0aGlzLm9uSGlkZGVuLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdWSVNJQkxFJywgdGhpcy5vblZpc2libGUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ09OX0JMVVInLCB0aGlzLm9uQmx1ci5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignT05fRk9DVVMnLCB0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lLCBkZWx0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5zdGF0ZS5hY3RpdmU7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHJcbiAgICAgICAgLy8gIEdsb2JhbCBNYW5hZ2VycyAoVGltZSwgSW5wdXQsIGV0YylcclxuXHJcbiAgICAgICAgdGhpcy5pbnB1dC51cGRhdGUodGltZSwgZGVsdGEpO1xyXG5cclxuICAgICAgICAvLyAgU3RhdGVzXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYWN0aXZlW2ldLnN0YXRlLnN5cy5zdGVwKHRpbWUsIGRlbHRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZW5kZXJcclxuXHJcbiAgICAgICAgLy8gdmFyIGludGVycG9sYXRpb24gPSB0aGlzLmZyYW1lRGVsdGEgLyB0aGlzLnRpbWVzdGVwO1xyXG5cclxuICAgICAgICByZW5kZXJlci5wcmVSZW5kZXIoKTtcclxuXHJcbiAgICAgICAgLy8gIFRoaXMgdXNlcyBhY3RpdmUubGVuZ3RoLCBpbiBjYXNlIHN0YXRlLnVwZGF0ZSByZW1vdmVkIHRoZSBzdGF0ZSBmcm9tIHRoZSBhY3RpdmUgbGlzdFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhY3RpdmVbaV0uc3RhdGUuc3lzLnJlbmRlcigwLCByZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlci5wb3N0UmVuZGVyKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uSGlkZGVuOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblZpc2libGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5sb29wLnJlc3VtZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkJsdXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5sb29wLmJsdXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Gb2N1czogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxvb3AuZm9jdXMoKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib290L0dhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkNyZWF0ZVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgXHJcbiAgICBHZW5lcmF0ZVRleHR1cmU6IHJlcXVpcmUoJy4vR2VuZXJhdGVUZXh0dXJlJyksXHJcbiAgICBHcmlkOiByZXF1aXJlKCcuL0dyaWQnKSxcclxuICAgIFBhbGV0dGVzOiByZXF1aXJlKCcuL3BhbGV0dGVzJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5ET01cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEFkZEV2ZW50TGlzdGVuZXI6IHJlcXVpcmUoJy4vQWRkRXZlbnRMaXN0ZW5lcicpLFxyXG4gICAgQWRkVG9ET006IHJlcXVpcmUoJy4vQWRkVG9ET00nKSxcclxuICAgIENhbnZhc0ludGVycG9sYXRpb246IHJlcXVpcmUoJy4vQ2FudmFzSW50ZXJwb2xhdGlvbicpLFxyXG4gICAgQ2FudmFzUG9vbDogcmVxdWlyZSgnLi9DYW52YXNQb29sJyksXHJcbiAgICBET01Db250ZW50TG9hZGVkOiByZXF1aXJlKCcuL0RPTUNvbnRlbnRMb2FkZWQnKSxcclxuICAgIFBhcnNlWE1MOiByZXF1aXJlKCcuL1BhcnNlWE1MJyksXHJcbiAgICBSZW1vdmVFdmVudExpc3RlbmVyOiByZXF1aXJlKCcuL1JlbW92ZUV2ZW50TGlzdGVuZXInKSxcclxuICAgIFJlbW92ZUZyb21ET006IHJlcXVpcmUoJy4vUmVtb3ZlRnJvbURPTScpLFxyXG4gICAgUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiByZXF1aXJlKCcuL1JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxyXG4gICAgU21vb3RoaW5nOiByZXF1aXJlKCcuL1Ntb290aGluZycpLFxyXG4gICAgVG91Y2hBY3Rpb246IHJlcXVpcmUoJy4vVG91Y2hBY3Rpb24nKSxcclxuICAgIFVzZXJTZWxlY3Q6IHJlcXVpcmUoJy4vVXNlclNlbGVjdCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBSZXF1aXJlZCwgYnV0IGRvbid0IG5lZWQgUGhhc2VyIGxldmVsIGV4cG9ydHNcclxuLy8gIChtYXliZSB0aGVzZSBzaG91bGQgYmUgUGhhc2VyIGV4cG9ydCBsZXZlbD8pXHJcblxyXG5yZXF1aXJlKCcuL2JsaXR0ZXIvQmxpdHRlckZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL2ltYWdlL0ltYWdlRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL3Nwcml0ZS9TcHJpdGVGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vZ3JhcGhpY3MvR3JhcGhpY3NGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9sYXllci9MYXllckZhY3RvcnknKTtcclxucmVxdWlyZSgnLi96b25lL1pvbmVGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vZWZmZWN0bGF5ZXIvRWZmZWN0TGF5ZXJGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vcmVuZGVycGFzcy9SZW5kZXJQYXNzRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL3RpbGVzcHJpdGUvVGlsZVNwcml0ZUZhY3RvcnknKTtcclxucmVxdWlyZSgnLi9tZXNoL01lc2hGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vcXVhZC9RdWFkRmFjdG9yeScpO1xyXG5yZXF1aXJlKCcuL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXBGYWN0b3J5Jyk7XHJcbnJlcXVpcmUoJy4vdGlsZW1hcC9keW5hbWljL1RpbGVtYXBGYWN0b3J5Jyk7XHJcblxyXG4vLyAgUGhhc2VyLkdhbWVPYmplY3RzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGYWN0b3J5OiByZXF1aXJlKCcuL0ZhY3RvcnlDb250YWluZXInKSxcclxuXHJcbiAgICBCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQnKSxcclxuICAgIEJsaXR0ZXI6IHJlcXVpcmUoJy4vYmxpdHRlci9CbGl0dGVyJyksXHJcbiAgICBDb250YWluZXI6IHJlcXVpcmUoJy4vY29udGFpbmVyL0NvbnRhaW5lcicpLFxyXG4gICAgRHluYW1pY0JpdG1hcFRleHQ6IHJlcXVpcmUoJy4vYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0JyksXHJcbiAgICBHcmFwaGljczogcmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljcy5qcycpLFxyXG4gICAgSW1hZ2U6IHJlcXVpcmUoJy4vaW1hZ2UvSW1hZ2UnKSxcclxuICAgIFRpbGVTcHJpdGU6IHJlcXVpcmUoJy4vdGlsZXNwcml0ZS9UaWxlU3ByaXRlJyksXHJcbiAgICBMYXllcjogcmVxdWlyZSgnLi9sYXllci9MYXllcicpLFxyXG4gICAgUmVuZGVyUGFzczogcmVxdWlyZSgnLi9yZW5kZXJwYXNzL1JlbmRlclBhc3MuanMnKSxcclxuICAgIFNwcml0ZTogcmVxdWlyZSgnLi9zcHJpdGUvU3ByaXRlJyksXHJcbiAgICBUZXh0OiByZXF1aXJlKCcuL3RleHQvc3RhdGljL1RleHQnKSxcclxuICAgIFpvbmU6IHJlcXVpcmUoJy4vem9uZS9ab25lJyksXHJcbiAgICBFZmZlY3RMYXllcjogcmVxdWlyZSgnLi9lZmZlY3RsYXllci9FZmZlY3RMYXllcicpLFxyXG4gICAgTWVzaDogcmVxdWlyZSgnLi9tZXNoL01lc2gnKSxcclxuICAgIFF1YWQ6IHJlcXVpcmUoJy4vcXVhZC9RdWFkJyksXHJcbiAgICBTdGF0aWNUaWxlbWFwOiByZXF1aXJlKCcuL3RpbGVtYXAvc3RhdGljL1N0YXRpY1RpbGVtYXAnKSxcclxuICAgIFRpbGVtYXA6IHJlcXVpcmUoJy4vdGlsZW1hcC9keW5hbWljL1RpbGVtYXAnKSxcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcclxuICAgIENpcmNsZTogcmVxdWlyZSgnLi9jaXJjbGUnKSxcclxuICAgIEVsbGlwc2U6IHJlcXVpcmUoJy4vZWxsaXBzZScpLFxyXG4gICAgSW50ZXJzZWN0czogcmVxdWlyZSgnLi9pbnRlcnNlY3RzJyksXHJcbiAgICBMaW5lOiByZXF1aXJlKCcuL2xpbmUnKSxcclxuICAgIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXHJcbiAgICBQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKSxcclxuICAgIFJlY3RhbmdsZTogcmVxdWlyZSgnLi9yZWN0YW5nbGUnKSxcclxuICAgIFRyaWFuZ2xlOiByZXF1aXJlKCcuL3RyaWFuZ2xlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR3JhcGhpY3NcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJsZW5kTW9kZXM6IHJlcXVpcmUoJy4vYmxlbmRtb2RlcycpLFxyXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vY29sb3InKVxyXG4gIFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5JbnB1dFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgS2V5Ym9hcmQ6IHJlcXVpcmUoJy4va2V5Ym9hcmQnKSxcclxuICAgIE1vdXNlOiByZXF1aXJlKCcuL21vdXNlJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlBoeXNpY3NcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgSW1wYWN0OiByZXF1aXJlKCcuL2ltcGFjdCcpLFxyXG4gICAgUG9seURlY29tcDogcmVxdWlyZSgnLi9wb2x5LWRlY29tcC8nKSxcclxuICAgIE1hdHRlckpTOiByZXF1aXJlKCcuL21hdHRlci1qcy9tb2R1bGUvbWFpbicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vQXJyYXkuZm9yRWFjaCcpO1xyXG5yZXF1aXJlKCcuL0FycmF5LmlzQXJyYXknKTtcclxucmVxdWlyZSgnLi9BdWRpb0NvbnRleHRNb25rZXlQYXRjaCcpO1xyXG5yZXF1aXJlKCcuL2NvbnNvbGUnKTtcclxucmVxdWlyZSgnLi9GdW5jdGlvbi5iaW5kJyk7XHJcbnJlcXVpcmUoJy4vTWF0aC50cnVuYycpO1xyXG5yZXF1aXJlKCcuL3BlcmZvcm1hbmNlLm5vdycpO1xyXG5yZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xyXG5yZXF1aXJlKCcuL1VpbnQzMkFycmF5Jyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5Tb3VuZFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRHluYW1pYzogcmVxdWlyZSgnLi9keW5hbWljJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291bmQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBbGlnbjogcmVxdWlyZSgnLi9hbGlnbi8nKSxcclxuICAgIEFycmF5OiByZXF1aXJlKCcuL2FycmF5LycpLFxyXG4gICAgQm91bmRzOiByZXF1aXJlKCcuL2JvdW5kcy8nKSxcclxuICAgIE9iamVjdHM6IHJlcXVpcmUoJy4vb2JqZWN0LycpLFxyXG4gICAgU3RyaW5nOiByZXF1aXJlKCcuL3N0cmluZy8nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uYW5nbGUgKz0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhbGwgPSBmdW5jdGlvbiAoaXRlbXMsIGNhbGxiYWNrLCB0aGlzQXJnKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvQ2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBjb21wYXJlID0gT2JqZWN0OlxyXG4vLyAge1xyXG4vLyAgICAgIHNjYWxlWDogMC41LFxyXG4vLyAgICAgIHNjYWxlWTogMVxyXG4vLyAgfVxyXG5cclxudmFyIEdldEZpcnN0ID0gZnVuY3Rpb24gKGl0ZW1zLCBjb21wYXJlLCBpbmRleClcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29tcGFyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtW3Byb3BlcnR5XSAhPT0gY29tcGFyZVtwcm9wZXJ0eV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXRjaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Rmlyc3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9HZXRGaXJzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FsaWduL2NvbnN0Jyk7XHJcbnZhciBBbGlnbkluID0gcmVxdWlyZSgnLi4vdXRpbHMvYWxpZ24vQWxpZ25JbicpO1xyXG52YXIgWm9uZSA9IHJlcXVpcmUoJy4uL2dhbWVvYmplY3RzL3pvbmUvWm9uZScpO1xyXG52YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxuXHJcbnZhciB0ZW1wWm9uZSA9IG5ldyBab25lKHt9LCAwLCAwLCAxLCAxKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgbWV0aG9kIGl0ZXJhdGVzIHRocm91Z2ggYWxsIGNoaWxkcmVuIGluIHRoZSBHcm91cCAocmVnYXJkbGVzcyBpZiB0aGV5IGFyZSB2aXNpYmxlIG9yIGV4aXN0KVxyXG4qIGFuZCB0aGVuIGNoYW5nZXMgdGhlaXIgcG9zaXRpb24gc28gdGhleSBhcmUgYXJyYW5nZWQgaW4gYSBHcmlkIGZvcm1hdGlvbi4gQ2hpbGRyZW4gbXVzdCBoYXZlXHJcbiogdGhlIGBhbGlnblRvYCBtZXRob2QgaW4gb3JkZXIgdG8gYmUgcG9zaXRpb25lZCBieSB0aGlzIGNhbGwuIEFsbCBkZWZhdWx0IFBoYXNlciBHYW1lIE9iamVjdHMgaGF2ZVxyXG4qIHRoaXMuXHJcbipcclxuKiBUaGUgZ3JpZCBkaW1lbnNpb25zIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBmb3VyIGFyZ3VtZW50cy4gVGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGFyZ3VtZW50c1xyXG4qIHJlbGF0ZSB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZ3JpZCByZXNwZWN0aXZlbHkuXHJcbipcclxuKiBGb3IgZXhhbXBsZSBpZiB0aGUgR3JvdXAgaGFkIDEwMCBjaGlsZHJlbiBpbiBpdDpcclxuKlxyXG4qIGBHcm91cC5hbGlnbigxMCwgMTAsIDMyLCAzMilgXHJcbipcclxuKiBUaGlzIHdpbGwgYWxpZ24gYWxsIG9mIHRoZSBjaGlsZHJlbiBpbnRvIGEgZ3JpZCBmb3JtYXRpb24gb2YgMTB4MTAsIHVzaW5nIDMyIHBpeGVscyBwZXJcclxuKiBncmlkIGNlbGwuIElmIHlvdSB3YW50IGEgd2lkZXIgZ3JpZCwgeW91IGNvdWxkIGRvOlxyXG4qIFxyXG4qIGBHcm91cC5hbGlnbigyNSwgNCwgMzIsIDMyKWBcclxuKlxyXG4qIFRoaXMgd2lsbCBhbGlnbiB0aGUgY2hpbGRyZW4gaW50byBhIGdyaWQgb2YgMjV4NCwgYWdhaW4gdXNpbmcgMzIgcGl4ZWxzIHBlciBncmlkIGNlbGwuXHJcbipcclxuKiBZb3UgY2FuIGNob29zZSB0byBzZXQgX2VpdGhlcl8gdGhlIGB3aWR0aGAgb3IgYGhlaWdodGAgdmFsdWUgdG8gLTEuIERvaW5nIHNvIHRlbGxzIHRoZSBtZXRob2RcclxuKiB0byBrZWVwIG9uIGFsaWduaW5nIGNoaWxkcmVuIHVudGlsIHRoZXJlIGFyZSBubyBjaGlsZHJlbiBsZWZ0LiBGb3IgZXhhbXBsZSBpZiB0aGlzIEdyb3VwIGhhZFxyXG4qIDQ4IGNoaWxkcmVuIGluIGl0LCB0aGUgZm9sbG93aW5nOlxyXG4qXHJcbiogYEdyb3VwLmFsaWduKC0xLCA4LCAzMiwgMzIpYFxyXG4qXHJcbiogLi4uIHdpbGwgYWxpZ24gdGhlIGNoaWxkcmVuIHNvIHRoYXQgdGhlcmUgYXJlIDggY2hpbGRyZW4gdmVydGljYWxseSAodGhlIHNlY29uZCBhcmd1bWVudCksIFxyXG4qIGFuZCBlYWNoIHJvdyB3aWxsIGNvbnRhaW4gNiBzcHJpdGVzLCBleGNlcHQgdGhlIGxhc3Qgb25lLCB3aGljaCB3aWxsIGNvbnRhaW4gNSAodG90YWxpbmcgNDgpXHJcbipcclxuKiBZb3UgY2FuIGFsc28gZG86XHJcbiogXHJcbiogYEdyb3VwLmFsaWduKDEwLCAtMSwgMzIsIDMyKWBcclxuKlxyXG4qIEluIHRoaXMgY2FzZSBpdCB3aWxsIGNyZWF0ZSBhIGdyaWQgMTAgd2lkZSwgYW5kIGFzIHRhbGwgYXMgaXQgbmVlZHMgdG8gYmUgaW4gb3JkZXIgdG8gZml0XHJcbiogYWxsIG9mIHRoZSBjaGlsZHJlbiBpbi5cclxuKlxyXG4qIFRoZSBgcG9zaXRpb25gIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gY29udHJvbCB3aGVyZSBpbiBlYWNoIGdyaWQgY2VsbCB0aGUgY2hpbGQgaXMgcG9zaXRpb25lZC5cclxuKiBUaGlzIGlzIGEgY29uc3RhbnQgYW5kIGNhbiBiZSBvbmUgb2YgYFBoYXNlci5UT1BfTEVGVGAgKGRlZmF1bHQpLCBgUGhhc2VyLlRPUF9DRU5URVJgLCBcclxuKiBgUGhhc2VyLlRPUF9SSUdIVGAsIGBQaGFzZXIuTEVGVF9DRU5URVJgLCBgUGhhc2VyLkNFTlRFUmAsIGBQaGFzZXIuUklHSFRfQ0VOVEVSYCwgXHJcbiogYFBoYXNlci5CT1RUT01fTEVGVGAsIGBQaGFzZXIuQk9UVE9NX0NFTlRFUmAgb3IgYFBoYXNlci5CT1RUT01fUklHSFRgLlxyXG4qXHJcbiogVGhlIGZpbmFsIGFyZ3VtZW50OyBgb2Zmc2V0YCBsZXRzIHlvdSBzdGFydCB0aGUgYWxpZ25tZW50IGZyb20gYSBzcGVjaWZpYyBjaGlsZCBpbmRleC5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkdyb3VwI2FsaWduXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZ3JpZCBpbiBpdGVtcyAobm90IHBpeGVscykuIFNldCB0byAtMSBmb3IgYSBkeW5hbWljIHdpZHRoLiBJZiAtMSB0aGVuIHlvdSBtdXN0IHNldCBhbiBleHBsaWNpdCBoZWlnaHQgdmFsdWUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBncmlkIGluIGl0ZW1zIChub3QgcGl4ZWxzKS4gU2V0IHRvIC0xIGZvciBhIGR5bmFtaWMgaGVpZ2h0LiBJZiAtMSB0aGVuIHlvdSBtdXN0IHNldCBhbiBleHBsaWNpdCB3aWR0aCB2YWx1ZS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGNlbGxXaWR0aCAtIFRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgY2VsbCwgaW4gcGl4ZWxzLlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gY2VsbEhlaWdodCAtIFRoZSBoZWlnaHQgb2YgZWFjaCBncmlkIGNlbGwsIGluIHBpeGVscy5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcG9zaXRpb24gY29uc3RhbnQuIE9uZSBvZiBgUGhhc2VyLlRPUF9MRUZUYCAoZGVmYXVsdCksIGBQaGFzZXIuVE9QX0NFTlRFUmAsIGBQaGFzZXIuVE9QX1JJR0hUYCwgYFBoYXNlci5MRUZUX0NFTlRFUmAsIGBQaGFzZXIuQ0VOVEVSYCwgYFBoYXNlci5SSUdIVF9DRU5URVJgLCBgUGhhc2VyLkJPVFRPTV9MRUZUYCwgYFBoYXNlci5CT1RUT01fQ0VOVEVSYCBvciBgUGhhc2VyLkJPVFRPTV9SSUdIVGAuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgR3JvdXAgY2hpbGRyZW4gd2VyZSBhbGlnbmVkLCBvdGhlcndpc2UgZmFsc2UuXHJcbiovXHJcbnZhciBHcmlkQWxpZ24gPSBmdW5jdGlvbiAoaXRlbXMsIG9wdGlvbnMpXHJcbntcclxuICAgIHZhciB3aWR0aCA9IEdldFZhbHVlKG9wdGlvbnMsICd3aWR0aCcsIC0xKTtcclxuICAgIHZhciBoZWlnaHQgPSBHZXRWYWx1ZShvcHRpb25zLCAnaGVpZ2h0JywgLTEpO1xyXG4gICAgdmFyIGNlbGxXaWR0aCA9IEdldFZhbHVlKG9wdGlvbnMsICdjZWxsV2lkdGgnLCAxKTtcclxuICAgIHZhciBjZWxsSGVpZ2h0ID0gR2V0VmFsdWUob3B0aW9ucywgJ2NlbGxIZWlnaHQnLCBjZWxsV2lkdGgpO1xyXG4gICAgdmFyIHBvc2l0aW9uID0gR2V0VmFsdWUob3B0aW9ucywgJ3Bvc2l0aW9uJywgQ09OU1QuVE9QX0xFRlQpO1xyXG4gICAgdmFyIHggPSBHZXRWYWx1ZShvcHRpb25zLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRWYWx1ZShvcHRpb25zLCAneScsIDApO1xyXG4gICAgLy8gdmFyIGNlbnRlclggPSBHZXRWYWx1ZShvcHRpb25zLCAnY2VudGVyWCcsIG51bGwpO1xyXG4gICAgLy8gdmFyIGNlbnRlclkgPSBHZXRWYWx1ZShvcHRpb25zLCAnY2VudGVyWScsIG51bGwpO1xyXG5cclxuICAgIHZhciBjeCA9IDA7XHJcbiAgICB2YXIgY3kgPSAwO1xyXG4gICAgdmFyIHcgPSAod2lkdGggKiBjZWxsV2lkdGgpO1xyXG4gICAgdmFyIGggPSAoaGVpZ2h0ICogY2VsbEhlaWdodCk7XHJcblxyXG4gICAgLy8gIElmIHRoZSBHcmlkIGlzIGNlbnRlcmVkIG9uIGEgcG9zaXRpb24gdGhlbiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBpdCBub3dcclxuICAgIC8vIGlmIChjZW50ZXJYICE9PSBudWxsICYmIGNlbnRlclkgIT09IG51bGwpXHJcbiAgICAvLyB7XHJcbiAgICAgICAgLy8gXHJcbiAgICAvLyB9XHJcblxyXG4gICAgdGVtcFpvbmUuc2V0UG9zaXRpb24oeCwgeSk7XHJcbiAgICB0ZW1wWm9uZS5zZXRTaXplKGNlbGxXaWR0aCwgY2VsbEhlaWdodCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBBbGlnbkluKGl0ZW1zW2ldLCB0ZW1wWm9uZSwgcG9zaXRpb24pO1xyXG5cclxuICAgICAgICBpZiAod2lkdGggPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGtlZXAgbGF5aW5nIHRoZW0gb3V0IGhvcml6b250YWxseSB1bnRpbCB3ZSd2ZSBkb25lIHRoZW0gYWxsXHJcbiAgICAgICAgICAgIGN5ICs9IGNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRlbXBab25lLnkgKz0gY2VsbEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjeSA9PT0gaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueCArPSBjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS55ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHQgPT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFdlIGtlZXAgbGF5aW5nIHRoZW0gb3V0IHZlcnRpY2FsbHkgdW50aWwgd2UndmUgZG9uZSB0aGVtIGFsbFxyXG4gICAgICAgICAgICBjeCArPSBjZWxsV2lkdGg7XHJcbiAgICAgICAgICAgIHRlbXBab25lLnggKz0gY2VsbFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGN4ID09PSB3KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS54ID0geDtcclxuICAgICAgICAgICAgICAgIHRlbXBab25lLnkgKz0gY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgV2Uga2VlcCBsYXlpbmcgdGhlbSBvdXQgdW50aWwgd2UgaGl0IHRoZSBjb2x1bW4gbGltaXRcclxuICAgICAgICAgICAgY3ggKz0gY2VsbFdpZHRoO1xyXG4gICAgICAgICAgICB0ZW1wWm9uZS54ICs9IGNlbGxXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjeCA9PT0gdylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgY3kgKz0gY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRlbXBab25lLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueSArPSBjZWxsSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjeSA9PT0gaClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgV2UndmUgaGl0IHRoZSBjb2x1bW4gbGltaXQsIHNvIHJldHVybiwgZXZlbiBpZiB0aGVyZSBhcmUgaXRlbXMgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JpZEFsaWduO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvR3JpZEFsaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY0FscGhhID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5hbHBoYSArPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluY0FscGhhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvSW5jQWxwaGEuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5jWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCArPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluY1g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9JbmNYLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY1hZID0gZnVuY3Rpb24gKGl0ZW1zLCB4LCB5KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggKz0geDtcclxuICAgICAgICBpdGVtc1tpXS55ICs9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmNYWTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL0luY1hZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY1kgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgKz0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmNZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvSW5jWS5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQbGFjZU9uQ2lyY2xlID0gZnVuY3Rpb24gKGl0ZW1zLCBjaXJjbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKVxyXG57XHJcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0QW5nbGUgPSAwOyB9XHJcbiAgICBpZiAoZW5kQW5nbGUgPT09IHVuZGVmaW5lZCkgeyBlbmRBbmdsZSA9IDYuMjg7IH1cclxuXHJcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlO1xyXG4gICAgdmFyIGFuZ2xlU3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gaXRlbXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCA9IGNpcmNsZS54ICsgKGNpcmNsZS5yYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgPSBjaXJjbGUueSArIChjaXJjbGUucmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcclxuXHJcbiAgICAgICAgYW5nbGUgKz0gYW5nbGVTdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxhY2VPbkNpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYWNlT25DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UG9pbnRzT25MaW5lID0gcmVxdWlyZSgnLi4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZScpO1xyXG5cclxudmFyIFBsYWNlT25MaW5lID0gZnVuY3Rpb24gKGl0ZW1zLCBsaW5lKVxyXG57XHJcbiAgICB2YXIgcG9pbnRzID0gR2V0UG9pbnRzT25MaW5lKGxpbmUpO1xyXG4gICAgdmFyIHN0ZXAgPSBwb2ludHMubGVuZ3RoIC8gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIHAgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbTWF0aC5mbG9vcihwKV07XHJcblxyXG4gICAgICAgIGl0ZW0ueCA9IHBvaW50WzBdO1xyXG4gICAgICAgIGl0ZW0ueSA9IHBvaW50WzFdO1xyXG5cclxuICAgICAgICBwICs9IHN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYWNlT25MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hcmNoaW5nQW50cyA9IHJlcXVpcmUoJy4uL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cycpO1xyXG52YXIgUm90YXRlTGVmdCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycmF5L1JvdGF0ZUxlZnQnKTtcclxudmFyIFJvdGF0ZVJpZ2h0ID0gcmVxdWlyZSgnLi4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQnKTtcclxuXHJcbi8vICBQbGFjZSB0aGUgaXRlbXMgaW4gdGhlIGFycmF5IGFyb3VuZCB0aGUgcGVyaW1ldGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGUuXHJcblxyXG4vLyAgUGxhY2VtZW50IHN0YXJ0cyBmcm9tIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlLCBhbmQgcHJvY2VlZHMgaW4gYVxyXG4vLyAgY2xvY2t3aXNlIGRpcmVjdGlvbi4gSWYgdGhlIHNoaWZ0IHBhcmFtZXRlciBpcyBnaXZlbiB5b3UgY2FuIG9mZnNldCB3aGVyZVxyXG4vLyAgcGxhY2VtZW50IGJlZ2lucy5cclxuXHJcbnZhciBQbGFjZU9uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCByZWN0LCBzaGlmdClcclxue1xyXG4gICAgaWYgKHNoaWZ0ID09PSB1bmRlZmluZWQpIHsgc2hpZnQgPSAwOyB9XHJcblxyXG4gICAgdmFyIHBvaW50cyA9IE1hcmNoaW5nQW50cyhyZWN0LCBmYWxzZSwgaXRlbXMubGVuZ3RoKTtcclxuXHJcbiAgICBpZiAoc2hpZnQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIFJvdGF0ZUxlZnQocG9pbnRzLCBzaGlmdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaGlmdCA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgUm90YXRlUmlnaHQocG9pbnRzLCBNYXRoLmFicyhzaGlmdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgIGl0ZW1zW2ldLnkgPSBwb2ludHNbaV0ueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYWNlT25SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9QbGFjZU9uUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4uL2dlb20vbGluZS9HZXRQb2ludHNPbkxpbmUnKTtcclxuXHJcbnZhciBQbGFjZU9uVHJpYW5nbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHRyaWFuZ2xlLCBzdGVwUmF0ZSlcclxue1xyXG4gICAgdmFyIHAxID0gR2V0UG9pbnRzT25MaW5lKHsgeDE6IHRyaWFuZ2xlLngxLCB5MTogdHJpYW5nbGUueTEsIHgyOiB0cmlhbmdsZS54MiwgeTI6IHRyaWFuZ2xlLnkyIH0sIHN0ZXBSYXRlKTtcclxuICAgIHZhciBwMiA9IEdldFBvaW50c09uTGluZSh7IHgxOiB0cmlhbmdsZS54MiwgeTE6IHRyaWFuZ2xlLnkyLCB4MjogdHJpYW5nbGUueDMsIHkyOiB0cmlhbmdsZS55MyB9LCBzdGVwUmF0ZSk7XHJcbiAgICB2YXIgcDMgPSBHZXRQb2ludHNPbkxpbmUoeyB4MTogdHJpYW5nbGUueDMsIHkxOiB0cmlhbmdsZS55MywgeDI6IHRyaWFuZ2xlLngxLCB5MjogdHJpYW5nbGUueTEgfSwgc3RlcFJhdGUpO1xyXG5cclxuICAgIC8vICBSZW1vdmUgb3ZlcmxhcHNcclxuICAgIHAxLnBvcCgpO1xyXG4gICAgcDIucG9wKCk7XHJcbiAgICBwMy5wb3AoKTtcclxuXHJcbiAgICBwMSA9IHAxLmNvbmNhdChwMiwgcDMpO1xyXG5cclxuICAgIHZhciBzdGVwID0gcDEubGVuZ3RoIC8gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIHAgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICB2YXIgcG9pbnQgPSBwMVtNYXRoLmZsb29yKHApXTtcclxuXHJcbiAgICAgICAgaXRlbS54ID0gcG9pbnRbMF07XHJcbiAgICAgICAgaXRlbS55ID0gcG9pbnRbMV07XHJcblxyXG4gICAgICAgIHAgKz0gc3RlcDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYWNlT25UcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYWNlT25UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKGl0ZW1zLCBrZXksIHN0YXJ0RnJhbWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uYW5pbXMucGxheShrZXksIHN0YXJ0RnJhbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxheUFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1BsYXlBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9jaXJjbGUvUmFuZG9tJyk7XHJcblxyXG52YXIgUmFuZG9tQ2lyY2xlID0gZnVuY3Rpb24gKGl0ZW1zLCBjaXJjbGUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgUmFuZG9tKGNpcmNsZSwgaXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUmFuZG9tQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vZWxsaXBzZS9SYW5kb20nKTtcclxuXHJcbnZhciBSYW5kb21FbGxpcHNlID0gZnVuY3Rpb24gKGl0ZW1zLCBlbGxpcHNlKVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIFJhbmRvbShlbGxpcHNlLCBpdGVtc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21FbGxpcHNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUmFuZG9tRWxsaXBzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSYW5kb20gPSByZXF1aXJlKCcuLi9nZW9tL2xpbmUvUmFuZG9tJyk7XHJcblxyXG52YXIgUmFuZG9tTGluZSA9IGZ1bmN0aW9uIChpdGVtcywgbGluZSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBSYW5kb20obGluZSwgaXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JhbmRvbUxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tJyk7XHJcblxyXG52YXIgUmFuZG9tUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCByZWN0KVxyXG57XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIFJhbmRvbShyZWN0LCBpdGVtc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21SZWN0YW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9SYW5kb21SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS90cmlhbmdsZS9SYW5kb20nKTtcclxuXHJcbnZhciBSYW5kb21UcmlhbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgdHJpYW5nbGUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgUmFuZG9tKHRyaWFuZ2xlLCBpdGVtc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21UcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JhbmRvbVRyaWFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnJvdGF0aW9uICs9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGVBcm91bmREaXN0YW5jZSA9IHJlcXVpcmUoJy4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UnKTtcclxudmFyIERpc3RhbmNlQmV0d2VlbiA9IHJlcXVpcmUoJy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuJyk7XHJcblxyXG4vLyAgcG9pbnQgPSBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlQXJvdW5kID0gZnVuY3Rpb24gKGl0ZW1zLCBwb2ludCwgYW5nbGUpXHJcbntcclxuICAgIHZhciB4ID0gcG9pbnQueDtcclxuICAgIHZhciB5ID0gcG9pbnQueTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgIFJvdGF0ZUFyb3VuZERpc3RhbmNlKGl0ZW0sIHgsIHksIGFuZ2xlLCBNYXRoLm1heCgxLCBEaXN0YW5jZUJldHdlZW4oaXRlbS54LCBpdGVtLnksIHgsIHkpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9Sb3RhdGVBcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDI2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWF0aFJvdGF0ZUFyb3VuZERpc3RhbmNlID0gcmVxdWlyZSgnLi4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZScpO1xyXG5cclxuLy8gIHBvaW50ID0gYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xyXG4vLyAgYW5nbGUgPSByYWRpYW5zXHJcbi8vICBkaXN0YW5jZSA9IHB4XHJcblxyXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAoaXRlbXMsIHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpXHJcbntcclxuICAgIHZhciB4ID0gcG9pbnQueDtcclxuICAgIHZhciB5ID0gcG9pbnQueTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIE1hdGhSb3RhdGVBcm91bmREaXN0YW5jZShpdGVtc1tpXSwgeCwgeSwgYW5nbGUsIGRpc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZERpc3RhbmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvUm90YXRlQXJvdW5kRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVYID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zY2FsZVggKz0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZVg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TY2FsZVguanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVYWSA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zY2FsZVggKz0geDtcclxuICAgICAgICBpdGVtc1tpXS5zY2FsZVkgKz0geTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TY2FsZVhZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjYWxlWSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uc2NhbGVZICs9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NhbGVZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2NhbGVZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldEFscGhhID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSwgc3RlcClcclxue1xyXG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0uYWxwaGEgPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRBbHBoYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldEFscGhhLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldE9yaWdpbiA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSlcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zZXRPcmlnaW4oeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRPcmlnaW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRPcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0Um90YXRpb24gPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5yb3RhdGlvbiA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFJvdGF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2V0Um90YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0U2NhbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHksIHN0ZXBYLCBzdGVwWSlcclxue1xyXG4gICAgaWYgKHN0ZXBYID09PSB1bmRlZmluZWQpIHsgc3RlcFggPSAwOyB9XHJcbiAgICBpZiAoc3RlcFkgPT09IHVuZGVmaW5lZCkgeyBzdGVwWSA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNldFNjYWxlKFxyXG4gICAgICAgICAgICB4ICsgKGkgKiBzdGVwWCksXHJcbiAgICAgICAgICAgIHkgKyAoaSAqIHN0ZXBZKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFNjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNjYWxlWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWCA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNjYWxlWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFNjYWxlWC5qc1xuLy8gbW9kdWxlIGlkID0gMjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRTY2FsZVkgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxyXG57XHJcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS5zY2FsZVkgPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRTY2FsZVk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRTY2FsZVkuanNcbi8vIG1vZHVsZSBpZCA9IDI3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0VmlzaWJsZSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXHJcbntcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0udmlzaWJsZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0VmlzaWJsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1NldFZpc2libGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0WCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXHJcbntcclxuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGl0ZW1zW2ldLnggPSB2YWx1ZSArIChpICogc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZXRYO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRYWSA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSwgc3RlcFgsIHN0ZXBZKVxyXG57XHJcbiAgICBpZiAoc3RlcFggPT09IHVuZGVmaW5lZCkgeyBzdGVwWCA9IDA7IH1cclxuICAgIGlmIChzdGVwWSA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBZID0gMDsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueCA9IHggKyAoaSAqIHN0ZXBYKTtcclxuICAgICAgICBpdGVtc1tpXS55ID0geSArIChpICogc3RlcFkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0WFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRYWS5qc1xuLy8gbW9kdWxlIGlkID0gMjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRZID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSwgc3RlcClcclxue1xyXG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgaXRlbXNbaV0ueSA9IHZhbHVlICsgKGkgKiBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TZXRZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEl0ZXJhdGUgdGhyb3VnaCBpdGVtcyBjaGFuZ2luZyB0aGUgcG9zaXRpb24gb2YgZWFjaCBlbGVtZW50IHRvXHJcbi8vICBiZSB0aGF0IG9mIHRoZSBlbGVtZW50IHRoYXQgY2FtZSBiZWZvcmUgaXQgaW4gdGhlIGFycmF5IChvciBhZnRlciBpdCBpZiBkaXJlY3Rpb24gPSAxKVxyXG4vLyAgVGhlIGZpcnN0IGl0ZW1zIHBvc2l0aW9uIGlzIHNldCB0byB4L3kuXHJcbi8vICBUaGUgZmluYWwgeC95IGNvb3JkcyBhcmUgcmV0dXJuZWRcclxuXHJcbnZhciBTaGlmdFBvc2l0aW9uID0gZnVuY3Rpb24gKGl0ZW1zLCB4LCB5LCBkaXJlY3Rpb24sIG91dHB1dClcclxue1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7IGRpcmVjdGlvbiA9IDA7IH1cclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIHZhciBweDtcclxuICAgIHZhciBweTtcclxuXHJcbiAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY3g7XHJcbiAgICAgICAgdmFyIGN5O1xyXG4gICAgICAgIHZhciBjdXI7XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQm90dG9tIHRvIFRvcFxyXG5cclxuICAgICAgICAgICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICBweCA9IGl0ZW1zW2xlbl0ueDtcclxuICAgICAgICAgICAgcHkgPSBpdGVtc1tsZW5dLnk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEN1cnJlbnQgaXRlbVxyXG4gICAgICAgICAgICAgICAgY3VyID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIEdldCBjdXJyZW50IGl0ZW0geC95LCB0byBiZSBwYXNzZWQgdG8gdGhlIG5leHQgaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgY3ggPSBjdXIueDtcclxuICAgICAgICAgICAgICAgIGN5ID0gY3VyLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGl0ZW0gdG8gdGhlIHByZXZpb3VzIGl0ZW1zIHgveVxyXG4gICAgICAgICAgICAgICAgY3VyLnggPSBweDtcclxuICAgICAgICAgICAgICAgIGN1ci55ID0gcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGFzIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgICBweCA9IGN4O1xyXG4gICAgICAgICAgICAgICAgcHkgPSBjeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFVwZGF0ZSB0aGUgaGVhZCBpdGVtIHRvIHRoZSBuZXcgeC95IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGl0ZW1zW2xlbl0ueCA9IHg7XHJcbiAgICAgICAgICAgIGl0ZW1zW2xlbl0ueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUb3AgdG8gQm90dG9tXHJcblxyXG4gICAgICAgICAgICBweCA9IGl0ZW1zWzBdLng7XHJcbiAgICAgICAgICAgIHB5ID0gaXRlbXNbMF0ueTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIEN1cnJlbnQgaXRlbVxyXG4gICAgICAgICAgICAgICAgY3VyID0gaXRlbXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIEdldCBjdXJyZW50IGl0ZW0geC95LCB0byBiZSBwYXNzZWQgdG8gdGhlIG5leHQgaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgY3ggPSBjdXIueDtcclxuICAgICAgICAgICAgICAgIGN5ID0gY3VyLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGl0ZW0gdG8gdGhlIHByZXZpb3VzIGl0ZW1zIHgveVxyXG4gICAgICAgICAgICAgICAgY3VyLnggPSBweDtcclxuICAgICAgICAgICAgICAgIGN1ci55ID0gcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFNldCBjdXJyZW50IGFzIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgICBweCA9IGN4O1xyXG4gICAgICAgICAgICAgICAgcHkgPSBjeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIFVwZGF0ZSB0aGUgaGVhZCBpdGVtIHRvIHRoZSBuZXcgeC95IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGl0ZW1zWzBdLnggPSB4O1xyXG4gICAgICAgICAgICBpdGVtc1swXS55ID0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcHggPSBpdGVtc1swXS54O1xyXG4gICAgICAgIHB5ID0gaXRlbXNbMF0ueTtcclxuXHJcbiAgICAgICAgaXRlbXNbMF0ueCA9IHg7XHJcbiAgICAgICAgaXRlbXNbMF0ueSA9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJldHVybiB0aGUgZmluYWwgc2V0IG9mIGNvb3JkaW5hdGVzIGFzIHRoZXkncmUgZWZmZWN0aXZlbHkgbG9zdCBmcm9tIHRoZSBzaGlmdCBhbmQgbWF5IGJlIG5lZWRlZFxyXG5cclxuICAgIG91dHB1dC54ID0gcHg7XHJcbiAgICBvdXRwdXQueSA9IHB5O1xyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoaWZ0UG9zaXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TaGlmdFBvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhTbW9vdGhTdGVwID0gcmVxdWlyZSgnLi4vbWF0aC9TbW9vdGhTdGVwJyk7XHJcblxyXG52YXIgU21vb3RoU3RlcCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbntcclxuICAgIGlmIChpbmMgPT09IHVuZGVmaW5lZCkgeyBpbmMgPSBmYWxzZTsgfVxyXG5cclxuICAgIHZhciBzdGVwID0gTWF0aC5hYnMobWF4IC0gbWluKSAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIGlmIChpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldICs9IE1hdGhTbW9vdGhTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGl0ZW1zW2ldW3Byb3BlcnR5XSA9IE1hdGhTbW9vdGhTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hY3Rpb25zL1Ntb290aFN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWF0aFNtb290aGVyU3RlcCA9IHJlcXVpcmUoJy4uL21hdGgvU21vb3RoZXJTdGVwJyk7XHJcblxyXG52YXIgU21vb3RoZXJTdGVwID0gZnVuY3Rpb24gKGl0ZW1zLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcclxue1xyXG4gICAgaWYgKGluYyA9PT0gdW5kZWZpbmVkKSB7IGluYyA9IGZhbHNlOyB9XHJcblxyXG4gICAgdmFyIHN0ZXAgPSBNYXRoLmFicyhtYXggLSBtaW4pIC8gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKGluYylcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gKz0gTWF0aFNtb290aGVyU3RlcChpICogc3RlcCwgbWluLCBtYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gPSBNYXRoU21vb3RoZXJTdGVwKGkgKiBzdGVwLCBtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU21vb3RoZXJTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwcmVhZCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXHJcbntcclxuICAgIGlmIChpbmMgPT09IHVuZGVmaW5lZCkgeyBpbmMgPSBmYWxzZTsgfVxyXG5cclxuICAgIHZhciBzdGVwID0gTWF0aC5hYnMobWF4IC0gbWluKSAvIGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIGlmIChpbmMpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldICs9IGkgKiBzdGVwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gPSBpICogc3RlcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJlYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYWN0aW9ucy9TcHJlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVG9nZ2xlVmlzaWJsZSA9IGZ1bmN0aW9uIChpdGVtcylcclxue1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpdGVtc1tpXS52aXNpYmxlID0gIWl0ZW1zW2ldLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb2dnbGVWaXNpYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FjdGlvbnMvVG9nZ2xlVmlzaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBjb25maWcgPSBBcnJheSBvZiBBbmltYXRpb24gY29uZmlnIG9iamVjdHMsIGxpa2U6XHJcbi8vICBbXHJcbi8vICAgICAgeyBrZXk6ICdnZW1zJywgZnJhbWU6ICdkaWFtb25kMDAwMScsIFtkdXJhdGlvbl0sIFt2aXNpYmxlXSwgW29uVXBkYXRlXSB9XHJcbi8vICBdXHJcblxyXG4vLyAgQWRkIGZyYW1lcyB0byB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb25cclxudmFyIEFkZEZyYW1lID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkRnJhbWVBdCh0aGlzLmZyYW1lcy5sZW5ndGgsIGNvbmZpZyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZEZyYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9BZGRGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRGcmFtZXMgPSByZXF1aXJlKCcuL0dldEZyYW1lcycpO1xyXG5cclxuLy8gIGNvbmZpZyA9IEFycmF5IG9mIEFuaW1hdGlvbiBjb25maWcgb2JqZWN0cywgbGlrZTpcclxuLy8gIFtcclxuLy8gICAgICB7IGtleTogJ2dlbXMnLCBmcmFtZTogJ2RpYW1vbmQwMDAxJywgW2R1cmF0aW9uXSwgW3Zpc2libGVdLCBbb25VcGRhdGVdIH1cclxuLy8gIF1cclxuXHJcbi8vICBBZGQgZnJhbWUvcyBpbnRvIHRoZSBhbmltYXRpb25cclxudmFyIEFkZEZyYW1lQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbmZpZylcclxue1xyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgdmFyIG5ld0ZyYW1lcyA9IEdldEZyYW1lcyh0aGlzLm1hbmFnZXIudGV4dHVyZU1hbmFnZXIsIGNvbmZpZyk7XHJcblxyXG4gICAgaWYgKG5ld0ZyYW1lcy5sZW5ndGggPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gbmV3RnJhbWVzLmNvbmNhdCh0aGlzLmZyYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmZyYW1lcy5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IHRoaXMuZnJhbWVzLmNvbmNhdChuZXdGcmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5mcmFtZXMuc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgcG9zdCA9IHRoaXMuZnJhbWVzLnNsaWNlKGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gcHJlLmNvbmNhdChuZXdGcmFtZXMsIHBvc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZVNlcXVlbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZEZyYW1lQXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL0FkZEZyYW1lQXQuanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0VmFsdWUnKTtcclxudmFyIEdldEZyYW1lcyA9IHJlcXVpcmUoJy4vR2V0RnJhbWVzJyk7XHJcblxyXG4vLyAgQSBGcmFtZSBiYXNlZCBBbmltYXRpb25cclxuLy8gIFRoaXMgY29uc2lzdHMgb2YgYSBrZXksIHNvbWUgZGVmYXVsdCB2YWx1ZXMgKGxpa2UgdGhlIGZyYW1lIHJhdGUpIGFuZCBhIGJ1bmNoIG9mIEZyYW1lIG9iamVjdHMuXHJcbi8vICBUaGUgQW5pbWF0aW9uIE1hbmFnZXIgY3JlYXRlcyB0aGVzZVxyXG4vLyAgR2FtZSBPYmplY3RzIGRvbid0IG93biBhbiBpbnN0YW5jZSBvZiB0aGVzZSBkaXJlY3RseVxyXG4vLyAgR2FtZSBPYmplY3RzIGhhdmUgdGhlIEFuaW1hdGlvbiBDb21wb25lbnQsIHdoaWNoIGFyZSBsaWtlIHBsYXloZWFkcyB0byBnbG9iYWwgQW5pbWF0aW9ucyAodGhlc2Ugb2JqZWN0cylcclxuLy8gIFNvIG11bHRpcGxlIEdhbWUgT2JqZWN0cyBjYW4gaGF2ZSBwbGF5aGVhZHMgYWxsIHBvaW50aW5nIHRvIHRoaXMgb25lIEFuaW1hdGlvbiBpbnN0YW5jZVxyXG5cclxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBrZXksIGNvbmZpZylcclxue1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAvLyAgQSBmcmFtZSBiYXNlZCBhbmltYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBib25lIGJhc2VkIGFuaW1hdGlvbilcclxuICAgIHRoaXMudHlwZSA9ICdmcmFtZSc7XHJcblxyXG4gICAgLy8gIEV4dHJhY3QgYWxsIHRoZSBmcmFtZSBkYXRhIGludG8gdGhlIGZyYW1lcyBhcnJheVxyXG4gICAgdGhpcy5mcmFtZXMgPSBHZXRGcmFtZXMobWFuYWdlci50ZXh0dXJlTWFuYWdlciwgR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVzJywgW10pKTtcclxuXHJcbiAgICAvLyAgVGhlIGZyYW1lIHJhdGUgb2YgcGxheWJhY2sgaW4gZnJhbWVzIHBlciBzZWNvbmQgKGRlZmF1bHQgMjQgaWYgZHVyYXRpb24gaXMgbnVsbClcclxuICAgIHRoaXMuZnJhbWVSYXRlID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVyYXRlJywgbnVsbCk7XHJcblxyXG4gICAgLy8gIEhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHBsYXkgZm9yLiBJZiBmcmFtZVJhdGUgaXMgc2V0IGl0IG92ZXJyaWRlcyB0aGlzIHZhbHVlXHJcbiAgICAvLyAgb3RoZXJ3aXNlIGZyYW1lUmF0ZSBpcyBkZXJpdmVkIGZyb20gZHVyYXRpb25cclxuICAgIHRoaXMuZHVyYXRpb24gPSBHZXRWYWx1ZShjb25maWcsICdkdXJhdGlvbicsIG51bGwpO1xyXG5cclxuICAgIGlmICh0aGlzLmR1cmF0aW9uID09PSBudWxsICYmIHRoaXMuZnJhbWVSYXRlID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBObyBkdXJhdGlvbiBvciBmcmFtZVJhdGUgZ2l2ZW4sIHVzZSBkZWZhdWx0IGZyYW1lUmF0ZSBvZiAyNGZwc1xyXG4gICAgICAgIHRoaXMuZnJhbWVSYXRlID0gMjQ7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZnJhbWVSYXRlIC8gdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5kdXJhdGlvbiAmJiB0aGlzLmZyYW1lUmF0ZSA9PT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICAvLyAgRHVyYXRpb24gZ2l2ZW4gYnV0IG5vIGZyYW1lUmF0ZSwgc28gc2V0IHRoZSBmcmFtZVJhdGUgYmFzZWQgb24gZHVyYXRpb25cclxuICAgICAgICAvLyAgSS5lLiAxMiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvbiwgZHVyYXRpb24gPSA0ICg0MDAwIG1zKVxyXG4gICAgICAgIC8vICBTbyBmcmFtZVJhdGUgaXMgMTIgLyA0ID0gMyBmcHNcclxuICAgICAgICB0aGlzLmZyYW1lUmF0ZSA9IHRoaXMuZnJhbWVzLmxlbmd0aCAvIHRoaXMuZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIGZyYW1lUmF0ZSBnaXZlbiwgZGVyaXZlIGR1cmF0aW9uIGZyb20gaXQgKGV2ZW4gaWYgZHVyYXRpb24gYWxzbyBzcGVjaWZpZWQpXHJcbiAgICAgICAgLy8gIEkuZS4gMTUgZnJhbWVzIGluIHRoZSBhbmltYXRpb24sIGZyYW1lUmF0ZSA9IDMwIGZwc1xyXG4gICAgICAgIC8vICBTbyBkdXJhdGlvbiBpcyAxNSAvIDMwID0gMC41IChoYWxmIGEgc2Vjb25kKVxyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmZyYW1lcy5sZW5ndGggLyB0aGlzLmZyYW1lUmF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgbXMgcGVyIGZyYW1lICh3aXRob3V0IGluY2x1ZGluZyBmcmFtZSBzcGVjaWZpYyBtb2RpZmllcnMpXHJcbiAgICB0aGlzLm1zUGVyRnJhbWUgPSAxMDAwIC8gdGhpcy5mcmFtZVJhdGU7XHJcblxyXG4gICAgLy8gIFNraXAgZnJhbWVzIGlmIHRoZSB0aW1lIGxhZ3MsIG9yIGFsd2F5cyBhZHZhbmNlZCBhbnl3YXk/XHJcbiAgICB0aGlzLnNraXBNaXNzZWRGcmFtZXMgPSBHZXRWYWx1ZShjb25maWcsICdza2lwTWlzc2VkRnJhbWVzJywgdHJ1ZSk7XHJcblxyXG4gICAgLy8gIERlbGF5IGJlZm9yZSBzdGFydGluZyBwbGF5YmFjayAoaW4gc2Vjb25kcylcclxuICAgIHRoaXMuZGVsYXkgPSBHZXRWYWx1ZShjb25maWcsICdkZWxheScsIDApO1xyXG5cclxuICAgIC8vICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBhbmltYXRpb24gKC0xIGZvciBpbmZpbml0eSlcclxuICAgIHRoaXMucmVwZWF0ID0gR2V0VmFsdWUoY29uZmlnLCAncmVwZWF0JywgMCk7XHJcblxyXG4gICAgLy8gIERlbGF5IGJlZm9yZSB0aGUgcmVwZWF0IHN0YXJ0cyAoaW4gc2Vjb25kcylcclxuICAgIHRoaXMucmVwZWF0RGVsYXkgPSBHZXRWYWx1ZShjb25maWcsICdyZXBlYXREZWxheScsIDApO1xyXG5cclxuICAgIC8vICBTaG91bGQgdGhlIGFuaW1hdGlvbiB5b3lvPyAocmV2ZXJzZSBiYWNrIGRvd24gdG8gdGhlIHN0YXJ0KSBiZWZvcmUgcmVwZWF0aW5nP1xyXG4gICAgdGhpcy55b3lvID0gR2V0VmFsdWUoY29uZmlnLCAneW95bycsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgU2hvdWxkIHNwcml0ZS52aXNpYmxlID0gdHJ1ZSB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzIHRvIHBsYXk/XHJcbiAgICB0aGlzLnNob3dPblN0YXJ0ID0gR2V0VmFsdWUoY29uZmlnLCAnc2hvd09uU3RhcnQnLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gIFNob3VsZCBzcHJpdGUudmlzaWJsZSA9IGZhbHNlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcz9cclxuICAgIHRoaXMuaGlkZU9uQ29tcGxldGUgPSBHZXRWYWx1ZShjb25maWcsICdoaWRlT25Db21wbGV0ZScsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgQ2FsbGJhY2tzXHJcbiAgICB0aGlzLmNhbGxiYWNrU2NvcGUgPSBHZXRWYWx1ZShjb25maWcsICdjYWxsYmFja1Njb3BlJywgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5vblN0YXJ0ID0gR2V0VmFsdWUoY29uZmlnLCAnb25TdGFydCcsIGZhbHNlKTtcclxuICAgIHRoaXMub25TdGFydFBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uU3RhcnRQYXJhbXMnLCBbXSk7XHJcblxyXG4gICAgdGhpcy5vblJlcGVhdCA9IEdldFZhbHVlKGNvbmZpZywgJ29uUmVwZWF0JywgZmFsc2UpO1xyXG4gICAgdGhpcy5vblJlcGVhdFBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uUmVwZWF0UGFyYW1zJywgW10pO1xyXG5cclxuICAgIC8vICBDYWxsZWQgZm9yIEVWRVJZIGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICAvLyAgU2VlIEFuaW1hdGlvbkZyYW1lLm9uVXBkYXRlIGZvciBhIGZyYW1lIHNwZWNpZmljIGNhbGxiYWNrLlxyXG4gICAgdGhpcy5vblVwZGF0ZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uVXBkYXRlJywgZmFsc2UpO1xyXG4gICAgdGhpcy5vblVwZGF0ZVBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ29uVXBkYXRlUGFyYW1zJywgW10pO1xyXG5cclxuICAgIHRoaXMub25Db21wbGV0ZSA9IEdldFZhbHVlKGNvbmZpZywgJ29uQ29tcGxldGUnLCBmYWxzZSk7XHJcbiAgICB0aGlzLm9uQ29tcGxldGVQYXJhbXMgPSBHZXRWYWx1ZShjb25maWcsICdvbkNvbXBsZXRlUGFyYW1zJywgW10pO1xyXG5cclxuICAgIC8vICBHbG9iYWwgcGF1c2UsIGVmZmVjdHMgYWxsIEdhbWUgT2JqZWN0cyB1c2luZyB0aGlzIEFuaW1hdGlvbiBpbnN0YW5jZVxyXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLm9uKCdQQVVTRV9BTExfQU5JTUFUSU9OX0VWRU5UJywgdGhpcy5wYXVzZS5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMubWFuYWdlci5ldmVudHMub24oJ1JFU1VNRV9BTExfQU5JTUFUSU9OX0VWRU5UJywgdGhpcy5yZXN1bWUuYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5BbmltYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5pbWF0aW9uO1xyXG5cclxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhZGRGcmFtZTogcmVxdWlyZSgnLi9BZGRGcmFtZScpLFxyXG4gICAgYWRkRnJhbWVBdDogcmVxdWlyZSgnLi9BZGRGcmFtZUF0JyksXHJcbiAgICBjaGVja0ZyYW1lOiByZXF1aXJlKCcuL0NoZWNrRnJhbWUnKSxcclxuICAgIGNvbXBsZXRlQW5pbWF0aW9uOiByZXF1aXJlKCcuL0NvbXBsZXRlQW5pbWF0aW9uJyksXHJcbiAgICBnZXRGaXJzdFRpY2s6IHJlcXVpcmUoJy4vR2V0Rmlyc3RUaWNrJyksXHJcbiAgICBnZXRGcmFtZUF0OiByZXF1aXJlKCcuL0dldEZyYW1lQXQnKSxcclxuICAgIGdldE5leHRUaWNrOiByZXF1aXJlKCcuL0dldE5leHRUaWNrJyksXHJcbiAgICBsb2FkOiByZXF1aXJlKCcuL0xvYWQnKSxcclxuICAgIG5leHRGcmFtZTogcmVxdWlyZSgnLi9OZXh0RnJhbWUnKSxcclxuICAgIHByZXZpb3VzRnJhbWU6IHJlcXVpcmUoJy4vUHJldmlvdXNGcmFtZScpLFxyXG4gICAgcmVtb3ZlRnJhbWU6IHJlcXVpcmUoJy4vUmVtb3ZlRnJhbWUnKSxcclxuICAgIHJlbW92ZUZyYW1lQXQ6IHJlcXVpcmUoJy4vUmVtb3ZlRnJhbWVBdCcpLFxyXG4gICAgcmVwZWF0QW5pbWF0aW9uOiByZXF1aXJlKCcuL1JlcGVhdEFuaW1hdGlvbicpLFxyXG4gICAgc2V0RnJhbWU6IHJlcXVpcmUoJy4vU2V0RnJhbWUnKSxcclxuICAgIHRvSlNPTjogcmVxdWlyZSgnLi9Ub0pTT04nKSxcclxuICAgIHVwZGF0ZUZyYW1lU2VxdWVuY2U6IHJlcXVpcmUoJy4vVXBkYXRlRnJhbWVTZXF1ZW5jZScpLFxyXG5cclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaGVja0ZyYW1lID0gZnVuY3Rpb24gKGluZGV4KVxyXG57XHJcbiAgICByZXR1cm4gKGluZGV4IDwgdGhpcy5mcmFtZXMubGVuZ3RoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hlY2tGcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvQ2hlY2tGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21wbGV0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIGlmICh0aGlzLmhpZGVPbkNvbXBsZXRlKVxyXG4gICAge1xyXG4gICAgICAgIGNvbXBvbmVudC5wYXJlbnQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudC5zdG9wKHRydWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wbGV0ZUFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvQ29tcGxldGVBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhbWUgPSBmdW5jdGlvbiAodGV4dHVyZUtleSwgdGV4dHVyZUZyYW1lLCBpbmRleCwgZnJhbWUpXHJcbntcclxuICAgIC8vICBUaGUga2V5cyBpbnRvIHRoZSBUZXh0dXJlIE1hbmFnZXIgb2YgdGhlIHRleHR1cmUgKyBmcmFtZSB0aGlzIHVzZXNcclxuICAgIHRoaXMudGV4dHVyZUtleSA9IHRleHR1cmVLZXk7XHJcbiAgICB0aGlzLnRleHR1cmVGcmFtZSA9IHRleHR1cmVGcmFtZTtcclxuXHJcbiAgICAvLyAgVGhlIGluZGV4IG9mIHRoaXMgZnJhbWUgd2l0aGluIHRoZSBBbmltYXRpb24uZnJhbWVzIGFycmF5XHJcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgLy8gIFRleHR1cmUgRnJhbWVcclxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcclxuXHJcbiAgICAvLyAgUmVhZC1vbmx5XHJcbiAgICB0aGlzLmlzRmlyc3QgPSBmYWxzZTtcclxuXHJcbiAgICAvLyAgUmVhZC1vbmx5XHJcbiAgICB0aGlzLmlzTGFzdCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBUaGUgZnJhbWUgdGhhdCBjb21lcyBiZWZvcmUgdGhpcyBvbmUgaW4gdGhlIGFuaW1hdGlvbiAoaWYgYW55KVxyXG4gICAgLy8gIFJlYWQtb25seVxyXG4gICAgdGhpcy5wcmV2RnJhbWUgPSBudWxsO1xyXG5cclxuICAgIC8vICBUaGUgZnJhbWUgdGhhdCBjb21lcyBhZnRlciB0aGlzIG9uZSBpbiB0aGUgYW5pbWF0aW9uIChpZiBhbnkpXHJcbiAgICAvLyAgUmVhZC1vbmx5XHJcbiAgICB0aGlzLm5leHRGcmFtZSA9IG51bGw7XHJcblxyXG4gICAgLy8gICBBZGRpdGlvbmFsIHRpbWUgKGluIG1zKSB0aGlzIGZyYW1lIHNob3VsZCBhcHBlYXIgZm9yIC0gYWRkZWQgb250byB0aGUgbXNQZXJGcmFtZVxyXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgLy8gICBXaGF0ICUgdGhyb3VnaCB0aGUgYW5pbWF0aW9uIHByb2dyZXNzIGlzIHRoaXMgZnJhbWU/XHJcbiAgICAvLyAgUmVhZC1vbmx5XHJcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuXHJcbiAgICAvLyAgQ2FsbGJhY2sgaWYgdGhpcyBmcmFtZSBnZXRzIGRpc3BsYXllZFxyXG4gICAgdGhpcy5vblVwZGF0ZSA9IG51bGw7XHJcblxyXG4gICAgLy8gIFdoZW4gdGhpcyBmcmFtZSBoaXRzLCBzZXQgc3ByaXRlLnZpc2libGUgdG8gdGhpc1xyXG4gICAgdGhpcy5zZXRWaXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbn07XHJcblxyXG5GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmFtZTtcclxuXHJcbkZyYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiB0aGlzLnRleHR1cmVLZXksXHJcbiAgICAgICAgICAgIGZyYW1lOiB0aGlzLnRleHR1cmVGcmFtZSxcclxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL0ZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEZpcnN0VGljayA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGluY2x1ZGVEZWxheSlcclxue1xyXG4gICAgaWYgKGluY2x1ZGVEZWxheSA9PT0gdW5kZWZpbmVkKSB7IGluY2x1ZGVEZWxheSA9IHRydWU7IH1cclxuXHJcbiAgICAvLyAgV2hlbiBpcyB0aGUgZmlyc3QgdXBkYXRlIGR1ZT9cclxuICAgIGNvbXBvbmVudC5hY2N1bXVsYXRvciA9IDA7XHJcbiAgICBjb21wb25lbnQubmV4dFRpY2sgPSBjb21wb25lbnQubXNQZXJGcmFtZSArIGNvbXBvbmVudC5jdXJyZW50RnJhbWUuZHVyYXRpb247XHJcblxyXG4gICAgaWYgKGluY2x1ZGVEZWxheSlcclxuICAgIHtcclxuICAgICAgICBjb21wb25lbnQubmV4dFRpY2sgKz0gKGNvbXBvbmVudC5fZGVsYXkgKiAxMDAwKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Rmlyc3RUaWNrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9HZXRGaXJzdFRpY2suanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0RnJhbWVBdCA9IGZ1bmN0aW9uIChpbmRleClcclxue1xyXG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzW2luZGV4XTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0RnJhbWVBdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvR2V0RnJhbWVBdC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXROZXh0VGljayA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIC8vIGFjY3VtdWxhdG9yICs9IGRlbHRhICogX3RpbWVTY2FsZVxyXG4gICAgLy8gYWZ0ZXIgYSBsYXJnZSBkZWx0YSBzdXJnZSAocGVyZiBpc3N1ZSBmb3IgZXhhbXBsZSkgd2UgbmVlZCB0byBhZGp1c3QgZm9yIGl0IGhlcmVcclxuXHJcbiAgICAvLyAgV2hlbiBpcyB0aGUgbmV4dCB1cGRhdGUgZHVlP1xyXG4gICAgY29tcG9uZW50LmFjY3VtdWxhdG9yIC09IGNvbXBvbmVudC5uZXh0VGljaztcclxuXHJcbiAgICBjb21wb25lbnQubmV4dFRpY2sgPSBjb21wb25lbnQubXNQZXJGcmFtZSArIGNvbXBvbmVudC5jdXJyZW50RnJhbWUuZHVyYXRpb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE5leHRUaWNrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9HZXROZXh0VGljay5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMb2FkID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgc3RhcnRGcmFtZSlcclxue1xyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPj0gdGhpcy5mcmFtZXMubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHN0YXJ0RnJhbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb21wb25lbnQuY3VycmVudEFuaW0gIT09IHRoaXMpXHJcbiAgICB7XHJcbiAgICAgICAgY29tcG9uZW50LmN1cnJlbnRBbmltID0gdGhpcztcclxuXHJcbiAgICAgICAgY29tcG9uZW50Ll90aW1lU2NhbGUgPSAxO1xyXG4gICAgICAgIGNvbXBvbmVudC5mcmFtZVJhdGUgPSB0aGlzLmZyYW1lUmF0ZTtcclxuICAgICAgICBjb21wb25lbnQuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgIGNvbXBvbmVudC5tc1BlckZyYW1lID0gdGhpcy5tc1BlckZyYW1lO1xyXG4gICAgICAgIGNvbXBvbmVudC5za2lwTWlzc2VkRnJhbWVzID0gdGhpcy5za2lwTWlzc2VkRnJhbWVzO1xyXG4gICAgICAgIGNvbXBvbmVudC5fZGVsYXkgPSB0aGlzLmRlbGF5O1xyXG4gICAgICAgIGNvbXBvbmVudC5fcmVwZWF0ID0gdGhpcy5yZXBlYXQ7XHJcbiAgICAgICAgY29tcG9uZW50Ll9yZXBlYXREZWxheSA9IHRoaXMucmVwZWF0RGVsYXk7XHJcbiAgICAgICAgY29tcG9uZW50Ll95b3lvID0gdGhpcy55b3lvO1xyXG4gICAgICAgIGNvbXBvbmVudC5fY2FsbGJhY2tBcmdzWzFdID0gdGhpcztcclxuICAgICAgICBjb21wb25lbnQuX3VwZGF0ZVBhcmFtcyA9IGNvbXBvbmVudC5fY2FsbGJhY2tBcmdzLmNvbmNhdCh0aGlzLm9uVXBkYXRlUGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnQudXBkYXRlRnJhbWUodGhpcy5mcmFtZXNbc3RhcnRGcmFtZV0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9Mb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5leHRGcmFtZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudC5jdXJyZW50RnJhbWU7XHJcblxyXG4gICAgLy8gIFRPRE86IEFkZCBmcmFtZSBza2lwIHN1cHBvcnRcclxuXHJcbiAgICBpZiAoZnJhbWUuaXNMYXN0KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb25cclxuXHJcbiAgICAgICAgLy8gIFlveW8/IChoYXBwZW5zIGJlZm9yZSByZXBlYXQpXHJcbiAgICAgICAgaWYgKHRoaXMueW95bylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5mb3J3YXJkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb21wb25lbnQudXBkYXRlRnJhbWUoZnJhbWUucHJldkZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBEZWxheSBmb3IgdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAgICAgICAgdGhpcy5nZXROZXh0VGljayhjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQucmVwZWF0Q291bnRlciA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVwZWF0IChoYXBwZW5zIGJlZm9yZSBjb21wbGV0ZSlcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRBbmltYXRpb24oY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbihjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjb21wb25lbnQudXBkYXRlRnJhbWUoZnJhbWUubmV4dEZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXROZXh0VGljayhjb21wb25lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZXh0RnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL05leHRGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQcmV2aW91c0ZyYW1lID0gZnVuY3Rpb24gKGNvbXBvbmVudClcclxue1xyXG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50LmN1cnJlbnRGcmFtZTtcclxuXHJcbiAgICAvLyAgVE9ETzogQWRkIGZyYW1lIHNraXAgc3VwcG9ydFxyXG5cclxuICAgIGlmIChmcmFtZS5pc0ZpcnN0KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBXZSdyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvblxyXG5cclxuICAgICAgICBpZiAoY29tcG9uZW50LnJlcGVhdENvdW50ZXIgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFJlcGVhdCAoaGFwcGVucyBiZWZvcmUgY29tcGxldGUpXHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0QW5pbWF0aW9uKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgY29tcG9uZW50LnVwZGF0ZUZyYW1lKGZyYW1lLnByZXZGcmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0TmV4dFRpY2soY29tcG9uZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJldmlvdXNGcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvUHJldmlvdXNGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBSZW1vdmUgZnJhbWUgaWYgaXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gZnJhbWVcclxudmFyIFJlbW92ZUZyYW1lID0gZnVuY3Rpb24gKGZyYW1lKVxyXG57XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZyYW1lcy5pbmRleE9mKGZyYW1lKTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRnJhbWVBdChpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZUZyYW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9SZW1vdmVGcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmVGcmFtZUF0ID0gZnVuY3Rpb24gKGluZGV4KVxyXG57XHJcbiAgICB0aGlzLmZyYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlRnJhbWVTZXF1ZW5jZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVGcmFtZUF0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9SZW1vdmVGcmFtZUF0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlcGVhdEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIGlmIChjb21wb25lbnQuX3JlcGVhdERlbGF5ID4gMCAmJiBjb21wb25lbnQucGVuZGluZ1JlcGVhdCA9PT0gZmFsc2UpXHJcbiAgICB7XHJcbiAgICAgICAgY29tcG9uZW50LnBlbmRpbmdSZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgIGNvbXBvbmVudC5hY2N1bXVsYXRvciAtPSBjb21wb25lbnQubmV4dFRpY2s7XHJcbiAgICAgICAgY29tcG9uZW50Lm5leHRUaWNrICs9IChjb21wb25lbnQuX3JlcGVhdERlbGF5ICogMTAwMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgY29tcG9uZW50LnJlcGVhdENvdW50ZXItLTtcclxuXHJcbiAgICAgICAgY29tcG9uZW50LmZvcndhcmQgPSB0cnVlO1xyXG5cclxuICAgICAgICBjb21wb25lbnQudXBkYXRlRnJhbWUoY29tcG9uZW50LmN1cnJlbnRGcmFtZS5uZXh0RnJhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmdldE5leHRUaWNrKGNvbXBvbmVudCk7XHJcblxyXG4gICAgICAgIGNvbXBvbmVudC5wZW5kaW5nUmVwZWF0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uUmVwZWF0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlcGVhdC5hcHBseSh0aGlzLmNhbGxiYWNrU2NvcGUsIGNvbXBvbmVudC5fY2FsbGJhY2tBcmdzLmNvbmNhdCh0aGlzLm9uUmVwZWF0UGFyYW1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXBlYXRBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL1JlcGVhdEFuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRGcmFtZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpXHJcbntcclxuICAgIC8vICBXb3JrIG91dCB3aGljaCBmcmFtZSBzaG91bGQgYmUgc2V0IG5leHQgb24gdGhlIGNoaWxkLCBhbmQgc2V0IGl0XHJcbiAgICBpZiAoY29tcG9uZW50LmZvcndhcmQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5uZXh0RnJhbWUoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzRnJhbWUoY29tcG9uZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0RnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL2ZyYW1lL1NldEZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRvSlNPTiA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAga2V5OiB0aGlzLmtleSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgZnJhbWVzOiBbXSxcclxuICAgICAgICBmcmFtZXJhdGU6IHRoaXMuZnJhbWVSYXRlLFxyXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgIHNraXBNaXNzZWRGcmFtZXM6IHRoaXMuc2tpcE1pc3NlZEZyYW1lcyxcclxuICAgICAgICBkZWxheTogdGhpcy5kZWxheSxcclxuICAgICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxyXG4gICAgICAgIHJlcGVhdERlbGF5OiB0aGlzLnJlcGVhdERlbGF5LFxyXG4gICAgICAgIHlveW86IHRoaXMueW95byxcclxuICAgICAgICBzaG93T25TdGFydDogdGhpcy5zaG93T25TdGFydCxcclxuICAgICAgICBoaWRlT25Db21wbGV0ZTogdGhpcy5oaWRlT25Db21wbGV0ZVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuZnJhbWVzLnB1c2goZnJhbWUudG9KU09OKCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9KU09OO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9mcmFtZS9Ub0pTT04uanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVXBkYXRlRnJhbWVTZXF1ZW5jZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBsZW4gPSB0aGlzLmZyYW1lcy5sZW5ndGg7XHJcbiAgICB2YXIgc2xpY2UgPSAxIC8gKGxlbiAtIDEpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbaV07XHJcblxyXG4gICAgICAgIGZyYW1lLmluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgZnJhbWUuaXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIGZyYW1lLmlzTGFzdCA9IGZhbHNlO1xyXG4gICAgICAgIGZyYW1lLnByb2dyZXNzID0gaSAqIHNsaWNlO1xyXG5cclxuICAgICAgICBpZiAoaSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lLmlzRmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBmcmFtZS5pc0xhc3QgPSAobGVuID09PSAxKTtcclxuICAgICAgICAgICAgZnJhbWUucHJldkZyYW1lID0gdGhpcy5mcmFtZXNbbGVuIC0gMV07XHJcbiAgICAgICAgICAgIGZyYW1lLm5leHRGcmFtZSA9IHRoaXMuZnJhbWVzW2kgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gbGVuIC0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lLmlzTGFzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZyYW1lLnByZXZGcmFtZSA9IHRoaXMuZnJhbWVzW2xlbiAtIDJdO1xyXG4gICAgICAgICAgICBmcmFtZS5uZXh0RnJhbWUgPSB0aGlzLmZyYW1lc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuID4gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZyYW1lLnByZXZGcmFtZSA9IHRoaXMuZnJhbWVzW2kgLSAxXTtcclxuICAgICAgICAgICAgZnJhbWUubmV4dEZyYW1lID0gdGhpcy5mcmFtZXNbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlRnJhbWVTZXF1ZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vZnJhbWUvVXBkYXRlRnJhbWVTZXF1ZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBNYXAgPSByZXF1aXJlKCcuLi8uLi9zdHJ1Y3RzL01hcCcpO1xyXG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy8nKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuXHJcbi8qKlxyXG4qIEFuaW1hdGlvbnMgYXJlIG1hbmFnZWQgYnkgdGhlIGdsb2JhbCBBbmltYXRpb25NYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcclxuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgYW5pbWF0aW9ucyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBkYXRhIHRvIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIGRhdGEgdGhleSBuZWVkIGZyb20gdGhlIEFuaW1hdGlvbk1hbmFnZXIuXHJcbipcclxuKiBBY2Nlc3MgaXQgdmlhIGBzdGF0ZS5hbmltc2AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkFuaW1hdGlvbk1hbmFnZXJcclxuKiBAY29uc3RydWN0b3JcclxuKi9cclxudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICB0aGlzLmdsb2JhbFRpbWVTY2FsZSA9IDE7XHJcblxyXG4gICAgdGhpcy5hbmltcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbmltYXRpb25NYW5hZ2VyO1xyXG5cclxuQW5pbWF0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYm9vdDogZnVuY3Rpb24gKHRleHR1cmVNYW5hZ2VyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSB0ZXh0dXJlTWFuYWdlcjtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBDb21wb25lbnRzLkFkZEFuaW1hdGlvbixcclxuICAgIGNyZWF0ZTogQ29tcG9uZW50cy5DcmVhdGVGcmFtZUFuaW1hdGlvbixcclxuICAgIGZyb21KU09OOiBDb21wb25lbnRzLkZyb21KU09OLFxyXG4gICAgZ2VuZXJhdGVGcmFtZU5hbWVzOiBDb21wb25lbnRzLkdlbmVyYXRlRnJhbWVOYW1lcyxcclxuICAgIGdlbmVyYXRlRnJhbWVOdW1iZXJzOiBDb21wb25lbnRzLkdlbmVyYXRlRnJhbWVOdW1iZXJzLFxyXG4gICAgZ2V0OiBDb21wb25lbnRzLkdldEFuaW1hdGlvbixcclxuICAgIGxvYWQ6IENvbXBvbmVudHMuTG9hZEFuaW1hdGlvblRvR2FtZU9iamVjdCxcclxuICAgIHBsYXk6IENvbXBvbmVudHMuUGxheUFuaW1hdGlvbixcclxuICAgIHBhdXNlQWxsOiBDb21wb25lbnRzLlBhdXNlQWxsLFxyXG4gICAgcmVtb3ZlOiBDb21wb25lbnRzLlJlbW92ZUFuaW1hdGlvbixcclxuICAgIHJlc3VtZUFsbDogQ29tcG9uZW50cy5SZXN1bWVBbGwsXHJcbiAgICBzdGFnZ2VyUGxheTogQ29tcG9uZW50cy5TdGFnZ2VyUGxheUFuaW1hdGlvbixcclxuICAgIHRvSlNPTjogQ29tcG9uZW50cy5Ub0pTT04sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgVE9ET1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25NYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL0FuaW1hdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcblxyXG52YXIgQWRkQW5pbWF0aW9uID0gZnVuY3Rpb24gKGtleSwgYW5pbWF0aW9uKVxyXG57XHJcbiAgICBpZiAodGhpcy5hbmltcy5oYXMoa2V5KSlcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdBbmltYXRpb24gd2l0aCBrZXknLCBrZXksICdhbHJlYWR5IGV4aXN0cycpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRpb24ua2V5ID0ga2V5O1xyXG5cclxuICAgIHRoaXMuYW5pbXMuc2V0KGtleSwgYW5pbWF0aW9uKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuQUREX0FOSU1BVElPTl9FVkVOVChrZXksIGFuaW1hdGlvbikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9BZGRBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcbnZhciBBbmltYXRpb24gPSByZXF1aXJlKCcuLi8uLi9mcmFtZS9BbmltYXRpb24nKTtcclxuXHJcbnZhciBDcmVhdGVGcmFtZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBjb25maWcua2V5O1xyXG5cclxuICAgIGlmICgha2V5IHx8IHRoaXMuYW5pbXMuaGFzKGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEFuaW1hdGlvbiBLZXksIG9yIEtleSBhbHJlYWR5IGluIHVzZTogJyArIGtleSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbmltID0gbmV3IEFuaW1hdGlvbih0aGlzLCBrZXksIGNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy5hbmltcy5zZXQoa2V5LCBhbmltKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuQUREX0FOSU1BVElPTl9FVkVOVChrZXksIGFuaW0pKTtcclxuXHJcbiAgICByZXR1cm4gYW5pbTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlRnJhbWVBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9DcmVhdGVGcmFtZUFuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGcm9tSlNPTiA9IGZ1bmN0aW9uIChkYXRhLCBjbGVhckN1cnJlbnRBbmltYXRpb25zKVxyXG57XHJcbiAgICBpZiAoY2xlYXJDdXJyZW50QW5pbWF0aW9ucyA9PT0gdW5kZWZpbmVkKSB7IGNsZWFyQ3VycmVudEFuaW1hdGlvbnMgPSBmYWxzZTsgfVxyXG5cclxuICAgIGlmIChjbGVhckN1cnJlbnRBbmltYXRpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYW5pbXMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRG8gd2UgaGF2ZSBhIFN0cmluZyAoaS5lLiBmcm9tIEpTT04sIG9yIGFuIE9iamVjdD8pXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxyXG4gICAge1xyXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICAvLyAgQXJyYXkgb2YgYW5pbWF0aW9ucywgb3IgYSBzaW5nbGUgYW5pbWF0aW9uP1xyXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2FuaW1zJykgJiYgQXJyYXkuaXNBcnJheShkYXRhLmFuaW1zKSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYW5pbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0aGlzLmNyZWF0ZShkYXRhLmFuaW1zW2ldKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZ2xvYmFsVGltZVNjYWxlJykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbFRpbWVTY2FsZSA9IGRhdGEuZ2xvYmFsVGltZVNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2tleScpICYmIGRhdGEudHlwZSA9PT0gJ2ZyYW1lJylcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQucHVzaCh0aGlzLmNyZWF0ZShkYXRhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJvbUpTT047XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9Gcm9tSlNPTi5qc1xuLy8gbW9kdWxlIGlkID0gMzA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgUGFkID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvc3RyaW5nL1BhZCcpO1xyXG5cclxudmFyIEdlbmVyYXRlRnJhbWVOYW1lcyA9IGZ1bmN0aW9uIChrZXksIGNvbmZpZylcclxue1xyXG4gICAgdmFyIHByZWZpeCA9IEdldFZhbHVlKGNvbmZpZywgJ3ByZWZpeCcsICcnKTtcclxuICAgIHZhciBzdGFydCA9IEdldFZhbHVlKGNvbmZpZywgJ3N0YXJ0JywgMCk7XHJcbiAgICB2YXIgZW5kID0gR2V0VmFsdWUoY29uZmlnLCAnZW5kJywgMCk7XHJcbiAgICB2YXIgc3VmZml4ID0gR2V0VmFsdWUoY29uZmlnLCAnc3VmZml4JywgJycpO1xyXG4gICAgdmFyIHplcm9QYWQgPSBHZXRWYWx1ZShjb25maWcsICd6ZXJvUGFkJywgMCk7XHJcbiAgICB2YXIgb3V0ID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWVzQXJyYXknLCBbXSk7XHJcblxyXG4gICAgdmFyIGRpZmYgPSAoc3RhcnQgPCBlbmQpID8gMSA6IC0xO1xyXG5cclxuICAgIC8vICBBZGp1c3QgYmVjYXVzZSB3ZSB1c2UgaSAhPT0gZW5kIGluIHRoZSBmb3IgbG9vcFxyXG4gICAgZW5kICs9IGRpZmY7XHJcblxyXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmdldChrZXkpO1xyXG5cclxuICAgIGlmICghdGV4dHVyZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSAhPT0gZW5kOyBpICs9IGRpZmYpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gcHJlZml4ICsgUGFkKGksIHplcm9QYWQsICcwJywgMSkgKyBzdWZmaXg7XHJcblxyXG4gICAgICAgIGlmICh0ZXh0dXJlLmhhcyhmcmFtZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXQucHVzaCh7IGtleToga2V5LCBmcmFtZTogZnJhbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyYXRlRnJhbWVOYW1lcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9jb21wb25lbnRzL0dlbmVyYXRlRnJhbWVOYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIEdlbmVyYXRlRnJhbWVOdW1iZXJzID0gZnVuY3Rpb24gKGtleSwgY29uZmlnKVxyXG57XHJcbiAgICB2YXIgc3RhcnRGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ3N0YXJ0JywgMCk7XHJcbiAgICB2YXIgZW5kRnJhbWUgPSBHZXRWYWx1ZShjb25maWcsICdlbmQnLCAtMSk7XHJcbiAgICB2YXIgZmlyc3RGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ2ZpcnN0JywgZmFsc2UpO1xyXG4gICAgdmFyIG91dCA9IEdldFZhbHVlKGNvbmZpZywgJ2ZyYW1lc0FycmF5JywgW10pO1xyXG5cclxuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoIXRleHR1cmUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTm8gZW5kRnJhbWUgdGhlbiBzZWUgaWYgd2UgY2FuIGdldCBpdFxyXG5cclxuICAgIGlmIChlbmRGcmFtZSA9PT0gLTEpXHJcbiAgICB7XHJcbiAgICAgICAgZW5kRnJhbWUgPSB0ZXh0dXJlLmZyYW1lVG90YWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpcnN0RnJhbWUgJiYgdGV4dHVyZS5oYXMoZmlyc3RGcmFtZSkpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnB1c2goeyBrZXk6IGtleSwgZnJhbWU6IGZpcnN0RnJhbWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0RnJhbWU7IGkgPD0gZW5kRnJhbWU7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpZiAodGV4dHVyZS5oYXMoaSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXQucHVzaCh7IGtleToga2V5LCBmcmFtZTogaSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2VuZXJhdGVGcmFtZU51bWJlcnM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9HZW5lcmF0ZUZyYW1lTnVtYmVycy5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBbmltYXRpb24gPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICByZXR1cm4gdGhpcy5hbmltcy5nZXQoa2V5KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvR2V0QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIExvYWQgYW4gQW5pbWF0aW9uIGludG8gYSBHYW1lIE9iamVjdHMgQW5pbWF0aW9uIENvbXBvbmVudFxyXG52YXIgTG9hZEFuaW1hdGlvblRvR2FtZU9iamVjdCA9IGZ1bmN0aW9uIChjaGlsZCwga2V5LCBzdGFydEZyYW1lKVxyXG57XHJcbiAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0KGtleSk7XHJcblxyXG4gICAgaWYgKGFuaW0pXHJcbiAgICB7XHJcbiAgICAgICAgYW5pbS5sb2FkKGNoaWxkLCBzdGFydEZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRBbmltYXRpb25Ub0dhbWVPYmplY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9Mb2FkQW5pbWF0aW9uVG9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzLycpO1xyXG5cclxudmFyIFBhdXNlQWxsID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKCF0aGlzLnBhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5QQVVTRV9BTExfQU5JTUFUSU9OX0VWRU5UKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZUFsbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9jb21wb25lbnRzL1BhdXNlQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoa2V5LCBjaGlsZClcclxue1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkKSlcclxuICAgIHtcclxuICAgICAgICBjaGlsZCA9IFsgY2hpbGQgXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0KGtleSk7XHJcblxyXG4gICAgaWYgKCFhbmltKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGNoaWxkW2ldLmFuaW1zLnBsYXkoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGxheUFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9jb21wb25lbnRzL1BsYXlBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcblxyXG52YXIgUmVtb3ZlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGtleSlcclxue1xyXG4gICAgdmFyIGFuaW0gPSB0aGlzLmdldChrZXkpO1xyXG5cclxuICAgIGlmIChhbmltKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5SRU1PVkVfQU5JTUFUSU9OX0VWRU5UKGtleSwgYW5pbSkpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1zLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhbmltO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYW5pbWF0aW9uL21hbmFnZXIvY29tcG9uZW50cy9SZW1vdmVBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvJyk7XHJcblxyXG52YXIgUmVzdW1lQWxsID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMucGF1c2VkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5SRVNVTUVfQUxMX0FOSU1BVElPTl9FVkVOVCgpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdW1lQWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvUmVzdW1lQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0YWdnZXJQbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKGtleSwgY2hpbGQsIHN0YWdnZXIpXHJcbntcclxuICAgIGlmIChzdGFnZ2VyID09PSB1bmRlZmluZWQpIHsgc3RhZ2dlciA9IDA7IH1cclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGQpKVxyXG4gICAge1xyXG4gICAgICAgIGNoaWxkID0gWyBjaGlsZCBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbmltID0gdGhpcy5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoIWFuaW0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgY2hpbGRbaV0uYW5pbXMuZGVsYXllZFBsYXkoc3RhZ2dlciAqIGksIGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWdnZXJQbGF5QW5pbWF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvU3RhZ2dlclBsYXlBbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVG9KU09OID0gZnVuY3Rpb24gKGtleSlcclxue1xyXG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gJycpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbXMuZ2V0KGtleSkudG9KU09OKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgYW5pbXM6IFtdLFxyXG4gICAgICAgICAgICBnbG9iYWxUaW1lU2NhbGU6IHRoaXMuZ2xvYmFsVGltZVNjYWxlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltcy5lYWNoKGZ1bmN0aW9uIChhbmltYXRpb25LZXksIGFuaW1hdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hbmltcy5wdXNoKGFuaW1hdGlvbi50b0pTT04oKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvSlNPTjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9jb21wb25lbnRzL1RvSlNPTi5qc1xuLy8gbW9kdWxlIGlkID0gMzE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIFxyXG4gICAgQWRkQW5pbWF0aW9uOiByZXF1aXJlKCcuL0FkZEFuaW1hdGlvbicpLFxyXG4gICAgQ3JlYXRlRnJhbWVBbmltYXRpb246IHJlcXVpcmUoJy4vQ3JlYXRlRnJhbWVBbmltYXRpb24nKSxcclxuICAgIEZyb21KU09OOiByZXF1aXJlKCcuL0Zyb21KU09OJyksXHJcbiAgICBHZW5lcmF0ZUZyYW1lTmFtZXM6IHJlcXVpcmUoJy4vR2VuZXJhdGVGcmFtZU5hbWVzJyksXHJcbiAgICBHZW5lcmF0ZUZyYW1lTnVtYmVyczogcmVxdWlyZSgnLi9HZW5lcmF0ZUZyYW1lTnVtYmVycycpLFxyXG4gICAgR2V0QW5pbWF0aW9uOiByZXF1aXJlKCcuL0dldEFuaW1hdGlvbicpLFxyXG4gICAgTG9hZEFuaW1hdGlvblRvR2FtZU9iamVjdDogcmVxdWlyZSgnLi9Mb2FkQW5pbWF0aW9uVG9HYW1lT2JqZWN0JyksXHJcbiAgICBQbGF5QW5pbWF0aW9uOiByZXF1aXJlKCcuL1BsYXlBbmltYXRpb24nKSxcclxuICAgIFBhdXNlQWxsOiByZXF1aXJlKCcuL1BhdXNlQWxsJyksXHJcbiAgICBSZXN1bWVBbGw6IHJlcXVpcmUoJy4vUmVzdW1lQWxsJyksXHJcbiAgICBSZW1vdmVBbmltYXRpb246IHJlcXVpcmUoJy4vUmVtb3ZlQW5pbWF0aW9uJyksXHJcbiAgICBTdGFnZ2VyUGxheUFuaW1hdGlvbjogcmVxdWlyZSgnLi9TdGFnZ2VyUGxheUFuaW1hdGlvbicpLFxyXG4gICAgVG9KU09OOiByZXF1aXJlKCcuL1RvSlNPTicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBBZGRBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChrZXksIGFuaW1hdGlvbilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnQUREX0FOSU1BVElPTl9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbn07XHJcblxyXG5BZGRBbmltYXRpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbkFkZEFuaW1hdGlvbkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFkZEFuaW1hdGlvbkV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRBbmltYXRpb25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvQWRkQW5pbWF0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBQYXVzZUFsbEFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnUEFVU0VfQUxMX0FOSU1BVElPTl9FVkVOVCcpO1xyXG59O1xyXG5cclxuUGF1c2VBbGxBbmltYXRpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcblBhdXNlQWxsQW5pbWF0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGF1c2VBbGxBbmltYXRpb25FdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF1c2VBbGxBbmltYXRpb25FdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hbmltYXRpb24vbWFuYWdlci9ldmVudHMvUGF1c2VBbGxBbmltYXRpb25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIFJlbW92ZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKGtleSwgYW5pbWF0aW9uKVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdSRU1PVkVfQU5JTUFUSU9OX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxufTtcclxuXHJcblJlbW92ZUFuaW1hdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuUmVtb3ZlQW5pbWF0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVtb3ZlQW5pbWF0aW9uRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZUFuaW1hdGlvbkV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9SZW1vdmVBbmltYXRpb25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIFJlc3VtZUFsbEFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnUkVTVU1FX0FMTF9BTklNQVRJT05fRVZFTlQnKTtcclxufTtcclxuXHJcblJlc3VtZUFsbEFuaW1hdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuUmVzdW1lQWxsQW5pbWF0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVzdW1lQWxsQW5pbWF0aW9uRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VtZUFsbEFuaW1hdGlvbkV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FuaW1hdGlvbi9tYW5hZ2VyL2V2ZW50cy9SZXN1bWVBbGxBbmltYXRpb25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBNQVRIID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgTk9PUCA9IHJlcXVpcmUoJy4uL3V0aWxzL05PT1AnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBWYWx1ZVRvQ29sb3IgPSByZXF1aXJlKCcuLi9ncmFwaGljcy9jb2xvci9WYWx1ZVRvQ29sb3InKTtcclxuXHJcbnZhciBkZWZhdWx0QmFubmVyQ29sb3IgPSBbXHJcbiAgICAnI2ZmMDAwMCcsXHJcbiAgICAnI2ZmZmYwMCcsXHJcbiAgICAnIzAwZmYwMCcsXHJcbiAgICAnIzAwZmZmZicsXHJcbiAgICAnIzAwMDAwMCdcclxuXTtcclxuXHJcbnZhciBkZWZhdWx0QmFubmVyVGV4dENvbG9yID0gJyNmZmZmZmYnO1xyXG5cclxudmFyIENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpXHJcbntcclxuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkgeyBjb25maWcgPSB7fTsgfVxyXG5cclxuICAgIHRoaXMud2lkdGggPSBHZXRWYWx1ZShjb25maWcsICd3aWR0aCcsIDEwMjQpO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdoZWlnaHQnLCA3NjgpO1xyXG4gICAgdGhpcy56b29tID0gR2V0VmFsdWUoY29uZmlnLCAnem9vbScsIDEpO1xyXG5cclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IEdldFZhbHVlKGNvbmZpZywgJ3Jlc29sdXRpb24nLCAxKTtcclxuXHJcbiAgICB0aGlzLnJlbmRlclR5cGUgPSBHZXRWYWx1ZShjb25maWcsICd0eXBlJywgQ09OU1QuQVVUTyk7XHJcblxyXG4gICAgdGhpcy5wYXJlbnQgPSBHZXRWYWx1ZShjb25maWcsICdwYXJlbnQnLCBudWxsKTtcclxuICAgIHRoaXMuY2FudmFzID0gR2V0VmFsdWUoY29uZmlnLCAnY2FudmFzJywgbnVsbCk7XHJcbiAgICB0aGlzLmNhbnZhc1N0eWxlID0gR2V0VmFsdWUoY29uZmlnLCAnY2FudmFzU3R5bGUnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlQ29uZmlnID0gR2V0VmFsdWUoY29uZmlnLCAnc3RhdGUnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLnNlZWQgPSBHZXRWYWx1ZShjb25maWcsICdzZWVkJywgWyAoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCkgXSk7XHJcblxyXG4gICAgTUFUSC5STkQuaW5pdCh0aGlzLnNlZWQpO1xyXG5cclxuICAgIHRoaXMuZ2FtZVRpdGxlID0gR2V0VmFsdWUoY29uZmlnLCAndGl0bGUnLCAnJyk7XHJcbiAgICB0aGlzLmdhbWVVUkwgPSBHZXRWYWx1ZShjb25maWcsICd1cmwnLCAnaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgdGhpcy5nYW1lVmVyc2lvbiA9IEdldFZhbHVlKGNvbmZpZywgJ3ZlcnNpb24nLCAnJyk7XHJcblxyXG4gICAgLy8gIElucHV0XHJcbiAgICB0aGlzLmlucHV0S2V5Ym9hcmQgPSBHZXRWYWx1ZShjb25maWcsICdpbnB1dC5rZXlib2FyZCcsIHRydWUpO1xyXG4gICAgdGhpcy5pbnB1dEtleWJvYXJkRXZlbnRUYXJnZXQgPSBHZXRWYWx1ZShjb25maWcsICdpbnB1dC5rZXlib2FyZC50YXJnZXQnLCB3aW5kb3cpO1xyXG5cclxuICAgIHRoaXMuaW5wdXRNb3VzZSA9IEdldFZhbHVlKGNvbmZpZywgJ2lucHV0Lm1vdXNlJywgdHJ1ZSk7XHJcbiAgICB0aGlzLmlucHV0TW91c2VFdmVudFRhcmdldCA9IEdldFZhbHVlKGNvbmZpZywgJ2lucHV0Lm1vdXNlLnRhcmdldCcsIG51bGwpO1xyXG5cclxuICAgIC8vICBJZiB5b3UgZG86IHsgYmFubmVyOiBmYWxzZSB9IGl0IHdvbid0IGRpc3BsYXkgYW55IGJhbm5lciBhdCBhbGxcclxuICAgIHRoaXMuaGlkZUJhbm5lciA9IChHZXRWYWx1ZShjb25maWcsICdiYW5uZXInLCBudWxsKSA9PT0gZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaGlkZVBoYXNlciA9IEdldFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5oaWRlUGhhc2VyJywgZmFsc2UpO1xyXG4gICAgdGhpcy5iYW5uZXJUZXh0Q29sb3IgPSBHZXRWYWx1ZShjb25maWcsICdiYW5uZXIudGV4dCcsIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IpO1xyXG4gICAgdGhpcy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IgPSBHZXRWYWx1ZShjb25maWcsICdiYW5uZXIuYmFja2dyb3VuZCcsIGRlZmF1bHRCYW5uZXJDb2xvcik7XHJcbiAgIFxyXG4gICAgLy8gIEZyYW1lIFJhdGUgY29uZmlnXHJcbiAgICAvLyAgICAgIGZwczoge1xyXG4gICAgLy8gICAgICAgICAgbWluOiAxMCxcclxuICAgIC8vICAgICAgICAgIHRhcmdldDogNjAsXHJcbiAgICAvLyAgICAgICAgICBtYXg6IDEyMFxyXG4gICAgLy8gICAgICAgICAgZm9yY2VTZXRUaW1lT3V0OiBmYWxzZSxcclxuICAgIC8vICAgICAgICAgIGRlbHRhSGlzdG9yeTogMTBcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgdGhpcy5mcHMgPSBHZXRWYWx1ZShjb25maWcsICdmcHMnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLnBpeGVsQXJ0ID0gR2V0VmFsdWUoY29uZmlnLCAncGl4ZWxBcnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XHJcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gR2V0VmFsdWUoY29uZmlnLCAnY2xlYXJCZWZvcmVSZW5kZXInLCB0cnVlKTtcclxuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gVmFsdWVUb0NvbG9yKEdldFZhbHVlKGNvbmZpZywgJ2JhY2tncm91bmRDb2xvcicsIDApKTtcclxuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gVmFsdWVUb0NvbG9yKEdldFZhbHVlKGNvbmZpZywgJ3ByZXNlcnZlRHJhd2luZ0J1ZmZlcicsIGZhbHNlKSk7XHJcblxyXG4gICAgLy8gIENhbGxiYWNrc1xyXG4gICAgdGhpcy5wcmVCb290ID0gR2V0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnByZUJvb3QnLCBOT09QKTtcclxuICAgIHRoaXMucG9zdEJvb3QgPSBHZXRWYWx1ZShjb25maWcsICdjYWxsYmFja3MucG9zdEJvb3QnLCBOT09QKTtcclxuXHJcbiAgICB0aGlzLnVzZVRpY2tlciA9IEdldFZhbHVlKGNvbmZpZywgJ3VzZVRpY2tlcicsIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgRGVmYXVsdCAvIE1pc3NpbmcgSW1hZ2VzXHJcbiAgICB2YXIgcG5nUHJlZml4ID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZyc7XHJcblxyXG4gICAgdGhpcy5kZWZhdWx0SW1hZ2UgPSBHZXRWYWx1ZShjb25maWcsICdpbWFnZXMuZGVmYXVsdCcsIHBuZ1ByZWZpeCArICdBUU1BQUFCSnRPaTNBQUFBQTFCTVZFWC8vLytueEJ2SUFBQUFBWFJTVGxNQVFPYllaZ0FBQUJWSlJFRlVlRjdOd0lFQUFBQUFnS0Q5cWRlb2NBTUFvQUFCbTNEa2NBQUFBQUJKUlU1RXJrSmdnZz09Jyk7XHJcbiAgICB0aGlzLm1pc3NpbmdJbWFnZSA9IEdldFZhbHVlKGNvbmZpZywgJ2ltYWdlcy5taXNzaW5nJywgcG5nUHJlZml4ICsgJ0NBSUFBQUQ4R08yakFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSjlKUkVGVWVOcTAxc3NPd3lBTVJGRzQ2di8vTXQxRVNtZ2grREZtRTJHUE9CQVJLYjJOVmpvKzE3UFhMRDhhMStwbDUrQSt3U2dGeWd5bVdZSEJiMEZ0c0toSkRkWmxuY0cySXpKNGF5b01EdjIwd1RtU016Q2xFZ2JXWU5UQWtRMForT0orQS9lV25BYVI5K294Q0Y0T3MwSDhodHNNVXArcHdjZ0JCaU1ObkF3RjhHcUlnTDJoQXphR0ZGZ1phdURQS0FCbW93WjRHTDM2OS8wcndBQ3AyeUEvdHRtdnNRQUFBQUJKUlU1RXJrSmdnZz09Jyk7XHJcbn07XHJcblxyXG5Db25maWcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZmlnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25maWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdC9Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDMyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XHJcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2RldmljZS9GZWF0dXJlcycpO1xyXG52YXIgQ2FudmFzUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXInKTtcclxudmFyIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XHJcbnZhciBDYW52YXNJbnRlcnBvbGF0aW9uID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24nKTtcclxuXHJcbi8qKlxyXG4qIENoZWNrcyBpZiB0aGUgZGV2aWNlIGlzIGNhcGFibGUgb2YgdXNpbmcgdGhlIHJlcXVlc3RlZCByZW5kZXJlciBhbmQgc2V0cyBpdCB1cCBvciBhbiBhbHRlcm5hdGl2ZSBpZiBub3QuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5HYW1lI3NldFVwUmVuZGVyZXJcclxuKiBAcHJvdGVjdGVkXHJcbiovXHJcbnZhciBDcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB2YXIgY29uZmlnID0gZ2FtZS5jb25maWc7XHJcblxyXG4gICAgLy8gIEdhbWUgZWl0aGVyIHJlcXVlc3RlZCBDYW52YXMsXHJcbiAgICAvLyAgb3IgcmVxdWVzdGVkIEFVVE8gb3IgV0VCR0wgYnV0IHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdCwgc28gZmFsbCBiYWNrIHRvIENhbnZhc1xyXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5DQU5WQVMgfHwgKGNvbmZpZy5yZW5kZXJUeXBlICE9PSBDT05TVC5DQU5WQVMgJiYgIUZlYXR1cmVzLndlYkdMKSlcclxuICAgIHtcclxuICAgICAgICBpZiAoRmVhdHVyZXMuY2FudmFzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZXkgcmVxdWVzdGVkIENhbnZhcyBhbmQgdGhlaXIgYnJvd3NlciBzdXBwb3J0cyBpdFxyXG4gICAgICAgICAgICBjb25maWcucmVuZGVyVHlwZSA9IENPTlNULkNBTlZBUztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIENhbnZhcyBvciBXZWJHTCBjb250ZXh0LCBhYm9ydGluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEdhbWUgcmVxdWVzdGVkIFdlYkdMIGFuZCBicm93c2VyIHNheXMgaXQgc3VwcG9ydHMgaXRcclxuICAgICAgICBjb25maWcucmVuZGVyVHlwZSA9IENPTlNULldFQkdMO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBQaXhlbCBBcnQgbW9kZT9cclxuICAgIGlmIChjb25maWcucGl4ZWxBcnQpXHJcbiAgICB7XHJcbiAgICAgICAgQ2FudmFzUG9vbC5kaXNhYmxlU21vb3RoaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgaXRzIG93biBjYW52YXMgZWxlbWVudCB0byB1c2U/XHJcbiAgICBpZiAoY29uZmlnLmNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBnYW1lLmNhbnZhcyA9IGNvbmZpZy5jYW52YXM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShnYW1lLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQsIGNvbmZpZy5yZW5kZXJUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBzb21lIGNhbnZhcyBjc3Mgc3R5bGVzIHRvIHVzZT9cclxuICAgIGlmIChjb25maWcuY2FudmFzU3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5jYW52YXMuc3R5bGUgPSBjb25maWcuY2FudmFzU3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFBpeGVsIEFydCBtb2RlP1xyXG4gICAgaWYgKGNvbmZpZy5waXhlbEFydClcclxuICAgIHtcclxuICAgICAgICBDYW52YXNJbnRlcnBvbGF0aW9uLnNldENyaXNwKGdhbWUuY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgWm9vbWVkP1xyXG4gICAgaWYgKGNvbmZpZy56b29tICE9PSAxKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gKGNvbmZpZy53aWR0aCAqIGNvbmZpZy56b29tKS50b1N0cmluZygpICsgJ3B4JztcclxuICAgICAgICBnYW1lLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAoY29uZmlnLmhlaWdodCAqIGNvbmZpZy56b29tKS50b1N0cmluZygpICsgJ3B4JztcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIHRoZSByZW5kZXJlclxyXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcclxuICAgIHtcclxuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoZ2FtZSk7XHJcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKGdhbWUpO1xyXG4gICAgICAgIGdhbWUuY29udGV4dCA9IGdhbWUucmVuZGVyZXIuZ2FtZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vICBkZWJ1Z1xyXG4gICAgICAgIGdhbWUuY2FudmFzLmlkID0gJ2dhbWUnO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIENIRUNLU1VNID0gcmVxdWlyZSgnLi4vY2hlY2tzdW0nKTtcclxuXHJcbnZhciBEZWJ1Z0hlYWRlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB2YXIgY29uZmlnID0gZ2FtZS5jb25maWc7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5oaWRlQmFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVuZGVyVHlwZSA9IChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTKSA/ICdDYW52YXMnIDogJ1dlYkdMJztcclxuXHJcbiAgICB2YXIgaWUgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIWllKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjID0gJyc7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbY107XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RDb2xvcjtcclxuXHJcbiAgICAgICAgICAgIGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IuZm9yRWFjaChmdW5jdGlvbihjb2xvcikge1xyXG5cclxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnJWMgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdiYWNrZ3JvdW5kOiAnICsgY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RDb2xvciA9IGNvbG9yO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyAgaW5qZWN0IHRoZSB0ZXh0IGNvbG9yXHJcbiAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9ICdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgbGFzdENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjID0gYy5jb25jYXQoJyVjICcpO1xyXG5cclxuICAgICAgICAgICAgYXJncy5wdXNoKCdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgVVJMIGxpbmsgYmFja2dyb3VuZCBjb2xvciAoYWx3YXlzIHdoaXRlKVxyXG4gICAgICAgIGFyZ3MucHVzaCgnYmFja2dyb3VuZDogI2ZmZicpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmdhbWVUaXRsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdChjb25maWcuZ2FtZVRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuZ2FtZVZlcnNpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnIHYnICsgY29uZmlnLmdhbWVWZXJzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCcgLyAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnUGhhc2VyIHYnICsgQ09OU1QuVkVSU0lPTiArICcgKCcgKyByZW5kZXJUeXBlICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGMgPSBjLmNvbmNhdCgnICVjICcgKyBjb25maWcuZ2FtZVVSTCk7XHJcblxyXG4gICAgICAgIC8vICBJbmplY3QgdGhlIG5ldyBzdHJpbmcgYmFjayBpbnRvIHRoZSBhcmdzIGFycmF5XHJcbiAgICAgICAgYXJnc1swXSA9IGM7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2luZG93Wydjb25zb2xlJ10pXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1BoYXNlciB2JyArIENPTlNULlZFUlNJT04gKyAnIC8gaHR0cDovL3BoYXNlci5pbycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEtlZXAgdGhpcyBkdXJpbmcgZGV2IGJ1aWxkIG9ubHlcclxuICAgIGNvbnNvbGUubG9nKENIRUNLU1VNLmJ1aWxkKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnSGVhZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Jvb3QvRGVidWdIZWFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTk9PUCA9IHJlcXVpcmUoJy4uL3V0aWxzL05PT1AnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuLi9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XHJcblxyXG4vLyAgRnJhbWUgUmF0ZSBjb25maWdcclxuLy8gICAgICBmcHM6IHtcclxuLy8gICAgICAgICAgbWluOiAxMCxcclxuLy8gICAgICAgICAgdGFyZ2V0OiA2MCxcclxuLy8gICAgICAgICAgbWF4OiAxMjBcclxuLy8gICAgICAgICAgZm9yY2VTZXRUaW1lT3V0OiBmYWxzZSxcclxuLy8gICAgICAgICAgZGVsdGFIaXN0b3J5OiAxMCxcclxuLy8gICAgICAgICAgcGFuaWNNYXg6IDEyMFxyXG4vLyAgICAgfVxyXG5cclxuLy8gaHR0cDovL3d3dy50ZXN0dWZvLmNvbS8jdGVzdD1hbmltYXRpb24tdGltZS1ncmFwaFxyXG4vLyBcclxuXHJcbnZhciBUaW1lU3RlcCA9IGZ1bmN0aW9uIChnYW1lLCBjb25maWcpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcblxyXG4gICAgdGhpcy5yYWYgPSBuZXcgUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XHJcblxyXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgdGhpcy5taW5GcHMgPSBHZXRWYWx1ZShjb25maWcsICdtaW4nLCA1KTtcclxuICAgIHRoaXMubWF4RnBzID0gR2V0VmFsdWUoY29uZmlnLCAnbWF4JywgMTIwKTtcclxuICAgIHRoaXMudGFyZ2V0RnBzID0gR2V0VmFsdWUoY29uZmlnLCAndGFyZ2V0JywgNjApO1xyXG5cclxuICAgIHRoaXMuX21pbiA9IDEwMDAgLyB0aGlzLm1pbkZwczsgICAgICAgICAvLyAgMjAwbXMgYmV0d2VlbiBmcmFtZXMgKGkuZS4gc3VwZXIgc2xvdyEpXHJcbiAgICB0aGlzLl9tYXggPSAxMDAwIC8gdGhpcy5tYXhGcHM7ICAgICAgICAgLy8gIDguMzMzbXMgYmV0d2VlbiBmcmFtZXMgKGkuZS4gc3VwZXIgZmFzdCwgMTIwSHogZGlzcGxheXMpXHJcbiAgICB0aGlzLl90YXJnZXQgPSAxMDAwIC8gdGhpcy50YXJnZXRGcHM7ICAgLy8gIDE2LjY2Nm1zIGJldHdlZW4gZnJhbWVzIChpLmUuIG5vcm1hbClcclxuXHJcbiAgICAvLyAgMjAwIC8gMTAwMCA9IDAuMiAoNWZwcylcclxuICAgIC8vICA4LjMzMyAvIDEwMDAgPSAwLjAwODMzMyAoMTIwZnBzKVxyXG4gICAgLy8gIDE2LjY2NiAvIDEwMDAgPSAwLjAxNjY2ICg2MGZwcylcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZwcyAtIEFuIGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIG9mIHRoZSBmcmFtZXMgcGVyIHNlY29uZC5cclxuICAgICogQHJlYWRPbmx5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5hY3R1YWxGcHMgPSB0aGlzLnRhcmdldEZwcztcclxuXHJcbiAgICB0aGlzLm5leHRGcHNVcGRhdGUgPSAwO1xyXG4gICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcclxuXHJcbiAgICB0aGlzLmNhbGxiYWNrID0gTk9PUDtcclxuXHJcbiAgICB0aGlzLmZvcmNlU2V0VGltZU91dCA9IEdldFZhbHVlKGNvbmZpZywgJ2ZvcmNlU2V0VGltZU91dCcsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5sYXN0VGltZSA9IDA7XHJcbiAgICB0aGlzLmZyYW1lID0gMDtcclxuXHJcbiAgICB0aGlzLmluRm9jdXMgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX3BhdXNlVGltZSA9IDA7XHJcbiAgICB0aGlzLl9jb29sRG93biA9IDA7XHJcblxyXG4gICAgdGhpcy5kZWx0YSA9IDA7XHJcbiAgICB0aGlzLmRlbHRhSW5kZXggPSAwO1xyXG4gICAgdGhpcy5kZWx0YUhpc3RvcnkgPSBbXTtcclxuICAgIHRoaXMuZGVsdGFTbW9vdGhpbmdNYXggPSBHZXRWYWx1ZShjb25maWcsICdkZWx0YUhpc3RvcnknLCAxMCk7XHJcbiAgICB0aGlzLnBhbmljTWF4ID0gR2V0VmFsdWUoY29uZmlnLCAncGFuaWNNYXgnLCAxMjApO1xyXG5cclxuICAgIC8vICBUaGUgYWN0dWFsIGVsYXBzZWQgdGltZSBpbiBtcyBiZXR3ZWVuIG9uZSB1cGRhdGUgYW5kIHRoZSBuZXh0LlxyXG4gICAgLy8gIE5vIHNtb290aGluZywgbm8gY2FwcGluZywgbm8gYXZlcmFnaW5nLiBTbyBwbGVhc2UgYmUgYXdhcmUgb2YgdGhpcyB3aGVuIHVzaW5nIHRoZSBjb250ZW50cyBvZiB0aGlzIHByb3BlcnR5LlxyXG4gICAgdGhpcy5yYXdEZWx0YSA9IDA7XHJcbn07XHJcblxyXG5UaW1lU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaW1lU3RlcDtcclxuXHJcblRpbWVTdGVwLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIERPTSB3aW5kb3cub25CbHVyIGV2ZW50IHRyaWdnZXJzXHJcbiAgICBibHVyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaW5Gb2N1cyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnVGltZVN0ZXAuYmx1cicpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIERPTSB3aW5kb3cub25Gb2N1cyBldmVudCB0cmlnZ2Vyc1xyXG4gICAgZm9jdXM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5pbkZvY3VzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1RpbWVTdGVwLmZvY3VzJyk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXREZWx0YSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgQVBJIHNheXMgdGhlIGdhbWUgaXMgJ2hpZGRlbicgKHRhYiBzd2l0Y2gsIGV0YylcclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdUaW1lU3RlcC5wYXVzZScpO1xyXG5cclxuICAgICAgICB0aGlzLl9wYXVzZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBBUEkgc2F5cyB0aGUgZ2FtZSBpcyAndmlzaWJsZScgYWdhaW4gKHRhYiBzd2l0Y2gsIGV0YylcclxuICAgIHJlc3VtZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0RGVsdGEoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgKz0gdGhpcy50aW1lIC0gdGhpcy5fcGF1c2VUaW1lO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnVGltZVN0ZXAucmVzdW1lIC0gcGF1c2VkIGZvcicsICh0aGlzLnRpbWUgLSB0aGlzLl9wYXVzZVRpbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXREZWx0YTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgICAgICB0aGlzLnRpbWUgPSBub3c7XHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IG5vdztcclxuICAgICAgICB0aGlzLm5leHRGcHNVcGRhdGUgPSBub3cgKyAxMDAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XHJcblxyXG4gICAgICAgIC8vICBQcmUtcG9wdWxhdGUgc21vb3RoaW5nIGFycmF5XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kZWx0YVNtb290aGluZ01heDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YUhpc3RvcnlbaV0gPSB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRlbHRhID0gMDtcclxuICAgICAgICB0aGlzLmRlbHRhSW5kZXggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl9jb29sRG93biA9IHRoaXMucGFuaWNNYXg7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmRlbHRhSGlzdG9yeSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2V0RGVsdGEoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQodGhpcy5zdGVwLmJpbmQodGhpcyksIHRoaXMuZm9yY2VTZXRUaW1lT3V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIHRpbWUgY29tZXMgZnJvbSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGlzIGVpdGhlciBhIGhpZ2ggcmVzIHRpbWUgdmFsdWUsXHJcbiAgICAvLyAgb3IgRGF0ZS5ub3cgaWYgdXNpbmcgc2V0VGltZW91dFxyXG4gICAgc3RlcDogZnVuY3Rpb24gKHRpbWUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIERlYnVnIG9ubHlcclxuICAgICAgICAvLyB2YXIgZGVidWcgPSAwO1xyXG4gICAgICAgIC8vIHZhciBkdW1wID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWUrKztcclxuXHJcbiAgICAgICAgdGhpcy5yYXdEZWx0YSA9IHRpbWUgLSB0aGlzLmxhc3RUaW1lO1xyXG5cclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5kZWx0YUluZGV4O1xyXG4gICAgICAgIHZhciBoaXN0b3J5ID0gdGhpcy5kZWx0YUhpc3Rvcnk7XHJcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuZGVsdGFTbW9vdGhpbmdNYXg7XHJcblxyXG4gICAgICAgIC8vICBkZWx0YSB0aW1lICh0aW1lIGlzIGluIG1zKVxyXG4gICAgICAgIHZhciBkdCA9ICh0aW1lIC0gdGhpcy5sYXN0VGltZSk7XHJcblxyXG4gICAgICAgIC8vICBXaGVuIGEgYnJvd3NlciBzd2l0Y2hlcyB0YWIsIHRoZW4gY29tZXMgYmFjayBhZ2FpbiwgaXQgdGFrZXMgYXJvdW5kIDEwIGZyYW1lcyBiZWZvcmVcclxuICAgICAgICAvLyAgdGhlIGRlbHRhIHRpbWUgc2V0dGxlcyBkb3duIHNvIHdlIGVtcGxveSBhICdjb29saW5nIGRvd24nIHBlcmlvZCBiZWZvcmUgd2Ugc3RhcnRcclxuICAgICAgICAvLyAgdHJ1c3RpbmcgdGhlIGRlbHRhIHZhbHVlcyBhZ2FpbiwgdG8gYXZvaWQgc3Bpa2VzIGZsb29kaW5nIHRocm91Z2ggb3VyIGRlbHRhIGF2ZXJhZ2VcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2Nvb2xEb3duID4gMCB8fCAhdGhpcy5pbkZvY3VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fY29vbERvd24tLTtcclxuXHJcbiAgICAgICAgICAgIGR0ID0gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICAvLyBkZWJ1ZyA9ICh0aW1lIC0gdGhpcy5sYXN0VGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgbWluIC8gbWF4IHJhbmdlICh5ZXMsIHRoZSA8IGFuZCA+IHNob3VsZCBiZSB0aGlzIHdheSBhcm91bmQpXHJcbiAgICAgICAgaWYgKGR0ID4gdGhpcy5fbWluIHx8IGR0IDwgdGhpcy5fbWF4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFByb2JhYmx5IHN1cGVyIGJhZCBzdGFydCB0aW1lIG9yIGJyb3dzZXIgdGFiIGNvbnRleHQgbG9zcyxcclxuICAgICAgICAgICAgLy8gIHNvIHVzZSB0aGUgbGFzdCAnc2FuZScgZHQgdmFsdWVcclxuXHJcbiAgICAgICAgICAgIC8vIGRlYnVnID0gZHQ7XHJcblxyXG4gICAgICAgICAgICBkdCA9IGhpc3RvcnlbaWR4XTtcclxuXHJcbiAgICAgICAgICAgIC8vICBDbGFtcCBkZWx0YSB0byBtaW4gbWF4IHJhbmdlIChpbiBjYXNlIGhpc3RvcnkgaGFzIGJlY29tZSBjb3JydXB0ZWQgc29tZWhvdylcclxuICAgICAgICAgICAgZHQgPSBNYXRoLm1heChNYXRoLm1pbihkdCwgdGhpcy5fbWF4KSwgdGhpcy5fbWluKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBTbW9vdGggb3V0IHRoZSBkZWx0YSBvdmVyIHRoZSBwcmV2aW91cyBYIGZyYW1lc1xyXG5cclxuICAgICAgICAvLyAgYWRkIHRoZSBkZWx0YSB0byB0aGUgc21vb3RoaW5nIGFycmF5XHJcbiAgICAgICAgaGlzdG9yeVtpZHhdID0gZHQ7XHJcblxyXG4gICAgICAgIC8vICBhZGp1c3RzIHRoZSBkZWx0YSBoaXN0b3J5IGFycmF5IGluZGV4IGJhc2VkIG9uIHRoZSBzbW9vdGhpbmcgY291bnRcclxuICAgICAgICAvLyAgdGhpcyBzdG9wcyB0aGUgYXJyYXkgZ3Jvd2luZyBiZXlvbmQgdGhlIHNpemUgb2YgZGVsdGFTbW9vdGhpbmdNYXhcclxuICAgICAgICB0aGlzLmRlbHRhSW5kZXgrKztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVsdGFJbmRleCA+IG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRGVsdGEgQXZlcmFnZVxyXG4gICAgICAgIHZhciBhdmcgPSAwO1xyXG5cclxuICAgICAgICAvLyAgTG9vcCB0aGUgaGlzdG9yeSBhcnJheSwgYWRkaW5nIHRoZSBkZWx0YSB2YWx1ZXMgdG9nZXRoZXJcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgRGVidWdcclxuICAgICAgICAgICAgLy8gaWYgKGhpc3RvcnlbaV0gPCAxNiB8fCBoaXN0b3J5W2ldID4gMTcpXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIGR1bXAucHVzaCh7IGk6IGksIGR0OiBoaXN0b3J5W2ldIH0pO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBhdmcgKz0gaGlzdG9yeVtpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBUaGVuIGRpdmlkZSBieSB0aGUgYXJyYXkgbGVuZ3RoIHRvIGdldCB0aGUgYXZlcmFnZSBkZWx0YVxyXG4gICAgICAgIGF2ZyAvPSBtYXg7XHJcblxyXG4gICAgICAgIC8vICBTZXQgYXMgdGhlIHdvcmxkIGRlbHRhIHZhbHVlXHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGF2ZztcclxuXHJcbiAgICAgICAgLy8gIFJlYWwtd29ybGQgdGltZXIgYWR2YW5jZVxyXG4gICAgICAgIC8vIHRoaXMudGltZSArPSBhdmc7XHJcbiAgICAgICAgdGhpcy50aW1lICs9IHRoaXMucmF3RGVsdGE7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZXN0aW1hdGUgb2YgdGhlIGZyYW1lIHJhdGUsIGBmcHNgLiBFdmVyeSBzZWNvbmQsIHRoZSBudW1iZXJcclxuICAgICAgICAvLyBvZiBmcmFtZXMgdGhhdCBvY2N1cnJlZCBpbiB0aGF0IHNlY29uZCBhcmUgaW5jbHVkZWQgaW4gYW4gZXhwb25lbnRpYWxcclxuICAgICAgICAvLyBtb3ZpbmcgYXZlcmFnZSBvZiBhbGwgZnJhbWVzIHBlciBzZWNvbmQsIHdpdGggYW4gYWxwaGEgb2YgMC4yNS4gVGhpc1xyXG4gICAgICAgIC8vIG1lYW5zIHRoYXQgbW9yZSByZWNlbnQgc2Vjb25kcyBhZmZlY3QgdGhlIGVzdGltYXRlZCBmcmFtZSByYXRlIG1vcmUgdGhhblxyXG4gICAgICAgIC8vIG9sZGVyIHNlY29uZHMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXaGVuIGEgYnJvd3NlciB3aW5kb3cgaXMgTk9UIG1pbmltaXplZCwgYnV0IGlzIGNvdmVyZWQgdXAgKGkuZS4geW91J3JlIHVzaW5nXHJcbiAgICAgICAgLy8gYW5vdGhlciBhcHAgd2hpY2ggaGFzIHNwYXduZWQgYSB3aW5kb3cgb3ZlciB0aGUgdG9wIG9mIHRoZSBicm93c2VyKSwgdGhlbiBpdFxyXG4gICAgICAgIC8vIHdpbGwgc3RhcnQgdG8gdGhyb3R0bGUgdGhlIHJhZiBjYWxsYmFjayB0aW1lLiBJdCB3YWl0cyBmb3IgYSB3aGlsZSwgYW5kIHRoZW5cclxuICAgICAgICAvLyBzdGFydHMgdG8gZHJvcCB0aGUgZnJhbWUgcmF0ZSBhdCAxIGZyYW1lIHBlciBzZWNvbmQgdW50aWwgaXQncyBkb3duIHRvIGp1c3Qgb3ZlciAxZnBzLlxyXG4gICAgICAgIC8vIFNvIGlmIHRoZSBnYW1lIHdhcyBydW5uaW5nIGF0IDYwZnBzLCBhbmQgdGhlIHBsYXllciBvcGVucyBhIG5ldyB3aW5kb3csIHRoZW5cclxuICAgICAgICAvLyBhZnRlciA2MCBzZWNvbmRzICgrIHRoZSAnYnVmZmVyIHRpbWUnKSBpdCdsbCBiZSBkb3duIHRvIDFmcHMsIHNvIHJhZmluJ2cgYXQgMUh6LlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2hlbiB0aGV5IG1ha2UgdGhlIGdhbWUgdmlzaWJsZSBhZ2FpbiwgdGhlIGZyYW1lIHJhdGUgaXMgaW5jcmVhc2VkIGF0IGEgcmF0ZSBvZlxyXG4gICAgICAgIC8vIGFwcHJveC4gOGZwcywgYmFjayB1cCB0byA2MGZwcyAob3IgdGhlIG1heCBpdCBjYW4gb2J0YWluKVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgZHJvcCBpbiBmcmFtZSByYXRlIGlzIGJlY2F1c2UgdGhlXHJcbiAgICAgICAgLy8gYnJvd3NlciBpcyB0aHJvdHRsaW5nIHJhZiwgb3IgYmVjYXVzZSB0aGUgZ2FtZSBpcyBzdHJ1Z2dsaW5nIHdpdGggcGVyZm9ybWFuY2VcclxuICAgICAgICAvLyBiZWNhdXNlIHlvdSdyZSBhc2tpbmcgaXQgdG8gZG8gdG9vIG11Y2ggb24gdGhlIGRldmljZS5cclxuXHJcbiAgICAgICAgaWYgKHRpbWUgPiB0aGlzLm5leHRGcHNVcGRhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQ29tcHV0ZSB0aGUgbmV3IGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIHdpdGggYW4gYWxwaGEgb2YgMC4yNS5cclxuICAgICAgICAgICAgdGhpcy5hY3R1YWxGcHMgPSAwLjI1ICogdGhpcy5mcmFtZXNUaGlzU2Vjb25kICsgMC43NSAqIHRoaXMuYWN0dWFsRnBzO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRGcHNVcGRhdGUgPSB0aW1lICsgMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmFjdHVhbEZwcyA8IDU2KVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyh0aGlzLmFjdHVhbEZwcyk7XHJcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnRicsIHRoaXMuZnJhbWUsICdBdmcnLCBhdmcsICdEdCcsIGRlYnVnLCAnUGFuaWMnLCB0aGlzLl9jb29sRG93bik7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCsrO1xyXG5cclxuICAgICAgICAvLyAgSW50ZXJwb2xhdGlvbiAtIGhvdyBmYXIgYmV0d2VlbiB3aGF0IGlzIGV4cGVjdGVkIGFuZCB3aGVyZSB3ZSBhcmU/XHJcbiAgICAgICAgdmFyIGludGVycG9sYXRpb24gPSBhdmcgLyB0aGlzLl90YXJnZXQ7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGltZSwgYXZnLCBpbnRlcnBvbGF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gIFNoaWZ0IHRpbWUgdmFsdWUgb3ZlclxyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0aW1lO1xyXG5cclxuICAgICAgICAvLyBpZiAoZGVidWcgIT09IDApXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnRicsIHRoaXMuZnJhbWUsICdBdmcnLCBhdmcsICdEdCcsIGRlYnVnLCAnUGFuaWMnLCB0aGlzLl9jb29sRG93bik7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIGlmIChkZWJ1ZyAhPT0gMCB8fCBkdW1wLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoJ0ZyYW1lICcgKyB0aGlzLmZyYW1lKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludGVycG9sYXRpb24nLCBpbnRlcnBvbGF0aW9uLCAnJScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlYnVnKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRWxhcHNlZCcsIGRlYnVnLCAnbXMnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZyYW1lJywgdGhpcy5mcmFtZSwgJ0RlbHRhJywgYXZnLCAnKGF2ZXJhZ2UpJywgZGVidWcsICcobm93KScpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RlbHRhJywgYXZnLCAnKGF2ZXJhZ2UpJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZHVtcC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUudGFibGUoZHVtcCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgIH0sXHJcblxyXG4gICAgdGljazogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0ZXAod2luZG93LnBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2xlZXA6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMucmFmLnN0b3AoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd2FrZTogZnVuY3Rpb24gKHNlYW1sZXNzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlYW1sZXNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgKz0gLXRoaXMubGFzdFRpbWUgKyAodGhpcy5sYXN0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJhZi5zdGFydCh0aGlzLnN0ZXAuYmluZCh0aGlzKSwgdGhpcy51c2VSQUYpO1xyXG5cclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLnN0ZXAod2luZG93LnBlcmZvcm1hbmNlLm5vdygpKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RnBzOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mcHMgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgdGhpcy53YWtlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZwczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMucmFmLnN0b3AoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Jvb3QvVGltZVN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBWaXNpYmlsaXR5SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudERpc3BhdGNoZXIpXHJcbntcclxuICAgIHZhciBoaWRkZW5WYXI7XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LmhpZGRlbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIGhpZGRlblZhciA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVuZG9ycyA9IFsgJ3dlYmtpdCcsICdtb3onLCAnbXMnIF07XHJcblxyXG4gICAgICAgIHZlbmRvcnMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50W3ByZWZpeCArICdIaWRkZW4nXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oaWRkZW4gPSBmdW5jdGlvbiAoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFtwcmVmaXggKyAnSGlkZGVuJ107XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGhpZGRlblZhciA9IHByZWZpeCArICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbiB8fCBldmVudC50eXBlID09PSAncGF1c2UnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoKG5ldyBFdmVudCgnSElEREVOJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZGlzcGF0Y2gobmV3IEV2ZW50KCdWSVNJQkxFJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gIERvZXMgYnJvd3NlciBzdXBwb3J0IGl0P1xyXG4gICAgLy8gIElmIG5vdCAobGlrZSBpbiBJRTkgb3Igb2xkIEFuZHJvaWQpIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGJsdXIgLyBmb2N1c1xyXG4gICAgaWYgKGhpZGRlblZhcilcclxuICAgIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGhpZGRlblZhciwgb25DaGFuZ2UsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnRmFsbGJhY2sgVE9ETycpO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaChuZXcgRXZlbnQoJ09OX0JMVVInKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBldmVudERpc3BhdGNoZXIuZGlzcGF0Y2gobmV3IEV2ZW50KCdPTl9GT0NVUycpKTtcclxuICAgIH07XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWaXNpYmlsaXR5SGFuZGxlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ib290L1Zpc2liaWxpdHlIYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhY2hlRW50cnkgPSByZXF1aXJlKCcuL0NhY2hlRW50cnknKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcblxyXG52YXIgQmFzZUNhY2hlID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgdGhpcy5lbnRyaWVzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG59O1xyXG5cclxuQmFzZUNhY2hlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VDYWNoZTtcclxuXHJcbkJhc2VDYWNoZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZW50cmllcy5zZXQoa2V5LCBkYXRhKTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50cy5DQUNIRV9BRERfRVZFTlQodGhpcywga2V5LCBkYXRhKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmhhcyhrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5nZXQoa2V5KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgIGlmIChlbnRyeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5kZWxldGUoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ0FDSEVfUkVNT1ZFX0VWRU5UKHRoaXMsIGtleSwgZW50cnkuZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmVudHJpZXMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDYWNoZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYWNoZS9CYXNlQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmFzZUNhY2hlID0gcmVxdWlyZSgnLi9CYXNlQ2FjaGUnKTtcclxuXHJcbnZhciBDYWNoZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHRoaXMuc291bmQgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLnZpZGVvID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgdGhpcy50ZXh0ID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgdGhpcy5qc29uID0gbmV3IEJhc2VDYWNoZSgpO1xyXG4gICAgdGhpcy54bWwgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLnBoeXNpY3MgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLnRpbGVtYXAgPSBuZXcgQmFzZUNhY2hlKCk7XHJcbiAgICB0aGlzLmJpbmFyeSA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMuYml0bWFwRm9udCA9IG5ldyBCYXNlQ2FjaGUoKTtcclxuICAgIHRoaXMuc2hhZGVyID0gbmV3IEJhc2VDYWNoZSgpO1xyXG5cclxuICAgIHRoaXMuY3VzdG9tID0ge307XHJcbn07XHJcblxyXG5DYWNoZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZTtcclxuXHJcbkNhY2hlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvLyAgQWRkIHlvdXIgb3duIGN1c3RvbSBDYWNoZSBlbnRyeSwgYXZhaWxhYmxlIHVuZGVyIENhY2hlLmN1c3RvbS5rZXlcclxuICAgIGFkZEN1c3RvbTogZnVuY3Rpb24gKGtleSlcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVtrZXldID0gbmV3IEJhc2VDYWNoZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FjaGUvQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FjaGVFbnRyeSA9IGZ1bmN0aW9uIChrZXksIHVybCwgZGF0YSlcclxue1xyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcblxyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxufTtcclxuXHJcbkNhY2hlRW50cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FjaGVFbnRyeTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVFbnRyeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jYWNoZS9DYWNoZUVudHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVBZGRFdmVudCA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhKVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn07XHJcblxyXG5DYWNoZUFkZEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuQ2FjaGVBZGRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZUFkZEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZUFkZEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgQ2FjaGVSZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChjYWNoZSwga2V5LCBkYXRhKVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn07XHJcblxyXG5DYWNoZVJlbW92ZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuQ2FjaGVSZW1vdmVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWNoZVJlbW92ZUV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVJlbW92ZUV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ0FDSEVfQUREX0VWRU5UOiByZXF1aXJlKCcuL0NhY2hlQWRkRXZlbnQnKSxcclxuICAgIENBQ0hFX1JFTU9WRV9FVkVOVDogcmVxdWlyZSgnLi9DYWNoZVJlbW92ZUV2ZW50JylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FjaGUvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vLyAgdmFyIGNhbUNvbnRyb2wgPSBuZXcgQ2FtZXJhQ29udHJvbCh7XHJcbi8vICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYXMubWFpbixcclxuLy8gICAgICBsZWZ0OiBjdXJzb3JzLmxlZnQsXHJcbi8vICAgICAgcmlnaHQ6IGN1cnNvcnMucmlnaHQsXHJcbi8vICAgICAgc3BlZWQ6IGZsb2F0IE9SIHsgeDogMCwgeTogMCB9XHJcbi8vICB9KVxyXG5cclxudmFyIEtleUNvbnRyb2wgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmNhbWVyYSA9IEdldFZhbHVlKGNvbmZpZywgJ2NhbWVyYScsIG51bGwpO1xyXG5cclxuICAgIHRoaXMubGVmdCA9IEdldFZhbHVlKGNvbmZpZywgJ2xlZnQnLCBudWxsKTtcclxuICAgIHRoaXMucmlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdyaWdodCcsIG51bGwpO1xyXG4gICAgdGhpcy51cCA9IEdldFZhbHVlKGNvbmZpZywgJ3VwJywgbnVsbCk7XHJcbiAgICB0aGlzLmRvd24gPSBHZXRWYWx1ZShjb25maWcsICdkb3duJywgbnVsbCk7XHJcblxyXG4gICAgdmFyIHNwZWVkID0gR2V0VmFsdWUoY29uZmlnLCAnc3BlZWQnLCBudWxsKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHNwZWVkID09PSAnbnVtYmVyJylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNwZWVkWCA9IHNwZWVkO1xyXG4gICAgICAgIHRoaXMuc3BlZWRZID0gc3BlZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zcGVlZFggPSBHZXRWYWx1ZShjb25maWcsICdzcGVlZC54JywgMCk7XHJcbiAgICAgICAgdGhpcy5zcGVlZFkgPSBHZXRWYWx1ZShjb25maWcsICdzcGVlZC55JywgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY3RpdmUgPSAodGhpcy5jYW1lcmEgIT09IG51bGwpO1xyXG59O1xyXG5cclxuS2V5Q29udHJvbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlDb250cm9sO1xyXG5cclxuS2V5Q29udHJvbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAodGhpcy5jYW1lcmEgIT09IG51bGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVsdGEgPT09IHVuZGVmaW5lZCkgeyBkZWx0YSA9IDE7IH1cclxuXHJcbiAgICAgICAgdmFyIGNhbSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51cCAmJiB0aGlzLnVwLmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbS5zY3JvbGxZIC09ICgodGhpcy5zcGVlZFkgKiBkZWx0YSkgfCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb3duICYmIHRoaXMuZG93bi5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWSArPSAoKHRoaXMuc3BlZWRZICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWCAtPSAoKHRoaXMuc3BlZWRYICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWCArPSAoKHRoaXMuc3BlZWRYICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRvd24gPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXlDb250cm9sO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NhbWVyYS9LZXlDb250cm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vLyAgdmFyIGNhbUNvbnRyb2wgPSBuZXcgU21vb3RoZWRLZXlDb250cm9sKHtcclxuLy8gICAgICBjYW1lcmE6IHRoaXMuY2FtZXJhcy5tYWluLFxyXG4vLyAgICAgIGxlZnQ6IGN1cnNvcnMubGVmdCxcclxuLy8gICAgICByaWdodDogY3Vyc29ycy5yaWdodCxcclxuLy8gICAgICBhY2NlbGVyYXRpb246IGZsb2F0IHx8IHsgeDogMCwgeTogMCB9XHJcbi8vICAgICAgZHJhZzogZmxvYXQgfHwgeyB4OiAwLCB5OiAwIH1cclxuLy8gICAgICBtYXhTcGVlZDogZmxvYXQgfHwgeyB4OiAwLCB5OiAwIH1cclxuLy8gIH0pXHJcblxyXG52YXIgU21vb3RoZWRLZXlDb250cm9sID0gZnVuY3Rpb24gKGNvbmZpZylcclxue1xyXG4gICAgdGhpcy5jYW1lcmEgPSBHZXRWYWx1ZShjb25maWcsICdjYW1lcmEnLCBudWxsKTtcclxuXHJcbiAgICB0aGlzLmxlZnQgPSBHZXRWYWx1ZShjb25maWcsICdsZWZ0JywgbnVsbCk7XHJcbiAgICB0aGlzLnJpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAncmlnaHQnLCBudWxsKTtcclxuICAgIHRoaXMudXAgPSBHZXRWYWx1ZShjb25maWcsICd1cCcsIG51bGwpO1xyXG4gICAgdGhpcy5kb3duID0gR2V0VmFsdWUoY29uZmlnLCAnZG93bicsIG51bGwpO1xyXG5cclxuICAgIHZhciBhY2NlbCA9IEdldFZhbHVlKGNvbmZpZywgJ2FjY2VsZXJhdGlvbicsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgYWNjZWwgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWNjZWxYID0gYWNjZWw7XHJcbiAgICAgICAgdGhpcy5hY2NlbFkgPSBhY2NlbDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjY2VsWCA9IEdldFZhbHVlKGNvbmZpZywgJ2FjY2VsZXJhdGlvbi54JywgMCk7XHJcbiAgICAgICAgdGhpcy5hY2NlbFkgPSBHZXRWYWx1ZShjb25maWcsICdhY2NlbGVyYXRpb24ueScsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkcmFnID0gR2V0VmFsdWUoY29uZmlnLCAnZHJhZycsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZHJhZyA9PT0gJ251bWJlcicpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kcmFnWCA9IGRyYWc7XHJcbiAgICAgICAgdGhpcy5kcmFnWSA9IGRyYWc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5kcmFnWCA9IEdldFZhbHVlKGNvbmZpZywgJ2RyYWcueCcsIDApO1xyXG4gICAgICAgIHRoaXMuZHJhZ1kgPSBHZXRWYWx1ZShjb25maWcsICdkcmFnLnknLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWF4U3BlZWQgPSBHZXRWYWx1ZShjb25maWcsICdtYXhTcGVlZCcsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbWF4U3BlZWQgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWF4U3BlZWRYID0gbWF4U3BlZWQ7XHJcbiAgICAgICAgdGhpcy5tYXhTcGVlZFkgPSBtYXhTcGVlZDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1heFNwZWVkWCA9IEdldFZhbHVlKGNvbmZpZywgJ21heFNwZWVkLngnLCAwKTtcclxuICAgICAgICB0aGlzLm1heFNwZWVkWSA9IEdldFZhbHVlKGNvbmZpZywgJ21heFNwZWVkLnknLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zcGVlZFggPSAwO1xyXG4gICAgdGhpcy5fc3BlZWRZID0gMDtcclxuXHJcbiAgICB0aGlzLmFjdGl2ZSA9ICh0aGlzLmNhbWVyYSAhPT0gbnVsbCk7XHJcbn07XHJcblxyXG5TbW9vdGhlZEtleUNvbnRyb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU21vb3RoZWRLZXlDb250cm9sO1xyXG5cclxuU21vb3RoZWRLZXlDb250cm9sLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9ICh0aGlzLmNhbWVyYSAhPT0gbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWx0YSA9PT0gdW5kZWZpbmVkKSB7IGRlbHRhID0gMTsgfVxyXG5cclxuICAgICAgICB2YXIgY2FtID0gdGhpcy5jYW1lcmE7XHJcblxyXG4gICAgICAgIC8vICBBcHBseSBEZWNlbGVyYXRpb25cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NwZWVkWCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggLT0gdGhpcy5kcmFnWCAqIGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWVkWCA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3BlZWRYIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWCArPSB0aGlzLmRyYWdYICogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRYID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NwZWVkWSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFkgLT0gdGhpcy5kcmFnWSAqIGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWVkWSA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3BlZWRZIDwgMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSArPSB0aGlzLmRyYWdZICogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRZID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENoZWNrIGZvciBrZXlzXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVwLmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSArPSB0aGlzLmFjY2VsWTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZFkgPiB0aGlzLm1heFNwZWVkWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gdGhpcy5tYXhTcGVlZFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb3duLmlzRG93bilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSAtPSB0aGlzLmFjY2VsWTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZFkgPCAtdGhpcy5tYXhTcGVlZFkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9IC10aGlzLm1heFNwZWVkWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0Rvd24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggKz0gdGhpcy5hY2NlbFg7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWRYID4gdGhpcy5tYXhTcGVlZFgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkWCA9IHRoaXMubWF4U3BlZWRYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmlnaHQuaXNEb3duKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRYIC09IHRoaXMuYWNjZWxYO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWVkWCA8IC10aGlzLm1heFNwZWVkWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gLXRoaXMubWF4U3BlZWRYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQXBwbHkgdG8gQ2FtZXJhXHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zcGVlZFggIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW0uc2Nyb2xsWCAtPSAoKHRoaXMuX3NwZWVkWCAqIGRlbHRhKSB8IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NwZWVkWSAhPT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbS5zY3JvbGxZIC09ICgodGhpcy5fc3BlZWRZICogZGVsdGEpIHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVwID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRvd24gPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhlZEtleUNvbnRyb2w7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2FtZXJhL1Ntb290aGVkS2V5Q29udHJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDSEVDS1NVTSA9IHtcbmJ1aWxkOiAnYWRiMDNlNzAtNWE3ZC0xMWU3LThlZTktZjdlZTY3ZDkzYzEzJ1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ0hFQ0tTVU07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jaGVja3N1bS5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFtcCA9IHJlcXVpcmUoJy4uL21hdGgvQ2xhbXAnKTtcclxuXHJcbi8vICBBbHBoYSBDb21wb25lbnRcclxuXHJcbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xyXG52YXIgX0ZMQUcgPSAyOyAvLyAwMDEwXHJcblxyXG52YXIgQWxwaGEgPSB7XHJcblxyXG4gICAgX2FscGhhOiAxLFxyXG5cclxuICAgIGFscGhhOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhID0gQ2xhbXAodmFsdWUsIDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBbHBoYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL0FscGhhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi9hbmltYXRpb24vJyk7XHJcblxyXG4vLyAgR2FtZSBPYmplY3QgQW5pbWF0aW9uIENvbnRyb2xsZXJcclxuXHJcbnZhciBBbmltYXRpb24gPSBuZXcgQ2xhc3Moe1xyXG5cclxuICAgIGluaXRpYWxpemU6XHJcblxyXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uIChwYXJlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFNwcml0ZSAvIEdhbWUgT2JqZWN0XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IHBhcmVudC5zdGF0ZS5zeXMuYW5pbXM7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5ldmVudHMub25jZSgnUkVNT1ZFX0FOSU1BVElPTl9FVkVOVCcsIHRoaXMucmVtb3ZlLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyAgUmVmZXJlbmNlIHRvIHRoZSBQaGFzZXIuQW5pbWF0aW9uIG9iamVjdFxyXG4gICAgICAgIHRoaXMuY3VycmVudEFuaW0gPSBudWxsO1xyXG5cclxuICAgICAgICAvLyAgUmVmZXJlbmNlIHRvIHRoZSBQaGFzZXIuQW5pbWF0aW9uRnJhbWUgb2JqZWN0XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyAgQW5pbWF0aW9uIHNwZWNpZmljIHZhbHVlc1xyXG4gICAgICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgIC8vICBTY2FsZSB0aGUgdGltZSAobWFrZSBpdCBnbyBmYXN0ZXIgLyBzbG93ZXIpXHJcbiAgICAgICAgLy8gIEZhY3RvciB0aGF0J3MgdXNlZCB0byBzY2FsZSB0aW1lIHdoZXJlIDEgPSBub3JtYWwgc3BlZWQgKHRoZSBkZWZhdWx0KSwgMC41ID0gaGFsZiBzcGVlZCwgMiA9IGRvdWJsZSBzcGVlZCwgZXRjLlxyXG4gICAgICAgIHRoaXMuX3RpbWVTY2FsZSA9IDE7XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgcmF0ZSBvZiBwbGF5YmFjayBpbiBmcmFtZXMgcGVyIHNlY29uZCAoZGVmYXVsdCAyNCBpZiBkdXJhdGlvbiBpcyBudWxsKVxyXG4gICAgICAgIHRoaXMuZnJhbWVSYXRlID0gMDtcclxuXHJcbiAgICAgICAgLy8gIEhvdyBsb25nIHRoZSBhbmltYXRpb24gc2hvdWxkIHBsYXkgZm9yLiBJZiBmcmFtZXJhdGUgaXMgc2V0IGl0IG92ZXJyaWRlcyB0aGlzIHZhbHVlXHJcbiAgICAgICAgLy8gIG90aGVyd2lzZSBmcmFtZXJhdGUgaXMgZGVyaXZlZCBmcm9tIGR1cmF0aW9uXHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIC8vICBtcyBwZXIgZnJhbWUgKHdpdGhvdXQgaW5jbHVkaW5nIGZyYW1lIHNwZWNpZmljIG1vZGlmaWVycylcclxuICAgICAgICB0aGlzLm1zUGVyRnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAvLyAgU2tpcCBmcmFtZXMgaWYgdGhlIHRpbWUgbGFncywgb3IgYWx3YXlzIGFkdmFuY2VkIGFueXdheT9cclxuICAgICAgICB0aGlzLnNraXBNaXNzZWRGcmFtZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyAgRGVsYXkgYmVmb3JlIHN0YXJ0aW5nIHBsYXliYWNrIChpbiBzZWNvbmRzKVxyXG4gICAgICAgIHRoaXMuX2RlbGF5ID0gMDtcclxuXHJcbiAgICAgICAgLy8gIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIGFuaW1hdGlvbiAoLTEgZm9yIGluZmluaXR5KVxyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IDA7XHJcblxyXG4gICAgICAgIC8vICBEZWxheSBiZWZvcmUgdGhlIHJlcGVhdCBzdGFydHMgKGluIHNlY29uZHMpXHJcbiAgICAgICAgdGhpcy5fcmVwZWF0RGVsYXkgPSAwO1xyXG5cclxuICAgICAgICAvLyAgU2hvdWxkIHRoZSBhbmltYXRpb24geW95bz8gKHJldmVyc2UgYmFjayBkb3duIHRvIHRoZSBzdGFydCkgYmVmb3JlIHJlcGVhdGluZz9cclxuICAgICAgICB0aGlzLl95b3lvID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vICBQbGF5aGVhZCB2YWx1ZXNcclxuICAgICAgICAvLyAgLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgIC8vICBNb3ZlIHRoZSBwbGF5aGVhZCBmb3J3YXJkICh0cnVlKSBvciBpbiByZXZlcnNlIChmYWxzZSlcclxuICAgICAgICB0aGlzLmZvcndhcmQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gMDtcclxuICAgICAgICB0aGlzLm5leHRUaWNrID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5yZXBlYXRDb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVwZWF0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3dhc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tBcmdzID0gWyBwYXJlbnQsIG51bGwgXTtcclxuICAgICAgICB0aGlzLl91cGRhdGVQYXJhbXMgPSBbXTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBkZWxheTogQ29tcG9uZW50cy5EZWxheSxcclxuICAgIGRlbGF5ZWRQbGF5OiBDb21wb25lbnRzLkRlbGF5ZWRQbGF5LFxyXG4gICAgZ2V0Q3VycmVudEtleTogQ29tcG9uZW50cy5HZXRDdXJyZW50S2V5LFxyXG4gICAgbG9hZDogQ29tcG9uZW50cy5Mb2FkLFxyXG4gICAgcGF1c2U6IENvbXBvbmVudHMuUGF1c2UsXHJcbiAgICBwYXVzZWQ6IENvbXBvbmVudHMuUGF1c2VkLFxyXG4gICAgcGxheTogQ29tcG9uZW50cy5QbGF5LFxyXG4gICAgcHJvZ3Jlc3M6IENvbXBvbmVudHMuUHJvZ3Jlc3MsXHJcbiAgICByZW1vdmU6IENvbXBvbmVudHMuUmVtb3ZlLFxyXG4gICAgcmVwZWF0OiBDb21wb25lbnRzLlJlcGVhdCxcclxuICAgIHJlcGVhdERlbGF5OiBDb21wb25lbnRzLlJlcGVhdERlbGF5LFxyXG4gICAgcmVzdGFydDogQ29tcG9uZW50cy5SZXN0YXJ0LFxyXG4gICAgcmVzdW1lOiBDb21wb25lbnRzLlJlc3VtZSxcclxuICAgIHN0b3A6IENvbXBvbmVudHMuU3RvcCxcclxuICAgIHRpbWVTY2FsZTogQ29tcG9uZW50cy5UaW1lU2NhbGUsXHJcbiAgICB0b3RhbEZyYW1lczogQ29tcG9uZW50cy5Ub3RhbEZyYW1lcyxcclxuICAgIHRvdGFsUHJvZ3Jlc3M6IENvbXBvbmVudHMuVG90YWxQcm9ncmVzcyxcclxuICAgIHVwZGF0ZTogQ29tcG9uZW50cy5VcGRhdGUsXHJcbiAgICB1cGRhdGVGcmFtZTogQ29tcG9uZW50cy5VcGRhdGVGcmFtZSxcclxuICAgIHlveW86IENvbXBvbmVudHMuWW95b1xyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvQmxlbmRNb2RlcycpO1xyXG5cclxuLy8gIEJsZW5kTW9kZSBDb21wb25lbnRcclxuXHJcbnZhciBCbGVuZE1vZGUgPSB7XHJcblxyXG4gICAgX2JsZW5kTW9kZTogQmxlbmRNb2Rlcy5OT1JNQUwsXHJcblxyXG4gICAgYmxlbmRNb2RlOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YWx1ZSB8IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxNilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsZW5kTW9kZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL0JsZW5kTW9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBDaGlsZHJlbiBDb21wb25lbnQgZmVhdHVyZXMgcXVpY2sgYWNjZXNzIHRvIEdyb3VwIHNvcnRpbmcgcmVsYXRlZCBtZXRob2RzLlxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBDaGlsZHJlbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xyXG5cclxuICAgIC8vICBUaGUgb2JqZWN0cyB0aGF0IGJlbG9uZyB0byB0aGlzIGNvbGxlY3Rpb24uXHJcbiAgICAvLyAgVGhlIGVxdWl2YWxlbnQgb2YgdGhlIG9sZCBgU3ByaXRlLmNoaWxkcmVuYCBhcnJheS5cclxuICAgIHRoaXMubGlzdCA9IFtdO1xyXG5cclxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG59O1xyXG5cclxuQ2hpbGRyZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpbGRyZW47XHJcblxyXG5DaGlsZHJlbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50LmNoaWxkcmVuLnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzLmdhbWVPYmplY3Q7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5wdXNoKGNoaWxkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdDogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGlzdC5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkTXVsdGlwbGU6IGZ1bmN0aW9uIChjaGlsZHJlbilcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChjaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QXQ6IGZ1bmN0aW9uIChpbmRleClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0W2luZGV4XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICAvLyAgUmV0dXJuIC0xIGlmIGdpdmVuIGNoaWxkIGlzbid0IGEgY2hpbGQgb2YgdGhpcyBwYXJlbnRcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmluZGV4T2YoY2hpbGQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBzZXQgYmFzZWQgb24gdGhlIHByb3BlcnR5IHN0cmljdGx5IGVxdWFsaW5nIHRoZSB2YWx1ZSBnaXZlbi5cclxuICAgICogUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjZ2V0QnlLZXlcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGNoZWNrIGFnYWluc3QgdGhlIHZhbHVlLlxyXG4gICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IHN0cmljdGx5IGVxdWFscy5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgaXRlbSB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbCBpZiBub3RoaW5nIG1hdGNoZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0QnlLZXk6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldW3Byb3BlcnR5XSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogU2VhcmNoZXMgdGhlIEdyb3VwIGZvciB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjaGlsZCB3aXRoIHRoZSBgbmFtZWBcclxuICAgICogcHJvcGVydHkgbWF0Y2hpbmcgdGhlIGdpdmVuIGFyZ3VtZW50LiBTaG91bGQgbW9yZSB0aGFuIG9uZSBjaGlsZCBoYXZlXHJcbiAgICAqIHRoZSBzYW1lIG5hbWUgb25seSB0aGUgZmlyc3QgaW5zdGFuY2UgaXMgcmV0dXJuZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldEJ5TmFtZVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGZpcnN0IGNoaWxkIHdpdGggYSBtYXRjaGluZyBuYW1lLCBvciBudWxsIGlmIG5vbmUgd2VyZSBmb3VuZC5cclxuICAgICovXHJcbiAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ5S2V5KCduYW1lJywgbmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGNoaWxkIGZyb20gdGhlIGdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRSYW5kb21cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnRJbmRleD0wXSAtIE9mZnNldCBmcm9tIHRoZSBmcm9udCBvZiB0aGUgZ3JvdXAgKGxvd2VzdCBjaGlsZCkuXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD0odG8gdG9wKV0gLSBSZXN0cmljdGlvbiBvbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB5b3Ugd2FudCB0byByYW5kb21seSBzZWxlY3QgZnJvbS5cclxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBjaGlsZCBvZiB0aGlzIEdyb3VwLlxyXG4gICAgKi9cclxuICAgIGdldFJhbmRvbTogZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIGxlbmd0aClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPiB0aGlzLmxpc3QubGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydEluZGV4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtyYW5kb21JbmRleF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZFtwcm9wZXJ0eV0gPT09IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gaW4gdGhpcyBHcm91cC5cclxuICAgICpcclxuICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBtYXRjaGluZyBjcml0ZXJpYSB1c2luZyB0aGUgYHByb3BlcnR5YCBhbmQgYHZhbHVlYCBhcmd1bWVudHMuXHJcbiAgICAqXHJcbiAgICAqIEZvciBleGFtcGxlOiBgZ2V0QWxsKCdleGlzdHMnLCB0cnVlKWAgd291bGQgcmV0dXJuIG9ubHkgY2hpbGRyZW4gdGhhdCBoYXZlIHRoZWlyIGV4aXN0cyBwcm9wZXJ0eSBzZXQuXHJcbiAgICAqXHJcbiAgICAqIE9wdGlvbmFsbHkgeW91IGNhbiBzcGVjaWZ5IGEgc3RhcnQgYW5kIGVuZCBpbmRleC4gRm9yIGV4YW1wbGUgaWYgdGhpcyBHcm91cCBoYWQgMTAwIGNoaWxkcmVuLFxyXG4gICAgKiBhbmQgeW91IHNldCBgc3RhcnRJbmRleGAgdG8gMCBhbmQgYGVuZEluZGV4YCB0byA1MCwgaXQgd291bGQgcmV0dXJuIG1hdGNoZXMgZnJvbSBvbmx5XHJcbiAgICAqIHRoZSBmaXJzdCA1MCBjaGlsZHJlbiBpbiB0aGUgR3JvdXAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldEFsbFxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEFuIG9wdGlvbmFsIHByb3BlcnR5IHRvIHRlc3QgYWdhaW5zdCB0aGUgdmFsdWUgYXJndW1lbnQuXHJcbiAgICAqIEBwYXJhbSB7YW55fSBbdmFsdWVdIC0gSWYgcHJvcGVydHkgaXMgc2V0IHRoZW4gQ2hpbGQucHJvcGVydHkgbXVzdCBzdHJpY3RseSBlcXVhbCB0aGlzIHZhbHVlIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLlxyXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydEluZGV4PTBdIC0gVGhlIGZpcnN0IGNoaWxkIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbS5cclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kSW5kZXhdIC0gVGhlIGxhc3QgY2hpbGQgaW5kZXggdG8gc2VhcmNoIHVwIHVudGlsLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIGV4aXN0aW5nIGNoaWxkIG9mIHRoaXMgR3JvdXAuXHJcbiAgICAqL1xyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRbcHJvcGVydHldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHN3YXA6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMilcclxuICAgIHtcclxuICAgICAgICBpZiAoY2hpbGQxID09PSBjaGlsZDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xyXG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmdldEluZGV4KGNoaWxkMik7XHJcblxyXG4gICAgICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgc2FtZSBwYXJlbnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDFdID0gY2hpbGQyO1xyXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDJdID0gY2hpbGQxO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgIHdhcyBzZXRJbmRleFxyXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLm1vdmVUbzogVGhlIHN1cHBsaWVkIGluZGV4IGlzIG91dCBvZiBib3VuZHMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBSZW1vdmVcclxuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XHJcblxyXG4gICAgICAgIC8vICBBZGQgaW4gbmV3IGxvY2F0aW9uXHJcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0OiBmdW5jdGlvbiAoaW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2luZGV4XTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVCZXR3ZWVuOiBmdW5jdGlvbiAoYmVnaW5JbmRleCwgZW5kSW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGJlZ2luSW5kZXggPT09IHVuZGVmaW5lZCkgeyBiZWdpbkluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxyXG5cclxuICAgICAgICB2YXIgcmFuZ2UgPSBlbmRJbmRleCAtIGJlZ2luSW5kZXg7XHJcblxyXG4gICAgICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMubGlzdC5zcGxpY2UoYmVnaW5JbmRleCwgcmFuZ2UpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMubGlzdC5sZW5ndGggPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4ucmVtb3ZlQmV0d2VlbjogUmFuZ2UgRXJyb3IsIG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlcyBhbGwgdGhlIGl0ZW1zLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNyZW1vdmVBbGxcclxuICAgICovXHJcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5saXN0W2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBnaXZlbiBjaGlsZCBpcyBhIGNoaWxkIG9mIHRoaXMgb2JqZWN0LCBhdCBhbnkgZGVwdGggKHJlY3Vyc2l2ZWx5IHNjYW5zIHVwIHRoZSB0cmVlKVxyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICBpZiAoIWNoaWxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoY2hpbGQucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBCcmluZ3MgdGhlIGdpdmVuIGNoaWxkIHRvIHRoZSB0b3Agb2YgdGhpcyBncm91cCBzbyBpdCByZW5kZXJzIGFib3ZlIGFsbCBvdGhlciBjaGlsZHJlbi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjYnJpbmdUb1RvcFxyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gYnJpbmcgdG8gdGhlIHRvcCBvZiB0aGlzIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cclxuICAgICovXHJcbiAgICBicmluZ1RvVG9wOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcyAmJiB0aGlzLmdldEluZGV4KGNoaWxkKSA8IHRoaXMubGlzdC5sZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKGNoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNlbmRzIHRoZSBnaXZlbiBjaGlsZCB0byB0aGUgYm90dG9tIG9mIHRoaXMgZ3JvdXAgc28gaXQgcmVuZGVycyBiZWxvdyBhbGwgb3RoZXIgY2hpbGRyZW4uXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI3NlbmRUb0JhY2tcclxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIHNlbmQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cclxuICAgICovXHJcbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcyAmJiB0aGlzLmdldEluZGV4KGNoaWxkKSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXQoY2hpbGQsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIHVwIG9uZSBwbGFjZSBpbiB0aGlzIGdyb3VwIHVubGVzcyBpdCdzIGFscmVhZHkgYXQgdGhlIHRvcC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZVVwXHJcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBtb3ZlIHVwIGluIHRoZSBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgbW92ZVVwOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGEgIT09IC0xICYmIGEgPCB0aGlzLmxpc3QubGVuZ3RoIC0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXRBdChhICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwKGNoaWxkLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIGRvd24gb25lIHBsYWNlIGluIHRoaXMgZ3JvdXAgdW5sZXNzIGl0J3MgYWxyZWFkeSBhdCB0aGUgYm90dG9tLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlRG93blxyXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gbW92ZSBkb3duIGluIHRoZSBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXHJcbiAgICAqL1xyXG4gICAgbW92ZURvd246IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoYSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0QXQoYSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldmVyc2VzIGFsbCBjaGlsZHJlbiBpbiB0aGlzIGdyb3VwLlxyXG4gICAgKlxyXG4gICAgKiBUaGlzIG9wZXJhdGlvbiBhcHBsaWVzIG9ubHkgdG8gaW1tZWRpYXRlIGNoaWxkcmVuIGFuZCBkb2VzIG5vdCBwcm9wYWdhdGUgdG8gc3ViZ3JvdXBzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXZlcnNlXHJcbiAgICAqL1xyXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxpc3QucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMubGlzdFtpXTtcclxuICAgICAgICAgICAgdGhpcy5saXN0W2ldID0gdGhpcy5saXN0W2pdO1xyXG4gICAgICAgICAgICB0aGlzLmxpc3Rbal0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXBsYWNlcyBhIGNoaWxkIG9mIHRoaXMgR3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmV3Q2hpbGQuIFRoZSBuZXdDaGlsZCBjYW5ub3QgYmUgYSBtZW1iZXIgb2YgdGhpcyBHcm91cC5cclxuICAgICpcclxuICAgICogSWYgYEdyb3VwLmVuYWJsZUJvZHlgIGlzIHNldCwgdGhlbiBhIHBoeXNpY3MgYm9keSB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgc28gbG9uZyBhcyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cclxuICAgICpcclxuICAgICogSWYgYEdyb3VwLmlucHV0RW5hYmxlQ2hpbGRyZW5gIGlzIHNldCwgdGhlbiBhbiBJbnB1dCBIYW5kbGVyIHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBzbyBsb25nIGFzIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXBsYWNlXHJcbiAgICAqIEBwYXJhbSB7YW55fSBvbGRDaGlsZCAtIFRoZSBjaGlsZCBpbiB0aGlzIGdyb3VwIHRoYXQgd2lsbCBiZSByZXBsYWNlZC5cclxuICAgICogQHBhcmFtIHthbnl9IG5ld0NoaWxkIC0gVGhlIGNoaWxkIHRvIGJlIGluc2VydGVkIGludG8gdGhpcyBncm91cC5cclxuICAgICogQHJldHVybiB7YW55fSBSZXR1cm5zIHRoZSBvbGRDaGlsZCB0aGF0IHdhcyByZXBsYWNlZCB3aXRoaW4gdGhpcyBncm91cC5cclxuICAgICovXHJcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG5ld0NoaWxkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgob2xkQ2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnBhcmVudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50LnJlbW92ZShuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG9sZENoaWxkKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXQobmV3Q2hpbGQsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBTd2FwcyBhIGNoaWxkIGZyb20gYW5vdGhlciBwYXJlbnQsIHdpdGggb25lIGZyb20gdGhpcyBwYXJlbnQuXHJcbiAgICAvLyAgY2hpbGQxID0gdGhlIGNoaWxkIG9mIFRISVMgcGFyZW50XHJcbiAgICAvLyAgY2hpbGQyID0gdGhlIGNoaWxkIG9mIHRoZSBPVEhFUiBwYXJlbnRcclxuICAgIGV4Y2hhbmdlOiBmdW5jdGlvbiAoY2hpbGQxLCBjaGlsZDIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNoaWxkMSA9PT0gY2hpbGQyIHx8IGNoaWxkMS5wYXJlbnQgPT09IGNoaWxkMi5wYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGFyZW50Q2hpbGRyZW4gPSBjaGlsZDIucGFyZW50LmNoaWxkcmVuO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xyXG4gICAgICAgIHZhciBpbmRleDIgPSBwYXJlbnRDaGlsZHJlbi5nZXRJbmRleChjaGlsZDIpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5zd2FwOiBTdXBwbGllZCBvYmplY3RzIG11c3QgYmUgY2hpbGRyZW4gb2YgcGFyZW50cycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQxKTtcclxuXHJcbiAgICAgICAgcGFyZW50Q2hpbGRyZW4ucmVtb3ZlKGNoaWxkMik7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkQXQoY2hpbGQyLCBpbmRleDEpO1xyXG5cclxuICAgICAgICBwYXJlbnRDaGlsZHJlbi5hZGRBdChjaGlsZDEsIGluZGV4Mik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDaGVja3MgZm9yIHRoZSBpdGVtIHdpdGhpbiB0aGlzIGxpc3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I2V4aXN0c1xyXG4gICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbGlzdCBpbmRleCBmb3IuXHJcbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGxpc3QsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICovXHJcbiAgICBleGlzdHM6IGZ1bmN0aW9uIChjaGlsZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKSA+IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBrZXlgIHRvIHRoZSBnaXZlbiB2YWx1ZSBvbiBhbGwgbWVtYmVycyBvZiB0aGlzIGxpc3QuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkFycmF5U2V0I3NldEFsbFxyXG4gICAgKiBAcGFyYW0ge2FueX0ga2V5IC0gVGhlIHByb3BlcnR5IG9mIHRoZSBpdGVtIHRvIHNldC5cclxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG8uXHJcbiAgICAqL1xyXG4gICAgc2V0QWxsOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtpXVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIGNoaWxkcmVuIHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBlYWNoXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxyXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBjaGlsZC5cclxuICAgICovXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbIG51bGwgXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhcmdzWzBdID0gdGhpcy5saXN0W2ldO1xyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBNb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIEdyb3VwIHRvIHRoZSBHcm91cCBnaXZlbi5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZUFsbFxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gZ3JvdXAgLSBUaGUgbmV3IEdyb3VwIHRvIHdoaWNoIHRoZSBjaGlsZHJlbiB3aWxsIGJlIG1vdmVkIHRvLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgY2hpbGRyZW4gd2lsbCBub3QgZGlzcGF0Y2ggdGhlIGBvbkFkZGVkVG9Hcm91cGAgZXZlbnQgZm9yIHRoZSBuZXcgR3JvdXAuXHJcbiAgICAqIEByZXR1cm4ge1BoYXNlci5Hcm91cH0gVGhlIEdyb3VwIHRvIHdoaWNoIGFsbCB0aGUgY2hpbGRyZW4gd2VyZSBtb3ZlZC5cclxuICAgICovXHJcbiAgICByZXBhcmVudDogZnVuY3Rpb24gKG5ld1BhcmVudClcclxuICAgIHtcclxuICAgICAgICBpZiAobmV3UGFyZW50ICE9PSB0aGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmFkZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdQYXJlbnQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hpbGRyZW4ucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2ZpcnN0XHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaXJzdFxyXG4gICAgKi9cclxuICAgIGxlbmd0aDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0Lmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBhbmQgcmVzZXRzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0LlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjZmlyc3RcclxuICAgICogQHByb3BlcnR5IHthbnl9IGZpcnN0XHJcbiAgICAqL1xyXG4gICAgZmlyc3Q6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNsYXN0XHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBsYXN0XHJcbiAgICAqL1xyXG4gICAgbGFzdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxpc3QubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgbmV4dCBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgYWR2YW5jZXMgdGhlIGN1cnNvci5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I25leHRcclxuICAgICogQHByb3BlcnR5IHthbnl9IG5leHRcclxuICAgICovXHJcbiAgICBuZXh0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uIDwgdGhpcy5saXN0Lmxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgcmV0cmVhdHMgdGhlIGN1cnNvci5cclxuICAgICpcclxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I3ByZXZpb3VzXHJcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcmV2aW91c1xyXG4gICAgKi9cclxuICAgIHByZXZpb3VzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hpbGRyZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9DaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFRoZSBDb2xvciBDb21wb25lbnQgYWxsb3dzIHlvdSB0byBjb250cm9sIHRoZSBhbHBoYSwgYmxlbmQgbW9kZSwgdGludCBhbmQgYmFja2dyb3VuZCBjb2xvclxyXG4qIG9mIGEgR2FtZSBPYmplY3QuXHJcbipcclxuKiBAY2xhc3NcclxuKi9cclxudmFyIENvbG9yID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXHJcbntcclxuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IGdhbWVPYmplY3Quc3RhdGU7XHJcblxyXG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9hbHBoYSA9IDE7XHJcbiAgICB0aGlzLl93b3JsZEFscGhhID0gMTtcclxuXHJcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSAwO1xyXG5cclxuICAgIHRoaXMuX3RpbnQgPSB7IHRvcExlZnQ6IDB4ZmZmZmZmLCB0b3BSaWdodDogMHhmZmZmZmYsIGJvdHRvbUxlZnQ6IDB4ZmZmZmZmLCBib3R0b21SaWdodDogMHhmZmZmZmYgfTtcclxuICAgIHRoaXMuX2dsVGludCA9IHsgdG9wTGVmdDogMTY3NzcyMTUsIHRvcFJpZ2h0OiAxNjc3NzIxNSwgYm90dG9tTGVmdDogMTY3NzcyMTUsIGJvdHRvbVJpZ2h0OiAxNjc3NzIxNSB9O1xyXG4gICAgdGhpcy5faGFzVGludCA9IGZhbHNlO1xyXG5cclxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDI1NVxyXG4gICAgdGhpcy5fciA9IDA7XHJcbiAgICB0aGlzLl9nID0gMDtcclxuICAgIHRoaXMuX2IgPSAwO1xyXG5cclxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDFcclxuICAgIHRoaXMuX2EgPSAxO1xyXG5cclxuICAgIC8vICBTdHJpbmcgdmVyc2lvbiBvZiBSR0JBXHJcbiAgICB0aGlzLl9yZ2JhID0gJyc7XHJcblxyXG4gICAgLy8gIDMyLWJpdCB2ZXJzaW9uIG9mIEFSR0JcclxuICAgIHRoaXMuX2dsQmcgPSAwO1xyXG5cclxuICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSBmYWxzZTtcclxufTtcclxuXHJcbkNvbG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yO1xyXG5cclxuQ29sb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldEJhY2tncm91bmQ6IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAocmVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fciA9IHJlZDtcclxuICAgICAgICAgICAgdGhpcy5fZyA9IChncmVlbikgPyBncmVlbiA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2IgPSAoYmx1ZSkgPyBibHVlIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fYSA9IChhbHBoYSkgPyBhbHBoYSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJUaW50OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VGludCgweGZmZmZmZik7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhc1RpbnQgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGludDogZnVuY3Rpb24gKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAodG9wUmlnaHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gdG9wTGVmdDtcclxuICAgICAgICAgICAgYm90dG9tTGVmdCA9IHRvcExlZnQ7XHJcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gdG9wTGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGludFRvcExlZnQgPSB0b3BMZWZ0O1xyXG4gICAgICAgIHRoaXMudGludFRvcFJpZ2h0ID0gdG9wUmlnaHQ7XHJcbiAgICAgICAgdGhpcy50aW50Qm90dG9tTGVmdCA9IGJvdHRvbUxlZnQ7XHJcbiAgICAgICAgdGhpcy50aW50Qm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5faGFzVGludCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBEaXJ0eSBNYW5hZ2VyXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc0JhY2tncm91bmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9yZ2JhID0gJ3JnYmEoJyArIHRoaXMuX3IgKyAnLCcgKyB0aGlzLl9nICsgJywnICsgdGhpcy5fYiArICcsJyArIHRoaXMuX2EgKyAnKSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSB0aGlzLmdldENvbG9yMzIodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgVGludCBtdWx0cz9cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbG9yOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Q29sb3IzMjogZnVuY3Rpb24gKHIsIGcsIGIsIGEpXHJcbiAgICB7XHJcbiAgICAgICAgYSAqPSAyNTU7XHJcblxyXG4gICAgICAgIHJldHVybiAoKGEgPDwgMjQpIHwgKGIgPDwgMTYpIHwgKGcgPDwgOCkgfCByKSA+Pj4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RpbnQgPSBbXTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBkaXJ0eToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlydHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLmFkZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0aW50VG9wTGVmdDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BMZWZ0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC50b3BMZWZ0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC50b3BMZWZ0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRUb3BSaWdodDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BSaWdodDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbnQudG9wUmlnaHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LnRvcFJpZ2h0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRpbnRCb3R0b21MZWZ0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbUxlZnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl90aW50LmJvdHRvbUxlZnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LmJvdHRvbUxlZnQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludEJvdHRvbVJpZ2h0OiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdGludC5ib3R0b21SaWdodCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQuYm90dG9tUmlnaHQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGludDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGludCh2YWx1ZSwgdmFsdWUsIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hbHBoYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYmxlbmRNb2RlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2JsZW5kTW9kZSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgd29ybGRBbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lT2JqZWN0LnBhcmVudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ybGRBbHBoYSA9IHRoaXMuX2FscGhhICogdGhpcy5nYW1lT2JqZWN0LnBhcmVudC5jb2xvci53b3JsZEFscGhhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRBbHBoYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkQWxwaGEgPSB0aGlzLl9hbHBoYSAqIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJhY2tncm91bmRBbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJlZDoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fciA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBncmVlbjoge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZyA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBibHVlOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9iKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iID0gdmFsdWUgfCAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbGlwID0ge1xyXG5cclxuICAgIGZsaXBYOiBmYWxzZSxcclxuICAgIGZsaXBZOiBmYWxzZSxcclxuXHJcbiAgICBzZXRGbGlwWDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmxpcFggPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZsaXBZOiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWCA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RmxpcDogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWCA9IHg7XHJcbiAgICAgICAgdGhpcy5mbGlwWSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEZsaXA6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mbGlwWCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsaXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9GbGlwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEJvdW5kcyA9IHtcclxuXHJcbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIChvdXRwdXQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9OyB9XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG5cclxuICAgICAgICB2YXIgdyA9IHRoaXMuZGlzcGxheVdpZHRoO1xyXG4gICAgICAgIHZhciBoID0gdGhpcy5kaXNwbGF5SGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgciA9IHRoaXMucm90YXRpb247XHJcblxyXG4gICAgICAgIHZhciB3Y3QgPSB3ICogTWF0aC5jb3Mocik7XHJcbiAgICAgICAgdmFyIGhjdCA9IGggKiBNYXRoLmNvcyhyKTtcclxuXHJcbiAgICAgICAgdmFyIHdzdCA9IHcgKiBNYXRoLnNpbihyKTtcclxuICAgICAgICB2YXIgaHN0ID0gaCAqIE1hdGguc2luKHIpO1xyXG5cclxuICAgICAgICB2YXIgeE1pbiA9IHg7XHJcbiAgICAgICAgdmFyIHhNYXggPSB4O1xyXG4gICAgICAgIHZhciB5TWluID0geTtcclxuICAgICAgICB2YXIgeU1heCA9IHk7XHJcblxyXG4gICAgICAgIGlmIChyID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyIDwgMS41NzA3OTYzMjY3OTQ4OTY2KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAwIDwgdGhldGEgPCA5MFxyXG4gICAgICAgICAgICAgICAgeU1heCA9IHkgKyBoY3QgKyB3c3Q7XHJcbiAgICAgICAgICAgICAgICB4TWluID0geCAtIGhzdDtcclxuICAgICAgICAgICAgICAgIHhNYXggPSB4ICsgd2N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gOTAgPD0gdGhldGEgPD0gMTgwXHJcbiAgICAgICAgICAgICAgICB5TWluID0geSArIGhjdDtcclxuICAgICAgICAgICAgICAgIHlNYXggPSB5ICsgd3N0O1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IHggLSBoc3QgKyB3Y3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAociA+IC0xLjU3MDc5NjMyNjc5NDg5NjYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAtOTAgPCB0aGV0YSA8PSAwXHJcbiAgICAgICAgICAgIHlNaW4gPSB5ICsgd3N0O1xyXG4gICAgICAgICAgICB5TWF4ID0geSArIGhjdDtcclxuICAgICAgICAgICAgeE1heCA9IHggKyB3Y3QgLSBoc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIC0xODAgPD0gdGhldGEgPD0gLTkwXHJcbiAgICAgICAgICAgIHlNaW4gPSB5ICsgd3N0ICsgaGN0O1xyXG4gICAgICAgICAgICB4TWluID0geCArIHdjdDtcclxuICAgICAgICAgICAgeE1heCA9IHggLSBoc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXRwdXQueCA9IHhNaW47XHJcbiAgICAgICAgb3V0cHV0LnkgPSB5TWluO1xyXG4gICAgICAgIG91dHB1dC53aWR0aCA9IHhNYXggLSB4TWluO1xyXG4gICAgICAgIG91dHB1dC5oZWlnaHQgPSB5TWF4IC0geU1pbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE9yaWdpbiBDb21wb25lbnRcclxuLy8gIFZhbHVlcyBhcmUgbm9ybWFsaXplZCwgZ2l2ZW4gaW4gdGhlIHJhbmdlIDAgdG8gMS5cclxuLy8gIERpc3BsYXkgdmFsdWVzIGNvbnRhaW4gdGhlIGNhbGN1bGF0ZWQgcGl4ZWwgdmFsdWVzLlxyXG5cclxudmFyIE9yaWdpbiA9IHtcclxuXHJcbiAgICBvcmlnaW5YOiAwLjUsXHJcbiAgICBvcmlnaW5ZOiAwLjUsXHJcblxyXG4gICAgLy8gIFJFQUQgT05MWVxyXG4gICAgZGlzcGxheU9yaWdpblg6IDAsXHJcbiAgICBkaXNwbGF5T3JpZ2luWTogMCxcclxuXHJcbiAgICBzZXRPcmlnaW46IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDAuNTsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5vcmlnaW5YID0geDtcclxuICAgICAgICB0aGlzLm9yaWdpblkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVPcmlnaW4oKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0RGlzcGxheU9yaWdpbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWCA9IHg7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMud2lkdGggLyB4O1xyXG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuaGVpZ2h0IC8geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9yaWdpbjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXlPcmlnaW5YID0gTWF0aC5yb3VuZCh0aGlzLm9yaWdpblggKiB0aGlzLndpZHRoKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlPcmlnaW5ZID0gTWF0aC5yb3VuZCh0aGlzLm9yaWdpblkgKiB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3JpZ2luO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvT3JpZ2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlclRhcmdldCA9IHtcclxuXHJcbiAgICByZW5kZXJUYXJnZXQ6IG51bGxcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUYXJnZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL1JlbmRlclRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMzQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG5cclxuLy8gIFNjYWxlTW9kZSBDb21wb25lbnRcclxuXHJcbnZhciBTY2FsZU1vZGUgPSB7XHJcblxyXG4gICAgX3NjYWxlTW9kZTogU2NhbGVNb2Rlcy5ERUZBVUxULFxyXG5cclxuICAgIHNjYWxlTW9kZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVNb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBTY2FsZU1vZGVzLkxJTkVBUiB8fCB2YWx1ZSA9PT0gU2NhbGVNb2Rlcy5ORUFSRVNUKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FsZU1vZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlTW9kZTogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NhbGVNb2RlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvU2NhbGVNb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjcm9sbEZhY3RvciA9IHtcclxuXHJcbiAgICBzY3JvbGxGYWN0b3JYOiAxLjAsXHJcbiAgICBzY3JvbGxGYWN0b3JZOiAxLjAsXHJcblxyXG4gICAgc2V0U2Nyb2xsRmFjdG9yOiBmdW5jdGlvbiAoeCwgeSlcclxuICAgIHtcclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2Nyb2xsRmFjdG9yWCA9IHg7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxGYWN0b3JZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxGYWN0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9TY3JvbGxGYWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDM0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2l6ZSA9IHtcclxuXHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMCxcclxuXHJcbiAgICBkaXNwbGF5V2lkdGg6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYICogdGhpcy5mcmFtZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHZhbHVlIC8gdGhpcy5mcmFtZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGlzcGxheUhlaWdodDoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVkgKiB0aGlzLmZyYW1lLnJlYWxIZWlnaHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHZhbHVlIC8gdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNpemVUb0ZyYW1lOiBmdW5jdGlvbiAoZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGZyYW1lID09PSB1bmRlZmluZWQpIHsgZnJhbWUgPSB0aGlzLmZyYW1lOyB9XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBmcmFtZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5yZWFsSGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpemU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9TaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRleHR1cmUgQ29tcG9uZW50XHJcblxyXG4vLyAgYml0bWFzayBmbGFnIGZvciBHYW1lT2JqZWN0LnJlbmRlck1hc2tcclxudmFyIF9GTEFHID0gODsgLy8gMTAwMFxyXG5cclxudmFyIFRleHR1cmUgPSB7XHJcblxyXG4gICAgdGV4dHVyZTogbnVsbCxcclxuICAgIGZyYW1lOiBudWxsLFxyXG5cclxuICAgIHNldFRleHR1cmU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuc3RhdGUuc3lzLnRleHR1cmVzLmdldChrZXkpO1xyXG5cclxuICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy50ZXh0dXJlLmdldChmcmFtZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5mcmFtZS5jdXRXaWR0aCB8fCAhdGhpcy5mcmFtZS5jdXRIZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL1RleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgRGVmYXVsdCBHYW1lIE9iamVjdCBKU09OIGV4cG9ydFxyXG4vLyAgSXMgZXh0ZW5kZWQgZnVydGhlciBieSBHYW1lIE9iamVjdCBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcclxuXHJcbnZhciBUb0pTT04gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcclxue1xyXG4gICAgdmFyIG91dCA9IHtcclxuICAgICAgICBuYW1lOiBnYW1lT2JqZWN0Lm5hbWUsXHJcbiAgICAgICAgdHlwZTogZ2FtZU9iamVjdC50eXBlLFxyXG4gICAgICAgIHg6IGdhbWVPYmplY3QueCxcclxuICAgICAgICB5OiBnYW1lT2JqZWN0LnksXHJcbiAgICAgICAgejogZ2FtZU9iamVjdC56LFxyXG4gICAgICAgIHNjYWxlOiB7XHJcbiAgICAgICAgICAgIHg6IGdhbWVPYmplY3Quc2NhbGVYLFxyXG4gICAgICAgICAgICB5OiBnYW1lT2JqZWN0LnNjYWxlWVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3JpZ2luOiB7XHJcbiAgICAgICAgICAgIHg6IGdhbWVPYmplY3Qub3JpZ2luWCxcclxuICAgICAgICAgICAgeTogZ2FtZU9iamVjdC5vcmlnaW5ZXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGlwWDogZ2FtZU9iamVjdC5mbGlwWCxcclxuICAgICAgICBmbGlwWTogZ2FtZU9iamVjdC5mbGlwWSxcclxuICAgICAgICByb3RhdGlvbjogZ2FtZU9iamVjdC5yb3RhdGlvbixcclxuICAgICAgICBhbHBoYTogZ2FtZU9iamVjdC5hbHBoYSxcclxuICAgICAgICB2aXNpYmxlOiBnYW1lT2JqZWN0LnZpc2libGUsXHJcbiAgICAgICAgc2NhbGVNb2RlOiBnYW1lT2JqZWN0LnNjYWxlTW9kZSxcclxuICAgICAgICBibGVuZE1vZGU6IGdhbWVPYmplY3QuYmxlbmRNb2RlLFxyXG4gICAgICAgIHRleHR1cmVLZXk6ICcnLFxyXG4gICAgICAgIGZyYW1lS2V5OiAnJyxcclxuICAgICAgICBkYXRhOiB7fVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC50ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIG91dC50ZXh0dXJlS2V5ID0gZ2FtZU9iamVjdC50ZXh0dXJlLmtleTtcclxuICAgICAgICBvdXQuZnJhbWVLZXkgPSBnYW1lT2JqZWN0LmZyYW1lLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9KU09OO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvVG9KU09OLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBXcmFwQW5nbGUgPSByZXF1aXJlKCcuLi9tYXRoL2FuZ2xlL1dyYXAnKTtcclxudmFyIFdyYXBBbmdsZURlZ3JlZXMgPSByZXF1aXJlKCcuLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzJyk7XHJcblxyXG4vLyAgZ2xvYmFsIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrICh1c2VkIGJ5IFNjYWxlKVxyXG52YXIgX0ZMQUcgPSA0OyAvLyAwMTAwXHJcblxyXG4vLyAgVHJhbnNmb3JtIENvbXBvbmVudFxyXG5cclxudmFyIFRyYW5zZm9ybSA9IHtcclxuXHJcbiAgICAvLyAgXCJwcml2YXRlXCIgcHJvcGVydGllc1xyXG4gICAgX3NjYWxlWDogMSxcclxuICAgIF9zY2FsZVk6IDEsXHJcbiAgICBfcm90YXRpb246IDAsXHJcbiAgICBfejogMCxcclxuXHJcbiAgICAvLyAgcHVibGljIHByb3BlcnRpZXMgLyBtZXRob2RzXHJcblxyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcblxyXG4gICAgejoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fejtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnNvcnRDaGlsZHJlbkZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl96ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVYOiB7XHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZVggPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZVggPT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlWToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2NhbGVZID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbmdsZToge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlRGVncmVlcyh0aGlzLl9yb3RhdGlvbiAqIE1BVEhfQ09OU1QuUkFEX1RPX0RFRyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgdmFsdWUgaXMgaW4gZGVncmVlc1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlRGVncmVlcyh2YWx1ZSkgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGlvbjoge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgdmFsdWUgaXMgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IFdyYXBBbmdsZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyYWRpYW5zKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyYWRpYW5zID09PSB1bmRlZmluZWQpIHsgcmFkaWFucyA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJhZGlhbnM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMTsgfVxyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zY2FsZVggPSB4O1xyXG4gICAgICAgIHRoaXMuc2NhbGVZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFo6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyB2YWx1ZSA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy56ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBWaXNpYmxlIENvbXBvbmVudFxyXG5cclxuLy8gIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrXHJcbnZhciBfRkxBRyA9IDE7IC8vIDAwMDFcclxuXHJcbnZhciBWaXNpYmxlID0ge1xyXG5cclxuICAgIF92aXNpYmxlOiB0cnVlLFxyXG5cclxuICAgIHZpc2libGU6IHtcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpc2libGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9WaXNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEdldHMgb3Igc2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyBiZXR3ZWVuIHJlcGVhdHMuXHJcbi8vICBGb3IgZXhhbXBsZSwgaWYgcmVwZWF0IGlzIDIgYW5kIHJlcGVhdERlbGF5IGlzIDEsIHRoZSBhbmltYXRpb24gd2lsbCBwbGF5IGluaXRpYWxseSxcclxuLy8gIHRoZW4gd2FpdCBmb3IgMSBzZWNvbmQgYmVmb3JlIGl0IHJlcGVhdHMsIHRoZW4gcGxheSBhZ2FpbiwgdGhlbiB3YWl0IDEgc2Vjb25kIGFnYWluXHJcbi8vICBiZWZvcmUgZG9pbmcgaXRzIGZpbmFsIHJlcGVhdC5cclxuXHJcbnZhciBEZWxheSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWxheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9EZWxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEZWxheWVkUGxheSA9IGZ1bmN0aW9uIChkZWxheSwga2V5LCBzdGFydEZyYW1lKVxyXG57XHJcbiAgICB0aGlzLnBsYXkoa2V5LCBzdGFydEZyYW1lKTtcclxuXHJcbiAgICB0aGlzLm5leHRUaWNrICs9IChkZWxheSAqIDEwMDApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWxheWVkUGxheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9EZWxheWVkUGxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDdXJyZW50S2V5ID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW0pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW0ua2V5O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDdXJyZW50S2V5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL0dldEN1cnJlbnRLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTG9hZCA9IGZ1bmN0aW9uIChrZXksIHN0YXJ0RnJhbWUpXHJcbntcclxuICAgIGlmIChzdGFydEZyYW1lID09PSB1bmRlZmluZWQpIHsgc3RhcnRGcmFtZSA9IDA7IH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIExvYWQgdGhlIG5ldyBhbmltYXRpb24gaW5cclxuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5sb2FkKHRoaXMsIGtleSwgc3RhcnRGcmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vTG9hZC5qc1xuLy8gbW9kdWxlIGlkID0gMzUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXVzZSA9IGZ1bmN0aW9uIChhdEZyYW1lKVxyXG57XHJcbiAgICBpZiAoIXRoaXMuX3BhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3dhc1BsYXlpbmcgPSB0aGlzLmlzUGxheWluZztcclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdEZyYW1lICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZShhdEZyYW1lKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhdXNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL1BhdXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdXNlZCA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFNldHRlclxyXG4gICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZWQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vUGF1c2VkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBsYXkgPSBmdW5jdGlvbiAoa2V5LCBpZ25vcmVJZlBsYXlpbmcsIHN0YXJ0RnJhbWUpXHJcbntcclxuICAgIGlmIChpZ25vcmVJZlBsYXlpbmcgPT09IHVuZGVmaW5lZCkgeyBpZ25vcmVJZlBsYXlpbmcgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPT09IHVuZGVmaW5lZCkgeyBzdGFydEZyYW1lID0gMDsgfVxyXG5cclxuICAgIGlmIChpZ25vcmVJZlBsYXlpbmcgJiYgdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5jdXJyZW50QW5pbS5rZXkgPT09IGtleSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvYWQoa2V5LCBzdGFydEZyYW1lKTtcclxuXHJcbiAgICB2YXIgYW5pbSA9IHRoaXMuY3VycmVudEFuaW07XHJcblxyXG4gICAgLy8gIFNob3VsZCBnaXZlIHVzIDksMDA3LDE5OSwyNTQsNzQwLDk5MSBzYWZlIHJlcGVhdHNcclxuICAgIHRoaXMucmVwZWF0Q291bnRlciA9ICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGhpcy5fcmVwZWF0O1xyXG5cclxuICAgIGFuaW0uZ2V0Rmlyc3RUaWNrKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZm9yd2FyZCA9IHRydWU7XHJcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcbiAgICB0aGlzLnBlbmRpbmdSZXBlYXQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoYW5pbS5zaG93T25TdGFydClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhcmVudC52aXNpYmxlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYW5pbS5vblN0YXJ0KVxyXG4gICAge1xyXG4gICAgICAgIGFuaW0ub25TdGFydC5hcHBseShhbmltLmNhbGxiYWNrU2NvcGUsIHRoaXMuX2NhbGxiYWNrQXJncy5jb25jYXQoYW5pbS5vblN0YXJ0UGFyYW1zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vUGxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIEhvdyBmYXIgdGhpcyBhbmltYXRpb24gaXMgdGhyb3VnaCwgaWdub3JpbmcgcmVwZWF0cyBhbmQgeW95b3MuXHJcbi8vICBJZiB0aGUgYW5pbWF0aW9uIGhhcyBhIG5vbi16ZXJvIHJlcGVhdCBkZWZpbmVkLCBwcm9ncmVzcyBhbmQgdG90YWxQcm9ncmVzcyB3aWxsIGJlIGRpZmZlcmVudFxyXG4vLyAgYmVjYXVzZSBwcm9ncmVzcyBkb2Vzbid0IGluY2x1ZGUgYW55IHJlcGVhdHMgb3IgcmVwZWF0RGVsYXlzIHdoZXJlYXMgdG90YWxQcm9ncmVzcyBkb2VzLlxyXG52YXIgUHJvZ3Jlc3MgPSBmdW5jdGlvbiAodmFsdWUpXHJcbntcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5jdXJyZW50RnJhbWUucHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5mb3J3YXJkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcCA9IDEgLSBwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRPRE86IFNldCBwcm9ncmVzc1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vUHJvZ3Jlc3MuanNcbi8vIG1vZHVsZSBpZCA9IDM1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxyXG57XHJcbiAgICBpZiAoZXZlbnQgPT09IHVuZGVmaW5lZCkgeyBldmVudCA9IHRoaXMuY3VycmVudEFuaW07IH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcgJiYgZXZlbnQua2V5ID09PSB0aGlzLmN1cnJlbnRBbmltLmtleSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuY3VycmVudEFuaW0uZnJhbWVzWzBdO1xyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xyXG5cclxuICAgICAgICBzcHJpdGUudGV4dHVyZSA9IGZyYW1lLmZyYW1lLnRleHR1cmU7XHJcbiAgICAgICAgc3ByaXRlLmZyYW1lID0gZnJhbWUuZnJhbWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9SZW1vdmUuanNcbi8vIG1vZHVsZSBpZCA9IDM1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgYW5pbWF0aW9uIHNob3VsZCByZXBlYXRcclxuLy8gIGFmdGVyIGl0cyBmaXJzdCBpdGVyYXRpb24uIEZvciBleGFtcGxlLCBpZiByZXBlYXQgaXMgMSwgdGhlIGFuaW1hdGlvbiB3aWxsXHJcbi8vICBwbGF5IGEgdG90YWwgb2YgdHdpY2UgKHRoZSBpbml0aWFsIHBsYXkgcGx1cyAxIHJlcGVhdCkuXHJcbi8vICBUbyByZXBlYXQgaW5kZWZpbml0ZWx5LCB1c2UgLTEuIHJlcGVhdCBzaG91bGQgYWx3YXlzIGJlIGFuIGludGVnZXIuXHJcblxyXG52YXIgUmVwZWF0ID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwZWF0O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMucmVwZWF0Q291bnRlciA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXBlYXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vUmVwZWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEdldHMgb3Igc2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyBiZXR3ZWVuIHJlcGVhdHMuXHJcbi8vICBGb3IgZXhhbXBsZSwgaWYgcmVwZWF0IGlzIDIgYW5kIHJlcGVhdERlbGF5IGlzIDEsIHRoZSBhbmltYXRpb24gd2lsbCBwbGF5IGluaXRpYWxseSxcclxuLy8gIHRoZW4gd2FpdCBmb3IgMSBzZWNvbmQgYmVmb3JlIGl0IHJlcGVhdHMsIHRoZW4gcGxheSBhZ2FpbiwgdGhlbiB3YWl0IDEgc2Vjb25kIGFnYWluXHJcbi8vICBiZWZvcmUgZG9pbmcgaXRzIGZpbmFsIHJlcGVhdC5cclxuXHJcbnZhciBSZXBlYXREZWxheSA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGVhdERlbGF5O1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXBlYXREZWxheTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9SZXBlYXREZWxheS5qc1xuLy8gbW9kdWxlIGlkID0gMzYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXN0YXJ0ID0gZnVuY3Rpb24gKGluY2x1ZGVEZWxheSlcclxue1xyXG4gICAgaWYgKGluY2x1ZGVEZWxheSA9PT0gdW5kZWZpbmVkKSB7IGluY2x1ZGVEZWxheSA9IGZhbHNlOyB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50QW5pbS5nZXRGaXJzdFRpY2sodGhpcywgaW5jbHVkZURlbGF5KTtcclxuXHJcbiAgICB0aGlzLmZvcndhcmQgPSB0cnVlO1xyXG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5wZW5kaW5nUmVwZWF0ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIFNldCBmcmFtZVxyXG4gICAgdGhpcy51cGRhdGVGcmFtZSh0aGlzLmN1cnJlbnRBbmltLmZyYW1lc1swXSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3RhcnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vUmVzdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXN1bWUgPSBmdW5jdGlvbiAoZnJvbUZyYW1lKVxyXG57XHJcbiAgICBpZiAodGhpcy5fcGF1c2VkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdGhpcy5fd2FzUGxheWluZztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJvbUZyYW1lICE9PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZShmcm9tRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdW1lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL1Jlc3VtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdG9wID0gZnVuY3Rpb24gKGRpc3BhdGNoQ2FsbGJhY2tzKVxyXG57XHJcbiAgICBpZiAoZGlzcGF0Y2hDYWxsYmFja3MgPT09IHVuZGVmaW5lZCkgeyBkaXNwYXRjaENhbGxiYWNrcyA9IGZhbHNlOyB9XHJcblxyXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgYW5pbSA9IHRoaXMuY3VycmVudEFuaW07XHJcblxyXG4gICAgaWYgKGRpc3BhdGNoQ2FsbGJhY2tzICYmIGFuaW0ub25Db21wbGV0ZSlcclxuICAgIHtcclxuICAgICAgICBhbmltLm9uQ29tcGxldGUuYXBwbHkoYW5pbS5jYWxsYmFja1Njb3BlLCB0aGlzLl9jYWxsYmFja0FyZ3MuY29uY2F0KGFuaW0ub25Db21wbGV0ZVBhcmFtcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL1N0b3AuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGltZVNjYWxlID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3RpbWVTY2FsZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGltZVNjYWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL1RpbWVTY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUb3RhbEZyYW1lcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRBbmltLmZyYW1lcy5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvdGFsRnJhbWVzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvYW5pbWF0aW9uL1RvdGFsRnJhbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFZhbHVlIGJldHdlZW4gMCBhbmQgMS4gSG93IGZhciB0aGlzIGFuaW1hdGlvbiBpcyB0aHJvdWdoLCBpbmNsdWRpbmcgdGhpbmdzIGxpa2UgZGVsYXlzXHJcbi8vICByZXBlYXRzLCBjdXN0b20gZnJhbWUgZHVyYXRpb25zLCBldGMuIElmIHRoZSBhbmltYXRpb24gaXMgc2V0IHRvIHJlcGVhdCAtMSBpdCBjYW4gbmV2ZXJcclxuLy8gIGhhdmUgYSBkdXJhdGlvbiwgdGhlcmVmb3JlIHRoaXMgd2lsbCByZXR1cm4gLTEuXHJcbnZhciBUb3RhbFByb2dyZXMgPSBmdW5jdGlvbiAoKVxyXG57XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb3RhbFByb2dyZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vVG90YWxQcm9ncmVzcy5qc1xuLy8gbW9kdWxlIGlkID0gMzY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBVcGRhdGUgPSBmdW5jdGlvbiAodGltZXN0YW1wLCBkZWx0YSlcclxue1xyXG4gICAgaWYgKCF0aGlzLmlzUGxheWluZyB8fCB0aGlzLmN1cnJlbnRBbmltLnBhdXNlZClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YSAqIHRoaXMuX3RpbWVTY2FsZTtcclxuXHJcbiAgICBpZiAodGhpcy5hY2N1bXVsYXRvciA+PSB0aGlzLm5leHRUaWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFuaW0uc2V0RnJhbWUodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9VcGRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVXBkYXRlRnJhbWUgPSBmdW5jdGlvbiAoYW5pbWF0aW9uRnJhbWUpXHJcbntcclxuICAgIHZhciBzcHJpdGUgPSB0aGlzLnBhcmVudDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIHNwcml0ZS50ZXh0dXJlID0gYW5pbWF0aW9uRnJhbWUuZnJhbWUudGV4dHVyZTtcclxuICAgIHNwcml0ZS5mcmFtZSA9IGFuaW1hdGlvbkZyYW1lLmZyYW1lO1xyXG5cclxuICAgIGlmICh0aGlzLmlzUGxheWluZylcclxuICAgIHtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uRnJhbWUuc2V0QWxwaGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzcHJpdGUuYWxwaGEgPSBhbmltYXRpb25GcmFtZS5hbHBoYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhbmltID0gdGhpcy5jdXJyZW50QW5pbTtcclxuXHJcbiAgICAgICAgaWYgKGFuaW0ub25VcGRhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltLm9uVXBkYXRlLmFwcGx5KGFuaW0uY2FsbGJhY2tTY29wZSwgdGhpcy5fdXBkYXRlUGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbmltYXRpb25GcmFtZS5vblVwZGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lLm9uVXBkYXRlKHNwcml0ZSwgYW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlRnJhbWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hbmltYXRpb24vVXBkYXRlRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDM2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgWW95byA9IGZ1bmN0aW9uICh2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3lveW87XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5feW95byA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWW95bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9Zb3lvLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5BbmltYXRpb24uRnJhbWUuQ29tcG9uZW50c1xyXG5cclxuLy8gIFVzZWQgYnkgdGhlIEdhbWVPYmplY3QgQW5pbWF0aW9uIENvbnRyb2xsZXIsIG5vdCB0aGUgQW5pbWF0aW9uIGl0c2VsZlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRGVsYXk6IHJlcXVpcmUoJy4vRGVsYXknKSxcclxuICAgIERlbGF5ZWRQbGF5OiByZXF1aXJlKCcuL0RlbGF5ZWRQbGF5JyksXHJcbiAgICBHZXRDdXJyZW50S2V5OiByZXF1aXJlKCcuL0dldEN1cnJlbnRLZXknKSxcclxuICAgIExvYWQ6IHJlcXVpcmUoJy4vTG9hZCcpLFxyXG4gICAgUGF1c2U6IHJlcXVpcmUoJy4vUGF1c2UnKSxcclxuICAgIFBhdXNlZDogcmVxdWlyZSgnLi9QYXVzZWQnKSxcclxuICAgIFBsYXk6IHJlcXVpcmUoJy4vUGxheScpLFxyXG4gICAgUHJvZ3Jlc3M6IHJlcXVpcmUoJy4vUHJvZ3Jlc3MnKSxcclxuICAgIFJlbW92ZTogcmVxdWlyZSgnLi9SZW1vdmUnKSxcclxuICAgIFJlcGVhdDogcmVxdWlyZSgnLi9SZXBlYXQnKSxcclxuICAgIFJlcGVhdERlbGF5OiByZXF1aXJlKCcuL1JlcGVhdERlbGF5JyksXHJcbiAgICBSZXN0YXJ0OiByZXF1aXJlKCcuL1Jlc3RhcnQnKSxcclxuICAgIFJlc3VtZTogcmVxdWlyZSgnLi9SZXN1bWUnKSxcclxuICAgIFN0b3A6IHJlcXVpcmUoJy4vU3RvcCcpLFxyXG4gICAgVGltZVNjYWxlOiByZXF1aXJlKCcuL1RpbWVTY2FsZScpLFxyXG4gICAgVG90YWxGcmFtZXM6IHJlcXVpcmUoJy4vVG90YWxGcmFtZXMnKSxcclxuICAgIFRvdGFsUHJvZ3Jlc3M6IHJlcXVpcmUoJy4vVG90YWxQcm9ncmVzcycpLFxyXG4gICAgVXBkYXRlOiByZXF1aXJlKCcuL1VwZGF0ZScpLFxyXG4gICAgVXBkYXRlRnJhbWU6IHJlcXVpcmUoJy4vVXBkYXRlRnJhbWUnKSxcclxuICAgIFlveW86IHJlcXVpcmUoJy4vWW95bycpXHJcbiAgICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2FuaW1hdGlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbmltcG9ydCBDYW52YXMgZnJvbSAnY2FudmFzL0NhbnZhcy5qcyc7XHJcbmltcG9ydCBHZXRDb250ZXh0IGZyb20gJ2NhbnZhcy9HZXRDb250ZXh0LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyaWQgIChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcyA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgd2lkdGggPSAyNTYsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoLFxyXG4gICAgICAgICAgICBjZWxsV2lkdGggPSAzMixcclxuICAgICAgICAgICAgY2VsbEhlaWdodCA9IGNlbGxXaWR0aCxcclxuICAgICAgICAgICAgY29sb3IxID0gJyNmZmYnLFxyXG4gICAgICAgICAgICBjb2xvcjIgPSAnIzAwMCcsXHJcbiAgICAgICAgICAgIGRyYXdMaW5lcyA9IGZhbHNlLFxyXG4gICAgICAgICAgICBsaW5lQ29sb3IgPSAnI2ZmMDAwMCcsXHJcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHRydWUsXHJcbiAgICAgICAgICAgIHJlc2l6ZUNhbnZhcyA9IHRydWUsXHJcbiAgICAgICAgICAgIGNsZWFyID0gdHJ1ZSxcclxuICAgICAgICAgICAgcHJlUmVuZGVyID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3N0UmVuZGVyID0gdW5kZWZpbmVkXHJcbiAgICAgICAgfSA9IHt9XHJcbiAgICApIHtcclxuXHJcbiAgICBpZiAoIWNhbnZhcylcclxuICAgIHtcclxuICAgICAgICBjYW52YXMgPSBDYW52YXMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVzaXplQ2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgY2xlYXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgVGhleSBwcm92aWRlZCBvd24gY2FudmFzLCBzbyB3ZSB1c2UgaXRzIGRpbWVuc2lvbnNcclxuICAgICAgICBpZiAoIXJlc2l6ZUNhbnZhcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgY3R4ID0gR2V0Q29udGV4dChjYW52YXMpO1xyXG5cclxuICAgIGlmIChyZXNpemVDYW52YXMpXHJcbiAgICB7XHJcbiAgICAgICAgUmVzaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNsZWFyKVxyXG4gICAge1xyXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRyYXdMaW5lcylcclxuICAgIHtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHByZVJlbmRlciBDYWxsYmFjaz9cclxuICAgIGlmIChwcmVSZW5kZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcHJlUmVuZGVyKGNhbnZhcywgY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgRHJhdyB0aGUgZ3JpZCBjZWxscyBmaXJzdCAodGhlIGxpbmVzIGdvIG9uIHRvcClcclxuXHJcbiAgICBsZXQgY3ggPSBNYXRoLmNlaWwod2lkdGggLyBjZWxsV2lkdGgpO1xyXG4gICAgbGV0IGN5ID0gTWF0aC5jZWlsKGhlaWdodCAvIGNlbGxIZWlnaHQpO1xyXG4gICAgbGV0IGMgPSAwO1xyXG4gICAgbGV0IGNvbG9yID0gY29sb3IxO1xyXG5cclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY3k7IHkrKylcclxuICAgIHtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGN4OyB4KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcjE7XHJcbiAgICAgICAgICAgICAgICBjID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3IyO1xyXG4gICAgICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2xvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggKiBjZWxsV2lkdGgsIHkgKiBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZHJhd0xpbmVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgKy0gMC41IGJlY2F1c2Ugd2UncmUgdXNpbmcgc3Ryb2tlLCBhbmQgd2lsbCBnZXQgYW50aS1hbGlhc2VkIGxpbmUgc3Ryb2tlcyB3aXRob3V0XHJcbiAgICAgICAgICAgICAgICBsZXQgb3ggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3kgPSAwLjU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGN4IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBveCA9IC0wLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IGN5IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBveSA9IC0wLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoKHggKiBjZWxsV2lkdGgpICsgb3gsICh5ICogY2VsbEhlaWdodCkgKyBveSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFsdGVybmF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyAgcG9zdFJlbmRlciBDYWxsYmFjaz9cclxuICAgIGlmIChwb3N0UmVuZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHBvc3RSZW5kZXIoY2FudmFzLCBjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW52YXM7XHJcblxyXG59XHJcbiovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL0dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDM3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIDE2IGNvbG9yIEM2NCBpbnNwaXJlZCBwYWxldHRlLlxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtBcnJheX1cclxuKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgMDogJyMwMDAnLFxyXG4gICAgMTogJyNmZmYnLFxyXG4gICAgMjogJyM4YjQxMzEnLFxyXG4gICAgMzogJyM3YmJkYzUnLFxyXG4gICAgNDogJyM4YjQxYWMnLFxyXG4gICAgNTogJyM2YWFjNDEnLFxyXG4gICAgNjogJyMzOTMxYTQnLFxyXG4gICAgNzogJyNkNWRlNzMnLFxyXG4gICAgODogJyM5NDVhMjAnLFxyXG4gICAgOTogJyM1YTQxMDAnLFxyXG4gICAgQTogJyNiZDczNmEnLFxyXG4gICAgQjogJyM1MjUyNTInLFxyXG4gICAgQzogJyM4MzgzODMnLFxyXG4gICAgRDogJyNhY2VlOGInLFxyXG4gICAgRTogJyM3YjczZGUnLFxyXG4gICAgRjogJyNhY2FjYWMnXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY3JlYXRlL3BhbGV0dGVzL0M2NC5qc1xuLy8gbW9kdWxlIGlkID0gMzcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEEgMTYgY29sb3IgQ0dBIGluc3BpcmVkIHBhbGV0dGUgYnkgW0FybmVdKGh0dHA6Ly9hbmRyb2lkYXJ0cy5jb20vcGFsZXR0ZS8xNnBhbC5odG0pXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge0FycmF5fVxyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAwOiAnIzAwMCcsXHJcbiAgICAxOiAnIzIyMzRkMScsXHJcbiAgICAyOiAnIzBjN2U0NScsXHJcbiAgICAzOiAnIzQ0YWFjYycsXHJcbiAgICA0OiAnIzhhMzYyMicsXHJcbiAgICA1OiAnIzVjMmU3OCcsXHJcbiAgICA2OiAnI2FhNWMzZCcsXHJcbiAgICA3OiAnI2I1YjViNScsXHJcbiAgICA4OiAnIzVlNjA2ZScsXHJcbiAgICA5OiAnIzRjODFmYicsXHJcbiAgICBBOiAnIzZjZDk0NycsXHJcbiAgICBCOiAnIzdiZTJmOScsXHJcbiAgICBDOiAnI2ViOGE2MCcsXHJcbiAgICBEOiAnI2UyM2Q2OScsXHJcbiAgICBFOiAnI2ZmZDkzZicsXHJcbiAgICBGOiAnI2ZmZidcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jcmVhdGUvcGFsZXR0ZXMvQ0dBLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQSAxNiBjb2xvciBKTVAgcGFsZXR0ZSBieSBbQXJuZV0oaHR0cDovL2FuZHJvaWRhcnRzLmNvbS9wYWxldHRlLzE2cGFsLmh0bSlcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7QXJyYXl9XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIDA6ICcjMDAwJyxcclxuICAgIDE6ICcjMTkxMDI4JyxcclxuICAgIDI6ICcjNDZhZjQ1JyxcclxuICAgIDM6ICcjYTFkNjg1JyxcclxuICAgIDQ6ICcjNDUzZTc4JyxcclxuICAgIDU6ICcjNzY2NGZlJyxcclxuICAgIDY6ICcjODMzMTI5JyxcclxuICAgIDc6ICcjOWVjMmU4JyxcclxuICAgIDg6ICcjZGM1MzRiJyxcclxuICAgIDk6ICcjZTE4ZDc5JyxcclxuICAgIEE6ICcjZDZiOTdiJyxcclxuICAgIEI6ICcjZTlkOGExJyxcclxuICAgIEM6ICcjMjE2YzRiJyxcclxuICAgIEQ6ICcjZDM2NWM4JyxcclxuICAgIEU6ICcjYWZhYWI5JyxcclxuICAgIEY6ICcjZjVmNGViJ1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NyZWF0ZS9wYWxldHRlcy9KTVAuanNcbi8vIG1vZHVsZSBpZCA9IDM3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBBIDE2IGNvbG9yIHBhbGV0dGUgaW5zcGlyZWQgYnkgSmFwYW5lc2UgY29tcHV0ZXJzIGxpa2UgdGhlIE1TWC5cclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7QXJyYXl9XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIDA6ICcjMDAwJyxcclxuICAgIDE6ICcjMTkxMDI4JyxcclxuICAgIDI6ICcjNDZhZjQ1JyxcclxuICAgIDM6ICcjYTFkNjg1JyxcclxuICAgIDQ6ICcjNDUzZTc4JyxcclxuICAgIDU6ICcjNzY2NGZlJyxcclxuICAgIDY6ICcjODMzMTI5JyxcclxuICAgIDc6ICcjOWVjMmU4JyxcclxuICAgIDg6ICcjZGM1MzRiJyxcclxuICAgIDk6ICcjZTE4ZDc5JyxcclxuICAgIEE6ICcjZDZiOTdiJyxcclxuICAgIEI6ICcjZTlkOGExJyxcclxuICAgIEM6ICcjMjE2YzRiJyxcclxuICAgIEQ6ICcjZDM2NWM4JyxcclxuICAgIEU6ICcjYWZhYWI5JyxcclxuICAgIEY6ICcjZmZmJ1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NyZWF0ZS9wYWxldHRlcy9NU1guanNcbi8vIG1vZHVsZSBpZCA9IDM3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBBUk5FMTY6IHJlcXVpcmUoJy4vQXJuZTE2JyksXHJcbiAgICBDNjQ6IHJlcXVpcmUoJy4vQzY0JyksXHJcbiAgICBDR0E6IHJlcXVpcmUoJy4vQ0dBJyksXHJcbiAgICBKTVA6IHJlcXVpcmUoJy4vSk1QJyksXHJcbiAgICBNU1g6IHJlcXVpcmUoJy4vTVNYJylcclxuICAgIFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NyZWF0ZS9wYWxldHRlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcclxudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcclxuXHJcbnZhciBBdWRpbyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdWRpb0RhdGEgLSBBcmUgQXVkaW8gdGFncyBhdmFpbGFibGU/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgYXVkaW9EYXRhOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJBdWRpbyAtIElzIHRoZSBXZWJBdWRpbyBBUEkgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHdlYkF1ZGlvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvZ2cgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb2dnOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvcHVzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb3B1cyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBvcHVzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtcDMgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBtcDMgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgbXAzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3YXYgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3YXYgZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2F2OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbTRhIGZpbGVzP1xyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG00YSAtIFRydWUgaWYgdGhpcyBkZXZpY2UgY2FuIHBsYXkgbTRhIGZpbGVzLlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG00YTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2VibSAtIENhbiB0aGlzIGRldmljZSBwbGF5IHdlYm0gZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgd2VibTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZG9sYnkgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBFQy0zIERvbGJ5IERpZ2l0YWwgUGx1cyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBkb2xieTogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIEF1ZGlvLmF1ZGlvRGF0YSA9ICEhKHdpbmRvd1snQXVkaW8nXSk7XHJcbiAgICBBdWRpby53ZWJBdWRpbyA9ICEhKHdpbmRvd1snQXVkaW9Db250ZXh0J10gfHwgd2luZG93Wyd3ZWJraXRBdWRpb0NvbnRleHQnXSk7XHJcblxyXG4gICAgdmFyIGF1ZGlvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9ICEhYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ub2dnID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJvcHVzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpIHx8IGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb3B1czsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5vcHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdWRpby5tcDMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgTWltZXR5cGVzIGFjY2VwdGVkOlxyXG4gICAgICAgICAgICAvLyAgZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL01lZGlhX2Zvcm1hdHNfc3VwcG9ydGVkX2J5X3RoZV9hdWRpb19hbmRfdmlkZW9fZWxlbWVudHNcclxuICAgICAgICAgICAgLy8gIGJpdC5seS9pcGhvbmVvc2NvZGVjc1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLndhdiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtbTRhOycpIHx8IGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF1ZGlvLm00YSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXVkaW8ud2VibSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDtjb2RlY3M9XCJlYy0zXCInKSAhPT0gJycpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChCcm93c2VyLmVkZ2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXVkaW8uZG9sYnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5zYWZhcmlWZXJzaW9uID49IDkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgvTWFjIE9TIFggKFxcZCspXyhcXGQrKS8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFqb3IgPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbm9yID0gcGFyc2VJbnQoUmVnRXhwLiQyLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1ham9yID09PSAxMCAmJiBtaW5vciA+PSAxMSkgfHwgbWFqb3IgPiAxMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXVkaW8uZG9sYnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5vdGhpbmcgdG8gZG8gaGVyZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBBdWRpbztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL0F1ZGlvLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG5cclxudmFyIEZ1bGxzY3JlZW4gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXZhaWxhYmxlIC0gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRoZSBGdWxsIFNjcmVlbiBBUEk/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgYXZhaWxhYmxlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3QgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGFjdGl2YXRlIGl0LlxyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHJlcXVlc3Q6ICcnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2FuY2VsIC0gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEZ1bGwgU2NyZWVuIEFQSSB0aGlzIGhvbGRzIHRoZSBjYWxsIHlvdSBuZWVkIHRvIHVzZSB0byBjYW5jZWwgaXQuXHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgY2FuY2VsOiAnJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBrZXlib2FyZCAtIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBhY2Nlc3MgdG8gdGhlIEtleWJvYXJkIGR1cmluZyBGdWxsIFNjcmVlbiBtb2RlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGtleWJvYXJkOiBmYWxzZVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4qIENoZWNrcyBmb3Igc3VwcG9ydCBvZiB0aGUgRnVsbCBTY3JlZW4gQVBJLlxyXG4qL1xyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciBmcyA9IFtcclxuICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxyXG4gICAgICAgICdyZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcclxuICAgICAgICAnbXNSZXF1ZXN0RnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbW96UmVxdWVzdEZ1bGxzY3JlZW4nXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpZiAoZWxlbWVudFtmc1tpXV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGdWxsc2NyZWVuLmF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIEZ1bGxzY3JlZW4ucmVxdWVzdCA9IGZzW2ldO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNmcyA9IFtcclxuICAgICAgICAnY2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ2V4aXRGdWxsc2NyZWVuJyxcclxuICAgICAgICAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsXHJcbiAgICAgICAgJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcclxuICAgICAgICAnbXNDYW5jZWxGdWxsU2NyZWVuJyxcclxuICAgICAgICAnbXNFeGl0RnVsbHNjcmVlbicsXHJcbiAgICAgICAgJ21vekNhbmNlbEZ1bGxTY3JlZW4nLFxyXG4gICAgICAgICdtb3pFeGl0RnVsbHNjcmVlbidcclxuICAgIF07XHJcblxyXG4gICAgaWYgKEZ1bGxzY3JlZW4uYXZhaWxhYmxlKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2ZzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50W2Nmc1tpXV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZ1bGxzY3JlZW4uY2FuY2VsID0gY2ZzW2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEtleWJvYXJkIElucHV0P1xyXG4gICAgaWYgKHdpbmRvd1snRWxlbWVudCddICYmIEVsZW1lbnRbJ0FMTE9XX0tFWUJPQVJEX0lOUFVUJ10pXHJcbiAgICB7XHJcbiAgICAgICAgRnVsbHNjcmVlbi5rZXlib2FyZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEZ1bGxzY3JlZW47XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9GdWxsc2NyZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG5cclxudmFyIElucHV0ID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRvdWNoIC0gSXMgdG91Y2ggYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRvdWNoOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtc3BvaW50ZXIgLSBJcyBtc3BvaW50ZXIgYXZhaWxhYmxlP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIG1zcG9pbnRlcjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gd2hlZWxUeXBlIC0gVGhlIG5ld2VzdCB0eXBlIG9mIFdoZWVsL1Njcm9sbCBldmVudCBzdXBwb3J0ZWQ6ICd3aGVlbCcsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJ1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqL1xyXG4gICAgd2hlZWxFdmVudDogbnVsbFxyXG4gICAgXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgKHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+PSAxKSlcclxuICAgIHtcclxuICAgICAgICBJbnB1dC50b3VjaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCB8fCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIElucHV0Lm1zcG9pbnRlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFPUy5jb2Nvb25KUylcclxuICAgIHtcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXHJcbiAgICAgICAgaWYgKCdvbndoZWVsJyBpbiB3aW5kb3cgfHwgKEJyb3dzZXIuaWUgJiYgJ1doZWVsRXZlbnQnIGluIHdpbmRvdykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBET00zIFdoZWVsIEV2ZW50OiBGRiAxNyssIElFIDkrLCBDaHJvbWUgMzErLCBTYWZhcmkgNytcclxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICd3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdvbm1vdXNld2hlZWwnIGluIHdpbmRvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIE5vbi1GRiBsZWdhY3k6IElFIDYtOSwgQ2hyb21lIDEtMzEsIFNhZmFyaSA1LTcuXHJcbiAgICAgICAgICAgIElucHV0LndoZWVsRXZlbnQgPSAnbW91c2V3aGVlbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuZmlyZWZveCAmJiAnTW91c2VTY3JvbGxFdmVudCcgaW4gd2luZG93KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRkYgcHJpb3IgdG8gMTcuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHNjcnViYmVkLlxyXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ0RPTU1vdXNlU2Nyb2xsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIElucHV0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZXZpY2UvSW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDM3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XHJcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XHJcblxyXG52YXIgVmlkZW8gPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgdmlkZW8gZmlsZXM/XHJcbiAgICAqIEBkZWZhdWx0XHJcbiAgICAqL1xyXG4gICAgb2dnVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGgyNjRWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGgyNjQgbXA0IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIGgyNjRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXA0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBtcDRWaWRlbzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2VibVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2VibSB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB3ZWJtVmlkZW86IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZwOVZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgdnA5IHZpZGVvIGZpbGVzP1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHZwOVZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBobHNWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGhscyB2aWRlbyBmaWxlcz9cclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICBobHNWaWRlbzogZmFsc2VcclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0ICgpXHJcbntcclxuICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgdmFyIHJlc3VsdCA9ICEhdmlkZW9FbGVtZW50LmNhblBsYXlUeXBlO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8ub2dnVmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IFF1aWNrVGltZSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgLiBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzU0NlxyXG4gICAgICAgICAgICAgICAgVmlkZW8uaDI2NFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFZpZGVvLm1wNFZpZGVvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZpZGVvLndlYm1WaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmlkZW8udnA5VmlkZW8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi94LW1wZWdVUkw7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWaWRlby5obHNWaWRlbyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICAvLyAgTm90aGluZyB0byBkb1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWaWRlbztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGV2aWNlL1ZpZGVvLmpzXG4vLyBtb2R1bGUgaWQgPSAzODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoaXMgc2luZ2xldG9uIGlzIGluc3RhbnRpYXRlZCBhcyBzb29uIGFzIFBoYXNlciBsb2FkcyxcclxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cclxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIGNhbiBzaGFyZSBpdCxcclxuLy8gIHdpdGhvdXQgaGF2aW5nIHRvIHJlLXBvbGwgdGhlIGRldmljZSBhbGwgb3ZlciBhZ2FpblxyXG5cclxudmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xyXG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xyXG52YXIgRmVhdHVyZXMgPSByZXF1aXJlKCcuL0ZlYXR1cmVzJyk7XHJcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vSW5wdXQnKTtcclxudmFyIEF1ZGlvID0gcmVxdWlyZSgnLi9BdWRpbycpO1xyXG52YXIgVmlkZW8gPSByZXF1aXJlKCcuL1ZpZGVvJyk7XHJcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9GdWxsc2NyZWVuJyk7XHJcbnZhciBDYW52YXNGZWF0dXJlcyA9IHJlcXVpcmUoJy4vQ2FudmFzRmVhdHVyZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIE9TOiBPUyxcclxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXHJcbiAgICBGZWF0dXJlczogRmVhdHVyZXMsXHJcbiAgICBJbnB1dDogSW5wdXQsXHJcbiAgICBBdWRpbzogQXVkaW8sXHJcbiAgICBWaWRlbzogVmlkZW8sXHJcbiAgICBGdWxsc2NyZWVuOiBGdWxsc2NyZWVuLFxyXG4gICAgQ2FudmFzRmVhdHVyZXM6IENhbnZhc0ZlYXR1cmVzXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RldmljZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKVxyXG57XHJcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxyXG5cclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkZEV2ZW50TGlzdGVuZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL0FkZEV2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcilcclxue1xyXG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vUmVtb3ZlRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMzgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW1vdmVGcm9tRE9NID0gZnVuY3Rpb24gKGVsZW1lbnQpXHJcbntcclxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVGcm9tRE9NO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RvbS9SZW1vdmVGcm9tRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSAzODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2V0cyB0aGUgdG91Y2gtYWN0aW9uIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgc3R5bGUuIENhbiBiZSB1c2VkIHRvIGRpc2FibGUgZGVmYXVsdCBicm93c2VyIHRvdWNoIGFjdGlvbnMuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuVG91Y2hBY3Rpb25cclxuKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIHRvIHNldCB0aGUgdG91Y2ggYWN0aW9uIG9uLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdIC0gVGhlIHRvdWNoIGFjdGlvbiB0byBzZXQuIERlZmF1bHRzIHRvICdub25lJy5cclxuKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHNvdXJjZSBjYW52YXMuXHJcbiovXHJcbnZhciBUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIChjYW52YXMsIHZhbHVlKVxyXG57XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyB2YWx1ZSA9ICdub25lJzsgfVxyXG5cclxuICAgIGNhbnZhcy5zdHlsZVsnbXNUb3VjaEFjdGlvbiddID0gdmFsdWU7XHJcbiAgICBjYW52YXMuc3R5bGVbJ21zLXRvdWNoLWFjdGlvbiddID0gdmFsdWU7XHJcbiAgICBjYW52YXMuc3R5bGVbJ3RvdWNoLWFjdGlvbiddID0gdmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG91Y2hBY3Rpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZG9tL1RvdWNoQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU2V0cyB0aGUgdXNlci1zZWxlY3QgcHJvcGVydHkgb24gdGhlIGNhbnZhcyBzdHlsZS4gQ2FuIGJlIHVzZWQgdG8gZGlzYWJsZSBkZWZhdWx0IGJyb3dzZXIgc2VsZWN0aW9uIGFjdGlvbnMuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0VXNlclNlbGVjdFxyXG4qIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgdG8gc2V0IHRoZSB0b3VjaCBhY3Rpb24gb24uXHJcbiogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBUaGUgdG91Y2ggYWN0aW9uIHRvIHNldC4gRGVmYXVsdHMgdG8gJ25vbmUnLlxyXG4qIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgc291cmNlIGNhbnZhcy5cclxuKi9cclxudmFyIFVzZXJTZWxlY3QgPSBmdW5jdGlvbiAoY2FudmFzLCB2YWx1ZSlcclxue1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgdmFsdWUgPSAnbm9uZSc7IH1cclxuXHJcbiAgICB2YXIgdmVuZG9ycyA9IFtcclxuICAgICAgICAnLXdlYmtpdC0nLFxyXG4gICAgICAgICcta2h0bWwtJyxcclxuICAgICAgICAnLW1vei0nLFxyXG4gICAgICAgICctbXMtJyxcclxuICAgICAgICAnJ1xyXG4gICAgXTtcclxuXHJcbiAgICB2ZW5kb3JzLmZvckVhY2goZnVuY3Rpb24gKHZlbmRvcilcclxuICAgIHtcclxuICAgICAgICBjYW52YXMuc3R5bGVbdmVuZG9yICsgJ3VzZXItc2VsZWN0J10gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbnZhcy5zdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSB2YWx1ZTtcclxuICAgIGNhbnZhcy5zdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLCAwLCAwLCAwKSc7XHJcblxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlclNlbGVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kb20vVXNlclNlbGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL0V2ZW50TGlzdGVuZXInKTtcclxuXHJcbnZhciBFdmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlciwgdHlwZSlcclxue1xyXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9JRExFO1xyXG4gICAgdGhpcy5hY3RpdmUgPSBbXTtcclxufTtcclxuXHJcbkV2ZW50QmluZGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudEJpbmRpbmc7XHJcblxyXG5FdmVudEJpbmRpbmcucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHRvdGFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG90YWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldChjYWxsYmFjaykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJpb3JpdHksIG9uY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5nZXQoY2FsbGJhY2spO1xyXG5cclxuICAgICAgICBpZiAoIWxpc3RlbmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoZSBsaXN0ZW5lciBkb2Vzbid0IGV4aXN0LCBzbyBjcmVhdGUgb25lXHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBMaXN0ZW5lciBhbHJlYWR5IGV4aXN0cywgYWJvcnRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgZG9uJ3QgbmVlZCBhIHBlbmRpbmcgc3RhdGVcclxuICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9BQ1RJVkU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0SGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWRkIGl0IHRvIHRoZSBsaXN0LCBidXQga2VlcCB0aGUgc3RhdGUgYXMgcGVuZGluZy5cclxuICAgICAgICAgICAgLy8gIFRoZSBjYWxsIHRvICd0aWR5JyB3aWxsIHNvcnQgaXQgb3V0IGF0IHRoZSBlbmQgb2YgdGhlIGRpc3BhdGNoLlxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNvcnRIYW5kbGVyOiBmdW5jdGlvbiAobGlzdGVuZXJBLCBsaXN0ZW5lckIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA8IGxpc3RlbmVyQS5wcmlvcml0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGlzdGVuZXJCLnByaW9yaXR5ID4gbGlzdGVuZXJBLnByaW9yaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgY2FuIHJlbW92ZSByaWdodCBhd2F5XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRJbmRleChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSAhPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXMgd29ya2luZywgc28gd2UgZmxhZyB0aGUgbGlzdGVuZXIgZm9yIHJlbW92YWwgYXQgdGhlIGVuZFxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmdldChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENPTlNULkRJU1BBVENIRVJfSURMRSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IEZhaWxlZCB0byBleGVjdXRlIFxcJ0V2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaFxcJyBvbiBcXCcnICsgdGhpcy50eXBlICsgJ1xcJzogVGhlIGV2ZW50IGlzIGFscmVhZHkgYmVpbmcgZGlzcGF0Y2hlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFRoaXMgd2FzIGEgdmFsaWQgZGlzcGF0Y2ggY2FsbCwgd2UganVzdCBoYWQgbm90aGluZyB0byBkbyAuLi5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfRElTUEFUQ0hJTkc7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5hY3RpdmVbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX0FDVElWRSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcy5kaXNwYXRjaGVyLCBldmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgSGFzIHRoZSBjYWxsYmFjayBjaGFuZ2VkIHRoZSBzdGF0ZSBvZiB0aGlzIGJpbmRpbmc/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgWXVwISBMZXQncyBicmVhayBvdXRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgV2FzIGl0IGEgJ29uY2UnIGxpc3RlbmVyP1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9SRU1PVklORztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgZXZlbnQgYmVlbiBoYWx0ZWQgYnkgdGhlIGNhbGxiYWNrP1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50Ll9wcm9wYWdhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBCcmVhayBvdXQsIGEgbGlzdGVuZXIgaGFzIGNhbGxlZCBFdmVudC5zdG9wUHJvcGFnYXRpb25cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRGlzcGF0Y2ggb3Zlciwgb3IgYWJvcnRlZFxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX1JFTU9WSU5HKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwgdGlkeSB0aGUgbGlzdCBpbiBjYXNlIHRoZXJlIHdlcmUgYW55IHBlbmRpbmcgZXZlbnRzIGFkZGVkXHJcbiAgICAgICAgICAgIHRoaXMudGlkeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0RFU1RST1lFRClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5kZWxldGUodGhpcy50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIEFsbCBkb25lLCBqdXN0IHB1cmdlIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIHRoaXMudGlkeSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBSZW1vdmVzIGFsbCBsaXN0ZW5lcnNcclxuICAgIC8vICBJZiB0aGlzIGlzIGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIHRoZW4gZG9uJ3QgcmVtb3ZlICdwZW5kaW5nJyBsaXN0ZW5lcnNcclxuICAgIC8vICAoaS5lLiBvbmVzIHRoYXQgd2VyZSBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoKSwgb25seSBhY3RpdmUgb25lc1xyXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfUEVORElORylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRpZHk6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIE5vdGhpbmcgdG8gZG8gLi4uXHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhZGRlZCA9IDA7XHJcblxyXG4gICAgICAgIHZhciBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgZG9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfUEVORElORylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX0FDVElWRTtcclxuICAgICAgICAgICAgICAgIGFkZGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPj0gMCk7XHJcblxyXG4gICAgICAgIGlmIChhZGRlZCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnJztcclxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEJpbmRpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZXZlbnRzL0V2ZW50QmluZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcclxue1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICBzdGF0ZTogQ09OU1QuTElTVEVORVJfUEVORElOR1xyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ldmVudHMvRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMzg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxuXHJcbnZhciBCdWlsZEdhbWVPYmplY3RBbmltYXRpb24gPSBmdW5jdGlvbiAoc3ByaXRlLCBjb25maWcpXHJcbntcclxuICAgIHZhciBhbmltQ29uZmlnID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdhbmltcycsIG51bGwpO1xyXG5cclxuICAgIGlmIChhbmltQ29uZmlnID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhbmltQ29uZmlnID09PSAnc3RyaW5nJylcclxuICAgIHtcclxuICAgICAgICAvLyAgeyBhbmltczogJ2tleScgfVxyXG4gICAgICAgIHNwcml0ZS5hbmltcy5wbGF5KGFuaW1Db25maWcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGFuaW1Db25maWcgPT09ICdvYmplY3QnKVxyXG4gICAge1xyXG4gICAgICAgIC8vICB7IGFuaW1zOiB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgIGtleTogc3RyaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgIHN0YXJ0RnJhbWU6IFtzdHJpbmd8aW50ZWdlcl1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgZGVsYXk6IFtmbG9hdF1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgcmVwZWF0OiBbaW50ZWdlcl1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgcmVwZWF0RGVsYXk6IFtmbG9hdF1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgeW95bzogW2Jvb2xlYW5dXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgIHBsYXk6IFtib29sZWFuXVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICBkZWxheWVkUGxheTogW2Jvb2xlYW5dXHJcbiAgICAgICAgLy8gICAgICAgICAgIH1cclxuICAgICAgICAvLyAgfVxyXG5cclxuICAgICAgICB2YXIgYW5pbXMgPSBzcHJpdGUuYW5pbXM7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGFuaW1Db25maWcsICdrZXknLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHZhciBzdGFydEZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAnc3RhcnRGcmFtZScsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgIGFuaW1zLmxvYWQoa2V5KTtcclxuXHJcbiAgICAgICAgdmFyIGRlbGF5ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAnZGVsYXknLCAwKTtcclxuICAgICAgICB2YXIgcmVwZWF0ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAncmVwZWF0JywgMCk7XHJcbiAgICAgICAgdmFyIHJlcGVhdERlbGF5ID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAncmVwZWF0RGVsYXknLCAwKTtcclxuICAgICAgICB2YXIgeW95byA9IEdldEFkdmFuY2VkVmFsdWUoYW5pbUNvbmZpZywgJ3lveW8nLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGFuaW1zLmRlbGF5KGRlbGF5KTtcclxuICAgICAgICBhbmltcy5yZXBlYXQocmVwZWF0KTtcclxuICAgICAgICBhbmltcy5yZXBlYXREZWxheShyZXBlYXREZWxheSk7XHJcbiAgICAgICAgYW5pbXMueW95byh5b3lvKTtcclxuXHJcbiAgICAgICAgaWYgKEdldEFkdmFuY2VkVmFsdWUoYW5pbUNvbmZpZywgJ3BsYXknLCBmYWxzZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhbmltcy5wbGF5KGtleSwgc3RhcnRGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkID0gR2V0QWR2YW5jZWRWYWx1ZShhbmltQ29uZmlnLCAnZGVsYXllZFBsYXknLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYW5pbXMuZGVsYXllZFBsYXkoZCwga2V5LCBzdGFydEZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3ByaXRlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEdhbWVPYmplY3RBbmltYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvQnVpbGRHYW1lT2JqZWN0QW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vLyAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyYWN0ZXJXaWR0aCAtIFRoZSB3aWR0aCBvZiBlYWNoIGNoYXJhY3RlciBpbiB0aGUgZm9udCBzZXQuXHJcbi8vICogQHBhcmFtIHtudW1iZXJ9IGNoYXJhY3RlckhlaWdodCAtIFRoZSBoZWlnaHQgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGZvbnQgc2V0LlxyXG4vLyAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyAtIFRoZSBjaGFyYWN0ZXJzIHVzZWQgaW4gdGhlIGZvbnQgc2V0LCBpbiBkaXNwbGF5IG9yZGVyLiBZb3UgY2FuIHVzZSB0aGUgVEVYVF9TRVQgY29uc3RzIGZvciBjb21tb24gZm9udCBzZXQgYXJyYW5nZW1lbnRzLlxyXG4vLyAqIEBwYXJhbSB7bnVtYmVyfSBbY2hhcnNQZXJSb3ddIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBlciByb3cgaW4gdGhlIGZvbnQgc2V0LiBJZiBub3QgZ2l2ZW4gY2hhcnNQZXJSb3cgd2lsbCBiZSB0aGUgaW1hZ2Ugd2lkdGggLyBjaGFyYWN0ZXJXaWR0aC5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gW3hTcGFjaW5nPTBdIC0gSWYgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGZvbnQgc2V0IGhhdmUgaG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gdGhlbSBzZXQgdGhlIHJlcXVpcmVkIGFtb3VudCBoZXJlLlxyXG4vLyAqIEBwYXJhbSB7bnVtYmVyfSBbeVNwYWNpbmc9MF0gLSBJZiB0aGUgY2hhcmFjdGVycyBpbiB0aGUgZm9udCBzZXQgaGF2ZSB2ZXJ0aWNhbCBzcGFjaW5nIGJldHdlZW4gdGhlbSBzZXQgdGhlIHJlcXVpcmVkIGFtb3VudCBoZXJlLlxyXG4vLyAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldD0wXSAtIElmIHRoZSBmb250IHNldCBkb2Vzbid0IHN0YXJ0IGF0IHRoZSB0b3AgbGVmdCBvZiB0aGUgZ2l2ZW4gaW1hZ2UsIHNwZWNpZnkgdGhlIFggY29vcmRpbmF0ZSBvZmZzZXQgaGVyZS5cclxuLy8gKiBAcGFyYW0ge251bWJlcn0gW3lPZmZzZXQ9MF0gLSBJZiB0aGUgZm9udCBzZXQgZG9lc24ndCBzdGFydCBhdCB0aGUgdG9wIGxlZnQgb2YgdGhlIGdpdmVuIGltYWdlLCBzcGVjaWZ5IHRoZSBZIGNvb3JkaW5hdGUgb2Zmc2V0IGhlcmUuXHJcbi8vIFBoYXNlci5HYW1lT2JqZWN0LlJldHJvRm9udCA9IGZ1bmN0aW9uIChnYW1lLCBrZXksIGNoYXJhY3RlcldpZHRoLCBjaGFyYWN0ZXJIZWlnaHQsIGNoYXJzLCBjaGFyc1BlclJvdywgeFNwYWNpbmcsIHlTcGFjaW5nLCB4T2Zmc2V0LCB5T2Zmc2V0KVxyXG5cclxuLy8ge1xyXG4vLyAgICAgIGltYWdlOiBrZXksICAgIFxyXG4vLyAgICAgIHdpZHRoOiAzMixcclxuLy8gICAgICBoZWlnaHQ6IDMyLFxyXG4vLyAgICAgIGNoYXJzOiAnc3RyaW5nJyxcclxuLy8gICAgICBjaGFyc1BlclJvdzogbnVsbCxcclxuLy8gICAgICBzcGFjaW5nOiB7IHg6IDAsIHk6IDAgfSxcclxuLy8gICAgICBvZmZzZXQ6IHsgeDogMCwgeTogMCB9XHJcbi8vIH1cclxuXHJcbnZhciBQYXJzZVJldHJvRm9udCA9IGZ1bmN0aW9uIChzdGF0ZSwgY29uZmlnKVxyXG57XHJcbiAgICB2YXIgdyA9IGNvbmZpZy53aWR0aDtcclxuICAgIHZhciBoID0gY29uZmlnLmhlaWdodDtcclxuICAgIHZhciBjeCA9IE1hdGguZmxvb3IodyAvIDIpO1xyXG4gICAgdmFyIGN5ID0gTWF0aC5mbG9vcihoIC8gMik7XHJcbiAgICB2YXIgbGV0dGVycyA9IGNvbmZpZy5jaGFycztcclxuXHJcbiAgICB2YXIga2V5ID0gR2V0VmFsdWUoY29uZmlnLCAnaW1hZ2UnLCAnJyk7XHJcbiAgICB2YXIgb2Zmc2V0WCA9IEdldFZhbHVlKGNvbmZpZywgJ29mZnNldC54JywgMCk7XHJcbiAgICB2YXIgb2Zmc2V0WSA9IEdldFZhbHVlKGNvbmZpZywgJ29mZnNldC55JywgMCk7XHJcbiAgICB2YXIgc3BhY2luZ1ggPSBHZXRWYWx1ZShjb25maWcsICdzcGFjaW5nLngnLCAwKTtcclxuICAgIHZhciBzcGFjaW5nWSA9IEdldFZhbHVlKGNvbmZpZywgJ3NwYWNpbmcueScsIDApO1xyXG5cclxuICAgIHZhciBjaGFyc1BlclJvdyA9IEdldFZhbHVlKGNvbmZpZywgJ2NoYXJzUGVyUm93JywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGNoYXJzUGVyUm93ID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJzUGVyUm93ID0gc3RhdGUuc3lzLnRleHR1cmVzLmdldEZyYW1lKGtleSkud2lkdGggLyB3O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ID0gb2Zmc2V0WDtcclxuICAgIHZhciB5ID0gb2Zmc2V0WTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICByZXRyb0ZvbnQ6IHRydWUsXHJcbiAgICAgICAgZm9udDoga2V5LFxyXG4gICAgICAgIHNpemU6IHcsXHJcbiAgICAgICAgbGluZUhlaWdodDogaCxcclxuICAgICAgICBjaGFyczoge31cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHIgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgbm9kZSA9IGxldHRlcnNbaV07XHJcblxyXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGxldHRlcnMuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgIGhlaWdodDogaCxcclxuICAgICAgICAgICAgY2VudGVyWDogY3gsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IGN5LFxyXG4gICAgICAgICAgICB4T2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB5T2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB4QWR2YW5jZTogdyxcclxuICAgICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICAgIGtlcm5pbmc6IHt9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcisrO1xyXG5cclxuICAgICAgICBpZiAociA9PT0gY2hhcnNQZXJSb3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByID0gMDtcclxuICAgICAgICAgICAgeCA9IG9mZnNldFg7XHJcbiAgICAgICAgICAgIHkgKz0gaCArIHNwYWNpbmdZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4ICs9IHcgKyBzcGFjaW5nWDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDEgPSBcIiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+XCI7XHJcblxyXG4vKipcclxuKiBUZXh0IFNldCAyID0gICFcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQyID0gXCIgIVxcXCIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgMyA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSBcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSBcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDQgPSBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAwMTIzNDU2Nzg5XHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAwMTIzNDU2Nzg5XCI7XHJcblxyXG4vKipcclxuKiBUZXh0IFNldCA1ID0gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVouLC8oKSAnIT8tKjowMTIzNDU2Nzg5XHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ1ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi4sLygpICchPy0qOjAxMjM0NTY3ODlcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDYgPSBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiE/OjswMTIzNDU2Nzg5XCIoKSwtLicgXHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ2ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiE/OjswMTIzNDU2Nzg5XFxcIigpLC0uJyBcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDcgPSBBR01TWSs6NEJITlRaITs1Q0lPVS4/MDZESlBWLCgxN0VLUVdcIikyOEZMUlgtJzM5XHJcbiogQGNvbnN0YW50XHJcbiogQHR5cGUge3N0cmluZ31cclxuKi9cclxuUGFyc2VSZXRyb0ZvbnQuVEVYVF9TRVQ3ID0gXCJBR01TWSs6NEJITlRaITs1Q0lPVS4/MDZESlBWLCgxN0VLUVdcXFwiKTI4RkxSWC0nMzlcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDggPSAwMTIzNDU2Nzg5IC5BQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUOCA9IFwiMDEyMzQ1Njc4OSAuQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcclxuXHJcbi8qKlxyXG4qIFRleHQgU2V0IDkgPSBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWigpLTAxMjM0NTY3ODkuOiwnXCI/IVxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUOSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVooKS0wMTIzNDU2Nzg5LjosJ1xcXCI/IVwiO1xyXG5cclxuLyoqXHJcbiogVGV4dCBTZXQgMTAgPSBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxyXG4qIEBjb25zdGFudFxyXG4qIEB0eXBlIHtzdHJpbmd9XHJcbiovXHJcblBhcnNlUmV0cm9Gb250LlRFWFRfU0VUMTAgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XHJcblxyXG4vKipcclxuKiBUZXh0IFNldCAxMSA9IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLixcIi0rIT8oKSc6OzAxMjM0NTY3ODlcclxuKiBAY29uc3RhbnRcclxuKiBAdHlwZSB7c3RyaW5nfVxyXG4qL1xyXG5QYXJzZVJldHJvRm9udC5URVhUX1NFVDExID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi4sXFxcIi0rIT8oKSc6OzAxMjM0NTY3ODlcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VSZXRyb0ZvbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVJldHJvRm9udC5qc1xuLy8gbW9kdWxlIGlkID0gMzkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGdldFZhbHVlIChub2RlLCBhdHRyaWJ1dGUpXHJcbntcclxuICAgIHJldHVybiBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpLCAxMCk7XHJcbn1cclxuXHJcbnZhciBQYXJzZVhNTEJpdG1hcEZvbnQgPSBmdW5jdGlvbiAoeG1sLCB4U3BhY2luZywgeVNwYWNpbmcsIGZyYW1lKVxyXG57XHJcbiAgICBpZiAoeFNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyB4U3BhY2luZyA9IDA7IH1cclxuICAgIGlmICh5U3BhY2luZyA9PT0gdW5kZWZpbmVkKSB7IHlTcGFjaW5nID0gMDsgfVxyXG5cclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICB2YXIgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xyXG4gICAgdmFyIGNvbW1vbiA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29tbW9uJylbMF07XHJcblxyXG4gICAgZGF0YS5mb250ID0gaW5mby5nZXRBdHRyaWJ1dGUoJ2ZhY2UnKTtcclxuICAgIGRhdGEuc2l6ZSA9IGdldFZhbHVlKGluZm8sICdzaXplJyk7XHJcbiAgICBkYXRhLmxpbmVIZWlnaHQgPSBnZXRWYWx1ZShjb21tb24sICdsaW5lSGVpZ2h0JykgKyB5U3BhY2luZztcclxuICAgIGRhdGEuY2hhcnMgPSB7fTtcclxuXHJcbiAgICB2YXIgbGV0dGVycyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpO1xyXG5cclxuICAgIHZhciB4ID0gKGZyYW1lKSA/IGZyYW1lLnggOiAwO1xyXG4gICAgdmFyIHkgPSAoZnJhbWUpID8gZnJhbWUueSA6IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBub2RlID0gbGV0dGVyc1tpXTtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gZ2V0VmFsdWUobm9kZSwgJ2lkJyk7XHJcbiAgICAgICAgdmFyIGd3ID0gZ2V0VmFsdWUobm9kZSwgJ3dpZHRoJyk7XHJcbiAgICAgICAgdmFyIGdoID0gZ2V0VmFsdWUobm9kZSwgJ2hlaWdodCcpO1xyXG5cclxuICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4OiB4ICsgZ2V0VmFsdWUobm9kZSwgJ3gnKSxcclxuICAgICAgICAgICAgeTogeSArIGdldFZhbHVlKG5vZGUsICd5JyksXHJcbiAgICAgICAgICAgIHdpZHRoOiBndyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnaCxcclxuICAgICAgICAgICAgY2VudGVyWDogTWF0aC5mbG9vcihndyAvIDIpLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBNYXRoLmZsb29yKGdoIC8gMiksXHJcbiAgICAgICAgICAgIHhPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd4b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd5b2Zmc2V0JyksXHJcbiAgICAgICAgICAgIHhBZHZhbmNlOiBnZXRWYWx1ZShub2RlLCAneGFkdmFuY2UnKSArIHhTcGFjaW5nLFxyXG4gICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAga2VybmluZzoge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXJuaW5ncyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgna2VybmluZycpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXJuaW5ncy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIga2VybiA9IGtlcm5pbmdzW2ldO1xyXG5cclxuICAgICAgICB2YXIgZmlyc3QgPSBnZXRWYWx1ZShrZXJuLCAnZmlyc3QnKTtcclxuICAgICAgICB2YXIgc2Vjb25kID0gZ2V0VmFsdWUoa2VybiwgJ3NlY29uZCcpO1xyXG4gICAgICAgIHZhciBhbW91bnQgPSBnZXRWYWx1ZShrZXJuLCAnYW1vdW50Jyk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyc2VYTUxCaXRtYXBGb250O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIER5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncyB8fCB0ZXh0TGVuZ3RoID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IHNyYy5mcmFtZTtcclxuXHJcbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3Rvclg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3Rvclk7XHJcblxyXG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcclxuXHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuXHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG5cclxuICAgIHZhciBnbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgZ2x5cGhYID0gMDtcclxuICAgIHZhciBnbHlwaFkgPSAwO1xyXG4gICAgdmFyIGdseXBoVyA9IDA7XHJcbiAgICB2YXIgZ2x5cGhIID0gMDtcclxuXHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgaW1hZ2UgPSBzcmMuZnJhbWUuc291cmNlLmltYWdlO1xyXG5cclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcblxyXG4gICAgdmFyIHJvdGF0aW9uID0gMDtcclxuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgIT09IHNyYy5zY2FsZU1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoc3JjLngsIHNyYy55KTtcclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcclxuXHJcbiAgICBpZiAoc3JjLndpZHRoID4gMCAmJiBzcmMuaGVpZ2h0ID4gMClcclxuICAgIHtcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgucmVjdCgwLCAwLCBzcmMud2lkdGgsIHNyYy5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5jbGlwKCk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIC8vICBSZXNldCB0aGUgc2NhbGUgKGluIGNhc2UgdGhlIGNhbGxiYWNrIGNoYW5nZWQgaXQpXHJcbiAgICAgICAgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xyXG4gICAgICAgIHJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuXHJcbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XHJcbiAgICAgICAgZ2x5cGhIID0gZ2x5cGguaGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gKGluZGV4Q291bnQgKyBnbHlwaC54T2Zmc2V0ICsgeEFkdmFuY2UpIC0gc3JjLnNjcm9sbFg7XHJcbiAgICAgICAgeSA9IChnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2UpIC0gc3JjLnNjcm9sbFk7XHJcblxyXG4gICAgICAgIC8vICBUaGlzIGNvdWxkIGJlIG9wdGltaXplZCBzbyB0aGF0IGl0IGRvZXNuJ3QgZXZlbiBib3RoZXIgZHJhd2luZyBpdCBpZiB0aGUgeC95IGlzIG91dCBvZiByYW5nZVxyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXNwbGF5Q2FsbGJhY2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZGlzcGxheUNhbGxiYWNrKHsgaW5kZXg6IGluZGV4LCBjaGFyQ29kZTogY2hhckNvZGUsIHg6IHgsIHk6IHksIHNjYWxlOiBzY2FsZSwgcm90YXRpb246IDAsIGRhdGE6IGdseXBoLmRhdGEgfSk7XHJcblxyXG4gICAgICAgICAgICB4ID0gb3V0cHV0Lng7XHJcbiAgICAgICAgICAgIHkgPSBvdXRwdXQueTtcclxuICAgICAgICAgICAgc2NhbGUgPSBvdXRwdXQuc2NhbGU7XHJcbiAgICAgICAgICAgIHJvdGF0aW9uID0gb3V0cHV0LnJvdGF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCAqPSBzY2FsZTtcclxuICAgICAgICB5ICo9IHNjYWxlO1xyXG5cclxuICAgICAgICB4IC09IGNhbWVyYVNjcm9sbFg7XHJcbiAgICAgICAgeSAtPSBjYW1lcmFTY3JvbGxZO1xyXG5cclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDI1NSwwLDAuMiknO1xyXG4gICAgICAgIC8vIGN0eC5maWxsUmVjdCgwLCAwLCBnbHlwaFcsIGdseXBoSCk7XHJcblxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGdseXBoWCwgZ2x5cGhZLCBnbHlwaFcsIGdseXBoSCwgMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xyXG5cclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3JjLndpZHRoID4gMCAmJiBzcmMuaGVpZ2h0ID4gMClcclxuICAgIHtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQml0bWFwVGV4dCA9IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHQnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2R5bmFtaWNCaXRtYXBUZXh0JyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5hZGQobmV3IEJpdG1hcFRleHQodGhpcy5zdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQml0bWFwVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbik7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKER5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9EeW5hbWljQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9EeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxudmFyIHRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcbnZhciB0ZW1wTWF0cml4Q2hhciA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxuXHJcbnZhciBEeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGdhbWVPYmplY3QsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkaXNwbGF5Q2FsbGJhY2sgPSBnYW1lT2JqZWN0LmRpc3BsYXlDYWxsYmFjaztcclxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBnYW1lT2JqZWN0LmZyYW1lO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgdGV4dCA9IGdhbWVPYmplY3QudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcbiAgICB2YXIgY2hhcnMgPSBnYW1lT2JqZWN0LmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBnYW1lT2JqZWN0LmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcbiAgICB2YXIgYmxpdHRlckJhdGNoID0gcmVuZGVyZXIuYmxpdHRlckJhdGNoO1xyXG4gICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gYmxpdHRlckJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgIHZhciB0ZXh0dXJlRGF0YSA9IGdhbWVPYmplY3QudGV4dHVyZS5zb3VyY2VbdGV4dHVyZUZyYW1lLnNvdXJjZUluZGV4XTtcclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gdGV4dHVyZURhdGEud2lkdGg7XHJcbiAgICB2YXIgdGV4dHVyZUhlaWdodCA9IHRleHR1cmVEYXRhLmhlaWdodDtcclxuICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZURhdGEuZ2xUZXh0dXJlO1xyXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcclxuICAgIHZhciB5QWR2YW5jZSA9IDA7XHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG4gICAgdmFyIGdseXBoID0gbnVsbDtcclxuICAgIHZhciBnbHlwaFggPSAwO1xyXG4gICAgdmFyIGdseXBoWSA9IDA7XHJcbiAgICB2YXIgZ2x5cGhXID0gMDtcclxuICAgIHZhciBnbHlwaEggPSAwO1xyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG4gICAgdmFyIHJvdGF0aW9uID0gMDtcclxuICAgIHZhciB4dyA9IDA7XHJcbiAgICB2YXIgeWggPSAwO1xyXG4gICAgdmFyIHVtaW4gPSAwO1xyXG4gICAgdmFyIHVtYXggPSAwO1xyXG4gICAgdmFyIHZtaW4gPSAwO1xyXG4gICAgdmFyIHZtYXggPSAwO1xyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XHJcbiAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgIHZhciBzY2FsZSA9IChnYW1lT2JqZWN0LmZvbnRTaXplIC8gZ2FtZU9iamVjdC5mb250RGF0YS5zaXplKTtcclxuICAgIHZhciB1dGEsIHV0YiwgdXRjLCB1dGQsIHV0ZSwgdXRmO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhDaGFyTWF0cml4ID0gdGVtcE1hdHJpeENoYXIubWF0cml4O1xyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0O1xyXG5cclxuICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKFxyXG4gICAgICAgIGdhbWVPYmplY3QueCAtIGNhbWVyYVNjcm9sbFgsIGdhbWVPYmplY3QueSAtIGNhbWVyYVNjcm9sbFksIFxyXG4gICAgICAgIC1nYW1lT2JqZWN0LnJvdGF0aW9uLCBcclxuICAgICAgICBnYW1lT2JqZWN0LnNjYWxlWCwgZ2FtZU9iamVjdC5zY2FsZVlcclxuICAgICk7XHJcblxyXG4gICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XHJcblxyXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3Qud2lkdGggPiAwICYmIGdhbWVPYmplY3QuaGVpZ2h0ID4gMClcclxuICAgIHtcclxuICAgICAgICBpZiAocmVuZGVyZXIuY3VycmVudFJlbmRlcmVyICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXJlbmRlcmVyLnNjaXNzb3IuZW5hYmxlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN3ID0gZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Quc2NhbGVYO1xyXG4gICAgICAgIHZhciBzaCA9IGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5zY2FsZVk7XHJcblxyXG4gICAgICAgIGdsLnNjaXNzb3IoZ2FtZU9iamVjdC54LCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0gZ2FtZU9iamVjdC55IC0gc2gsIHN3LCBzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRleHRMZW5ndGg7ICsraW5kZXgpXHJcbiAgICB7XHJcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ID0gMDtcclxuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbHlwaCA9IGNoYXJzW2NoYXJDb2RlXTtcclxuXHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuICAgICAgICBnbHlwaFcgPSBnbHlwaC53aWR0aDtcclxuICAgICAgICBnbHlwaEggPSBnbHlwaC5oZWlnaHQ7XHJcbiAgICAgICAgeCA9IChpbmRleENvdW50ICsgZ2x5cGgueE9mZnNldCArIHhBZHZhbmNlKSAqIHNjYWxlO1xyXG4gICAgICAgIHkgPSAoZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlKSAqIHNjYWxlO1xyXG4gICAgICAgIHJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXJuaW5nT2Zmc2V0ID0gZ2x5cGgua2VybmluZ1tsYXN0Q2hhckNvZGVdO1xyXG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlzcGxheUNhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGRpc3BsYXlDYWxsYmFjayh7IGluZGV4OiBpbmRleCwgY2hhckNvZGU6IGNoYXJDb2RlLCB4OiB4LCB5OiB5LCBzY2FsZTogc2NhbGUsIHJvdGF0aW9uOiAwLCBkYXRhOiBnbHlwaC5kYXRhIH0pO1xyXG5cclxuICAgICAgICAgICAgeCA9IG91dHB1dC54O1xyXG4gICAgICAgICAgICB5ID0gb3V0cHV0Lnk7XHJcbiAgICAgICAgICAgIHNjYWxlID0gb3V0cHV0LnNjYWxlO1xyXG4gICAgICAgICAgICByb3RhdGlvbiA9IG91dHB1dC5yb3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggLT0gZ2FtZU9iamVjdC5zY3JvbGxYIHwgMDtcclxuICAgICAgICB5IC09IGdhbWVPYmplY3Quc2Nyb2xsWSB8IDA7XHJcblxyXG4gICAgICAgIHRlbXBNYXRyaXhDaGFyLmFwcGx5SVRSUyhcclxuICAgICAgICAgICAgeCwgeSxcclxuICAgICAgICAgICAgLXJvdGF0aW9uLFxyXG4gICAgICAgICAgICBzY2FsZSwgc2NhbGVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB1dGEgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFswXTtcclxuICAgICAgICB1dGIgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFsxXTtcclxuICAgICAgICB1dGMgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFsyXTtcclxuICAgICAgICB1dGQgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFszXTtcclxuICAgICAgICB1dGUgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFs0XTtcclxuICAgICAgICB1dGYgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgc3JhID0gdXRhICogbXZhICsgdXRiICogbXZjO1xyXG4gICAgICAgIHNyYiA9IHV0YSAqIG12YiArIHV0YiAqIG12ZDtcclxuICAgICAgICBzcmMgPSB1dGMgKiBtdmEgKyB1dGQgKiBtdmM7XHJcbiAgICAgICAgc3JkID0gdXRjICogbXZiICsgdXRkICogbXZkO1xyXG4gICAgICAgIHNyZSA9IHV0ZSAqIG12YSArIHV0ZiAqIG12YyArIG12ZTtcclxuICAgICAgICBzcmYgPSB1dGUgKiBtdmIgKyB1dGYgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHh3ID0gZ2x5cGhXO1xyXG4gICAgICAgIHloID0gZ2x5cGhIO1xyXG4gICAgICAgIHR4MCA9IHNyZTtcclxuICAgICAgICB0eTAgPSBzcmY7XHJcbiAgICAgICAgdHgxID0geWggKiBzcmMgKyBzcmU7XHJcbiAgICAgICAgdHkxID0geWggKiBzcmQgKyBzcmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBzcmEgKyB5aCAqIHNyYyArIHNyZTtcclxuICAgICAgICB0eTIgPSB4dyAqIHNyYiArIHloICogc3JkICsgc3JmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogc3JhICsgc3JlO1xyXG4gICAgICAgIHR5MyA9IHh3ICogc3JiICsgc3JmO1xyXG4gICAgICAgIHVtaW4gPSBnbHlwaFggLyB0ZXh0dXJlV2lkdGg7XHJcbiAgICAgICAgdW1heCA9IChnbHlwaFggKyBnbHlwaFcpIC8gdGV4dHVyZVdpZHRoO1xyXG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xyXG4gICAgICAgIHZtYXggPSAoZ2x5cGhZICsgZ2x5cGhIKSAvIHRleHR1cmVIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ID49IGJsaXR0ZXJCYXRjaC5tYXhQYXJ0aWNsZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBibGl0dGVyQmF0Y2guZmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKGJsaXR0ZXJCYXRjaCwgdGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDIwKTtcclxuICAgICAgICBibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ICs9IDY7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC53aWR0aCA+IDAgJiYgZ2FtZU9iamVjdC5oZWlnaHQgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIGJsaXR0ZXJCYXRjaC5mbHVzaCgpO1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyZXIuc2Npc3Nvci5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuc2Npc3NvcihyZW5kZXJlci5zY2lzc29yLngsIHJlbmRlcmVyLnNjaXNzb3IueSwgcmVuZGVyZXIuc2Npc3Nvci53aWR0aCwgcmVuZGVyZXIuc2Npc3Nvci5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5zY2lzc29yKGNhbWVyYS54LCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0gY2FtZXJhLnkgLSBjYW1lcmEuaGVpZ2h0LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncyB8fCB0ZXh0TGVuZ3RoID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IHNyYy5mcmFtZTtcclxuXHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3Rvclg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3Rvclk7XHJcblxyXG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcclxuXHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuXHJcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xyXG5cclxuICAgIHZhciBnbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgZ2x5cGhYID0gMDtcclxuICAgIHZhciBnbHlwaFkgPSAwO1xyXG4gICAgdmFyIGdseXBoVyA9IDA7XHJcbiAgICB2YXIgZ2x5cGhIID0gMDtcclxuXHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcclxuXHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgaW1hZ2UgPSBzcmMuZnJhbWUuc291cmNlLmltYWdlO1xyXG5cclxuICAgIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVGcmFtZS5jdXRYO1xyXG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XHJcblxyXG4gICAgdmFyIHJvdGF0aW9uID0gMDtcclxuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgIT09IHNyYy5zY2FsZU1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoc3JjLnggLSBjYW1lcmFTY3JvbGxYLCBzcmMueSAtIGNhbWVyYVNjcm9sbFkpO1xyXG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKHNyYy5zY2FsZVgsIHNyYy5zY2FsZVkpO1xyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcclxuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHlBZHZhbmNlICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGlmICghZ2x5cGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdseXBoWCA9IHRleHR1cmVYICsgZ2x5cGgueDtcclxuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XHJcblxyXG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xyXG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcclxuXHJcbiAgICAgICAgeCA9IGluZGV4Q291bnQgKyBnbHlwaC54T2Zmc2V0ICsgeEFkdmFuY2U7XHJcbiAgICAgICAgeSA9IGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZTtcclxuXHJcbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBrZXJuaW5nT2Zmc2V0ID0gZ2x5cGgua2VybmluZ1tsYXN0Q2hhckNvZGVdO1xyXG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ICo9IHNjYWxlO1xyXG4gICAgICAgIHkgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBnbHlwaFgsIGdseXBoWSwgZ2x5cGhXLCBnbHlwaEgsIDAsIDAsIGdseXBoVywgZ2x5cGhIKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xyXG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcclxuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcclxuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcclxuICAgIH1cclxuXHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpdG1hcFRleHQgPSByZXF1aXJlKCcuL0JpdG1hcFRleHQnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgQml0bWFwVGV4dEZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnYml0bWFwVGV4dCcsXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBCaXRtYXBUZXh0KHRoaXMuc3RhdGUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpdG1hcFRleHQodGhpcy5zdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihCaXRtYXBUZXh0RmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxudmFyIHRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XHJcblxyXG52YXIgQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGdhbWVPYmplY3QsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBnYW1lT2JqZWN0LmZyYW1lO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgdGV4dCA9IGdhbWVPYmplY3QudGV4dDtcclxuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcbiAgICB2YXIgY2hhcnMgPSBnYW1lT2JqZWN0LmZvbnREYXRhLmNoYXJzO1xyXG4gICAgdmFyIGxpbmVIZWlnaHQgPSBnYW1lT2JqZWN0LmZvbnREYXRhLmxpbmVIZWlnaHQ7XHJcbiAgICB2YXIgYmxpdHRlckJhdGNoID0gcmVuZGVyZXIuYmxpdHRlckJhdGNoO1xyXG4gICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gYmxpdHRlckJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgIHZhciBzcmNYID0gZ2FtZU9iamVjdC54OyBcclxuICAgIHZhciBzcmNZID0gZ2FtZU9iamVjdC55O1xyXG4gICAgdmFyIHRleHR1cmVEYXRhID0gZ2FtZU9iamVjdC50ZXh0dXJlLnNvdXJjZVt0ZXh0dXJlRnJhbWUuc291cmNlSW5kZXhdO1xyXG4gICAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUZyYW1lLmN1dFg7XHJcbiAgICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlRnJhbWUuY3V0WTtcclxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlRGF0YS53aWR0aDtcclxuICAgIHZhciB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZURhdGEuaGVpZ2h0O1xyXG4gICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlRGF0YS5nbFRleHR1cmU7XHJcbiAgICB2YXIgeEFkdmFuY2UgPSAwO1xyXG4gICAgdmFyIHlBZHZhbmNlID0gMDtcclxuICAgIHZhciBpbmRleENvdW50ID0gMDtcclxuICAgIHZhciBjaGFyQ29kZSA9IDA7XHJcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGdseXBoWCA9IDA7XHJcbiAgICB2YXIgZ2x5cGhZID0gMDtcclxuICAgIHZhciBnbHlwaFcgPSAwO1xyXG4gICAgdmFyIGdseXBoSCA9IDA7XHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcbiAgICB2YXIgeHcgPSAwO1xyXG4gICAgdmFyIHloID0gMDtcclxuICAgIHZhciB0eCA9IDA7XHJcbiAgICB2YXIgdHkgPSAwO1xyXG4gICAgdmFyIHR4dyA9IDA7XHJcbiAgICB2YXIgdHloID0gMDtcclxuICAgIHZhciB1bWluID0gMDtcclxuICAgIHZhciB1bWF4ID0gMDtcclxuICAgIHZhciB2bWluID0gMDtcclxuICAgIHZhciB2bWF4ID0gMDtcclxuICAgIHZhciBsYXN0R2x5cGggPSBudWxsO1xyXG4gICAgdmFyIGxhc3RDaGFyQ29kZSA9IDA7XHJcbiAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICB2YXIgc2NhbGUgPSAoZ2FtZU9iamVjdC5mb250U2l6ZSAvIGdhbWVPYmplY3QuZm9udERhdGEuc2l6ZSk7XHJcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQ7XHJcblxyXG4gICAgdGVtcE1hdHJpeC5hcHBseUlUUlMoXHJcbiAgICAgICAgZ2FtZU9iamVjdC54IC0gY2FtZXJhU2Nyb2xsWCwgZ2FtZU9iamVjdC55IC0gY2FtZXJhU2Nyb2xsWSwgXHJcbiAgICAgICAgLWdhbWVPYmplY3Qucm90YXRpb24sIFxyXG4gICAgICAgIGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LnNjYWxlWVxyXG4gICAgKTtcclxuXHJcbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcclxuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHlBZHZhbmNlICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XHJcbiAgICAgICAgaWYgKCFnbHlwaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xyXG4gICAgICAgIGdseXBoWSA9IHRleHR1cmVZICsgZ2x5cGgueTtcclxuICAgICAgICBnbHlwaFcgPSBnbHlwaC53aWR0aDtcclxuICAgICAgICBnbHlwaEggPSBnbHlwaC5oZWlnaHQ7XHJcbiAgICAgICAgeCA9IChpbmRleENvdW50ICsgZ2x5cGgueE9mZnNldCArIHhBZHZhbmNlKSAqIHNjYWxlO1xyXG4gICAgICAgIHkgPSAoZ2x5cGgueU9mZnNldCArIHlBZHZhbmNlKSAqIHNjYWxlO1xyXG5cclxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XHJcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHh3ID0geCArIGdseXBoVyAqIHNjYWxlO1xyXG4gICAgICAgIHloID0geSArIGdseXBoSCAqIHNjYWxlO1xyXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdW1pbiA9IGdseXBoWCAvIHRleHR1cmVXaWR0aDtcclxuICAgICAgICB1bWF4ID0gKGdseXBoWCArIGdseXBoVykgLyB0ZXh0dXJlV2lkdGg7XHJcbiAgICAgICAgdm1pbiA9IGdseXBoWSAvIHRleHR1cmVIZWlnaHQ7XHJcbiAgICAgICAgdm1heCA9IChnbHlwaFkgKyBnbHlwaEgpIC8gdGV4dHVyZUhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgPj0gYmxpdHRlckJhdGNoLm1heFBhcnRpY2xlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJsaXR0ZXJCYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyZXIoYmxpdHRlckJhdGNoLCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjApO1xyXG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtYXg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XHJcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xyXG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xyXG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0V2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQmxpdHRlckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaXN0ID0gc3JjLmdldFJlbmRlckxpc3QoKTtcclxuXHJcbiAgICByZW5kZXJlci5zZXRCbGVuZE1vZGUoc3JjLmJsZW5kTW9kZSk7XHJcblxyXG4gICAgdmFyIGNhID0gcmVuZGVyZXIuY3VycmVudEFscGhhO1xyXG5cclxuICAgIC8vICBSZW5kZXIgYm9ic1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBib2IgPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICBpZiAoY2EgIT09IGJvYi5hbHBoYSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhID0gcmVuZGVyZXIuc2V0QWxwaGEoYm9iLmFscGhhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLmJsaXRJbWFnZShib2IueCwgYm9iLnksIGJvYi5mcmFtZSwgY2FtZXJhKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlckNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBCbGl0dGVyID0gcmVxdWlyZSgnLi9CbGl0dGVyJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIEJsaXR0ZXJGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2JsaXR0ZXInLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBCbGl0dGVyKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbGl0dGVyKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihCbGl0dGVyRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9CbGl0dGVyQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0JsaXR0ZXJXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJsaXR0ZXJXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaXN0ID0gc3JjLmdldFJlbmRlckxpc3QoKTtcclxuICAgIHZhciBibGl0dGVyQmF0Y2ggPSByZW5kZXJlci5ibGl0dGVyQmF0Y2g7XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgIHZhciBiID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgdmFyIGMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICB2YXIgZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgIHZhciBlID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgdmFyIGYgPSBjYW1lcmFNYXRyaXhbNV07XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3Rvclg7XHJcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWSA9IGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gc3JjLnJlbmRlclRhcmdldDtcclxuXHJcbiAgICAvLyAgUmVuZGVyIGJvYnNcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBib2IgPSBsaXN0W2ldO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGJvYi5mcmFtZTtcclxuICAgICAgICB2YXIgYWxwaGEgPSBib2IuYWxwaGE7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBibGl0dGVyQmF0Y2gudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcclxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aCAqIChib2IuZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiAoYm9iLmZsaXBZID8gLTEgOiAxKTtcclxuICAgICAgICB2YXIgeCA9IGJvYi54ICsgZnJhbWUueCAtIGNhbWVyYVNjcm9sbFggKyAoKGZyYW1lLndpZHRoKSAqIChib2IuZmxpcFggPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHkgPSBib2IueSArIGZyYW1lLnkgLSBjYW1lcmFTY3JvbGxZICsgKChmcmFtZS5oZWlnaHQpICogKGJvYi5mbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgdHggPSB4ICogYSArIHkgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkgPSB4ICogYiArIHkgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHh3ID0geHcgKiBhICsgeWggKiBjICsgZTtcclxuICAgICAgICB2YXIgdHloID0geHcgKiBiICsgeWggKiBkICsgZjtcclxuXHJcbiAgICAgICAgaWYgKGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgPj0gYmxpdHRlckJhdGNoLm1heFBhcnRpY2xlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJsaXR0ZXJCYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyZXIoYmxpdHRlckJhdGNoLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBjYW1lcmEsIHJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyMCk7XHJcbiAgICAgICAgYmxpdHRlckJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgIHggKz0gZnJhbWUueDtcclxuICAgICAgICB5ICs9IGZyYW1lLnk7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eWg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4dztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHloO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eHc7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJsaXR0ZXJXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm9iID0gZnVuY3Rpb24gKGJsaXR0ZXIsIHgsIHksIGZyYW1lLCB2aXNpYmxlKVxyXG57XHJcbiAgICB0aGlzLnBhcmVudCA9IGJsaXR0ZXI7XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XHJcbiAgICB0aGlzLmRhdGEgPSB7fTtcclxuXHJcbiAgICB0aGlzLl92aXNpYmxlID0gdmlzaWJsZTtcclxuICAgIHRoaXMuX2FscGhhID0gMTtcclxuXHJcbiAgICB0aGlzLmZsaXBYIC0gZmFsc2U7XHJcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuQm9iLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvYjtcclxuXHJcbkJvYi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgcmVzZXRGbGlwOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKHgsIHksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9iLnByb3RvdHlwZSwge1xyXG5cclxuICAgIHZpc2libGU6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhbHBoYToge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb2I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvYmxpdHRlci9Cb2IuanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENvbnRhaW5lckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBSZW5kZXIgY2hpbGRyZW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gc3JjLmNoaWxkcmVuLmxpc3RbaV07XHJcblxyXG4gICAgICAgIGNoaWxkLnJlbmRlckNhbnZhcyhyZW5kZXJlciwgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXJDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4vQ29udGFpbmVyJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIENvbnRhaW5lckZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnY29udGFpbmVyJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChwYXJlbnQsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7IHBhcmVudCA9IHRoaXMuc3RhdGU7IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihDb250YWluZXJGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9Db250YWluZXJDYW52YXNSZW5kZXJlcicpLFxyXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vQ29udGFpbmVyV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENvbnRhaW5lcldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFJlbmRlciBjaGlsZHJlblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBzcmMuY2hpbGRyZW4ubGlzdFtpXTtcclxuXHJcbiAgICAgICAgY2hpbGQucmVuZGVyV2ViR0wocmVuZGVyZXIsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFZmZlY3RMYXllciA9IHJlcXVpcmUoJy4vRWZmZWN0TGF5ZXInKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG5cclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChzdGF0ZSwgY29uZmlnKVxyXG57XHJcbiAgICB2YXIgeCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3knLCAwKTtcclxuICAgIHZhciB3aWR0aCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnd2lkdGgnLCA1MTIpO1xyXG4gICAgdmFyIGhlaWdodCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnaGVpZ2h0JywgNTEyKTtcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFnbWVudFNoYWRlcicsICcnKTtcclxuXHJcbiAgICB2YXIgbGF5ZXIgPSBuZXcgRWZmZWN0TGF5ZXIoc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhZ21lbnRTaGFkZXIpO1xyXG5cclxuICAgIHJldHVybiBsYXllcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVpbGRGcm9tQ29uZmlnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0J1aWxkRnJvbUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFZmZlY3RMYXllckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVmZmVjdExheWVyQ2FudmFzUmVuZGVyZXI7XHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRWZmZWN0TGF5ZXIgPSByZXF1aXJlKCcuL0VmZmVjdExheWVyJyk7XHJcbnZhciBCdWlsZEZyb21Db25maWcgPSByZXF1aXJlKCcuL0J1aWxkRnJvbUNvbmZpZycpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBFZmZlY3RMYXllckZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnZWZmZWN0TGF5ZXInLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGVmZmVjdE5hbWUsIGZyYWdtZW50U2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFkZChuZXcgRWZmZWN0TGF5ZXIodGhpcy5zdGF0ZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZWZmZWN0TmFtZSwgZnJhZ21lbnRTaGFkZXIpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGVmZmVjdE5hbWUsIGZyYWdtZW50U2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWZmZWN0TGF5ZXIodGhpcy5zdGF0ZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZWZmZWN0TmFtZSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2U6IGZ1bmN0aW9uIChjb25maWcpXHJcbiAgICAvLyB7XHJcbiAgICAvLyAgICAgcmV0dXJuIEJ1aWxkRnJvbUNvbmZpZyh0aGlzLnN0YXRlLCBjb25maWcpO1xyXG4gICAgLy8gfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihFZmZlY3RMYXllckZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9FZmZlY3RMYXllckNhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9FZmZlY3RMYXllcldlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9lZmZlY3RsYXllci9FZmZlY3RMYXllclJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFZmZlY3RMYXllcldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZW5kZXJlci5lZmZlY3RSZW5kZXJlci5yZW5kZXJFZmZlY3Qoc3JjLCBjYW1lcmEsIHNyYy5yZW5kZXJUZXh0dXJlLCBzcmMud2lkdGgsIHNyYy5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMYXllcldlYkdMUmVuZGVyZXI7XHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2VmZmVjdGxheWVyL0VmZmVjdExheWVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcclxudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcblxyXG52YXIgR3JhcGhpY3NDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRDdHgpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjYW1lcmFTY3JvbGxYID0gY2FtZXJhLnNjcm9sbFggKiBzcmMuc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiBzcmMuc2Nyb2xsRmFjdG9yWTtcclxuICAgIHZhciBzcmNYID0gc3JjLng7XHJcbiAgICB2YXIgc3JjWSA9IHNyYy55O1xyXG4gICAgdmFyIHNyY1NjYWxlWCA9IHNyYy5zY2FsZVg7XHJcbiAgICB2YXIgc3JjU2NhbGVZID0gc3JjLnNjYWxlWTtcclxuICAgIHZhciBzcmNSb3RhdGlvbiA9IHNyYy5yb3RhdGlvbjtcclxuICAgIHZhciBjb21tYW5kQnVmZmVyID0gc3JjLmNvbW1hbmRCdWZmZXI7XHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyVGFyZ2V0Q3R4IHx8IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgdmFyIGxpbmVBbHBoYSA9IDEuMDtcclxuICAgIHZhciBmaWxsQWxwaGEgPSAxLjA7XHJcbiAgICB2YXIgbGluZUNvbG9yID0gMDtcclxuICAgIHZhciBmaWxsQ29sb3IgPSAwO1xyXG4gICAgdmFyIGxpbmVXaWR0aCA9IDEuMDtcclxuICAgIHZhciByZWQgPSAwO1xyXG4gICAgdmFyIGdyZWVuID0gMDtcclxuICAgIHZhciBibHVlID0gMDtcclxuXHJcbiAgICAvLyAgQmxlbmQgTW9kZVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgIT09IHNyYy5ibGVuZE1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XHJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudEFscGhhICE9PSBzcmMuYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgU21vb3RoaW5nXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlID0gc3JjLnNjYWxlTW9kZTtcclxuICAgIH1cclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShzcmNYIC0gY2FtZXJhU2Nyb2xsWCwgc3JjWSAtIGNhbWVyYVNjcm9sbFkpO1xyXG4gICAgY3R4LnJvdGF0ZShzcmNSb3RhdGlvbik7XHJcbiAgICBjdHguc2NhbGUoc3JjU2NhbGVYLCBzcmNTY2FsZVkpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcclxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHNyYy5hbHBoYTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGNvbW1hbmRCdWZmZXIubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgIHtcclxuICAgICAgICB2YXIgY29tbWFuZElEID0gY29tbWFuZEJ1ZmZlcltpbmRleF07XHJcblxyXG4gICAgICAgIHN3aXRjaCAoY29tbWFuZElEKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5BUkM6XHJcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA0XSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDZdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1NUWUxFOlxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgbGluZUNvbG9yID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgbGluZUFscGhhID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdO1xyXG4gICAgICAgICAgICAgICAgcmVkID0gKChsaW5lQ29sb3IgJiAweEZGMDAwMCkgPj4+IDE2KTtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gKChsaW5lQ29sb3IgJiAweEZGMDApID4+PiA4KTtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSAobGluZUNvbG9yICYgMHhGRik7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgcmVkICsgJywnICsgZ3JlZW4gKyAnLCcgKyBibHVlICsgJywnICsgbGluZUFscGhhICsgJyknO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGZpbGxBbHBoYSA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIHJlZCA9ICgoZmlsbENvbG9yICYgMHhGRjAwMDApID4+PiAxNik7XHJcbiAgICAgICAgICAgICAgICBncmVlbiA9ICgoZmlsbENvbG9yICYgMHhGRjAwKSA+Pj4gOCk7XHJcbiAgICAgICAgICAgICAgICBibHVlID0gKGZpbGxDb2xvciAmIDB4RkYpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByZWQgKyAnLCcgKyBncmVlbiArICcsJyArIGJsdWUgKyAnLCcgKyBmaWxsQWxwaGEgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkJFR0lOX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQ0xPU0VfUEFUSDpcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUUk9LRV9QQVRIOlxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfUkVDVDpcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgNF1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfVFJJQU5HTEU6XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNF0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgNV0sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA2XSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUUk9LRV9UUklBTkdMRTpcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb21tYW5kQnVmZmVyW2luZGV4ICsgM10sIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA0XSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyA1XSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDZdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1RPOlxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5NT1ZFX1RPOlxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX0ZYX1RPOlxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5NT1ZFX0ZYX1RPOlxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQVZFOlxyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5SRVNUT1JFOlxyXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5UUkFOU0xBVEU6XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNDQUxFOlxyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlJPVEFURTpcclxuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BoYXNlcjogSW52YWxpZCBHcmFwaGljcyBDb21tYW5kIElEICcgKyBjb21tYW5kSUQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHcmFwaGljcyA9IHJlcXVpcmUoJy4vR3JhcGhpY3MnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgR3JhcGhpY3NGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2dyYXBoaWNzJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChvcHRpb25zKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFkZChuZXcgR3JhcGhpY3ModGhpcy5zdGF0ZSwgb3B0aW9ucykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAob3B0aW9ucylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNzKHRoaXMuc3RhdGUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihHcmFwaGljc0ZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9HcmFwaGljc0NhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9HcmFwaGljc1dlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcclxudmFyIFRyYW5zZm9ybU1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4Jyk7XHJcbnZhciBwYXRoQXJyYXkgPSBbXTtcclxudmFyIGNvcyA9IE1hdGguY29zO1xyXG52YXIgc2luID0gTWF0aC5zaW47XHJcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xyXG52YXIgdGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxudmFyIG1hdHJpeFN0YWNrID0gbmV3IEZsb2F0MzJBcnJheSg2ICogMTAwMCk7XHJcbnZhciBtYXRyaXhTdGFja0xlbmd0aCA9IDA7XHJcbnZhciBjdXJyZW50TWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG5cclxudmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCByZ2IsIGFscGhhKVxyXG57XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMucmdiID0gcmdiO1xyXG4gICAgdGhpcy5hbHBoYSA9IGFscGhhO1xyXG59O1xyXG5cclxudmFyIFBhdGggPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIHJnYiwgYWxwaGEpXHJcbntcclxuICAgIHRoaXMucG9pbnRzID0gW107XHJcbiAgICB0aGlzLnBvaW50c0xlbmd0aCA9IDE7XHJcbiAgICB0aGlzLnBvaW50c1swXSA9IG5ldyBQb2ludCh4LCB5LCB3aWR0aCwgcmdiLCBhbHBoYSk7XHJcbn07XHJcblxyXG52YXIgR3JhcGhpY3NXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBnYW1lT2JqZWN0LCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhLCBmb3JjZVJlbmRlclRhcmdldClcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGZvcmNlUmVuZGVyVGFyZ2V0IHx8IGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0O1xyXG4gICAgdmFyIHNoYXBlQmF0Y2ggPSByZW5kZXJlci5zaGFwZUJhdGNoO1xyXG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBzaGFwZUJhdGNoLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGNhbWVyYVNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICBjb25zdCBzcmNYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhU2Nyb2xsWDtcclxuICAgIGNvbnN0IHNyY1kgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmFTY3JvbGxZO1xyXG4gICAgY29uc3Qgc3JjU2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICBjb25zdCBzcmNTY2FsZVkgPSBnYW1lT2JqZWN0LnNjYWxlWTtcclxuICAgIGNvbnN0IHNyY1JvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICB2YXIgY29tbWFuZEJ1ZmZlciA9IGdhbWVPYmplY3QuY29tbWFuZEJ1ZmZlcjtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciBsaW5lQWxwaGEgPSAxLjA7XHJcbiAgICB2YXIgZmlsbEFscGhhID0gMS4wO1xyXG4gICAgdmFyIGxpbmVDb2xvciA9IDA7XHJcbiAgICB2YXIgZmlsbENvbG9yID0gMDtcclxuICAgIHZhciBsaW5lV2lkdGggPSAxLjA7XHJcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICB2YXIgbGFzdFBhdGggPSBudWxsO1xyXG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XHJcbiAgICB2YXIgaXRlclN0ZXAgPSAwLjAxO1xyXG4gICAgdmFyIHR4ID0gMDtcclxuICAgIHZhciB0eSA9IDA7XHJcbiAgICB2YXIgdGEgPSAwO1xyXG4gICAgdmFyIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2U7XHJcbiAgICB2YXIgd2lkdGgsIGhlaWdodCwgdHh3LCB0eWg7XHJcbiAgICB2YXIgdmVydGV4Q291bnQgPSBzaGFwZUJhdGNoLnZlcnRleENvdW50O1xyXG4gICAgdmFyIHBvbHlnb24gPSBbXTtcclxuICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyO1xyXG4gICAgdmFyIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTI7XHJcbiAgICB2YXIgdjAsIHYxLCB2MjtcclxuICAgIHZhciBwb2x5Z29uSW5kZXg7XHJcbiAgICB2YXIgcGF0aDtcclxuICAgIHZhciBwYXRoTGVuZ3RoO1xyXG4gICAgdmFyIHBvaW50O1xyXG4gICAgdmFyIG1heFZlcnRpY2VzID0gc2hhcGVCYXRjaC5tYXhWZXJ0aWNlcztcclxuICAgIHZhciB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZO1xyXG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmY7XHJcblxyXG4gICAgdGVtcE1hdHJpeC5hcHBseUlUUlMoc3JjWCwgc3JjWSwgc3JjUm90YXRpb24sIHNyY1NjYWxlWCwgc3JjU2NhbGVZKTtcclxuXHJcbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjtcclxuXHJcbiAgICByZW5kZXJlci5zZXRSZW5kZXJlcihzaGFwZUJhdGNoLCBudWxsLCByZW5kZXJUYXJnZXQpO1xyXG5cclxuICAgIGZvciAodmFyIGNtZEluZGV4ID0gMCwgY21kTGVuZ3RoID0gY29tbWFuZEJ1ZmZlci5sZW5ndGg7IGNtZEluZGV4IDwgY21kTGVuZ3RoOyArK2NtZEluZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4XTtcclxuXHJcbiAgICAgICAgc3dpdGNoKGNtZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQVJDOlxyXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHggPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICB5ID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XTtcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdO1xyXG4gICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA2XTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbiA8IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGEgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAqIGl0ZXJhdGlvbiArIHN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHggPSB4ICsgY29zKHRhKSAqIHJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB0eSA9IHkgKyBzaW4odGEpICogcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgUGF0aCh0eCwgdHksIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludCh0eCwgdHksIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiArPSBpdGVyU3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGxpbmVDb2xvciA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIGxpbmVBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9TVFlMRTpcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGZpbGxBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQkVHSU5fUEFUSDpcclxuICAgICAgICAgICAgICAgIHBhdGhBcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkNMT1NFX1BBVEg6XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGggIT09IG51bGwgJiYgbGFzdFBhdGgucG9pbnRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSBsYXN0UGF0aC5wb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RQb2ludCA9IGxhc3RQYXRoLnBvaW50c1tsYXN0UGF0aC5wb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGgucG9pbnRzLnB1c2goZmlyc3RQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgUGF0aChsYXN0UG9pbnQueCwgbGFzdFBvaW50LnksIGxhc3RQb2ludC53aWR0aCwgbGFzdFBvaW50LnJnYiwgbGFzdFBvaW50LmFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9QQVRIOlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aEFycmF5SW5kZXggPSAwLCBwYXRoQXJyYXlMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheUluZGV4IDwgcGF0aEFycmF5TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICsrcGF0aEFycmF5SW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsUGF0aChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXlbcGF0aEFycmF5SW5kZXhdLnBvaW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfUEFUSDpcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhdGhBcnJheUluZGV4ID0gMCwgcGF0aEFycmF5TGVuZ3RoID0gcGF0aEFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXlJbmRleCA8IHBhdGhBcnJheUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICArK3BhdGhBcnJheUluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aEFycmF5W3BhdGhBcnJheUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZFN0cm9rZVBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZWN0YW5nbGUgcHJvcGVydGllcyAqLyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5wb2ludHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID09PSB0aGlzLl9sYXN0UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeFxyXG5cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1JFQ1Q6XHJcbiAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZEZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cclxuICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgLyogUmVjdGFuZ2xlIHByb3BlcnRpZXMgKi8gXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cclxuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfVFJJQU5HTEU6XHJcbiAgICAgICAgICAgICAgICBzaGFwZUJhdGNoLmFkZEZpbGxUcmlhbmdsZShcclxuICAgICAgICAgICAgICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBQcm9wZXJ0aWVzICovXHJcbiAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRyaWFuZ2xlIHByb3BlcnRpZXMgKi8gXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV0gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA2XSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cclxuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLlNUUk9LRV9UUklBTkdMRTpcclxuICAgICAgICAgICAgICAgIHNoYXBlQmF0Y2guYWRkU3Ryb2tlVHJpYW5nbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSAtIGNhbWVyYVNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdIC0gY2FtZXJhU2Nyb2xsWSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10gLSBjYW1lcmFTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XSAtIGNhbWVyYVNjcm9sbFksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdIC0gY2FtZXJhU2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl0gLSBjYW1lcmFTY3JvbGxZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeFxyXG5cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1RPOlxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludChjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0sIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9UTzpcclxuICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX0ZYX1RPOlxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA1XVxyXG4gICAgICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheS5wdXNoKGxhc3RQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9GWF9UTzpcclxuICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQVZFOlxyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAwXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzBdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAxXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzFdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAyXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzJdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAzXSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzNdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA0XSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzRdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA1XSA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzVdO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tMZW5ndGggKz0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5SRVNUT1JFOlxyXG4gICAgICAgICAgICAgICAgbWF0cml4U3RhY2tMZW5ndGggLT0gNjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzBdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAwXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzFdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAxXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzJdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAyXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzNdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyAzXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzRdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA0XTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXgubWF0cml4WzVdID0gbWF0cml4U3RhY2tbbWF0cml4U3RhY2tMZW5ndGggKyA1XTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5UUkFOU0xBVEU6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0cml4LnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TQ0FMRTpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXguc2NhbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuUk9UQVRFOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudE1hdHJpeC5yb3RhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgLWNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaGFzZXI6IEludmFsaWQgR3JhcGhpY3MgQ29tbWFuZCBJRCAnICsgY21kKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGN1cnJlbnRNYXRyaXgubG9hZElkZW50aXR5KCk7XHJcbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJbWFnZSA9IHJlcXVpcmUoJy4vSW1hZ2UnKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsIG51bGwpO1xyXG5cclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZShzdGF0ZSwgMCwgMCwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHN0YXRlLCBpbWFnZSwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gaW1hZ2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkRnJvbUNvbmZpZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9pbWFnZS9CdWlsZEZyb21Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEltYWdlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayA9PT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5kcmF3SW1hZ2Uoc3JjLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEltYWdlID0gcmVxdWlyZSgnLi9JbWFnZScpO1xyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gcmVxdWlyZSgnLi9CdWlsZEZyb21Db25maWcnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgSW1hZ2VGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2ltYWdlJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlIGEgbmV3IGBJbWFnZWAgb2JqZWN0LlxyXG4gICAgKlxyXG4gICAgKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cclxuICAgICpcclxuICAgICogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLlxyXG4gICAgKiBUaGlzIG1ha2VzIGl0IHBlcmZlY3QgZm9yIGxvZ29zLCBiYWNrZ3JvdW5kcywgc2ltcGxlIGJ1dHRvbnMgYW5kIG90aGVyIG5vbi1TcHJpdGUgZ3JhcGhpY3MuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNpbWFnZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuSW1hZ2V9IFRoZSBuZXdseSBjcmVhdGVkIEltYWdlIG9iamVjdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFkZChuZXcgSW1hZ2UodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBCdWlsZEZyb21Db25maWcodGhpcy5zdGF0ZSwgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoSW1hZ2VGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vSW1hZ2VDYW52YXNSZW5kZXJlcicpLFxyXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vSW1hZ2VXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2VXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlKHNyYywgY2FtZXJhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgTGF5ZXJGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ2xheWVyJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZHJlbilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IExheWVyKHRoaXMuc3RhdGUsIGNoaWxkcmVuKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKGNoaWxkcmVuKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXIodGhpcy5zdGF0ZSwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihMYXllckZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL2xheWVyL0xheWVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNZXNoID0gcmVxdWlyZSgnLi9NZXNoJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9CdWlsZEdhbWVPYmplY3QnKTtcclxuXHJcbnZhciBCdWlsZEZyb21Db25maWcgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIGtleSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAna2V5JywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZyYW1lJywgbnVsbCk7XHJcbiAgICB2YXIgdmVydGljZXMgPSBHZXRWYWx1ZShjb25maWcsICd2ZXJ0aWNlcycsIFtdKTtcclxuICAgIHZhciBpbmRpY2VzID0gR2V0VmFsdWUoY29uZmlnLCAnaW5kaWNlcycsIFtdKTtcclxuICAgIHZhciBjb2xvcnMgPSBHZXRWYWx1ZShjb25maWcsICdjb2xvcnMnLCBbXSk7XHJcbiAgICB2YXIgYWxwaGFzID0gR2V0VmFsdWUoY29uZmlnLCAnYWxwaGFzJywgW10pO1xyXG4gICAgdmFyIHV2ID0gR2V0VmFsdWUoY29uZmlnLCAndXYnLCBbXSk7XHJcblxyXG4gICAgdmFyIG1lc2ggPSBuZXcgTWVzaChzdGF0ZSwgMCwgMCwgdmVydGljZXMsIHV2LCBpbmRpY2VzLCBjb2xvcnMsIGFscGhhcywga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHN0YXRlLCBtZXNoLCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiBtZXNoO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEZyb21Db25maWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvbWVzaC9CdWlsZEZyb21Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVzaENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVzaENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaENhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBNZXNoID0gcmVxdWlyZSgnLi9NZXNoJyk7XHJcbnZhciBCdWlsZEZyb21Db25maWcgPSByZXF1aXJlKCcuL0J1aWxkRnJvbUNvbmZpZycpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBNZXNoRmFjdG9yeSA9IHtcclxuXHJcbiAgICBLRVk6ICdtZXNoJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCB2ZXJ0aWNlcywgdXYsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBNZXNoKHRoaXMuc3RhdGUsIHgsIHksIHZlcnRpY2VzLCB1diwga2V5LCBmcmFtZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBCdWlsZEZyb21Db25maWcodGhpcy5zdGF0ZSwgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoTWVzaEZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vTWVzaENhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9NZXNoV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL21lc2gvTWVzaFJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNZXNoV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChzcmMuaW5kaWNlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZE1lc2hJbmRleGVkKHNyYywgY2FtZXJhKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRNZXNoKHNyYywgY2FtZXJhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVzaFdlYkdMUmVuZGVyZXJcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9tZXNoL01lc2hXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFF1YWQgPSByZXF1aXJlKCcuL1F1YWQnKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXHJcbntcclxuICAgIHZhciB4ID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICd4JywgMCk7XHJcbiAgICB2YXIgeSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAneScsIDApO1xyXG4gICAgdmFyIGtleSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAna2V5JywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2ZyYW1lJywgbnVsbCk7XHJcblxyXG4gICAgdmFyIHF1YWQgPSBuZXcgUXVhZChzdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHN0YXRlLCBxdWFkLCBjb25maWcpO1xyXG5cclxuICAgIHJldHVybiBxdWFkO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEZyb21Db25maWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcXVhZC9CdWlsZEZyb21Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFF1YWQgPSByZXF1aXJlKCcuL1F1YWQnKTtcclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IHJlcXVpcmUoJy4vQnVpbGRGcm9tQ29uZmlnJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFF1YWRGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ3F1YWQnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBRdWFkKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gQnVpbGRGcm9tQ29uZmlnKHRoaXMuc3RhdGUsIGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKFF1YWRGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9xdWFkL1F1YWRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlclBhc3NDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJQYXNzQ2FudmFzUmVuZGVyZXI7XHJcbiBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3JlbmRlcnBhc3MvUmVuZGVyUGFzc0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlclBhc3MgPSByZXF1aXJlKCcuL1JlbmRlclBhc3MnKTtcclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG52YXIgUmVuZGVyUGFzc0ZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAncmVuZGVyUGFzcycsXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgc2hhZGVyTmFtZSwgZnJhZ21lbnRTaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBSZW5kZXJQYXNzKHRoaXMuc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHNoYWRlck5hbWUsIGZyYWdtZW50U2hhZGVyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzaGFkZXJOYW1lLCBmcmFnbWVudFNoYWRlcilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlclBhc3ModGhpcy5zdGF0ZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc2hhZGVyTmFtZSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihSZW5kZXJQYXNzRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9SZW5kZXJQYXNzQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL1JlbmRlclBhc3NXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvcmVuZGVycGFzcy9SZW5kZXJQYXNzUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbmRlclBhc3NXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlVGV4dHVyZShzcmMsIGNhbWVyYSwgc3JjLnJlbmRlclRleHR1cmUsIHNyYy53aWR0aCwgc3JjLmhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclBhc3NXZWJHTFJlbmRlcmVyO1xyXG4gXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9yZW5kZXJwYXNzL1JlbmRlclBhc3NXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vU3ByaXRlJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIEJ1aWxkR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0J1aWxkR2FtZU9iamVjdCcpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0QW5pbWF0aW9uID0gcmVxdWlyZSgnLi4vQnVpbGRHYW1lT2JqZWN0QW5pbWF0aW9uJyk7XHJcblxyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXHJcbntcclxuICAgIHZhciBrZXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2tleScsIG51bGwpO1xyXG4gICAgdmFyIGZyYW1lID0gR2V0QWR2YW5jZWRWYWx1ZShjb25maWcsICdmcmFtZScsIG51bGwpO1xyXG5cclxuICAgIHZhciBzcHJpdGUgPSBuZXcgU3ByaXRlKHN0YXRlLCAwLCAwLCBrZXksIGZyYW1lKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3Qoc3RhdGUsIHNwcml0ZSwgY29uZmlnKTtcclxuXHJcbiAgICAvLyAgU3ByaXRlIHNwZWNpZmljIGNvbmZpZyBvcHRpb25zOlxyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdEFuaW1hdGlvbihzcHJpdGUsIGNvbmZpZyk7XHJcblxyXG4gICAgLy8gIFBoeXNpY3MsIElucHV0LCBldGMgdG8gZm9sbG93IC4uLlxyXG5cclxuICAgIHJldHVybiBzcHJpdGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkRnJvbUNvbmZpZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9zcHJpdGUvQnVpbGRGcm9tQ29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBTcHJpdGVDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrID09PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmRyYXdJbWFnZShzcmMsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9TcHJpdGUnKTtcclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IHJlcXVpcmUoJy4vQnVpbGRGcm9tQ29uZmlnJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFNwcml0ZUZhY3RvcnkgPSB7XHJcblxyXG4gICAgS0VZOiAnc3ByaXRlJyxcclxuXHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlIGEgbmV3IFNwcml0ZSB3aXRoIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBzcHJpdGUgc2hlZXQga2V5LlxyXG4gICAgKlxyXG4gICAgKiBBdCBpdHMgbW9zdCBiYXNpYyBhIFNwcml0ZSBjb25zaXN0cyBvZiBhIHNldCBvZiBjb29yZGluYXRlcyBhbmQgYSB0ZXh0dXJlIHRoYXQgaXMgdXNlZCB3aGVuIHJlbmRlcmVkLlxyXG4gICAgKiBUaGV5IGFsc28gY29udGFpbiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYWxsb3dpbmcgZm9yIHBoeXNpY3MgbW90aW9uICh2aWEgU3ByaXRlLmJvZHkpLCBpbnB1dCBoYW5kbGluZyAodmlhIFNwcml0ZS5pbnB1dCksXHJcbiAgICAqIGV2ZW50cyAodmlhIFNwcml0ZS5ldmVudHMpLCBhbmltYXRpb24gKHZpYSBTcHJpdGUuYW5pbWF0aW9ucyksIGNhbWVyYSBjdWxsaW5nIGFuZCBtb3JlLiBQbGVhc2Ugc2VlIHRoZSBFeGFtcGxlcyBmb3IgdXNlIGNhc2VzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5HYW1lT2JqZWN0LkZhY3Rvcnkjc3ByaXRlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHNwcml0ZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBzcHJpdGUgbWF5IGJlIGluLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBzcHJpdGUuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgc3ByaXRlIG1heSBiZSBpbi5cclxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxyXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCBTcHJpdGUgb2JqZWN0LlxyXG4gICAgKi9cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBTcHJpdGUodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBCdWlsZEZyb21Db25maWcodGhpcy5zdGF0ZSwgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoU3ByaXRlRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vU3ByaXRlQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL1Nwcml0ZVdlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwcml0ZVdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRTcHJpdGUoc3JjLCBjYW1lcmEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBHZXRUZXh0U2l6ZSA9IGZ1bmN0aW9uICh0ZXh0LCBzaXplLCBsaW5lcylcclxue1xyXG4gICAgdmFyIGNhbnZhcyA9IHRleHQuY2FudmFzO1xyXG4gICAgdmFyIGNvbnRleHQgPSB0ZXh0LmNvbnRleHQ7XHJcbiAgICB2YXIgc3R5bGUgPSB0ZXh0LnN0eWxlO1xyXG5cclxuICAgIHZhciBsaW5lV2lkdGhzID0gW107XHJcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcclxuICAgIHZhciBkcmF3bkxpbmVzID0gbGluZXMubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBpZiAoc3R5bGUubWF4TGluZXMgPiAwICYmIHN0eWxlLm1heExpbmVzIDwgbGluZXMubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIGRyYXduTGluZXMgPSBzdHlsZS5tYXhMaW5lcztcclxuICAgIH1cclxuXHJcbiAgICBzdHlsZS5zeW5jRm9udChjYW52YXMsIGNvbnRleHQpO1xyXG5cclxuICAgIC8vICBUZXh0IFdpZHRoXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmF3bkxpbmVzOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcclxuXHJcbiAgICAgICAgbGluZVdpZHRoICs9IGNvbnRleHQubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoO1xyXG5cclxuICAgICAgICAvLyBBZGp1c3QgZm9yIHdyYXBwZWQgdGV4dFxyXG4gICAgICAgIGlmIChzdHlsZS53b3JkV3JhcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aCAtPSBjb250ZXh0Lm1lYXN1cmVUZXh0KCcgJykud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaW5lV2lkdGhzW2ldID0gTWF0aC5jZWlsKGxpbmVXaWR0aCk7XHJcbiAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGhzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgVGV4dCBIZWlnaHRcclxuXHJcbiAgICB2YXIgbGluZUhlaWdodCA9IHNpemUuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XHJcbiAgICB2YXIgaGVpZ2h0ID0gbGluZUhlaWdodCAqIGRyYXduTGluZXM7XHJcbiAgICB2YXIgbGluZVNwYWNpbmcgPSB0ZXh0Ll9saW5lU3BhY2luZyB8fCAwO1xyXG5cclxuICAgIGlmIChsaW5lU3BhY2luZyA8IDAgJiYgTWF0aC5hYnMobGluZVNwYWNpbmcpID4gbGluZUhlaWdodClcclxuICAgIHtcclxuICAgICAgICBsaW5lU3BhY2luZyA9IC1saW5lSGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGp1c3QgZm9yIGxpbmUgc3BhY2luZ1xyXG4gICAgaWYgKGxpbmVTcGFjaW5nICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIGhlaWdodCArPSAobGluZVNwYWNpbmcgPiAwKSA/IGxpbmVTcGFjaW5nICogbGluZXMubGVuZ3RoIDogbGluZVNwYWNpbmcgKiAobGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogbWF4TGluZVdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGxpbmVzOiBkcmF3bkxpbmVzLFxyXG4gICAgICAgIGxpbmVXaWR0aHM6IGxpbmVXaWR0aHMsXHJcbiAgICAgICAgbGluZVNwYWNpbmc6IGxpbmVTcGFjaW5nLFxyXG4gICAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcclxuICAgIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFRleHRTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvR2V0VGV4dFNpemUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XHJcblxyXG4vKipcclxuKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udCBzdHlsZS5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuVGV4dCNkZXRlcm1pbmVGb250UHJvcGVydGllc1xyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtvYmplY3R9IHRleHRTdHlsZVxyXG4qL1xyXG52YXIgTWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCB0ZXN0U3RyaW5nKVxyXG57XHJcbiAgICBpZiAodGVzdFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7IHRlc3RTdHJpbmcgPSAnfE3DiXFneSc7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHRoZSB0ZXh0IGlzIHJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgdGhlIHRleHQgaXMgcmVuZGVyZWQgdG8uXHJcbiAgICAgKi9cclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgdGV4dFN0eWxlLnN5bmNGb250KGNhbnZhcywgY29udGV4dCk7XHJcblxyXG4gICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQodGVzdFN0cmluZykud2lkdGggKiAxLjIpO1xyXG4gICAgdmFyIGJhc2VsaW5lID0gd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gMiAqIGJhc2VsaW5lO1xyXG5cclxuICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgKiAxLjQgfCAwO1xyXG5cclxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgY29udGV4dC5mb250ID0gdGV4dFN0eWxlLmZvbnQ7XHJcblxyXG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGVzdFN0cmluZywgMCwgYmFzZWxpbmUpO1xyXG5cclxuICAgIHZhciBvdXRwdXQgPSB7XHJcbiAgICAgICAgYXNjZW50OiAwLFxyXG4gICAgICAgIGRlc2NlbnQ6IDAsXHJcbiAgICAgICAgZm9udFNpemU6IDBcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KSlcclxuICAgIHtcclxuICAgICAgICBvdXRwdXQuYXNjZW50ID0gYmFzZWxpbmU7XHJcbiAgICAgICAgb3V0cHV0LmRlc2NlbnQgPSBiYXNlbGluZSArIDY7XHJcbiAgICAgICAgb3V0cHV0LmZvbnRTaXplID0gb3V0cHV0LmFzY2VudCArIG91dHB1dC5kZXNjZW50O1xyXG5cclxuICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xyXG4gICAgdmFyIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGg7XHJcbiAgICB2YXIgbGluZSA9IHdpZHRoICogNDtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgaWR4ID0gMDtcclxuICAgIHZhciBzdG9wID0gZmFsc2U7XHJcblxyXG4gICAgLy8gYXNjZW50LiBzY2FuIGZyb20gdG9wIHRvIGJvdHRvbSB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxyXG4gICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFzdG9wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWR4ICs9IGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvdXRwdXQuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xyXG5cclxuICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XHJcbiAgICBzdG9wID0gZmFsc2U7XHJcblxyXG4gICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyBpLS0pXHJcbiAgICB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFzdG9wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWR4IC09IGxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvdXRwdXQuZGVzY2VudCA9IChpIC0gYmFzZWxpbmUpO1xyXG4gICAgb3V0cHV0LmZvbnRTaXplID0gb3V0cHV0LmFzY2VudCArIG91dHB1dC5kZXNjZW50O1xyXG5cclxuICAgIENhbnZhc1Bvb2wucmVtb3ZlKGNhbnZhcyk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVhc3VyZVRleHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGV4dC9NZWFzdXJlVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgR2V0QWR2YW5jZWRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRBZHZhbmNlZFZhbHVlJyk7XHJcbnZhciBNZWFzdXJlVGV4dCA9IHJlcXVpcmUoJy4vTWVhc3VyZVRleHQnKTtcclxuXHJcbi8vICBLZXk6IFsgT2JqZWN0IEtleSwgRGVmYXVsdCBWYWx1ZSBdXHJcblxyXG52YXIgcHJvcGVydHlNYXAgPSB7XHJcbiAgICBmb250OiBbICdmb250JywgJzE2cHggQ291cmllcicgXSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogWyAnYmFja2dyb3VuZENvbG9yJywgbnVsbCBdLFxyXG4gICAgZmlsbDogWyAnZmlsbCcsICcjZmZmJyBdLFxyXG4gICAgc3Ryb2tlOiBbICdzdHJva2UnLCAnI2ZmZicgXSxcclxuICAgIHN0cm9rZVRoaWNrbmVzczogWyAnc3Ryb2tlVGhpY2tuZXNzJywgMCBdLFxyXG4gICAgc2hhZG93T2Zmc2V0WDogWyAnc2hhZG93Lm9mZnNldFgnLCAwIF0sXHJcbiAgICBzaGFkb3dPZmZzZXRZOiBbICdzaGFkb3cub2Zmc2V0WScsIDAgXSxcclxuICAgIHNoYWRvd0NvbG9yOiBbICdzaGFkb3cuY29sb3InLCAnIzAwMCcgXSxcclxuICAgIHNoYWRvd0JsdXI6IFsgJ3NoYWRvdy5ibHVyJywgMCBdLFxyXG4gICAgc2hhZG93U3Ryb2tlOiBbICdzaGFkb3cuc3Ryb2tlJywgZmFsc2UgXSxcclxuICAgIHNoYWRvd0ZpbGw6IFsgJ3NoYWRvdy5maWxsJywgZmFsc2UgXSxcclxuICAgIGFsaWduOiBbICdhbGlnbicsICdsZWZ0JyBdLFxyXG4gICAgbWF4TGluZXM6IFsgJ21heExpbmVzJywgMCBdLFxyXG4gICAgZml4ZWRXaWR0aDogWyAnZml4ZWRXaWR0aCcsIGZhbHNlIF0sXHJcbiAgICBmaXhlZEhlaWdodDogWyAnZml4ZWRIZWlnaHQnLCBmYWxzZSBdLFxyXG4gICAgcnRsOiBbICdydGwnLCBmYWxzZSBdXHJcbn07XHJcblxyXG52YXIgVGV4dFN0eWxlID0gbmV3IENsYXNzKHtcclxuXHJcbiAgICBpbml0aWFsaXplOlxyXG5cclxuICAgIGZ1bmN0aW9uIFRleHRTdHlsZSAodGV4dCwgc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0ZXh0O1xyXG5cclxuICAgICAgICB0aGlzLmZvbnQ7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdGhpcy5maWxsO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WDtcclxuICAgICAgICB0aGlzLnNoYWRvd09mZnNldFk7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dDb2xvcjtcclxuICAgICAgICB0aGlzLnNoYWRvd0JsdXI7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dTdHJva2U7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dGaWxsO1xyXG4gICAgICAgIHRoaXMuYWxpZ247XHJcbiAgICAgICAgdGhpcy5tYXhMaW5lcztcclxuICAgICAgICB0aGlzLmZpeGVkV2lkdGg7XHJcbiAgICAgICAgdGhpcy5maXhlZEhlaWdodDtcclxuICAgICAgICB0aGlzLnJ0bDtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0byBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHJcbiAgICAgICAgaWYgKHN0eWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnR5TWFwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBHZXRBZHZhbmNlZFZhbHVlKHN0eWxlLCBwcm9wZXJ0eU1hcFtrZXldWzBdLCB0aGlzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWV0cmljcyA9IEdldFZhbHVlKHN0eWxlLCAnbWV0cmljcycsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gIFByb3ZpZGUgb3B0aW9uYWwgVGV4dE1ldHJpY3MgaW4gdGhlIHN0eWxlIG9iamVjdCB0byBhdm9pZCB0aGUgY2FudmFzIGxvb2stdXAgLyBzY2FubmluZ1xyXG4gICAgICAgIC8vICBEb2luZyB0aGlzIGlzIHVuLWRvbmUgaWYgeW91IHRoZW4gY2hhbmdlIHRoZSBmb250IG9mIHRoaXMgVGV4dFN0eWxlIGFmdGVyIGNyZWF0aW9uXHJcbiAgICAgICAgaWYgKG1ldHJpY3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm1ldHJpY3MgPSB7XHJcbiAgICAgICAgICAgICAgICBhc2NlbnQ6IEdldFZhbHVlKG1ldHJpY3MsICdhc2NlbnQnLCAwKSxcclxuICAgICAgICAgICAgICAgIGRlc2NlbnQ6IEdldFZhbHVlKG1ldHJpY3MsICdkZXNjZW50JywgMCksXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogR2V0VmFsdWUobWV0cmljcywgJ2ZvbnRTaXplJywgMClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5tZXRyaWNzID0gTWVhc3VyZVRleHQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydHlNYXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzW2tleV0gPSBwcm9wZXJ0eU1hcFtrZXldWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHN5bmNGb250OiBmdW5jdGlvbiAoY2FudmFzLCBjb250ZXh0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLnJ0bClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5kaXIgPSAncnRsJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IHRoaXMuZm9udDtcclxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcclxuXHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xyXG5cclxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XHJcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcbiAgICB9LFxyXG5cclxuICAgIHN5bmNTaGFkb3c6IGZ1bmN0aW9uIChjb250ZXh0LCBlbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChlbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSB0aGlzLnNoYWRvd0NvbG9yO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAocmVjYWxjdWxhdGVNZXRyaWNzKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChyZWNhbGN1bGF0ZU1ldHJpY3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm1ldHJpY3MgPSBNZWFzdXJlVGV4dCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC51cGRhdGVUZXh0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnR5TWFwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gR2V0QWR2YW5jZWRWYWx1ZShzdHlsZSwgcHJvcGVydHlNYXBba2V5XVswXSwgdGhpc1trZXldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0Rm9udDogZnVuY3Rpb24gKGZvbnQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mb250ID0gZm9udDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaXhlZFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZml4ZWRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuZml4ZWRIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChjb2xvcilcclxuICAgIHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRGaWxsOiBmdW5jdGlvbiAoY29sb3IpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5maWxsID0gY29sb3I7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0cm9rZTogZnVuY3Rpb24gKGNvbG9yLCB0aGlja25lc3MpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgUmVzZXQgdGhlIHN0cm9rZSB0byB6ZXJvIChkaXNhYmxpbmcgaXQpXHJcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlVGhpY2tuZXNzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkKSB7IHRoaWNrbmVzcyA9IHRoaXMuc3Ryb2tlVGhpY2tuZXNzOyB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZVRoaWNrbmVzcyA9IHRoaWNrbmVzcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93OiBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGJsdXIsIHNoYWRvd1N0cm9rZSwgc2hhZG93RmlsbClcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7IGNvbG9yID0gJyMwMDAnOyB9XHJcbiAgICAgICAgaWYgKGJsdXIgPT09IHVuZGVmaW5lZCkgeyBibHVyID0gMDsgfVxyXG4gICAgICAgIGlmIChzaGFkb3dTdHJva2UgPT09IHVuZGVmaW5lZCkgeyBzaGFkb3dTdHJva2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChzaGFkb3dGaWxsID09PSB1bmRlZmluZWQpIHsgc2hhZG93RmlsbCA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyID0gYmx1cjtcclxuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZSA9IHNoYWRvd1N0cm9rZTtcclxuICAgICAgICB0aGlzLnNoYWRvd0ZpbGwgPSBzaGFkb3dGaWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkb3dPZmZzZXQ6IGZ1bmN0aW9uICh4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WCA9IHg7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93Q29sb3I6IGZ1bmN0aW9uIChjb2xvcilcclxuICAgIHtcclxuICAgICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkgeyBjb2xvciA9ICcjMDAwJzsgfVxyXG5cclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gY29sb3I7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0JsdXI6IGZ1bmN0aW9uIChibHVyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChibHVyID09PSB1bmRlZmluZWQpIHsgYmx1ciA9IDA7IH1cclxuXHJcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyID0gYmx1cjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U2hhZG93U3Ryb2tlOiBmdW5jdGlvbiAoZW5hYmxlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZSA9IGVuYWJsZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRvd0ZpbGw6IGZ1bmN0aW9uIChlbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2hhZG93RmlsbCA9IGVuYWJsZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEFsaWduOiBmdW5jdGlvbiAoYWxpZ24pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGFsaWduID09PSB1bmRlZmluZWQpIHsgYWxpZ24gPSAnbGVmdCc7IH1cclxuXHJcbiAgICAgICAgdGhpcy5hbGlnbiA9IGFsaWduO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRNYXhMaW5lczogZnVuY3Rpb24gKG1heClcclxuICAgIHtcclxuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHsgbWF4ID0gMDsgfVxyXG5cclxuICAgICAgICB0aGlzLm1heExpbmVzID0gbWF4O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUZXh0TWV0cmljczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXNjZW50OiBtZXRyaWNzLmFzY2VudCxcclxuICAgICAgICAgICAgZGVzY2VudDogbWV0cmljcy5kZXNjZW50LFxyXG4gICAgICAgICAgICBmb250U2l6ZTogbWV0cmljcy5mb250U2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0eU1hcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpc1trZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0cHV0Lm1ldHJpY3MgPSB0aGlzLmdldFRleHRNZXRyaWNzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dFN0eWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvVGV4dFN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRleHQgPSByZXF1aXJlKCcuL1RleHQnKTtcclxudmFyIEdldEFkdmFuY2VkVmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9vYmplY3QvR2V0QWR2YW5jZWRWYWx1ZScpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXHJcbntcclxuICAgIC8vIHN0eWxlIE9iamVjdCA9IHtcclxuICAgIC8vICAgICBmb250OiBbICdmb250JywgJzE2cHggQ291cmllcicgXSxcclxuICAgIC8vICAgICBiYWNrZ3JvdW5kQ29sb3I6IFsgJ2JhY2tncm91bmRDb2xvcicsIG51bGwgXSxcclxuICAgIC8vICAgICBmaWxsOiBbICdmaWxsJywgJyNmZmYnIF0sXHJcbiAgICAvLyAgICAgc3Ryb2tlOiBbICdzdHJva2UnLCAnI2ZmZicgXSxcclxuICAgIC8vICAgICBzdHJva2VUaGlja25lc3M6IFsgJ3N0cm9rZVRoaWNrbmVzcycsIDAgXSxcclxuICAgIC8vICAgICBzaGFkb3dPZmZzZXRYOiBbICdzaGFkb3cub2Zmc2V0WCcsIDAgXSxcclxuICAgIC8vICAgICBzaGFkb3dPZmZzZXRZOiBbICdzaGFkb3cub2Zmc2V0WScsIDAgXSxcclxuICAgIC8vICAgICBzaGFkb3dDb2xvcjogWyAnc2hhZG93LmNvbG9yJywgJyMwMDAnIF0sXHJcbiAgICAvLyAgICAgc2hhZG93Qmx1cjogWyAnc2hhZG93LmJsdXInLCAwIF0sXHJcbiAgICAvLyAgICAgc2hhZG93U3Ryb2tlOiBbICdzaGFkb3cuc3Ryb2tlJywgZmFsc2UgXSxcclxuICAgIC8vICAgICBzaGFkb3dGaWxsOiBbICdzaGFkb3cuZmlsbCcsIGZhbHNlIF0sXHJcbiAgICAvLyAgICAgYWxpZ246IFsgJ2FsaWduJywgJ2xlZnQnIF0sXHJcbiAgICAvLyAgICAgbWF4TGluZXM6IFsgJ21heExpbmVzJywgMCBdLFxyXG4gICAgLy8gICAgIGZpeGVkV2lkdGg6IFsgJ2ZpeGVkV2lkdGgnLCBmYWxzZSBdLFxyXG4gICAgLy8gICAgIGZpeGVkSGVpZ2h0OiBbICdmaXhlZEhlaWdodCcsIGZhbHNlIF0sXHJcbiAgICAvLyAgICAgcnRsOiBbICdydGwnLCBmYWxzZSBdXHJcbiAgICAvLyB9XHJcblxyXG4gICAgdmFyIGNvbnRlbnQgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3RleHQnLCAnJyk7XHJcbiAgICB2YXIgc3R5bGUgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3N0eWxlJywgbnVsbCk7XHJcblxyXG4gICAgdmFyIHRleHQgPSBuZXcgVGV4dChzdGF0ZSwgMCwgMCwgY29udGVudCwgc3R5bGUpO1xyXG5cclxuICAgIEJ1aWxkR2FtZU9iamVjdChzdGF0ZSwgdGV4dCwgY29uZmlnKTtcclxuXHJcbiAgICAvLyAgVGV4dCBzcGVjaWZpYyBjb25maWcgb3B0aW9uczpcclxuXHJcbiAgICB0ZXh0LmF1dG9Sb3VuZCA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnYXV0b1JvdW5kJywgdHJ1ZSk7XHJcbiAgICB0ZXh0LnJlc29sdXRpb24gPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ3Jlc29sdXRpb24nLCAxKTtcclxuXHJcbiAgICAvLyAgUGFkZGluZ1xyXG4gICAgLy8gIEVpdGhlcjogeyBwYWRkaW5nOiAyIH0gb3IgeyBwYWRkaW5nOiB7IHg6IDIsIHk6IDIgfX1cclxuXHJcbiAgICB2YXIgcGFkZGluZyA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAncGFkZGluZycsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpXHJcbiAgICB7XHJcbiAgICAgICAgdGV4dC5wYWRkaW5nLnggPSBwYWRkaW5nO1xyXG4gICAgICAgIHRleHQucGFkZGluZy55ID0gcGFkZGluZztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhZGRpbmcgIT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgdGV4dC5wYWRkaW5nLnggPSBHZXRBZHZhbmNlZFZhbHVlKHBhZGRpbmcsICd4JywgMSk7XHJcbiAgICAgICAgdGV4dC5wYWRkaW5nLnkgPSBHZXRBZHZhbmNlZFZhbHVlKHBhZGRpbmcsICd5JywgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGV4dC51cGRhdGVUZXh0KCk7XHJcblxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkRnJvbUNvbmZpZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9CdWlsZEZyb21Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQ0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGV4dENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XHJcblxyXG4gICAgLy8gIEJsZW5kIE1vZGVcclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFNtb290aGluZ1xyXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgIT09IHNyYy5zY2FsZU1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNhbnZhcyA9IHNyYy5jYW52YXM7XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC50cmFuc2xhdGUoc3JjLnggLSBjYW1lcmEuc2Nyb2xsWCAqIHNyYy5zY3JvbGxGYWN0b3JYLCBzcmMueSAtIGNhbWVyYS5zY3JvbGxZICogc3JjLnNjcm9sbEZhY3RvclkpO1xyXG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xyXG4gICAgY3R4LnNjYWxlKHNyYy5zY2FsZVgsIHNyYy5zY2FsZVkpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGggKiAoc3JjLmZsaXBYID8gMSA6IDApLCBjYW52YXMuaGVpZ2h0ICogKHNyYy5mbGlwWSA/IDEgOiAwKSk7XHJcbiAgICBjdHguc2NhbGUoc3JjLmZsaXBYID8gLTEgOiAxLCBzcmMuZmxpcFkgPyAtMSA6IDEpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgLXNyYy5kaXNwbGF5T3JpZ2luWCwgLXNyYy5kaXNwbGF5T3JpZ2luWSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0Q2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFRleHQgPSByZXF1aXJlKCcuL1RleHQnKTtcclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IHJlcXVpcmUoJy4vQnVpbGRGcm9tQ29uZmlnJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFRleHRGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ3RleHQnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHRleHQsIHN0eWxlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFkZChuZXcgVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCB0ZXh0LCBzdHlsZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYWtlOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBCdWlsZEZyb21Db25maWcodGhpcy5zdGF0ZSwgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoVGV4dEZhY3RvcnkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVuZGVyQ2FudmFzOiByZXF1aXJlKCcuL1RleHRDYW52YXNSZW5kZXJlcicpLFxyXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vVGV4dFdlYkdMUmVuZGVyZXInKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0UmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRleHRXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoc3JjLmRpcnR5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB3ID0gc3JjLmNhbnZhcy53aWR0aDtcclxuICAgICAgICB2YXIgaCA9IHNyYy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciByZXNpemUgPSAhKHNyYy5wcmV2V2lkdGggPCB3IHx8IHNyYy5wcmV2SGVpZ2h0IDwgaCk7XHJcblxyXG4gICAgICAgIHNyYy5jYW52YXNUZXh0dXJlID0gcmVuZGVyZXIudXBsb2FkQ2FudmFzVG9HUFUoc3JjLmNhbnZhcywgc3JjLmNhbnZhc1RleHR1cmUsIHJlc2l6ZSk7XHJcbiAgICAgICAgc3JjLnByZXZXaWR0aCA9IHc7XHJcbiAgICAgICAgc3JjLnByZXZIZWlnaHQgPSBoO1xyXG4gICAgICAgIHNyYy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLnNwcml0ZUJhdGNoLmFkZFNwcml0ZVRleHR1cmUoc3JjLCBjYW1lcmEsIHNyYy5jYW52YXNUZXh0dXJlLCBzcmMucHJldldpZHRoLCBzcmMucHJldkhlaWdodCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbGVtYXAgPSByZXF1aXJlKCcuL1RpbGVtYXAnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBCdWlsZEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9CdWlsZEdhbWVPYmplY3QnKTtcclxuXHJcbnZhciBCdWlsZEZyb21Db25maWcgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIG1hcERhdGEgPSBHZXRWYWx1ZShjb25maWcsICdtYXAuZGF0YScsIG51bGwpO1xyXG4gICAgdmFyIG1hcFdpZHRoID0gR2V0VmFsdWUoY29uZmlnLCAnbWFwLndpZHRoJywgMSk7XHJcbiAgICB2YXIgbWFwSGVpZ2h0ID0gR2V0VmFsdWUoY29uZmlnLCAnbWFwLmhlaWdodCcsIDEpO1xyXG5cclxuICAgIHZhciB4ID0gR2V0VmFsdWUoY29uZmlnLCAneCcsIDApO1xyXG4gICAgdmFyIHkgPSBHZXRWYWx1ZShjb25maWcsICd5JywgMCk7XHJcblxyXG4gICAgdmFyIHRpbGVXaWR0aCA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUud2lkdGgnLCAxNik7XHJcbiAgICB2YXIgdGlsZUhlaWdodCA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUuaGVpZ2h0JywgMTYpO1xyXG4gICAgdmFyIHRpbGVUZXh0dXJlID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS50ZXh0dXJlJywgbnVsbCk7XHJcbiAgICB2YXIgdGlsZUZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAndGlsZS5mcmFtZScsIG51bGwpO1xyXG5cclxuICAgIHZhciBtYXAgPSBuZXcgVGlsZW1hcChzdGF0ZSwgbWFwRGF0YSwgeCwgeSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBtYXBXaWR0aCwgbWFwSGVpZ2h0LCB0aWxlVGV4dHVyZSwgdGlsZUZyYW1lKTtcclxuXHJcbiAgICBCdWlsZEdhbWVPYmplY3Qoc3RhdGUsIG1hcCwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEZyb21Db25maWc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZW1hcC9keW5hbWljL0J1aWxkRnJvbUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIFRpbGUocHJvcGVydGllcylcclxue1xyXG4gICAgdGhpcy5pbmRleCA9IHByb3BlcnRpZXMuaW5kZXg7XHJcblx0dGhpcy5pZCA9IHByb3BlcnRpZXMuaWQ7XHJcblx0dGhpcy54ID0gIHByb3BlcnRpZXMueDtcclxuXHR0aGlzLnkgPSBwcm9wZXJ0aWVzLnk7XHJcblx0dGhpcy53aWR0aCA9IHByb3BlcnRpZXMud2lkdGg7XHJcblx0dGhpcy5oZWlnaHQgPSBwcm9wZXJ0aWVzLmhlaWdodDtcclxuICAgIHRoaXMuZnJhbWVYID0gcHJvcGVydGllcy5mcmFtZVg7XHJcbiAgICB0aGlzLmZyYW1lWSA9IHByb3BlcnRpZXMuZnJhbWVZO1xyXG4gICAgdGhpcy5mcmFtZVdpZHRoID0gcHJvcGVydGllcy5mcmFtZVdpZHRoO1xyXG5cdHRoaXMuZnJhbWVIZWlnaHQgPSBwcm9wZXJ0aWVzLmZyYW1lSGVpZ2h0O1xyXG4gICAgdGhpcy5hbHBoYSA9IDEuMDtcclxuXHR0aGlzLnRpbnQgPSAweEZGRkZGRjtcclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgdGhpcy50ZXh0dXJlV2lkdGggPSBwcm9wZXJ0aWVzLnRleHR1cmVXaWR0aDtcclxuICAgIHRoaXMudGV4dHVyZUhlaWdodCA9IHByb3BlcnRpZXMudGV4dHVyZUhlaWdodDtcclxufVxyXG5cclxuVGlsZS5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiAoaWQpXHJcbntcclxuICAgIHZhciB0aWxlSWQgPSB0aGlzLmlkID0gaWQ7XHJcbiAgICB2YXIgdGlsZVdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICB2YXIgc2V0V2lkdGggPSB0aGlzLnRleHR1cmVXaWR0aCAvIHRpbGVXaWR0aDtcclxuICAgIHZhciBoYWxmVGlsZVdpZHRoID0gKHRpbGVXaWR0aCkgKiAwLjU7XHJcbiAgICB2YXIgaGFsZlRpbGVIZWlnaHQgPSAodGlsZUhlaWdodCkgKiAwLjU7XHJcbiAgICB2YXIgcmVjdHggPSAoKCh0aWxlSWQgJSBzZXRXaWR0aCl8MCkgKiB0aWxlV2lkdGgpICsgaGFsZlRpbGVXaWR0aDtcclxuICAgIHZhciByZWN0eSA9ICgoKHRpbGVJZCAvIHNldFdpZHRoKXwwKSAqIHRpbGVIZWlnaHQpICsgaGFsZlRpbGVIZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5mcmFtZVggPSByZWN0eDtcclxuICAgIHRoaXMuZnJhbWVZID0gcmVjdHk7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbGVtYXBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZW1hcENhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFRpbGVtYXAgPSByZXF1aXJlKCcuL1RpbGVtYXAnKTtcclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IHJlcXVpcmUoJy4vQnVpbGRGcm9tQ29uZmlnJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFRpbGVtYXBGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ3RpbGVtYXAnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBUaWxlbWFwKHRoaXMuc3RhdGUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGV4dHVyZSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gQnVpbGRGcm9tQ29uZmlnKHRoaXMuc3RhdGUsIGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKFRpbGVtYXBGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL2R5bmFtaWMvVGlsZW1hcEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vVGlsZW1hcENhbnZhc1JlbmRlcmVyJyksXHJcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9UaWxlbWFwV2ViR0xSZW5kZXJlcicpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbGVtYXBXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBnYW1lT2JqZWN0LCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1bGwoY2FtZXJhKTtcclxuXHJcbiAgICB2YXIgcmVuZGVyVGlsZXMgPSBnYW1lT2JqZWN0LmN1bGxlZFRpbGVzO1xyXG4gICAgdmFyIGxlbmd0aCA9IHJlbmRlclRpbGVzLmxlbmd0aDtcclxuICAgIHZhciBiYXRjaCA9IHJlbmRlcmVyLnNwcml0ZUJhdGNoO1xyXG4gICAgdmFyIHRleHR1cmUgPSBnYW1lT2JqZWN0LnRleHR1cmUuc291cmNlWzBdLmdsVGV4dHVyZTtcclxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgdmFyIHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlLmhlaWdodDtcclxuICAgIHZhciByZW5kZXJUYXJnZXQgPSBnYW1lT2JqZWN0LnJlbmRlclRhcmdldDtcclxuICAgIHZhciBzY3JvbGxGYWN0b3JYID0gZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgdmFyIHNjcm9sbEZhY3RvclkgPSBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgdmFyIHggPSBnYW1lT2JqZWN0Lng7XHJcbiAgICB2YXIgeSA9IGdhbWVPYmplY3QueTtcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0aWxlID0gcmVuZGVyVGlsZXNbaW5kZXhdO1xyXG4gICAgICAgIGJhdGNoLmFkZFRpbGVUZXh0dXJlUmVjdChcclxuICAgICAgICAgICAgdGV4dHVyZSxcclxuICAgICAgICAgICAgeCArIHRpbGUueCwgeSArIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQsIGFscGhhICogdGlsZS5hbHBoYSwgdGlsZS50aW50LFxyXG4gICAgICAgICAgICBzY3JvbGxGYWN0b3JYLCBzY3JvbGxGYWN0b3JZLFxyXG4gICAgICAgICAgICB0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHQsXHJcbiAgICAgICAgICAgIHRpbGUuZnJhbWVYLCB0aWxlLmZyYW1lWSwgdGlsZS5mcmFtZVdpZHRoLCB0aWxlLmZyYW1lSGVpZ2h0LFxyXG4gICAgICAgICAgICBjYW1lcmEsXHJcbiAgICAgICAgICAgIHJlbmRlclRhcmdldFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVtYXBXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvZHluYW1pYy9UaWxlbWFwV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGF0aWNUaWxlbWFwID0gcmVxdWlyZSgnLi9TdGF0aWNUaWxlbWFwJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG52YXIgQnVpbGRHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vQnVpbGRHYW1lT2JqZWN0Jyk7XHJcblxyXG52YXIgQnVpbGRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXHJcbntcclxuICAgIHZhciBtYXBEYXRhID0gR2V0VmFsdWUoY29uZmlnLCAnbWFwLmRhdGEnLCBudWxsKTtcclxuICAgIHZhciBtYXBXaWR0aCA9IEdldFZhbHVlKGNvbmZpZywgJ21hcC53aWR0aCcsIDEpO1xyXG4gICAgdmFyIG1hcEhlaWdodCA9IEdldFZhbHVlKGNvbmZpZywgJ21hcC5oZWlnaHQnLCAxKTtcclxuXHJcbiAgICB2YXIgeCA9IEdldFZhbHVlKGNvbmZpZywgJ3gnLCAwKTtcclxuICAgIHZhciB5ID0gR2V0VmFsdWUoY29uZmlnLCAneScsIDApO1xyXG5cclxuICAgIHZhciB0aWxlV2lkdGggPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLndpZHRoJywgMTYpO1xyXG4gICAgdmFyIHRpbGVIZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICd0aWxlLmhlaWdodCcsIDE2KTtcclxuICAgIHZhciB0aWxlVGV4dHVyZSA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUudGV4dHVyZScsIG51bGwpO1xyXG4gICAgdmFyIHRpbGVGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ3RpbGUuZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICB2YXIgbWFwID0gbmV3IFN0YXRpY1RpbGVtYXAoc3RhdGUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGlsZVRleHR1cmUsIHRpbGVGcmFtZSk7XHJcblxyXG4gICAgQnVpbGRHYW1lT2JqZWN0KHN0YXRlLCBtYXAsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIG1hcDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQnVpbGRGcm9tQ29uZmlnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVtYXAvc3RhdGljL0J1aWxkRnJvbUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGF0aWNUaWxlbWFwQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxue1xyXG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRpY1RpbGVtYXBDYW52YXNSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFN0YXRpY1RpbGVtYXAgPSByZXF1aXJlKCcuL1N0YXRpY1RpbGVtYXAnKTtcclxudmFyIEJ1aWxkRnJvbUNvbmZpZyA9IHJlcXVpcmUoJy4vQnVpbGRGcm9tQ29uZmlnJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFN0YXRpY1RpbGVtYXBGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ3N0YXRpY1RpbGVtYXAnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGV4dHVyZSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBTdGF0aWNUaWxlbWFwKHRoaXMuc3RhdGUsIG1hcERhdGEsIHgsIHksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgbWFwV2lkdGgsIG1hcEhlaWdodCwgdGV4dHVyZSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gQnVpbGRGcm9tQ29uZmlnKHRoaXMuc3RhdGUsIGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKFN0YXRpY1RpbGVtYXBGYWN0b3J5KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9TdGF0aWNUaWxlbWFwQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL1N0YXRpY1RpbGVtYXBXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZW1hcC9zdGF0aWMvU3RhdGljVGlsZW1hcFJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxyXG57XHJcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ2FtZU9iamVjdCA9IHNyYztcclxuICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICB2YXIgZ2wgPSBnYW1lT2JqZWN0LmdsO1xyXG5cclxuICAgIHJlbmRlcmVyLnNldFJlbmRlcmVyKGdhbWVPYmplY3QudGlsZW1hcFJlbmRlcmVyLCBmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLCBnYW1lT2JqZWN0LnJlbmRlclRhcmdldCk7XHJcbiAgICBnYW1lT2JqZWN0LnRpbGVtYXBSZW5kZXJlci5iaW5kKCk7XHJcbiAgICBnYW1lT2JqZWN0LnVwbG9hZChjYW1lcmEpO1xyXG4gICAgLy9nYW1lT2JqZWN0LmN1bGwoY2FtZXJhKTtcclxuICAgIGdhbWVPYmplY3QudmJvLmJpbmQoKTtcclxuXHJcbiAgICAvL3ZhciB2ZXJ0ZXhDb3VudCA9IGdhbWVPYmplY3QuY3VsbEVuZCAtIGdhbWVPYmplY3QuY3VsbFN0YXJ0O1xyXG4gICAgLy9pZiAodmVydGV4Q291bnQgPiAwKVxyXG4gICAgLy97XHJcbiAgICAvLyAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgZ2FtZU9iamVjdC5jdWxsU3RhcnQsIHZlcnRleENvdW50KTtcclxuICAgIC8vfVxyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGdhbWVPYmplY3QudmVydGV4Q291bnQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nYW1lb2JqZWN0cy90aWxlbWFwL3N0YXRpYy9TdGF0aWNUaWxlbWFwV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgVGlsZVNwcml0ZUNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdHggPSByZW5kZXJlci5jdXJyZW50Q29udGV4dDtcclxuICAgIHZhciBmcmFtZSA9IHNyYy5mcmFtZTtcclxuXHJcbiAgICAvLyAgQmxlbmQgTW9kZVxyXG5cclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBbHBoYVxyXG5cclxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuXHJcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcclxuICAgIHtcclxuICAgICAgICByZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlID0gc3JjLnNjYWxlTW9kZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHggPSBmcmFtZS54IC0gKHNyYy5vcmlnaW5YICogc3JjLndpZHRoKTtcclxuICAgIHZhciBkeSA9IGZyYW1lLnkgLSAoc3JjLm9yaWdpblkgKiBzcmMuaGVpZ2h0KTtcclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShkeCwgZHkpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShzcmMueCAtIGNhbWVyYS5zY3JvbGxYICogc3JjLnNjcm9sbEZhY3RvclgsIHNyYy55IC0gY2FtZXJhLnNjcm9sbFkgKiBzcmMuc2Nyb2xsRmFjdG9yWSk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gc3JjLmNhbnZhc1BhdHRlcm47XHJcbiAgICBjdHgudHJhbnNsYXRlKC10aGlzLnRpbGVQb3NpdGlvblgsIC10aGlzLnRpbGVQb3NpdGlvblkpO1xyXG4gICAgY3R4LmZpbGxSZWN0KHRoaXMudGlsZVBvc2l0aW9uWCwgdGhpcy50aWxlUG9zaXRpb25ZLCBzcmMud2lkdGgsIHNyYy5oZWlnaHQpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVNwcml0ZUNhbnZhc1JlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZUNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBUaWxlU3ByaXRlID0gcmVxdWlyZSgnLi9UaWxlU3ByaXRlJyk7XHJcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xyXG5cclxudmFyIFRpbGVTcHJpdGVGYWN0b3J5ID0ge1xyXG5cclxuICAgIEtFWTogJ3RpbGVTcHJpdGUnLFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKG5ldyBUaWxlU3ByaXRlKHRoaXMuc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhbWUpKTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlU3ByaXRlKHRoaXMuc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGtleSwgZnJhbWUpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihUaWxlU3ByaXRlRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9UaWxlU3ByaXRlQ2FudmFzUmVuZGVyZXInKSxcclxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL1RpbGVTcHJpdGVXZWJHTFJlbmRlcmVyJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvdGlsZXNwcml0ZS9UaWxlU3ByaXRlUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRpbGVTcHJpdGVXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbntcclxuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3JjLnVwZGF0ZVRpbGVUZXh0dXJlKCk7XHJcbiAgICByZW5kZXJlci50aWxlQmF0Y2guYWRkVGlsZVNwcml0ZShzcmMsIGNhbWVyYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVTcHJpdGVXZWJHTFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbWVvYmplY3RzL3RpbGVzcHJpdGUvVGlsZVNwcml0ZVdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgWm9uZSA9IHJlcXVpcmUoJy4vWm9uZScpO1xyXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uL0ZhY3RvcnlDb250YWluZXInKTtcclxuXHJcbnZhciBab25lRmFjdG9yeSA9IHtcclxuXHJcbiAgICBLRVk6ICd6b25lJyxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9uZSh0aGlzLnN0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab25lKHRoaXMuc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3Rlcihab25lRmFjdG9yeSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FtZW9iamVjdHMvem9uZS9ab25lRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGNpcmNsZSlcclxue1xyXG4gICAgcmV0dXJuIChjaXJjbGUucmFkaXVzID4gMCkgPyBNYXRoLlBJICogY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMgOiAwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY3VtZmVyZW5jZSA9IGZ1bmN0aW9uIChjaXJjbGUpXHJcbntcclxuICAgIHJldHVybiAyICogKE1hdGguUEkgKiBjaXJjbGUucmFkaXVzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUmV0dXJucyBhIFBvaW50IG9iamVjdCBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBDaXJjbGUgYmFzZWQgb24gdGhlIGdpdmVuIGFuZ2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZS5jaXJjdW1mZXJlbmNlUG9pbnRcclxuKiBAcGFyYW0ge1BoYXNlci5DaXJjbGV9IGEgLSBUaGUgZmlyc3QgQ2lyY2xlIG9iamVjdC5cclxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucyB0byByZXR1cm4gdGhlIHBvaW50IGZyb20uXHJcbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR9IFtvdXRdIC0gQW4gb3B0aW9uYWwgUG9pbnQgb2JqZWN0IHRvIHB1dCB0aGUgcmVzdWx0IGluIHRvLiBJZiBub25lIHNwZWNpZmllZCBhIG5ldyBQb2ludCBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkLlxyXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gVGhlIFBvaW50IG9iamVjdCBob2xkaW5nIHRoZSByZXN1bHQuXHJcbiovXHJcbnZhciBDaXJjdW1mZXJlbmNlUG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICBvdXQueCA9IGNpcmNsZS54ICsgKGNpcmNsZS5yYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgb3V0LnkgPSBjaXJjbGUueSArIChjaXJjbGUucmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1mZXJlbmNlUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZVBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY2xlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IENpcmNsZShzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS5yYWRpdXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhjaXJjbGUsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNSZWN0ID0gZnVuY3Rpb24gKGNpcmNsZSwgcmVjdClcclxue1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGNpcmNsZSwgcmVjdC5yaWdodCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGNpcmNsZSwgcmVjdC54LCByZWN0LmJvdHRvbSkgJiZcclxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXHJcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxyXG4qL1xyXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxyXG57XHJcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS5yYWRpdXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAoY2lyY2xlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgY2lyY2xlLnggPT09IHRvQ29tcGFyZS54ICYmXHJcbiAgICAgICAgY2lyY2xlLnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gNDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0Qm91bmRzID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgb3V0LnggPSBjaXJjbGUubGVmdDtcclxuICAgIG91dC55ID0gY2lyY2xlLnRvcDtcclxuICAgIG91dC53aWR0aCA9IGNpcmNsZS5kaWFtZXRlcjtcclxuICAgIG91dC5oZWlnaHQgPSBjaXJjbGUuZGlhbWV0ZXI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoY2lyY2xlLCB4LCB5KVxyXG57XHJcbiAgICBjaXJjbGUueCArPSB4O1xyXG4gICAgY2lyY2xlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gY2lyY2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9jaXJjbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgcG9pbnQpXHJcbntcclxuICAgIGNpcmNsZS54ICs9IHBvaW50Lng7XHJcbiAgICBjaXJjbGUueSArPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkNpcmNsZVxyXG5cclxudmFyIENpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY2xlJyk7XHJcblxyXG5DaXJjbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5DaXJjbGUuQ2lyY3VtZmVyZW5jZSA9IHJlcXVpcmUoJy4vQ2lyY3VtZmVyZW5jZScpO1xyXG5DaXJjbGUuQ2lyY3VtZmVyZW5jZVBvaW50ID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlUG9pbnQnKTtcclxuQ2lyY2xlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5DaXJjbGUuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcbkNpcmNsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XHJcbkNpcmNsZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xyXG5DaXJjbGUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkNpcmNsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5DaXJjbGUuR2V0Qm91bmRzID0gcmVxdWlyZSgnLi9HZXRCb3VuZHMnKTtcclxuQ2lyY2xlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcbkNpcmNsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcclxuQ2lyY2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2NpcmNsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGVsbGlwc2UpXHJcbntcclxuICAgIGlmIChlbGxpcHNlLmlzRW1wdHkoKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgdW5pdHMgc3F1YXJlZFxyXG4gICAgcmV0dXJuIChlbGxpcHNlLmdldE1ham9yUmFkaXVzKCkgKiBlbGxpcHNlLmdldE1pbm9yUmFkaXVzKCkgKiBNYXRoLlBJKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gNDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IEVsbGlwc2Uoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcblxyXG52YXIgQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcclxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxyXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtFbGxpcHNlfSBUaGlzIENpcmNsZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgZWxsaXBzZS54ID09PSB0b0NvbXBhcmUueCAmJlxyXG4gICAgICAgIGVsbGlwc2UueSA9PT0gdG9Db21wYXJlLnkgJiZcclxuICAgICAgICBlbGxpcHNlLndpZHRoID09PSB0b0NvbXBhcmUud2lkdGggJiZcclxuICAgICAgICBlbGxpcHNlLmhlaWdodCA9PT0gdG9Db21wYXJlLmhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIEdldEJvdW5kcyA9IGZ1bmN0aW9uIChlbGxpcHNlLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICBvdXQueCA9IGVsbGlwc2UueCAtIGVsbGlwc2Uud2lkdGg7XHJcbiAgICBvdXQueSA9IGVsbGlwc2UueSAtIGVsbGlwc2UuaGVpZ2h0O1xyXG4gICAgb3V0LndpZHRoID0gZWxsaXBzZS53aWR0aDtcclxuICAgIG91dC5oZWlnaHQgPSBlbGxpcHNlLmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRCb3VuZHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gNDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcclxue1xyXG4gICAgZWxsaXBzZS54ICs9IHg7XHJcbiAgICBlbGxpcHNlLnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gZWxsaXBzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgcG9pbnQpXHJcbntcclxuICAgIGVsbGlwc2UueCArPSBwb2ludC54O1xyXG4gICAgZWxsaXBzZS55ICs9IHBvaW50Lnk7XHJcblxyXG4gICAgcmV0dXJuIGVsbGlwc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vZWxsaXBzZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5FbGxpcHNlXHJcblxyXG52YXIgRWxsaXBzZSA9IHJlcXVpcmUoJy4vRWxsaXBzZScpO1xyXG5cclxuRWxsaXBzZS5BcmVhID0gcmVxdWlyZSgnLi9BcmVhJyk7XHJcbkVsbGlwc2UuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcbkVsbGlwc2UuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XHJcbkVsbGlwc2UuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xyXG5FbGxpcHNlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XHJcbkVsbGlwc2UuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkVsbGlwc2UuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuRWxsaXBzZS5HZXRCb3VuZHMgPSByZXF1aXJlKCcuL0dldEJvdW5kcycpO1xyXG5FbGxpcHNlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcbkVsbGlwc2UuT2Zmc2V0UG9pbnQgPSByZXF1aXJlKCcuL09mZnNldFBvaW50Jyk7XHJcbkVsbGlwc2UuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2VsbGlwc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzdGFuY2VCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4nKTtcclxuXHJcbnZhciBDaXJjbGVUb0NpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKVxyXG57XHJcbiAgICByZXR1cm4gKERpc3RhbmNlQmV0d2VlbihjaXJjbGVBLngsIGNpcmNsZUEueSwgY2lyY2xlQi54LCBjaXJjbGVCLnkpIDw9IChjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZVRvQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXJjbGVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXHJcbntcclxuICAgIHZhciBoYWxmV2lkdGggPSByZWN0LndpZHRoIC8gMjtcclxuICAgIHZhciBoYWxmSGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgIHZhciBjeCA9IE1hdGguYWJzKGNpcmNsZS54IC0gcmVjdC54IC0gaGFsZldpZHRoKTtcclxuICAgIHZhciB4RGlzdCA9IGhhbGZXaWR0aCArIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgaWYgKGN4IDw9IGhhbGZXaWR0aCB8fCBjeCA+IHhEaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3kgPSBNYXRoLmFicyhjaXJjbGUueSAtIHJlY3QueSAtIGhhbGZIZWlnaHQpO1xyXG4gICAgdmFyIHlEaXN0ID0gaGFsZkhlaWdodCArIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgaWYgKGN5IDw9IGhhbGZIZWlnaHQgfHwgY3kgPiB5RGlzdClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhDb3JuZXJEaXN0ID0gY3ggLSBoYWxmV2lkdGg7XHJcbiAgICB2YXIgeUNvcm5lckRpc3QgPSBjeSAtIGhhbGZIZWlnaHQ7XHJcbiAgICB2YXIgeENvcm5lckRpc3RTcSA9IHhDb3JuZXJEaXN0ICogeENvcm5lckRpc3Q7XHJcbiAgICB2YXIgeUNvcm5lckRpc3RTcSA9IHlDb3JuZXJEaXN0ICogeUNvcm5lckRpc3Q7XHJcbiAgICB2YXIgbWF4Q29ybmVyRGlzdFNxID0gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXM7XHJcblxyXG4gICAgcmV0dXJuICh4Q29ybmVyRGlzdFNxICsgeUNvcm5lckRpc3RTcSA8PSBtYXhDb3JuZXJEaXN0U3EpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVUb1JlY3RhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xyXG52YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZVRvUmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gbmV3IFJlY3RhbmdsZSgpOyB9XHJcblxyXG4gICAgaWYgKFJlY3RhbmdsZVRvUmVjdGFuZ2xlKHJlY3RBLCByZWN0QikpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnggPSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcclxuICAgICAgICBvdXRwdXQueSA9IE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xyXG4gICAgICAgIG91dHB1dC53aWR0aCA9IE1hdGgubWluKHJlY3RBLnJpZ2h0LCByZWN0Qi5yaWdodCkgLSBvdXRwdXQueDtcclxuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0gTWF0aC5taW4ocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0gb3V0cHV0Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDaGVja3MgZm9yIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBMaW5lIGFuZCBhIFJlY3RhbmdsZSBzaGFwZSwgb3IgYSByZWN0YW5nbGUtbGlrZVxyXG4qIG9iamVjdCwgd2l0aCBwdWJsaWMgYHhgLCBgeWAsIGByaWdodGAgYW5kIGBib3R0b21gIHByb3BlcnRpZXMsIHN1Y2ggYXMgYSBTcHJpdGUgb3IgQm9keS5cclxuKlxyXG4qIEFuIGludGVyc2VjdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkIGlmOlxyXG4qXHJcbiogVGhlIGxpbmUgc3RhcnRzIHdpdGhpbiwgb3IgZW5kcyB3aXRoaW4sIHRoZSBSZWN0YW5nbGUuXHJcbiogVGhlIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgNCByZWN0YW5nbGUgZWRnZXMuXHJcbipcclxuKiBUaGUgZm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGZ1bmN0aW9uIHJlY3RhbmdsZXMgYXJlIGNvbnNpZGVyZWQgJ3NvbGlkJy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUuaW50ZXJzZWN0c1JlY3RhbmdsZVxyXG4qIEBwYXJhbSB7UGhhc2VyLkxpbmV9IGxpbmUgLSBUaGUgbGluZSB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGguXHJcbiogQHBhcmFtIHtQaGFzZXIuUmVjdGFuZ2xlfG9iamVjdH0gcmVjdCAtIFRoZSByZWN0YW5nbGUsIG9yIHJlY3RhbmdsZS1saWtlIG9iamVjdCwgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGxpbmUgaW50ZXJzZWN0cyB3aXRoIHRoZSByZWN0YW5nbGUgZWRnZXMsIG9yIHN0YXJ0cyBvciBlbmRzIHdpdGhpbiB0aGUgcmVjdGFuZ2xlLlxyXG4qL1xyXG52YXIgTGluZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxpbmUsIHJlY3QpXHJcbntcclxuICAgIHZhciB4MSA9IGxpbmUueDE7XHJcbiAgICB2YXIgeTEgPSBsaW5lLnkyO1xyXG5cclxuICAgIHZhciB4MiA9IGxpbmUueDI7XHJcbiAgICB2YXIgeTIgPSBsaW5lLnkyO1xyXG5cclxuICAgIHZhciBieDEgPSByZWN0Lng7XHJcbiAgICB2YXIgYnkxID0gcmVjdC55O1xyXG4gICAgdmFyIGJ4MiA9IHJlY3QucmlnaHQ7XHJcbiAgICB2YXIgYnkyID0gcmVjdC5ib3R0b207XHJcblxyXG4gICAgdmFyIHQgPSAwO1xyXG5cclxuICAgIC8vICBJZiB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBsaW5lIGlzIGluc2lkZSB0aGUgcmVjdCB0aGVuIHdlIGFzc3VtZVxyXG4gICAgLy8gIGNvbGxpc2lvbiwgYXMgcmVjdHMgYXJlIHNvbGlkIGZvciBvdXIgdXNlLWNhc2UuXHJcblxyXG4gICAgaWYgKCh4MSA+PSBieDEgJiYgeDEgPD0gYngyICYmIHkxID49IGJ5MSAmJiB5MSA8PSBieTIpIHx8XHJcbiAgICAgICAgKHgyID49IGJ4MSAmJiB4MiA8PSBieDIgJiYgeTIgPj0gYnkxICYmIHkyIDw9IGJ5MikpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHgxIDwgYngxICYmIHgyID49IGJ4MSlcclxuICAgIHtcclxuICAgICAgICAvLyAgTGVmdCBlZGdlXHJcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MSAtIHgxKSAvICh4MiAtIHgxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPiBieTEgJiYgdCA8PSBieTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh4MSA+IGJ4MiAmJiB4MiA8PSBieDIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJpZ2h0IGVkZ2VcclxuICAgICAgICB0ID0geTEgKyAoeTIgLSB5MSkgKiAoYngyIC0geDEpIC8gKHgyIC0geDEpO1xyXG5cclxuICAgICAgICBpZiAodCA+PSBieTEgJiYgdCA8PSBieTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHkxIDwgYnkxICYmIHkyID49IGJ5MSlcclxuICAgIHtcclxuICAgICAgICAvLyAgVG9wIGVkZ2VcclxuICAgICAgICB0ID0geDEgKyAoeDIgLSB4MSkgKiAoYnkxIC0geTEpIC8gKHkyIC0geTEpO1xyXG5cclxuICAgICAgICBpZiAodCA+PSBieDEgJiYgdCA8PSBieDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh5MSA+IGJ5MiAmJiB5MiA8PSBieTIpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEJvdHRvbSBlZGdlXHJcbiAgICAgICAgdCA9IHgxICsgKHgyIC0geDEpICogKGJ5MiAtIHkxKSAvICh5MiAtIHkxKTtcclxuXHJcbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZVRvUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnRUb0xpbmUgPSByZXF1aXJlKCcuL1BvaW50VG9MaW5lJyk7XHJcblxyXG52YXIgUG9pbnRUb0xpbmVTZWdtZW50ID0gZnVuY3Rpb24gKHBvaW50LCBsaW5lKVxyXG57XHJcbiAgICBpZiAoIVBvaW50VG9MaW5lKHBvaW50LCBsaW5lKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhNaW4gPSBNYXRoLm1pbihsaW5lLngxLCBsaW5lLngyKTtcclxuICAgIHZhciB4TWF4ID0gTWF0aC5tYXgobGluZS54MSwgbGluZS54Mik7XHJcbiAgICB2YXIgeU1pbiA9IE1hdGgubWluKGxpbmUueTEsIGxpbmUueTIpO1xyXG4gICAgdmFyIHlNYXggPSBNYXRoLm1heChsaW5lLnkxLCBsaW5lLnkyKTtcclxuXHJcbiAgICByZXR1cm4gKChwb2ludC54ID49IHhNaW4gJiYgcG9pbnQueCA8PSB4TWF4KSAmJiAocG9pbnQueSA+PSB5TWluICYmIHBvaW50LnkgPD0geU1heCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFRvTGluZVNlZ21lbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgTGluZVRvTGluZSA9IHJlcXVpcmUoJy4vTGluZVRvTGluZScpO1xyXG52YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvQ29udGFpbnMnKTtcclxudmFyIENvbnRhaW5zQXJyYXkgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWluc0FycmF5Jyk7XHJcbnZhciBEZWNvbXBvc2UgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvRGVjb21wb3NlJyk7XHJcblxyXG52YXIgUmVjdGFuZ2xlVG9UcmlhbmdsZSA9IGZ1bmN0aW9uIChyZWN0LCB0cmlhbmdsZSlcclxue1xyXG4gICAgLy8gIEZpcnN0IHRoZSBjaGVhcGVzdCBvbmVzOlxyXG5cclxuICAgIGlmIChcclxuICAgICAgICB0cmlhbmdsZS5sZWZ0ID4gcmVjdC5yaWdodCB8fFxyXG4gICAgICAgIHRyaWFuZ2xlLnJpZ2h0IDwgcmVjdC5sZWZ0IHx8XHJcbiAgICAgICAgdHJpYW5nbGUudG9wID4gcmVjdC5ib3R0b20gfHxcclxuICAgICAgICB0cmlhbmdsZS5ib3R0b20gPCByZWN0LnRvcClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRyaUEgPSB0cmlhbmdsZS5nZXRMaW5lQSgpO1xyXG4gICAgdmFyIHRyaUIgPSB0cmlhbmdsZS5nZXRMaW5lQigpO1xyXG4gICAgdmFyIHRyaUMgPSB0cmlhbmdsZS5nZXRMaW5lQygpO1xyXG5cclxuICAgIC8vICBBcmUgYW55IG9mIHRoZSB0cmlhbmdsZSBwb2ludHMgd2l0aGluIHRoZSByZWN0YW5nbGU/XHJcblxyXG4gICAgaWYgKENvbnRhaW5zKHJlY3QsIHRyaUEueDEsIHRyaUEueTEpIHx8IENvbnRhaW5zKHJlY3QsIHRyaUEueDIsIHRyaUEueTIpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDb250YWlucyhyZWN0LCB0cmlCLngxLCB0cmlCLnkxKSB8fCBDb250YWlucyhyZWN0LCB0cmlCLngyLCB0cmlCLnkyKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ29udGFpbnMocmVjdCwgdHJpQy54MSwgdHJpQy55MSkgfHwgQ29udGFpbnMocmVjdCwgdHJpQy54MiwgdHJpQy55MikpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIENoZWFwIHRlc3RzIG92ZXIsIG5vdyB0byBzZWUgaWYgYW55IG9mIHRoZSBsaW5lcyBpbnRlcnNlY3QgLi4uXHJcblxyXG4gICAgdmFyIHJlY3RBID0gcmVjdC5nZXRMaW5lQSgpO1xyXG4gICAgdmFyIHJlY3RCID0gcmVjdC5nZXRMaW5lQigpO1xyXG4gICAgdmFyIHJlY3RDID0gcmVjdC5nZXRMaW5lQygpO1xyXG4gICAgdmFyIHJlY3REID0gcmVjdC5nZXRMaW5lRCgpO1xyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKHRyaUEsIHJlY3RBKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3RCKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3RDKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3REKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTGluZVRvTGluZSh0cmlCLCByZWN0QSkgfHwgTGluZVRvTGluZSh0cmlCLCByZWN0QikgfHwgTGluZVRvTGluZSh0cmlCLCByZWN0QykgfHwgTGluZVRvTGluZSh0cmlCLCByZWN0RCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0xpbmUodHJpQywgcmVjdEEpIHx8IExpbmVUb0xpbmUodHJpQywgcmVjdEIpIHx8IExpbmVUb0xpbmUodHJpQywgcmVjdEMpIHx8IExpbmVUb0xpbmUodHJpQywgcmVjdEQpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBOb25lIG9mIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHNvIGFyZSBhbnkgcmVjdGFuZ2xlIHBvaW50cyB3aXRoaW4gdGhlIHRyaWFuZ2xlP1xyXG5cclxuICAgIHZhciBwb2ludHMgPSBEZWNvbXBvc2UocmVjdCk7XHJcbiAgICB2YXIgd2l0aGluID0gQ29udGFpbnNBcnJheSh0cmlhbmdsZSwgcG9pbnRzLCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gKHdpdGhpbi5sZW5ndGggPiAwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlVG9UcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGVUb1ZhbHVlcyA9IGZ1bmN0aW9uIChyZWN0LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRvbGVyYW5jZSlcclxue1xyXG4gICAgaWYgKHRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkKSB7IHRvbGVyYW5jZSA9IDA7IH1cclxuXHJcbiAgICByZXR1cm4gIShcclxuICAgICAgICBsZWZ0ID4gcmVjdC5yaWdodCArIHRvbGVyYW5jZSB8fFxyXG4gICAgICAgIHJpZ2h0IDwgcmVjdC5sZWZ0IC0gdG9sZXJhbmNlIHx8XHJcbiAgICAgICAgdG9wID4gcmVjdC5ib3R0b20gKyB0b2xlcmFuY2UgfHxcclxuICAgICAgICBib3R0b20gPCByZWN0LnRvcCAtIHRvbGVyYW5jZVxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlVG9WYWx1ZXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBMaW5lVG9DaXJjbGUgPSByZXF1aXJlKCcuL0xpbmVUb0NpcmNsZScpO1xyXG52YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWlucycpO1xyXG5cclxudmFyIFRyaWFuZ2xlVG9DaXJjbGUgPSBmdW5jdGlvbiAodHJpYW5nbGUsIGNpcmNsZSlcclxue1xyXG4gICAgIC8vICBGaXJzdCB0aGUgY2hlYXBlc3Qgb25lczpcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICAgdHJpYW5nbGUubGVmdCA+IGNpcmNsZS5yaWdodCB8fFxyXG4gICAgICAgIHRyaWFuZ2xlLnJpZ2h0IDwgY2lyY2xlLmxlZnQgfHxcclxuICAgICAgICB0cmlhbmdsZS50b3AgPiBjaXJjbGUuYm90dG9tIHx8XHJcbiAgICAgICAgdHJpYW5nbGUuYm90dG9tIDwgY2lyY2xlLnRvcClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKENvbnRhaW5zKHRyaWFuZ2xlLCBjaXJjbGUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9DaXJjbGUodHJpYW5nbGUuZ2V0TGluZUEoKSwgY2lyY2xlKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTGluZVRvQ2lyY2xlKHRyaWFuZ2xlLmdldExpbmVCKCksIGNpcmNsZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0NpcmNsZSh0cmlhbmdsZS5nZXRMaW5lQygpLCBjaXJjbGUpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGVUb0NpcmNsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgTGluZVRvTGluZSA9IHJlcXVpcmUoJy4vTGluZVRvTGluZScpO1xyXG52YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWlucycpO1xyXG5cclxudmFyIFRyaWFuZ2xlVG9MaW5lID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBsaW5lKVxyXG57XHJcbiAgICAvLyAgSWYgdGhlIFRyaWFuZ2xlIGNvbnRhaW5zIGVpdGhlciB0aGUgc3RhcnQgb3IgZW5kIHBvaW50IG9mIHRoZSBsaW5lLCBpdCBpbnRlcnNlY3RzXHJcbiAgICBpZiAoQ29udGFpbnModHJpYW5nbGUsIGxpbmUuZ2V0UG9pbnRBKCkpIHx8IENvbnRhaW5zKHRyaWFuZ2xlLCBsaW5lLmdldFBvaW50QigpKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTm93IGNoZWNrIHRoZSBsaW5lIGFnYWluc3QgZWFjaCBsaW5lIG9mIHRoZSBUcmlhbmdsZVxyXG4gICAgaWYgKExpbmVUb0xpbmUodHJpYW5nbGUuZ2V0TGluZUEoKSwgbGluZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0xpbmUodHJpYW5nbGUuZ2V0TGluZUIoKSwgbGluZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0xpbmUodHJpYW5nbGUuZ2V0TGluZUMoKSwgbGluZSkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZVRvTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2ludGVyc2VjdHMvVHJpYW5nbGVUb0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIExpbmVUb0xpbmUgPSByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKTtcclxudmFyIENvbnRhaW5zQXJyYXkgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWluc0FycmF5Jyk7XHJcbnZhciBEZWNvbXBvc2UgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9EZWNvbXBvc2UnKTtcclxuXHJcbnZhciBUcmlhbmdsZVRvVHJpYW5nbGUgPSBmdW5jdGlvbiAodHJpYW5nbGVBLCB0cmlhbmdsZUIpXHJcbntcclxuICAgIC8vICBGaXJzdCB0aGUgY2hlYXBlc3Qgb25lczpcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICAgdHJpYW5nbGVBLmxlZnQgPiB0cmlhbmdsZUIucmlnaHQgfHxcclxuICAgICAgICB0cmlhbmdsZUEucmlnaHQgPCB0cmlhbmdsZUIubGVmdCB8fFxyXG4gICAgICAgIHRyaWFuZ2xlQS50b3AgPiB0cmlhbmdsZUIuYm90dG9tIHx8XHJcbiAgICAgICAgdHJpYW5nbGVBLmJvdHRvbSA8IHRyaWFuZ2xlQi50b3ApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaW5lQUEgPSB0cmlhbmdsZUEuZ2V0TGluZUEoKTtcclxuICAgIHZhciBsaW5lQUIgPSB0cmlhbmdsZUEuZ2V0TGluZUIoKTtcclxuICAgIHZhciBsaW5lQUMgPSB0cmlhbmdsZUEuZ2V0TGluZUMoKTtcclxuXHJcbiAgICB2YXIgbGluZUJBID0gdHJpYW5nbGVCLmdldExpbmVBKCk7XHJcbiAgICB2YXIgbGluZUJCID0gdHJpYW5nbGVCLmdldExpbmVCKCk7XHJcbiAgICB2YXIgbGluZUJDID0gdHJpYW5nbGVCLmdldExpbmVDKCk7XHJcblxyXG4gICAgLy8gIE5vdyBjaGVjayB0aGUgbGluZXMgYWdhaW5zdCBlYWNoIGxpbmUgb2YgVHJpYW5nbGVCXHJcbiAgICBpZiAoTGluZVRvTGluZShsaW5lQUEsIGxpbmVCQSkgfHwgTGluZVRvTGluZShsaW5lQUEsIGxpbmVCQikgfHwgTGluZVRvTGluZShsaW5lQUEsIGxpbmVCQykpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkEpIHx8IExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkIpIHx8IExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkMpKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChMaW5lVG9MaW5lKGxpbmVBQywgbGluZUJBKSB8fCBMaW5lVG9MaW5lKGxpbmVBQywgbGluZUJCKSB8fCBMaW5lVG9MaW5lKGxpbmVBQywgbGluZUJDKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTm9wZSwgc28gY2hlY2sgdG8gc2VlIGlmIGFueSBvZiB0aGUgcG9pbnRzIG9mIHRyaWFuZ2xlQSBhcmUgd2l0aGluIHRyaWFuZ2xlQlxyXG5cclxuICAgIHZhciBwb2ludHMgPSBEZWNvbXBvc2UodHJpYW5nbGVBKTtcclxuICAgIHZhciB3aXRoaW4gPSBDb250YWluc0FycmF5KHRyaWFuZ2xlQiwgcG9pbnRzLCB0cnVlKTtcclxuXHJcbiAgICBpZiAod2l0aGluLmxlbmd0aCA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEZpbmFsbHkgY2hlY2sgdG8gc2VlIGlmIGFueSBvZiB0aGUgcG9pbnRzIG9mIHRyaWFuZ2xlQiBhcmUgd2l0aGluIHRyaWFuZ2xlQVxyXG5cclxuICAgIHBvaW50cyA9IERlY29tcG9zZSh0cmlhbmdsZUIpO1xyXG4gICAgd2l0aGluID0gQ29udGFpbnNBcnJheSh0cmlhbmdsZUEsIHBvaW50cywgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKHdpdGhpbi5sZW5ndGggPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGVUb1RyaWFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvVHJpYW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uSW50ZXJzZWN0c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2lyY2xlVG9DaXJjbGU6IHJlcXVpcmUoJy4vQ2lyY2xlVG9DaXJjbGUnKSxcclxuICAgIENpcmNsZVRvUmVjdGFuZ2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvUmVjdGFuZ2xlJyksXHJcbiAgICBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb246IHJlcXVpcmUoJy4vR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uJyksXHJcbiAgICBMaW5lVG9DaXJjbGU6IHJlcXVpcmUoJy4vTGluZVRvQ2lyY2xlJyksXHJcbiAgICBMaW5lVG9MaW5lOiByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKSxcclxuICAgIExpbmVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9MaW5lVG9SZWN0YW5nbGUnKSxcclxuICAgIFBvaW50VG9MaW5lOiByZXF1aXJlKCcuL1BvaW50VG9MaW5lJyksXHJcbiAgICBQb2ludFRvTGluZVNlZ21lbnQ6IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmVTZWdtZW50JyksXHJcbiAgICBSZWN0YW5nbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1JlY3RhbmdsZScpLFxyXG4gICAgUmVjdGFuZ2xlVG9UcmlhbmdsZTogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1RyaWFuZ2xlJyksXHJcbiAgICBSZWN0YW5nbGVUb1ZhbHVlczogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1ZhbHVlcycpLFxyXG4gICAgVHJpYW5nbGVUb0NpcmNsZTogcmVxdWlyZSgnLi9UcmlhbmdsZVRvQ2lyY2xlJyksXHJcbiAgICBUcmlhbmdsZVRvTGluZTogcmVxdWlyZSgnLi9UcmlhbmdsZVRvTGluZScpLFxyXG4gICAgVHJpYW5nbGVUb1RyaWFuZ2xlOiByZXF1aXJlKCcuL1RyaWFuZ2xlVG9UcmlhbmdsZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ2VudGVyT24gPSBmdW5jdGlvbiAobGluZSwgeCwgeSlcclxue1xyXG4gICAgdmFyIHR4ID0geCAtICgobGluZS54MSArIGxpbmUueDIpIC8gMik7XHJcbiAgICB2YXIgdHkgPSB5IC0gKChsaW5lLnkxICsgbGluZS55MikgLyAyKTtcclxuXHJcbiAgICBsaW5lLngxICs9IHR4O1xyXG4gICAgbGluZS55MSArPSB0eTtcclxuXHJcbiAgICBsaW5lLngyICs9IHR4O1xyXG4gICAgbGluZS55MiArPSB0eTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcclxuXHJcbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXHJcbntcclxuICAgIHJldHVybiBuZXcgTGluZShzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgTGluZS5cclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lI2NvcHlGcm9tXHJcbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxyXG4qIEByZXR1cm4ge0xpbmV9IFRoaXMgTGluZSBvYmplY3QuXHJcbiovXHJcbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXHJcbntcclxuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54MSwgc291cmNlLnkxLCBzb3VyY2UueDIsIHNvdXJjZS55Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAobGluZSwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGxpbmUueDEgPT09IHRvQ29tcGFyZS54MSAmJlxyXG4gICAgICAgIGxpbmUueTEgPT09IHRvQ29tcGFyZS55MSAmJlxyXG4gICAgICAgIGxpbmUueDIgPT09IHRvQ29tcGFyZS54MiAmJlxyXG4gICAgICAgIGxpbmUueTIgPT09IHRvQ29tcGFyZS55MlxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDUwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xyXG5cclxudmFyIEdldE1pZFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgb3V0LnggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcclxuICAgIG91dC55ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWlkUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XHJcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcclxuXHJcbnZhciBHZXROb3JtYWwgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cclxuXHJcbiAgICB2YXIgYSA9IEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVU7XHJcblxyXG4gICAgb3V0LnggPSBNYXRoLmNvcyhhKTtcclxuICAgIG91dC55ID0gTWF0aC5zaW4oYSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0Tm9ybWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9HZXROb3JtYWwuanNcbi8vIG1vZHVsZSBpZCA9IDUwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSGVpZ2h0ID0gZnVuY3Rpb24gKGxpbmUpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhsaW5lLnkxIC0gbGluZS55Mik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvSGVpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlbmd0aCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChsaW5lLngyIC0gbGluZS54MSkgKiAobGluZS54MiAtIGxpbmUueDEpICsgKGxpbmUueTIgLSBsaW5lLnkxKSAqIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMZW5ndGg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcblxyXG52YXIgTm9ybWFsWCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5jb3MoQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbFg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL05vcm1hbFguanNcbi8vIG1vZHVsZSBpZCA9IDUwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcclxudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xyXG5cclxudmFyIE5vcm1hbFkgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIE1hdGguc2luKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9Ob3JtYWxZLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldCA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5KVxyXG57XHJcbiAgICBsaW5lLngxICs9IHg7XHJcbiAgICBsaW5lLnkxICs9IHk7XHJcblxyXG4gICAgbGluZS54MiArPSB4O1xyXG4gICAgbGluZS55MiArPSB5O1xyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gNTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcclxue1xyXG4gICAgcmV0dXJuIC0oKGxpbmUueDIgLSBsaW5lLngxKSAvIChsaW5lLnkyIC0gbGluZS55MSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwU2xvcGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gNTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcclxudmFyIE5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5cclxuLyoqXHJcbiogUmV0dXJucyB0aGUgcmVmbGVjdGVkIGFuZ2xlIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLnJlZmxlY3RcclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBhIC0gVGhlIGJhc2UgbGluZS5cclxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBiIC0gVGhlIGxpbmUgdG8gYmUgcmVmbGVjdGVkIGZyb20gdGhlIGJhc2UgbGluZS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWZsZWN0ZWQgYW5nbGUgaW4gcmFkaWFucy5cclxuKi9cclxudmFyIFJlZmxlY3RBbmdsZSA9IGZ1bmN0aW9uIChsaW5lQSwgbGluZUIpXHJcbntcclxuICAgIHJldHVybiAoMiAqIE5vcm1hbEFuZ2xlKGxpbmVCKSAtIE1hdGguUEkgLSBBbmdsZShsaW5lQSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0QW5nbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGUgPSBmdW5jdGlvbiAobGluZSwgYW5nbGUpXHJcbntcclxuICAgIHZhciB4ID0gKGxpbmUueDEgKyBsaW5lLngyKSAvIDI7XHJcbiAgICB2YXIgeSA9IChsaW5lLnkxICsgbGluZS55MikgLyAyO1xyXG5cclxuICAgIHJldHVybiBSb3RhdGVBcm91bmRYWShsaW5lLCB4LCB5LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5cclxudmFyIFJvdGF0ZUFyb3VuZFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIHBvaW50LCBhbmdsZSlcclxue1xyXG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKGxpbmUsIHBvaW50LngsIHBvaW50LnksIGFuZ2xlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9saW5lL1JvdGF0ZUFyb3VuZFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFRvQW5nbGUgPSBmdW5jdGlvbiAobGluZSwgeCwgeSwgYW5nbGUsIGxlbmd0aClcclxue1xyXG4gICAgbGluZS54MSA9IHg7XHJcbiAgICBsaW5lLnkxID0geTtcclxuXHJcbiAgICBsaW5lLngyID0geCArIChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgpO1xyXG4gICAgbGluZS55MiA9IHkgKyAoTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gbGluZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0VG9BbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvU2V0VG9BbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbG9wZSA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gKGxpbmUueTIgLSBsaW5lLnkxKSAvIChsaW5lLngyIC0gbGluZS54MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNsb3BlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vbGluZS9TbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gNTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXaWR0aCA9IGZ1bmN0aW9uIChsaW5lKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobGluZS54MSAtIGxpbmUueDIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXaWR0aDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvV2lkdGguanNcbi8vIG1vZHVsZSBpZCA9IDUxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLkdlb20uTGluZVxyXG5cclxudmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcclxuXHJcbkxpbmUuQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XHJcbkxpbmUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XHJcbkxpbmUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcbkxpbmUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcbkxpbmUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcclxuTGluZS5HZXRNaWRQb2ludCA9IHJlcXVpcmUoJy4vR2V0TWlkUG9pbnQnKTtcclxuTGluZS5HZXROb3JtYWwgPSByZXF1aXJlKCcuL0dldE5vcm1hbCcpO1xyXG5MaW5lLkdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRzT25MaW5lJyk7XHJcbkxpbmUuSGVpZ2h0ID0gcmVxdWlyZSgnLi9IZWlnaHQnKTtcclxuTGluZS5MZW5ndGggPSByZXF1aXJlKCcuL0xlbmd0aCcpO1xyXG5MaW5lLk5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xyXG5MaW5lLk5vcm1hbFggPSByZXF1aXJlKCcuL05vcm1hbFgnKTtcclxuTGluZS5Ob3JtYWxZID0gcmVxdWlyZSgnLi9Ob3JtYWxZJyk7XHJcbkxpbmUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuTGluZS5QZXJwU2xvcGUgPSByZXF1aXJlKCcuL1BlcnBTbG9wZScpO1xyXG5MaW5lLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XHJcbkxpbmUuUmVmbGVjdEFuZ2xlID0gcmVxdWlyZSgnLi9SZWZsZWN0QW5nbGUnKTtcclxuTGluZS5Sb3RhdGUgPSByZXF1aXJlKCcuL1JvdGF0ZScpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFBvaW50ID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRQb2ludCcpO1xyXG5MaW5lLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5MaW5lLlNldFRvQW5nbGUgPSByZXF1aXJlKCcuL1NldFRvQW5nbGUnKTtcclxuTGluZS5TbG9wZSA9IHJlcXVpcmUoJy4vU2xvcGUnKTtcclxuTGluZS5XaWR0aCA9IHJlcXVpcmUoJy4vV2lkdGgnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL2xpbmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQWRkID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxyXG57XHJcbiAgICBwb2ludC54ICs9IHg7XHJcbiAgICBwb2ludC55ICs9IHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9BZGQuanNcbi8vIG1vZHVsZSBpZCA9IDUxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguY2VpbChwb2ludC54KSwgTWF0aC5jZWlsKHBvaW50LnkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDUxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxyXG57XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHNvdXJjZS54LCBzb3VyY2UueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDUxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcm9zcyA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qilcclxue1xyXG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueSkgLSAocG9pbnRBLnkgKiBwb2ludEIueCkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcm9zcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0Nyb3NzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpdmlkZSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAvPSB4O1xyXG4gICAgcG9pbnQueSAvPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGl2aWRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvRGl2aWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChwb2ludCwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKHBvaW50LnggPT09IHRvQ29tcGFyZS54ICYmIHBvaW50LnkgPT09IHRvQ29tcGFyZS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oTWF0aC5mbG9vcihwb2ludC54KSwgTWF0aC5mbG9vcihwb2ludC55KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDUyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgR2V0Q2VudHJvaWQgPSBmdW5jdGlvbiAocG9pbnRzLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0Q2VudHJvaWQgcG9pbnRzIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXknKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcnJheSBtdXN0IG5vdCBiZSBlbXB0eScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVuID09PSAxKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gcG9pbnRzWzBdLng7XHJcbiAgICAgICAgb3V0LnkgPSBwb2ludHNbMF0ueTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0LnggKz0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgIG91dC55ICs9IHBvaW50c1tpXS55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3V0LnggLz0gbGVuO1xyXG4gICAgICAgIG91dC55IC89IGxlbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50cm9pZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxudmFyIEludGVycG9sYXRlID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCB0LCBvdXQpXHJcbntcclxuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIG91dC54ID0gcG9pbnRBLnggKyAoKHBvaW50Qi54IC0gcG9pbnRBLngpICogdCk7XHJcbiAgICBvdXQueSA9IHBvaW50QS55ICsgKChwb2ludEIueSAtIHBvaW50QS55KSAqIHQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVycG9sYXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvSW50ZXJwb2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIEludmVydCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnZlcnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDUyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgTmVnYXRpdmUgPSBmdW5jdGlvbiAocG9pbnQsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L05lZ2F0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA1Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZVJpZ2h0SGFuZCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnkgKiAtMSwgcG9pbnQueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZVJpZ2h0SGFuZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qc1xuLy8gbW9kdWxlIGlkID0gNTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gNTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcbnZhciBHZXRNYWduaXR1ZGVTcSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlU3EnKTtcclxuXHJcbnZhciBQcm9qZWN0ID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxyXG5cclxuICAgIHZhciBhbXQgPSBEb3QocG9pbnRBLCBwb2ludEIpIC8gR2V0TWFnbml0dWRlU3EocG9pbnRCKTtcclxuXHJcbiAgICBpZiAoYW10ICE9PSAwKVxyXG4gICAge1xyXG4gICAgICAgIG91dC54ID0gYW10ICogcG9pbnRCLng7XHJcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9pbnQvUHJvamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XHJcblxyXG52YXIgUHJvamVjdFVuaXQgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XHJcblxyXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50Qik7XHJcblxyXG4gICAgaWYgKGFtdCAhPT0gMClcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IGFtdCAqIHBvaW50Qi54O1xyXG4gICAgICAgIG91dC55ID0gYW10ICogcG9pbnRCLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdFVuaXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gNTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSUGVycCA9IGZ1bmN0aW9uIChwb2ludClcclxue1xyXG4gICAgcmV0dXJuIHBvaW50LnNldFRvKHBvaW50LnksIC1wb2ludC54KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUlBlcnA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9SUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gNTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG52YXIgTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblxyXG52YXIgU2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50LCBtYWduaXR1ZGUpXHJcbntcclxuICAgIE5vcm1hbGl6ZShwb2ludCk7XHJcblxyXG4gICAgcmV0dXJuIE11bHRpcGx5KHBvaW50LCBtYWduaXR1ZGUsIG1hZ25pdHVkZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldE1hZ25pdHVkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gNTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdWJ0cmFjdCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcclxue1xyXG4gICAgcG9pbnQueCAtPSB4O1xyXG4gICAgcG9pbnQueSAtPSB5O1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VidHJhY3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxyXG5cclxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9Qb2ludCcpO1xyXG5cclxuUG9pbnQuQWRkID0gcmVxdWlyZSgnLi9BZGQnKTtcclxuUG9pbnQuQ2VpbCA9IHJlcXVpcmUoJy4vQ2VpbCcpO1xyXG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcclxuUG9pbnQuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XHJcblBvaW50LkNyb3NzID0gcmVxdWlyZSgnLi9Dcm9zcycpO1xyXG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xyXG5Qb2ludC5Eb3QgPSByZXF1aXJlKCcuL0RvdCcpO1xyXG5Qb2ludC5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcclxuUG9pbnQuR2V0Q2VudHJvaWQgPSByZXF1aXJlKCcuL0dldENlbnRyb2lkJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vR2V0TWFnbml0dWRlJyk7XHJcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xyXG5Qb2ludC5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcclxuUG9pbnQuSW52ZXJ0ID0gcmVxdWlyZSgnLi9JbnZlcnQnKTtcclxuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XHJcblBvaW50Lk5lZ2F0aXZlID0gcmVxdWlyZSgnLi9OZWdhdGl2ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xyXG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xyXG5Qb2ludC5QZXJwID0gcmVxdWlyZSgnLi9QZXJwJyk7XHJcblBvaW50LlByb2plY3QgPSByZXF1aXJlKCcuL1Byb2plY3QnKTtcclxuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XHJcblBvaW50LlJQZXJwID0gcmVxdWlyZSgnLi9SUGVycCcpO1xyXG5Qb2ludC5TZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL1NldE1hZ25pdHVkZScpO1xyXG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2ludC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XHJcblxyXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAocG9seWdvbilcclxue1xyXG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvbHlnb24ucG9pbnRzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA1MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5cclxuLyoqXHJcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNjb250YWluc1xyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cclxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb24sIG90aGVyd2lzZSBmYWxzZS5cclxuKi9cclxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXHJcbntcclxuICAgIHJldHVybiBDb250YWlucyhwb2x5Z29uLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICAyLjEuMSAoTWFyIDE3LCAyMDE2KVxyXG5cclxuLypcclxuSVNDIExpY2Vuc2VcclxuXHJcbkNvcHlyaWdodCAoYykgMjAxNiwgTWFwYm94XHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZVxyXG53aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlXHJcbmFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXHJcbkZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TU1xyXG5PRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVJcclxuVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRlxyXG5USElTIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xyXG5cclxuLypcclxudmVydGljZXMgaXMgYSBmbGF0IGFycmF5IG9mIHZlcnRpY2UgY29vcmRpbmF0ZXMgbGlrZSBbeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uXS5cclxuaG9sZXMgaXMgYW4gYXJyYXkgb2YgaG9sZSBpbmRpY2VzIGlmIGFueSAoZS5nLiBbNSwgOF0gZm9yIGEgMTItdmVydGljZSBpbnB1dCB3b3VsZCBtZWFuIG9uZSBob2xlIHdpdGggdmVydGljZXMgNeKAkzcgYW5kIGFub3RoZXIgd2l0aCA44oCTMTEpLlxyXG5kaW1lbnNpb25zIGlzIHRoZSBudW1iZXIgb2YgY29vcmRpbmF0ZXMgcGVyIHZlcnRpY2UgaW4gdGhlIGlucHV0IGFycmF5ICgyIGJ5IGRlZmF1bHQpLlxyXG5FYWNoIGdyb3VwIG9mIHRocmVlIHZlcnRpY2UgaW5kaWNlcyBpbiB0aGUgcmVzdWx0aW5nIGFycmF5IGZvcm1zIGEgdHJpYW5nbGUuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcclxuXHJcbiAgICBkaW0gPSBkaW0gfHwgMjtcclxuXHJcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXHJcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcclxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoIW91dGVyTm9kZSkgcmV0dXJuIHRyaWFuZ2xlcztcclxuXHJcbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZTtcclxuXHJcbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XHJcblxyXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xyXG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcclxuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcclxuICAgICAgICAgICAgeCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcclxuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcclxuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcclxuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICB9XHJcblxyXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG5cclxuICAgIHJldHVybiB0cmlhbmdsZXM7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XHJcbiAgICB2YXIgaSwgbGFzdDtcclxuXHJcbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XHJcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcclxuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXN0O1xyXG59XHJcblxyXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xyXG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xyXG5cclxuICAgIHZhciBwID0gc3RhcnQsXHJcbiAgICAgICAgYWdhaW47XHJcbiAgICBkbyB7XHJcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xyXG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XHJcblxyXG4gICAgcmV0dXJuIGVuZDtcclxufVxyXG5cclxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXHJcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCBwYXNzKSB7XHJcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xyXG5cclxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XHJcblxyXG4gICAgdmFyIHN0b3AgPSBlYXIsXHJcbiAgICAgICAgcHJldiwgbmV4dDtcclxuXHJcbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcclxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcclxuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XHJcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xyXG5cclxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XHJcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcclxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcclxuXHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcclxuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcclxuXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWFyID0gbmV4dDtcclxuXHJcbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcclxuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XHJcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXHJcbiAgICAgICAgICAgIGlmICghcGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XHJcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XHJcblxyXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xyXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcclxuICAgIHZhciBhID0gZWFyLnByZXYsXHJcbiAgICAgICAgYiA9IGVhcixcclxuICAgICAgICBjID0gZWFyLm5leHQ7XHJcblxyXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXHJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XHJcblxyXG4gICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XHJcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkge1xyXG4gICAgdmFyIGEgPSBlYXIucHJldixcclxuICAgICAgICBiID0gZWFyLFxyXG4gICAgICAgIGMgPSBlYXIubmV4dDtcclxuXHJcbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXHJcblxyXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcclxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXHJcbiAgICAgICAgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLFxyXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcclxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XHJcblxyXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXHJcbiAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xyXG5cclxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxyXG4gICAgdmFyIHAgPSBlYXIubmV4dFo7XHJcblxyXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcclxuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxyXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcCA9IHAubmV4dFo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXHJcbiAgICBwID0gZWFyLnByZXZaO1xyXG5cclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XHJcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHAgPSBwLnByZXZaO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xyXG4gICAgdmFyIHAgPSBzdGFydDtcclxuICAgIGRvIHtcclxuICAgICAgICB2YXIgYSA9IHAucHJldixcclxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xyXG5cclxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XHJcblxyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XHJcblxyXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xyXG5cclxuICAgIHJldHVybiBwO1xyXG59XHJcblxyXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxyXG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpIHtcclxuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXHJcbiAgICB2YXIgYSA9IHN0YXJ0O1xyXG4gICAgZG8ge1xyXG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xyXG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xyXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXHJcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gYi5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBhID0gYS5uZXh0O1xyXG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xyXG59XHJcblxyXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXHJcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xyXG4gICAgdmFyIHF1ZXVlID0gW10sXHJcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcclxuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XHJcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XHJcblxyXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcclxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XHJcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRlck5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcclxuICAgIHJldHVybiBhLnggLSBiLng7XHJcbn1cclxuXHJcbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxyXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcclxuICAgIGlmIChvdXRlck5vZGUpIHtcclxuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xyXG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXHJcbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXHJcbiAgICAgICAgaHggPSBob2xlLngsXHJcbiAgICAgICAgaHkgPSBob2xlLnksXHJcbiAgICAgICAgcXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgbTtcclxuXHJcbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XHJcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XHJcbiAgICBkbyB7XHJcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xyXG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcclxuICAgICAgICAgICAgICAgIHF4ID0geDtcclxuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcclxuXHJcbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XHJcblxyXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xyXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XHJcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuICAgIHZhciBzdG9wID0gbSxcclxuICAgICAgICBteCA9IG0ueCxcclxuICAgICAgICBteSA9IG0ueSxcclxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcclxuICAgICAgICB0YW47XHJcblxyXG4gICAgcCA9IG0ubmV4dDtcclxuXHJcbiAgICB3aGlsZSAocCAhPT0gc3RvcCkge1xyXG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcclxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcclxuXHJcbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcclxuXHJcbiAgICAgICAgICAgIGlmICgodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLngpKSAmJiBsb2NhbGx5SW5zaWRlKHAsIGhvbGUpKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gcDtcclxuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbTtcclxufVxyXG5cclxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XHJcbiAgICB2YXIgcCA9IHN0YXJ0O1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XHJcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcclxuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XHJcblxyXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XHJcbiAgICBwLnByZXZaID0gbnVsbDtcclxuXHJcbiAgICBzb3J0TGlua2VkKHApO1xyXG59XHJcblxyXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxyXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxyXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcclxuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcclxuICAgICAgICBpblNpemUgPSAxO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgICBwID0gbGlzdDtcclxuICAgICAgICBsaXN0ID0gbnVsbDtcclxuICAgICAgICB0YWlsID0gbnVsbDtcclxuICAgICAgICBudW1NZXJnZXMgPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICBudW1NZXJnZXMrKztcclxuICAgICAgICAgICAgcSA9IHA7XHJcbiAgICAgICAgICAgIHBTaXplID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xyXG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcclxuXHJcbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcclxuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwID0gcTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xyXG4gICAgICAgIGluU2l6ZSAqPSAyO1xyXG5cclxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xyXG5cclxuICAgIHJldHVybiBsaXN0O1xyXG59XHJcblxyXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBzaXplIG9mIHRoZSBkYXRhIGJvdW5kaW5nIGJveFxyXG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xyXG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxyXG4gICAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAvIHNpemU7XHJcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcclxuXHJcbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xyXG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcclxuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XHJcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xyXG5cclxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XHJcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xyXG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcclxuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XHJcblxyXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcclxufVxyXG5cclxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xyXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xyXG4gICAgdmFyIHAgPSBzdGFydCxcclxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54KSBsZWZ0bW9zdCA9IHA7XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcclxuXHJcbiAgICByZXR1cm4gbGVmdG1vc3Q7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcclxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xyXG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXHJcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcclxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXHJcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxyXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYik7XHJcbn1cclxuXHJcbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcclxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XHJcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcclxuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcclxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xyXG4gICAgaWYgKChlcXVhbHMocDEsIHExKSAmJiBlcXVhbHMocDIsIHEyKSkgfHxcclxuICAgICAgICAoZXF1YWxzKHAxLCBxMikgJiYgZXF1YWxzKHAyLCBxMSkpKSByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcclxuICAgICAgICAgICBhcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gYXJlYShwMiwgcTIsIHExKSA+IDA7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXHJcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcclxuICAgIHZhciBwID0gYTtcclxuICAgIGRvIHtcclxuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxyXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcclxuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xyXG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcclxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxyXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xyXG4gICAgdmFyIHAgPSBhLFxyXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxyXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxyXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xyXG4gICAgZG8ge1xyXG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXHJcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxyXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcclxuXHJcbiAgICByZXR1cm4gaW5zaWRlO1xyXG59XHJcblxyXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XHJcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xyXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xyXG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXHJcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcclxuICAgICAgICBhbiA9IGEubmV4dCxcclxuICAgICAgICBicCA9IGIucHJldjtcclxuXHJcbiAgICBhLm5leHQgPSBiO1xyXG4gICAgYi5wcmV2ID0gYTtcclxuXHJcbiAgICBhMi5uZXh0ID0gYW47XHJcbiAgICBhbi5wcmV2ID0gYTI7XHJcblxyXG4gICAgYjIubmV4dCA9IGEyO1xyXG4gICAgYTIucHJldiA9IGIyO1xyXG5cclxuICAgIGJwLm5leHQgPSBiMjtcclxuICAgIGIyLnByZXYgPSBicDtcclxuXHJcbiAgICByZXR1cm4gYjI7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXHJcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xyXG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcclxuXHJcbiAgICBpZiAoIWxhc3QpIHtcclxuICAgICAgICBwLnByZXYgPSBwO1xyXG4gICAgICAgIHAubmV4dCA9IHA7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XHJcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcclxuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XHJcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcclxuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xyXG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XHJcblxyXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xyXG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xyXG59XHJcblxyXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcclxuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcclxuICAgIHRoaXMuaSA9IGk7XHJcblxyXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXHJcbiAgICB0aGlzLnByZXYgPSBudWxsO1xyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuXHJcbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXHJcbiAgICB0aGlzLnogPSBudWxsO1xyXG5cclxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcclxuICAgIHRoaXMucHJldlogPSBudWxsO1xyXG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XHJcblxyXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcclxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xyXG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXHJcbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XHJcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XHJcbiAgICBpZiAoaGFzSG9sZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XHJcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xyXG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcclxuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxyXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cclxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcclxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XHJcbiAgICB2YXIgc3VtID0gMDtcclxuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcclxuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcclxuICAgICAgICBqID0gaTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW07XHJcbn1cclxuXHJcbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xyXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXHJcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxyXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcclxuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL0VhcmN1dC5qc1xuLy8gbW9kdWxlIGlkID0gNTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgR2V0QUFCQiA9IGZ1bmN0aW9uIChwb2x5Z29uKVxyXG57XHJcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhYID0gLW1pblg7XHJcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xyXG4gICAgdmFyIHA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBwID0gcG9seWdvbi5wb2ludHNbaV07XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwLnkpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogbWluWCxcclxuICAgICAgICB5OiBtaW5ZLFxyXG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcG9seWdvbi9HZXRBQUJCLmpzXG4vLyBtb2R1bGUgaWQgPSA1Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEV4cG9ydCB0aGUgcG9pbnRzIGFzIGFuIGFycmF5IG9mIGZsYXQgbnVtYmVycywgZm9sbG93aW5nIHRoZSBzZXF1ZW5jZSBbIHgseSwgeCx5LCB4LHkgXVxyXG4gKlxyXG4gKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI3RvTnVtYmVyQXJyYXlcclxuICogQHBhcmFtIHthcnJheX0gW291dHB1dF0gLSBUaGUgYXJyYXkgdG8gYXBwZW5kIHRoZSBwb2ludHMgdG8uIElmIG5vdCBzcGVjaWZpZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxyXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIGZsYXR0ZW5lZCBhcnJheS5cclxuICovXHJcbnZhciBHZXROdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChwb2x5Z29uLCBvdXRwdXQpXHJcbntcclxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBbXTsgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gocG9seWdvbi5wb2ludHNbaV0ueCk7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gocG9seWdvbi5wb2ludHNbaV0ueSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TnVtYmVyQXJyYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLlBvbHlnb25cclxuXHJcbnZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XHJcblxyXG5Qb2x5Z29uLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5Qb2x5Z29uLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xyXG5Qb2x5Z29uLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuUG9seWdvbi5HZXRBQUJCID0gcmVxdWlyZSgnLi9HZXRBQUJCJyk7XHJcblBvbHlnb24uR2V0TnVtYmVyQXJyYXkgPSByZXF1aXJlKCcuL0dldE51bWJlckFycmF5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmV0dXJuIHJlY3Qud2lkdGggKiByZWN0LmhlaWdodDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWwgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5jZWlsKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmNlaWwocmVjdC55KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VpbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9DZWlsLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWxBbGwgPSBmdW5jdGlvbiAocmVjdClcclxue1xyXG4gICAgcmVjdC54ID0gTWF0aC5jZWlsKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmNlaWwocmVjdC55KTtcclxuICAgIHJlY3Qud2lkdGggPSBNYXRoLmNlaWwocmVjdC53aWR0aCk7XHJcbiAgICByZWN0LmhlaWdodCA9IE1hdGguY2VpbChyZWN0LmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxBbGw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvQ2VpbEFsbC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENlbnRlcnMgdGhpcyBSZWN0YW5nbGUgc28gdGhhdCB0aGUgY2VudGVyIGNvb3JkaW5hdGVzIG1hdGNoIHRoZSBnaXZlbiB4IGFuZCB5IHZhbHVlcy5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJlY3RhbmdsZSNjZW50ZXJPblxyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBjZW50ZXIgb2YgdGhlIFJlY3RhbmdsZSBhdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUmVjdGFuZ2xlfSBUaGlzIFJlY3RhbmdsZSBvYmplY3RcclxuKi9cclxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgcmVjdC55ID0geSAtIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9DZW50ZXJPbi5qc1xuLy8gbW9kdWxlIGlkID0gNTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHJlY3QsIHBvaW50KVxyXG57XHJcbiAgICByZXR1cm4gQ29udGFpbnMocmVjdCwgcG9pbnQueCwgcG9pbnQueSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDaGVja3MgaWYgcmVjdEIgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiByZWN0QVxyXG5cclxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXHJcbntcclxuICAgIC8vICBWb2x1bWUgY2hlY2sgKGlmIHJlY3RCIHZvbHVtZSA+IHJlY3RBIHRoZW4gcmVjdEEgY2Fubm90IGNvbnRhaW4gaXQpXHJcbiAgICBpZiAoKHJlY3RCLndpZHRoICogcmVjdEIuaGVpZ2h0KSA+IChyZWN0QS53aWR0aCAqIHJlY3RBLmhlaWdodCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHJlY3RCLnggPiByZWN0QS54ICYmIHJlY3RCLnggPCByZWN0QS5yaWdodCkgJiZcclxuICAgICAgICAocmVjdEIucmlnaHQgPiByZWN0QS54ICYmIHJlY3RCLnJpZ2h0IDwgcmVjdEEucmlnaHQpICYmXHJcbiAgICAgICAgKHJlY3RCLnkgPiByZWN0QS55ICYmIHJlY3RCLnkgPCByZWN0QS5ib3R0b20pICYmIFxyXG4gICAgICAgIChyZWN0Qi5ib3R0b20gPiByZWN0QS55ICYmIHJlY3RCLmJvdHRvbSA8IHJlY3RBLmJvdHRvbSlcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxyXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocmVjdCwgdG9Db21wYXJlKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHJlY3QueCA9PT0gdG9Db21wYXJlLnggJiZcclxuICAgICAgICByZWN0LnkgPT09IHRvQ29tcGFyZS55ICYmXHJcbiAgICAgICAgcmVjdC53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXHJcbiAgICAgICAgcmVjdC5oZWlnaHQgPT09IHRvQ29tcGFyZS5oZWlnaHRcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XHJcblxyXG4vLyAgRml0cyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSBpbnRvIHRoZSBzb3VyY2UgcmVjdGFuZ2xlLlxyXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpby5cclxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG5cclxudmFyIEZpdEluc2lkZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcclxue1xyXG4gICAgdmFyIHJhdGlvID0gR2V0QXNwZWN0UmF0aW8odGFyZ2V0KTtcclxuXHJcbiAgICBpZiAocmF0aW8gPCBHZXRBc3BlY3RSYXRpbyhzb3VyY2UpKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUYWxsZXIgdGhhbiBXaWRlXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgV2lkZXIgdGhhbiBUYWxsXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLndpZHRoLCBzb3VyY2Uud2lkdGggKiByYXRpbyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldC5zZXRQb3NpdGlvbihcclxuICAgICAgICAoc291cmNlLnJpZ2h0IC8gMikgLSAodGFyZ2V0LndpZHRoIC8gMiksXHJcbiAgICAgICAgKHNvdXJjZS5ib3R0b20gLyAyKSAtICh0YXJnZXQuaGVpZ2h0IC8gMilcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpdEluc2lkZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XHJcblxyXG4vLyAgRml0cyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSBhcm91bmQgdGhlIHNvdXJjZSByZWN0YW5nbGUuXHJcbi8vICBQcmVzZXJ2ZXMgYXNwZWN0IHJhdGlvbi5cclxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG5cclxudmFyIEZpdE91dHNpZGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XHJcblxyXG4gICAgaWYgKHJhdGlvID4gR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcclxuICAgIHtcclxuICAgICAgICAvLyAgV2lkZXIgdGhhbiBUYWxsXHJcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyAgVGFsbGVyIHRoYW4gV2lkZVxyXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS53aWR0aCwgc291cmNlLndpZHRoICogcmF0aW8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQuc2V0UG9zaXRpb24oXHJcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gdGFyZ2V0LndpZHRoIC8gMixcclxuICAgICAgICAoc291cmNlLmJvdHRvbSAvIDIpIC0gdGFyZ2V0LmhlaWdodCAvIDJcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpdE91dHNpZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qc1xuLy8gbW9kdWxlIGlkID0gNTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChyZWN0KVxyXG57XHJcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XHJcbiAgICByZWN0LnkgPSBNYXRoLmZsb29yKHJlY3QueSk7XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yQWxsID0gZnVuY3Rpb24gKHJlY3QpXHJcbntcclxuICAgIHJlY3QueCA9IE1hdGguZmxvb3IocmVjdC54KTtcclxuICAgIHJlY3QueSA9IE1hdGguZmxvb3IocmVjdC55KTtcclxuICAgIHJlY3Qud2lkdGggPSBNYXRoLmZsb29yKHJlY3Qud2lkdGgpO1xyXG4gICAgcmVjdC5oZWlnaHQgPSBNYXRoLmZsb29yKHJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvb3JBbGw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvRmxvb3JBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDU1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIGNlbnRlciBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxyXG5cclxudmFyIEdldENlbnRlciA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXHJcbntcclxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC5yaWdodCAvIDI7XHJcbiAgICBvdXQueSA9IHJlY3QuYm90dG9tIC8gMjtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvR2V0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRoZSBzaXplIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0LCBleHByZXNzZWQgYXMgYSBQb2ludCBvYmplY3QgXHJcbi8vICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cclxuXHJcbnZhciBHZXRTaXplID0gZnVuY3Rpb24gKHJlY3QsIG91dClcclxue1xyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgb3V0LnggPSByZWN0LndpZHRoO1xyXG4gICAgb3V0LnkgPSByZWN0LmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRTaXplO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL0dldFNpemUuanNcbi8vIG1vZHVsZSBpZCA9IDU1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0IGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cclxuLy8gIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3Qgc3RheXMgdGhlIHNhbWUsIGFuZCBpdHMgc2l6ZSBpbmNyZWFzZXMgXHJcbi8vICB0byB0aGUgbGVmdCBhbmQgcmlnaHQgYnkgdGhlIHggdmFsdWUsIGFuZCB0byB0aGUgdG9wIGFuZCB0aGUgYm90dG9tIGJ5IHRoZSB5IHZhbHVlLlxyXG5cclxudmFyIEluZmxhdGUgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgLy8gIEdldCB0aGUgY3VycmVudCBjZW50ZXJcclxuICAgIHZhciBjeCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICB2YXIgY3kgPSByZWN0LnkgKyAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyAgSW5mbGF0ZVxyXG4gICAgcmVjdC53aWR0aCA9IDIgKiB4O1xyXG4gICAgcmVjdC5oZWlnaHQgPSAyICogeTtcclxuXHJcbiAgICByZWN0LnggPSB4IC0gKHJlY3Qud2lkdGggLyAyKTtcclxuICAgIHJlY3QueSA9IHkgLSAocmVjdC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5mbGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9JbmZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE1lcmdlcyB0aGUgdGFyZ2V0IFJlY3RhbmdsZSB3aXRoIGEgbGlzdCBvZiBwb2ludHMuXHJcbi8vICBUaGUgcG9pbnRzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXMuXHJcblxyXG52YXIgTWVyZ2VQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBwb2ludHMpXHJcbntcclxuICAgIHZhciBtaW5YID0gdGFyZ2V0Lng7XHJcbiAgICB2YXIgbWF4WCA9IHRhcmdldC5yaWdodDtcclxuICAgIHZhciBtaW5ZID0gdGFyZ2V0Lnk7XHJcbiAgICB2YXIgbWF4WSA9IHRhcmdldC5ib3R0b207XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHBvaW50c1tpXS54KTtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcG9pbnRzW2ldLngpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludHNbaV0ueSk7XHJcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHBvaW50c1tpXS55KTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQueSA9IG1pblk7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVBvaW50cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVBvaW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBNZXJnZXMgc291cmNlIHJlY3RhbmdsZSBpbnRvIHRhcmdldCByZWN0YW5nbGUgYW5kIHJldHVybnMgdGFyZ2V0XHJcbi8vICBOZWl0aGVyIHJlY3Qgc2hvdWxkIGhhdmUgbmVnYXRpdmUgd2lkdGhzIG9yIGhlaWdodHNcclxuXHJcbnZhciBNZXJnZVJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXHJcbntcclxuICAgIHZhciBtaW5YID0gTWF0aC5taW4odGFyZ2V0LngsIHNvdXJjZS54KTtcclxuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCBzb3VyY2UucmlnaHQpO1xyXG5cclxuICAgIHRhcmdldC54ID0gbWluWDtcclxuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG5cclxuICAgIHZhciBtaW5ZID0gTWF0aC5taW4odGFyZ2V0LnksIHNvdXJjZS55KTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgc291cmNlLmJvdHRvbSk7XHJcblxyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUmVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE1lcmdlWFkgPSBmdW5jdGlvbiAodGFyZ2V0LCB4LCB5KVxyXG57XHJcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHRhcmdldC54LCB4KTtcclxuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCB4KTtcclxuXHJcbiAgICB0YXJnZXQueCA9IG1pblg7XHJcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuXHJcbiAgICB2YXIgbWluWSA9IE1hdGgubWluKHRhcmdldC55LCB5KTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgeSk7XHJcblxyXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xyXG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlWFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VYWS5qc1xuLy8gbW9kdWxlIGlkID0gNTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcclxue1xyXG4gICAgcmVjdC54ICs9IHg7XHJcbiAgICByZWN0LnkgKz0geTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gNTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChyZWN0LCBwb2ludClcclxue1xyXG4gICAgcmVjdC54ICs9IHBvaW50Lng7XHJcbiAgICByZWN0LnkgKz0gcG9pbnQueTtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0UG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxyXG57XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHJlY3RBLnggPCByZWN0Qi5yaWdodCAmJiBcclxuICAgICAgICByZWN0QS5yaWdodCA+IHJlY3RCLnggJiYgXHJcbiAgICAgICAgcmVjdEEueSA8IHJlY3RCLmJvdHRvbSAmJiBcclxuICAgICAgICByZWN0QS5ib3R0b20gPiByZWN0Qi55XHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGFwcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9PdmVybGFwcy5qc1xuLy8gbW9kdWxlIGlkID0gNTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xyXG5cclxuLy8gIGRlZyA9IGRlZ3JlZXMgKDAtMzYwKVxyXG5cclxudmFyIFBlcmltZXRlclBvaW50ID0gZnVuY3Rpb24gKHJlY3QsIGRlZywgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICB2YXIgdGhldGEgPSBkZWcgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XHJcblxyXG4gICAgd2hpbGUgKHRoZXRhIDwgLU1hdGguUEkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhldGEgKz0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKHRoZXRhID4gTWF0aC5QSSlcclxuICAgIHtcclxuICAgICAgICB0aGV0YSAtPSBNQVRIX0NPTlNULlBJMjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVjdEF0YW4gPSBNYXRoLmF0YW4yKHJlY3QuaGVpZ2h0LCByZWN0LndpZHRoKTtcclxuICAgIHZhciB0YW5UaGV0YSA9IE1hdGgudGFuKHRoZXRhKTtcclxuICAgIHZhciB0aGV0YUJvdW5kcyA9IE1hdGguUEkgLSByZWN0QXRhbjtcclxuICAgIHZhciByZWdpb247XHJcbiAgICB2YXIgeEZhY3RvciA9IDE7XHJcbiAgICB2YXIgeUZhY3RvciA9IDE7XHJcblxyXG4gICAgaWYgKHRoZXRhID4gLXJlY3RBdGFuICYmIHRoZXRhIDw9IHJlY3RBdGFuKVxyXG4gICAge1xyXG4gICAgICAgIHJlZ2lvbiA9IDE7XHJcbiAgICAgICAgeUZhY3RvciA9IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhldGEgPiByZWN0QXRhbiAmJiB0aGV0YSA8PSB0aGV0YUJvdW5kcylcclxuICAgIHtcclxuICAgICAgICByZWdpb24gPSAyO1xyXG4gICAgICAgIHlGYWN0b3IgPSAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoZXRhID4gdGhldGFCb3VuZHMgfHwgdGhldGEgPD0gLXRoZXRhQm91bmRzKVxyXG4gICAge1xyXG4gICAgICAgIHJlZ2lvbiA9IDM7XHJcbiAgICAgICAgeEZhY3RvciA9IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJlZ2lvbiA9IDQ7XHJcbiAgICAgICAgeEZhY3RvciA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIG91dC54ID0gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKTtcclxuICAgIG91dC55ID0gcmVjdC55ICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgaWYgKHJlZ2lvbiA9PT0gMSB8fCByZWdpb24gPT09IDMpXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnggKz0geEZhY3RvciAqIChyZWN0LndpZHRoIC8gMik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiWjBcIlxyXG4gICAgICAgIG91dC55ICs9IHlGYWN0b3IgKiAocmVjdC53aWR0aCAvIDIpICogdGFuVGhldGE7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgb3V0LnggKz0geEZhY3RvciAqIChyZWN0LmhlaWdodCAvICgyICogdGFuVGhldGEpKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIloxXCJcclxuICAgICAgICBvdXQueSArPSB5RmFjdG9yICogKHJlY3QuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyaW1ldGVyUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBTY2FsZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhpcyBSZWN0YW5nbGUgYnkgdGhlIGdpdmVuIGFtb3VudHMuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuUmVjdGFuZ2xlI3NjYWxlXHJcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIHRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlIGJ5LiBBIHZhbHVlIG9mIDAuNSB3b3VsZCByZWR1Y2UgYnkgaGFsZiwgYSB2YWx1ZSBvZiAyIHdvdWxkIGRvdWJsZSB0aGUgd2lkdGgsIGV0Yy5cclxuKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUgYnkuIEEgdmFsdWUgb2YgMC41IHdvdWxkIHJlZHVjZSBieSBoYWxmLCBhIHZhbHVlIG9mIDIgd291bGQgZG91YmxlIHRoZSBoZWlnaHQsIGV0Yy5cclxuKiBAcmV0dXJuIHtQaGFzZXIuUmVjdGFuZ2xlfSBUaGlzIFJlY3RhbmdsZSBvYmplY3RcclxuKi9cclxudmFyIFNjYWxlID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXHJcbntcclxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cclxuXHJcbiAgICByZWN0LndpZHRoICo9IHg7XHJcbiAgICByZWN0LmhlaWdodCAqPSB5O1xyXG5cclxuICAgIHJldHVybiByZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xyXG5cclxudmFyIFVuaW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxyXG57XHJcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0gUmVjdGFuZ2xlKCk7IH1cclxuXHJcbiAgICB2YXIgeCA9IE1hdGgubWluKHJlY3RBLngsIHJlY3RCLngpO1xyXG4gICAgdmFyIHkgPSBNYXRoLm1pbihyZWN0QS55LCByZWN0Qi55KTtcclxuXHJcbiAgICByZXR1cm4gb3V0cHV0LnNldChcclxuICAgICAgICB4LFxyXG4gICAgICAgIHksXHJcbiAgICAgICAgTWF0aC5tYXgocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIHgsXHJcbiAgICAgICAgTWF0aC5tYXgocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0geVxyXG4gICAgKTtcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5SZWN0YW5nbGVcclxuXHJcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xyXG5cclxuUmVjdGFuZ2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcclxuUmVjdGFuZ2xlLkNlaWwgPSByZXF1aXJlKCcuL0NlaWwnKTtcclxuUmVjdGFuZ2xlLkNlaWxBbGwgPSByZXF1aXJlKCcuL0NlaWxBbGwnKTtcclxuUmVjdGFuZ2xlLkNlbnRlck9uID0gcmVxdWlyZSgnLi9DZW50ZXJPbicpO1xyXG5SZWN0YW5nbGUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XHJcblJlY3RhbmdsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcclxuUmVjdGFuZ2xlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XHJcblJlY3RhbmdsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcclxuUmVjdGFuZ2xlLkRlY29tcG9zZSA9IHJlcXVpcmUoJy4vRGVjb21wb3NlJyk7XHJcblJlY3RhbmdsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5SZWN0YW5nbGUuRml0SW5zaWRlID0gcmVxdWlyZSgnLi9GaXRJbnNpZGUnKTtcclxuUmVjdGFuZ2xlLkZpdE91dHNpZGUgPSByZXF1aXJlKCcuL0ZpdE91dHNpZGUnKTtcclxuUmVjdGFuZ2xlLkZsb29yID0gcmVxdWlyZSgnLi9GbG9vcicpO1xyXG5SZWN0YW5nbGUuRmxvb3JBbGwgPSByZXF1aXJlKCcuL0Zsb29yQWxsJyk7XHJcblJlY3RhbmdsZS5HZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcclxuUmVjdGFuZ2xlLkdldENlbnRlciA9IHJlcXVpcmUoJy4vR2V0Q2VudGVyJyk7XHJcblJlY3RhbmdsZS5HZXRTaXplID0gcmVxdWlyZSgnLi9HZXRTaXplJyk7XHJcblJlY3RhbmdsZS5JbmZsYXRlID0gcmVxdWlyZSgnLi9JbmZsYXRlJyk7XHJcblJlY3RhbmdsZS5NYXJjaGluZ0FudHMgPSByZXF1aXJlKCcuL01hcmNoaW5nQW50cycpO1xyXG5SZWN0YW5nbGUuTWVyZ2VQb2ludHMgPSByZXF1aXJlKCcuL01lcmdlUG9pbnRzJyk7XHJcblJlY3RhbmdsZS5NZXJnZVJlY3QgPSByZXF1aXJlKCcuL01lcmdlUmVjdCcpO1xyXG5SZWN0YW5nbGUuTWVyZ2VYWSA9IHJlcXVpcmUoJy4vTWVyZ2VYWScpO1xyXG5SZWN0YW5nbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuUmVjdGFuZ2xlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xyXG5SZWN0YW5nbGUuT3ZlcmxhcHMgPSByZXF1aXJlKCcuL092ZXJsYXBzJyk7XHJcblJlY3RhbmdsZS5QZXJpbWV0ZXIgPSByZXF1aXJlKCcuL1BlcmltZXRlcicpO1xyXG5SZWN0YW5nbGUuUGVyaW1ldGVyUG9pbnQgPSByZXF1aXJlKCcuL1BlcmltZXRlclBvaW50Jyk7XHJcblJlY3RhbmdsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xyXG5SZWN0YW5nbGUuU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XHJcblJlY3RhbmdsZS5VbmlvbiA9IHJlcXVpcmUoJy4vVW5pb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIDJEIGFyZWEgb2YgYSB0cmlhbmdsZS4gVGhlIGFyZWEgdmFsdWUgaXMgYWx3YXlzIG5vbi1uZWdhdGl2ZS5cclxuXHJcbnZhciBBcmVhID0gZnVuY3Rpb24gKHRyaWFuZ2xlKVxyXG57XHJcbiAgICB2YXIgeDEgPSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB5MSA9IHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIHZhciB4MiA9IHRyaWFuZ2xlLngyO1xyXG4gICAgdmFyIHkyID0gdHJpYW5nbGUueTI7XHJcblxyXG4gICAgdmFyIHgzID0gdHJpYW5nbGUueDM7XHJcbiAgICB2YXIgeTMgPSB0cmlhbmdsZS55MztcclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMoKCh4MyAtIHgxKSAqICh5MiAtIHkxKSAtICh4MiAtIHgxKSAqICh5MyAtIHkxKSkgLyAyKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDU2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHJpYW5nbGUgPSByZXF1aXJlKCcuL1RyaWFuZ2xlJyk7XHJcblxyXG4vLyBCdWlsZHMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXHJcbi8vIEluIHRoZSBlcXVpbGF0ZXJhbCB0cmlhbmdsZSwgYWxsIHRoZSBzaWRlcyBhcmUgdGhlIHNhbWUgbGVuZ3RoIChjb25ncnVlbnQpXHJcbi8vIGFuZCBhbGwgdGhlIGFuZ2xlcyBhcmUgdGhlIHNhbWUgc2l6ZSAoY29uZ3J1ZW50KS5cclxuXHJcbi8vICBUaGUgeC95IHNwZWNpZmllcyB0aGUgdG9wLW1pZGRsZSBvZiB0aGUgdHJpYW5nbGUgKHgxL3kxKSBhbmQgbGVuZ3RoXHJcbi8vICBpcyB0aGUgbGVuZ3RoIG9mIGVhY2ggc2lkZVxyXG5cclxudmFyIEJ1aWxkRXF1aWxhdGVyYWwgPSBmdW5jdGlvbiAoeCwgeSwgbGVuZ3RoKVxyXG57XHJcbiAgICB2YXIgaGVpZ2h0ID0gbGVuZ3RoICogKE1hdGguc3FydCgzKSAvIDIpO1xyXG5cclxuICAgIHZhciB4MSA9IHg7XHJcbiAgICB2YXIgeTEgPSB5O1xyXG5cclxuICAgIHZhciB4MiA9IHggKyAobGVuZ3RoIC8gMik7XHJcbiAgICB2YXIgeTIgPSB5ICsgaGVpZ2h0O1xyXG5cclxuICAgIHZhciB4MyA9IHggLSAobGVuZ3RoIC8gMik7XHJcbiAgICB2YXIgeTMgPSB5ICsgaGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiBuZXcgVHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkRXF1aWxhdGVyYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9CdWlsZEVxdWlsYXRlcmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVhckN1dCA9IHJlcXVpcmUoJy4uL3BvbHlnb24vRWFyY3V0Jyk7XHJcbnZhciBUcmlhbmdsZSA9IHJlcXVpcmUoJy4vVHJpYW5nbGUnKTtcclxuXHJcbnZhciBCdWlsZEZyb21Qb2x5Z29uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVzLCBzY2FsZVgsIHNjYWxlWSwgb3V0KVxyXG57XHJcbiAgICBpZiAoaG9sZXMgPT09IHVuZGVmaW5lZCkgeyBob2xlcyA9IG51bGw7IH1cclxuICAgIGlmIChzY2FsZVggPT09IHVuZGVmaW5lZCkgeyBzY2FsZVggPSAxOyB9XHJcbiAgICBpZiAoc2NhbGVZID09PSB1bmRlZmluZWQpIHsgc2NhbGVZID0gMTsgfVxyXG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IFtdOyB9XHJcblxyXG4gICAgdmFyIHRyaXMgPSBFYXJDdXQoZGF0YSwgaG9sZXMpO1xyXG5cclxuICAgIHZhciBhO1xyXG4gICAgdmFyIGI7XHJcbiAgICB2YXIgYztcclxuXHJcbiAgICB2YXIgeDE7XHJcbiAgICB2YXIgeTE7XHJcblxyXG4gICAgdmFyIHgyO1xyXG4gICAgdmFyIHkyO1xyXG5cclxuICAgIHZhciB4MztcclxuICAgIHZhciB5MztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaXMubGVuZ3RoOyBpICs9IDMpXHJcbiAgICB7XHJcbiAgICAgICAgYSA9IHRyaXNbaV07XHJcbiAgICAgICAgYiA9IHRyaXNbaSArIDFdO1xyXG4gICAgICAgIGMgPSB0cmlzW2kgKyAyXTtcclxuXHJcbiAgICAgICAgeDEgPSBkYXRhW2EgKiAyXSAqIHNjYWxlWDtcclxuICAgICAgICB5MSA9IGRhdGFbKGEgKiAyKSArIDFdICogc2NhbGVZO1xyXG5cclxuICAgICAgICB4MiA9IGRhdGFbYiAqIDJdICogc2NhbGVYO1xyXG4gICAgICAgIHkyID0gZGF0YVsoYiAqIDIpICsgMV0gKiBzY2FsZVk7XHJcblxyXG4gICAgICAgIHgzID0gZGF0YVtjICogMl0gKiBzY2FsZVg7XHJcbiAgICAgICAgeTMgPSBkYXRhWyhjICogMikgKyAxXSAqIHNjYWxlWTtcclxuXHJcbiAgICAgICAgb3V0LnB1c2gobmV3IFRyaWFuZ2xlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEZyb21Qb2x5Z29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUcmlhbmdsZSA9IHJlcXVpcmUoJy4vVHJpYW5nbGUnKTtcclxuXHJcbi8vICBCdWlsZHMgYSByaWdodCB0cmlhbmdsZSwgd2l0aCBvbmUgOTAgZGVncmVlIGFuZ2xlIGFuZCB0d28gYWN1dGUgYW5nbGVzXHJcbi8vICBUaGUgeC95IGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSA5MCBkZWdyZWUgYW5nbGUgKGFuZCB3aWxsIG1hcCB0byB4MS95MSBpbiB0aGUgcmVzdWx0aW5nIFRyaWFuZ2xlKVxyXG4vLyAgdy9oIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbmQgcmVwcmVzZW50IHRoZSBsZW5ndGggb2YgZWFjaCBzaWRlXHJcblxyXG52YXIgQnVpbGRSaWdodCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG57XHJcbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgIGhlaWdodCA9IHdpZHRoOyB9XHJcblxyXG4gICAgLy8gIDkwIGRlZ3JlZSBhbmdsZVxyXG4gICAgdmFyIHgxID0geDtcclxuICAgIHZhciB5MSA9IHk7XHJcblxyXG4gICAgdmFyIHgyID0geDtcclxuICAgIHZhciB5MiA9IHkgLSBoZWlnaHQ7XHJcblxyXG4gICAgdmFyIHgzID0geCArIHdpZHRoO1xyXG4gICAgdmFyIHkzID0geTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRyaWFuZ2xlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZFJpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQnVpbGRSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZW50cm9pZCA9IHJlcXVpcmUoJy4vQ2VudHJvaWQnKTtcclxudmFyIE9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XHJcblxyXG52YXIgQ2VudGVyT24gPSBmdW5jdGlvbiAodHJpYW5nbGUsIHgsIHksIGNlbnRlckZ1bmMpXHJcbntcclxuICAgIGlmIChjZW50ZXJGdW5jID09PSB1bmRlZmluZWQpIHsgY2VudGVyRnVuYyA9IENlbnRyb2lkOyB9XHJcblxyXG4gICAgLy8gIEdldCB0aGUgY2VudGVyIG9mIHRoZSB0cmlhbmdsZVxyXG4gICAgdmFyIGNlbnRlciA9IGNlbnRlckZ1bmModHJpYW5nbGUpO1xyXG5cclxuICAgIC8vICBEaWZmZXJlbmNlXHJcbiAgICB2YXIgZGlmZlggPSB4IC0gY2VudGVyLng7XHJcbiAgICB2YXIgZGlmZlkgPSB5IC0gY2VudGVyLnk7XHJcblxyXG4gICAgcmV0dXJuIE9mZnNldCh0cmlhbmdsZSwgZGlmZlgsIGRpZmZZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9DZW50ZXJPbi5qc1xuLy8gbW9kdWxlIGlkID0gNTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBBZGFwdGVkIGZyb20gaHR0cDovL2Jqb3JuaGFycnRlbGwuZ2l0aHViLmlvL2pzdHMvZG9jL2FwaS9qc3RzX2dlb21fVHJpYW5nbGUuanMuaHRtbFxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDJ4MiBtYXRyaXguIFVzZXMgc3RhbmRhcmQgZG91YmxlLXByZWNpc2lvblxyXG4gKiBhcml0aG1ldGljLCBzbyBpcyBzdXNjZXB0aWJsZSB0byByb3VuZC1vZmYgZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfVxyXG4gKiAgICAgICAgICBtMDAgdGhlIFswLDBdIGVudHJ5IG9mIHRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfVxyXG4gKiAgICAgICAgICBtMDEgdGhlIFswLDFdIGVudHJ5IG9mIHRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfVxyXG4gKiAgICAgICAgICBtMTAgdGhlIFsxLDBdIGVudHJ5IG9mIHRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSB7TnVtYmVyfVxyXG4gKiAgICAgICAgICBtMTEgdGhlIFsxLDFdIGVudHJ5IG9mIHRoZSBtYXRyaXguXHJcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGRldGVybWluYW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZGV0IChtMDAsIG0wMSwgbTEwLCBtMTEpXHJcbntcclxuICAgIHJldHVybiAobTAwICogbTExKSAtIChtMDEgKiBtMTApO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNpcmN1bWNlbnRyZSBvZiBhIHRyaWFuZ2xlLiBUaGUgY2lyY3VtY2VudHJlIGlzIHRoZSBjZW50cmUgb2ZcclxuICogdGhlIGNpcmN1bWNpcmNsZSwgdGhlIHNtYWxsZXN0IGNpcmNsZSB3aGljaCBlbmNsb3NlcyB0aGUgdHJpYW5nbGUuIEl0IGlzIGFsc29cclxuICogdGhlIGNvbW1vbiBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgdGhlIHBlcnBlbmRpY3VsYXIgYmlzZWN0b3JzIG9mIHRoZSBzaWRlcyBvZlxyXG4gKiB0aGUgdHJpYW5nbGUsIGFuZCBpcyB0aGUgb25seSBwb2ludCB3aGljaCBoYXMgZXF1YWwgZGlzdGFuY2UgdG8gYWxsIHRocmVlXHJcbiAqIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZS5cclxuICogPHA+XHJcbiAqIFRoaXMgbWV0aG9kIHVzZXMgYW4gYWxnb3JpdGhtIGR1ZSB0byBKLlIuU2hld2NodWsgd2hpY2ggdXNlcyBub3JtYWxpemF0aW9uIHRvXHJcbiAqIHRoZSBvcmlnaW4gdG8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgY29tcHV0YXRpb24uIChTZWUgPGk+TGVjdHVyZSBOb3RlcyBvblxyXG4gKiBHZW9tZXRyaWMgUm9idXN0bmVzczwvaT4sIEpvbmF0aGFuIFJpY2hhcmQgU2hld2NodWssIDE5OTkpLlxyXG4gKi9cclxudmFyIENpcmN1bUNlbnRlciA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuXHJcbiAgICB2YXIgY3ggPSB0cmlhbmdsZS54MztcclxuICAgIHZhciBjeSA9IHRyaWFuZ2xlLnkzO1xyXG5cclxuICAgIHZhciBheCA9IHRyaWFuZ2xlLngxIC0gY3g7XHJcbiAgICB2YXIgYXkgPSB0cmlhbmdsZS55MSAtIGN5O1xyXG5cclxuICAgIHZhciBieCA9IHRyaWFuZ2xlLngyIC0gY3g7XHJcbiAgICB2YXIgYnkgPSB0cmlhbmdsZS55MiAtIGN5O1xyXG5cclxuICAgIHZhciBkZW5vbSA9IDIgKiBkZXQoYXgsIGF5LCBieCwgYnkpO1xyXG4gICAgdmFyIG51bXggPSBkZXQoYXksIGF4ICogYXggKyBheSAqIGF5LCBieSwgYnggKiBieCArIGJ5ICogYnkpO1xyXG4gICAgdmFyIG51bXkgPSBkZXQoYXgsIGF4ICogYXggKyBheSAqIGF5LCBieCwgYnggKiBieCArIGJ5ICogYnkpO1xyXG5cclxuICAgIG91dC54ID0gY3ggLSBudW14IC8gZGVub207XHJcbiAgICBvdXQueSA9IGN5ICsgbnVteSAvIGRlbm9tO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENpcmN1bUNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0NpcmN1bUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXV0b28vNTYxNzY5MVxyXG5cclxudmFyIENpcmN1bUNpcmNsZSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxyXG57XHJcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwLCByYWRpdXM6IDAgfTsgfVxyXG5cclxuICAgIC8vICBBXHJcbiAgICB2YXIgeDEgPSB0cmlhbmdsZS54MTtcclxuICAgIHZhciB5MSA9IHRyaWFuZ2xlLnkxO1xyXG5cclxuICAgIC8vICBCXHJcbiAgICB2YXIgeDIgPSB0cmlhbmdsZS54MjtcclxuICAgIHZhciB5MiA9IHRyaWFuZ2xlLnkyO1xyXG5cclxuICAgIC8vICBDXHJcbiAgICB2YXIgeDMgPSB0cmlhbmdsZS54MztcclxuICAgIHZhciB5MyA9IHRyaWFuZ2xlLnkzO1xyXG5cclxuICAgIHZhciBBID0geDIgLSB4MTtcclxuICAgIHZhciBCID0geTIgLSB5MTtcclxuICAgIHZhciBDID0geDMgLSB4MTtcclxuICAgIHZhciBEID0geTMgLSB5MTtcclxuICAgIHZhciBFID0gQSAqICh4MSArIHgyKSArIEIgKiAoeTEgKyB5Mik7XHJcbiAgICB2YXIgRiA9IEMgKiAoeDEgKyB4MykgKyBEICogKHkxICsgeTMpO1xyXG4gICAgdmFyIEcgPSAyICogKEEgKiAoeTMgLSB5MikgLSBCICogKHgzIC0geDIpKTtcclxuXHJcbiAgICB2YXIgZHg7XHJcbiAgICB2YXIgZHk7XHJcblxyXG4gICAgLy8gIElmIHRoZSBwb2ludHMgb2YgdGhlIHRyaWFuZ2xlIGFyZSBjb2xsaW5lYXIsIHRoZW4ganVzdCBmaW5kIHRoZVxyXG4gICAgLy8gIGV4dHJlbWVzIGFuZCB1c2UgdGhlIG1pZHBvaW50IGFzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmN1bWNpcmNsZS5cclxuXHJcbiAgICBpZiAoTWF0aC5hYnMoRykgPCAwLjAwMDAwMSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKHgxLCB4MiwgeDMpO1xyXG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4oeTEsIHkyLCB5Myk7XHJcbiAgICAgICAgZHggPSAoTWF0aC5tYXgoeDEsIHgyLCB4MykgLSBtaW5YKSAqIDAuNTtcclxuICAgICAgICBkeSA9IChNYXRoLm1heCh5MSwgeTIsIHkzKSAtIG1pblkpICogMC41O1xyXG5cclxuICAgICAgICBvdXQueCA9IG1pblggKyBkeDtcclxuICAgICAgICBvdXQueSA9IG1pblkgKyBkeTtcclxuICAgICAgICBvdXQucmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBvdXQueCA9IChEICogRSAtIEIgKiBGKSAvIEc7XHJcbiAgICAgICAgb3V0LnkgPSAoQSAqIEYgLSBDICogRSkgLyBHO1xyXG4gICAgICAgIGR4ID0gb3V0LnggLSB4MTtcclxuICAgICAgICBkeSA9IG91dC55IC0geTE7XHJcbiAgICAgICAgb3V0LnJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtQ2lyY2xlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xyXG5cclxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcclxue1xyXG4gICAgcmV0dXJuIG5ldyBUcmlhbmdsZShzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIsIHNvdXJjZS54Mywgc291cmNlLnkzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuXHJcbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBwb2ludClcclxue1xyXG4gICAgcmV0dXJuIENvbnRhaW5zKHRyaWFuZ2xlLCBwb2ludC54LCBwb2ludC55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb3BpZXMgdGhlIHgxLCB5MSAtIHgzLCB5MyBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIFRyaWFuZ2xlLlxyXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUjY29weUZyb21cclxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXHJcbiogQHJldHVybiB7TGluZX0gVGhpcyBMaW5lIG9iamVjdC5cclxuKi9cclxudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcclxue1xyXG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyLCBzb3VyY2UueDMsIHNvdXJjZS55Myk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dlb20vdHJpYW5nbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDU3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB0b0NvbXBhcmUpXHJcbntcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdHJpYW5nbGUueDEgPT09IHRvQ29tcGFyZS54MSAmJlxyXG4gICAgICAgIHRyaWFuZ2xlLnkxID09PSB0b0NvbXBhcmUueTEgJiZcclxuICAgICAgICB0cmlhbmdsZS54MiA9PT0gdG9Db21wYXJlLngyICYmXHJcbiAgICAgICAgdHJpYW5nbGUueTIgPT09IHRvQ29tcGFyZS55MiAmJlxyXG4gICAgICAgIHRyaWFuZ2xlLngzID09PSB0b0NvbXBhcmUueDMgJiZcclxuICAgICAgICB0cmlhbmdsZS55MyA9PT0gdG9Db21wYXJlLnkzXHJcbiAgICApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDU3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm90YXRlQXJvdW5kWFkgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFhZJyk7XHJcbnZhciBJbkNlbnRlciA9IHJlcXVpcmUoJy4vSW5DZW50ZXInKTtcclxuXHJcbnZhciBSb3RhdGUgPSBmdW5jdGlvbiAodHJpYW5nbGUsIGFuZ2xlKVxyXG57XHJcbiAgICB2YXIgcG9pbnQgPSBJbkNlbnRlcih0cmlhbmdsZSk7XHJcblxyXG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKHRyaWFuZ2xlLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcclxuXHJcbnZhciBSb3RhdGVBcm91bmRQb2ludCA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgcG9pbnQsIGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkodHJpYW5nbGUsIHBvaW50LngsIHBvaW50LnksIGFuZ2xlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2VvbS90cmlhbmdsZS9Sb3RhdGVBcm91bmRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5UcmlhbmdsZVxyXG5cclxudmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xyXG5cclxuVHJpYW5nbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xyXG5UcmlhbmdsZS5CdWlsZEVxdWlsYXRlcmFsID0gcmVxdWlyZSgnLi9CdWlsZEVxdWlsYXRlcmFsJyk7XHJcblRyaWFuZ2xlLkJ1aWxkRnJvbVBvbHlnb24gPSByZXF1aXJlKCcuL0J1aWxkRnJvbVBvbHlnb24nKTtcclxuVHJpYW5nbGUuQnVpbGRSaWdodCA9IHJlcXVpcmUoJy4vQnVpbGRSaWdodCcpO1xyXG5UcmlhbmdsZS5DZW50ZXJPbiA9IHJlcXVpcmUoJy4vQ2VudGVyT24nKTtcclxuVHJpYW5nbGUuQ2VudHJvaWQgPSByZXF1aXJlKCcuL0NlbnRyb2lkJyk7XHJcblRyaWFuZ2xlLkNpcmN1bUNlbnRlciA9IHJlcXVpcmUoJy4vQ2lyY3VtQ2VudGVyJyk7XHJcblRyaWFuZ2xlLkNpcmN1bUNpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY3VtQ2lyY2xlJyk7XHJcblRyaWFuZ2xlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5UcmlhbmdsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcclxuVHJpYW5nbGUuQ29udGFpbnNBcnJheSA9IHJlcXVpcmUoJy4vQ29udGFpbnNBcnJheScpO1xyXG5UcmlhbmdsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XHJcblRyaWFuZ2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xyXG5UcmlhbmdsZS5EZWNvbXBvc2UgPSByZXF1aXJlKCcuL0RlY29tcG9zZScpO1xyXG5UcmlhbmdsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xyXG5UcmlhbmdsZS5JbkNlbnRlciA9IHJlcXVpcmUoJy4vSW5DZW50ZXInKTtcclxuVHJpYW5nbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcclxuVHJpYW5nbGUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcclxuVHJpYW5nbGUuUm90YXRlID0gcmVxdWlyZSgnLi9Sb3RhdGUnKTtcclxuVHJpYW5nbGUuUm90YXRlQXJvdW5kUG9pbnQgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFBvaW50Jyk7XHJcblRyaWFuZ2xlLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL3RyaWFuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1ODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGFrZXMgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZEF2ZXJhZ2VcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgQXZlcmFnZSA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGEgKyBiKSAvIDI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF2ZXJhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9BdmVyYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU3VidHJhY3RzIHRoZSBkYXJrZXIgb2YgdGhlIHR3byBjb25zdGl0dWVudCBjb2xvcnMgZnJvbSB0aGUgbGlnaHRlci5cclxuKiBcclxuKiBQYWludGluZyB3aXRoIHdoaXRlIGludmVydHMgdGhlIGJhY2tkcm9wIGNvbG9yOyBwYWludGluZyB3aXRoIGJsYWNrIHByb2R1Y2VzIG5vIGNoYW5nZS4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRGlmZmVyZW5jZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpZmZlcmVuY2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9EaWZmZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogUHJvZHVjZXMgYW4gZWZmZWN0IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgRGlmZmVyZW5jZSBtb2RlLCBidXQgbG93ZXIgaW4gY29udHJhc3QuIFxyXG4qIFBhaW50aW5nIHdpdGggd2hpdGUgaW52ZXJ0cyB0aGUgYmFja2Ryb3AgY29sb3I7IHBhaW50aW5nIHdpdGggYmxhY2sgcHJvZHVjZXMgbm8gY2hhbmdlLiBcclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRFeGNsdXNpb25cclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgRXhjbHVzaW9uID0gIGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gYSArIGIgLSAyICogYSAqIGIgLyAyNTU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2x1c2lvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL0V4Y2x1c2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9SZWZsZWN0Jyk7XHJcblxyXG4vKipcclxuKiBHbG93IGJsZW5kIG1vZGUuIFRoaXMgbW9kZSBpcyBhIHZhcmlhdGlvbiBvZiByZWZsZWN0IG1vZGUgd2l0aCB0aGUgc291cmNlIGFuZCBiYWNrZHJvcCBjb2xvcnMgc3dhcHBlZC5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRHbG93XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIEdsb3cgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIFJlZmxlY3QoYiwgYSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdsb3c7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzXG4vLyBtb2R1bGUgaWQgPSA1ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcclxuXHJcbi8qKlxyXG4qIE11bHRpcGxpZXMgb3Igc2NyZWVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBsaWdodGVyIHRoYW4gMC41LCB0aGUgYmFja2Ryb3AgaXMgbGlnaHRlbmVkLCBhcyBpZiBpdCB3ZXJlIHNjcmVlbmVkOyBcclxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIGhpZ2hsaWdodHMgdG8gYSBzY2VuZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBkYXJrZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBkYXJrZW5lZCwgYXMgaWYgaXQgd2VyZSBtdWx0aXBsaWVkOyBcclxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIHNoYWRvd3MgdG8gYSBzY2VuZS4gXHJcbiogXHJcbiogVGhlIGRlZ3JlZSBvZiBsaWdodGVuaW5nIG9yIGRhcmtlbmluZyBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGNvbG9yIGFuZCAwLjU7IFxyXG4qIGlmIGl0IGlzIGVxdWFsIHRvIDAuNSwgdGhlIGJhY2tkcm9wIGlzIHVuY2hhbmdlZC5cclxuKiBcclxuKiBQYWludGluZyB3aXRoIHB1cmUgYmxhY2sgb3Igd2hpdGUgcHJvZHVjZXMgcHVyZSBibGFjayBvciB3aGl0ZS4gVGhlIGVmZmVjdCBpcyBzaW1pbGFyIHRvIHNoaW5pbmcgYSBoYXJzaCBzcG90bGlnaHQgb24gdGhlIGJhY2tkcm9wLiBcclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRIYXJkTGlnaHRcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgSGFyZExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiBPdmVybGF5KGIsIGEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDU4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVml2aWRMaWdodCA9IHJlcXVpcmUoJy4vVml2aWRMaWdodCcpO1xyXG5cclxuLyoqXHJcbiogUnVucyBibGVuZFZpdmlkTGlnaHQgb24gdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzLlxyXG4qIElmIHRoZSByZXN1bHRpbmcgY29sb3IgaXMgMTI4IG9yIG1vcmUsIGl0IHJlY2VpdmVzIGEgdmFsdWUgb2YgMjU1OyBpZiBsZXNzIHRoYW4gMTI4LCBhIHZhbHVlIG9mIDAuXHJcbiogVGhlcmVmb3JlLCBhbGwgYmxlbmRlZCBwaXhlbHMgaGF2ZSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjaGFubmVsIHZhbHVlcyBvZiBlaXRoZXIgMCBvciAyNTUuXHJcbiogVGhpcyBjaGFuZ2VzIGFsbCBwaXhlbHMgdG8gcHJpbWFyeSBhZGRpdGl2ZSBjb2xvcnMgKHJlZCwgZ3JlZW4sIG9yIGJsdWUpLCB3aGl0ZSwgb3IgYmxhY2suXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kSGFyZE1peFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBIYXJkTWl4ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoVml2aWRMaWdodChhLCBiKSA8IDEyOCkgPyAwIDogMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTWl4O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZE1peC5qc1xuLy8gbW9kdWxlIGlkID0gNTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lYXJCdXJuID0gcmVxdWlyZSgnLi9MaW5lYXJCdXJuJyk7XHJcbnZhciBMaW5lYXJEb2RnZSA9IHJlcXVpcmUoJy4vTGluZWFyRG9kZ2UnKTtcclxuXHJcbi8qKlxyXG4qIFRoaXMgYmxlbmQgbW9kZSBjb21iaW5lcyBMaW5lYXIgRG9kZ2UgYW5kIExpbmVhciBCdXJuIChyZXNjYWxlZCBzbyB0aGF0IG5ldXRyYWwgY29sb3JzIGJlY29tZSBtaWRkbGUgZ3JheSkuXHJcbiogRG9kZ2UgYXBwbGllcyB0byB2YWx1ZXMgb2YgdG9wIGxheWVyIGxpZ2h0ZXIgdGhhbiBtaWRkbGUgZ3JheSwgYW5kIGJ1cm4gdG8gZGFya2VyIHZhbHVlcy5cclxuKiBUaGUgY2FsY3VsYXRpb24gc2ltcGxpZmllcyB0byB0aGUgc3VtIG9mIGJvdHRvbSBsYXllciBhbmQgdHdpY2UgdGhlIHRvcCBsYXllciwgc3VidHJhY3QgMTI4LiBUaGUgY29udHJhc3QgZGVjcmVhc2VzLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckxpZ2h0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIExpbmVhckxpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYiA8IDEyOCkgPyBMaW5lYXJCdXJuKGEsIDIgKiBiKSA6IExpbmVhckRvZGdlKGEsICgyICogKGIgLSAxMjgpKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckxpZ2h0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyTGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDU4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBNdWx0aXBsaWVzIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcy5cclxuKiBUaGUgcmVzdWx0IGNvbG9yIGlzIGFsd2F5cyBhdCBsZWFzdCBhcyBkYXJrIGFzIGVpdGhlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50XHJcbiogY29sb3JzLiBNdWx0aXBseWluZyBhbnkgY29sb3Igd2l0aCBibGFjayBwcm9kdWNlcyBibGFjaztcclxuKiBtdWx0aXBseWluZyB3aXRoIHdoaXRlIGxlYXZlcyB0aGUgb3JpZ2luYWwgY29sb3IgdW5jaGFuZ2VkLlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZE11bHRpcGx5XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIE11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpXHJcbntcclxuICAgIHJldHVybiAoYSAqIGIpIC8gMjU1O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL011bHRpcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSA1ODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogTmVnYXRpb24gYmxlbmQgbW9kZS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmROZWdhdGlvblxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBOZWdhdGlvbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gMjU1IC0gTWF0aC5hYnMoMjU1IC0gYSAtIGIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL05lZ2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQmxlbmRzIHRoZSBzb3VyY2UgY29sb3IsIGlnbm9yaW5nIHRoZSBiYWNrZHJvcC5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmROb3JtYWxcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgTm9ybWFsID0gZnVuY3Rpb24gKGEpXHJcbntcclxuICAgIHJldHVybiBhO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Ob3JtYWwuanNcbi8vIG1vZHVsZSBpZCA9IDU5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBQaG9lbml4IGJsZW5kIG1vZGUuIFRoaXMgc3VidHJhY3RzIHRoZSBsaWdodGVyIGNvbG9yIGZyb20gdGhlIGRhcmtlciBjb2xvciwgYW5kIGFkZHMgMjU1LCBnaXZpbmcgYSBicmlnaHQgcmVzdWx0LlxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZFBob2VuaXhcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxyXG4qL1xyXG52YXIgUGhvZW5peCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5taW4oYSwgYikgLSBNYXRoLm1heChhLCBiKSArIDI1NTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGhvZW5peDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL1Bob2VuaXguanNcbi8vIG1vZHVsZSBpZCA9IDU5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGFya2VuID0gcmVxdWlyZSgnLi9EYXJrZW4nKTtcclxudmFyIExpZ2h0ZW4gPSByZXF1aXJlKCcuL0xpZ2h0ZW4nKTtcclxuXHJcbi8qKlxyXG4qIElmIHRoZSBiYWNrZHJvcCBjb2xvciAobGlnaHQgc291cmNlKSBpcyBsaWdodGVyIHRoYW4gNTAlLCB0aGUgYmxlbmREYXJrZW4gbW9kZSBpcyB1c2VkLCBhbmQgY29sb3JzIGxpZ2h0ZXIgdGhhbiB0aGUgYmFja2Ryb3AgY29sb3IgZG8gbm90IGNoYW5nZS5cclxuKiBJZiB0aGUgYmFja2Ryb3AgY29sb3IgaXMgZGFya2VyIHRoYW4gNTAlIGdyYXksIGNvbG9ycyBsaWdodGVyIHRoYW4gdGhlIGJsZW5kIGNvbG9yIGFyZSByZXBsYWNlZCwgYW5kIGNvbG9ycyBkYXJrZXIgdGhhbiB0aGUgYmxlbmQgY29sb3IgZG8gbm90IGNoYW5nZS5cclxuKlxyXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRQaW5MaWdodFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXHJcbiovXHJcbnZhciBQaW5MaWdodCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gRGFya2VuKGEsIDIgKiBiKSA6IExpZ2h0ZW4oYSwgKDIgKiAoYiAtIDEyOCkpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGluTGlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIE11bHRpcGxpZXMgdGhlIGNvbXBsZW1lbnRzIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcywgdGhlbiBjb21wbGVtZW50cyB0aGUgcmVzdWx0LlxyXG4qIFRoZSByZXN1bHQgY29sb3IgaXMgYWx3YXlzIGF0IGxlYXN0IGFzIGxpZ2h0IGFzIGVpdGhlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50IGNvbG9ycy4gXHJcbiogU2NyZWVuaW5nIGFueSBjb2xvciB3aXRoIHdoaXRlIHByb2R1Y2VzIHdoaXRlOyBzY3JlZW5pbmcgd2l0aCBibGFjayBsZWF2ZXMgdGhlIG9yaWdpbmFsIGNvbG9yIHVuY2hhbmdlZC4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kU2NyZWVuXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFNjcmVlbiA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gMjU1IC0gKCgoMjU1IC0gYSkgKiAoMjU1IC0gYikpID4+IDgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY3JlZW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDU5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBEYXJrZW5zIG9yIGxpZ2h0ZW5zIHRoZSBjb2xvcnMsIGRlcGVuZGluZyBvbiB0aGUgc291cmNlIGNvbG9yIHZhbHVlLiBcclxuKiBcclxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGxpZ2h0ZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBsaWdodGVuZWQsIGFzIGlmIGl0IHdlcmUgZG9kZ2VkOyBcclxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIGhpZ2hsaWdodHMgdG8gYSBzY2VuZS4gXHJcbiogXHJcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBkYXJrZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBkYXJrZW5lZCwgYXMgaWYgaXQgd2VyZSBidXJuZWQgaW4uIFxyXG4qIFRoZSBkZWdyZWUgb2YgbGlnaHRlbmluZyBvciBkYXJrZW5pbmcgaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBjb2xvciBhbmQgMC41OyBcclxuKiBpZiBpdCBpcyBlcXVhbCB0byAwLjUsIHRoZSBiYWNrZHJvcCBpcyB1bmNoYW5nZWQuXHJcbiogXHJcbiogUGFpbnRpbmcgd2l0aCBwdXJlIGJsYWNrIG9yIHdoaXRlIHByb2R1Y2VzIGEgZGlzdGluY3RseSBkYXJrZXIgb3IgbGlnaHRlciBhcmVhLCBidXQgZG9lcyBub3QgcmVzdWx0IGluIHB1cmUgYmxhY2sgb3Igd2hpdGUuIFxyXG4qIFRoZSBlZmZlY3QgaXMgc2ltaWxhciB0byBzaGluaW5nIGEgZGlmZnVzZWQgc3BvdGxpZ2h0IG9uIHRoZSBiYWNrZHJvcC4gXHJcbipcclxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kU29mdExpZ2h0XHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cclxuKi9cclxudmFyIFNvZnRMaWdodCA9IGZ1bmN0aW9uIChhLCBiKVxyXG57XHJcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gKDIgKiAoKGEgPj4gMSkgKyA2NCkpICogKGIgLyAyNTUpIDogMjU1IC0gKDIgKiAoMjU1IC0gKChhID4+IDEpICsgNjQpKSAqICgyNTUgLSBiKSAvIDI1NSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNvZnRMaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9ibGVuZG1vZGVzL1NvZnRMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR3JhcGhpY3MuQmxlbmRNb2Rlc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQWRkOiByZXF1aXJlKCcuL0FkZCcpLFxyXG4gICAgQXZlcmFnZTogcmVxdWlyZSgnLi9BdmVyYWdlJyksXHJcbiAgICBDb2xvckJ1cm46IHJlcXVpcmUoJy4vQ29sb3JCdXJuJyksXHJcbiAgICBDb2xvckRvZGdlOiByZXF1aXJlKCcuL0NvbG9yRG9kZ2UnKSxcclxuICAgIERhcmtlbjogcmVxdWlyZSgnLi9EYXJrZW4nKSxcclxuICAgIERpZmZlcmVuY2U6IHJlcXVpcmUoJy4vRGlmZmVyZW5jZScpLFxyXG4gICAgRXhjbHVzaW9uOiByZXF1aXJlKCcuL0V4Y2x1c2lvbicpLFxyXG4gICAgR2xvdzogcmVxdWlyZSgnLi9HbG93JyksXHJcbiAgICBIYXJkTGlnaHQ6IHJlcXVpcmUoJy4vSGFyZExpZ2h0JyksXHJcbiAgICBIYXJkTWl4OiByZXF1aXJlKCcuL0hhcmRNaXgnKSxcclxuICAgIExpZ2h0ZW46IHJlcXVpcmUoJy4vTGlnaHRlbicpLFxyXG4gICAgTGluZWFyQnVybjogcmVxdWlyZSgnLi9MaW5lYXJCdXJuJyksXHJcbiAgICBMaW5lYXJEb2RnZTogcmVxdWlyZSgnLi9MaW5lYXJEb2RnZScpLFxyXG4gICAgTGluZWFyTGlnaHQ6IHJlcXVpcmUoJy4vTGluZWFyTGlnaHQnKSxcclxuICAgIE11bHRpcGx5OiByZXF1aXJlKCcuL011bHRpcGx5JyksXHJcbiAgICBOZWdhdGlvbjogcmVxdWlyZSgnLi9OZWdhdGlvbicpLFxyXG4gICAgTm9ybWFsOiByZXF1aXJlKCcuL05vcm1hbCcpLFxyXG4gICAgT3ZlcmxheTogcmVxdWlyZSgnLi9PdmVybGF5JyksXHJcbiAgICBQaG9lbml4OiByZXF1aXJlKCcuL1Bob2VuaXgnKSxcclxuICAgIFBpbkxpZ2h0OiByZXF1aXJlKCcuL1BpbkxpZ2h0JyksXHJcbiAgICBSZWZsZWN0OiByZXF1aXJlKCcuL1JlZmxlY3QnKSxcclxuICAgIFNjcmVlbjogcmVxdWlyZSgnLi9TY3JlZW4nKSxcclxuICAgIFNvZnRMaWdodDogcmVxdWlyZSgnLi9Tb2Z0TGlnaHQnKSxcclxuICAgIFN1YnRyYWN0OiByZXF1aXJlKCcuL1N1YnRyYWN0JyksXHJcbiAgICBWaXZpZExpZ2h0OiByZXF1aXJlKCcuL1ZpdmlkTGlnaHQnKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcclxuXHJcbnZhciBDU1NNYXAgPSB7XHJcbiAgICBhbGljZWJsdWU6IFsgMjQwLCAyNDgsIDI0NSBdLFxyXG4gICAgYW50aXF1ZXdoaXRlOiBbIDI1MCwgMjM1LCAyMTUgXSxcclxuICAgIGFxdWE6IFsgMCwgMjU1LCAyNTUgXSxcclxuICAgIGFxdWFtYXJpbmU6IFsgMTI3LCAyNTUsIDIxMiBdLFxyXG4gICAgYXp1cmU6IFsgMjQwLCAyNTUsIDI1NSBdLFxyXG4gICAgYmVpZ2U6IFsgMjQ1LCAyNDUsIDIyMCBdLFxyXG4gICAgYmlzcXVlOiBbIDI1NSwgMjI4LCAxOTYgXSxcclxuICAgIGJsYWNrOiBbIDAsIDAsIDAgXSxcclxuICAgIGJsYW5jaGVkYWxtb25kOiBbIDI1NSwgMjM1LCAyMDUgXSxcclxuICAgIGJsdWU6IFsgMCwgMCwgMjU1IF0sXHJcbiAgICBibHVldmlvbGV0OiBbIDEzOCwgNDMsIDIyNiBdLFxyXG4gICAgYnJvd246IFsgMTY1LCA0MiwgNDIgXSxcclxuICAgIGJ1cmx5d29vZDogWyAyMjIsIDE4NCwgMzUgXSxcclxuICAgIGNhZGV0Ymx1ZTogWyA5NSwgMTU4LCAxNjAgXSxcclxuICAgIGNoYXJ0cmV1c2U6IFsgMTI3LCAyNTUsIDAgXSxcclxuICAgIGNob2NvbGF0ZTogWyAyMTAsIDEwNSwgMzAgXSxcclxuICAgIGNvcmFsOiBbIDI1NSwgMTI3LCA4MCBdLFxyXG4gICAgY29ybmZsb3dlcmJsdWU6IFsgMTAwLCAxNDksIDIzNyBdLFxyXG4gICAgY29ybnNpbGs6IFsgMjU1LCAyNDgsIDIyMCBdLFxyXG4gICAgY3JpbXNvbjogWyAyMjAsIDIwLCA2MCBdLFxyXG4gICAgZGFya2JsdWU6IFsgMCwgMCwgMTM5IF0sXHJcbiAgICBkYXJrY3lhbjogWyAwLCAxMzksIDEzOSBdLFxyXG4gICAgZGFya2dvbGRlbnJvZDogWyAxODQsIDEzNCwgMTEgXSxcclxuICAgIGRhcmtncmF5OiBbIDE2OSwgMTY5LCAxNjkgXSxcclxuICAgIGRhcmtncmVlbjogWyAwLCAxMDAsIDAgXSxcclxuICAgIGRhcmtncmV5OiBbIDE2OSwgMTY5LCAxNjkgXSxcclxuICAgIGRhcmtraGFraTogWyAxODksIDE4MywgMTA3IF0sXHJcbiAgICBkYXJrbWFnZW50YTogWyAxMzksIDAsIDEzOSBdLFxyXG4gICAgZGFya29saXZlZ3JlZW46IFsgODUsIDEwNywgNDcgXSxcclxuICAgIGRhcmtvcmFuZ2U6IFsgMjU1LCAxNDAsIDAgXSxcclxuICAgIGRhcmtvcmNoaWQ6IFsgMTUzLCA1MCwgMjA0IF0sXHJcbiAgICBkYXJrcmVkOiBbIDEzOSwgMCwgMCBdLFxyXG4gICAgZGFya3NhbG1vbjogWyAyMzMsIDE1MCwgMTIyIF0sXHJcbiAgICBkYXJrc2VhZ3JlZW46IFsgMTQzLCAxODgsIDE0MyBdLFxyXG4gICAgZGFya3NsYXRlYmx1ZTogWyA3MiwgNjEsIDEzOSBdLFxyXG4gICAgZGFya3NsYXRlZ3JheTogWyA0NywgNzksIDc5IF0sXHJcbiAgICBkYXJrc2xhdGVncmV5OiBbIDQ3LCA3OSwgNzkgXSxcclxuICAgIGRhcmt0dXJxdW9pc2U6IFsgMCwgMjA2LCAyMDkgXSxcclxuICAgIGRhcmt2aW9sZXQ6IFsgMTQ4LCAwLCAyMTEgXSxcclxuICAgIGRlZXBwaW5rOiBbIDI1NSwgMjAsIDE0NyBdLFxyXG4gICAgZGVlcHNreWJsdWU6IFsgMCwgMTkxLCAyNTUgXSxcclxuICAgIGRpbWdyYXk6IFsgMTA1LCAxMDUsIDEwNSBdLFxyXG4gICAgZGltZ3JleTogWyAxMDUsIDEwNSwgMTA1IF0sXHJcbiAgICBkb2RnZXJibHVlOiBbIDMwLCAxNDQsIDI1NSBdLFxyXG4gICAgZmlyZWJyaWNrOiBbIDE3OCwgMzQsIDM0IF0sXHJcbiAgICBmbG9yYWx3aGl0ZTogWyAyNTUsIDI1MCwgMjQwIF0sXHJcbiAgICBmb3Jlc3RncmVlbjogWyAzNCwgMTM5LCAzNCBdLFxyXG4gICAgZnVjaHNpYTogWyAyNTUsIDAsIDI1NSBdLFxyXG4gICAgZ2FpbnNib3JvOiBbIDIyMCwgMjIwLCAyMjAgXSxcclxuICAgIGdob3N0d2hpdGU6IFsgMjQ4LCAyNDgsIDI1NSBdLFxyXG4gICAgZ29sZDogWyAyNTUsIDIxNSwgMCBdLFxyXG4gICAgZ29sZGVucm9kOiBbIDIxOCwgMTY1LCAzMiBdLFxyXG4gICAgZ3JheTogWyAxMjgsIDEyOCwgMTI4IF0sXHJcbiAgICBncmVlbjogWyAwLCAxMjgsIDAgXSxcclxuICAgIGdyZWVueWVsbG93OiBbIDE3MywgMjU1LCA0NyBdLFxyXG4gICAgZ3JleTogWyAxMjgsIDEyOCwgMTI4IF0sXHJcbiAgICBob25leWRldzogWyAyNDAsIDI1NSwgMjQwIF0sXHJcbiAgICBob3RwaW5rOiBbIDI1NSwgMTA1LCAxODAgXSxcclxuICAgIGluZGlhbnJlZDogWyAyMDUsIDkyLCA5MiBdLFxyXG4gICAgaW5kaWdvOiBbIDc1LCAwLCAxMzAgXSxcclxuICAgIGl2b3J5OiBbIDI1NSwgMjU1LCAyNDAgXSxcclxuICAgIGtoYWtpOiBbIDI0MCwgMjMwLCAxNDAgXSxcclxuICAgIGxhdmVuZGVyOiBbIDIzMCwgMjMwLCAyNTAgXSxcclxuICAgIGxhdmVuZGVyYmx1c2g6IFsgMjU1LCAyNDAsIDI0NSBdLFxyXG4gICAgbGF3bmdyZWVuOiBbIDEyNCwgMjUyLCAwIF0sXHJcbiAgICBsZW1vbmNoaWZmb246IFsgMjU1LCAyNTAsIDIwNSBdLFxyXG4gICAgbGlnaHRibHVlOiBbIDE3MywgMjE2LCAyMzAgXSxcclxuICAgIGxpZ2h0Y29yYWw6IFsgMjQwLCAxMjgsIDEyOCBdLFxyXG4gICAgbGlnaHRjeWFuOiBbIDIyNCwgMjU1LCAyNTUgXSxcclxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbIDI1MCwgMjUwLCAyMTAgXSxcclxuICAgIGxpZ2h0Z3JheTogWyAyMTEsIDIxMSwgMjExIF0sXHJcbiAgICBsaWdodGdyZWVuOiBbIDE0NCwgMjM4LCAxNDQgXSxcclxuICAgIGxpZ2h0Z3JleTogWyAyMTEsIDIxMSwgMjExIF0sXHJcbiAgICBsaWdodHBpbms6IFsgMjU1LCAxODIsIDE5MyBdLFxyXG4gICAgbGlnaHRzYWxtb246IFsgMjU1LCAxNjAsIDEyMiBdLFxyXG4gICAgbGlnaHRzZWFncmVlbjogWyAzMiwgMTc4LCAxNzAgXSxcclxuICAgIGxpZ2h0c2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjUwIF0sXHJcbiAgICBsaWdodHNsYXRlZ3JheTogWyAxMTksIDEzNiwgMTUzIF0sXHJcbiAgICBsaWdodHNsYXRlZ3JleTogWyAxMTksIDEzNiwgMTUzIF0sXHJcbiAgICBsaWdodHN0ZWVsYmx1ZTogWyAxNzYsIDE5NiwgMjIyIF0sXHJcbiAgICBsaWdodHllbGxvdzogWyAyNTUsIDI1NSwgMjI0IF0sXHJcbiAgICBsaW1lOiBbIDAsIDI1NSwgMCBdLFxyXG4gICAgbGltZWdyZWVuOiBbIDUwLCAyMDUsIDUwIF0sXHJcbiAgICBsaW5lbjogWyAyNTAsIDI0MCwgMjMwIF0sXHJcbiAgICBtYXJvb246IFsgMTI4LCAwLCAwIF0sXHJcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBbIDEwMiwgMjA1LCAxNzAgXSxcclxuICAgIG1lZGl1bWJsdWU6IFsgMCwgMCwgMjA1IF0sXHJcbiAgICBtZWRpdW1vcmNoaWQ6IFsgMTg2LCA4NSwgMjExIF0sXHJcbiAgICBtZWRpdW1wdXJwbGU6IFsgMTQ3LCAxMTIsIDIxOSBdLFxyXG4gICAgbWVkaXVtc2VhZ3JlZW46IFsgNjAsIDE3OSwgMTEzIF0sXHJcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFsgMTIzLCAxMDQsIDIzOCBdLFxyXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFsgMCwgMjUwLCAxNTQgXSxcclxuICAgIG1lZGl1bXR1cnF1b2lzZTogWyA3MiwgMjA5LCAyMDQgXSxcclxuICAgIG1lZGl1bXZpb2xldHJlZDogWyAxOTksIDIxLCAxMzMgXSxcclxuICAgIG1pZG5pZ2h0Ymx1ZTogWyAyNSwgMjUsIDExMiBdLFxyXG4gICAgbWludGNyZWFtOiBbIDI0NSwgMjU1LCAyNTAgXSxcclxuICAgIG1pc3R5cm9zZTogWyAyNTUsIDIyOCwgMjI1IF0sXHJcbiAgICBtb2NjYXNpbjogWyAyNTUsIDIyOCwgMTgxIF0sXHJcbiAgICBuYXZham93aGl0ZTogWyAyNTUsIDIyMiwgMTczIF0sXHJcbiAgICBuYXZ5OiBbIDAsIDAsIDEyOCBdLFxyXG4gICAgb2xkbGFjZTogWyAyNTMsIDI0NSwgMjMwIF0sXHJcbiAgICBvbGl2ZTogWyAxMjgsIDEyOCwgMCBdLFxyXG4gICAgb2xpdmVkcmFiOiBbIDEwNywgMTQyLCAzNSBdLFxyXG4gICAgb3JhbmdlOiBbIDI1NSwgMTY1LCAwIF0sXHJcbiAgICBvcmFuZ2VyZWQ6IFsgMjU1LCA2OSwgMCBdLFxyXG4gICAgb3JjaGlkOiBbIDIxOCwgMTEyLCAyMTQgXSxcclxuICAgIHBhbGVnb2xkZW5yb2Q6IFsgMjM4LCAyMzIsIDE3MCBdLFxyXG4gICAgcGFsZWdyZWVuOiBbIDE1MiwgMjUxLCAxNTIgXSxcclxuICAgIHBhbGV0dXJxdW9pc2U6IFsgMTc1LCAyMzgsIDIzOCBdLFxyXG4gICAgcGFsZXZpb2xldHJlZDogWyAyMTksIDExMiwgMTQ3IF0sXHJcbiAgICBwYXBheWF3aGlwOiBbIDI1NSwgMjM5LCAyMTMgXSxcclxuICAgIHBlYWNocHVmZjogWyAyNTUsIDIxOCwgMTg1IF0sXHJcbiAgICBwZXJ1OiBbIDIwNSwgMTMzLCA2MyBdLFxyXG4gICAgcGluazogWyAyNTUsIDE5MiwgMjAzIF0sXHJcbiAgICBwbHVtOiBbIDIyMSwgMTYwLCAyMjEgXSxcclxuICAgIHBvd2RlcmJsdWU6IFsgMTc2LCAyMjQsIDIzMCBdLFxyXG4gICAgcHVycGxlOiBbIDEyOCwgMCwgMTI4IF0sXHJcbiAgICByZWJlY2NhcHVycGxlOiBbIDEwMiwgNTEsIDE1MyBdLFxyXG4gICAgcmVkOiBbIDI1NSwgMCwgMCBdLFxyXG4gICAgcm9zeWJyb3duOiBbIDE4OCwgMTQzLCAxNDMgXSxcclxuICAgIHJveWFsYmx1ZTogWyA2NSwgMTA1LCAyMjUgXSxcclxuICAgIHNhZGRsZWJyb3duOiBbIDEzOSwgNjksIDE5IF0sXHJcbiAgICBzYWxtb246IFsgMjUwLCAxMjgsIDExNCBdLFxyXG4gICAgc2FuZHlicm93bjogWyAyNDQsIDE2NCwgOTYgXSxcclxuICAgIHNlYWdyZWVuOiBbIDQ2LCAxMzksIDg3IF0sXHJcbiAgICBzZWFzaGVsbDogWyAyNTUsIDI0NSwgMjM4IF0sXHJcbiAgICBzaWVubmE6IFsgMTYwLCA4MiwgNDUgXSxcclxuICAgIHNpbHZlcjogWyAxOTIsIDE5MiwgMTI5IF0sXHJcbiAgICBza3libHVlOiBbIDEzNSwgMjA2LCAyMzUgXSxcclxuICAgIHNsYXRlYmx1ZTogWyAxMDYsIDkwLCAyMDUgXSxcclxuICAgIHNsYXRlZ3JheTogWyAxMTIsIDEyOCwgMTQ0IF0sXHJcbiAgICBzbGF0ZWdyZXk6IFsgMTEyLCAxMjgsIDE0NCBdLFxyXG4gICAgc25vdzogWyAyNTUsIDI1MCwgMjUwIF0sXHJcbiAgICBzcHJpbmdncmVlbjogWyAwLCAyNTUsIDEyNyBdLFxyXG4gICAgc3RlZWxibHVlOiBbIDcwLCAxMzAsIDE4MCBdLFxyXG4gICAgdGFuOiBbIDIxMCwgMTgwLCAxNDAgXSxcclxuICAgIHRlYWw6IFsgMCwgMTI4LCAxMjggXSxcclxuICAgIHRoaXN0bGU6IFsgMjE2LCAxOTEsIDIxNiBdLFxyXG4gICAgdG9tYXRvOiBbIDI1NSwgOTksIDcxIF0sXHJcbiAgICB0dXJxdW9pc2U6IFsgNjQsIDIyNCwgMjA4IF0sXHJcbiAgICB2aW9sZXQ6IFsgMjM4LCAxMzAsIDIzOCBdLFxyXG4gICAgd2hlYXQ6IFsgMjQ1LCAyMjIsIDE3OSBdLFxyXG4gICAgd2hpdGU6IFsgMjU1LCAyNTUsIDI1NSBdLFxyXG4gICAgd2hpdGVzbW9rZTogWyAyNDUsIDI0NSwgMjQ1IF0sXHJcbiAgICB5ZWxsb3c6IFsgMjU1LCAyNTUsIDAgXSxcclxuICAgIHllbGxvd2dyZWVuOiBbIDE1NCwgMjA1LCA1MCBdXHJcbn07XHJcblxyXG52YXIgQ1NTVG9Db2xvciA9IGZ1bmN0aW9uIChuYW1lKVxyXG57XHJcbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xyXG4gICAgdmFyIGVudHJ5ID0gQ1NTTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChlbnRyeSlcclxuICAgIHtcclxuICAgICAgICBjb2xvci5zZXRUbyhlbnRyeVswXSwgZW50cnlbMV0sIGVudHJ5WzJdLCAyNTUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ1NTVG9Db2xvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yVG9SR0JBID0gZnVuY3Rpb24gKGNvbG9yKVxyXG57XHJcbiAgICB2YXIgb3V0cHV0ID0ge1xyXG4gICAgICAgIHI6IGNvbG9yID4+IDE2ICYgMHhGRixcclxuICAgICAgICBnOiBjb2xvciA+PiA4ICYgMHhGRixcclxuICAgICAgICBiOiBjb2xvciAmIDB4RkYsXHJcbiAgICAgICAgYTogMjU1XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjb2xvciA+IDE2Nzc3MjE1KVxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dC5hID0gY29sb3IgPj4+IDI0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yVG9SR0JBO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0NvbG9yVG9SR0JBLmpzXG4vLyBtb2R1bGUgaWQgPSA1OThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG52YXIgSHVlVG9Db21wb25lbnQgPSByZXF1aXJlKCcuL0h1ZVRvQ29tcG9uZW50Jyk7XHJcblxyXG52YXIgSFNMVG9Db2xvciA9IGZ1bmN0aW9uIChoLCBzLCBsKVxyXG57XHJcbiAgICAvLyBhY2hyb21hdGljIGJ5IGRlZmF1bHRcclxuICAgIHZhciByID0gbDtcclxuICAgIHZhciBnID0gbDtcclxuICAgIHZhciBiID0gbDtcclxuXHJcbiAgICBpZiAocyAhPT0gMClcclxuICAgIHtcclxuICAgICAgICB2YXIgcSA9IChsIDwgMC41KSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcclxuXHJcbiAgICAgICAgciA9IEh1ZVRvQ29tcG9uZW50KHAsIHEsIGggKyAxIC8gMyk7XHJcbiAgICAgICAgZyA9IEh1ZVRvQ29tcG9uZW50KHAsIHEsIGgpO1xyXG4gICAgICAgIGIgPSBIdWVUb0NvbXBvbmVudChwLCBxLCBoIC0gMSAvIDMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xyXG5cclxuICAgIHJldHVybiBjb2xvci5zZXRHTFRvKHIsIGcsIGIsIDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIU0xUb0NvbG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL0hTTFRvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDU5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSFNWVG9SR0IgPSByZXF1aXJlKCcuL0hTVlRvUkdCJyk7XHJcblxyXG4vKipcclxuKiBHZXQgSFNWIGNvbG9yIHdoZWVsIHZhbHVlcyBpbiBhbiBhcnJheSB3aGljaCB3aWxsIGJlIDM2MCBlbGVtZW50cyBpbiBzaXplLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuQ29sb3IuSFNWQ29sb3JXaGVlbFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge251bWJlcn0gW3M9MV0gLSBUaGUgc2F0dXJhdGlvbiwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbdj0xXSAtIFRoZSB2YWx1ZSwgaW4gdGhlIHJhbmdlIDAgLSAxLlxyXG4qIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIDM2MCBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBIU1YgY29sb3Igd2hlZWwuXHJcbiovXHJcbnZhciBIU1ZDb2xvcldoZWVsID0gZnVuY3Rpb24gKHMsIHYpXHJcbntcclxuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHsgcyA9IDE7IH1cclxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IDE7IH1cclxuXHJcbiAgICB2YXIgY29sb3JzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPD0gMzU5OyBjKyspXHJcbiAgICB7XHJcbiAgICAgICAgY29sb3JzLnB1c2goSFNWVG9SR0IoYyAvIDM1OSwgcywgdikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb2xvcnM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhTVkNvbG9yV2hlZWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSFNWQ29sb3JXaGVlbC5qc1xuLy8gbW9kdWxlIGlkID0gNjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lYXIgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbicpO1xyXG5cclxudmFyIFJHQldpdGhSR0IgPSBmdW5jdGlvbiAocjEsIGcxLCBiMSwgcjIsIGcyLCBiMiwgbGVuZ3RoLCBpbmRleClcclxue1xyXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IDEwMDsgfVxyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XHJcblxyXG4gICAgdmFyIHQgPSBpbmRleCAvIGxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IExpbmVhcihyMSwgcjIsIHQpLFxyXG4gICAgICAgIGc6IExpbmVhcihnMSwgZzIsIHQpLFxyXG4gICAgICAgIGI6IExpbmVhcihiMSwgYjIsIHQpXHJcbiAgICB9O1xyXG59O1xyXG5cclxudmFyIENvbG9yV2l0aENvbG9yID0gZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyLCBsZW5ndGgsIGluZGV4KVxyXG57XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICByZXR1cm4gUkdCV2l0aFJHQihjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iLCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iLCBsZW5ndGgsIGluZGV4KTtcclxufTtcclxuXHJcbnZhciBDb2xvcldpdGhSR0IgPSBmdW5jdGlvbiAgKGNvbG9yLCByLCBnLCBiLCBsZW5ndGgsIGluZGV4KVxyXG57XHJcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cclxuXHJcbiAgICByZXR1cm4gUkdCV2l0aFJHQihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCByLCBnLCBiLCBsZW5ndGgsIGluZGV4KTtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBSR0JXaXRoUkdCOiBSR0JXaXRoUkdCLFxyXG4gICAgQ29sb3JXaXRoUkdCOiBDb2xvcldpdGhSR0IsXHJcbiAgICBDb2xvcldpdGhDb2xvcjogQ29sb3JXaXRoQ29sb3JcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvSW50ZXJwb2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWIChodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlKS5cclxuKiBDb252ZXJzaW9uIGZvcnVtbGEgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuKiBBc3N1bWVzIFJHQiB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZCByZXR1cm5zIGgsIHMgYW5kIHYgaW4gdGhlIHNldCBbMCwgMV0uXHJcbiogQmFzZWQgb24gY29kZSBieSBNaWNoYWVsIEphY2tzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uKVxyXG4qXHJcbiogQG1ldGhvZCBMYXplci5Db2xvci5SR0J0b0hTVlxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSByZWQgY29sb3IgY29tcG9uZW50LCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuKiBAcGFyYW0ge251bWJlcn0gZyAtIFRoZSBncmVlbiBjb2xvciBjb21wb25lbnQsIGluIHRoZSByYW5nZSAwIC0gMjU1LlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIGJsdWUgY29sb3IgY29tcG9uZW50LCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cclxuKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlIHNldCBpbiB0aGUgaCwgcyBhbmQgdiBwcm9wZXJ0aWVzLlxyXG4qL1xyXG52YXIgUkdCVG9IU1YgPSBmdW5jdGlvbiAociwgZywgYilcclxue1xyXG4gICAgciAvPSAyNTU7XHJcbiAgICBnIC89IDI1NTtcclxuICAgIGIgLz0gMjU1O1xyXG5cclxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG5cclxuICAgIC8vIGFjaHJvbWF0aWMgYnkgZGVmYXVsdFxyXG4gICAgdmFyIGggPSAwO1xyXG4gICAgdmFyIHMgPSAobWF4ID09PSAwKSA/IDAgOiBkIC8gbWF4O1xyXG4gICAgdmFyIHYgPSBtYXg7XHJcblxyXG4gICAgaWYgKG1heCAhPT0gbWluKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChtYXggPT09IHIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoKGcgPCBiKSA/IDYgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF4ID09PSBnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF4ID09PSBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGggLz0gNjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJHQlRvSFNWO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dyYXBoaWNzL2NvbG9yL1JHQlRvSFNWLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbXBvbmVudFRvSGV4ID0gcmVxdWlyZSgnLi9Db21wb25lbnRUb0hleCcpO1xyXG5cclxudmFyIFJHQlRvU3RyaW5nID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEsIHByZWZpeClcclxue1xyXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gMjU1OyB9XHJcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHsgcHJlZml4ID0gJyMnOyB9XHJcblxyXG4gICAgaWYgKHByZWZpeCA9PT0gJyMnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICcweCcgKyBDb21wb25lbnRUb0hleChhKSArIENvbXBvbmVudFRvSGV4KHIpICsgQ29tcG9uZW50VG9IZXgoZykgKyBDb21wb25lbnRUb0hleChiKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUkdCVG9TdHJpbmc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvUkdCVG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDYwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvQmV0d2VlbicpO1xyXG5cclxudmFyIFJhbmRvbVJHQiA9IGZ1bmN0aW9uIChtaW4sIG1heClcclxue1xyXG4gICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7IG1pbiA9IDA7IH1cclxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkgeyBtYXggPSAyNTU7IH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IEJldHdlZW4obWluLCBtYXgpLFxyXG4gICAgICAgIGc6IEJldHdlZW4obWluLCBtYXgpLFxyXG4gICAgICAgIGI6IEJldHdlZW4obWluLCBtYXgpXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21SR0I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvUmFuZG9tUkdCLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HcmFwaGljcy5Db2xvclxyXG5cclxudmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xyXG5cclxuQ29sb3IuQ29sb3JUb1JHQkEgPSByZXF1aXJlKCcuL0NvbG9yVG9SR0JBJyk7XHJcbkNvbG9yLkNvbXBvbmVudFRvSGV4ID0gcmVxdWlyZSgnLi9Db21wb25lbnRUb0hleCcpO1xyXG5Db2xvci5DU1NUb0NvbG9yID0gcmVxdWlyZSgnLi9DU1NUb0NvbG9yJyk7XHJcbkNvbG9yLkdldENvbG9yID0gcmVxdWlyZSgnLi9HZXRDb2xvcicpO1xyXG5Db2xvci5HZXRDb2xvcjMyID0gcmVxdWlyZSgnLi9HZXRDb2xvcjMyJyk7XHJcbkNvbG9yLkhleFN0cmluZ1RvQ29sb3IgPSByZXF1aXJlKCcuL0hleFN0cmluZ1RvQ29sb3InKTtcclxuQ29sb3IuSFNMVG9Db2xvciA9IHJlcXVpcmUoJy4vSFNMVG9Db2xvcicpO1xyXG5Db2xvci5IU1ZDb2xvcldoZWVsID0gcmVxdWlyZSgnLi9IU1ZDb2xvcldoZWVsJyk7XHJcbkNvbG9yLkhTVlRvUkdCID0gcmVxdWlyZSgnLi9IU1ZUb1JHQicpO1xyXG5Db2xvci5IdWVUb0NvbXBvbmVudCA9IHJlcXVpcmUoJy4vSHVlVG9Db21wb25lbnQnKTtcclxuQ29sb3IuSW50ZWdlclRvQ29sb3IgPSByZXF1aXJlKCcuL0ludGVnZXJUb0NvbG9yJyk7XHJcbkNvbG9yLkludGVnZXJUb1JHQiA9IHJlcXVpcmUoJy4vSW50ZWdlclRvUkdCJyk7XHJcbkNvbG9yLkludGVycG9sYXRlID0gcmVxdWlyZSgnLi9JbnRlcnBvbGF0ZScpO1xyXG5Db2xvci5SYW5kb21SR0IgPSByZXF1aXJlKCcuL1JhbmRvbVJHQicpO1xyXG5Db2xvci5SR0JTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9SR0JTdHJpbmdUb0NvbG9yJyk7XHJcbkNvbG9yLlJHQlRvSFNWID0gcmVxdWlyZSgnLi9SR0JUb0hTVicpO1xyXG5Db2xvci5SR0JUb1N0cmluZyA9IHJlcXVpcmUoJy4vUkdCVG9TdHJpbmcnKTtcclxuQ29sb3IuVmFsdWVUb0NvbG9yID0gcmVxdWlyZSgnLi9WYWx1ZVRvQ29sb3InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpY3MvY29sb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgR2xvYmFsSW5wdXRNYW5hZ2VyXHJcblxyXG52YXIgS2V5Ym9hcmQgPSByZXF1aXJlKCcuL2tleWJvYXJkL0tleWJvYXJkTWFuYWdlcicpO1xyXG52YXIgTW91c2UgPSByZXF1aXJlKCcuL21vdXNlL01vdXNlTWFuYWdlcicpO1xyXG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vbW91c2UvZXZlbnRzLycpO1xyXG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xyXG52YXIgR2V0VHJhbnNmb3JtZWRQb2ludCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9HZXRUcmFuc2Zvcm1lZFBvaW50Jyk7XHJcbnZhciBQb2ludFdpdGhpbkdhbWVPYmplY3QgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUG9pbnRXaXRoaW5HYW1lT2JqZWN0Jyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG5cclxudmFyIEdsb2JhbElucHV0TWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lLCBnYW1lQ29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgIHRoaXMuZ2FtZUNvbmZpZyA9IGdhbWVDb25maWc7XHJcblxyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAvLyAgIFN0YW5kYXJkIEZJRk8gcXVldWVcclxuICAgIHRoaXMucXVldWUgPSBbXTtcclxuXHJcbiAgICAvLyAgTGlzdGVuZXJzXHJcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKHRoaXMpO1xyXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLl90ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG4gICAgdGhpcy5fdGVtcFBvaW50ID0geyB4OiAwLCB5OiAwIH07XHJcbn07XHJcblxyXG5HbG9iYWxJbnB1dE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2xvYmFsSW5wdXRNYW5hZ2VyO1xyXG5cclxuR2xvYmFsSW5wdXRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXHJcbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5JbnB1dC5LZXlib2FyZE1hbmFnZXIjYm9vdFxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5rZXlib2FyZC5ib290KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5ib290KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmtleWJvYXJkLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5xdWV1ZS5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8IGxlbiA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDbGVhcnMgdGhlIHF1ZXVlIGFycmF5LCBhbmQgYWxzbyBtZWFucyB3ZSBkb24ndCB3b3JrIG9uIGFycmF5IGRhdGEgdGhhdCBjb3VsZCBwb3RlbnRpYWxseVxyXG4gICAgICAgIC8vICBiZSBtb2RpZmllZCBkdXJpbmcgdGhlIHByb2Nlc3NpbmcgcGhhc2VcclxuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlLnNwbGljZSgwLCBsZW4pO1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgZXZlbnQgcXVldWUsIGRpc3BhdGNoaW5nIGFsbCBvZiB0aGUgZXZlbnRzIHRoYXQgaGF2ZSBzdG9yZWQgdXBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcXVldWVbaV07XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IE1vdXNlRXZlbnQuTU9WRShldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IE1vdXNlRXZlbnQuRE9XTihldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBNb3VzZUV2ZW50LlVQKGV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRyYW5zZm9ybWVkUG9pbnQ6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBHZXRUcmFuc2Zvcm1lZFBvaW50KHRoaXMuX3RlbXBNYXRyaXgsIGdhbWVPYmplY3QsIHgsIHksIHRoaXMuX3RlbXBQb2ludCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHBvaW50V2l0aGluR2FtZU9iamVjdDogZnVuY3Rpb24gKGdhbWVPYmplY3QsIHgsIHkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50V2l0aGluR2FtZU9iamVjdChnYW1lT2JqZWN0LCB4LCB5KTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdsb2JhbElucHV0TWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIFBvaW50ZXIuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5JbnB1dCNnZXRMb2NhbFBvc2l0aW9uXHJcbiogQHBhcmFtIHtQaGFzZXIuU3ByaXRlfFBoYXNlci5JbWFnZX0gZ2FtZU9iamVjdCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGdldCB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgZm9yLlxyXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50ZXJ9IHBvaW50ZXIgLSBUaGUgUG9pbnRlciB0byB1c2UgaW4gdGhlIGNoZWNrIGFnYWluc3QgdGhlIGdhbWVPYmplY3QuXHJcbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBQb2ludGVyIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBEaXNwbGF5T2JqZWN0LlxyXG4qL1xyXG52YXIgR2V0VHJhbnNmb3JtZWRQb2ludCA9IGZ1bmN0aW9uIChtYXRyaXgsIGdhbWVPYmplY3QsIHgsIHksIG91dHB1dClcclxue1xyXG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IHsgeDogMCwgeTogMCB9OyB9XHJcblxyXG4gICAgbWF0cml4LmFwcGx5SVRSUyhnYW1lT2JqZWN0LngsIGdhbWVPYmplY3QueSwgLWdhbWVPYmplY3Qucm90YXRpb24sIGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LnNjYWxlWSk7XHJcblxyXG4gICAgbWF0cml4LmludmVydCgpO1xyXG5cclxuICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtUG9pbnQoeCwgeSwgb3V0cHV0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VHJhbnNmb3JtZWRQb2ludDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9jb21wb25lbnRzL0dldFRyYW5zZm9ybWVkUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgeC95IE1VU1QgYmUgdHJhbnNsYXRlZCBiZWZvcmUgYmVpbmcgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHVubGVzcyB0aGUgZ2FtZU9iamVjdCBpcyBndWFybmF0ZWVkIHRvXHJcbi8vICBiZSBub3Qgcm90YXRlZCBvciBzY2FsZWQgaW4gYW55IHdheVxyXG5cclxudmFyIFBvaW50V2l0aGluR2FtZU9iamVjdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5KVxyXG57XHJcbiAgICB2YXIgd2lkdGggPSBnYW1lT2JqZWN0LndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGdhbWVPYmplY3QuaGVpZ2h0O1xyXG5cclxuICAgIHZhciB4MSA9IC13aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWDtcclxuICAgIHZhciB5MSA9IC1oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblk7XHJcblxyXG4gICAgcmV0dXJuICh4ID49IHgxICYmIHggPCAoeDEgKyB3aWR0aCkgJiYgeSA+PSB5MSAmJiB5IDwgKHkxICsgaGVpZ2h0KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50V2l0aGluR2FtZU9iamVjdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9jb21wb25lbnRzL1BvaW50V2l0aGluR2FtZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBSZXR1cm4gYm9vbGVhbiAodHJ1ZSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGNvbWJvLCBmYWxzZSBpZiBub3QpXHJcblxyXG52YXIgQWR2YW5jZUtleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcclxue1xyXG4gICAgY29tYm8udGltZUxhc3RNYXRjaGVkID0gZXZlbnQudGltZVN0YW1wO1xyXG4gICAgY29tYm8uaW5kZXgrKztcclxuXHJcbiAgICBpZiAoY29tYm8uaW5kZXggPT09IGNvbWJvLnNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgY29tYm8uY3VycmVudCA9IGNvbWJvLmtleUNvZGVzW2NvbWJvLmluZGV4XTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFkdmFuY2VLZXlDb21ibztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9jb21iby9BZHZhbmNlS2V5Q29tYm8uanNcbi8vIG1vZHVsZSBpZCA9IDYwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBLZXlDb21ib01hdGNoRXZlbnQgPSBmdW5jdGlvbiAoa2V5Q29tYm8sIGtleWJvYXJkRXZlbnQpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ0tFWV9DT01CT19NQVRDSF9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0ga2V5Q29tYm87XHJcblxyXG4gICAgdGhpcy5kYXRhID0ga2V5Ym9hcmRFdmVudDtcclxufTtcclxuXHJcbktleUNvbWJvTWF0Y2hFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbktleUNvbWJvTWF0Y2hFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlDb21ib01hdGNoRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvbWJvTWF0Y2hFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21ib01hdGNoRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVzZXRLZXlDb21ibyA9IGZ1bmN0aW9uIChjb21ibylcclxue1xyXG4gICAgY29tYm8uY3VycmVudCA9IGNvbWJvLmtleUNvZGVzWzBdO1xyXG4gICAgY29tYm8uaW5kZXggPSAwO1xyXG4gICAgY29tYm8udGltZUxhc3RNYXRjaGVkID0gMDtcclxuICAgIGNvbWJvLm1hdGNoZWQgPSBmYWxzZTtcclxuICAgIGNvbWJvLnRpbWVNYXRjaGVkID0gMDtcclxuXHJcbiAgICByZXR1cm4gY29tYm87XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2V0S2V5Q29tYm87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUmVzZXRLZXlDb21iby5qc1xuLy8gbW9kdWxlIGlkID0gNjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEtleURvd25FdmVudCA9IGZ1bmN0aW9uIChrZXlib2FyZEV2ZW50KVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdLRVlfRE9XTl9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IGtleWJvYXJkRXZlbnQ7XHJcbn07XHJcblxyXG5LZXlEb3duRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xyXG5LZXlEb3duRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5RG93bkV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXlEb3duRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleURvd25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIEtleVVwRXZlbnQgPSBmdW5jdGlvbiAoa2V5Ym9hcmRFdmVudClcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5kYXRhID0ga2V5Ym9hcmRFdmVudDtcclxufTtcclxuXHJcbktleVVwRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xyXG5LZXlVcEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleVVwRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleVVwRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxudmFyIEtleUNvZGVzID0gcmVxdWlyZSgnLi8uLi9rZXlzL0tleUNvZGVzJyk7XHJcblxyXG52YXIgZXZlbnRzID0ge1xyXG4gICAgS0VZX0RPV05fRVZFTlQ6IHJlcXVpcmUoJy4vS2V5RG93bkV2ZW50JyksXHJcbiAgICBLRVlfVVBfRVZFTlQ6IHJlcXVpcmUoJy4vS2V5VXBFdmVudCcpLFxyXG4gICAgX1VQOiBbXSxcclxuICAgIF9ET1dOOiBbXVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlS2V5RXZlbnQgKHR5cGUpXHJcbntcclxuICAgIHZhciBLZXlFdmVudCA9IGZ1bmN0aW9uIChrZXlib2FyZEV2ZW50KVxyXG4gICAge1xyXG4gICAgICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGtleWJvYXJkRXZlbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIEtleUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuICAgIEtleUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUV2ZW50O1xyXG5cclxuICAgIHJldHVybiBLZXlFdmVudDtcclxufVxyXG5cclxuLy8gIEluamVjdCB0aGUgS2V5Q29kZSBldmVudHNcclxuXHJcbmZvciAodmFyIGNvZGUgaW4gS2V5Q29kZXMpXHJcbntcclxuICAgIC8vICBUaGUgS2V5IERvd24gRXZlbnQgVHlwZXNcclxuXHJcbiAgICB2YXIgZG93blR5cGUgPSAnS0VZX0RPV05fJyArIGNvZGU7XHJcbiAgICB2YXIgdXBUeXBlID0gJ0tFWV9VUF8nICsgY29kZTtcclxuXHJcbiAgICBldmVudHMuX0RPV05bS2V5Q29kZXNbY29kZV1dID0gY3JlYXRlS2V5RXZlbnQoZG93blR5cGUpO1xyXG4gICAgZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV0gPSBjcmVhdGVLZXlFdmVudCh1cFR5cGUpO1xyXG5cclxuICAgIC8vICBNb3JlIGZyaWVuZGx5IGFsaWFzZXMgdG8gdGhlIG1haW4gZXZlbnRzXHJcbiAgICBldmVudHNbZG93blR5cGVdID0gZXZlbnRzLl9ET1dOW0tleUNvZGVzW2NvZGVdXTtcclxuICAgIGV2ZW50c1t1cFR5cGVdID0gZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2V2ZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuSW5wdXQuS2V5Ym9hcmRcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEtleWJvYXJkTWFuYWdlcjogcmVxdWlyZSgnLi9LZXlib2FyZE1hbmFnZXInKSxcclxuXHJcbiAgICBLZXk6IHJlcXVpcmUoJy4va2V5cy9LZXknKSxcclxuICAgIEtleUNvZGVzOiByZXF1aXJlKCcuL2tleXMvS2V5Q29kZXMnKSxcclxuXHJcbiAgICBLZXlDb21ibzogcmVxdWlyZSgnLi9jb21iby9LZXlDb21ibycpLFxyXG5cclxuICAgIEp1c3REb3duOiByZXF1aXJlKCcuL2tleXMvSnVzdERvd24nKSxcclxuICAgIEp1c3RVcDogcmVxdWlyZSgnLi9rZXlzL0p1c3RVcCcpLFxyXG4gICAgRG93bkR1cmF0aW9uOiByZXF1aXJlKCcuL2tleXMvRG93bkR1cmF0aW9uJyksXHJcbiAgICBVcER1cmF0aW9uOiByZXF1aXJlKCcuL2tleXMvVXBEdXJhdGlvbicpXHJcbiAgICBcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFJldHVybnMgYHRydWVgIGlmIHRoZSBLZXkgd2FzIHByZXNzZWQgZG93biB3aXRoaW4gdGhlIGBkdXJhdGlvbmAgdmFsdWUgZ2l2ZW4sIG9yIGBmYWxzZWAgaWYgaXQgZWl0aGVyIGlzbid0IGRvd24sXHJcbiogb3Igd2FzIHByZXNzZWQgZG93biBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5LZXkjZG93bkR1cmF0aW9uXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj01MF0gLSBUaGUgZHVyYXRpb24gd2l0aGluIHdoaWNoIHRoZSBrZXkgaXMgY29uc2lkZXJlZCBhcyBiZWluZyBqdXN0IHByZXNzZWQuIEdpdmVuIGluIG1zLlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGtleSB3YXMgcHJlc3NlZCBkb3duIHdpdGhpbiB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiovXHJcbnZhciBEb3duRHVyYXRpb24gPSBmdW5jdGlvbiAoa2V5LCBkdXJhdGlvbilcclxue1xyXG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHsgZHVyYXRpb24gPSA1MDsgfVxyXG5cclxuICAgIHJldHVybiAoa2V5LmlzRG93biAmJiBrZXkuZHVyYXRpb24gPCBkdXJhdGlvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERvd25EdXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9rZXlib2FyZC9rZXlzL0Rvd25EdXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBqdXN0RG93biB2YWx1ZSBhbGxvd3MgeW91IHRvIHRlc3QgaWYgdGhpcyBLZXkgaGFzIGp1c3QgYmVlbiBwcmVzc2VkIGRvd24gb3Igbm90LlxyXG4qIFdoZW4geW91IGNoZWNrIHRoaXMgdmFsdWUgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBLZXkgaXMgZG93biwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiogWW91IGNhbiBvbmx5IGNhbGwganVzdERvd24gb25jZSBwZXIga2V5IHByZXNzLiBJdCB3aWxsIG9ubHkgcmV0dXJuIGB0cnVlYCBvbmNlLCB1bnRpbCB0aGUgS2V5IGlzIHJlbGVhc2VkIGFuZCBwcmVzc2VkIGRvd24gYWdhaW4uXHJcbiogVGhpcyBhbGxvd3MgeW91IHRvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSB3YW50IHRvIGNoZWNrIGlmIHRoaXMga2V5IGlzIGRvd24gd2l0aG91dCB1c2luZyBhIFNpZ25hbCwgc3VjaCBhcyBpbiBhIGNvcmUgZ2FtZSBsb29wLlxyXG4qIFxyXG4qIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ganVzdERvd25cclxuKiBAbWVtYmVyb2YgUGhhc2VyLktleVxyXG4qIEBkZWZhdWx0IGZhbHNlXHJcbiovXHJcblxyXG52YXIgSnVzdERvd24gPSBmdW5jdGlvbiAoa2V5KVxyXG57XHJcbiAgICB2YXIgY3VycmVudCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChrZXkuaXNEb3duKVxyXG4gICAge1xyXG4gICAgICAgIGN1cnJlbnQgPSBrZXkuX2p1c3REb3duO1xyXG4gICAgICAgIGtleS5fanVzdERvd24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSnVzdERvd247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQva2V5cy9KdXN0RG93bi5qc1xuLy8gbW9kdWxlIGlkID0gNjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBqdXN0VXAgdmFsdWUgYWxsb3dzIHlvdSB0byB0ZXN0IGlmIHRoaXMgS2V5IGhhcyBqdXN0IGJlZW4gcmVsZWFzZWQgb3Igbm90LlxyXG4qIFdoZW4geW91IGNoZWNrIHRoaXMgdmFsdWUgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBLZXkgaXMgdXAsIG90aGVyd2lzZSBgZmFsc2VgLlxyXG4qIFlvdSBjYW4gb25seSBjYWxsIGp1c3RVcCBvbmNlIHBlciBrZXkgcmVsZWFzZS4gSXQgd2lsbCBvbmx5IHJldHVybiBgdHJ1ZWAgb25jZSwgdW50aWwgdGhlIEtleSBpcyBwcmVzc2VkIGRvd24gYW5kIHJlbGVhc2VkIGFnYWluLlxyXG4qIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3Ugd2FudCB0byBjaGVjayBpZiB0aGlzIGtleSBpcyB1cCB3aXRob3V0IHVzaW5nIGEgU2lnbmFsLCBzdWNoIGFzIGluIGEgY29yZSBnYW1lIGxvb3AuXHJcbiogXHJcbiogQHByb3BlcnR5IHtib29sZWFufSBqdXN0VXBcclxuKiBAbWVtYmVyb2YgUGhhc2VyLktleVxyXG4qIEBkZWZhdWx0IGZhbHNlXHJcbiovXHJcblxyXG52YXIgSnVzdFVwID0gZnVuY3Rpb24gKGtleSlcclxue1xyXG4gICAgdmFyIGN1cnJlbnQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoa2V5LmlzRG93bilcclxuICAgIHtcclxuICAgICAgICBjdXJyZW50ID0ga2V5Ll9qdXN0VXA7XHJcbiAgICAgICAga2V5Ll9qdXN0VXAgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSnVzdFVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L2tleWJvYXJkL2tleXMvSnVzdFVwLmpzXG4vLyBtb2R1bGUgaWQgPSA2MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBQcm9jZXNzS2V5RG93biA9IGZ1bmN0aW9uIChrZXksIGV2ZW50KVxyXG57XHJcbiAgICBrZXkub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG5cclxuICAgIGlmIChrZXkucHJldmVudERlZmF1bHQpXHJcbiAgICB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWtleS5lbmFibGVkKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBrZXkuYWx0S2V5ID0gZXZlbnQuYWx0S2V5O1xyXG4gICAga2V5LmN0cmxLZXkgPSBldmVudC5jdHJsS2V5O1xyXG4gICAga2V5LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XHJcbiAgICBrZXkubG9jYXRpb24gPSBldmVudC5sb2NhdGlvbjtcclxuXHJcbiAgICBrZXkuaXNEb3duID0gdHJ1ZTtcclxuICAgIGtleS5pc1VwID0gZmFsc2U7XHJcbiAgICBrZXkudGltZURvd24gPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICBrZXkuZHVyYXRpb24gPSAwO1xyXG4gICAga2V5LnJlcGVhdHMrKztcclxuXHJcbiAgICBrZXkuX2p1c3REb3duID0gdHJ1ZTtcclxuICAgIGtleS5fanVzdFVwID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleURvd247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQva2V5cy9Qcm9jZXNzS2V5RG93bi5qc1xuLy8gbW9kdWxlIGlkID0gNjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgUHJvY2Vzc0tleVVwID0gZnVuY3Rpb24gKGtleSwgZXZlbnQpXHJcbntcclxuICAgIGtleS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XHJcblxyXG4gICAgaWYgKGtleS5wcmV2ZW50RGVmYXVsdClcclxuICAgIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgha2V5LmVuYWJsZWQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGtleS5pc0Rvd24gPSBmYWxzZTtcclxuICAgIGtleS5pc1VwID0gdHJ1ZTtcclxuICAgIGtleS50aW1lVXAgPSBldmVudC50aW1lU3RhbXA7XHJcbiAgICBrZXkuZHVyYXRpb24gPSBrZXkudGltZVVwIC0ga2V5LnRpbWVEb3duO1xyXG4gICAga2V5LnJlcGVhdHMgPSAwO1xyXG5cclxuICAgIGtleS5fanVzdERvd24gPSBmYWxzZTtcclxuICAgIGtleS5fanVzdFVwID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4ga2V5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9jZXNzS2V5VXA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQva2V5cy9Qcm9jZXNzS2V5VXAuanNcbi8vIG1vZHVsZSBpZCA9IDYyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgS2V5IHdhcyByZWxlYXNlZCB3aXRoaW4gdGhlIGBkdXJhdGlvbmAgdmFsdWUgZ2l2ZW4sIG9yIGBmYWxzZWAgaWYgaXQgZWl0aGVyIGlzbid0IHVwLFxyXG4qIG9yIHdhcyByZWxlYXNlZCBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5LZXkjdXBEdXJhdGlvblxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NTBdIC0gVGhlIGR1cmF0aW9uIHdpdGhpbiB3aGljaCB0aGUga2V5IGlzIGNvbnNpZGVyZWQgYXMgYmVpbmcganVzdCByZWxlYXNlZC4gR2l2ZW4gaW4gbXMuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUga2V5IHdhcyByZWxlYXNlZCB3aXRoaW4gdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4qL1xyXG52YXIgVXBEdXJhdGlvbiA9IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxyXG57XHJcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgeyBkdXJhdGlvbiA9IDUwOyB9XHJcblxyXG4gICAgcmV0dXJuIChrZXkuaXNVcCAmJiBrZXkuZHVyYXRpb24gPCBkdXJhdGlvbik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwRHVyYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQva2V5Ym9hcmQva2V5cy9VcER1cmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTW91c2VEb3duRXZlbnQgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnQpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ01PVVNFX0RPV05fRVZFTlQnKTtcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBuYXRpdmVFdmVudDtcclxuXHJcbiAgICB0aGlzLnggPSBuYXRpdmVFdmVudC5jbGllbnRYO1xyXG4gICAgdGhpcy55ID0gbmF0aXZlRXZlbnQuY2xpZW50WTtcclxufTtcclxuXHJcbk1vdXNlRG93bkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTW91c2VEb3duRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VEb3duRXZlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlRG93bkV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2lucHV0L21vdXNlL2V2ZW50cy9Nb3VzZURvd25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50cy9FdmVudCcpO1xyXG5cclxudmFyIE1vdXNlTW92ZUV2ZW50ID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50KVxyXG57XHJcbiAgICBFdmVudC5jYWxsKHRoaXMsICdNT1VTRV9NT1ZFX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gbmF0aXZlRXZlbnQ7XHJcblxyXG4gICAgdGhpcy54ID0gbmF0aXZlRXZlbnQuY2xpZW50WDtcclxuICAgIHRoaXMueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFk7XHJcbn07XHJcblxyXG5Nb3VzZU1vdmVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbk1vdXNlTW92ZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlTW92ZUV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZU1vdmVFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbnB1dC9tb3VzZS9ldmVudHMvTW91c2VNb3ZlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBNb3VzZVVwRXZlbnQgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnQpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ01PVVNFX1VQX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gbmF0aXZlRXZlbnQ7XHJcblxyXG4gICAgdGhpcy54ID0gbmF0aXZlRXZlbnQuY2xpZW50WDtcclxuICAgIHRoaXMueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFk7XHJcbn07XHJcblxyXG5Nb3VzZVVwRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xyXG5Nb3VzZVVwRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VVcEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZVVwRXZlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbW91c2UvZXZlbnRzL01vdXNlVXBFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIERPV046IHJlcXVpcmUoJy4vTW91c2VEb3duRXZlbnQnKSxcclxuICAgIFVQOiByZXF1aXJlKCcuL01vdXNlVXBFdmVudCcpLFxyXG4gICAgTU9WRTogcmVxdWlyZSgnLi9Nb3VzZU1vdmVFdmVudCcpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbW91c2UvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5JbnB1dC5Nb3VzZVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgTW91c2VNYW5hZ2VyOiByZXF1aXJlKCcuL01vdXNlTWFuYWdlcicpIFxyXG4gICAgICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5wdXQvbW91c2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vc3RydWN0cy9TZXQnKTtcclxudmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xyXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50cy8nKTtcclxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcclxuXHJcbnZhciBCYXNlTG9hZGVyID0gZnVuY3Rpb24gKClcclxue1xyXG4gICAgLy8gIFRvIGZpbmlzaCB0aGUgbG9hZGVyIC4uLlxyXG4gICAgLy8gIFxyXG4gICAgLy8gIDMpIFByb2dyZXNzIHVwZGF0ZVxyXG5cclxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG5cclxuICAgIC8vICBNb3ZlIHRvIGEgJ3NldFVSTCcgbWV0aG9kP1xyXG4gICAgdGhpcy5iYXNlVVJMID0gJyc7XHJcbiAgICB0aGlzLnBhdGggPSAnJztcclxuXHJcbiAgICAvLyAgUmVhZCBmcm9tIEdhbWUgLyBTdGF0ZSBDb25maWdcclxuICAgIHRoaXMuZW5hYmxlUGFyYWxsZWwgPSB0cnVlO1xyXG4gICAgdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcyA9IDQ7XHJcblxyXG4gICAgLy8gIHhociBzcGVjaWZpYyBnbG9iYWwgc2V0dGluZ3MgKGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgcGVyLWZpbGUgYmFzaXMpXHJcbiAgICB0aGlzLnhociA9IFhIUlNldHRpbmdzKCk7XHJcblxyXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLmluZmxpZ2h0ID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5mYWlsZWQgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLnF1ZXVlID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFNldCgpO1xyXG5cclxuICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX0lETEU7XHJcbn07XHJcblxyXG5CYXNlTG9hZGVyLnByb3RvdHlwZS5jb250cnVjdG9yID0gQmFzZUxvYWRlcjtcclxuXHJcbkJhc2VMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaWxlLnBhdGggPSB0aGlzLnBhdGg7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5zZXQoZmlsZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgSXMgdGhlIExvYWRlciBhY3RpdmVseSBsb2FkaW5nIChvciBwcm9jZXNzaW5nIGxvYWRlZCBmaWxlcylcclxuICAgIGlzTG9hZGluZzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfTE9BRElORyB8fCB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkcpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgSXMgdGhlIExvYWRlciByZWFkeSB0byBzdGFydCBhIG5ldyBsb2FkP1xyXG4gICAgaXNSZWFkeTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfSURMRSB8fCB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0NPTVBMRVRFIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfRkFJTEVEKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5zdGF0ZS5zZXR0aW5ncy5rZXksICctIEJhc2VMb2FkZXIgc3RhcnQuIEZpbGVzIHRvIGxvYWQ6JywgdGhpcy5saXN0LnNpemUpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNSZWFkeSgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LkxPQURFUl9TVEFSVF9FVkVOVCh0aGlzKSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2l6ZSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX0xPQURJTkc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuZGVidWcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTG9hZFF1ZXVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVQcm9ncmVzczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3NMb2FkUXVldWU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09PT09PT09IEJhc2VMb2FkZXIgcHJvY2Vzc0xvYWRRdWV1ZScpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMaXN0IHNpemUnLCB0aGlzLmxpc3Quc2l6ZSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pbmZsaWdodC5zaXplLCAnaXRlbXMgc3RpbGwgaW4gZmxpZ2h0LiBDYW4gbG9hZCBhbm90aGVyJywgKHRoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMgLSB0aGlzLmluZmxpZ2h0LnNpemUpKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5saXN0LmVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9QRU5ESU5HICYmIF90aGlzLmluZmxpZ2h0LnNpemUgPCBfdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5mbGlnaHQuc2V0KGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIF90aGlzLmxpc3QuZGVsZXRlKGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRGaWxlKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5mbGlnaHQuc2l6ZSA9PT0gX3RoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBUZWxscyB0aGUgU2V0IGl0ZXJhdG9yIHRvIGFib3J0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBwcml2YXRlXHJcbiAgICBsb2FkRmlsZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPQURJTkcnLCBmaWxlLmtleSk7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGUgZmlsZSBkb2Vzbid0IGhhdmUgaXRzIG93biBjcm9zc09yaWdpbiBzZXQsXHJcbiAgICAgICAgLy8gIHdlJ2xsIHVzZSB0aGUgTG9hZGVycyAod2hpY2ggaXMgdW5kZWZpbmVkIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgaWYgKCFmaWxlLmNyb3NzT3JpZ2luKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmlsZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaWxlLmxvYWQodGhpcy5uZXh0RmlsZS5iaW5kKHRoaXMpLCB0aGlzLmJhc2VVUkwpO1xyXG4gICAgfSxcclxuXHJcbiAgICBuZXh0RmlsZTogZnVuY3Rpb24gKHByZXZpb3VzRmlsZSwgc3VjY2VzcylcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTE9BREVEOicsIHByZXZpb3VzRmlsZS5zcmMsIHN1Y2Nlc3MpO1xyXG5cclxuICAgICAgICAvLyAgTW92ZSB0aGUgZmlsZSB0aGF0IGp1c3QgbG9hZGVkIGZyb20gdGhlIGluZmxpZ2h0IGxpc3QgdG8gdGhlIHF1ZXVlIG9yIGZhaWxlZCBTZXRcclxuXHJcbiAgICAgICAgaWYgKHN1Y2Nlc3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNldChwcmV2aW91c0ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5zZXQocHJldmlvdXNGaWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuZGVsZXRlKHByZXZpb3VzRmlsZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2l6ZSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV4dEZpbGUgLSBzdGlsbCBzb21ldGhpbmcgaW4gdGhlIGxpc3QnKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTG9hZFF1ZXVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5mbGlnaHQuc2l6ZSA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXh0RmlsZSBjYWxsaW5nIGZpbmlzaGVkTG9hZGluZycpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkTG9hZGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZmluaXNoZWRMb2FkaW5nOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IEJhc2VMb2FkZXIuZmluaXNoZWRMb2FkaW5nIFBST0NFU1NJTkcnLCB0aGlzLnF1ZXVlLnNpemUsICdmaWxlcycpO1xyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9QUk9DRVNTSU5HO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5xdWV1ZS5lYWNoKGZ1bmN0aW9uIChmaWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIENhbGxpbmcgcHJvY2VzcyBvbiAnICsgZmlsZS5rZXksICdjb2xvcjogIzAwMDAwMDsgYmFja2dyb3VuZDogI2ZmZmYwMDsnKTtcclxuXHJcbiAgICAgICAgICAgIGZpbGUub25Qcm9jZXNzKF90aGlzLnByb2Nlc3NVcGRhdGUuYmluZChfdGhpcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIEZpbGUgd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZ1xyXG4gICAgcHJvY2Vzc1VwZGF0ZTogZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0+IHByb2Nlc3NVcGRhdGUnLCBmaWxlLmtleSwgZmlsZS5zdGF0ZSk7XHJcblxyXG4gICAgICAgIC8vICBUaGlzIGZpbGUgaGFzIGZhaWxlZCB0byBsb2FkLCBzbyBtb3ZlIGl0IHRvIHRoZSBmYWlsZWQgU2V0XHJcbiAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfRVJST1JFRClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlLmxpbmtGaWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZSBmaWxlIGxvYWRlZFxyXG5cclxuICAgICAgICAvLyAgU3BlY2lhbCBoYW5kbGluZyBmb3IgbXVsdGktcGFydCBmaWxlc1xyXG5cclxuICAgICAgICBpZiAoZmlsZS5saW5rRmlsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0NPTVBMRVRFICYmIGZpbGUubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfQ09NUExFVEUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vICBQYXJ0bmVyIGhhcyBsb2FkZWQsIHNvIGFkZCB0aGVtIGJvdGggdG8gU3RvcmFnZVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoeyB0eXBlOiBmaWxlLmxpbmtUeXBlLCBmaWxlQTogZmlsZSwgZmlsZUI6IGZpbGUubGlua0ZpbGUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZS5saW5rRmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChmaWxlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlRnJvbVF1ZXVlOiBmdW5jdGlvbiAoZmlsZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucXVldWUuc2l6ZSA9PT0gMCAmJiB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgV2UndmUgcHJvY2Vzc2VkIGFsbCB0aGUgZmlsZXMgd2UgbG9hZGVkXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9jZXNzQ29tcGxldGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5zdGF0ZS5zZXR0aW5ncy5rZXksICctIExvYWRlciBDb21wbGV0ZS4gTG9hZGVkOicsIHRoaXMuc3RvcmFnZS5zaXplLCAnRmFpbGVkOicsIHRoaXMuZmFpbGVkLnNpemUpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzQ2FsbGJhY2spXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfQ09NUExFVEU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5MT0FERVJfQ09NUExFVEVfRVZFTlQodGhpcykpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5mYWlsZWQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbCgnTE9BREVSX1NUQVJUX0VWRU5UJyk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnKTtcclxuXHJcbiAgICAgICAgdGhpcy50YWcgPSAnJztcclxuICAgICAgICB0aGlzLnBhdGggPSAnJztcclxuICAgICAgICB0aGlzLmJhc2VVUkwgPSAnJztcclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfREVTVFJPWUVEO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZUxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRVUkwgPSBmdW5jdGlvbiAoZmlsZSwgYmFzZVVSTClcclxue1xyXG4gICAgaWYgKCFmaWxlLnVybClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbGUudXJsLm1hdGNoKC9eKD86YmxvYjp8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfFxcL1xcLykvKSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmlsZS51cmw7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBmaWxlLnVybDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0VVJMO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDYyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xyXG5cclxudmFyIFhIUkxvYWRlciA9IGZ1bmN0aW9uIChmaWxlLCBnbG9iYWxYSFJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IE1lcmdlWEhSU2V0dGluZ3MoZ2xvYmFsWEhSU2V0dGluZ3MsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICB4aHIub3BlbignR0VUJywgZmlsZS5zcmMsIGNvbmZpZy5hc3luYywgY29uZmlnLnVzZXIsIGNvbmZpZy5wYXNzd29yZCk7XHJcblxyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZpbGUueGhyU2V0dGluZ3MucmVzcG9uc2VUeXBlO1xyXG4gICAgeGhyLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcclxuXHJcbiAgICBpZiAoY29uZmlnLmhlYWRlciAmJiBjb25maWcuaGVhZGVyVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LCB0aGUgeGhyLnJlc3BvbnNlIHByb3BlcnR5IHdpbGwgY29udGFpbiB0aGUgcmVxdWVzdGVkIGRhdGEgYXMgYSBET01TdHJpbmcsIEFycmF5QnVmZmVyLCBCbG9iLCBvciBEb2N1bWVudCAoZGVwZW5kaW5nIG9uIHdoYXQgd2FzIHNldCBmb3IgcmVzcG9uc2VUeXBlLilcclxuXHJcbiAgICB4aHIub25sb2FkID0gZmlsZS5vbkxvYWQuYmluZChmaWxlKTtcclxuICAgIHhoci5vbmVycm9yID0gZmlsZS5vbkVycm9yLmJpbmQoZmlsZSk7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xyXG5cclxuICAgIC8vICBUaGlzIGlzIHRoZSBvbmx5IHN0YW5kYXJkIG1ldGhvZCwgdGhlIG9uZXMgYWJvdmUgYXJlIGJyb3dzZXIgYWRkaXRpb25zIChtYXliZSBub3QgdW5pdmVyc2FsPylcclxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcclxuXHJcbiAgICB4aHIuc2VuZCgpO1xyXG5cclxuICAgIHJldHVybiB4aHI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvYWRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvWEhSTG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XHJcblxyXG52YXIgTG9hZGVyQ29tcGxldGVFdmVudCA9IGZ1bmN0aW9uIChsb2FkZXIpXHJcbntcclxuICAgIEV2ZW50LmNhbGwodGhpcywgJ0xPQURFUl9DT01QTEVURV9FVkVOVCcpO1xyXG5cclxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xyXG59O1xyXG5cclxuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XHJcbkxvYWRlckNvbXBsZXRlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyQ29tcGxldGVFdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyQ29tcGxldGVFdmVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcclxuXHJcbnZhciBMb2FkZXJTdGFydEV2ZW50ID0gZnVuY3Rpb24gKGxvYWRlcilcclxue1xyXG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX1NUQVJUX0VWRU5UJyk7XHJcblxyXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbn07XHJcblxyXG5Mb2FkZXJTdGFydEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcclxuTG9hZGVyU3RhcnRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJTdGFydEV2ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIExPQURFUl9TVEFSVF9FVkVOVDogcmVxdWlyZSgnLi9Mb2FkZXJTdGFydEV2ZW50JyksXHJcbiAgICBMT0FERVJfQ09NUExFVEVfRVZFTlQ6IHJlcXVpcmUoJy4vTG9hZGVyQ29tcGxldGVFdmVudCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuL0pTT05GaWxlLmpzJyk7XHJcblxyXG52YXIgQW5pbWF0aW9uSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIganNvbiA9IG5ldyBKU09ORmlsZShrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vICBPdmVycmlkZSB0aGUgRmlsZSB0eXBlXHJcbiAgICBqc29uLnR5cGUgPSAnYW5pbWF0aW9uSlNPTic7XHJcblxyXG4gICAgcmV0dXJuIGpzb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbkpTT05GaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvQW5pbWF0aW9uSlNPTkZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcclxudmFyIEpTT05GaWxlID0gcmVxdWlyZSgnLi9KU09ORmlsZS5qcycpO1xyXG5cclxudmFyIEF0bGFzSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdGV4dHVyZVVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcclxuICAgIHZhciBkYXRhID0gbmV3IEpTT05GaWxlKGtleSwgYXRsYXNVUkwsIHBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcclxuICAgIGltYWdlLmxpbmtGaWxlID0gZGF0YTtcclxuICAgIGRhdGEubGlua0ZpbGUgPSBpbWFnZTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSB0eXBlXHJcbiAgICBpbWFnZS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG4gICAgZGF0YS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xyXG5cclxuICAgIHJldHVybiB7IHRleHR1cmU6IGltYWdlLCBkYXRhOiBkYXRhIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF0bGFzSlNPTkZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIEJpbmFyeUZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuYmluYXJ5XFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLmJpbic7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ2JpbmFyeScsIGtleSwgdXJsLCAnYXJyYXlidWZmZXInLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5CaW5hcnlGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5CaW5hcnlGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeUZpbGU7XHJcblxyXG5CaW5hcnlGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2U7XHJcblxyXG4gICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeUZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XHJcbnZhciBYTUxGaWxlID0gcmVxdWlyZSgnLi9YTUxGaWxlLmpzJyk7XHJcblxyXG52YXIgQml0bWFwRm9udEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCB4bWxVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgeG1sWGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZUZpbGUoa2V5LCB0ZXh0dXJlVVJMLCBwYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MpO1xyXG4gICAgdmFyIGRhdGEgPSBuZXcgWE1MRmlsZShrZXksIHhtbFVSTCwgcGF0aCwgeG1sWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcclxuICAgIGltYWdlLmxpbmtGaWxlID0gZGF0YTtcclxuICAgIGRhdGEubGlua0ZpbGUgPSBpbWFnZTtcclxuXHJcbiAgICAvLyAgU2V0IHRoZSB0eXBlXHJcbiAgICBpbWFnZS5saW5rVHlwZSA9ICdiaXRtYXBmb250JztcclxuICAgIGRhdGEubGlua1R5cGUgPSAnYml0bWFwZm9udCc7XHJcblxyXG4gICAgcmV0dXJuIHsgdGV4dHVyZTogaW1hZ2UsIGRhdGE6IGRhdGEgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQml0bWFwRm9udEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcclxuXHJcbnZhciBHTFNMRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XHJcblxyXG4gICAgaWYgKCFrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci50ZXh0XFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLmdsc2wnO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgRmlsZS5jYWxsKHRoaXMsICdnbHNsJywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xyXG59O1xyXG5cclxuR0xTTEZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcbkdMU0xGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdMU0xGaWxlO1xyXG5cclxuR0xTTEZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XHJcblxyXG4gICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgY2FsbGJhY2sodGhpcyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdMU0xGaWxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XHJcblxyXG52YXIgSFRNTEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHdpZHRoLCBoZWlnaHQsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDUxMjsgfVxyXG4gICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDUxMjsgfVxyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmh0bWxcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcuaHRtbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ2h0bWwnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncywgY29uZmlnKTtcclxufTtcclxuXHJcbkhUTUxGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xyXG5IVE1MRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MRmlsZTtcclxuXHJcbkhUTUxGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XHJcblxyXG4gICAgdmFyIHcgPSB0aGlzLmNvbmZpZy53aWR0aDtcclxuICAgIHZhciBoID0gdGhpcy5jb25maWcuaGVpZ2h0O1xyXG5cclxuICAgIHZhciBkYXRhID0gW107XHJcblxyXG4gICAgZGF0YS5wdXNoKCc8c3ZnIHdpZHRoPVwiJyArIHcgKyAncHhcIiBoZWlnaHQ9XCInICsgaCArICdweFwiIHZpZXdCb3g9XCIwIDAgJyArIHcgKyAnICcgKyBoICsgJ1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nKTtcclxuICAgIGRhdGEucHVzaCgnPGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPicpO1xyXG4gICAgZGF0YS5wdXNoKCc8Ym9keSB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj4nKTtcclxuICAgIGRhdGEucHVzaCh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xyXG4gICAgZGF0YS5wdXNoKCc8L2JvZHk+Jyk7XHJcbiAgICBkYXRhLnB1c2goJzwvZm9yZWlnbk9iamVjdD4nKTtcclxuICAgIGRhdGEucHVzaCgnPC9zdmc+Jyk7XHJcblxyXG4gICAgdmFyIHN2ZyA9IFsgZGF0YS5qb2luKCdcXG4nKSBdO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKHN2ZywgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04JyB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKVxyXG4gICAge1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIF90aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEub25lcnJvciA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhfdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGF0YS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRmlsZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL0hUTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIFNWR0ZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxyXG5cclxuICAgIGlmICgha2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuc3ZnXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdXJsKVxyXG4gICAge1xyXG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnN2Zyc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ3N2ZycsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcclxufTtcclxuXHJcblNWR0ZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XHJcblNWR0ZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHRmlsZTtcclxuXHJcblNWR0ZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcclxue1xyXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcclxuXHJcbiAgICB2YXIgc3ZnID0gWyB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQgXTtcclxuXHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihzdmcsIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCcgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSlcclxuICAgIHtcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfRVJST1JFRDtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdmFyIHJldHJ5ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIF90aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRhdGEub25lcnJvciA9IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XHJcblxyXG4gICAgICAgIC8vICBTYWZhcmkgOCByZS10cnlcclxuICAgICAgICBpZiAoIXJldHJ5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0cnkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVybCA9ICdkYXRhOmltYWdlL3N2Zyt4bWwsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmcuam9pbignJykpO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMuZGF0YS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0ZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9TVkdGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XHJcblxyXG4vLyAgY29uZmlnIGNhbiBpbmNsdWRlOiBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZ1xyXG5cclxudmFyIFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCBjb25maWcsIHBhdGgsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncywgY29uZmlnKTtcclxuXHJcbiAgICAvLyAgT3ZlcnJpZGUgdGhlIEZpbGUgdHlwZVxyXG4gICAgaW1hZ2UudHlwZSA9ICdzcHJpdGVzaGVldCc7XHJcblxyXG4gICAgcmV0dXJuIGltYWdlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVTaGVldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sb2FkZXIvZmlsZXR5cGVzL1Nwcml0ZVNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xyXG5cclxudmFyIFRleHRGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cclxuXHJcbiAgICBpZiAoIWtleSlcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnRleHRcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF1cmwpXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcudGV4dCc7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBGaWxlLmNhbGwodGhpcywgJ3RleHQnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XHJcbn07XHJcblxyXG5UZXh0RmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcclxuVGV4dEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEZpbGU7XHJcblxyXG5UZXh0RmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dDtcclxuXHJcbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuXHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dEZpbGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdmVyYWdlID0gZnVuY3Rpb24gKHZhbHVlcylcclxue1xyXG4gICAgdmFyIHN1bSA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgc3VtICs9ICgrdmFsdWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VtIC8gdmFsdWVzLmxlbmd0aDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXZlcmFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0F2ZXJhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDY0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcclxue1xyXG4gICAgaWYgKHBsYWNlID09PSB1bmRlZmluZWQpIHsgcGxhY2UgPSAwOyB9XHJcbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxyXG5cclxuICAgIHZhciBwID0gTWF0aC5wb3coYmFzZSwgLXBsYWNlKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlICogcCkgLyBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9DZWlsVG8uanNcbi8vIG1vZHVsZSBpZCA9IDY0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgRGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcylcclxue1xyXG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBDT05TVC5ERUdfVE9fUkFEO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEZWdUb1JhZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0RlZ1RvUmFkLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL0RpZmZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDY0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvYXRCZXR3ZWVuID0gZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmxvYXRCZXR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvRmxvYXRCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxyXG57XHJcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cclxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XHJcblxyXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICogcCkgLyBwO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vclRvO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvRmxvb3JUby5qc1xuLy8gbW9kdWxlIGlkID0gNjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBkaXN0YW5jZSAtIHVzdWFsbHkgaW4gcGl4ZWxzXHJcbi8vICB0aW1lIC0gaG93IGxvbmcgc2hvdWxkIGl0IHRha2UgdG8gY292ZXIgdGhlIGRpc3RhbmNlPyBJbiBzZWNvbmRzXHJcbi8vICBSZXR1cm5zIHRoZSBhbW91bnQgeW91IHdpbGwgbmVlZCB0byBpbmNyZW1lbnQgYnkgZWFjaCBzdGVwIHRvIGNvdmVyIHRoZSBkaXN0YW5jZSBpbiB0aGUgdGltZSBnaXZlblxyXG52YXIgR2V0U3BlZWQgPSBmdW5jdGlvbiAoZGlzdGFuY2UsIHRpbWUpXHJcbntcclxuICAgIHJldHVybiAoZGlzdGFuY2UgLyB0aW1lKSAvIDEwMDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFNwZWVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvR2V0U3BlZWQuanNcbi8vIG1vZHVsZSBpZCA9IDY0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIE1heEFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtYXgpXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1pbih2YWx1ZSArIGFtb3VudCwgbWF4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWF4QWRkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTWF4QWRkLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1pblN1YiA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtaW4pXHJcbntcclxuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAtIGFtb3VudCwgbWluKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWluU3ViO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvTWluU3ViLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBlcmNlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYmFzZSlcclxue1xyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMDsgfVxyXG5cclxuICAgIGlmIChhID4gYiB8fCBiYXNlID4gYilcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPCBiYXNlIHx8IGJhc2UgPiBhKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoYSAtIGJhc2UpIC8gYjtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyY2VudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1BlcmNlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgUmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucylcclxue1xyXG4gICAgcmV0dXJuIHJhZGlhbnMgKiBDT05TVC5SQURfVE9fREVHO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSYWRUb0RlZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1JhZFRvRGVnLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKHBvaW50LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIHggPSBwb2ludC54O1xyXG4gICAgdmFyIHkgPSBwb2ludC55O1xyXG5cclxuICAgIHBvaW50LnggPSAoeCAqIE1hdGguY29zKGFuZ2xlKSkgLSAoeSAqIE1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICBwb2ludC55ID0gKHggKiBNYXRoLnNpbihhbmdsZSkpICsgKHkgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXHJcblxyXG52YXIgUm90YXRlQXJvdW5kID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5LCBhbmdsZSlcclxue1xyXG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICB2YXIgdHggPSBwb2ludC54IC0geDtcclxuICAgIHZhciB0eSA9IHBvaW50LnkgLSB5O1xyXG5cclxuICAgIHBvaW50LnggPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xyXG4gICAgcG9pbnQueSA9IHR4ICogcyArIHR5ICogYyArIHk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3RhdGVBcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDY1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXHJcbntcclxuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxyXG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cclxuXHJcbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwKSAvIHA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kVG87XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9Sb3VuZFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBTaW5Db3NUYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIChsZW5ndGgsIHNpbkFtcCwgY29zQW1wLCBmcmVxdWVuY3kpXHJcbntcclxuICAgIGlmIChzaW5BbXAgPT09IHVuZGVmaW5lZCkgeyBzaW5BbXAgPSAxOyB9XHJcbiAgICBpZiAoY29zQW1wID09PSB1bmRlZmluZWQpIHsgY29zQW1wID0gMTsgfVxyXG4gICAgaWYgKGZyZXF1ZW5jeSA9PT0gdW5kZWZpbmVkKSB7IGZyZXF1ZW5jeSA9IDE7IH1cclxuXHJcbiAgICBmcmVxdWVuY3kgKj0gTWF0aC5QSSAvIGxlbmd0aDtcclxuXHJcbiAgICB2YXIgY29zID0gW107XHJcbiAgICB2YXIgc2luID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBsZW5ndGg7IGMrKylcclxuICAgIHtcclxuICAgICAgICBjb3NBbXAgLT0gc2luQW1wICogZnJlcXVlbmN5O1xyXG4gICAgICAgIHNpbkFtcCArPSBjb3NBbXAgKiBmcmVxdWVuY3k7XHJcblxyXG4gICAgICAgIGNvc1tjXSA9IGNvc0FtcDtcclxuICAgICAgICBzaW5bY10gPSBzaW5BbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzaW46IHNpbixcclxuICAgICAgICBjb3M6IGNvcyxcclxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxyXG4gICAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2luQ29zVGFibGVHZW5lcmF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9TaW5Db3NUYWJsZUdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIENoZWNrcyBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZSBvZiBlYWNoIG90aGVyLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCN3aXRoaW5cclxuKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gY2hlY2tcclxuKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGNoZWNrXHJcbiogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSAtIFRoZSB0b2xlcmFuY2UuIEFueXRoaW5nIGVxdWFsIHRvIG9yIGxlc3MgdGhhbiB0aGlzIGlzIGNvbnNpZGVyZWQgd2l0aGluIHRoZSByYW5nZS5cclxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgaXMgPD0gdG9sZXJhbmNlIG9mIGIuXHJcbiogQHNlZSB7QGxpbmsgUGhhc2VyLk1hdGguZnV6enlFcXVhbH1cclxuKi9cclxudmFyIFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBiLCB0b2xlcmFuY2UpXHJcbntcclxuICAgIHJldHVybiAoTWF0aC5hYnMoYSAtIGIpIDw9IHRvbGVyYW5jZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdpdGhpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL1dpdGhpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL0JldHdlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDY1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQyLnkgLSBwb2ludDEueSwgcG9pbnQyLnggLSBwb2ludDEueCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5Qb2ludHM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5Qb2ludHNZID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxyXG57XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludDIueCAtIHBvaW50MS54LCBwb2ludDIueSAtIHBvaW50MS55KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlblBvaW50c1k7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzWS5qc1xuLy8gbW9kdWxlIGlkID0gNjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuWSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Milcclxue1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeDIgLSB4MSwgeTIgLSB5MSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5ZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvYW5nbGUvQmV0d2VlblkuanNcbi8vIG1vZHVsZSBpZCA9IDY2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gcmVxdWlyZSgnLi9Ob3JtYWxpemUnKTtcclxuXHJcbnZhciBSZXZlcnNlID0gZnVuY3Rpb24gKGFuZ2xlKVxyXG57XHJcbiAgICByZXR1cm4gTm9ybWFsaXplKGFuZ2xlICsgTWF0aC5QSSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJldmVyc2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9hbmdsZS9SZXZlcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxuLyoqXHJcbiogUm90YXRlcyBjdXJyZW50QW5nbGUgdG93YXJkcyB0YXJnZXRBbmdsZSwgdGFraW5nIHRoZSBzaG9ydGVzdCByb3RhdGlvbiBkaXN0YW5jZS5cclxuKiBUaGUgbGVycCBhcmd1bWVudCBpcyB0aGUgYW1vdW50IHRvIHJvdGF0ZSBieSBpbiB0aGlzIGNhbGwuXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNyb3RhdGVUb0FuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRBbmdsZSAtIFRoZSBjdXJyZW50IGFuZ2xlLCBpbiByYWRpYW5zLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRBbmdsZSAtIFRoZSB0YXJnZXQgYW5nbGUgdG8gcm90YXRlIHRvLCBpbiByYWRpYW5zLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbGVycD0wLjA1XSAtIFRoZSBsZXJwIHZhbHVlIHRvIGFkZCB0byB0aGUgY3VycmVudCBhbmdsZS5cclxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhZGp1c3RlZCBhbmdsZS5cclxuKi9cclxudmFyIFJvdGF0ZVRvID0gZnVuY3Rpb24gKGN1cnJlbnRBbmdsZSwgdGFyZ2V0QW5nbGUsIGxlcnApXHJcbntcclxuICAgIGlmIChsZXJwID09PSB1bmRlZmluZWQpIHsgbGVycCA9IDAuMDU7IH1cclxuXHJcbiAgICBpZiAoY3VycmVudEFuZ2xlID09PSB0YXJnZXRBbmdsZSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNYXRoLmFicyh0YXJnZXRBbmdsZSAtIGN1cnJlbnRBbmdsZSkgPD0gbGVycCB8fCBNYXRoLmFicyh0YXJnZXRBbmdsZSAtIGN1cnJlbnRBbmdsZSkgPj0gKE1BVEhfQ09OU1QuUEkyIC0gbGVycCkpXHJcbiAgICB7XHJcbiAgICAgICAgY3VycmVudEFuZ2xlID0gdGFyZ2V0QW5nbGU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+IE1hdGguUEkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5nbGUgPCBjdXJyZW50QW5nbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlICs9IE1BVEhfQ09OU1QuUEkyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QW5nbGUgLT0gTUFUSF9DT05TVC5QSTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXRBbmdsZSA+IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBbmdsZSArPSBsZXJwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBbmdsZSAtPSBsZXJwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzXG4vLyBtb2R1bGUgaWQgPSA2NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogR2V0cyB0aGUgc2hvcnRlc3QgYW5nbGUgYmV0d2VlbiBgYW5nbGUxYCBhbmQgYGFuZ2xlMmAuXHJcbiogQm90aCBhbmdsZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAsIHdoaWNoIGlzIHRoZSBzYW1lIGNsYW1wZWRcclxuKiByYW5nZSB0aGF0IGBzcHJpdGUuYW5nbGVgIHVzZXMsIHNvIHlvdSBjYW4gcGFzcyBpbiB0d28gc3ByaXRlIGFuZ2xlcyB0b1xyXG4qIHRoaXMgbWV0aG9kLCBhbmQgZ2V0IHRoZSBzaG9ydGVzdCBhbmdsZSBiYWNrIGJldHdlZW4gdGhlIHR3byBvZiB0aGVtLlxyXG4qXHJcbiogVGhlIGFuZ2xlIHJldHVybmVkIHdpbGwgYmUgaW4gdGhlIHNhbWUgcmFuZ2UuIElmIHRoZSByZXR1cm5lZCBhbmdsZSBpc1xyXG4qIGdyZWF0ZXIgdGhhbiAwIHRoZW4gaXQncyBhIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLCBpZiA8IDAgdGhlbiBpdCdzXHJcbiogYSBjbG9ja3dpc2Ugcm90YXRpb24uXHJcbiogXHJcbiogQG1ldGhvZCBQaGFzZXIuTWF0aCNnZXRTaG9ydGVzdEFuZ2xlXHJcbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlMSAtIFRoZSBmaXJzdCBhbmdsZS4gSW4gdGhlIHJhbmdlIC0xODAgdG8gMTgwLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTIgLSBUaGUgc2Vjb25kIGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXHJcbiogQHJldHVybiB7bnVtYmVyfSBUaGUgc2hvcnRlc3QgYW5nbGUsIGluIGRlZ3JlZXMuIElmIGdyZWF0ZXIgdGhhbiB6ZXJvIGl0J3MgYSBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cclxuKi9cclxudmFyIFNob3J0ZXN0QmV0d2VlbiA9IGZ1bmN0aW9uIChhbmdsZTEsIGFuZ2xlMilcclxue1xyXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBhbmdsZTIgLSBhbmdsZTE7XHJcblxyXG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigoZGlmZmVyZW5jZSAtICgtMTgwKSkgLyAzNjApO1xyXG5cclxuICAgIHJldHVybiBkaWZmZXJlbmNlIC0gKHRpbWVzICogMzYwKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0ZXN0QmV0d2VlbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL1Nob3J0ZXN0QmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vQmV0d2VlbicpLFxyXG4gICAgQmV0d2Vlblk6IHJlcXVpcmUoJy4vQmV0d2VlblknKSxcclxuICAgIEJldHdlZW5Qb2ludHM6IHJlcXVpcmUoJy4vQmV0d2VlblBvaW50cycpLFxyXG4gICAgQmV0d2VlblBvaW50c1k6IHJlcXVpcmUoJy4vQmV0d2VlblBvaW50c1knKSxcclxuICAgIFJldmVyc2U6IHJlcXVpcmUoJy4vUmV2ZXJzZScpLFxyXG4gICAgUm90YXRlVG86IHJlcXVpcmUoJy4vUm90YXRlVG8nKSxcclxuICAgIFNob3J0ZXN0QmV0d2VlbjogcmVxdWlyZSgnLi9TaG9ydGVzdEJldHdlZW4nKSxcclxuICAgIE5vcm1hbGl6ZTogcmVxdWlyZSgnLi9Ob3JtYWxpemUnKSxcclxuICAgIFdyYXA6IHJlcXVpcmUoJy4vV3JhcCcpLFxyXG4gICAgV3JhcERlZ3JlZXM6IHJlcXVpcmUoJy4vV3JhcERlZ3JlZXMnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2FuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlUG93ZXIgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHBvdylcclxue1xyXG4gICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKSB7IHBvdyA9IDI7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIHBvdykgKyBNYXRoLnBvdyh5MiAtIHkxLCBwb3cpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VQb3dlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxyXG57XHJcbiAgICB2YXIgZHggPSB4MSAtIHgyO1xyXG4gICAgdmFyIGR5ID0geTEgLSB5MjtcclxuXHJcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlU3F1YXJlZDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlU3F1YXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vRGlzdGFuY2VCZXR3ZWVuJyksXHJcbiAgICBQb3dlcjogcmVxdWlyZSgnLi9EaXN0YW5jZVBvd2VyJyksXHJcbiAgICBTcXVhcmVkOiByZXF1aXJlKCcuL0Rpc3RhbmNlU3F1YXJlZCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZGlzdGFuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmFjayA9IHJlcXVpcmUoJy4vQmFjaycpO1xyXG52YXIgQm91bmNlID0gcmVxdWlyZSgnLi9Cb3VuY2UnKTtcclxudmFyIENpcmN1bGFyID0gcmVxdWlyZSgnLi9DaXJjdWxhcicpO1xyXG52YXIgQ3ViaWMgPSByZXF1aXJlKCcuL0N1YmljJyk7XHJcbnZhciBFbGFzdGljID0gcmVxdWlyZSgnLi9FbGFzdGljJyk7XHJcbnZhciBFeHBvID0gcmVxdWlyZSgnLi9FeHBvJyk7XHJcbnZhciBMaW5lYXIgPSByZXF1aXJlKCcuL0xpbmVhcicpO1xyXG52YXIgUXVhZHJhdGljID0gcmVxdWlyZSgnLi9RdWFkcmF0aWMnKTtcclxudmFyIFF1YXJ0aWMgPSByZXF1aXJlKCcuL1F1YXJ0aWMnKTtcclxudmFyIFF1aW50aWMgPSByZXF1aXJlKCcuL1F1aW50aWMnKTtcclxudmFyIFNpbmUgPSByZXF1aXJlKCcuL1NpbmUnKTtcclxuXHJcbi8vICBFYXNlTWFwXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIFBvd2VyMDogTGluZWFyLFxyXG4gICAgUG93ZXIxOiBRdWFkcmF0aWMuT3V0LFxyXG4gICAgUG93ZXIyOiBDdWJpYy5PdXQsXHJcbiAgICBQb3dlcjM6IFF1YXJ0aWMuT3V0LFxyXG4gICAgUG93ZXI0OiBRdWludGljLk91dCxcclxuXHJcbiAgICBMaW5lYXI6IExpbmVhcixcclxuICAgIFF1YWQ6IFF1YWRyYXRpYy5PdXQsXHJcbiAgICBDdWJpYzogQ3ViaWMuT3V0LFxyXG4gICAgUXVhcnQ6IFF1YXJ0aWMuT3V0LFxyXG4gICAgUXVpbnQ6IFF1aW50aWMuT3V0LFxyXG4gICAgU2luZTogU2luZS5PdXQsXHJcbiAgICBFeHBvOiBFeHBvLk91dCxcclxuICAgIENpcmM6IENpcmN1bGFyLk91dCxcclxuICAgIEVsYXN0aWM6IEVsYXN0aWMuT3V0LFxyXG4gICAgQmFjazogQmFjay5PdXQsXHJcbiAgICBCb3VuY2U6IEJvdW5jZS5PdXQsXHJcblxyXG4gICAgJ1F1YWQuZWFzZUluJzogUXVhZHJhdGljLkluLFxyXG4gICAgJ0N1YmljLmVhc2VJbic6IEN1YmljLkluLFxyXG4gICAgJ1F1YXJ0LmVhc2VJbic6IFF1YXJ0aWMuSW4sXHJcbiAgICAnUXVpbnQuZWFzZUluJzogUXVpbnRpYy5JbixcclxuICAgICdTaW5lLmVhc2VJbic6IFNpbmUuSW4sXHJcbiAgICAnRXhwby5lYXNlSW4nOiBFeHBvLkluLFxyXG4gICAgJ0NpcmMuZWFzZUluJzogQ2lyY3VsYXIuSW4sXHJcbiAgICAnRWxhc3RpYy5lYXNlSW4nOiBFbGFzdGljLkluLFxyXG4gICAgJ0JhY2suZWFzZUluJzogQmFjay5JbixcclxuICAgICdCb3VuY2UuZWFzZUluJzogQm91bmNlLkluLFxyXG5cclxuICAgICdRdWFkLmVhc2VPdXQnOiBRdWFkcmF0aWMuT3V0LFxyXG4gICAgJ0N1YmljLmVhc2VPdXQnOiBDdWJpYy5PdXQsXHJcbiAgICAnUXVhcnQuZWFzZU91dCc6IFF1YXJ0aWMuT3V0LFxyXG4gICAgJ1F1aW50LmVhc2VPdXQnOiBRdWludGljLk91dCxcclxuICAgICdTaW5lLmVhc2VPdXQnOiBTaW5lLk91dCxcclxuICAgICdFeHBvLmVhc2VPdXQnOiBFeHBvLk91dCxcclxuICAgICdDaXJjLmVhc2VPdXQnOiBDaXJjdWxhci5PdXQsXHJcbiAgICAnRWxhc3RpYy5lYXNlT3V0JzogRWxhc3RpYy5PdXQsXHJcbiAgICAnQmFjay5lYXNlT3V0JzogQmFjay5PdXQsXHJcbiAgICAnQm91bmNlLmVhc2VPdXQnOiBCb3VuY2UuT3V0LFxyXG5cclxuICAgICdRdWFkLmVhc2VJbk91dCc6IFF1YWRyYXRpYy5Jbk91dCxcclxuICAgICdDdWJpYy5lYXNlSW5PdXQnOiBDdWJpYy5Jbk91dCxcclxuICAgICdRdWFydC5lYXNlSW5PdXQnOiBRdWFydGljLkluT3V0LFxyXG4gICAgJ1F1aW50LmVhc2VJbk91dCc6IFF1aW50aWMuSW5PdXQsXHJcbiAgICAnU2luZS5lYXNlSW5PdXQnOiBTaW5lLkluT3V0LFxyXG4gICAgJ0V4cG8uZWFzZUluT3V0JzogRXhwby5Jbk91dCxcclxuICAgICdDaXJjLmVhc2VJbk91dCc6IENpcmN1bGFyLkluT3V0LFxyXG4gICAgJ0VsYXN0aWMuZWFzZUluT3V0JzogRWxhc3RpYy5Jbk91dCxcclxuICAgICdCYWNrLmVhc2VJbk91dCc6IEJhY2suSW5PdXQsXHJcbiAgICAnQm91bmNlLmVhc2VJbk91dCc6IEJvdW5jZS5Jbk91dFxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Vhc2luZy9FYXNlTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmFjazogcmVxdWlyZSgnLi9CYWNrJyksXHJcbiAgICBCb3VuY2U6IHJlcXVpcmUoJy4vQm91bmNlJyksXHJcbiAgICBDaXJjdWxhcjogcmVxdWlyZSgnLi9DaXJjdWxhcicpLFxyXG4gICAgQ3ViaWM6IHJlcXVpcmUoJy4vQ3ViaWMnKSxcclxuICAgIEVsYXN0aWM6IHJlcXVpcmUoJy4vRWxhc3RpYycpLFxyXG4gICAgRXhwbzogcmVxdWlyZSgnLi9FeHBvJyksXHJcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXHJcbiAgICBRdWFkcmF0aWM6IHJlcXVpcmUoJy4vUXVhZHJhdGljJyksXHJcbiAgICBRdWFydGljOiByZXF1aXJlKCcuL1F1YXJ0aWMnKSxcclxuICAgIFF1aW50aWM6IHJlcXVpcmUoJy4vUXVpbnRpYycpLFxyXG4gICAgU2luZTogcmVxdWlyZSgnLi9TaW5lJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9lYXNpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAtIGVwc2lsb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZnV6enkvQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbCA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXF1YWw7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9mdXp6eS9FcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gNjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9vciA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxyXG57XHJcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSArIGVwc2lsb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Z1enp5L0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSA2NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXHJcbntcclxuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxyXG5cclxuICAgIHJldHVybiBhID4gYiAtIGVwc2lsb247XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyZWF0ZXJUaGFuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvZnV6enkvR3JlYXRlclRoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDY3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGVzc1RoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcclxue1xyXG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XHJcblxyXG4gICAgcmV0dXJuIGEgPCBiICsgZXBzaWxvbjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGVzc1RoYW47XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9mdXp6eS9MZXNzVGhhbi5qc1xuLy8gbW9kdWxlIGlkID0gNjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIENlaWw6IHJlcXVpcmUoJy4vQ2VpbCcpLFxyXG4gICAgRXF1YWw6IHJlcXVpcmUoJy4vRXF1YWwnKSxcclxuICAgIEZsb29yOiByZXF1aXJlKCcuL0Zsb29yJyksXHJcbiAgICBHcmVhdGVyVGhhbjogcmVxdWlyZSgnLi9HcmVhdGVyVGhhbicpLFxyXG4gICAgTGVzc1RoYW46IHJlcXVpcmUoJy4vTGVzc1RoYW4nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2Z1enp5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJlcm5zdGVpbiA9IHJlcXVpcmUoJy4uL0Jlcm5zdGVpbicpO1xyXG5cclxudmFyIEJlemllckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcclxue1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGIgKz0gTWF0aC5wb3coMSAtIGssIG4gLSBpKSAqIE1hdGgucG93KGssIGkpICogdltpXSAqIEJlcm5zdGVpbihuLCBpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmV6aWVySW50ZXJwb2xhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYXRtdWxsUm9tID0gcmVxdWlyZSgnLi4vQ2F0bXVsbFJvbScpO1xyXG5cclxudmFyIENhdG11bGxSb21JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXHJcbntcclxuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGYgPSBtICogaztcclxuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcclxuXHJcbiAgICBpZiAodlswXSA9PT0gdlttXSlcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBpZiAoayA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdlswXSAtIChDYXRtdWxsUm9tKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPiAxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoQ2F0bXVsbFJvbSh2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2F0bXVsbFJvbUludGVycG9sYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2Nzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQmV6aWVyOiByZXF1aXJlKCcuL0JlemllckludGVycG9sYXRpb24nKSxcclxuICAgIENhdG11bGxSb206IHJlcXVpcmUoJy4vQ2F0bXVsbFJvbUludGVycG9sYXRpb24nKSxcclxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXJJbnRlcnBvbGF0aW9uJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRha2VzIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDJcclxuXHJcbnZhciBHZXRQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICAvLyAgTWF0aC5sb2coMilcclxuICAgIHZhciBpbmRleCA9IE1hdGgubG9nKHZhbHVlKSAvIDAuNjkzMTQ3MTgwNTU5OTQ1MztcclxuXHJcbiAgICByZXR1cm4gKDEgPDwgTWF0aC5jZWlsKGluZGV4KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvd2VyT2ZUd287XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9wb3cyL0dldFBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDY4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgSXMgdmFsdWUgYSBwb3dlciBvZiAyP1xyXG5cclxudmFyIElzVmFsdWVQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxyXG57XHJcbiAgICByZXR1cm4gKHZhbHVlID4gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJc1ZhbHVlUG93ZXJPZlR3bztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3BvdzIvSXNWYWx1ZVBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDY4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBHZXROZXh0OiByZXF1aXJlKCcuL0dldFBvd2VyT2ZUd28nKSxcclxuICAgIElzU2l6ZTogcmVxdWlyZSgnLi9Jc1NpemVQb3dlck9mVHdvJyksXHJcbiAgICBJc1ZhbHVlOiByZXF1aXJlKCcuL0lzVmFsdWVQb3dlck9mVHdvJylcclxuXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9wb3cyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2ODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IGMgLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIGMgPSAxO1xyXG5cclxuLyoqXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMwIC0gSW50ZXJuYWwgdmFyLlxyXG4qIEBwcml2YXRlXHJcbiovXHJcbnZhciBzMCA9IDA7XHJcblxyXG4vKipcclxuKiBAcHJvcGVydHkge251bWJlcn0gczEgLSBJbnRlcm5hbCB2YXIuXHJcbiogQHByaXZhdGVcclxuKi9cclxudmFyIHMxID0gMDtcclxuXHJcbi8qKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMiAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgczIgPSAwO1xyXG5cclxuLyoqXHJcbiogQHByb3BlcnR5IHtBcnJheX0gc2lnbiAtIEludGVybmFsIHZhci5cclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG52YXIgc2lnbiA9IFsgLTEsIDEgXTtcclxuXHJcbi8qKlxyXG4qIFByaXZhdGUgcmFuZG9tIGhlbHBlci5cclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijcm5kXHJcbiogQHByaXZhdGVcclxuKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiovXHJcbnZhciBybmQgPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxyXG5cclxuICAgIGMgPSB0IHwgMDtcclxuICAgIHMwID0gczE7XHJcbiAgICBzMSA9IHMyO1xyXG4gICAgczIgPSB0IC0gYztcclxuXHJcbiAgICByZXR1cm4gczI7XHJcbn07XHJcblxyXG4vKipcclxuKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgc2VlZCBoYXNoLlxyXG4qXHJcbiogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNoYXNoXHJcbiogQHByaXZhdGVcclxuKiBAcGFyYW0ge2FueX0gZGF0YVxyXG4qIEByZXR1cm4ge251bWJlcn0gaGFzaGVkIHZhbHVlLlxyXG4qL1xyXG52YXIgaGFzaCA9IGZ1bmN0aW9uIChkYXRhKVxyXG57XHJcbiAgICB2YXIgaCwgaSwgbjtcclxuICAgIG4gPSAweGVmYzgyNDlkO1xyXG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIGggKj0gbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7Ly8gMl4zMlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOy8vIDJeLTMyXHJcbn07XHJcblxyXG5cclxudmFyIFJhbmRvbURhdGFHZW5lcmF0b3IgPSBmdW5jdGlvbiAoc2VlZHMpXHJcbntcclxuICAgIGlmIChzZWVkcylcclxuICAgIHtcclxuICAgICAgICB0aGlzLmluaXQoc2VlZHMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xyXG5cclxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKHNlZWRzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VlZHMgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZShzZWVkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc293KHNlZWRzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXNldCB0aGUgc2VlZCBvZiB0aGUgcmFuZG9tIGRhdGEgZ2VuZXJhdG9yLlxyXG4gICAgKlxyXG4gICAgKiBfTm90ZV86IHRoZSBzZWVkIGFycmF5IGlzIG9ubHkgcHJvY2Vzc2VkIHVwIHRvIHRoZSBmaXJzdCBgdW5kZWZpbmVkYCAob3IgYG51bGxgKSB2YWx1ZSwgc2hvdWxkIHN1Y2ggYmUgcHJlc2VudC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzb3dcclxuICAgICogQHBhcmFtIHthbnlbXX0gc2VlZHMgLSBUaGUgYXJyYXkgb2Ygc2VlZHM6IHRoZSBgdG9TdHJpbmcoKWAgb2YgZWFjaCB2YWx1ZSBpcyB1c2VkLlxyXG4gICAgKi9cclxuICAgIHNvdzogZnVuY3Rpb24gKHNlZWRzKVxyXG4gICAge1xyXG4gICAgICAgIC8vIEFsd2F5cyByZXNldCB0byBkZWZhdWx0IHNlZWRcclxuICAgICAgICBzMCA9IGhhc2goJyAnKTtcclxuICAgICAgICBzMSA9IGhhc2goczApO1xyXG4gICAgICAgIHMyID0gaGFzaChzMSk7XHJcbiAgICAgICAgYyA9IDE7XHJcblxyXG4gICAgICAgIGlmICghc2VlZHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbnkgc2VlZHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZWRzLmxlbmd0aCAmJiAoc2VlZHNbaV0gIT0gbnVsbCk7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzZWVkID0gc2VlZHNbaV07XHJcblxyXG4gICAgICAgICAgICBzMCAtPSBoYXNoKHNlZWQpO1xyXG4gICAgICAgICAgICBzMCArPSB+fihzMCA8IDApO1xyXG4gICAgICAgICAgICBzMSAtPSBoYXNoKHNlZWQpO1xyXG4gICAgICAgICAgICBzMSArPSB+fihzMSA8IDApO1xyXG4gICAgICAgICAgICBzMiAtPSBoYXNoKHNlZWQpO1xyXG4gICAgICAgICAgICBzMiArPSB+fihzMiA8IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2ludGVnZXJcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICovXHJcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIDJeMzJcclxuICAgICAgICByZXR1cm4gcm5kKCkgKiAweDEwMDAwMDAwMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2ZyYWNcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAqL1xyXG4gICAgZnJhYzogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAyXi01M1xyXG4gICAgICAgIHJldHVybiBybmQoKSArIChybmQoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjcmVhbFxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMl4zMi5cclxuICAgICovXHJcbiAgICByZWFsOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoKSArIHRoaXMuZnJhYygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gYW5kIGluY2x1ZGluZyBtaW4gYW5kIG1heC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VySW5SYW5nZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIGludGVnZXJJblJhbmdlOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5yZWFsSW5SYW5nZSgwLCBtYXggLSBtaW4gKyAxKSArIG1pbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBhbmQgaW5jbHVkaW5nIG1pbiBhbmQgbWF4LlxyXG4gICAgKiBUaGlzIG1ldGhvZCBpcyBhbiBhbGlhcyBmb3IgUmFuZG9tRGF0YUdlbmVyYXRvci5pbnRlZ2VySW5SYW5nZS5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNiZXR3ZWVuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAgICAqL1xyXG4gICAgYmV0d2VlbjogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKG1pbiwgbWF4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyZWFsSW5SYW5nZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIHJlYWxJblJhbmdlOiBmdW5jdGlvbiAobWluLCBtYXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhYygpICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijbm9ybWFsXHJcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS5cclxuICAgICovXHJcbiAgICBub3JtYWw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSAoMiAqIHRoaXMuZnJhYygpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSB2YWxpZCBSRkM0MTIyIHZlcnNpb240IElEIGhleCBzdHJpbmcgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMzA4MzY4XHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdXVpZFxyXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nXHJcbiAgICAqL1xyXG4gICAgdXVpZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgYSA9ICcnO1xyXG4gICAgICAgIHZhciBiID0gJyc7XHJcblxyXG4gICAgICAgIGZvciAoYiA9IGEgPSAnJzsgYSsrIDwgMzY7IGIgKz1+YSAlIDUgfCBhICogMyY0ID8gKGFeMTUgPyA4XnRoaXMuZnJhYygpICogKGFeMjAgPyAxNiA6IDQpIDogNCkudG9TdHJpbmcoMTYpIDogJy0nKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBiO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSBtZW1iZXIgb2YgYGFycmF5YC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNwaWNrXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQW4gQXJyYXkgdG8gcGljayBhIHJhbmRvbSBtZW1iZXIgb2YuXHJcbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gbWVtYmVyIG9mIHRoZSBhcnJheS5cclxuICAgICovXHJcbiAgICBwaWNrOiBmdW5jdGlvbiAoYXJyYXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlckluUmFuZ2UoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHNpZ24gdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxpY2F0aW9uIG9wZXJhdG9yLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3NpZ25cclxuICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBvciArMS5cclxuICAgICovXHJcbiAgICBzaWduOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2soc2lnbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIG1lbWJlciBvZiBgYXJyYXlgLCBmYXZvcmluZyB0aGUgZWFybGllciBlbnRyaWVzLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3dlaWdodGVkUGlja1xyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxyXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIG1lbWJlciBvZiB0aGUgYXJyYXkuXHJcbiAgICAqL1xyXG4gICAgd2VpZ2h0ZWRQaWNrOiBmdW5jdGlvbiAoYXJyYXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W35+KE1hdGgucG93KHRoaXMuZnJhYygpLCAyKSAqIChhcnJheS5sZW5ndGggLSAxKSArIDAuNSldO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHJhbmRvbSB0aW1lc3RhbXAgYmV0d2VlbiBtaW4gYW5kIG1heCwgb3IgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIDIwMDAgYW5kIHRoZSBlbmQgb2YgMjAyMCBpZiBtaW4gYW5kIG1heCBhcmVuJ3Qgc3BlY2lmaWVkLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3RpbWVzdGFtcFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHRpbWVzdGFtcCBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gICAgKi9cclxuICAgIHRpbWVzdGFtcDogZnVuY3Rpb24gKG1pbiwgbWF4KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKG1pbiB8fCA5NDY2ODQ4MDAwMDAsIG1heCB8fCAxNTc3ODYyMDAwMDAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gYW5nbGUgYmV0d2VlbiAtMTgwIGFuZCAxODAuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjYW5nbGVcclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAuXHJcbiAgICAqL1xyXG4gICAgYW5nbGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlckluUmFuZ2UoLTE4MCwgMTgwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSByYW5kb20gcm90YXRpb24gaW4gcmFkaWFucywgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijcm90YXRpb25cclxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXHJcbiAgICAqL1xyXG4gICAgcm90YXRpb246IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbEluUmFuZ2UoLTMuMTQxNTkyNjUzNTg5NzkzLCAzLjE0MTU5MjY1MzU4OTc5Myk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIG9yIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRhaW4gdGhlIHZhbHVlc1xyXG4gICAgKiB0aGF0IHRoZSBnZW5lcmF0b3IgaXMgdXNpbmcgYmV0d2VlbiBnYW1lcywgaS5lLiBpbiBhIGdhbWUgc2F2ZSBmaWxlLlxyXG4gICAgKlxyXG4gICAgKiBUbyBzZWVkIHRoaXMgZ2VuZXJhdG9yIHdpdGggYSBwcmV2aW91c2x5IHNhdmVkIHN0YXRlIHlvdSBjYW4gcGFzcyBpdCBhcyB0aGVcclxuICAgICogYHNlZWRgIHZhbHVlIGluIHlvdXIgZ2FtZSBjb25maWcsIG9yIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHkgYWZ0ZXIgUGhhc2VyIGhhcyBib290ZWQuXHJcbiAgICAqXHJcbiAgICAqIENhbGwgdGhpcyBtZXRob2Qgd2l0aCBubyBwYXJhbWV0ZXJzIHRvIHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgICpcclxuICAgICogSWYgcHJvdmlkaW5nIGEgc3RhdGUgaXQgc2hvdWxkIG1hdGNoIHRoZSBzYW1lIGZvcm1hdCB0aGF0IHRoaXMgbWV0aG9kXHJcbiAgICAqIHJldHVybnMsIHdoaWNoIGlzIGEgc3RyaW5nIHdpdGggYSBoZWFkZXIgYCFybmRgIGZvbGxvd2VkIGJ5IHRoZSBgY2AsXHJcbiAgICAqIGBzMGAsIGBzMWAgYW5kIGBzMmAgdmFsdWVzIHJlc3BlY3RpdmVseSwgZWFjaCBjb21tYS1kZWxpbWl0ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijc3RhdGVcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV0gLSBHZW5lcmF0b3Igc3RhdGUgdG8gYmUgc2V0LlxyXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXHJcbiAgICAqL1xyXG4gICAgc3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSAnc3RyaW5nJyAmJiBzdGF0ZS5tYXRjaCgvXiFybmQvKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgICAgICAgIGMgPSBwYXJzZUZsb2F0KHN0YXRlWzFdKTtcclxuICAgICAgICAgICAgczAgPSBwYXJzZUZsb2F0KHN0YXRlWzJdKTtcclxuICAgICAgICAgICAgczEgPSBwYXJzZUZsb2F0KHN0YXRlWzNdKTtcclxuICAgICAgICAgICAgczIgPSBwYXJzZUZsb2F0KHN0YXRlWzRdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbICchcm5kJywgYywgczAsIHMxLCBzMiBdLmpvaW4oJywnKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbURhdGFHZW5lcmF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwQ2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZ2FwLCBzdGFydClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcblxyXG4gICAgaWYgKGdhcCA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWUgLT0gc3RhcnQ7XHJcbiAgICB2YWx1ZSA9IGdhcCAqIE1hdGguY2VpbCh2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBDZWlsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG5cclxuICAgIGlmIChnYXAgPT09IDApXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlIC09IHN0YXJ0O1xyXG4gICAgdmFsdWUgPSBnYXAgKiBNYXRoLmZsb29yKHZhbHVlIC8gZ2FwKTtcclxuXHJcbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL21hdGgvc25hcC9TbmFwRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDY4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU25hcFRvID0gZnVuY3Rpb24gKHZhbHVlLCBnYXAsIHN0YXJ0KVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuXHJcbiAgICBpZiAoZ2FwID09PSAwKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSAtPSBzdGFydDtcclxuICAgIHZhbHVlID0gZ2FwICogTWF0aC5yb3VuZCh2YWx1ZSAvIGdhcCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXJ0ICsgdmFsdWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBUbztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3NuYXAvU25hcFRvLmpzXG4vLyBtb2R1bGUgaWQgPSA2ODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9TbmFwQ2VpbCcpLFxyXG4gICAgRmxvb3I6IHJlcXVpcmUoJy4vU25hcEZsb29yJyksXHJcbiAgICBUbzogcmVxdWlyZSgnLi9TbmFwVG8nKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL3BvbHlmaWxscycpO1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG52YXIgRXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XHJcblxyXG4vLyAgVGhpcyBvYmplY3QgaXMgZXhwb3J0ZWQgZ2xvYmFsbHlcclxuXHJcbnZhciBQaGFzZXIgPSB7XHJcblxyXG4gICAgQWN0aW9uczogcmVxdWlyZSgnLi9hY3Rpb25zLycpLFxyXG5cclxuICAgIENyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUvJyksXHJcblxyXG4gICAgRE9NOiByZXF1aXJlKCcuL2RvbS8nKSxcclxuXHJcbiAgICBHYW1lOiByZXF1aXJlKCcuL2Jvb3QvR2FtZScpLFxyXG5cclxuICAgIEV2ZW50OiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudCcpLFxyXG4gICAgRXZlbnREaXNwYXRjaGVyOiByZXF1aXJlKCcuL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKSxcclxuXHJcbiAgICBNYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcclxuXHJcbiAgICBDb21wb25lbnRzOiByZXF1aXJlKCcuL2NvbXBvbmVudHMnKSxcclxuXHJcbiAgICBHZW9tOiByZXF1aXJlKCcuL2dlb20nKSxcclxuXHJcbiAgICBHcmFwaGljczogcmVxdWlyZSgnLi9ncmFwaGljcycpLFxyXG5cclxuICAgIElucHV0OiByZXF1aXJlKCcuL2lucHV0JyksXHJcblxyXG4gICAgR2FtZU9iamVjdHM6IHJlcXVpcmUoJy4vZ2FtZW9iamVjdHMnKSxcclxuXHJcbiAgICBTdGF0ZTogcmVxdWlyZSgnLi9zdGF0ZS9TdGF0ZScpLFxyXG5cclxuICAgIExvYWRlcjoge1xyXG5cclxuICAgICAgICBJbWFnZUZpbGU6IHJlcXVpcmUoJy4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUnKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgU291bmQ6IHJlcXVpcmUoJy4vc291bmQnKSxcclxuXHJcbiAgICBQaHlzaWNzOiByZXF1aXJlKCcuL3BoeXNpY3MnKSxcclxuXHJcbiAgICBDbGFzczogcmVxdWlyZSgnLi91dGlscy9DbGFzcycpLFxyXG5cclxuICAgIFV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJylcclxuXHJcbn07XHJcblxyXG4vLyAgIE1lcmdlIGluIHRoZSBjb25zdHNcclxuXHJcblBoYXNlciA9IEV4dGVuZChmYWxzZSwgUGhhc2VyLCBDT05TVCk7XHJcblxyXG4vLyAgRXhwb3J0IGl0XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBoYXNlcjtcclxuXHJcbmdsb2JhbC5QaGFzZXIgPSBQaGFzZXI7XHJcblxyXG4vKlxyXG4gKiBcIkRvY3VtZW50YXRpb24gaXMgbGlrZSBzZXg6ICB3aGVuIGl0IGlzIGdvb2QsIGl0IGlzIHZlcnksIHZlcnkgZ29vZDtcclxuICogYW5kIHdoZW4gaXQgaXMgYmFkLCBpdCBpcyBiZXR0ZXIgdGhhbiBub3RoaW5nLlwiXHJcbiAqICAtLSBEaWNrIEJyYW5kb25cclxuICovXHJcblxyXG4vKlxyXG4gKiBcIlNvbWV0aW1lcywgdGhlIGVsZWdhbnQgaW1wbGVtZW50YXRpb24gaXMganVzdCBhIGZ1bmN0aW9uLlxyXG4gKiBOb3QgYSBtZXRob2QuIE5vdCBhIGNsYXNzLiBOb3QgYSBmcmFtZXdvcmsuIEp1c3QgYSBmdW5jdGlvbi5cIlxyXG4gKiAgLS0gSm9obiBDYXJtYWNrXHJcbiAqL1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoYXNlci5qc1xuLy8gbW9kdWxlIGlkID0gNjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIID0gMC41O1xyXG52YXIgTiA9IDEgLyAzO1xyXG52YXIgTSA9IDIgLyAzO1xyXG5cclxuLy8gIFRpbGUgSUQgdG8gU2xvcGUgZGVmcy5cclxuLy8gIEZpcnN0IDQgZWxlbWVudHMgPSBsaW5lIGRhdGEsIGZpbmFsID0gc29saWQgb3Igbm9uLXNvbGlkIGJlaGluZCB0aGUgbGluZVxyXG4gICAgXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIDI6IFsgMCwgMSwgMSwgMCwgdHJ1ZSBdLFxyXG4gICAgMzogWyAwLCAxLCAxLCBILCB0cnVlIF0sXHJcbiAgICA0OiBbIDAsIEgsIDEsIDAsIHRydWUgXSxcclxuICAgIDU6IFsgMCwgMSwgMSwgTSwgdHJ1ZSBdLFxyXG4gICAgNjogWyAwLCBNLCAxLCBOLCB0cnVlIF0sXHJcbiAgICA3OiBbIDAsIE4sIDEsIDAsIHRydWUgXSxcclxuICAgIDg6IFsgSCwgMSwgMCwgMCwgdHJ1ZSBdLFxyXG4gICAgOTogWyAxLCAwLCBILCAxLCB0cnVlIF0sXHJcbiAgICAxMDogWyBILCAxLCAxLCAwLCB0cnVlIF0sXHJcbiAgICAxMTogWyAwLCAwLCBILCAxLCB0cnVlIF0sXHJcbiAgICAxMjogWyAwLCAwLCAxLCAwLCBmYWxzZSBdLFxyXG4gICAgMTM6IFsgMSwgMSwgMCwgMCwgdHJ1ZSBdLFxyXG4gICAgMTQ6IFsgMSwgSCwgMCwgMCwgdHJ1ZSBdLFxyXG4gICAgMTU6IFsgMSwgMSwgMCwgSCwgdHJ1ZSBdLFxyXG4gICAgMTY6IFsgMSwgTiwgMCwgMCwgdHJ1ZSBdLFxyXG4gICAgMTc6IFsgMSwgTSwgMCwgTiwgdHJ1ZSBdLFxyXG4gICAgMTg6IFsgMSwgMSwgMCwgTSwgdHJ1ZSBdLFxyXG4gICAgMTk6IFsgMSwgMSwgSCwgMCwgdHJ1ZSBdLFxyXG4gICAgMjA6IFsgSCwgMCwgMCwgMSwgdHJ1ZSBdLFxyXG4gICAgMjE6IFsgMCwgMSwgSCwgMCwgdHJ1ZSBdLFxyXG4gICAgMjI6IFsgSCwgMCwgMSwgMSwgdHJ1ZSBdLFxyXG4gICAgMjM6IFsgMSwgMSwgMCwgMSwgZmFsc2UgXSxcclxuICAgIDI0OiBbIDAsIDAsIDEsIDEsIHRydWUgXSxcclxuICAgIDI1OiBbIDAsIDAsIDEsIEgsIHRydWUgXSxcclxuICAgIDI2OiBbIDAsIEgsIDEsIDEsIHRydWUgXSxcclxuICAgIDI3OiBbIDAsIDAsIDEsIE4sIHRydWUgXSxcclxuICAgIDI4OiBbIDAsIE4sIDEsIE0sIHRydWUgXSxcclxuICAgIDI5OiBbIDAsIE0sIDEsIDEsIHRydWUgXSxcclxuICAgIDMwOiBbIE4sIDEsIDAsIDAsIHRydWUgXSxcclxuICAgIDMxOiBbIDEsIDAsIE0sIDEsIHRydWUgXSxcclxuICAgIDMyOiBbIE0sIDEsIDEsIDAsIHRydWUgXSxcclxuICAgIDMzOiBbIDAsIDAsIE4sIDEsIHRydWUgXSxcclxuICAgIDM0OiBbIDEsIDAsIDEsIDEsIGZhbHNlIF0sXHJcbiAgICAzNTogWyAxLCAwLCAwLCAxLCB0cnVlIF0sXHJcbiAgICAzNjogWyAxLCBILCAwLCAxLCB0cnVlIF0sXHJcbiAgICAzNzogWyAxLCAwLCAwLCBILCB0cnVlIF0sXHJcbiAgICAzODogWyAxLCBNLCAwLCAxLCB0cnVlIF0sXHJcbiAgICAzOTogWyAxLCBOLCAwLCBNLCB0cnVlIF0sXHJcbiAgICA0MDogWyAxLCAwLCAwLCBOLCB0cnVlIF0sXHJcbiAgICA0MTogWyBNLCAxLCBOLCAwLCB0cnVlIF0sXHJcbiAgICA0MjogWyBNLCAwLCBOLCAxLCB0cnVlIF0sXHJcbiAgICA0MzogWyBOLCAxLCBNLCAwLCB0cnVlIF0sXHJcbiAgICA0NDogWyBOLCAwLCBNLCAxLCB0cnVlIF0sXHJcbiAgICA0NTogWyAwLCAxLCAwLCAwLCBmYWxzZSBdLFxyXG4gICAgNTI6IFsgMSwgMSwgTSwgMCwgdHJ1ZSBdLFxyXG4gICAgNTM6IFsgTiwgMCwgMCwgMSwgdHJ1ZSBdLFxyXG4gICAgNTQ6IFsgMCwgMSwgTiwgMCwgdHJ1ZSBdLFxyXG4gICAgNTU6IFsgTSwgMCwgMSwgMSwgdHJ1ZSBdXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L0RlZmF1bHREZWZzLmpzXG4vLyBtb2R1bGUgaWQgPSA2ODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYW1wID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9DbGFtcCcpO1xyXG5cclxudmFyIEdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKGRlbHRhLCB2ZWwsIGFjY2VsLCBmcmljdGlvbiwgbWF4KVxyXG57XHJcbiAgICBpZiAoYWNjZWwpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIENsYW1wKHZlbCArIGFjY2VsICogZGVsdGEsIC1tYXgsIG1heCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmcmljdGlvbilcclxuICAgIHtcclxuICAgICAgICB2YXIgZnJpY3Rpb25EZWx0YSA9IGZyaWN0aW9uICogZGVsdGE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHZlbCAtIGZyaWN0aW9uRGVsdGEgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlbCAtIGZyaWN0aW9uRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZlbCArIGZyaWN0aW9uRGVsdGEgPCAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlbCArIGZyaWN0aW9uRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQ2xhbXAodmVsLCAtbWF4LCBtYXgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRWZWxvY2l0eTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9HZXRWZWxvY2l0eS5qc1xuLy8gbW9kdWxlIGlkID0gNjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG52YXIgU2VwZXJhdGVYID0gZnVuY3Rpb24gKHdvcmxkLCBsZWZ0LCByaWdodCwgd2Vhaylcclxue1xyXG4gICAgdmFyIG51ZGdlID0gbGVmdC5wb3MueCArIGxlZnQuc2l6ZS54IC0gcmlnaHQucG9zLng7XHJcbiAgICBcclxuICAgIC8vIFdlIGhhdmUgYSB3ZWFrIGVudGl0eSwgc28ganVzdCBtb3ZlIHRoaXMgb25lXHJcbiAgICBpZiAod2VhaylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3Ryb25nID0gKGxlZnQgPT09IHdlYWspID8gcmlnaHQgOiBsZWZ0O1xyXG5cclxuICAgICAgICB3ZWFrLnZlbC54ID0gLXdlYWsudmVsLnggKiB3ZWFrLmJvdW5jaW5lc3MgKyBzdHJvbmcudmVsLng7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc1dlYWsgPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2Uod2Vhay5wb3MueCwgd2Vhay5wb3MueSwgd2VhayA9PT0gbGVmdCA/IC1udWRnZSA6IG51ZGdlLCAwLCB3ZWFrLnNpemUueCwgd2Vhay5zaXplLnkpO1xyXG5cclxuICAgICAgICB3ZWFrLnBvcy54ID0gcmVzV2Vhay5wb3MueDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICB2YXIgdjIgPSAobGVmdC52ZWwueCAtIHJpZ2h0LnZlbC54KSAvIDI7XHJcblxyXG4gICAgICAgIGxlZnQudmVsLnggPSAtdjI7XHJcbiAgICAgICAgcmlnaHQudmVsLnggPSB2MjtcclxuICAgIFxyXG4gICAgICAgIHZhciByZXNMZWZ0ID0gd29ybGQuY29sbGlzaW9uTWFwLnRyYWNlKGxlZnQucG9zLngsIGxlZnQucG9zLnksIC1udWRnZSAvIDIsIDAsIGxlZnQuc2l6ZS54LCBsZWZ0LnNpemUueSk7XHJcblxyXG4gICAgICAgIGxlZnQucG9zLnggPSBNYXRoLmZsb29yKHJlc0xlZnQucG9zLngpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXNSaWdodCA9IHdvcmxkLmNvbGxpc2lvbk1hcC50cmFjZShyaWdodC5wb3MueCwgcmlnaHQucG9zLnksIG51ZGdlIC8gMiwgMCwgcmlnaHQuc2l6ZS54LCByaWdodC5zaXplLnkpO1xyXG5cclxuICAgICAgICByaWdodC5wb3MueCA9IE1hdGguY2VpbChyZXNSaWdodC5wb3MueCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlcGVyYXRlWDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL2ltcGFjdC9TZXBlcmF0ZVguanNcbi8vIG1vZHVsZSBpZCA9IDY5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIFNlcGVyYXRlWSA9IGZ1bmN0aW9uICh3b3JsZCwgdG9wLCBib3R0b20sIHdlYWspXHJcbntcclxuICAgIHZhciBudWRnZSA9ICh0b3AucG9zLnkgKyB0b3Auc2l6ZS55IC0gYm90dG9tLnBvcy55KTtcclxuICAgIHZhciBudWRnZVg7XHJcbiAgICB2YXIgcmVzVG9wO1xyXG4gICAgXHJcbiAgICBpZiAod2VhaylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3Ryb25nID0gKHRvcCA9PT0gd2VhaykgPyBib3R0b20gOiB0b3A7XHJcblxyXG4gICAgICAgIHdlYWsudmVsLnkgPSAtd2Vhay52ZWwueSAqIHdlYWsuYm91bmNpbmVzcyArIHN0cm9uZy52ZWwueTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSaWRpbmcgb24gYSBwbGF0Zm9ybT9cclxuICAgICAgICBudWRnZVggPSAwO1xyXG5cclxuICAgICAgICBpZiAod2VhayA9PT0gdG9wICYmIE1hdGguYWJzKHdlYWsudmVsLnkgLSBzdHJvbmcudmVsLnkpIDwgd2Vhay5taW5Cb3VuY2VWZWxvY2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdlYWsuc3RhbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBudWRnZVggPSBzdHJvbmcudmVsLnggKiB3b3JsZC5kZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc1dlYWsgPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2Uod2Vhay5wb3MueCwgd2Vhay5wb3MueSwgbnVkZ2VYLCB3ZWFrID09PSB0b3AgPyAtbnVkZ2UgOiBudWRnZSwgd2Vhay5zaXplLngsIHdlYWsuc2l6ZS55KTtcclxuXHJcbiAgICAgICAgd2Vhay5wb3MueSA9IHJlc1dlYWsucG9zLnk7XHJcbiAgICAgICAgd2Vhay5wb3MueCA9IHJlc1dlYWsucG9zLng7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3b3JsZC5ncmF2aXR5ICYmIChib3R0b20uc3RhbmRpbmcgfHwgdG9wLnZlbC55ID4gMCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmVzVG9wID0gd29ybGQuY29sbGlzaW9uTWFwLnRyYWNlKHRvcC5wb3MueCwgdG9wLnBvcy55LCAwLCAtKHRvcC5wb3MueSArIHRvcC5zaXplLnkgLSBib3R0b20ucG9zLnkpLCB0b3Auc2l6ZS54LCB0b3Auc2l6ZS55KTtcclxuXHJcbiAgICAgICAgdG9wLnBvcy55ID0gcmVzVG9wLnBvcy55O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0b3AuYm91bmNpbmVzcyA+IDAgJiYgdG9wLnZlbC55ID4gdG9wLm1pbkJvdW5jZVZlbG9jaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9wLnZlbC55ICo9IC10b3AuYm91bmNpbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdG9wLnN0YW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdG9wLnZlbC55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHYyID0gKHRvcC52ZWwueSAtIGJvdHRvbS52ZWwueSkgLyAyO1xyXG5cclxuICAgICAgICB0b3AudmVsLnkgPSAtdjI7XHJcbiAgICAgICAgYm90dG9tLnZlbC55ID0gdjI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbnVkZ2VYID0gYm90dG9tLnZlbC54ICogd29ybGQuZGVsdGE7XHJcblxyXG4gICAgICAgIHJlc1RvcCA9IHdvcmxkLmNvbGxpc2lvbk1hcC50cmFjZSh0b3AucG9zLngsIHRvcC5wb3MueSwgbnVkZ2VYLCAtbnVkZ2UgLyAyLCB0b3Auc2l6ZS54LCB0b3Auc2l6ZS55KTtcclxuXHJcbiAgICAgICAgdG9wLnBvcy55ID0gcmVzVG9wLnBvcy55O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXNCb3R0b20gPSB3b3JsZC5jb2xsaXNpb25NYXAudHJhY2UoYm90dG9tLnBvcy54LCBib3R0b20ucG9zLnksIDAsIG51ZGdlIC8gMiwgYm90dG9tLnNpemUueCwgYm90dG9tLnNpemUueSk7XHJcblxyXG4gICAgICAgIGJvdHRvbS5wb3MueSA9IHJlc0JvdHRvbS5wb3MueTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VwZXJhdGVZO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L1NlcGVyYXRlWS5qc1xuLy8gbW9kdWxlIGlkID0gNjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXBlcmF0ZVggPSByZXF1aXJlKCcuL1NlcGVyYXRlWCcpO1xyXG52YXIgU2VwZXJhdGVZID0gcmVxdWlyZSgnLi9TZXBlcmF0ZVknKTtcclxudmFyIENPTExJREVTID0gcmVxdWlyZSgnLi9DT0xMSURFUycpO1xyXG5cclxuLy8gIEltcGFjdCBQaHlzaWNzIFNvbHZlclxyXG5cclxudmFyIFNvbHZlciA9IGZ1bmN0aW9uICh3b3JsZCwgYm9keUEsIGJvZHlCKVxyXG57XHJcbiAgICB2YXIgd2VhayA9IG51bGw7XHJcblxyXG4gICAgaWYgKGJvZHlBLmNvbGxpZGVzID09PSBDT0xMSURFUy5MSVRFIHx8IGJvZHlCLmNvbGxpZGVzID09PSBDT0xMSURFUy5GSVhFRClcclxuICAgIHtcclxuICAgICAgICB3ZWFrID0gYm9keUE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib2R5Qi5jb2xsaWRlcyA9PT0gQ09MTElERVMuTElURSB8fCBib2R5QS5jb2xsaWRlcyA9PT0gQ09MTElERVMuRklYRUQpXHJcbiAgICB7XHJcbiAgICAgICAgd2VhayA9IGJvZHlCO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChib2R5QS5sYXN0LnggKyBib2R5QS5zaXplLnggPiBib2R5Qi5sYXN0LnggJiYgYm9keUEubGFzdC54IDwgYm9keUIubGFzdC54ICsgYm9keUIuc2l6ZS54KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChib2R5QS5sYXN0LnkgPCBib2R5Qi5sYXN0LnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXBlcmF0ZVkod29ybGQsIGJvZHlBLCBib2R5Qiwgd2Vhayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNlcGVyYXRlWSh3b3JsZCwgYm9keUIsIGJvZHlBLCB3ZWFrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJvZHlBLmNvbGxpZGVXaXRoKGJvZHlCLCAneScpO1xyXG4gICAgICAgIGJvZHlCLmNvbGxpZGVXaXRoKGJvZHlBLCAneScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keUEubGFzdC55ICsgYm9keUEuc2l6ZS55ID4gYm9keUIubGFzdC55ICYmIGJvZHlBLmxhc3QueSA8IGJvZHlCLmxhc3QueSArIGJvZHlCLnNpemUueSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYm9keUEubGFzdC54IDwgYm9keUIubGFzdC54KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2VwZXJhdGVYKHdvcmxkLCBib2R5QSwgYm9keUIsIHdlYWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXBlcmF0ZVgod29ybGQsIGJvZHlCLCBib2R5QSwgd2Vhayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib2R5QS5jb2xsaWRlV2l0aChib2R5QiwgJ3gnKTtcclxuICAgICAgICBib2R5Qi5jb2xsaWRlV2l0aChib2R5QSwgJ3gnKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L1NvbHZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFNldCB1cCB0aGUgdHJhY2UtcmVzdWx0XHJcbi8vIHZhciByZXMgPSB7XHJcbi8vICAgICBjb2xsaXNpb246IHt4OiBmYWxzZSwgeTogZmFsc2UsIHNsb3BlOiBmYWxzZX0sXHJcbi8vICAgICBwb3M6IHt4OiB4LCB5OiB5fSxcclxuLy8gICAgIHRpbGU6IHt4OiAwLCB5OiAwfVxyXG4vLyB9O1xyXG5cclxudmFyIFVwZGF0ZU1vdGlvbiA9IGZ1bmN0aW9uIChib2R5LCByZXMpXHJcbntcclxuICAgIGJvZHkuc3RhbmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyAgWVxyXG4gICAgaWYgKHJlcy5jb2xsaXNpb24ueSlcclxuICAgIHtcclxuICAgICAgICBpZiAoYm9keS5ib3VuY2luZXNzID4gMCAmJiBNYXRoLmFicyhib2R5LnZlbC55KSA+IGJvZHkubWluQm91bmNlVmVsb2NpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2R5LnZlbC55ICo9IC1ib2R5LmJvdW5jaW5lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChib2R5LnZlbC55ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9keS5zdGFuZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvZHkudmVsLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgWFxyXG4gICAgaWYgKHJlcy5jb2xsaXNpb24ueClcclxuICAgIHtcclxuICAgICAgICBpZiAoYm9keS5ib3VuY2luZXNzID4gMCAmJiBNYXRoLmFicyhib2R5LnZlbC54KSA+IGJvZHkubWluQm91bmNlVmVsb2NpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib2R5LnZlbC54ICo9IC1ib2R5LmJvdW5jaW5lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZHkudmVsLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgU0xPUEVcclxuICAgIGlmIChyZXMuY29sbGlzaW9uLnNsb3BlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gcmVzLmNvbGxpc2lvbi5zbG9wZTtcclxuICAgICAgIFxyXG4gICAgICAgIGlmIChib2R5LmJvdW5jaW5lc3MgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHByb2ogPSBib2R5LnZlbC54ICogcy5ueCArIGJvZHkudmVsLnkgKiBzLm55O1xyXG5cclxuICAgICAgICAgICAgYm9keS52ZWwueCA9IChib2R5LnZlbC54IC0gcy5ueCAqIHByb2ogKiAyKSAqIGJvZHkuYm91bmNpbmVzcztcclxuICAgICAgICAgICAgYm9keS52ZWwueSA9IChib2R5LnZlbC55IC0gcy5ueSAqIHByb2ogKiAyKSAqIGJvZHkuYm91bmNpbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aFNxdWFyZWQgPSBzLnggKiBzLnggKyBzLnkgKiBzLnk7XHJcbiAgICAgICAgICAgIHZhciBkb3QgPSAoYm9keS52ZWwueCAqIHMueCArIGJvZHkudmVsLnkgKiBzLnkpIC8gbGVuZ3RoU3F1YXJlZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJvZHkudmVsLnggPSBzLnggKiBkb3Q7XHJcbiAgICAgICAgICAgIGJvZHkudmVsLnkgPSBzLnkgKiBkb3Q7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHMueCwgcy55KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbmdsZSA+IGJvZHkuc2xvcGVTdGFuZGluZy5taW4gJiYgYW5nbGUgPCBib2R5LnNsb3BlU3RhbmRpbmcubWF4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5LnN0YW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5kdW1waXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwKCdzbG9wZScpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3BvcycsIHJlcy5wb3MueCwgcmVzLnBvcy55KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZlbCcsIGJvZHkudmVsLngsIGJvZHkudmVsLnkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGJvZHkucG9zID0gcmVzLnBvcztcclxuXHJcbiAgICBib2R5LnBvcy54ID0gcmVzLnBvcy54O1xyXG4gICAgYm9keS5wb3MueSA9IHJlcy5wb3MueTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlTW90aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L1VwZGF0ZU1vdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuUGh5c2ljcy5JbXBhY3QuV29ybGRcclxuXHJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XHJcbnZhciBTZXQgPSByZXF1aXJlKCcuLi8uLi9zdHJ1Y3RzL1NldCcpO1xyXG52YXIgQm9keSA9IHJlcXVpcmUoJy4vQm9keScpO1xyXG52YXIgU29sdmVyID0gcmVxdWlyZSgnLi9Tb2x2ZXInKTtcclxudmFyIENvbGxpc2lvbk1hcCA9IHJlcXVpcmUoJy4vQ29sbGlzaW9uTWFwJyk7XHJcbnZhciBDT0xMSURFUyA9IHJlcXVpcmUoJy4vQ09MTElERVMnKTtcclxudmFyIFRZUEUgPSByZXF1aXJlKCcuL1RZUEUnKTtcclxuXHJcbnZhciBXb3JsZCA9IG5ldyBDbGFzcyh7XHJcblxyXG4gICAgaW5pdGlhbGl6ZTpcclxuXHJcbiAgICBmdW5jdGlvbiBXb3JsZCAoZ3Jhdml0eSwgY2VsbFNpemUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGdyYXZpdHkgPT09IHVuZGVmaW5lZCkgeyBncmF2aXR5ID0gMDsgfVxyXG4gICAgICAgIGlmIChjZWxsU2l6ZSA9PT0gdW5kZWZpbmVkKSB7IGNlbGxTaXplID0gNjQ7IH1cclxuXHJcbiAgICAgICAgdGhpcy5ib2RpZXMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3Jhdml0eSA9IGdyYXZpdHk7XHJcblxyXG4gICAgICAgIC8vICBTcGF0aWFsIGhhc2ggY2VsbCBkaW1lbnNpb25zXHJcbiAgICAgICAgdGhpcy5jZWxsU2l6ZSA9IGNlbGxTaXplO1xyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBDb2xsaXNpb25NYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHksIHNpemVYLCBzaXplWSlcclxuICAgIHtcclxuICAgICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHRoaXMsIHgsIHksIHNpemVYLCBzaXplWSk7XHJcblxyXG4gICAgICAgIHRoaXMuYm9kaWVzLnNldChib2R5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmJvZGllcy5zaXplID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEltcGFjdCB1c2VzIGEgZGl2aWRlZCBkZWx0YSB2YWx1ZVxyXG4gICAgICAgIGRlbHRhIC89IDEwMDA7XHJcblxyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcclxuXHJcbiAgICAgICAgLy8gIFVwZGF0ZSBhbGwgYm9kaWVzXHJcblxyXG4gICAgICAgIHRoaXMuYm9kaWVzLml0ZXJhdGUoZnVuY3Rpb24gKGJvZHkpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChib2R5LmVuYWJsZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHkudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gIFJ1biBjb2xsaXNpb24gYWdhaW5zdCB0aGVtIGFsbFxyXG5cclxuICAgICAgICB2YXIgaGFzaCA9IHt9O1xyXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5jZWxsU2l6ZTtcclxuXHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5za2lwSGFzaCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tIYXNoKGJvZHksIGhhc2gsIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2hlY2sgdGhlIGJvZHkgYWdhaW5zdCB0aGUgc3BhdGlhbCBoYXNoXHJcbiAgICBjaGVja0hhc2g6IGZ1bmN0aW9uIChib2R5LCBoYXNoLCBzaXplKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjaGVja0hhc2gnKTtcclxuXHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSB7fTtcclxuICAgICAgICB2YXIgeG1pbiA9IE1hdGguZmxvb3IoYm9keS5wb3MueCAvIHNpemUpO1xyXG4gICAgICAgIHZhciB5bWluID0gTWF0aC5mbG9vcihib2R5LnBvcy55IC8gc2l6ZSk7XHJcbiAgICAgICAgdmFyIHhtYXggPSBNYXRoLmZsb29yKChib2R5LnBvcy54ICsgYm9keS5zaXplLngpIC8gc2l6ZSkgKyAxO1xyXG4gICAgICAgIHZhciB5bWF4ID0gTWF0aC5mbG9vcigoYm9keS5wb3MueSArIGJvZHkuc2l6ZS55KSAvIHNpemUpICsgMTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeCA9IHhtaW47IHggPCB4bWF4OyB4KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0geW1pbjsgeSA8IHltYXg7IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNoW3hdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hbeF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW3hdW3ldID0gWyBib2R5IF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaGFzaFt4XVt5XSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW3hdW3ldID0gWyBib2R5IF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBoYXNoW3hdW3ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbGwubGVuZ3RoOyBjKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS50b3VjaGVzKGNlbGxbY10pICYmICFjaGVja2VkW2NlbGxbY10uaWRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkW2NlbGxbY10uaWRdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQm9kaWVzKGJvZHksIGNlbGxbY10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjZWxsLnB1c2goYm9keSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrQm9kaWVzOiBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBiaXR3aXNlIGNoZWNrc1xyXG4gICAgICAgIGlmIChib2R5QS5jaGVja0FnYWluc3QgJiBib2R5Qi50eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9keUEuY2hlY2soYm9keUIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoYm9keUIuY2hlY2tBZ2FpbnN0ICYgYm9keUEudHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvZHlCLmNoZWNrKGJvZHlBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJvZHlBLmNvbGxpZGVzICYmIGJvZHlCLmNvbGxpZGVzICYmIGJvZHlBLmNvbGxpZGVzICsgYm9keUIuY29sbGlkZXMgPiBDT0xMSURFUy5BQ1RJVkUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc29sdmUnKTtcclxuICAgICAgICAgICAgU29sdmVyKHRoaXMsIGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L1dvcmxkLmpzXG4vLyBtb2R1bGUgaWQgPSA2OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5QaHlzaWNzLkltcGFjdFxyXG5cclxuLy8gIEFuIEltcGFjdC5qcyBjb21wYXRpYmxlIHBoeXNpY3Mgd29ybGQsIGJvZHkgYW5kIHNvbHZlciwgZm9yIHRob3NlIHdobyBhcmUgdXNlZFxyXG4vLyAgdG8gdGhlIEltcGFjdCB3YXkgb2YgZGVmaW5pbmcgYW5kIGNvbnRyb2xsaW5nIHBoeXNpY3MgYm9kaWVzLiBBbHNvIHdvcmtzIHdpdGhcclxuLy8gIHRoZSBuZXcgTG9hZGVyIHN1cHBvcnQgZm9yIFdlbHRtZWlzdGVyIG1hcCBkYXRhLlxyXG4vL1xyXG4vLyAgV29ybGQgdXBkYXRlZCB0byBydW4gb2ZmIHRoZSBQaGFzZXIgbWFpbiBsb29wLlxyXG4vLyAgQm9keSBleHRlbmRlZCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgc2V0dGVyIGZ1bmN0aW9ucy5cclxuLy9cclxuLy8gIFRvIGNyZWF0ZSB0aGUgbWFwIGRhdGEgeW91J2xsIG5lZWQgV2VsdG1laXN0ZXIsIHdoaWNoIGNvbWVzIHdpdGggSW1wYWN0XHJcbi8vICBhbmQgY2FuIGJlIHB1cmNoYXNlZCBmcm9tIGh0dHA6Ly9pbXBhY3Rqcy5jb21cclxuLy9cclxuLy8gIE15IHRoYW5rcyB0byBEb21pbmljIFN6YWJsZXdza2kgZm9yIGhpcyBwZXJtaXNzaW9uIHRvIHN1cHBvcnQgSW1wYWN0IGluIFBoYXNlci5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIEJvZHk6IHJlcXVpcmUoJy4vQm9keScpLFxyXG4gICAgQ09MTElERVM6IHJlcXVpcmUoJy4vQ09MTElERVMnKSxcclxuICAgIENvbGxpc2lvbk1hcDogcmVxdWlyZSgnLi9Db2xsaXNpb25NYXAnKSxcclxuICAgIFRZUEU6IHJlcXVpcmUoJy4vVFlQRScpLFxyXG4gICAgV29ybGQ6IHJlcXVpcmUoJy4vV29ybGQnKVxyXG4gIFxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvaW1wYWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2OTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuUXVlcnlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBwZXJmb3JtaW5nIGNvbGxpc2lvbiBxdWVyaWVzLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBRdWVyeVxyXG4qL1xyXG5cclxudmFyIFF1ZXJ5ID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xyXG5cclxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG52YXIgU0FUID0gcmVxdWlyZSgnLi9TQVQnKTtcclxudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG52YXIgQm9kaWVzID0gcmVxdWlyZSgnLi4vZmFjdG9yeS9Cb2RpZXMnKTtcclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGEgcmF5IHNlZ21lbnQgYWdhaW5zdCBhIHNldCBvZiBib2RpZXMgYW5kIHJldHVybnMgYWxsIGNvbGxpc2lvbnMsIHJheSB3aWR0aCBpcyBvcHRpb25hbC4gSW50ZXJzZWN0aW9uIHBvaW50cyBhcmUgbm90IHByb3ZpZGVkLlxyXG4gICAgICogQG1ldGhvZCByYXlcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBzdGFydFBvaW50XHJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZW5kUG9pbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF5V2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3RbXX0gQ29sbGlzaW9uc1xyXG4gICAgICovXHJcbiAgICBRdWVyeS5yYXkgPSBmdW5jdGlvbihib2RpZXMsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCByYXlXaWR0aCkge1xyXG4gICAgICAgIHJheVdpZHRoID0gcmF5V2lkdGggfHwgMWUtMTAwO1xyXG5cclxuICAgICAgICB2YXIgcmF5QW5nbGUgPSBWZWN0b3IuYW5nbGUoc3RhcnRQb2ludCwgZW5kUG9pbnQpLFxyXG4gICAgICAgICAgICByYXlMZW5ndGggPSBWZWN0b3IubWFnbml0dWRlKFZlY3Rvci5zdWIoc3RhcnRQb2ludCwgZW5kUG9pbnQpKSxcclxuICAgICAgICAgICAgcmF5WCA9IChlbmRQb2ludC54ICsgc3RhcnRQb2ludC54KSAqIDAuNSxcclxuICAgICAgICAgICAgcmF5WSA9IChlbmRQb2ludC55ICsgc3RhcnRQb2ludC55KSAqIDAuNSxcclxuICAgICAgICAgICAgcmF5ID0gQm9kaWVzLnJlY3RhbmdsZShyYXlYLCByYXlZLCByYXlMZW5ndGgsIHJheVdpZHRoLCB7IGFuZ2xlOiByYXlBbmdsZSB9KSxcclxuICAgICAgICAgICAgY29sbGlzaW9ucyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKGJvZHlBLmJvdW5kcywgcmF5LmJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5QS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaiA8IGJvZHlBLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5QS5wYXJ0c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhwYXJ0LmJvdW5kcywgcmF5LmJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IFNBVC5jb2xsaWRlcyhwYXJ0LCByYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24uYm9keSA9IGNvbGxpc2lvbi5ib2R5QSA9IGNvbGxpc2lvbi5ib2R5QiA9IGJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIGJvdW5kcyBhcmUgaW5zaWRlIChvciBvdXRzaWRlIGlmIHNldCkgdGhlIGdpdmVuIHNldCBvZiBib3VuZHMsIGZyb20gdGhlIGdpdmVuIHNldCBvZiBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xyXG4gICAgICogQHBhcmFtIHtib29sfSBbb3V0c2lkZT1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge2JvZHlbXX0gVGhlIGJvZGllcyBtYXRjaGluZyB0aGUgcXVlcnlcclxuICAgICAqL1xyXG4gICAgUXVlcnkucmVnaW9uID0gZnVuY3Rpb24oYm9kaWVzLCBib3VuZHMsIG91dHNpZGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIGJvdW5kcyk7XHJcbiAgICAgICAgICAgIGlmICgob3ZlcmxhcHMgJiYgIW91dHNpZGUpIHx8ICghb3ZlcmxhcHMgJiYgb3V0c2lkZSkpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIHZlcnRpY2VzIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LCBmcm9tIHRoZSBnaXZlbiBzZXQgb2YgYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBwb2ludFxyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xyXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib2R5W119IFRoZSBib2RpZXMgbWF0Y2hpbmcgdGhlIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIFF1ZXJ5LnBvaW50ID0gZnVuY3Rpb24oYm9kaWVzLCBwb2ludCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBwb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5jb250YWlucyhwYXJ0LmJvdW5kcywgcG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFZlcnRpY2VzLmNvbnRhaW5zKHBhcnQudmVydGljZXMsIHBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1F1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA2OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuTW91c2VDb25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgbW91c2UgY29uc3RyYWludHMuXHJcbiogTW91c2UgY29uc3RyYWludHMgYXJlIHVzZWQgZm9yIGFsbG93aW5nIHVzZXIgaW50ZXJhY3Rpb24sIHByb3ZpZGluZyB0aGUgYWJpbGl0eSB0byBtb3ZlIGJvZGllcyB2aWEgdGhlIG1vdXNlIG9yIHRvdWNoLlxyXG4qXHJcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cclxuKlxyXG4qIEBjbGFzcyBNb3VzZUNvbnN0cmFpbnRcclxuKi9cclxuXHJcbnZhciBNb3VzZUNvbnN0cmFpbnQgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VDb25zdHJhaW50O1xyXG5cclxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcclxudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xyXG52YXIgTW91c2UgPSByZXF1aXJlKCcuLi9jb3JlL01vdXNlJyk7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xyXG52YXIgRGV0ZWN0b3IgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vRGV0ZWN0b3InKTtcclxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcclxudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4uL2JvZHkvQ29tcG9zaXRlJyk7XHJcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1vdXNlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7TW91c2VDb25zdHJhaW50fSBBIG5ldyBNb3VzZUNvbnN0cmFpbnRcclxuICAgICAqL1xyXG4gICAgTW91c2VDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBtb3VzZSA9IChlbmdpbmUgPyBlbmdpbmUubW91c2UgOiBudWxsKSB8fCAob3B0aW9ucyA/IG9wdGlvbnMubW91c2UgOiBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKCFtb3VzZSkge1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lICYmIGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKGVuZ2luZS5yZW5kZXIuY2FudmFzKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUob3B0aW9ucy5lbGVtZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignTW91c2VDb25zdHJhaW50LmNyZWF0ZTogb3B0aW9ucy5tb3VzZSB3YXMgdW5kZWZpbmVkLCBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgbWF5IG5vdCBmdW5jdGlvbiBhcyBleHBlY3RlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29uc3RyYWludCA9IENvbnN0cmFpbnQuY3JlYXRlKHsgXHJcbiAgICAgICAgICAgIGxhYmVsOiAnTW91c2UgQ29uc3RyYWludCcsXHJcbiAgICAgICAgICAgIHBvaW50QTogbW91c2UucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgICAgIGxlbmd0aDogMC4wMSwgXHJcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4xLFxyXG4gICAgICAgICAgICBhbmd1bGFyU3RpZmZuZXNzOiAxLFxyXG4gICAgICAgICAgICByZW5kZXI6IHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnIzkwRUU5MCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZUNvbnN0cmFpbnQnLFxyXG4gICAgICAgICAgICBtb3VzZTogbW91c2UsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGJvZHk6IG51bGwsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IGNvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IDB4MDAwMSxcclxuICAgICAgICAgICAgICAgIG1hc2s6IDB4RkZGRkZGRkYsXHJcbiAgICAgICAgICAgICAgICBncm91cDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIG1vdXNlQ29uc3RyYWludCA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBFdmVudHMub24oZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZS53b3JsZCk7XHJcbiAgICAgICAgICAgIE1vdXNlQ29uc3RyYWludC51cGRhdGUobW91c2VDb25zdHJhaW50LCBhbGxCb2RpZXMpO1xyXG4gICAgICAgICAgICBfdHJpZ2dlckV2ZW50cyhtb3VzZUNvbnN0cmFpbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbW91c2VDb25zdHJhaW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIG1vdXNlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7TW91c2VDb25zdHJhaW50fSBtb3VzZUNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcclxuICAgICAqL1xyXG4gICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZSA9IGZ1bmN0aW9uKG1vdXNlQ29uc3RyYWludCwgYm9kaWVzKSB7XHJcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxyXG4gICAgICAgICAgICBjb25zdHJhaW50ID0gbW91c2VDb25zdHJhaW50LmNvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgIGJvZHkgPSBtb3VzZUNvbnN0cmFpbnQuYm9keTtcclxuXHJcbiAgICAgICAgaWYgKG1vdXNlLmJ1dHRvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBtb3VzZS5wb3NpdGlvbikgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHkuY29sbGlzaW9uRmlsdGVyLCBtb3VzZUNvbnN0cmFpbnQuY29sbGlzaW9uRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgbW91c2UucG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBtb3VzZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJvZHlCID0gbW91c2VDb25zdHJhaW50LmJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiBtb3VzZS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBtb3VzZS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5LmFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ3N0YXJ0ZHJhZycsIHsgbW91c2U6IG1vdXNlLCBib2R5OiBib2R5IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChjb25zdHJhaW50LmJvZHlCLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IG1vdXNlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3RyYWludC5ib2R5QiA9IG1vdXNlQ29uc3RyYWludC5ib2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkpXHJcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdlbmRkcmFnJywgeyBtb3VzZTogbW91c2UsIGJvZHk6IGJvZHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIG1vdXNlIGNvbnN0cmFpbnQgZXZlbnRzLlxyXG4gICAgICogQG1ldGhvZCBfdHJpZ2dlckV2ZW50c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlQ29uc3RyYWludFxyXG4gICAgICovXHJcbiAgICB2YXIgX3RyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihtb3VzZUNvbnN0cmFpbnQpIHtcclxuICAgICAgICB2YXIgbW91c2UgPSBtb3VzZUNvbnN0cmFpbnQubW91c2UsXHJcbiAgICAgICAgICAgIG1vdXNlRXZlbnRzID0gbW91c2Uuc291cmNlRXZlbnRzO1xyXG5cclxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2Vtb3ZlKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZW1vdmUnLCB7IG1vdXNlOiBtb3VzZSB9KTtcclxuXHJcbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNlZG93bilcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIobW91c2VDb25zdHJhaW50LCAnbW91c2Vkb3duJywgeyBtb3VzZTogbW91c2UgfSk7XHJcblxyXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZXVwKVxyXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZXVwJywgeyBtb3VzZTogbW91c2UgfSk7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBtb3VzZSBzdGF0ZSByZWFkeSBmb3IgdGhlIG5leHQgc3RlcFxyXG4gICAgICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzKG1vdXNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICpcclxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBoYXMgbW92ZWQgKG9yIGEgdG91Y2ggbW92ZXMpIGR1cmluZyB0aGUgbGFzdCBzdGVwXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBtb3VzZW1vdmVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyBkb3duIChvciBhIHRvdWNoIGhhcyBzdGFydGVkKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgbW91c2Vkb3duXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgdXAgKG9yIGEgdG91Y2ggaGFzIGVuZGVkKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgbW91c2V1cFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGEgYm9keVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgc3RhcnRkcmFnXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXHJcbiAgICAqIEBwYXJhbSB7Ym9keX0gZXZlbnQuYm9keSBUaGUgYm9keSBiZWluZyBkcmFnZ2VkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBlbmRzIGRyYWdnaW5nIGEgYm9keVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgZW5kZHJhZ1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxyXG4gICAgKiBAcGFyYW0ge2JvZHl9IGV2ZW50LmJvZHkgVGhlIGJvZHkgdGhhdCBoYXMgc3RvcHBlZCBiZWluZyBkcmFnZ2VkXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYE1vdXNlYCBpbnN0YW5jZSBpbiB1c2UuIElmIG5vdCBzdXBwbGllZCBpbiBgTW91c2VDb25zdHJhaW50LmNyZWF0ZWAsIG9uZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlXHJcbiAgICAgKiBAdHlwZSBtb3VzZVxyXG4gICAgICogQGRlZmF1bHQgbW91c2VcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBCb2R5YCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBtb3ZlZCBieSB0aGUgdXNlciwgb3IgYG51bGxgIGlmIG5vIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGJvZHlcclxuICAgICAqIEB0eXBlIGJvZHlcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBDb25zdHJhaW50YCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIG1vdmUgdGhlIGJvZHkgZHVyaW5nIGludGVyYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50XHJcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBUaGUgY29sbGlzaW9uIGZpbHRlciBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHdoaWNoIHR5cGVzIG9mIGJvZHkgdGhpcyBtb3VzZSBjb25zdHJhaW50IGNhbiBpbnRlcmFjdCB3aXRoLlxyXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxyXG4gICAgICogQHR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGh5c2ljcy9tYXR0ZXItanMvY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlcmAgbW9kdWxlIGlzIHRoZSB0b3AgbGV2ZWwgbmFtZXNwYWNlLiBJdCBhbHNvIGluY2x1ZGVzIGEgZnVuY3Rpb24gZm9yIGluc3RhbGxpbmcgcGx1Z2lucyBvbiB0b3Agb2YgdGhlIGxpYnJhcnkuXHJcbipcclxuKiBAY2xhc3MgTWF0dGVyXHJcbiovXHJcblxyXG52YXIgTWF0dGVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHRlcjtcclxuXHJcbnZhciBQbHVnaW4gPSByZXF1aXJlKCcuL1BsdWdpbicpO1xyXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaWJyYXJ5IG5hbWUuXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIubmFtZSA9ICdtYXR0ZXItanMnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpYnJhcnkgdmVyc2lvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJzaW9uXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci52ZXJzaW9uID0gJ0BAVkVSU0lPTkBAJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbGlzdCBvZiBwbHVnaW4gZGVwZW5kZW5jaWVzIHRvIGJlIGluc3RhbGxlZC4gVGhlc2UgYXJlIG5vcm1hbGx5IHNldCBhbmQgaW5zdGFsbGVkIHRocm91Z2ggYE1hdHRlci51c2VgLlxyXG4gICAgICogQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHNldCBgTWF0dGVyLnVzZXNgIG1hbnVhbGx5IGFuZCBpbnN0YWxsIHRoZW0gYnkgY2FsbGluZyBgUGx1Z2luLnVzZShNYXR0ZXIpYC5cclxuICAgICAqIEBwcm9wZXJ0eSB1c2VzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci51c2VzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGx1Z2lucyB0aGF0IGhhdmUgYmVlbiBpbnN0YWxsZWQgdGhyb3VnaCBgTWF0dGVyLlBsdWdpbi5pbnN0YWxsYC4gUmVhZCBvbmx5LlxyXG4gICAgICogQHByb3BlcnR5IHVzZWRcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlZCA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFsbHMgdGhlIGdpdmVuIHBsdWdpbnMgb24gdGhlIGBNYXR0ZXJgIG5hbWVzcGFjZS5cclxuICAgICAqIFRoaXMgaXMgYSBzaG9ydC1oYW5kIGZvciBgUGx1Z2luLnVzZWAsIHNlZSBpdCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIENhbGwgdGhpcyBmdW5jdGlvbiBvbmNlIGF0IHRoZSBzdGFydCBvZiB5b3VyIGNvZGUsIHdpdGggYWxsIG9mIHRoZSBwbHVnaW5zIHlvdSB3aXNoIHRvIGluc3RhbGwgYXMgYXJndW1lbnRzLlxyXG4gICAgICogQXZvaWQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHVubGVzcyB5b3UgaW50ZW5kIHRvIG1hbnVhbGx5IGNvbnRyb2wgaW5zdGFsbGF0aW9uIG9yZGVyLlxyXG4gICAgICogQG1ldGhvZCB1c2VcclxuICAgICAqIEBwYXJhbSAuLi5wbHVnaW4ge0Z1bmN0aW9ufSBUaGUgcGx1Z2luKHMpIHRvIGluc3RhbGwgb24gYGJhc2VgIChtdWx0aS1hcmd1bWVudCkuXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci51c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBQbHVnaW4udXNlKE1hdHRlciwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGJlZm9yZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgTWF0dGVyYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBiZWZvcmVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBNYXR0ZXJgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBiZWZvcmUgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcclxuICAgICAqL1xyXG4gICAgTWF0dGVyLmJlZm9yZSA9IGZ1bmN0aW9uKHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eTWF0dGVyLi8sICcnKTtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLmNoYWluUGF0aEJlZm9yZShNYXR0ZXIsIHBhdGgsIGZ1bmMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBhZnRlciB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIGdpdmVuIGBwYXRoYCByZWxhdGl2ZSB0byBgTWF0dGVyYC5cclxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxyXG4gICAgICogQG1ldGhvZCBhZnRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYE1hdHRlcmBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGFmdGVyIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci5hZnRlciA9IGZ1bmN0aW9uKHBhdGgsIGZ1bmMpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eTWF0dGVyLi8sICcnKTtcclxuICAgICAgICByZXR1cm4gQ29tbW9uLmNoYWluUGF0aEFmdGVyKE1hdHRlciwgcGF0aCwgZnVuYyk7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL01hdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBgTWF0dGVyLlJ1bm5lcmAgbW9kdWxlIGlzIGFuIG9wdGlvbmFsIHV0aWxpdHkgd2hpY2ggcHJvdmlkZXMgYSBnYW1lIGxvb3AsIFxyXG4qIHRoYXQgaGFuZGxlcyBjb250aW51b3VzbHkgdXBkYXRpbmcgYSBgTWF0dGVyLkVuZ2luZWAgZm9yIHlvdSB3aXRoaW4gYSBicm93c2VyLlxyXG4qIEl0IGlzIGludGVuZGVkIGZvciBkZXZlbG9wbWVudCBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLCBidXQgbWF5IGFsc28gYmUgc3VpdGFibGUgZm9yIHNpbXBsZSBnYW1lcy5cclxuKiBJZiB5b3UgYXJlIHVzaW5nIHlvdXIgb3duIGdhbWUgbG9vcCBpbnN0ZWFkLCB0aGVuIHlvdSBkbyBub3QgbmVlZCB0aGUgYE1hdHRlci5SdW5uZXJgIG1vZHVsZS5cclxuKiBJbnN0ZWFkIGp1c3QgY2FsbCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaW4geW91ciBvd24gbG9vcC5cclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgUnVubmVyXHJcbiovXHJcblxyXG52YXIgUnVubmVyID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcclxuXHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuL0V2ZW50cycpO1xyXG52YXIgRW5naW5lID0gcmVxdWlyZSgnLi9FbmdpbmUnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgdmFyIF9mcmFtZVRpbWVvdXQ7XHJcblxyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjayl7IFxyXG4gICAgICAgICAgICBfZnJhbWVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhDb21tb24ubm93KCkpOyBcclxuICAgICAgICAgICAgfSwgMTAwMCAvIDYwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9mcmFtZVRpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJ1bm5lci4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgUnVubmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGZwczogNjAsXHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgIGRlbHRhU2FtcGxlU2l6ZTogNjAsXHJcbiAgICAgICAgICAgIGNvdW50ZXJUaW1lc3RhbXA6IDAsXHJcbiAgICAgICAgICAgIGZyYW1lQ291bnRlcjogMCxcclxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5OiBbXSxcclxuICAgICAgICAgICAgdGltZVByZXY6IG51bGwsXHJcbiAgICAgICAgICAgIHRpbWVTY2FsZVByZXY6IDEsXHJcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxyXG4gICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBydW5uZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcnVubmVyLmRlbHRhID0gcnVubmVyLmRlbHRhIHx8IDEwMDAgLyBydW5uZXIuZnBzO1xyXG4gICAgICAgIHJ1bm5lci5kZWx0YU1pbiA9IHJ1bm5lci5kZWx0YU1pbiB8fCAxMDAwIC8gcnVubmVyLmZwcztcclxuICAgICAgICBydW5uZXIuZGVsdGFNYXggPSBydW5uZXIuZGVsdGFNYXggfHwgMTAwMCAvIChydW5uZXIuZnBzICogMC41KTtcclxuICAgICAgICBydW5uZXIuZnBzID0gMTAwMCAvIHJ1bm5lci5kZWx0YTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51b3VzbHkgdGlja3MgYSBgTWF0dGVyLkVuZ2luZWAgYnkgY2FsbGluZyBgUnVubmVyLnRpY2tgIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cclxuICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKi9cclxuICAgIFJ1bm5lci5ydW4gPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBydW5uZXIgaWYgZW5naW5lIGlzIGZpcnN0IGFyZ3VtZW50XHJcbiAgICAgICAgaWYgKHR5cGVvZiBydW5uZXIucG9zaXRpb25JdGVyYXRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBlbmdpbmUgPSBydW5uZXI7XHJcbiAgICAgICAgICAgIHJ1bm5lciA9IFJ1bm5lci5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIChmdW5jdGlvbiByZW5kZXIodGltZSl7XHJcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZVJlcXVlc3RJZCA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lICYmIHJ1bm5lci5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBSdW5uZXIudGljayhydW5uZXIsIGVuZ2luZSwgdGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcnVubmVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZ2FtZSBsb29wIHV0aWxpdHkgdGhhdCB1cGRhdGVzIHRoZSBlbmdpbmUgYW5kIHJlbmRlcmVyIGJ5IG9uZSBzdGVwIChhICd0aWNrJykuXHJcbiAgICAgKiBGZWF0dXJlcyBkZWx0YSBzbW9vdGhpbmcsIHRpbWUgY29ycmVjdGlvbiBhbmQgZml4ZWQgb3IgZHluYW1pYyB0aW1pbmcuXHJcbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlVGlja2AsIGB0aWNrYCBhbmQgYGFmdGVyVGlja2AgZXZlbnRzIG9uIHRoZSBlbmdpbmUuXHJcbiAgICAgKiBDb25zaWRlciBqdXN0IGBFbmdpbmUudXBkYXRlKGVuZ2luZSwgZGVsdGEpYCBpZiB5b3UncmUgdXNpbmcgeW91ciBvd24gbG9vcC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcclxuICAgICAqL1xyXG4gICAgUnVubmVyLnRpY2sgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSwgdGltZSkge1xyXG4gICAgICAgIHZhciB0aW1pbmcgPSBlbmdpbmUudGltaW5nLFxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMSxcclxuICAgICAgICAgICAgZGVsdGE7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBvYmplY3RcclxuICAgICAgICB2YXIgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVRpY2snLCBldmVudCk7XHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcclxuXHJcbiAgICAgICAgaWYgKHJ1bm5lci5pc0ZpeGVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZpeGVkIHRpbWVzdGVwXHJcbiAgICAgICAgICAgIGRlbHRhID0gcnVubmVyLmRlbHRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgdGltZXN0ZXAgYmFzZWQgb24gd2FsbCBjbG9jayBiZXR3ZWVuIGNhbGxzXHJcbiAgICAgICAgICAgIGRlbHRhID0gKHRpbWUgLSBydW5uZXIudGltZVByZXYpIHx8IHJ1bm5lci5kZWx0YTtcclxuICAgICAgICAgICAgcnVubmVyLnRpbWVQcmV2ID0gdGltZTtcclxuXHJcbiAgICAgICAgICAgIC8vIG9wdGltaXN0aWNhbGx5IGZpbHRlciBkZWx0YSBvdmVyIGEgZmV3IGZyYW1lcywgdG8gaW1wcm92ZSBzdGFiaWxpdHlcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhSGlzdG9yeS5wdXNoKGRlbHRhKTtcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhSGlzdG9yeSA9IHJ1bm5lci5kZWx0YUhpc3Rvcnkuc2xpY2UoLXJ1bm5lci5kZWx0YVNhbXBsZVNpemUpO1xyXG4gICAgICAgICAgICBkZWx0YSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHJ1bm5lci5kZWx0YUhpc3RvcnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbGltaXQgZGVsdGFcclxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IHJ1bm5lci5kZWx0YU1pbiA/IHJ1bm5lci5kZWx0YU1pbiA6IGRlbHRhO1xyXG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhID4gcnVubmVyLmRlbHRhTWF4ID8gcnVubmVyLmRlbHRhTWF4IDogZGVsdGE7XHJcblxyXG4gICAgICAgICAgICAvLyBjb3JyZWN0aW9uIGZvciBkZWx0YVxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gZGVsdGEgLyBydW5uZXIuZGVsdGE7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgZW5naW5lIHRpbWluZyBvYmplY3RcclxuICAgICAgICAgICAgcnVubmVyLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aW1lIGNvcnJlY3Rpb24gZm9yIHRpbWUgc2NhbGluZ1xyXG4gICAgICAgIGlmIChydW5uZXIudGltZVNjYWxlUHJldiAhPT0gMClcclxuICAgICAgICAgICAgY29ycmVjdGlvbiAqPSB0aW1pbmcudGltZVNjYWxlIC8gcnVubmVyLnRpbWVTY2FsZVByZXY7XHJcblxyXG4gICAgICAgIGlmICh0aW1pbmcudGltZVNjYWxlID09PSAwKVxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMDtcclxuXHJcbiAgICAgICAgcnVubmVyLnRpbWVTY2FsZVByZXYgPSB0aW1pbmcudGltZVNjYWxlO1xyXG4gICAgICAgIHJ1bm5lci5jb3JyZWN0aW9uID0gY29ycmVjdGlvbjtcclxuXHJcbiAgICAgICAgLy8gZnBzIGNvdW50ZXJcclxuICAgICAgICBydW5uZXIuZnJhbWVDb3VudGVyICs9IDE7XHJcbiAgICAgICAgaWYgKHRpbWUgLSBydW5uZXIuY291bnRlclRpbWVzdGFtcCA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgIHJ1bm5lci5mcHMgPSBydW5uZXIuZnJhbWVDb3VudGVyICogKCh0aW1lIC0gcnVubmVyLmNvdW50ZXJUaW1lc3RhbXApIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIHJ1bm5lci5jb3VudGVyVGltZXN0YW1wID0gdGltZTtcclxuICAgICAgICAgICAgcnVubmVyLmZyYW1lQ291bnRlciA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICd0aWNrJywgZXZlbnQpO1xyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ3RpY2snLCBldmVudCk7IC8vIEBkZXByZWNhdGVkXHJcblxyXG4gICAgICAgIC8vIGlmIHdvcmxkIGhhcyBiZWVuIG1vZGlmaWVkLCBjbGVhciB0aGUgcmVuZGVyIHNjZW5lIGdyYXBoXHJcbiAgICAgICAgaWYgKGVuZ2luZS53b3JsZC5pc01vZGlmaWVkIFxyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyXHJcbiAgICAgICAgICAgICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlclxyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIuY2xlYXIpIHtcclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLmNsZWFyKGVuZ2luZS5yZW5kZXIpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlVXBkYXRlJywgZXZlbnQpO1xyXG4gICAgICAgIEVuZ2luZS51cGRhdGUoZW5naW5lLCBkZWx0YSwgY29ycmVjdGlvbik7XHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICAgICAgaWYgKGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVJlbmRlcicsIGV2ZW50KTtcclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxyXG5cclxuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLndvcmxkKGVuZ2luZS5yZW5kZXIpO1xyXG5cclxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7XHJcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJUaWNrJywgZXZlbnQpO1xyXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUnVubmVyLnJ1bmAgb24gdGhlIGdpdmVuIGBydW5uZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXHJcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBvbmx5IHRlbXBvcmFyaWx5IHBhdXNlIHRoZSBlbmdpbmUsIHNlZSBgZW5naW5lLmVuYWJsZWRgIGluc3RlYWQuXHJcbiAgICAgKiBAbWV0aG9kIHN0b3BcclxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcclxuICAgICAqL1xyXG4gICAgUnVubmVyLnN0b3AgPSBmdW5jdGlvbihydW5uZXIpIHtcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUocnVubmVyLmZyYW1lUmVxdWVzdElkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYFJ1bm5lci5ydW5gLlxyXG4gICAgICogQG1ldGhvZCBzdGFydFxyXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBSdW5uZXIuc3RhcnQgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSkge1xyXG4gICAgICAgIFJ1bm5lci5ydW4ocnVubmVyLCBlbmdpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGF0IHRoZSBzdGFydCBvZiBhIHRpY2ssIGJlZm9yZSBhbnkgdXBkYXRlcyB0byB0aGUgZW5naW5lIG9yIHRpbWluZ1xyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYmVmb3JlVGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB0aW1pbmcgdXBkYXRlZCwgYnV0IGp1c3QgYmVmb3JlIHVwZGF0ZVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgdGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGF0IHRoZSBlbmQgb2YgYSB0aWNrLCBhZnRlciBlbmdpbmUgdXBkYXRlIGFuZCBhZnRlciByZW5kZXJpbmdcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyVGlja1xyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGJlZm9yZSB1cGRhdGVcclxuICAgICpcclxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpcmVkIGFmdGVyIHVwZGF0ZVxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBiZWZvcmVSZW5kZXJcclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcclxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGaXJlZCBhZnRlciByZW5kZXJpbmdcclxuICAgICpcclxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXHJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XHJcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgKi9cclxuXHJcbiAgICAvKlxyXG4gICAgKlxyXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHJ1bm5lciBpcyBydW5uaW5nIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZFxyXG4gICAgICogQHR5cGUgYm9vbGVhblxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBCb29sZWFuYCB0aGF0IHNwZWNpZmllcyBpZiB0aGUgcnVubmVyIHNob3VsZCB1c2UgYSBmaXhlZCB0aW1lc3RlcCAob3RoZXJ3aXNlIGl0IGlzIHZhcmlhYmxlKS5cclxuICAgICAqIElmIHRpbWluZyBpcyBmaXhlZCwgdGhlbiB0aGUgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZCB3aWxsIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGZyYW1lIHJhdGUgKGJ1dCBiZWhhdmlvdXIgd2lsbCBiZSBkZXRlcm1pbmlzdGljKS5cclxuICAgICAqIElmIHRoZSB0aW1pbmcgaXMgdmFyaWFibGUsIHRoZW4gdGhlIGFwcGFyZW50IHNpbXVsYXRpb24gc3BlZWQgd2lsbCBiZSBjb25zdGFudCAoYXBwcm94aW1hdGVseSwgYnV0IGF0IHRoZSBjb3N0IG9mIGRldGVybWluaW5pc20pLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSBpc0ZpeGVkXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIHN0ZXAgYmV0d2VlbiB1cGRhdGVzIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIElmIGBlbmdpbmUudGltaW5nLmlzRml4ZWRgIGlzIHNldCB0byBgdHJ1ZWAsIHRoZW4gYGRlbHRhYCBpcyBmaXhlZC5cclxuICAgICAqIElmIGl0IGlzIGBmYWxzZWAsIHRoZW4gYGRlbHRhYCBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIHRvIG1haW50YWluIHRoZSBjb3JyZWN0IGFwcGFyZW50IHNpbXVsYXRpb24gc3BlZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IGRlbHRhXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxyXG4gICAgICovXHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUnVubmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuQ29tcG9zaXRlc2AgbW9kdWxlIGNvbnRhaW5zIGZhY3RvcnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGJvZGllc1xyXG4qIHdpdGggY29tbW9ubHkgdXNlZCBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyBzdGFja3MgYW5kIGNoYWlucykuXHJcbipcclxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxyXG4qXHJcbiogQGNsYXNzIENvbXBvc2l0ZXNcclxuKi9cclxuXHJcbnZhciBDb21wb3NpdGVzID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZXM7XHJcblxyXG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBCb2R5ID0gcmVxdWlyZSgnLi4vYm9keS9Cb2R5Jyk7XHJcbnZhciBCb2RpZXMgPSByZXF1aXJlKCcuL0JvZGllcycpO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIGJvZGllcyBjcmVhdGVkIGluIHRoZSBjYWxsYmFjayBpbiBhIGdyaWQgYXJyYW5nZW1lbnQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGJvZHkncyBib3VuZHMgdG8gcHJldmVudCBvdmVybGFwcy5cclxuICAgICAqIEBtZXRob2Qgc3RhY2tcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dHYXBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5zdGFjayA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHN0YWNrID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnU3RhY2snIH0pLFxyXG4gICAgICAgICAgICB4ID0geHgsXHJcbiAgICAgICAgICAgIHkgPSB5eSxcclxuICAgICAgICAgICAgbGFzdEJvZHksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG4gICAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGNhbGxiYWNrKHgsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5SGVpZ2h0ID0gYm9keS5ib3VuZHMubWF4LnkgLSBib2R5LmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVdpZHRoID0gYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueDsgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5SGVpZ2h0ID4gbWF4SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBib2R5SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGJvZHksIHsgeDogYm9keVdpZHRoICogMC41LCB5OiBib2R5SGVpZ2h0ICogMC41IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gYm9keS5ib3VuZHMubWF4LnggKyBjb2x1bW5HYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KHN0YWNrLCBib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Qm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IGNvbHVtbkdhcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgeSArPSBtYXhIZWlnaHQgKyByb3dHYXA7XHJcbiAgICAgICAgICAgIHggPSB4eDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSB0b2dldGhlciB1c2luZyBjb25zdHJhaW50cy5cclxuICAgICAqIEBtZXRob2QgY2hhaW5cclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4T2Zmc2V0QVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRBXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5T2Zmc2V0QlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjaGFpbmVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5jaGFpbiA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgeE9mZnNldEEsIHlPZmZzZXRBLCB4T2Zmc2V0QiwgeU9mZnNldEIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcztcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBib2R5QUhlaWdodCA9IGJvZHlBLmJvdW5kcy5tYXgueSAtIGJvZHlBLmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgICAgIGJvZHlBV2lkdGggPSBib2R5QS5ib3VuZHMubWF4LnggLSBib2R5QS5ib3VuZHMubWluLngsIFxyXG4gICAgICAgICAgICAgICAgYm9keUJIZWlnaHQgPSBib2R5Qi5ib3VuZHMubWF4LnkgLSBib2R5Qi5ib3VuZHMubWluLnksXHJcbiAgICAgICAgICAgICAgICBib2R5QldpZHRoID0gYm9keUIuYm91bmRzLm1heC54IC0gYm9keUIuYm91bmRzLm1pbi54O1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QTogYm9keUEsXHJcbiAgICAgICAgICAgICAgICBwb2ludEE6IHsgeDogYm9keUFXaWR0aCAqIHhPZmZzZXRBLCB5OiBib2R5QUhlaWdodCAqIHlPZmZzZXRBIH0sXHJcbiAgICAgICAgICAgICAgICBib2R5QjogYm9keUIsXHJcbiAgICAgICAgICAgICAgICBwb2ludEI6IHsgeDogYm9keUJXaWR0aCAqIHhPZmZzZXRCLCB5OiBib2R5QkhlaWdodCAqIHlPZmZzZXRCIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoY29uc3RyYWludCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tcG9zaXRlLmxhYmVsICs9ICcgQ2hhaW4nO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgYm9kaWVzIGluIHRoZSBjb21wb3NpdGUgd2l0aCBjb25zdHJhaW50cyBpbiBhIGdyaWQgcGF0dGVybiwgd2l0aCBvcHRpb25hbCBjcm9zcyBicmFjZXMuXHJcbiAgICAgKiBAbWV0aG9kIG1lc2hcclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBtZXNoZWQgdG9nZXRoZXIgd2l0aCBjb25zdHJhaW50c1xyXG4gICAgICovXHJcbiAgICBDb21wb3NpdGVzLm1lc2ggPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbHVtbnMsIHJvd3MsIGNyb3NzQnJhY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcyxcclxuICAgICAgICAgICAgcm93LFxyXG4gICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgIGJvZHlBLFxyXG4gICAgICAgICAgICBib2R5QixcclxuICAgICAgICAgICAgYm9keUM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbCA9IDE7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QSA9IGJvZGllc1soY29sIC0gMSkgKyAocm93ICogY29sdW1ucyldO1xyXG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBib2RpZXNbY29sICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGJvZGllc1tjb2wgKyAocm93ICogY29sdW1ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUMgPSBib2RpZXNbKGNvbCAtIDEpICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA8IGNvbHVtbnMgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlDID0gYm9kaWVzWyhjb2wgKyAxKSArICgocm93IC0gMSkgKiBjb2x1bW5zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QywgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb3NpdGUubGFiZWwgKz0gJyBNZXNoJztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgYm9kaWVzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrIGluIGEgcHlyYW1pZCBhcnJhbmdlbWVudC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYm9keSdzIGJvdW5kcyB0byBwcmV2ZW50IG92ZXJsYXBzLlxyXG4gICAgICogQG1ldGhvZCBweXJhbWlkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMucHlyYW1pZCA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZXMuc3RhY2soeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgZnVuY3Rpb24oeCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3R1YWxSb3dzID0gTWF0aC5taW4ocm93cywgTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSksXHJcbiAgICAgICAgICAgICAgICBsYXN0Qm9keVdpZHRoID0gbGFzdEJvZHkgPyBsYXN0Qm9keS5ib3VuZHMubWF4LnggLSBsYXN0Qm9keS5ib3VuZHMubWluLnggOiAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHJvdyA+IGFjdHVhbFJvd3MpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyByZXZlcnNlIHJvdyBvcmRlclxyXG4gICAgICAgICAgICByb3cgPSBhY3R1YWxSb3dzIC0gcm93O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcm93LFxyXG4gICAgICAgICAgICAgICAgZW5kID0gY29sdW1ucyAtIDEgLSByb3c7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgc3RhcnQgfHwgY29sdW1uID4gZW5kKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gcmV0cm9hY3RpdmVseSBmaXggdGhlIGZpcnN0IGJvZHkncyBwb3NpdGlvbiwgc2luY2Ugd2lkdGggd2FzIHVua25vd25cclxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGxhc3RCb2R5LCB7IHg6IChjb2x1bW4gKyAoY29sdW1ucyAlIDIgPT09IDEgPyAxIDogLTEpKSAqIGxhc3RCb2R5V2lkdGgsIHk6IDAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gbGFzdEJvZHkgPyBjb2x1bW4gKiBsYXN0Qm9keVdpZHRoIDogMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh4eCArIHhPZmZzZXQgKyBjb2x1bW4gKiBjb2x1bW5HYXAsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB3aXRoIGEgTmV3dG9uJ3MgQ3JhZGxlIHNldHVwIG9mIGJvZGllcyBhbmQgY29uc3RyYWludHMuXHJcbiAgICAgKiBAbWV0aG9kIG5ld3RvbnNDcmFkbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgbmV3dG9uc0NyYWRsZSBib2R5XHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMubmV3dG9uc0NyYWRsZSA9IGZ1bmN0aW9uKHh4LCB5eSwgbnVtYmVyLCBzaXplLCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgbmV3dG9uc0NyYWRsZSA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ05ld3RvbnMgQ3JhZGxlJyB9KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXI7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IDEuOSxcclxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IEJvZGllcy5jaXJjbGUoeHggKyBpICogKHNpemUgKiBzZXBhcmF0aW9uKSwgeXkgKyBsZW5ndGgsIHNpemUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbmVydGlhOiBJbmZpbml0eSwgcmVzdGl0dXRpb246IDEsIGZyaWN0aW9uOiAwLCBmcmljdGlvbkFpcjogMC4wMDAxLCBzbG9wOiAxIH0pLFxyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludCA9IENvbnN0cmFpbnQuY3JlYXRlKHsgcG9pbnRBOiB7IHg6IHh4ICsgaSAqIChzaXplICogc2VwYXJhdGlvbiksIHk6IHl5IH0sIGJvZHlCOiBjaXJjbGUgfSk7XHJcblxyXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShuZXd0b25zQ3JhZGxlLCBjaXJjbGUpO1xyXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChuZXd0b25zQ3JhZGxlLCBjb25zdHJhaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXd0b25zQ3JhZGxlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIHdpdGggc2ltcGxlIGNhciBzZXR1cCBvZiBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLlxyXG4gICAgICogQG1ldGhvZCBjYXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aGVlbFNpemVcclxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNhciBib2R5XHJcbiAgICAgKi9cclxuICAgIENvbXBvc2l0ZXMuY2FyID0gZnVuY3Rpb24oeHgsIHl5LCB3aWR0aCwgaGVpZ2h0LCB3aGVlbFNpemUpIHtcclxuICAgICAgICB2YXIgZ3JvdXAgPSBCb2R5Lm5leHRHcm91cCh0cnVlKSxcclxuICAgICAgICAgICAgd2hlZWxCYXNlID0gLTIwLFxyXG4gICAgICAgICAgICB3aGVlbEFPZmZzZXQgPSAtd2lkdGggKiAwLjUgKyB3aGVlbEJhc2UsXHJcbiAgICAgICAgICAgIHdoZWVsQk9mZnNldCA9IHdpZHRoICogMC41IC0gd2hlZWxCYXNlLFxyXG4gICAgICAgICAgICB3aGVlbFlPZmZzZXQgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgdmFyIGNhciA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ0NhcicgfSksXHJcbiAgICAgICAgICAgIGJvZHkgPSBCb2RpZXMudHJhcGV6b2lkKHh4LCB5eSwgd2lkdGgsIGhlaWdodCwgMC4zLCB7IFxyXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuMDEsXHJcbiAgICAgICAgICAgICAgICBjaGFtZmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAxMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgIHZhciB3aGVlbEEgPSBCb2RpZXMuY2lyY2xlKHh4ICsgd2hlZWxBT2Zmc2V0LCB5eSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxyXG4gICAgICAgICAgICBjb2xsaXNpb25GaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmcmljdGlvbjogMC44LFxyXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIHdoZWVsQiA9IEJvZGllcy5jaXJjbGUoeHggKyB3aGVlbEJPZmZzZXQsIHl5ICsgd2hlZWxZT2Zmc2V0LCB3aGVlbFNpemUsIHsgXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjgsXHJcbiAgICAgICAgICAgIGRlbnNpdHk6IDAuMDFcclxuICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgYXhlbEEgPSBDb25zdHJhaW50LmNyZWF0ZSh7XHJcbiAgICAgICAgICAgIGJvZHlBOiBib2R5LFxyXG4gICAgICAgICAgICBwb2ludEE6IHsgeDogd2hlZWxBT2Zmc2V0LCB5OiB3aGVlbFlPZmZzZXQgfSxcclxuICAgICAgICAgICAgYm9keUI6IHdoZWVsQSxcclxuICAgICAgICAgICAgc3RpZmZuZXNzOiAwLjIsXHJcbiAgICAgICAgICAgIHJlbmRlcjoge1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIGF4ZWxCID0gQ29uc3RyYWludC5jcmVhdGUoe1xyXG4gICAgICAgICAgICBib2R5QTogYm9keSxcclxuICAgICAgICAgICAgcG9pbnRBOiB7IHg6IHdoZWVsQk9mZnNldCwgeTogd2hlZWxZT2Zmc2V0IH0sXHJcbiAgICAgICAgICAgIGJvZHlCOiB3aGVlbEIsXHJcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4yLFxyXG4gICAgICAgICAgICByZW5kZXI6IHtcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCBib2R5KTtcclxuICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjYXIsIHdoZWVsQSk7XHJcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEIpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEEpO1xyXG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEIpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzaW1wbGUgc29mdCBib2R5IGxpa2Ugb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCBzb2Z0Qm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkdhcFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydGljbGVSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7fSBwYXJ0aWNsZU9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7fSBjb25zdHJhaW50T3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgc29mdEJvZHlcclxuICAgICAqL1xyXG4gICAgQ29tcG9zaXRlcy5zb2Z0Qm9keSA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNyb3NzQnJhY2UsIHBhcnRpY2xlUmFkaXVzLCBwYXJ0aWNsZU9wdGlvbnMsIGNvbnN0cmFpbnRPcHRpb25zKSB7XHJcbiAgICAgICAgcGFydGljbGVPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IGluZXJ0aWE6IEluZmluaXR5IH0sIHBhcnRpY2xlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3RyYWludE9wdGlvbnMgPSBDb21tb24uZXh0ZW5kKHsgc3RpZmZuZXNzOiAwLjQgfSwgY29uc3RyYWludE9wdGlvbnMpO1xyXG5cclxuICAgICAgICB2YXIgc29mdEJvZHkgPSBDb21wb3NpdGVzLnN0YWNrKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJvZGllcy5jaXJjbGUoeCwgeSwgcGFydGljbGVSYWRpdXMsIHBhcnRpY2xlT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIENvbXBvc2l0ZXMubWVzaChzb2Z0Qm9keSwgY29sdW1ucywgcm93cywgY3Jvc3NCcmFjZSwgY29uc3RyYWludE9wdGlvbnMpO1xyXG5cclxuICAgICAgICBzb2Z0Qm9keS5sYWJlbCA9ICdTb2Z0IEJvZHknO1xyXG5cclxuICAgICAgICByZXR1cm4gc29mdEJvZHk7XHJcbiAgICB9O1xyXG5cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9waHlzaWNzL21hdHRlci1qcy9mYWN0b3J5L0NvbXBvc2l0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDcwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBUaGUgYE1hdHRlci5TdmdgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjb252ZXJ0aW5nIFNWRyBpbWFnZXMgaW50byBhbiBhcnJheSBvZiB2ZWN0b3IgcG9pbnRzLlxyXG4qXHJcbiogVG8gdXNlIHRoaXMgbW9kdWxlIHlvdSBhbHNvIG5lZWQgdGhlIFNWR1BhdGhTZWcgcG9seWZpbGw6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9nZXJzL3BhdGhzZWdcclxuKlxyXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXHJcbipcclxuKiBAY2xhc3MgU3ZnXHJcbiovXHJcblxyXG52YXIgU3ZnID0ge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN2ZztcclxuXHJcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGFuIFNWRyBwYXRoIGludG8gYW4gYXJyYXkgb2YgdmVjdG9yIHBvaW50cy5cclxuICAgICAqIElmIHRoZSBpbnB1dCBwYXRoIGZvcm1zIGEgY29uY2F2ZSBzaGFwZSwgeW91IG11c3QgZGVjb21wb3NlIHRoZSByZXN1bHQgaW50byBjb252ZXggcGFydHMgYmVmb3JlIHVzZS5cclxuICAgICAqIFNlZSBgQm9kaWVzLmZyb21WZXJ0aWNlc2Agd2hpY2ggcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhpcy5cclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1cHBvcnQgY29tcGxleCBwYXRocyAoc3VjaCBhcyB0aG9zZSB3aXRoIGhvbGVzKS5cclxuICAgICAqIEBtZXRob2QgcGF0aFRvVmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7U1ZHUGF0aEVsZW1lbnR9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlTGVuZ3RoPTE1XVxyXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHBvaW50c1xyXG4gICAgICovXHJcbiAgICBTdmcucGF0aFRvVmVydGljZXMgPSBmdW5jdGlvbihwYXRoLCBzYW1wbGVMZW5ndGgpIHtcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd291dC9zdmcudG9wb2x5LmpzL2Jsb2IvbWFzdGVyL3N2Zy50b3BvbHkuanNcclxuICAgICAgICB2YXIgaSwgaWwsIHRvdGFsLCBwb2ludCwgc2VnbWVudCwgc2VnbWVudHMsIFxyXG4gICAgICAgICAgICBzZWdtZW50c1F1ZXVlLCBsYXN0U2VnbWVudCwgXHJcbiAgICAgICAgICAgIGxhc3RQb2ludCwgc2VnbWVudEluZGV4LCBwb2ludHMgPSBbXSxcclxuICAgICAgICAgICAgbHgsIGx5LCBsZW5ndGggPSAwLCB4ID0gMCwgeSA9IDA7XHJcblxyXG4gICAgICAgIHNhbXBsZUxlbmd0aCA9IHNhbXBsZUxlbmd0aCB8fCAxNTtcclxuXHJcbiAgICAgICAgdmFyIGFkZFBvaW50ID0gZnVuY3Rpb24ocHgsIHB5LCBwYXRoU2VnVHlwZSkge1xyXG4gICAgICAgICAgICAvLyBhbGwgb2RkLW51bWJlcmVkIHBhdGggdHlwZXMgYXJlIHJlbGF0aXZlIGV4Y2VwdCBQQVRIU0VHX0NMT1NFUEFUSCAoMSlcclxuICAgICAgICAgICAgdmFyIGlzUmVsYXRpdmUgPSBwYXRoU2VnVHlwZSAlIDIgPT09IDEgJiYgcGF0aFNlZ1R5cGUgPiAxO1xyXG5cclxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgbGFzdCBwb2ludCBkb2Vzbid0IGVxdWFsIHRoZSBjdXJyZW50IHBvaW50IGFkZCB0aGUgY3VycmVudCBwb2ludFxyXG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCBweCAhPSBsYXN0UG9pbnQueCB8fCBweSAhPSBsYXN0UG9pbnQueSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQb2ludCAmJiBpc1JlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbHggPSBsYXN0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgICBseSA9IGxhc3RQb2ludC55O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBseCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBseCArIHB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGx5ICsgcHlcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxhc3QgcG9pbnRcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlIHx8ICFsYXN0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgeCA9IGx4ICsgcHg7XHJcbiAgICAgICAgICAgICAgICB5ID0gbHkgKyBweTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBhZGRTZWdtZW50UG9pbnQgPSBmdW5jdGlvbihzZWdtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdUeXBlID0gc2VnbWVudC5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBza2lwIHBhdGggZW5kc1xyXG4gICAgICAgICAgICBpZiAoc2VnVHlwZSA9PT0gJ1onKSBcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIG1hcCBzZWdtZW50IHRvIHggYW5kIHlcclxuICAgICAgICAgICAgc3dpdGNoIChzZWdUeXBlKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgY2FzZSAnTCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1QnOlxyXG4gICAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgY2FzZSAnUyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcclxuICAgICAgICAgICAgICAgIHkgPSBzZWdtZW50Lnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnSCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gc2VnbWVudC54O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1YnOlxyXG4gICAgICAgICAgICAgICAgeSA9IHNlZ21lbnQueTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRQb2ludCh4LCB5LCBzZWdtZW50LnBhdGhTZWdUeXBlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBlbnN1cmUgcGF0aCBpcyBhYnNvbHV0ZVxyXG4gICAgICAgIF9zdmdQYXRoVG9BYnNvbHV0ZShwYXRoKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRvdGFsIGxlbmd0aFxyXG4gICAgICAgIHRvdGFsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xyXG5cclxuICAgICAgICAvLyBxdWV1ZSBzZWdtZW50c1xyXG4gICAgICAgIHNlZ21lbnRzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGgucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtczsgaSArPSAxKVxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHBhdGgucGF0aFNlZ0xpc3QuZ2V0SXRlbShpKSk7XHJcblxyXG4gICAgICAgIHNlZ21lbnRzUXVldWUgPSBzZWdtZW50cy5jb25jYXQoKTtcclxuXHJcbiAgICAgICAgLy8gc2FtcGxlIHRocm91Z2ggcGF0aFxyXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0b3RhbCkge1xyXG4gICAgICAgICAgICAvLyBnZXQgc2VnbWVudCBhdCBwb3NpdGlvblxyXG4gICAgICAgICAgICBzZWdtZW50SW5kZXggPSBwYXRoLmdldFBhdGhTZWdBdExlbmd0aChsZW5ndGgpO1xyXG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcclxuXHJcbiAgICAgICAgICAgIC8vIG5ldyBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50ICE9IGxhc3RTZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VnbWVudHNRdWV1ZS5sZW5ndGggJiYgc2VnbWVudHNRdWV1ZVswXSAhPSBzZWdtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlZ21lbnRQb2ludChzZWdtZW50c1F1ZXVlLnNoaWZ0KCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50ID0gc2VnbWVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYWRkIHBvaW50cyBpbiBiZXR3ZWVuIHdoZW4gY3VydmluZ1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBhZGFwdGl2ZSBzYW1wbGluZ1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNlZ21lbnQucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgY2FzZSAnVCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgYWRkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBieSBzYW1wbGUgdmFsdWVcclxuICAgICAgICAgICAgbGVuZ3RoICs9IHNhbXBsZUxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgc2VnbWVudHMgbm90IHBhc3NlZCBieSBzYW1wbGluZ1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gc2VnbWVudHNRdWV1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxyXG4gICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZVtpXSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfc3ZnUGF0aFRvQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICAgICAgLy8gaHR0cDovL3Bocm9nei5uZXQvY29udmVydC1zdmctcGF0aC10by1hbGwtYWJzb2x1dGUtY29tbWFuZHNcclxuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Miwgc2VncyA9IHBhdGgucGF0aFNlZ0xpc3QsXHJcbiAgICAgICAgICAgIHggPSAwLCB5ID0gMCwgbGVuID0gc2Vncy5udW1iZXJPZkl0ZW1zO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzLmdldEl0ZW0oaSksXHJcbiAgICAgICAgICAgICAgICBzZWdUeXBlID0gc2VnLnBhdGhTZWdUeXBlQXNMZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoL1tNTEhWQ1NRVEFdLy50ZXN0KHNlZ1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3gnIGluIHNlZykgeCA9IHNlZy54O1xyXG4gICAgICAgICAgICAgICAgaWYgKCd5JyBpbiBzZWcpIHkgPSBzZWcueTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgneDEnIGluIHNlZykgeDEgPSB4ICsgc2VnLngxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCd4MicgaW4gc2VnKSB4MiA9IHggKyBzZWcueDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3kxJyBpbiBzZWcpIHkxID0geSArIHNlZy55MTtcclxuICAgICAgICAgICAgICAgIGlmICgneTInIGluIHNlZykgeTIgPSB5ICsgc2VnLnkyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggKz0gc2VnLng7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSArPSBzZWcueTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlZ1R5cGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b0Ficyh4LCB5KSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Ficyh4LCB5KSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnMoeCksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndic6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicyh5KSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficyh4LCB5LCB4MSwgeTEsIHgyLCB5MiksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMoeCwgeSwgeDIsIHkyKSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdxJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNBYnMoeCwgeSwgeDEsIHkxKSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMoeCwgeSksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdBcmNBYnMoeCwgeSwgc2VnLnIxLCBzZWcucjIsIHNlZy5hbmdsZSwgc2VnLmxhcmdlQXJjRmxhZywgc2VnLnN3ZWVwRmxhZyksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdaJzpcclxuICAgICAgICAgICAgICAgICAgICB4ID0geDA7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlZ1R5cGUgPT0gJ00nIHx8IHNlZ1R5cGUgPT0gJ20nKSB7XHJcbiAgICAgICAgICAgICAgICB4MCA9IHg7XHJcbiAgICAgICAgICAgICAgICB5MCA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qc1xuLy8gbW9kdWxlIGlkID0gNzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXR0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2NvcmUvTWF0dGVyJyk7XHJcblxyXG5NYXR0ZXIuQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xyXG5NYXR0ZXIuQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxuTWF0dGVyLldvcmxkID0gcmVxdWlyZSgnLi4vYm9keS9Xb3JsZCcpO1xyXG5cclxuTWF0dGVyLkNvbnRhY3QgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQ29udGFjdCcpO1xyXG5NYXR0ZXIuRGV0ZWN0b3IgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vRGV0ZWN0b3InKTtcclxuTWF0dGVyLkdyaWQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xyXG5NYXR0ZXIuUGFpcnMgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUGFpcnMnKTtcclxuTWF0dGVyLlBhaXIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUGFpcicpO1xyXG5NYXR0ZXIuUXVlcnkgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUXVlcnknKTtcclxuTWF0dGVyLlJlc29sdmVyID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1Jlc29sdmVyJyk7XHJcbk1hdHRlci5TQVQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vU0FUJyk7XHJcblxyXG5NYXR0ZXIuQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xyXG5NYXR0ZXIuTW91c2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQnKTtcclxuXHJcbk1hdHRlci5Db21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG5NYXR0ZXIuRW5naW5lID0gcmVxdWlyZSgnLi4vY29yZS9FbmdpbmUnKTtcclxuTWF0dGVyLkV2ZW50cyA9IHJlcXVpcmUoJy4uL2NvcmUvRXZlbnRzJyk7XHJcbk1hdHRlci5Nb3VzZSA9IHJlcXVpcmUoJy4uL2NvcmUvTW91c2UnKTtcclxuTWF0dGVyLlJ1bm5lciA9IHJlcXVpcmUoJy4uL2NvcmUvUnVubmVyJyk7XHJcbk1hdHRlci5TbGVlcGluZyA9IHJlcXVpcmUoJy4uL2NvcmUvU2xlZXBpbmcnKTtcclxuTWF0dGVyLlBsdWdpbiA9IHJlcXVpcmUoJy4uL2NvcmUvUGx1Z2luJyk7XHJcblxyXG4vLyBAaWYgREVCVUdcclxuTWF0dGVyLk1ldHJpY3MgPSByZXF1aXJlKCcuLi9jb3JlL01ldHJpY3MnKTtcclxuLy8gQGVuZGlmXHJcblxyXG5NYXR0ZXIuQm9kaWVzID0gcmVxdWlyZSgnLi4vZmFjdG9yeS9Cb2RpZXMnKTtcclxuTWF0dGVyLkNvbXBvc2l0ZXMgPSByZXF1aXJlKCcuLi9mYWN0b3J5L0NvbXBvc2l0ZXMnKTtcclxuXHJcbk1hdHRlci5BeGVzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQXhlcycpO1xyXG5NYXR0ZXIuQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbk1hdHRlci5TdmcgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9TdmcnKTtcclxuTWF0dGVyLlZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG5NYXR0ZXIuVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xyXG5cclxuTWF0dGVyLlJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcclxuTWF0dGVyLlJlbmRlclBpeGkgPSByZXF1aXJlKCcuLi9yZW5kZXIvUmVuZGVyUGl4aScpO1xyXG5cclxuLy8gYWxpYXNlc1xyXG5cclxuTWF0dGVyLldvcmxkLmFkZCA9IE1hdHRlci5Db21wb3NpdGUuYWRkO1xyXG5NYXR0ZXIuV29ybGQucmVtb3ZlID0gTWF0dGVyLkNvbXBvc2l0ZS5yZW1vdmU7XHJcbk1hdHRlci5Xb3JsZC5hZGRDb21wb3NpdGUgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZENvbXBvc2l0ZTtcclxuTWF0dGVyLldvcmxkLmFkZEJvZHkgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZEJvZHk7XHJcbk1hdHRlci5Xb3JsZC5hZGRDb25zdHJhaW50ID0gTWF0dGVyLkNvbXBvc2l0ZS5hZGRDb25zdHJhaW50O1xyXG5NYXR0ZXIuV29ybGQuY2xlYXIgPSBNYXR0ZXIuQ29tcG9zaXRlLmNsZWFyO1xyXG5NYXR0ZXIuRW5naW5lLnJ1biA9IE1hdHRlci5SdW5uZXIucnVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL21vZHVsZS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXIuUmVuZGVyUGl4aWAgbW9kdWxlIGlzIGFuIGV4YW1wbGUgcmVuZGVyZXIgdXNpbmcgcGl4aS5qcy5cclxuKiBTZWUgYWxzbyBgTWF0dGVyLlJlbmRlcmAgZm9yIGEgY2FudmFzIGJhc2VkIHJlbmRlcmVyLlxyXG4qXHJcbiogQGNsYXNzIFJlbmRlclBpeGlcclxuKiBAZGVwcmVjYXRlZCB0aGUgTWF0dGVyLlJlbmRlclBpeGkgbW9kdWxlIHdpbGwgc29vbiBiZSByZW1vdmVkIGZyb20gdGhlIE1hdHRlci5qcyBjb3JlLlxyXG4qIEl0IHdpbGwgbGlrZWx5IGJlIG1vdmVkIHRvIGl0cyBvd24gcmVwb3NpdG9yeSAoYnV0IG1haW50ZW5hbmNlIHdpbGwgYmUgbGltaXRlZCkuXHJcbiovXHJcblxyXG52YXIgUmVuZGVyUGl4aSA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJQaXhpO1xyXG5cclxudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xyXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbihjYWxsYmFjayl7IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhDb21tb24ubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG4gICBcclxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBpeGkuanMgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiB7UmVuZGVyUGl4aX0gQSBuZXcgcmVuZGVyZXJcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIENvbW1vbi53YXJuKCdSZW5kZXJQaXhpLmNyZWF0ZTogTWF0dGVyLlJlbmRlclBpeGkgaXMgZGVwcmVjYXRlZCAoc2VlIGRvY3MpJyk7XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgY29udHJvbGxlcjogUmVuZGVyUGl4aSxcclxuICAgICAgICAgICAgZW5naW5lOiBudWxsLFxyXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxyXG4gICAgICAgICAgICBmcmFtZVJlcXVlc3RJZDogbnVsbCxcclxuICAgICAgICAgICAgY2FudmFzOiBudWxsLFxyXG4gICAgICAgICAgICByZW5kZXJlcjogbnVsbCxcclxuICAgICAgICAgICAgY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBzcHJpdGVDb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHBpeGlPcHRpb25zOiBudWxsLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogODAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZhZmFmYScsXHJcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWVCYWNrZ3JvdW5kOiAnIzIyMicsXHJcbiAgICAgICAgICAgICAgICBoYXNCb3VuZHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93U2xlZXBpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93RGVidWc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0Jyb2FkcGhhc2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0JvdW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0NvbGxpc2lvbnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0F4ZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd1Bvc2l0aW9uczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QW5nbGVJbmRpY2F0b3I6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0lkczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93U2hhZG93czogZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZW5kZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgPSAhcmVuZGVyLm9wdGlvbnMud2lyZWZyYW1lcyAmJiByZW5kZXIub3B0aW9ucy5iYWNrZ3JvdW5kID09PSAndHJhbnNwYXJlbnQnO1xyXG5cclxuICAgICAgICAvLyBpbml0IHBpeGlcclxuICAgICAgICByZW5kZXIucGl4aU9wdGlvbnMgPSByZW5kZXIucGl4aU9wdGlvbnMgfHwge1xyXG4gICAgICAgICAgICB2aWV3OiByZW5kZXIuY2FudmFzLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZW5kZXIubW91c2UgPSBvcHRpb25zLm1vdXNlO1xyXG4gICAgICAgIHJlbmRlci5lbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcclxuICAgICAgICByZW5kZXIucmVuZGVyZXIgPSByZW5kZXIucmVuZGVyZXIgfHwgbmV3IFBJWEkuV2ViR0xSZW5kZXJlcihyZW5kZXIub3B0aW9ucy53aWR0aCwgcmVuZGVyLm9wdGlvbnMuaGVpZ2h0LCByZW5kZXIucGl4aU9wdGlvbnMpO1xyXG4gICAgICAgIHJlbmRlci5jb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyIHx8IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHJlbmRlci5zcHJpdGVDb250YWluZXIgPSByZW5kZXIuc3ByaXRlQ29udGFpbmVyIHx8IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHJlbmRlci5jYW52YXMgPSByZW5kZXIuY2FudmFzIHx8IHJlbmRlci5yZW5kZXJlci52aWV3O1xyXG4gICAgICAgIHJlbmRlci5ib3VuZHMgPSByZW5kZXIuYm91bmRzIHx8IHsgXHJcbiAgICAgICAgICAgIG1pbjoge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgfSwgXHJcbiAgICAgICAgICAgIG1heDogeyBcclxuICAgICAgICAgICAgICAgIHg6IHJlbmRlci5vcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgeTogcmVuZGVyLm9wdGlvbnMuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICBFdmVudHMub24ocmVuZGVyLmVuZ2luZSwgJ2JlZm9yZVVwZGF0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLmNsZWFyKHJlbmRlcik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGNhY2hlc1xyXG4gICAgICAgIHJlbmRlci50ZXh0dXJlcyA9IHt9O1xyXG4gICAgICAgIHJlbmRlci5zcHJpdGVzID0ge307XHJcbiAgICAgICAgcmVuZGVyLnByaW1pdGl2ZXMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gdXNlIGEgc3ByaXRlIGJhdGNoIGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICAgIHJlbmRlci5jb250YWluZXIuYWRkQ2hpbGQocmVuZGVyLnNwcml0ZUNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIC8vIGluc2VydCBjYW52YXNcclxuICAgICAgICBpZiAoQ29tbW9uLmlzRWxlbWVudChyZW5kZXIuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmVuZGVyLmVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyLmNhbnZhcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ05vIFwicmVuZGVyLmVsZW1lbnRcIiBwYXNzZWQsIFwicmVuZGVyLmNhbnZhc1wiIHdhcyBub3QgaW5zZXJ0ZWQgaW50byBkb2N1bWVudC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHByZXZlbnQgbWVudXMgb24gY2FudmFzXHJcbiAgICAgICAgcmVuZGVyLmNhbnZhcy5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgICAgICByZW5kZXIuY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVuZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSByZW5kZXIgY2FudmFzIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cclxuICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBSZW5kZXJQaXhpLnJ1biA9IGZ1bmN0aW9uKHJlbmRlcikge1xyXG4gICAgICAgIChmdW5jdGlvbiBsb29wKHRpbWUpe1xyXG4gICAgICAgICAgICByZW5kZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLndvcmxkKHJlbmRlcik7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXHJcbiAgICAgKiBAbWV0aG9kIHN0b3BcclxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuc3RvcCA9IGZ1bmN0aW9uKHJlbmRlcikge1xyXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXIuZnJhbWVSZXF1ZXN0SWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgc2NlbmUgZ3JhcGhcclxuICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBSZW5kZXJQaXhpLmNsZWFyID0gZnVuY3Rpb24ocmVuZGVyKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIsXHJcbiAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lciA9IHJlbmRlci5zcHJpdGVDb250YWluZXI7XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIHN0YWdlIGNvbnRhaW5lclxyXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuY2hpbGRyZW5bMF0pIHsgXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuY2hpbGRyZW5bMF0pOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIHNwcml0ZSBiYXRjaFxyXG4gICAgICAgIHdoaWxlIChzcHJpdGVDb250YWluZXIuY2hpbGRyZW5bMF0pIHsgXHJcbiAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lci5yZW1vdmVDaGlsZChzcHJpdGVDb250YWluZXIuY2hpbGRyZW5bMF0pOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ107XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGNhY2hlc1xyXG4gICAgICAgIHJlbmRlci50ZXh0dXJlcyA9IHt9O1xyXG4gICAgICAgIHJlbmRlci5zcHJpdGVzID0ge307XHJcbiAgICAgICAgcmVuZGVyLnByaW1pdGl2ZXMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gc2V0IGJhY2tncm91bmQgc3ByaXRlXHJcbiAgICAgICAgcmVuZGVyLnNwcml0ZXNbJ2JnLTAnXSA9IGJnU3ByaXRlO1xyXG4gICAgICAgIGlmIChiZ1Nwcml0ZSlcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkQXQoYmdTcHJpdGUsIDApO1xyXG5cclxuICAgICAgICAvLyBhZGQgc3ByaXRlIGJhdGNoIGJhY2sgaW50byBjb250YWluZXJcclxuICAgICAgICByZW5kZXIuY29udGFpbmVyLmFkZENoaWxkKHJlbmRlci5zcHJpdGVDb250YWluZXIpO1xyXG5cclxuICAgICAgICAvLyByZXNldCBiYWNrZ3JvdW5kIHN0YXRlXHJcbiAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gcmVzZXQgYm91bmRzIHRyYW5zZm9ybXNcclxuICAgICAgICBjb250YWluZXIuc2NhbGUuc2V0KDEsIDEpO1xyXG4gICAgICAgIGNvbnRhaW5lci5wb3NpdGlvbi5zZXQoMCwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYmFja2dyb3VuZCBvZiB0aGUgY2FudmFzIFxyXG4gICAgICogQG1ldGhvZCBzZXRCYWNrZ3JvdW5kXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuc2V0QmFja2dyb3VuZCA9IGZ1bmN0aW9uKHJlbmRlciwgYmFja2dyb3VuZCkge1xyXG4gICAgICAgIGlmIChyZW5kZXIuY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgdmFyIGlzQ29sb3IgPSBiYWNrZ3JvdW5kLmluZGV4T2YgJiYgYmFja2dyb3VuZC5pbmRleE9mKCcjJykgIT09IC0xLFxyXG4gICAgICAgICAgICAgICAgYmdTcHJpdGUgPSByZW5kZXIuc3ByaXRlc1snYmctMCddO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNvbGlkIGJhY2tncm91bmQgY29sb3JcclxuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IENvbW1vbi5jb2xvclRvTnVtYmVyKGJhY2tncm91bmQpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyLnJlbmRlcmVyLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBiYWNrZ3JvdW5kIHNwcml0ZSBpZiBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGJnU3ByaXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlci5jb250YWluZXIucmVtb3ZlQ2hpbGQoYmdTcHJpdGUpOyBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYmFja2dyb3VuZCBzcHJpdGUgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJnU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIGJhY2tncm91bmQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ10gPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmdTcHJpdGUucG9zaXRpb24ueCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmdTcHJpdGUucG9zaXRpb24ueSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5hZGRDaGlsZEF0KGJnU3ByaXRlLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzY3JpcHRpb25cclxuICAgICAqIEBtZXRob2Qgd29ybGRcclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkud29ybGQgPSBmdW5jdGlvbihyZW5kZXIpIHtcclxuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcclxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXHJcbiAgICAgICAgICAgIHJlbmRlcmVyID0gcmVuZGVyLnJlbmRlcmVyLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxyXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCksXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gW10sXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgUmVuZGVyUGl4aS5zZXRCYWNrZ3JvdW5kKHJlbmRlciwgb3B0aW9ucy53aXJlZnJhbWVCYWNrZ3JvdW5kKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLnNldEJhY2tncm91bmQocmVuZGVyLCBvcHRpb25zLmJhY2tncm91bmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGJvdW5kc1xyXG4gICAgICAgIHZhciBib3VuZHNXaWR0aCA9IHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54LFxyXG4gICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcclxuICAgICAgICAgICAgYm91bmRzU2NhbGVYID0gYm91bmRzV2lkdGggLyByZW5kZXIub3B0aW9ucy53aWR0aCxcclxuICAgICAgICAgICAgYm91bmRzU2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcclxuICAgICAgICAgICAgLy8gSGlkZSBib2RpZXMgdGhhdCBhcmUgbm90IGluIHZpZXdcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgICAgICBib2R5LnJlbmRlci5zcHJpdGUudmlzaWJsZSA9IEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgcmVuZGVyLmJvdW5kcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY29uc3RyYWludHMgdGhhdCBhcmUgbm90IGluIHZpZXdcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbENvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGFsbENvbnN0cmFpbnRzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcclxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBV29ybGQgPSBjb25zdHJhaW50LnBvaW50QSxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludEJXb3JsZCA9IGNvbnN0cmFpbnQucG9pbnRCO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUIpIHBvaW50QldvcmxkID0gVmVjdG9yLmFkZChib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRBV29ybGQpIHx8IEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEJXb3JsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSB2aWV3XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zY2FsZS5zZXQoMSAvIGJvdW5kc1NjYWxlWCwgMSAvIGJvdW5kc1NjYWxlWSk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5wb3NpdGlvbi5zZXQoLXJlbmRlci5ib3VuZHMubWluLnggKiAoMSAvIGJvdW5kc1NjYWxlWCksIC1yZW5kZXIuYm91bmRzLm1pbi55ICogKDEgLyBib3VuZHNTY2FsZVkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGFsbENvbnN0cmFpbnRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgUmVuZGVyUGl4aS5ib2R5KHJlbmRlciwgYm9kaWVzW2ldKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBSZW5kZXJQaXhpLmNvbnN0cmFpbnQocmVuZGVyLCBjb25zdHJhaW50c1tpXSk7XHJcblxyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihjb250YWluZXIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQG1ldGhvZCBjb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuY29uc3RyYWludCA9IGZ1bmN0aW9uKHJlbmRlciwgY29uc3RyYWludCkge1xyXG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXHJcbiAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcclxuICAgICAgICAgICAgcG9pbnRBID0gY29uc3RyYWludC5wb2ludEEsXHJcbiAgICAgICAgICAgIHBvaW50QiA9IGNvbnN0cmFpbnQucG9pbnRCLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBjb25zdHJhaW50UmVuZGVyID0gY29uc3RyYWludC5yZW5kZXIsXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZUlkID0gJ2MtJyArIGNvbnN0cmFpbnQuaWQsXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZSA9IHJlbmRlci5wcmltaXRpdmVzW3ByaW1pdGl2ZUlkXTtcclxuXHJcbiAgICAgICAgLy8gaW5pdGlhbGlzZSBjb25zdHJhaW50IHByaW1pdGl2ZSBpZiBub3QgZXhpc3RpbmdcclxuICAgICAgICBpZiAoIXByaW1pdGl2ZSlcclxuICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcclxuXHJcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIGlmIGNvbnN0cmFpbnQgZG9lcyBub3QgaGF2ZSB0d28gZW5kIHBvaW50c1xyXG4gICAgICAgIGlmICghY29uc3RyYWludFJlbmRlci52aXNpYmxlIHx8ICFjb25zdHJhaW50LnBvaW50QSB8fCAhY29uc3RyYWludC5wb2ludEIpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCB0byBzY2VuZSBncmFwaCBpZiBub3QgYWxyZWFkeSB0aGVyZVxyXG4gICAgICAgIGlmIChDb21tb24uaW5kZXhPZihjb250YWluZXIuY2hpbGRyZW4sIHByaW1pdGl2ZSkgPT09IC0xKVxyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQocHJpbWl0aXZlKTtcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBjb25zdHJhaW50IG9uIGV2ZXJ5IHVwZGF0ZSwgc2luY2UgdGhleSBjYW4gY2hhbmdlIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgcHJpbWl0aXZlLmNsZWFyKCk7XHJcbiAgICAgICAgcHJpbWl0aXZlLmJlZ2luRmlsbCgwLCAwKTtcclxuICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKGNvbnN0cmFpbnRSZW5kZXIubGluZVdpZHRoLCBDb21tb24uY29sb3JUb051bWJlcihjb25zdHJhaW50UmVuZGVyLnN0cm9rZVN0eWxlKSwgMSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJvZHlBKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5tb3ZlVG8oYm9keUEucG9zaXRpb24ueCArIHBvaW50QS54LCBib2R5QS5wb3NpdGlvbi55ICsgcG9pbnRBLnkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5tb3ZlVG8ocG9pbnRBLngsIHBvaW50QS55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChib2R5Qikge1xyXG4gICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggKyBwb2ludEIueCwgYm9keUIucG9zaXRpb24ueSArIHBvaW50Qi55KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKHBvaW50Qi54LCBwb2ludEIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmltaXRpdmUuZW5kRmlsbCgpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNjcmlwdGlvblxyXG4gICAgICogQG1ldGhvZCBib2R5XHJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIFJlbmRlclBpeGkuYm9keSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9keSkge1xyXG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxyXG4gICAgICAgICAgICBib2R5UmVuZGVyID0gYm9keS5yZW5kZXI7XHJcblxyXG4gICAgICAgIGlmICghYm9keVJlbmRlci52aXNpYmxlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChib2R5UmVuZGVyLnNwcml0ZSAmJiBib2R5UmVuZGVyLnNwcml0ZS50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVJZCA9ICdiLScgKyBib2R5LmlkLFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbc3ByaXRlSWRdLFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyID0gcmVuZGVyLnNwcml0ZUNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYm9keSBzcHJpdGUgaWYgbm90IGV4aXN0aW5nXHJcbiAgICAgICAgICAgIGlmICghc3ByaXRlKVxyXG4gICAgICAgICAgICAgICAgc3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbc3ByaXRlSWRdID0gX2NyZWF0ZUJvZHlTcHJpdGUocmVuZGVyLCBib2R5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCB0byBzY2VuZSBncmFwaCBpZiBub3QgYWxyZWFkeSB0aGVyZVxyXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmluZGV4T2Yoc3ByaXRlQ29udGFpbmVyLmNoaWxkcmVuLCBzcHJpdGUpID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHNwcml0ZUNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgc3ByaXRlXHJcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi54ID0gYm9keS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBzcHJpdGUucG9zaXRpb24ueSA9IGJvZHkucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgc3ByaXRlLnJvdGF0aW9uID0gYm9keS5hbmdsZTtcclxuICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnggPSBib2R5UmVuZGVyLnNwcml0ZS54U2NhbGUgfHwgMTtcclxuICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnkgPSBib2R5UmVuZGVyLnNwcml0ZS55U2NhbGUgfHwgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlSWQgPSAnYi0nICsgYm9keS5pZCxcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZSA9IHJlbmRlci5wcmltaXRpdmVzW3ByaW1pdGl2ZUlkXSxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXNlIGJvZHkgcHJpbWl0aXZlIGlmIG5vdCBleGlzdGluZ1xyXG4gICAgICAgICAgICBpZiAoIXByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlID0gcmVuZGVyLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdID0gX2NyZWF0ZUJvZHlQcmltaXRpdmUocmVuZGVyLCBib2R5KTtcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5pbml0aWFsQW5nbGUgPSBib2R5LmFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgdG8gc2NlbmUgZ3JhcGggaWYgbm90IGFscmVhZHkgdGhlcmVcclxuICAgICAgICAgICAgaWYgKENvbW1vbi5pbmRleE9mKGNvbnRhaW5lci5jaGlsZHJlbiwgcHJpbWl0aXZlKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQocHJpbWl0aXZlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBib2R5IHByaW1pdGl2ZVxyXG4gICAgICAgICAgICBwcmltaXRpdmUucG9zaXRpb24ueCA9IGJvZHkucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgcHJpbWl0aXZlLnBvc2l0aW9uLnkgPSBib2R5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5yb3RhdGlvbiA9IGJvZHkuYW5nbGUgLSBwcmltaXRpdmUuaW5pdGlhbEFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYm9keSBzcHJpdGVcclxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUJvZHlTcHJpdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gc3ByaXRlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICB2YXIgX2NyZWF0ZUJvZHlTcHJpdGUgPSBmdW5jdGlvbihyZW5kZXIsIGJvZHkpIHtcclxuICAgICAgICB2YXIgYm9keVJlbmRlciA9IGJvZHkucmVuZGVyLFxyXG4gICAgICAgICAgICB0ZXh0dXJlUGF0aCA9IGJvZHlSZW5kZXIuc3ByaXRlLnRleHR1cmUsXHJcbiAgICAgICAgICAgIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIHRleHR1cmVQYXRoKSxcclxuICAgICAgICAgICAgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xyXG5cclxuICAgICAgICBzcHJpdGUuYW5jaG9yLnggPSBib2R5LnJlbmRlci5zcHJpdGUueE9mZnNldDtcclxuICAgICAgICBzcHJpdGUuYW5jaG9yLnkgPSBib2R5LnJlbmRlci5zcHJpdGUueU9mZnNldDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYm9keSBwcmltaXRpdmVcclxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUJvZHlQcmltaXRpdmVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljc1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgdmFyIF9jcmVhdGVCb2R5UHJpbWl0aXZlID0gZnVuY3Rpb24ocmVuZGVyLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIGJvZHlSZW5kZXIgPSBib2R5LnJlbmRlcixcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxyXG4gICAgICAgICAgICBwcmltaXRpdmUgPSBuZXcgUElYSS5HcmFwaGljcygpLFxyXG4gICAgICAgICAgICBmaWxsU3R5bGUgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLmZpbGxTdHlsZSksXHJcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoYm9keVJlbmRlci5zdHJva2VTdHlsZSksXHJcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlSW5kaWNhdG9yID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoYm9keVJlbmRlci5zdHJva2VTdHlsZSksXHJcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlV2lyZWZyYW1lID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoJyNiYmInKSxcclxuICAgICAgICAgICAgc3Ryb2tlU3R5bGVXaXJlZnJhbWVJbmRpY2F0b3IgPSBDb21tb24uY29sb3JUb051bWJlcignI0NENUM1QycpLFxyXG4gICAgICAgICAgICBwYXJ0O1xyXG5cclxuICAgICAgICBwcmltaXRpdmUuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXHJcbiAgICAgICAgZm9yICh2YXIgayA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKGZpbGxTdHlsZSwgMSk7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKGJvZHlSZW5kZXIubGluZVdpZHRoLCBzdHJva2VTdHlsZSwgMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZSgxLCBzdHJva2VTdHlsZVdpcmVmcmFtZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5tb3ZlVG8ocGFydC52ZXJ0aWNlc1swXS54IC0gYm9keS5wb3NpdGlvbi54LCBwYXJ0LnZlcnRpY2VzWzBdLnkgLSBib2R5LnBvc2l0aW9uLnkpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKHBhcnQudmVydGljZXNbal0ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC52ZXJ0aWNlc1tqXS55IC0gYm9keS5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVUbyhwYXJ0LnZlcnRpY2VzWzBdLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQudmVydGljZXNbMF0ueSAtIGJvZHkucG9zaXRpb24ueSk7XHJcblxyXG4gICAgICAgICAgICBwcmltaXRpdmUuZW5kRmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gYW5nbGUgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dBbmdsZUluZGljYXRvciB8fCBvcHRpb25zLnNob3dBeGVzKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKDEsIHN0cm9rZVN0eWxlV2lyZWZyYW1lSW5kaWNhdG9yLCAxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZSgxLCBzdHJva2VTdHlsZUluZGljYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKCgocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIgLSBib2R5LnBvc2l0aW9uLngpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChwYXJ0LnZlcnRpY2VzWzBdLnkgKyBwYXJ0LnZlcnRpY2VzW3BhcnQudmVydGljZXMubGVuZ3RoLTFdLnkpIC8gMiAtIGJvZHkucG9zaXRpb24ueSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcmVxdWVzdGVkIHRleHR1cmUgKGEgUElYSS5UZXh0dXJlKSB2aWEgaXRzIHBhdGhcclxuICAgICAqIEBtZXRob2QgX2dldFRleHR1cmVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlUGF0aFxyXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICB2YXIgX2dldFRleHR1cmUgPSBmdW5jdGlvbihyZW5kZXIsIGltYWdlUGF0aCkge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF07XHJcblxyXG4gICAgICAgIGlmICghdGV4dHVyZSlcclxuICAgICAgICAgICAgdGV4dHVyZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZVBhdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BoeXNpY3MvbWF0dGVyLWpzL3JlbmRlci9SZW5kZXJQaXhpLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmZvckVhY2hcclxuKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXHJcbiovXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpXHJcbntcclxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc0FyZyAqLylcclxuICAgIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcclxuKi9cclxuaWYgKCFBcnJheS5pc0FycmF5KVxyXG57XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKGFyZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL0FycmF5LmlzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDcwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBDb3B5cmlnaHQgMjAxMyBDaHJpcyBXaWxzb25cblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKlxuXG5UaGlzIG1vbmtleXBhdGNoIGxpYnJhcnkgaXMgaW50ZW5kZWQgdG8gYmUgaW5jbHVkZWQgaW4gcHJvamVjdHMgdGhhdCBhcmVcbndyaXR0ZW4gdG8gdGhlIHByb3BlciBBdWRpb0NvbnRleHQgc3BlYyAoaW5zdGVhZCBvZiB3ZWJraXRBdWRpb0NvbnRleHQpLFxuYW5kIHRoYXQgdXNlIHRoZSBuZXcgbmFtaW5nIGFuZCBwcm9wZXIgYml0cyBvZiB0aGUgV2ViIEF1ZGlvIEFQSSAoZS5nLlxudXNpbmcgQnVmZmVyU291cmNlTm9kZS5zdGFydCgpIGluc3RlYWQgb2YgQnVmZmVyU291cmNlTm9kZS5ub3RlT24oKSksIGJ1dCBtYXlcbmhhdmUgdG8gcnVuIG9uIHN5c3RlbXMgdGhhdCBvbmx5IHN1cHBvcnQgdGhlIGRlcHJlY2F0ZWQgYml0cy5cblxuVGhpcyBsaWJyYXJ5IHNob3VsZCBiZSBoYXJtbGVzcyB0byBpbmNsdWRlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzXG51bnByZWZpeGVkIFwiQXVkaW9Db250ZXh0XCIsIGFuZC9vciBpZiBpdCBzdXBwb3J0cyB0aGUgbmV3IG5hbWVzLlxuXG5UaGUgcGF0Y2hlcyB0aGlzIGxpYnJhcnkgaGFuZGxlczpcbmlmIHdpbmRvdy5BdWRpb0NvbnRleHQgaXMgdW5zdXBwb3J0ZWQsIGl0IHdpbGwgYmUgYWxpYXNlZCB0byB3ZWJraXRBdWRpb0NvbnRleHQoKS5cbmlmIEF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgpIGlzIHVuaW1wbGVtZW50ZWQsIGl0IHdpbGwgYmUgcm91dGVkIHRvIG5vdGVPbigpIG9yXG5ub3RlR3JhaW5PbigpLCBkZXBlbmRpbmcgb24gcGFyYW1ldGVycy5cblxuVGhlIGZvbGxvd2luZyBhbGlhc2VzIG9ubHkgdGFrZSBlZmZlY3QgaWYgdGhlIG5ldyBuYW1lcyBhcmUgbm90IGFscmVhZHkgaW4gcGxhY2U6XG5cbkF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKCkgaXMgYWxpYXNlZCB0byBub3RlT2ZmKClcbkF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCkgaXMgYWxpYXNlZCB0byBjcmVhdGVHYWluTm9kZSgpXG5BdWRpb0NvbnRleHQuY3JlYXRlRGVsYXkoKSBpcyBhbGlhc2VkIHRvIGNyZWF0ZURlbGF5Tm9kZSgpXG5BdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKCkgaXMgYWxpYXNlZCB0byBjcmVhdGVKYXZhU2NyaXB0Tm9kZSgpXG5BdWRpb0NvbnRleHQuY3JlYXRlUGVyaW9kaWNXYXZlKCkgaXMgYWxpYXNlZCB0byBjcmVhdGVXYXZlVGFibGUoKVxuT3NjaWxsYXRvck5vZGUuc3RhcnQoKSBpcyBhbGlhc2VkIHRvIG5vdGVPbigpXG5Pc2NpbGxhdG9yTm9kZS5zdG9wKCkgaXMgYWxpYXNlZCB0byBub3RlT2ZmKClcbk9zY2lsbGF0b3JOb2RlLnNldFBlcmlvZGljV2F2ZSgpIGlzIGFsaWFzZWQgdG8gc2V0V2F2ZVRhYmxlKClcbkF1ZGlvUGFyYW0uc2V0VGFyZ2V0QXRUaW1lKCkgaXMgYWxpYXNlZCB0byBzZXRUYXJnZXRWYWx1ZUF0VGltZSgpXG5cblRoaXMgbGlicmFyeSBkb2VzIE5PVCBwYXRjaCB0aGUgZW51bWVyYXRlZCB0eXBlIGNoYW5nZXMsIGFzIGl0IGlzXG5yZWNvbW1lbmRlZCBpbiB0aGUgc3BlY2lmaWNhdGlvbiB0aGF0IGltcGxlbWVudGF0aW9ucyBzdXBwb3J0IGJvdGggaW50ZWdlclxuYW5kIHN0cmluZyB0eXBlcyBmb3IgQXVkaW9QYW5uZXJOb2RlLnBhbm5pbmdNb2RlbCwgQXVkaW9QYW5uZXJOb2RlLmRpc3RhbmNlTW9kZWxcbkJpcXVhZEZpbHRlck5vZGUudHlwZSBhbmQgT3NjaWxsYXRvck5vZGUudHlwZS5cblxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBleHBvcnRzLCBwZXJmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBmaXhTZXRUYXJnZXQocGFyYW0pIHtcbiAgICBpZiAoIXBhcmFtKVx0Ly8gaWYgTllJLCBqdXN0IHJldHVyblxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcGFyYW0uc2V0VGFyZ2V0QXRUaW1lKVxuICAgICAgcGFyYW0uc2V0VGFyZ2V0QXRUaW1lID0gcGFyYW0uc2V0VGFyZ2V0VmFsdWVBdFRpbWU7XG4gIH1cblxuICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRBdWRpb0NvbnRleHQnKSAmJlxuICAgICAgIXdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnQXVkaW9Db250ZXh0JykpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2Via2l0QXVkaW9Db250ZXh0O1xuXG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVHYWluJykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlO1xuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlRGVsYXknKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5Tm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZVNjcmlwdFByb2Nlc3NvcicpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVTY3JpcHRQcm9jZXNzb3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUphdmFTY3JpcHROb2RlO1xuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlUGVyaW9kaWNXYXZlJykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBlcmlvZGljV2F2ZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlV2F2ZVRhYmxlO1xuXG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUdhaW4gPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW47XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlR2FpbigpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZ2Fpbik7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVEZWxheSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXk7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IGZ1bmN0aW9uKG1heERlbGF5VGltZSkge1xuICAgICAgdmFyIG5vZGUgPSBtYXhEZWxheVRpbWUgPyB0aGlzLmludGVybmFsX2NyZWF0ZURlbGF5KG1heERlbGF5VGltZSkgOiB0aGlzLmludGVybmFsX2NyZWF0ZURlbGF5KCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZWxheVRpbWUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJTb3VyY2U7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJTb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIGlmICghbm9kZS5zdGFydCkge1xuICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uICkge1xuICAgICAgICAgIGlmICggb2Zmc2V0IHx8IGR1cmF0aW9uIClcbiAgICAgICAgICAgIHRoaXMubm90ZUdyYWluT24oIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubm90ZU9uKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQgPSBub2RlLnN0YXJ0O1xuICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24oIHdoZW4sIG9mZnNldCwgZHVyYXRpb24gKSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgKVxuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCggd2hlbiB8fCAwLCBvZmZzZXQsIGR1cmF0aW9uICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCggd2hlbiB8fCAwLCBvZmZzZXQgfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLnN0b3ApIHtcbiAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uKCB3aGVuICkge1xuICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5wbGF5YmFja1JhdGUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3I7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnRocmVzaG9sZCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5rbmVlKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJhdGlvKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlZHVjdGlvbik7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5hdHRhY2spO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucmVsZWFzZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJpcXVhZEZpbHRlcjtcbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJpcXVhZEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZnJlcXVlbmN5KTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmRldHVuZSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5RKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIGlmIChBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCAnY3JlYXRlT3NjaWxsYXRvcicgKSkge1xuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVPc2NpbGxhdG9yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVPc2NpbGxhdG9yO1xuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVPc2NpbGxhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICAgIGlmICghbm9kZS5zdGFydCkge1xuICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAoIHdoZW4gKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCggd2hlbiB8fCAwKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgdGhpcy5ub3RlT2ZmKCB3aGVuIHx8IDAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCA9IG5vZGUuc3RvcDtcbiAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuc2V0UGVyaW9kaWNXYXZlKVxuICAgICAgICAgIG5vZGUuc2V0UGVyaW9kaWNXYXZlID0gbm9kZS5zZXRXYXZlVGFibGU7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmRldHVuZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0JykgJiZcbiAgICAgICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ09mZmxpbmVBdWRpb0NvbnRleHQnKSkge1xuICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgfVxuXG59KHdpbmRvdykpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9BdWRpb0NvbnRleHRNb25rZXlQYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vLyBFUzYgTWF0aC50cnVuYyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmNcclxuaWYgKCFNYXRoLnRydW5jKSB7XHJcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IE1hdGguY2VpbCh4KSA6IE1hdGguZmxvb3IoeCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxyXG4qL1xyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcblxyXG4gICAgLyoganNoaW50IGZyZWV6ZTogZmFsc2UgKi9cclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IHRoaXMgOiB0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gKGZ1bmN0aW9uIEYocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90bylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgc3VwZXJuZXc6IHRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKHRhcmdldC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG59XHJcblxyXG4vKipcclxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5pc0FycmF5XHJcbiovXHJcbmlmICghQXJyYXkuaXNBcnJheSlcclxue1xyXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxyXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcclxue1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXHJcbiAgICB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuKiBMb3ctYnVkZ2V0IEZsb2F0MzJBcnJheSBrbm9jay1vZmYsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBQMi5qcyBpbiBJRTlcclxuKiBTb3VyY2U6IGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvNTk4OC1waGFzZXItMTItaWU5L1xyXG4qIENhbWVyb24gRm9hbGUgKGh0dHA6Ly93d3cua2liaWJ1LmNvbSlcclxuKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcIm9iamVjdFwiKVxyXG57XHJcbiAgICB2YXIgQ2hlYXBBcnJheSA9IGZ1bmN0aW9uKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IEFycmF5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0gPSBmdW5jdGlvbihhcmcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYXJnKSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmc7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0ucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICAgICAgd2luZG93W3R5cGVdLmNvbnN0cnVjdG9yID0gd2luZG93W3R5cGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBDaGVhcEFycmF5KCdGbG9hdDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnSW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0FycmF5QnVmZmVyJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG59XHJcblxyXG4vKipcclxuICogQWxzbyBmaXggZm9yIHRoZSBhYnNlbnQgY29uc29sZSBpbiBJRTlcclxuICovXHJcbmlmICghd2luZG93LmNvbnNvbGUpXHJcbntcclxuICAgIHdpbmRvdy5jb25zb2xlID0ge307XHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2cgPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbiAgICB3aW5kb3cuY29uc29sZS53YXJuID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xyXG59XHJcblxyXG4vKipcclxuICogcGVyZm9ybWFuY2Uubm93XHJcbiAqL1xyXG4oZnVuY3Rpb24oKXtcclxuXHJcbiAgaWYgKFwicGVyZm9ybWFuY2VcIiBpbiB3aW5kb3cgPT0gZmFsc2UpIHtcclxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XHJcbiAgfVxyXG4gIFxyXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXHJcbiAge1xyXG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XHJcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XHJcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDcwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXHJcbmlmICghTWF0aC50cnVuYykge1xyXG4gICAgTWF0aC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BvbHlmaWxscy9NYXRoLnRydW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA3MDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcblxyXG4vKipcclxuKiBMb3ctYnVkZ2V0IEZsb2F0MzJBcnJheSBrbm9jay1vZmYsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBQMi5qcyBpbiBJRTlcclxuKiBTb3VyY2U6IGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvNTk4OC1waGFzZXItMTItaWU5L1xyXG4qIENhbWVyb24gRm9hbGUgKGh0dHA6Ly93d3cua2liaWJ1LmNvbSlcclxuKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcIm9iamVjdFwiKVxyXG57XHJcbiAgICB2YXIgQ2hlYXBBcnJheSA9IGZ1bmN0aW9uKHR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IEFycmF5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0gPSBmdW5jdGlvbihhcmcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YoYXJnKSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmc7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB3aW5kb3dbdHlwZV0ucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICAgICAgd2luZG93W3R5cGVdLmNvbnN0cnVjdG9yID0gd2luZG93W3R5cGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBDaGVhcEFycmF5KCdGbG9hdDMyQXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICBDaGVhcEFycmF5KCdVaW50MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ1VpbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgQ2hlYXBBcnJheSgnSW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIENoZWFwQXJyYXkoJ0FycmF5QnVmZmVyJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxyXG4gKi9cclxuaWYgKCF3aW5kb3cuY29uc29sZSlcclxue1xyXG4gICAgd2luZG93LmNvbnNvbGUgPSB7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gNzExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuICogcGVyZm9ybWFuY2Uubm93XHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGlmICgncGVyZm9ybWFuY2UnIGluIHdpbmRvdyA9PT0gZmFsc2UpXHJcbiAgICB7XHJcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoYW5rcyBJRThcclxuICAgIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09PSBmYWxzZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3cgKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcG9seWZpbGxzL3BlcmZvcm1hbmNlLm5vdy5qc1xuLy8gbW9kdWxlIGlkID0gNzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFJlZmVyZW5jZXM6XHJcbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE1Nzk2NzFcclxuLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cclxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdGltaGFsbC80MDc4NjE0XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS90cmVlL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcblxyXG4vLyBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggQnJvd3NlcmZpeVxyXG4vLyBCcm93c2VyaWZ5IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgdXNlIG9mIGBnbG9iYWxgIGFuZCBwYXNzZXMgdGhlXHJcbi8vIGNvcnJlY3QgcmVmZXJlbmNlIG9mIGBnbG9iYWxgLCBgc2VsZmAsIGFuZCBmaW5hbGx5IGB3aW5kb3dgXHJcblxyXG4vLyBEYXRlLm5vd1xyXG5pZiAoIShEYXRlLm5vdyAmJiBEYXRlLnByb3RvdHlwZS5nZXRUaW1lKSkge1xyXG4gICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcGVyZm9ybWFuY2Uubm93XHJcbmlmICghKGdsb2JhbC5wZXJmb3JtYW5jZSAmJiBnbG9iYWwucGVyZm9ybWFuY2Uubm93KSkge1xyXG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICBpZiAoIWdsb2JhbC5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIGdsb2JhbC5wZXJmb3JtYW5jZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG52YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcblxyXG5mb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxyXG4gICAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG59XHJcblxyXG5pZiAoIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnaXMgbm90IGEgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIGRlbGF5ID0gMTYgKyBsYXN0VGltZSAtIGN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxhc3RUaW1lID0gY3VycmVudFRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhwZXJmb3JtYW5jZS5ub3coKSk7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgIH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcclxudmFyIERyYXdJbWFnZSA9IHJlcXVpcmUoJy4vdXRpbHMvRHJhd0ltYWdlJyk7XHJcbnZhciBCbGl0SW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL0JsaXRJbWFnZScpO1xyXG52YXIgR2V0QmxlbmRNb2RlcyA9IHJlcXVpcmUoJy4vdXRpbHMvR2V0QmxlbmRNb2RlcycpO1xyXG52YXIgR2V0Q29udGV4dCA9IHJlcXVpcmUoJy4uLy4uL2NhbnZhcy9HZXRDb250ZXh0Jyk7XHJcbnZhciBTbmFwc2hvdCA9IHJlcXVpcmUoJy4uLy4uL3NuYXBzaG90L1NuYXBzaG90Jyk7XHJcbnZhciBTbW9vdGhpbmcgPSByZXF1aXJlKCcuLi8uLi9kb20vU21vb3RoaW5nJyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vU2NhbGVNb2RlcycpO1xyXG5cclxudmFyIENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvLyAgTmVlZGVkP1xyXG4gICAgdGhpcy50eXBlID0gQ09OU1QuQ0FOVkFTO1xyXG5cclxuICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcclxuXHJcbiAgICAvLyAgUmVhZCBhbGwgdGhlIGZvbGxvd2luZyBmcm9tIGdhbWUgY29uZmlnIChvciBTdGF0ZSBjb25maWc/KVxyXG4gICAgLy8gdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XHJcbiAgICAvLyB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAvLyB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcclxuICAgIC8vIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICB0aGlzLnNjYWxlTW9kZSA9IChnYW1lLmNvbmZpZy5waXhlbEFydCkgPyBTY2FsZU1vZGVzLk5FQVJFU1QgOiBTY2FsZU1vZGVzLkxJTkVBUjtcclxuXHJcbiAgICB0aGlzLmdhbWVDYW52YXMgPSBnYW1lLmNhbnZhcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxyXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcclxuICAgICAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxyXG4gICAgICovXHJcbiAgICB0aGlzLmdhbWVDb250ZXh0ID0gR2V0Q29udGV4dCh0aGlzLmdhbWVDYW52YXMpO1xyXG5cclxuICAgIHRoaXMuZ2FtZUNvbmZpZyA9IGdhbWUuY29uZmlnO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB0aGlzLmdhbWVDb250ZXh0O1xyXG5cclxuICAgIC8vICBNYXAgdG8gdGhlIHJlcXVpcmVkIGZ1bmN0aW9uXHJcbiAgICB0aGlzLmRyYXdJbWFnZSA9IERyYXdJbWFnZTtcclxuICAgIHRoaXMuYmxpdEltYWdlID0gQmxpdEltYWdlO1xyXG5cclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IEdldEJsZW5kTW9kZXMoKTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XHJcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gMDtcclxuXHJcbiAgICAvLyB0aGlzLnRpbnRNZXRob2QgPSB0aGlzLnRpbnRXaXRoUGVyUGl4ZWw7XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZW5kZXJlcjtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFJlc2l6ZSB0aGUgbWFpbiBnYW1lIGNhbnZhc1xyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXM7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXM7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZUNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5nYW1lQ2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lQ2FudmFzLnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXMpICsgJ3B4JztcclxuICAgICAgICAgICAgdGhpcy5nYW1lQ2FudmFzLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCAvIHJlcykgKyAncHgnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFJlc2l6aW5nIGEgY2FudmFzIHdpbGwgcmVzZXQgaW1hZ2VTbW9vdGhpbmdFbmFibGVkIChhbmQgcHJvYmFibHkgb3RoZXIgcHJvcGVydGllcylcclxuICAgICAgICBpZiAodGhpcy5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTkVBUkVTVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNtb290aGluZy5kaXNhYmxlKHRoaXMuZ2FtZUNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gKGJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBibGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gYmxlbmRNb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEJsZW5kTW9kZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uIChhbHBoYSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IGFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBsb29wXHJcbiAgICBwcmVSZW5kZXI6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBzdGFydCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICMwMGZmMDA7Jyk7XHJcblxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdhbWVDb250ZXh0O1xyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdhbWVDb25maWc7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmNsZWFyQmVmb3JlUmVuZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLnRyYW5zcGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IucmdiYTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEFkZCBQcmUtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIFN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UgLSBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQsIGRpdmlkZWRcclxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxyXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHcgPSBzdGF0ZS5zeXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGggPSBzdGF0ZS5zeXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5zeXMuY29udGV4dDtcclxuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzdGF0ZS5zeXMuc2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIHNjaXNzb3IgPSAoY2FtZXJhLnggIT09IDAgfHwgY2FtZXJhLnkgIT09IDAgfHwgY2FtZXJhLndpZHRoICE9PSBjdHguY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGN0eC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB2YXIgbGlzdCA9IGNoaWxkcmVuLmxpc3Q7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjdHg7XHJcblxyXG4gICAgICAgIC8vICBJZiB0aGUgYWxwaGEgb3IgYmxlbmQgbW9kZSBkaWRuJ3QgY2hhbmdlIHNpbmNlIHRoZSBsYXN0IHJlbmRlciwgdGhlbiBkb24ndCBzZXQgdGhlbSBhZ2FpbiAoc2F2ZXMgMiBvcHMpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbHBoYSAhPT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCbGVuZE1vZGUgIT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IDA7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2xlYXJCZWZvcmVSZW5kZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdywgaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZHJhd0NvdW50ICs9IGxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoc2Npc3NvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnJlY3QoY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcblxyXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbGlzdC5sZW5ndGg7IGMrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbY107XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXJDYW52YXModGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIENhbGwgdGhlIFN0YXRlLnJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIHN0YXRlLnJlbmRlci5jYWxsKHN0YXRlLCBjdHgsIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcclxuICAgICAgICBcclxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cclxuICAgICAgICBpZiAoY2FtZXJhLl9mYWRlQWxwaGEgPiAwIHx8IGNhbWVyYS5fZmxhc2hBbHBoYSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBmYWRlIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgKGNhbWVyYS5fZmFkZVJlZCAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mYWRlR3JlZW4gKiAyNTUpICsgJywnICsgKGNhbWVyYS5fZmFkZUJsdWUgKiAyNTUpICsgJyknO1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBjYW1lcmEuX2ZhZGVBbHBoYTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGZsYXNoIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgKGNhbWVyYS5fZmxhc2hSZWQgKiAyNTUpICsgJywnICsgKGNhbWVyYS5fZmxhc2hHcmVlbiAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mbGFzaEJsdWUgKiAyNTUpICsgJyknO1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBjYW1lcmEuX2ZsYXNoQWxwaGE7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgUmVzZXQgdGhlIGNhbWVyYSBzY2lzc29yXHJcbiAgICAgICAgaWYgKHNjaXNzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyAgQmxhc3QgaXQgdG8gdGhlIEdhbWUgQ2FudmFzIChpZiBuZWVkZWQpXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlclRvVGV4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNvbnRleHQuZHJhd0ltYWdlKHN0YXRlLnN5cy5jYW52YXMsIDAsIDAsIHcsIGgsIHNldHRpbmdzLngsIHNldHRpbmdzLnksIHcsIGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcG9zdFJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIGVuZCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICNmZjAwMDA7Jyk7XHJcblxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdhbWVDb250ZXh0O1xyXG5cclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc25hcHNob3RDYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayhTbmFwc2hvdC5DYW52YXNTbmFwc2hvdCh0aGlzLmdhbWVDYW52YXMpKTtcclxuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBBZGQgUG9zdC1yZW5kZXIgaG9va1xyXG4gICAgfSxcclxuXHJcbiAgICBzbmFwc2hvdDogZnVuY3Rpb24gKGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0gW3JlbW92ZWdhbWVDYW52YXM9dHJ1ZV0ge2Jvb2xlYW59IFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgQ2FudmFzUG9vbFxyXG5cclxuICAgICAgICB0aGlzLmdhbWVDYW52YXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ2FtZUNvbnRleHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8vICBObyBzY2FsaW5nLCBhbmNob3IsIHJvdGF0aW9uIG9yIGVmZmVjdHMsIGxpdGVyYWxseSBkcmF3cyB0aGUgZnJhbWUgZGlyZWN0bHkgdG8gdGhlIGNhbnZhc1xyXG52YXIgQmxpdEltYWdlID0gZnVuY3Rpb24gKGR4LCBkeSwgZnJhbWUsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgZnJhbWUuc291cmNlLmltYWdlLFxyXG4gICAgICAgIGNkLnN4LFxyXG4gICAgICAgIGNkLnN5LFxyXG4gICAgICAgIGNkLnNXaWR0aCxcclxuICAgICAgICBjZC5zSGVpZ2h0LFxyXG4gICAgICAgIGR4IC0gY2FtZXJhLnNjcm9sbFgsXHJcbiAgICAgICAgZHkgLSBjYW1lcmEuc2Nyb2xsWSxcclxuICAgICAgICBjZC5kV2lkdGgsXHJcbiAgICAgICAgY2QuZEhlaWdodFxyXG4gICAgKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxpdEltYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL2NhbnZhcy91dGlscy9CbGl0SW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDcxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIERyYXdJbWFnZSA9IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcclxue1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3VycmVudENvbnRleHQ7XHJcbiAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XHJcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xyXG5cclxuICAgIC8vICBCbGVuZCBNb2RlXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gc3JjLmJsZW5kTW9kZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBzcmMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFscGhhXHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBzcmMuYWxwaGEpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBTbW9vdGhpbmdcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XHJcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHggPSBmcmFtZS54IC0gc3JjLmRpc3BsYXlPcmlnaW5YO1xyXG4gICAgdmFyIGR5ID0gZnJhbWUueSAtIHNyYy5kaXNwbGF5T3JpZ2luWTtcclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZShzcmMueCAtIGNhbWVyYS5zY3JvbGxYLCBzcmMueSAtIGNhbWVyYS5zY3JvbGxZKTtcclxuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcclxuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcclxuICAgIGN0eC5zY2FsZShzcmMuZmxpcFggPyAtMSA6IDEsIHNyYy5mbGlwWSA/IC0xIDogMSk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHNyYy5kV2lkdGggKiAoc3JjLmZsaXBYID8gMSA6IDApLCBzcmMuZEhlaWdodCAqIChzcmMuZmxpcFkgPyAxIDogMCkpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShmcmFtZS5zb3VyY2UuaW1hZ2UsIGNkLnN4LCBjZC5zeSwgY2Quc1dpZHRoLCBjZC5zSGVpZ2h0LCBkeCwgZHksIGNkLmRXaWR0aCwgY2QuZEhlaWdodCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmF3SW1hZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNzE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb2RlcyA9IHJlcXVpcmUoJy4uLy4uL0JsZW5kTW9kZXMnKTtcclxudmFyIENhbnZhc0ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZGV2aWNlL0NhbnZhc0ZlYXR1cmVzJyk7XHJcblxyXG52YXIgR2V0QmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHZhciB1c2VOZXcgPSBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcztcclxuXHJcbiAgICBvdXRwdXRbbW9kZXMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcclxuICAgIG91dHB1dFttb2Rlcy5NVUxUSVBMWV0gPSAodXNlTmV3KSA/ICdtdWx0aXBseScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNDUkVFTl0gPSAodXNlTmV3KSA/ICdzY3JlZW4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5EQVJLRU5dID0gKHVzZU5ldykgPyAnZGFya2VuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTElHSFRFTl0gPSAodXNlTmV3KSA/ICdsaWdodGVuJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5DT0xPUl9CVVJOXSA9ICh1c2VOZXcpID8gJ2NvbG9yLWJ1cm4nIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5IQVJEX0xJR0hUXSA9ICh1c2VOZXcpID8gJ2hhcmQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5ESUZGRVJFTkNFXSA9ICh1c2VOZXcpID8gJ2RpZmZlcmVuY2UnIDogJ3NvdXJjZS1vdmVyJztcclxuICAgIG91dHB1dFttb2Rlcy5FWENMVVNJT05dID0gKHVzZU5ldykgPyAnZXhjbHVzaW9uJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLlNBVFVSQVRJT05dID0gKHVzZU5ldykgPyAnc2F0dXJhdGlvbicgOiAnc291cmNlLW92ZXInO1xyXG4gICAgb3V0cHV0W21vZGVzLkNPTE9SXSA9ICh1c2VOZXcpID8gJ2NvbG9yJyA6ICdzb3VyY2Utb3Zlcic7XHJcbiAgICBvdXRwdXRbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0QmxlbmRNb2RlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXNvdXJjZXMgPSByZXF1aXJlKCcuL3Jlc291cmNlcycpO1xyXG5cclxudmFyIFJlc291cmNlTWFuYWdlciA9IGZ1bmN0aW9uIChnbCkgXHJcbntcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIC8qIE1heWJlIGFkZCBwb29saW5nIGhlcmUgKi9cclxuICAgIHRoaXMuc2hhZGVyQ2FjaGUgPSB7fTtcclxuICAgIHRoaXMuc2hhZGVyQ291bnQgPSAwO1xyXG59O1xyXG5cclxuUmVzb3VyY2VNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblJlc291cmNlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY3JlYXRlUmVuZGVyVGFyZ2V0OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY29sb3JCdWZmZXIsIGRlcHRoU3RlbmNpbEJ1ZmZlcikgXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgZnJhbWVidWZmZXJPYmplY3QgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIHZhciBkZXB0aFN0ZW5jaWxSZW5kZXJidWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHZhciBjb2xvclJlbmRlcmJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gMDtcclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlck9iamVjdClcclxuXHJcbiAgICAgICAgaWYgKGRlcHRoU3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkICYmIGRlcHRoU3RlbmNpbEJ1ZmZlciAhPT0gbnVsbCkgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWxCdWZmZXIuaXNSZW5kZXJUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhTdGVuY2lsQnVmZmVyLnRleHR1cmUsIGRlcHRoU3RlbmNpbEJ1ZmZlci5taXBMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbFJlbmRlcmJ1ZmZlck9iamVjdCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZGVwdGhTdGVuY2lsUmVuZGVyYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGRlcHRoU3RlbmNpbFJlbmRlcmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29sb3JCdWZmZXIgIT09IHVuZGVmaW5lZCAmJiBjb2xvckJ1ZmZlciAhPT0gbnVsbCkgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2xvckJ1ZmZlci5pc1JlbmRlclRleHR1cmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGNvbG9yQnVmZmVyLnRleHR1cmUsIGNvbG9yQnVmZmVyLm1pcExldmVsKTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbG9yUmVuZGVyYnVmZmVyT2JqZWN0ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBjb2xvclJlbmRlcmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5SR0JBNCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuUkVOREVSQlVGRkVSLCBjb2xvclJlbmRlcmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wbGV0ZSA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xyXG5cclxuICAgICAgICBpZiAoY29tcGxldGUgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSBcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAzNjA1NDogJ0luY29tcGxldGUgQXR0YWNobWVudCcsXHJcbiAgICAgICAgICAgICAgICAzNjA1NTogJ01pc3NpbmcgQXR0YWNobWVudCcsXHJcbiAgICAgICAgICAgICAgICAzNjA1NzogJ0luY29tcGxldGUgRGltZW5zaW9ucycsXHJcbiAgICAgICAgICAgICAgICAzNjA2MTogJ0ZyYW1lYnVmZmVyIFVuc3VwcG9ydGVkJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGluY29tcGxldGUuIEZyYW1lYnVmZmVyIHN0YXR1czogJyArIGVycm9yc1tjb21wbGV0ZV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMuUmVuZGVyVGFyZ2V0KFxyXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlck9iamVjdCxcclxuICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgKGNvbG9yQnVmZmVyID09PSB1bmRlZmluZWQgPyBudWxsIDogY29sb3JCdWZmZXIpLFxyXG4gICAgICAgICAgICAoZGVwdGhTdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwdGhTdGVuY2lsQnVmZmVyKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJ1ZmZlcjogZnVuY3Rpb24gKHRhcmdldCwgaW5pdGlhbERhdGFPclNpemUsIGJ1ZmZlclVzYWdlKSBcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBidWZmZXJPYmplY3QgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKHRhcmdldCwgaW5pdGlhbERhdGFPclNpemUsIGJ1ZmZlclVzYWdlKTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0YXJnZXQpIFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSBnbC5BUlJBWV9CVUZGRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlcy5WZXJ0ZXhCdWZmZXIoZ2wsIGJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlcy5JbmRleEJ1ZmZlcihnbCwgYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCdWZmZXIgVGFyZ2V0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24gKG1pcExldmVsLCBtaW5GaWx0ZXIsIG1hZ0ZpbHRlciwgd3JhcFQsIHdyYXBTLCBmb3JtYXQsIHBpeGVscywgd2lkdGgsIGhlaWdodCkgXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIG1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIG1hZ0ZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgd3JhcFMpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBUKTtcclxuXHJcbiAgICAgICAgaWYgKHBpeGVscyA9PT0gbnVsbCB8fCBwaXhlbHMgPT09IHVuZGVmaW5lZCkgXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcExldmVsLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBMZXZlbCwgZm9ybWF0LCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gcGl4ZWxzLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBwaXhlbHMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMuVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU2hhZGVyOiBmdW5jdGlvbiAoc2hhZGVyTmFtZSwgc2hhZGVyU291cmNlcykgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlck5hbWUgPT09IG51bGwgfHwgc2hhZGVyTmFtZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2hhZGVyTmFtZSArPSAnU2hhZGVyJyArIHRoaXMuc2hhZGVyQ291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ291bnQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoc2hhZGVyTmFtZSBpbiB0aGlzLnNoYWRlckNhY2hlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtO1xyXG4gICAgICAgICAgICB2YXIgdmVydFNoYWRlcjtcclxuICAgICAgICAgICAgdmFyIGZyYWdTaGFkZXI7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXM7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcjtcclxuICAgICAgICAgICAgdmFyIHNoYWRlcjtcclxuXHJcbiAgICAgICAgICAgIHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0U2hhZGVyLCBzaGFkZXJTb3VyY2VzLnZlcnQpO1xyXG4gICAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpO1xyXG5cclxuICAgICAgICAgICAgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRTaGFkZXIpO1xyXG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgJiYgZXJyb3IgJiYgZXJyb3IubGVuZ3RoID4gMCkgXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IFNoYWRlciBDb21waWxhdGlvbiBFcnJvci4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IgKyAnXFxuXFxuIFNoYWRlciBzb3VyY2U6XFxuJyArIHNoYWRlclNvdXJjZXMudmVydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IubGVuZ3RoID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdWZXJ0ZXggU2hhZGVyIENvbXBpbGF0aW9uIFdhcm5pbmcuIFNoYWRlciBuYW1lOiAnICsgc2hhZGVyTmFtZSArICcuXFxuJyArIGVycm9yICsgJ1xcblxcbiBTaGFkZXIgc291cmNlOlxcbicgKyBzaGFkZXJTb3VyY2VzLnZlcnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmcmFnU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZShmcmFnU2hhZGVyLCBzaGFkZXJTb3VyY2VzLmZyYWcpO1xyXG4gICAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdTaGFkZXIpO1xyXG5cclxuICAgICAgICAgICAgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpO1xyXG4gICAgICAgICAgICBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ1NoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgJiYgZXJyb3IgJiYgZXJyb3IubGVuZ3RoID4gMCkgXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhZ21lbnQgU2hhZGVyIENvbXBpbGF0aW9uIEVycm9yLiBTaGFkZXIgbmFtZTogJyArIHNoYWRlck5hbWUgKyAnLlxcbicgKyBlcnJvciArICdcXG5cXG4gU2hhZGVyIHNvdXJjZTpcXG4nICsgc2hhZGVyU291cmNlcy5mcmFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZyYWdtZW50IFNoYWRlciBDb21waWxhdGlvbiBXYXJuaW5nLiBTaGFkZXIgbmFtZTogJyArIHNoYWRlck5hbWUgKyAnLlxcbicgKyBlcnJvciArICdcXG5cXG4gU2hhZGVyIHNvdXJjZTpcXG4nICsgc2hhZGVyU291cmNlcy5mcmFnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpO1xyXG4gICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgICAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICBlcnJvciA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbSBMaW5raW5nIEVycm9yLiBTaGFkZXIgbmFtZTogJyArIHNoYWRlck5hbWUgKyAnLlxcbicgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGVycm9yID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2dyYW0gVmFsaWRhdGlvbiBFcnJvci4gU2hhZGVyIG5hbWU6ICcgKyBzaGFkZXJOYW1lICsgJy5cXG4nICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzaGFkZXIgPSBuZXcgUmVzb3VyY2VzLlNoYWRlcihzaGFkZXJOYW1lLCBnbCwgcHJvZ3JhbSwgdmVydFNoYWRlciwgZnJhZ1NoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2FjaGVbc2hhZGVyTmFtZV0gPSBzaGFkZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAgc2hhZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDYWNoZVtzaGFkZXJOYW1lXTsgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGV0ZVNoYWRlcjogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RvcmVkU2hhZGVyID0gdGhpcy5zaGFkZXJDYWNoZVtzaGFkZXIubmFtZV1cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGlmIChzdG9yZWRTaGFkZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNoYWRlckNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyLnZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlci5mcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XHJcbiAgICAgICAgc2hhZGVyLnZlcnRleFNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gbnVsbDtcclxuICAgICAgICBzaGFkZXIucHJvZ3JhbSA9IG51bGw7XHJcbiAgICAgICAgc2hhZGVyLm5hbWUgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGVCdWZmZXI6IGZ1bmN0aW9uIChidWZmZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlci5idWZmZXJPYmplY3QpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL1Jlc291cmNlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSAoQHBob3RvbnN0b3JtKVxyXG4qIEBhdXRob3IgICAgICAgRmVsaXBlIEFsZm9uc28gKEBiaXRuZW5mZXIpXHJcbiogQGNvcHlyaWdodCAgICAyMDE3IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBCbGl0dGVyQmF0Y2ggPSByZXF1aXJlKCcuL3JlbmRlcmVycy9ibGl0dGVyYmF0Y2gvQmxpdHRlckJhdGNoJyk7XHJcbnZhciBRdWFkQmF0Y2ggPSByZXF1aXJlKCcuL3JlbmRlcmVycy9xdWFkYmF0Y2gvUXVhZEJhdGNoJyk7XHJcbnZhciBTcHJpdGVCYXRjaCA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3Nwcml0ZWJhdGNoL1Nwcml0ZUJhdGNoJyk7XHJcbnZhciBUaWxlQmF0Y2ggPSByZXF1aXJlKCcuL3JlbmRlcmVycy90aWxlYmF0Y2gvVGlsZUJhdGNoJyk7XHJcbnZhciBTaGFwZUJhdGNoID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvc2hhcGViYXRjaC9TaGFwZUJhdGNoJyk7XHJcbnZhciBFZmZlY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL2VmZmVjdHJlbmRlcmVyL0VmZmVjdFJlbmRlcmVyJyk7XHJcbnZhciBUaWxlbWFwUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy90aWxlbWFwcmVuZGVyZXIvVGlsZW1hcFJlbmRlcmVyJyk7XHJcbnZhciBCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vQmxlbmRNb2RlcycpO1xyXG52YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL1NjYWxlTW9kZXMnKTtcclxudmFyIFJlc291cmNlTWFuYWdlciA9IHJlcXVpcmUoJy4vUmVzb3VyY2VNYW5hZ2VyJyk7XHJcbnZhciBSZXNvdXJjZXMgPSByZXF1aXJlKCcuL3Jlc291cmNlcycpO1xyXG52YXIgU25hcHNob3QgPSByZXF1aXJlKCcuLi8uLi9zbmFwc2hvdC9TbmFwc2hvdCcpO1xyXG5cclxudmFyIFdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IENPTlNULldFQkdMO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuXHJcbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcclxuXHJcbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xyXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcclxuICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xyXG4gICAgdGhpcy5tdWx0aVRleHR1cmUgPSBmYWxzZTtcclxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xyXG4gICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBudWxsO1xyXG4gICAgdGhpcy5yZW5kZXJlckFycmF5ID0gW107XHJcbiAgICB0aGlzLmJsaXR0ZXJCYXRjaCA9IG51bGw7XHJcbiAgICB0aGlzLmFhUXVhZEJhdGNoID0gbnVsbDtcclxuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBudWxsO1xyXG4gICAgdGhpcy5zaGFwZUJhdGNoID0gbnVsbDtcclxuICAgIHRoaXMuZWZmZWN0UmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZSA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlckNhY2hlID0ge307XHJcbiAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zY2lzc29yID0ge1xyXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDBcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn07XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyZXI7XHJcblxyXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdXZWJHTFJlbmRlcmVyLmluaXQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCd3ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpIHx8IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB0aGlzLmNvbmZpZy5XZWJHTENvbnRleHRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0TG9zdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuIFRyeSB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdhbWUuY29uZmlnLmJhY2tncm91bmRDb2xvcjtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKGdsKTtcclxuICAgIFxyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihjb2xvci5yZWRHTCwgY29sb3IuZ3JlZW5HTCwgY29sb3IuYmx1ZUdMLCBjb2xvci5hbHBoYUdMKTtcclxuXHJcbiAgICAgICAgLy8gIE1hcCBCbGVuZCBNb2Rlc1xyXG5cclxuICAgICAgICB2YXIgYWRkID0gWyBnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQSBdO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF07XHJcbiAgICAgICAgdmFyIG11bHRpcGx5ID0gWyBnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTtcclxuICAgICAgICB2YXIgc2NyZWVuID0gWyBnbC5TUkNfQUxQSEEsIGdsLk9ORSBdO1xyXG5cclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSBbXHJcbiAgICAgICAgICAgIG5vcm1hbCwgYWRkLCBtdWx0aXBseSwgc2NyZWVuLCBub3JtYWwsXHJcbiAgICAgICAgICAgIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCxcclxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLFxyXG4gICAgICAgICAgICBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLCBub3JtYWxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IC0xO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcclxuICAgICAgICB0aGlzLmJsaXR0ZXJCYXRjaCA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IEJsaXR0ZXJCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5xdWFkQmF0Y2ggPSB0aGlzLmFkZFJlbmRlcmVyKG5ldyBRdWFkQmF0Y2godGhpcy5nYW1lLCBnbCwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSB0aGlzLmFkZFJlbmRlcmVyKG5ldyBTcHJpdGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZUJhdGNoID0gdGhpcy5hZGRSZW5kZXJlcihuZXcgU2hhcGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RSZW5kZXJlciA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IEVmZmVjdFJlbmRlcmVyKHRoaXMuZ2FtZSwgZ2wsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLnRpbGVCYXRjaCA9IHRoaXMuYWRkUmVuZGVyZXIobmV3IFRpbGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIgPSB0aGlzLmFkZFJlbmRlcmVyKG5ldyBUaWxlbWFwUmVuZGVyZXIodGhpcy5nYW1lLCBnbCwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gdGhpcy5zcHJpdGVCYXRjaDtcclxuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgwKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uIChzb3VyY2UsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgd2lkdGggPSBzb3VyY2UgPyBzb3VyY2Uud2lkdGggOiB3aWR0aDtcclxuICAgICAgICBoZWlnaHQgPSBzb3VyY2UgPyBzb3VyY2UuaGVpZ2h0IDogaGVpZ2h0O1xyXG4gICAgICAgIHZhciBwb3QgPSAoKHdpZHRoICYgKHdpZHRoIC0gMSkpID09IDAgJiYgKGhlaWdodCAmIChoZWlnaHQgLSAxKSkgPT0gMCk7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZ2wuTkVBUkVTVDtcclxuICAgICAgICB2YXIgd3JhcCA9IHBvdCA/IGdsLlJFUEVBVCA6IGdsLkNMQU1QX1RPX0VER0U7XHJcblxyXG4gICAgICAgIGlmICghc291cmNlLmdsVGV4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyID0gZ2wuTElORUFSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTkVBUkVTVCB8fCB0aGlzLmdhbWUuY29uZmlnLnBpeGVsQXJ0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBnbC5ORUFSRVNUO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZSAmJiB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuZ2xUZXh0dXJlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlVGV4dHVyZShcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcCxcclxuICAgICAgICAgICAgICAgICAgICB3cmFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGdsLlJHQkEsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmdsVGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVRleHR1cmUoXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcCxcclxuICAgICAgICAgICAgICAgICAgICBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5pbWFnZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZSA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmU6IGZ1bmN0aW9uICh0ZXh0dXJlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUZXh0dXJlICE9PSB0ZXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICE9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChyZW5kZXJlciwgdGV4dHVyZSwgcmVuZGVyVGFyZ2V0KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXIgfHwgdGhpcy5jdXJyZW50UmVuZGVyZXIuc2hvdWxkRmx1c2goKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZW5kZXJUYXJnZXQ6IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlbmRlclRhcmdldCAhPT0gcmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXQuc2hvdWxkQ2xlYXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuc2hvdWxkQ2xlYXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRvUmVzaXplKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXNvbHV0aW9uKSArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXNvbHV0aW9uKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMucmVuZGVyZXJBcnJheS5sZW5ndGg7IGkgPCBsOyArK2kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyQXJyYXlbaV0uYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyQXJyYXlbaV0ucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vICBDYWxsIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIGxvb3BcclxuICAgIHByZVJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChudWxsKTtcclxuXHJcbiAgICAgICAgLy8gIE5vIHBvaW50IHJlbmRlcmluZyBpZiBvdXIgY29udGV4dCBoYXMgYmVlbiBibG93biB1cCFcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0TG9zdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBBZGQgUHJlLXJlbmRlciBob29rXHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nYW1lLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoY29sb3IucmVkR0wsIGNvbG9yLmdyZWVuR0wsIGNvbG9yLmJsdWVHTCwgY29sb3IuYWxwaGFHTCk7XHJcblxyXG4gICAgICAgIC8vIFNvbWUgZHJpdmVycyByZXF1aXJlIHRvIGNhbGwgZ2xDbGVhclxyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlcy5OT1JNQUwpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBzaW5nbGUgU3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0byBiZSByZW5kZXJlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSAtIFRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzbid0IGJlZW4gc2ltdWxhdGVkIHlldCwgZGl2aWRlZFxyXG4gICAgICogICBieSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB3aWxsIGJlIHNpbXVsYXRlZCB0aGUgbmV4dCB0aW1lIHVwZGF0ZSgpXHJcbiAgICAgKiAgIHJ1bnMuIFVzZWZ1bCBmb3IgaW50ZXJwb2xhdGluZyBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKHN0YXRlLCBjaGlsZHJlbiwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICAvLyAgQ291bGQgbW92ZSB0byB0aGUgU3RhdGUgU3lzdGVtcyBvciBNYWluTG9vcFxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIHRoaXMuc2Npc3Nvci5lbmFibGVkID0gKGNhbWVyYS54ICE9PSAwIHx8IGNhbWVyYS55ICE9PSAwIHx8IGNhbWVyYS53aWR0aCAhPT0gZ2wuY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGdsLmNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFJlbmRlclRhcmdldChudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2Npc3Nvci5lbmFibGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNjaXNzb3IueCA9IGNhbWVyYS54O1xyXG4gICAgICAgICAgICB0aGlzLnNjaXNzb3IueSA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgLSBjYW1lcmEueSAtIGNhbWVyYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2Npc3Nvci53aWR0aCA9IGNhbWVyYS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zY2lzc29yLmhlaWdodCA9IGNhbWVyYS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBnbC5zY2lzc29yKHRoaXMuc2Npc3Nvci54LCB0aGlzLnNjaXNzb3IueSwgdGhpcy5zY2lzc29yLndpZHRoLCB0aGlzLnNjaXNzb3IuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGNvdWxkIGVpdGhlciBjbGVhciBjb2xvciBvciByZW5kZXIgYSBxdWFkXHJcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nYW1lLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihjb2xvci5yZWRHTCwgY29sb3IuZ3JlZW5HTCwgY29sb3IuYmx1ZUdMLCBjb2xvci5hbHBoYUdMKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgdmFyIGxpc3QgPSBjaGlsZHJlbi5saXN0O1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0dGluZyBibGVuZCBtb2RlIGlmIG5lZWRlZCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmN1cnJlbnRSZW5kZXJlcjtcclxuICAgICAgICAgICAgdmFyIG5ld0JsZW5kTW9kZSA9IGNoaWxkLmJsZW5kTW9kZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gbmV3QmxlbmRNb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBibGVuZCA9IHRoaXMuYmxlbmRNb2Rlc1tuZXdCbGVuZE1vZGVdO1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgICAgIGlmIChibGVuZC5sZW5ndGggPiAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGJsZW5kWzBdLCBibGVuZFsxXSwgYmxlbmRbMl0sIGJsZW5kWzNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoYmxlbmRbMF0sIGJsZW5kWzFdKTsgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBuZXdCbGVuZE1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRyYXdpbmcgY2hpbGRcclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyV2ViR0wodGhpcywgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xyXG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMuY3VycmVudFJlbmRlcmVyO1xyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuaXNGdWxsKCkgfHwgcmVuZGVyZXIuc2hvdWxkRmx1c2goKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYW1lcmEuX2ZhZGVBbHBoYSA+IDAgfHwgY2FtZXJhLl9mbGFzaEFscGhhID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgcXVhZEJhdGNoID0gdGhpcy5xdWFkQmF0Y2g7XHJcbiAgICAgICAgICAgIHF1YWRCYXRjaC5iaW5kKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBmYWRlIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBxdWFkQmF0Y2guYWRkKFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlUmVkLCBcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5fZmFkZUdyZWVuLCBcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5fZmFkZUJsdWUsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlQWxwaGFcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGZsYXNoIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBxdWFkQmF0Y2guYWRkKFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLngsIGNhbWVyYS55LCBjYW1lcmEud2lkdGgsIGNhbWVyYS5oZWlnaHQsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaFJlZCwgXHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZsYXNoR3JlZW4sIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEJsdWUsIFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEFscGhhXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHF1YWRCYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5zY2lzc29yLmVuYWJsZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQ2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlciBsb29wICh0aWR5IHRoaW5ncyB1cCwgZXRjKVxyXG4gICAgcG9zdFJlbmRlcjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zbmFwc2hvdENhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrKFNuYXBzaG90LldlYkdMU25hcHNob3QodGhpcy52aWV3KSk7XHJcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQWRkIFBvc3QtcmVuZGVyIGhvb2tcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBlbmQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjZmYwMDAwOycpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzbmFwc2hvdDogZnVuY3Rpb24gKGNhbGxiYWNrKSBcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUZCTzogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAobmV3QmxlbmRNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5jdXJyZW50UmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIGJsZW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSBuZXdCbGVuZE1vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJsZW5kID0gdGhpcy5ibGVuZE1vZGVzW25ld0JsZW5kTW9kZV07XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoYmxlbmRbMF0sIGJsZW5kWzFdLCBibGVuZFsyXSwgYmxlbmRbM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7ICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBuZXdCbGVuZE1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRSZW5kZXJlcjogZnVuY3Rpb24gKHJlbmRlcmVySW5zdGFuY2UpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5yZW5kZXJlckFycmF5LmluZGV4T2YocmVuZGVyZXJJbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA8IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyQXJyYXkucHVzaChyZW5kZXJlckluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVySW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZUZpbHRlck1vZGU6IGZ1bmN0aW9uICh0ZXh0dXJlLCBmaWx0ZXJNb2RlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIGdsRmlsdGVyID0gWyBnbC5MSU5FQVIsIGdsLk5FQVJFU1QgXVtmaWx0ZXJNb2RlXTtcclxuXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xGaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbEZpbHRlcik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUZXh0dXJlICE9PSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5jdXJyZW50VGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBsb2FkQ2FudmFzVG9HUFU6IGZ1bmN0aW9uIChzcmNDYW52YXMsIGRzdFRleHR1cmUsIHNob3VsZFVwZGF0ZVJlc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmICghZHN0VGV4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRzdFRleHR1cmUgPSBuZXcgUmVzb3VyY2VzLlRleHR1cmUobnVsbCwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8qIG9ubHkgY2FsbCB0aGlzIG9uY2UgKi9cclxuICAgICAgICAgICAgZHN0VGV4dHVyZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlUmVzb3VyY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvKiBVcGRhdGUgcmVzb3VyY2UgKi9cclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZHN0VGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzcmNDYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvKiBBbGxvY2F0ZSBvciBSZWFsbG9jYXRlIHJlc291cmNlICovXHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGRzdFRleHR1cmUudGV4dHVyZSk7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgc3JjQ2FudmFzKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkc3RUZXh0dXJlLndpZHRoID0gc3JjQ2FudmFzLndpZHRoO1xyXG4gICAgICAgIGRzdFRleHR1cmUuaGVpZ2h0ID0gc3JjQ2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgICAgLyogd2UgbXVzdCByZWJpbmQgb2xkIHRleHR1cmUgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRzdFRleHR1cmU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMUmVuZGVyZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRhQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMzInKTtcclxudmFyIERhdGFCdWZmZXIxNiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIxNicpO1xyXG52YXIgVGV4dHVyZWRBbmRBbHBoYVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVGV4dHVyZWRBbmRBbHBoYVNoYWRlcicpO1xyXG5cclxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBCbGl0dGVyQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcclxuICAgIHRoaXMubWF4UGFydGljbGVzID0gbnVsbDtcclxuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgIHRoaXMuY3VycmVudFRleHR1cmUyRCA9IG51bGw7XHJcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbn07XHJcblxyXG5CbGl0dGVyQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxpdHRlckJhdGNoO1xyXG5cclxuQmxpdHRlckJhdGNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xyXG4gICAgICAgIHZhciBpbmRleERhdGFCdWZmZXIgPSBuZXcgRGF0YUJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVGV4dHVyZWRBbmRBbHBoYVNoYWRlcicsIFRleHR1cmVkQW5kQWxwaGFTaGFkZXIpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVFJFQU1fRFJBVyk7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9QQVJUSUNMRVMgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2FscGhhJyksIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDE2KTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSB2ZXJ0ZXhCdWZmZXJPYmplY3Q7XHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcbiAgICAgICAgdGhpcy5tYXhQYXJ0aWNsZXMgPSBtYXg7XHJcblxyXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXhBID0gMCwgaW5kZXhCID0gMDsgaW5kZXhBIDwgbWF4OyBpbmRleEEgKz0gQ09OU1QuUEFSVElDTEVfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5QQVJUSUNMRV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIGFjdGl2ZVNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2JsaXR0ZXJiYXRjaC9CbGl0dGVyQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDcyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjMikgKyBzaXplb2YoZmxvYXQpXHJcbiAgICBWRVJURVhfU0laRTogMjAsXHJcbiAgICBJTkRFWF9TSVpFOiAyLFxyXG4gICAgUEFSVElDTEVfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgUEFSVElDTEVfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBQQVJUSUNMRV9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA1LFxyXG5cclxuICAgIC8vIENhbid0IGJlIGJpZ2dlciB0aGFuIDEwLDAwMCBzaW5jZSBpbmRleCBhcmUgMTYtYml0XHJcbiAgICBNQVhfUEFSVElDTEVTOiAyMDAwLFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2JsaXR0ZXJiYXRjaC9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRhQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMzInKTtcclxudmFyIERhdGFCdWZmZXIxNiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIxNicpO1xyXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcclxudmFyIFRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIEVmZmVjdFJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICB0aGlzLm1heFNwcml0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuICAgIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuRWZmZWN0UmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWZmZWN0UmVuZGVyZXI7XHJcblxyXG5FZmZlY3RSZW5kZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5RVUFEX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9RVUFEUyk7XHJcbiAgICAgICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMTYoQ09OU1QuSU5ERVhfU0laRSAqIENPTlNULlFVQURfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfUVVBRFMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJywgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfUVVBRFMgKiBDT05TVC5RVUFEX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBpbmRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2NvbG9yJyksIDMsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAxNik7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfYWxwaGEnKSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMjApO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlFVQURfSU5ERVhfQ09VTlQsIGluZGV4QiArPSBDT05TVC5RVUFEX1ZFUlRFWF9DT1VOVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMV0gPSBpbmRleEIgKyAxO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAyXSA9IGluZGV4QiArIDI7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNF0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA1XSA9IGluZGV4QiArIDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbmRleEJ1ZmZlck9iamVjdC51cGRhdGVSZXNvdXJjZShpbmRleEJ1ZmZlciwgMCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbiwgc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciBhY3RpdmVTaGFkZXIgPSBzaGFkZXIgIT09IHVuZGVmaW5lZCA/IHNoYWRlciA6IHRoaXMuc2hhZGVyO1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgYWN0aXZlU2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICBhY3RpdmVTaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4JyksXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJFZmZlY3Q6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjYW1lcmEsIHRleHR1cmUsIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeCA9IHRoaXMudGVtcE1hdHJpeDtcclxuICAgICAgICB2YXIgYWxwaGEgPSAxNjc3NzIxNjtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZVdpZHRoICogKGdhbWVPYmplY3QuZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlSGVpZ2h0ICogKGdhbWVPYmplY3QuZmxpcFkgPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIHggPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWCArICgodGV4dHVyZVdpZHRoKSAqIChnYW1lT2JqZWN0LmZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gLWdhbWVPYmplY3QuZGlzcGxheU9yaWdpblkgKyAoKHRleHR1cmVIZWlnaHQpICogKGdhbWVPYmplY3QuZmxpcFkgPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG5cclxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICAgICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICAgICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mOyBcclxuICAgICAgICBcclxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDEgPSB4ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkyID0geHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0UmVuZGVyZXIodGhpcywgdGV4dHVyZSwgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMuZmx1c2goZ2FtZU9iamVjdC5kc3RTaGFkZXIpO1xyXG4gICAgICAgIGdhbWVPYmplY3QuZHN0UmVuZGVyVGFyZ2V0LnNob3VsZENsZWFyID0gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RSZW5kZXJlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvZWZmZWN0cmVuZGVyZXIvRWZmZWN0UmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSAoc2l6ZW9mKHZlYzIpICogNCkgKyAoc2l6ZW9mKGZsb2F0KSArIHNpemVvZih1aW50MzIpKVxyXG4gICAgVkVSVEVYX1NJWkU6IDI0LFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFFVQURfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgUVVBRF9JTkRFWF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cclxuICAgIFFVQURfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxyXG4gICAgTUFYX1FVQURTOiAyXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL2VmZmVjdHJlbmRlcmVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgRGF0YUJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjE2Jyk7XHJcbnZhciBVbnRleHR1cmVkQW5kVGludGVkU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vc2hhZGVycy9VbnRleHR1cmVkQW5kVGludGVkU2hhZGVyJyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFF1YWRCYXRjaCA9IGZ1bmN0aW9uIChnYW1lLCBnbCwgbWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG4gICAgdGhpcy5tYXhRdWFkcyA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XHJcbn07XHJcblxyXG5RdWFkQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZEJhdGNoO1xyXG5cclxuUXVhZEJhdGNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQgKiBDT05TVC5NQVhfQUFRVUFEKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuQUFRVUFEX0lOREVYX0NPVU5UICogQ09OU1QuTUFYX0FBUVVBRCk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdVbnRleHR1cmVkQW5kVGludGVkU2hhZGVyJywgVW50ZXh0dXJlZEFuZFRpbnRlZFNoYWRlcik7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUUkVBTV9EUkFXKTtcclxuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV92aWV3X21hdHJpeCcpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX0FBUVVBRCAqIENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVDtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgOCk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBpbmRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gdmVydGV4QnVmZmVyT2JqZWN0O1xyXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgY2hlY2sgaWYgdGhlIGJ1ZmZlcnMgYXJlIGZ1bGwgYmVmb3JlIGZsdXNoaW5nXHJcbiAgICAgICAgLy8gdGhpcyBpcyB0byBnaXZlIGZyZWVkb20gb2Ygd2hlbiBzaG91bGQgdGhlIHJlbmRlcmVyIGZsdXNoLiB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgZmxvYXRCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5BQVFVQURfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpO1xyXG5cclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB4O1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHk7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSByZWQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYmx1ZTtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XHJcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJlZDtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBncmVlbjtcclxuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBibHVlO1xyXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Q291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIGFjdGl2ZVNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWFkQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3F1YWRiYXRjaC9RdWFkQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDcyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjNClcclxuICAgIFZFUlRFWF9TSVpFOiAyNCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBBQVFVQURfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgQUFRVUFEX0lOREVYX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgQUFRVUFEX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXHJcbiAgICBNQVhfQUFRVUFEOiAyMDAwLFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3F1YWRiYXRjaC9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNzI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRhQnVmZmVyMzIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9EYXRhQnVmZmVyMzInKTtcclxudmFyIEVhcmN1dCA9IHJlcXVpcmUoJy4vZWFyY3V0Jyk7XHJcbnZhciBVbnRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3NoYWRlcnMvVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInKTtcclxuXHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgU2hhcGVCYXRjaCA9IGZ1bmN0aW9uIChnYW1lLCBnbCwgbWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG4gICAgdGhpcy5tYXhWZXJ0aWNlcyA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLnRlbXBUcmlhbmdsZSA9IFtcclxuICAgICAgICB7eDogMCwgeTogMCwgd2lkdGg6IDAsIHJnYjogMHhGRkZGRkYsIGFscGhhOiAxLjB9LFxyXG4gICAgICAgIHt4OiAwLCB5OiAwLCB3aWR0aDogMCwgcmdiOiAweEZGRkZGRiwgYWxwaGE6IDEuMH0sXHJcbiAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcclxuICAgICAgICB7eDogMCwgeTogMCwgd2lkdGg6IDAsIHJnYjogMHhGRkZGRkYsIGFscGhhOiAxLjB9XHJcbiAgICBdO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG5cclxufTtcclxuXHJcblNoYXBlQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCYXRjaDtcclxuXHJcblNoYXBlQmF0Y2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5NQVhfVkVSVElDRVMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInLCBVbnRleHR1cmVkQW5kTm9ybWFsaXplZFRpbnRlZFNoYWRlcik7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSwgZ2wuU1RSRUFNX0RSQVcpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9WRVJUSUNFUztcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfY29sb3InKSwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2FscGhhJyksIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDEyKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLm1heFZlcnRpY2VzID0gbWF4O1xyXG4gICAgICAgIHRoaXMucG9seWdvbkNhY2hlID0gW107XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG91bGRGbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlTGVuZ3RoKCkgPj0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24sIHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmx1c2g6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UodmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpLCAwKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdGhpcy52ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG5cclxuICAgICAgICBhY3RpdmVTaGFkZXIuc2V0Q29uc3RhbnRNYXRyaXg0eDQoXHJcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxyXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLndpZHRoLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLmhlaWdodCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAtMSwgMSwgMCwgMFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVTaGFkZXIodGhpcy5zaGFkZXIpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyT2JqZWN0KTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkTGluZTogZnVuY3Rpb24gKFxyXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cclxuICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgLyogbGluZSBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgYXgsIGF5LCBieCwgYnksIGFMaW5lV2lkdGgsIGJMaW5lV2lkdGgsIGFMaW5lQ29sb3IsIGJMaW5lQ29sb3IsIGxpbmVBbHBoYSxcclxuICAgICAgICAvKiB0cmFuc2Zvcm0gKi9cclxuICAgICAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxyXG4gICAgICAgIGN1cnJlbnRNYXRyaXhcclxuICAgICkge1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XHJcblxyXG4gICAgICAgIHZhciBhMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzBdO1xyXG4gICAgICAgIHZhciBiMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzFdO1xyXG4gICAgICAgIHZhciBjMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzJdO1xyXG4gICAgICAgIHZhciBkMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzNdO1xyXG4gICAgICAgIHZhciBlMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzRdO1xyXG4gICAgICAgIHZhciBmMCA9IGN1cnJlbnRNYXRyaXgubWF0cml4WzVdO1xyXG4gICAgICAgIHZhciBhID0gYTEgKiBhMCArIGIxICogYzA7XHJcbiAgICAgICAgdmFyIGIgPSBhMSAqIGIwICsgYjEgKiBkMDtcclxuICAgICAgICB2YXIgYyA9IGMxICogYTAgKyBkMSAqIGMwO1xyXG4gICAgICAgIHZhciBkID0gYzEgKiBiMCArIGQxICogZDA7XHJcbiAgICAgICAgdmFyIGUgPSBlMSAqIGEwICsgZjEgKiBjMCArIGUwO1xyXG4gICAgICAgIHZhciBmID0gZTEgKiBiMCArIGYxICogZDAgKyBmMDtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlclUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIGR4ID0gYnggLSBheDtcclxuICAgICAgICB2YXIgZHkgPSBieSAtIGF5O1xyXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgIHZhciBhbDAgPSBhTGluZVdpZHRoICogKGJ5IC0gYXkpIC8gbGVuO1xyXG4gICAgICAgIHZhciBhbDEgPSBhTGluZVdpZHRoICogKGF4IC0gYngpIC8gbGVuO1xyXG4gICAgICAgIHZhciBibDAgPSBiTGluZVdpZHRoICogKGJ5IC0gYXkpIC8gbGVuO1xyXG4gICAgICAgIHZhciBibDEgPSBiTGluZVdpZHRoICogKGF4IC0gYngpIC8gbGVuO1xyXG4gICAgICAgIHZhciBseDAgPSBieCAtIGJsMDtcclxuICAgICAgICB2YXIgbHkwID0gYnkgLSBibDE7XHJcbiAgICAgICAgdmFyIGx4MSA9IGF4IC0gYWwwO1xyXG4gICAgICAgIHZhciBseTEgPSBheSAtIGFsMTtcclxuICAgICAgICB2YXIgbHgyID0gYnggKyBibDA7XHJcbiAgICAgICAgdmFyIGx5MiA9IGJ5ICsgYmwxO1xyXG4gICAgICAgIHZhciBseDMgPSBheCArIGFsMDtcclxuICAgICAgICB2YXIgbHkzID0gYXkgKyBhbDE7XHJcbiAgICAgICAgdmFyIHgwID0gbHgwICogYSArIGx5MCAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB5MCA9IGx4MCAqIGIgKyBseTAgKiBkICsgZjtcclxuICAgICAgICB2YXIgeDEgPSBseDEgKiBhICsgbHkxICogYyArIGU7XHJcbiAgICAgICAgdmFyIHkxID0gbHgxICogYiArIGx5MSAqIGQgKyBmO1xyXG4gICAgICAgIHZhciB4MiA9IGx4MiAqIGEgKyBseTIgKiBjICsgZTtcclxuICAgICAgICB2YXIgeTIgPSBseDIgKiBiICsgbHkyICogZCArIGY7XHJcbiAgICAgICAgdmFyIHgzID0gbHgzICogYSArIGx5MyAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB5MyA9IGx4MyAqIGIgKyBseTMgKiBkICsgZjtcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGJMaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhTGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYkxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGFMaW5lQ29sb3I7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhTGluZUNvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYkxpbmVDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB4MCwgeTAsIGJMaW5lQ29sb3IsXHJcbiAgICAgICAgICAgIHgxLCB5MSwgYUxpbmVDb2xvcixcclxuICAgICAgICAgICAgeDIsIHkyLCBiTGluZUNvbG9yLFxyXG4gICAgICAgICAgICB4MywgeTMsIGFMaW5lQ29sb3JcclxuICAgICAgICBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3Ryb2tlUGF0aDogZnVuY3Rpb24gKFxyXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cclxuICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgLyogUGF0aCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgcGF0aCwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSxcclxuICAgICAgICAvKiB0cmFuc2Zvcm0gKi9cclxuICAgICAgICBhLCBiLCBjLCBkLCBlLCBmLFxyXG4gICAgICAgIC8qIGlzIGxhc3QgY29ubmVjdGlvbiAqL1xyXG4gICAgICAgIGlzTGFzdFBhdGgsXHJcbiAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIHBvaW50MCwgcG9pbnQxO1xyXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHBvbHlsaW5lcyA9IHRoaXMucG9seWdvbkNhY2hlO1xyXG4gICAgICAgIHZhciBoYWxmTGluZVdpZHRoID0gbGluZVdpZHRoICogMC41O1xyXG4gICAgICAgIHZhciBsYXN0LCBjdXJyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyO1xyXG4gICAgICAgIHZhciBsaW5lO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwYXRoSW5kZXggPSAwOyBwYXRoSW5kZXggKyAxIDwgcGF0aExlbmd0aDsgcGF0aEluZGV4ICs9IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludDAgPSBwYXRoW3BhdGhJbmRleF07XHJcbiAgICAgICAgICAgIHBvaW50MSA9IHBhdGhbcGF0aEluZGV4ICsgMV07XHJcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLmFkZExpbmUoXHJcbiAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICBwb2ludDAueCwgcG9pbnQwLnksIFxyXG4gICAgICAgICAgICAgICAgcG9pbnQxLngsIHBvaW50MS55LCBcclxuICAgICAgICAgICAgICAgIHBvaW50MC53aWR0aCAvIDIsIHBvaW50MS53aWR0aCAvIDIsIFxyXG4gICAgICAgICAgICAgICAgcG9pbnQwLnJnYiwgcG9pbnQxLnJnYiwgbGluZUFscGhhLFxyXG4gICAgICAgICAgICAgICAgYSwgYiwgYywgZCwgZSwgZixcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRyaXhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcG9seWxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBSZW5kZXIgam9pbnRzICovXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxLCBwb2x5bGluZXNMZW5ndGggPSBwb2x5bGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpbmRleCA8IHBvbHlsaW5lc0xlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCArIDYgPiB0aGlzLm1heFZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhc3QgPSBwb2x5bGluZXNbaW5kZXggLSAxXSB8fCBwb2x5bGluZXNbcG9seWxpbmVzTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGN1cnIgPSBwb2x5bGluZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KVxyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDIgKyAwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDIgKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDIgKyAyXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMl07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMyArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMyArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMyArIDJdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDAgKyAwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDAgKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDAgKyAyXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMF07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMl07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMSArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMSArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMSArIDJdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCArPSA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2x5bGluZXMubGVuZ3RoID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkRmlsbFBhdGg6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIFBhdGggcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHBhdGgsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXHJcbiAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwb2x5Z29uQ2FjaGUgPSB0aGlzLnBvbHlnb25DYWNoZTtcclxuICAgICAgICB2YXIgcG9seWdvbkluZGV4QXJyYXk7XHJcbiAgICAgICAgdmFyIHBvaW50O1xyXG4gICAgICAgIHZhciB2MCwgdjEsIHYyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHZlcnRleENvdW50ID0gdGhpcy52ZXJ0ZXhDb3VudDtcclxuICAgICAgICB2YXIgbWF4VmVydGljZXMgPSB0aGlzLm1heFZlcnRpY2VzO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MjtcclxuICAgICAgICB2YXIgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MjtcclxuICAgICAgICB2YXIgYTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYzAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZDAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFszXTtcclxuICAgICAgICB2YXIgZTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgZjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgYSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIHZhciBiID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICAgICAgdmFyIGMgPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgICAgICB2YXIgZCA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIHZhciBlID0gZTEgKiBhMCArIGYxICogYzAgKyBlMDtcclxuICAgICAgICB2YXIgZiA9IGUxICogYjAgKyBmMSAqIGQwICsgZjA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IGxlbmd0aDsgKytwYXRoSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludCA9IHBhdGhbcGF0aEluZGV4XTtcclxuICAgICAgICAgICAgcG9seWdvbkNhY2hlLnB1c2gocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvbHlnb25JbmRleEFycmF5ID0gRWFyY3V0KHBvbHlnb25DYWNoZSk7XHJcbiAgICAgICAgbGVuZ3RoID0gcG9seWdvbkluZGV4QXJyYXkubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdjAgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDBdICogMjtcclxuICAgICAgICAgICAgdjEgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDFdICogMjtcclxuICAgICAgICAgICAgdjIgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDJdICogMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCArIDMgPiBtYXhWZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMTIpO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhDb3VudCArPSAzO1xyXG5cclxuICAgICAgICAgICAgeDAgPSBwb2x5Z29uQ2FjaGVbdjAgKyAwXTtcclxuICAgICAgICAgICAgeTAgPSBwb2x5Z29uQ2FjaGVbdjAgKyAxXTtcclxuICAgICAgICAgICAgeDEgPSBwb2x5Z29uQ2FjaGVbdjEgKyAwXTtcclxuICAgICAgICAgICAgeTEgPSBwb2x5Z29uQ2FjaGVbdjEgKyAxXTtcclxuICAgICAgICAgICAgeDIgPSBwb2x5Z29uQ2FjaGVbdjIgKyAwXTtcclxuICAgICAgICAgICAgeTIgPSBwb2x5Z29uQ2FjaGVbdjIgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIHR4MCA9IHgwICogYSArIHkwICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MCA9IHgwICogYiArIHkwICogZCArIGY7XHJcbiAgICAgICAgICAgIHR4MSA9IHgxICogYSArIHkxICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MSA9IHgxICogYiArIHkxICogZCArIGY7XHJcbiAgICAgICAgICAgIHR4MiA9IHgyICogYSArIHkyICogYyArIGU7XHJcbiAgICAgICAgICAgIHR5MiA9IHgyICogYiArIHkyICogZCArIGY7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XHJcbiAgICAgICAgcG9seWdvbkNhY2hlLmxlbmd0aCA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZpbGxSZWN0OiBmdW5jdGlvbiAoXHJcbiAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAvKiBSZWN0YW5nbGUgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXHJcbiAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4Q291bnQgKyA2ID4gdGhpcy5tYXhWZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgYTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFswXTtcclxuICAgICAgICB2YXIgYjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsxXTtcclxuICAgICAgICB2YXIgYzAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFsyXTtcclxuICAgICAgICB2YXIgZDAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFszXTtcclxuICAgICAgICB2YXIgZTAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs0XTtcclxuICAgICAgICB2YXIgZjAgPSBjdXJyZW50TWF0cml4Lm1hdHJpeFs1XTtcclxuICAgICAgICB2YXIgYSA9IGExICogYTAgKyBiMSAqIGMwO1xyXG4gICAgICAgIHZhciBiID0gYTEgKiBiMCArIGIxICogZDA7XHJcbiAgICAgICAgdmFyIGMgPSBjMSAqIGEwICsgZDEgKiBjMDtcclxuICAgICAgICB2YXIgZCA9IGMxICogYjAgKyBkMSAqIGQwO1xyXG4gICAgICAgIHZhciBlID0gZTEgKiBhMCArIGYxICogYzAgKyBlMDtcclxuICAgICAgICB2YXIgZiA9IGUxICogYjAgKyBmMSAqIGQwICsgZjA7XHJcbiAgICAgICAgdmFyIHR4MCA9IHggKiBhICsgeSAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTAgPSB4ICogYiArIHkgKiBkICsgZjtcclxuICAgICAgICB2YXIgdHgxID0geCAqIGEgKyB5aCAqIGMgKyBlO1xyXG4gICAgICAgIHZhciB0eTEgPSB4ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MiA9IHh3ICogYSArIHloICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MiA9IHh3ICogYiArIHloICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MyA9IHh3ICogYSArIHkgKiBjICsgZTtcclxuICAgICAgICB2YXIgdHkzID0geHcgKiBiICsgeSAqIGQgKyBmO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEZpbGxUcmlhbmdsZTogZnVuY3Rpb24gKFxyXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cclxuICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXHJcbiAgICAgICAgLyogVHJpYW5nbGUgcHJvcGVydGllcyAqL1xyXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXHJcbiAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4Q291bnQgKyAzID4gdGhpcy5tYXhWZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMF07XHJcbiAgICAgICAgdmFyIGIwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMV07XHJcbiAgICAgICAgdmFyIGMwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbMl07XHJcbiAgICAgICAgdmFyIGQwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbM107XHJcbiAgICAgICAgdmFyIGUwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbNF07XHJcbiAgICAgICAgdmFyIGYwID0gY3VycmVudE1hdHJpeC5tYXRyaXhbNV07XHJcbiAgICAgICAgdmFyIGEgPSBhMSAqIGEwICsgYjEgKiBjMDtcclxuICAgICAgICB2YXIgYiA9IGExICogYjAgKyBiMSAqIGQwO1xyXG4gICAgICAgIHZhciBjID0gYzEgKiBhMCArIGQxICogYzA7XHJcbiAgICAgICAgdmFyIGQgPSBjMSAqIGIwICsgZDEgKiBkMDtcclxuICAgICAgICB2YXIgZSA9IGUxICogYTAgKyBmMSAqIGMwICsgZTA7XHJcbiAgICAgICAgdmFyIGYgPSBlMSAqIGIwICsgZjEgKiBkMCArIGYwO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgxMik7XHJcbiAgICAgICAgdmFyIHR4MCA9IHgwICogYSArIHkwICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MCA9IHgwICogYiArIHkwICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MSA9IHgxICogYSArIHkxICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MSA9IHgxICogYiArIHkxICogZCArIGY7XHJcbiAgICAgICAgdmFyIHR4MiA9IHgyICogYSArIHkyICogYyArIGU7XHJcbiAgICAgICAgdmFyIHR5MiA9IHgyICogYiArIHkyICogZCArIGY7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gMztcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3Ryb2tlVHJpYW5nbGU6IGZ1bmN0aW9uIChcclxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXHJcbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxyXG4gICAgICAgIC8qIFRyaWFuZ2xlIHByb3BlcnRpZXMgKi9cclxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGYsXHJcbiAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIHRlbXBUcmlhbmdsZSA9IHRoaXMudGVtcFRyaWFuZ2xlO1xyXG5cclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ueCA9IHgwO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVswXS55ID0geTA7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzBdLndpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVswXS5yZ2IgPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzBdLmFscGhhID0gbGluZUFscGhhO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsxXS54ID0geDE7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnkgPSB5MTtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0ud2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnJnYiA9IGxpbmVDb2xvcjtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0uYWxwaGEgPSBsaW5lQWxwaGE7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzJdLnggPSB4MjtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMl0ueSA9IHkyO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS53aWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbMl0ucmdiID0gbGluZUNvbG9yO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS5hbHBoYSA9IGxpbmVBbHBoYTtcclxuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ueCA9IHgwO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVszXS55ID0geTA7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzNdLndpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgIHRlbXBUcmlhbmdsZVszXS5yZ2IgPSBsaW5lQ29sb3I7XHJcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzNdLmFscGhhID0gbGluZUFscGhhO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFN0cm9rZVBhdGgoXHJcbiAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcclxuICAgICAgICAgICAgdGVtcFRyaWFuZ2xlLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhLFxyXG4gICAgICAgICAgICBhLCBiLCBjLCBkLCBlLCBmLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgY3VycmVudE1hdHJpeFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvU2hhcGVCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNzI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcclxuXHJcbiAgICBWRVJURVhfU0laRTogMTYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBTSEFQRV9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA0LFxyXG5cclxuICAgIC8vIENhbid0IGJlIGJpZ2dlciB0aGFuIDEwLDAwMCBzaW5jZSBpbmRleCBhcmUgMTYtYml0XHJcbiAgICBNQVhfVkVSVElDRVM6IDE2MDAwXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDcyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBuO249XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLG4uZWFyY3V0PWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUobix0LHIpe2Z1bmN0aW9uIHgodSxmKXtpZighdFt1XSl7aWYoIW5bdV0pe3ZhciBvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJm8pcmV0dXJuIG8odSwhMCk7aWYoaSlyZXR1cm4gaSh1LCEwKTt2YXIgdj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3UrXCInXCIpO3Rocm93IHYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix2fXZhciBsPXRbdV09e2V4cG9ydHM6e319O25bdV1bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIHQ9blt1XVsxXVtlXTtyZXR1cm4geCh0P3Q6ZSl9LGwsbC5leHBvcnRzLGUsbix0LHIpfXJldHVybiB0W3VdLmV4cG9ydHN9Zm9yKHZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsdT0wO3U8ci5sZW5ndGg7dSsrKXgoclt1XSk7cmV0dXJuIHh9KHsxOltmdW5jdGlvbihlLG4sdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLG4sdCl7dD10fHwyO3ZhciByPW4mJm4ubGVuZ3RoLGk9cj9uWzBdKnQ6ZS5sZW5ndGgsZj14KGUsMCxpLHQsITApLG89W107aWYoIWYpcmV0dXJuIG87dmFyIHYsbCxwLGEsaCxzLGM7aWYociYmKGY9eShlLG4sZix0KSksZS5sZW5ndGg+ODAqdCl7dj1wPWVbMF0sbD1hPWVbMV07Zm9yKHZhciBkPXQ7aT5kO2QrPXQpaD1lW2RdLHM9ZVtkKzFdLHY+aCYmKHY9aCksbD5zJiYobD1zKSxoPnAmJihwPWgpLHM+YSYmKGE9cyk7Yz1NYXRoLm1heChwLXYsYS1sKX1yZXR1cm4gdShmLG8sdCx2LGwsYyksb31mdW5jdGlvbiB4KGUsbix0LHIseCl7dmFyIGksdTtpZih4PT09XyhlLG4sdCxyKT4wKWZvcihpPW47dD5pO2krPXIpdT1FKGksZVtpXSxlW2krMV0sdSk7ZWxzZSBmb3IoaT10LXI7aT49bjtpLT1yKXU9RShpLGVbaV0sZVtpKzFdLHUpO3JldHVybiB1JiZ6KHUsdS5uZXh0KSYmKE4odSksdT11Lm5leHQpLHV9ZnVuY3Rpb24gaShlLG4pe2lmKCFlKXJldHVybiBlO258fChuPWUpO3ZhciB0LHI9ZTtkbyBpZih0PSExLHIuc3RlaW5lcnx8IXoocixyLm5leHQpJiYwIT09YihyLnByZXYscixyLm5leHQpKXI9ci5uZXh0O2Vsc2V7aWYoTihyKSxyPW49ci5wcmV2LHI9PT1yLm5leHQpcmV0dXJuIG51bGw7dD0hMH13aGlsZSh0fHxyIT09bik7cmV0dXJuIG59ZnVuY3Rpb24gdShlLG4sdCxyLHgseSxwKXtpZihlKXshcCYmeSYmcyhlLHIseCx5KTtmb3IodmFyIGEsaCxjPWU7ZS5wcmV2IT09ZS5uZXh0OylpZihhPWUucHJldixoPWUubmV4dCx5P28oZSxyLHgseSk6ZihlKSluLnB1c2goYS5pL3QpLG4ucHVzaChlLmkvdCksbi5wdXNoKGguaS90KSxOKGUpLGU9aC5uZXh0LGM9aC5uZXh0O2Vsc2UgaWYoZT1oLGU9PT1jKXtwPzE9PT1wPyhlPXYoZSxuLHQpLHUoZSxuLHQscix4LHksMikpOjI9PT1wJiZsKGUsbix0LHIseCx5KTp1KGkoZSksbix0LHIseCx5LDEpO2JyZWFrfX19ZnVuY3Rpb24gZihlKXt2YXIgbj1lLnByZXYsdD1lLHI9ZS5uZXh0O2lmKGIobix0LHIpPj0wKXJldHVybiExO2Zvcih2YXIgeD1lLm5leHQubmV4dDt4IT09ZS5wcmV2Oyl7aWYoZyhuLngsbi55LHQueCx0Lnksci54LHIueSx4LngseC55KSYmYih4LnByZXYseCx4Lm5leHQpPj0wKXJldHVybiExO3g9eC5uZXh0fXJldHVybiEwfWZ1bmN0aW9uIG8oZSxuLHQscil7dmFyIHg9ZS5wcmV2LGk9ZSx1PWUubmV4dDtpZihiKHgsaSx1KT49MClyZXR1cm4hMTtmb3IodmFyIGY9eC54PGkueD94Lng8dS54P3gueDp1Lng6aS54PHUueD9pLng6dS54LG89eC55PGkueT94Lnk8dS55P3gueTp1Lnk6aS55PHUueT9pLnk6dS55LHY9eC54PmkueD94Lng+dS54P3gueDp1Lng6aS54PnUueD9pLng6dS54LGw9eC55PmkueT94Lnk+dS55P3gueTp1Lnk6aS55PnUueT9pLnk6dS55LHk9ZChmLG8sbix0LHIpLHA9ZCh2LGwsbix0LHIpLGE9ZS5uZXh0WjthJiZhLno8PXA7KXtpZihhIT09ZS5wcmV2JiZhIT09ZS5uZXh0JiZnKHgueCx4LnksaS54LGkueSx1LngsdS55LGEueCxhLnkpJiZiKGEucHJldixhLGEubmV4dCk+PTApcmV0dXJuITE7YT1hLm5leHRafWZvcihhPWUucHJldlo7YSYmYS56Pj15Oyl7aWYoYSE9PWUucHJldiYmYSE9PWUubmV4dCYmZyh4LngseC55LGkueCxpLnksdS54LHUueSxhLngsYS55KSYmYihhLnByZXYsYSxhLm5leHQpPj0wKXJldHVybiExO2E9YS5wcmV2Wn1yZXR1cm4hMH1mdW5jdGlvbiB2KGUsbix0KXt2YXIgcj1lO2Rve3ZhciB4PXIucHJldixpPXIubmV4dC5uZXh0OyF6KHgsaSkmJk0oeCxyLHIubmV4dCxpKSYmcSh4LGkpJiZxKGkseCkmJihuLnB1c2goeC5pL3QpLG4ucHVzaChyLmkvdCksbi5wdXNoKGkuaS90KSxOKHIpLE4oci5uZXh0KSxyPWU9aSkscj1yLm5leHR9d2hpbGUociE9PWUpO3JldHVybiByfWZ1bmN0aW9uIGwoZSxuLHQscix4LGYpe3ZhciBvPWU7ZG97Zm9yKHZhciB2PW8ubmV4dC5uZXh0O3YhPT1vLnByZXY7KXtpZihvLmkhPT12LmkmJncobyx2KSl7dmFyIGw9RChvLHYpO3JldHVybiBvPWkobyxvLm5leHQpLGw9aShsLGwubmV4dCksdShvLG4sdCxyLHgsZiksdm9pZCB1KGwsbix0LHIseCxmKX12PXYubmV4dH1vPW8ubmV4dH13aGlsZShvIT09ZSl9ZnVuY3Rpb24geShlLG4sdCxyKXt2YXIgdSxmLG8sdixsLHk9W107Zm9yKHU9MCxmPW4ubGVuZ3RoO2Y+dTt1Kyspbz1uW3VdKnIsdj1mLTE+dT9uW3UrMV0qcjplLmxlbmd0aCxsPXgoZSxvLHYsciwhMSksbD09PWwubmV4dCYmKGwuc3RlaW5lcj0hMCkseS5wdXNoKFoobCkpO2Zvcih5LnNvcnQocCksdT0wO3U8eS5sZW5ndGg7dSsrKWEoeVt1XSx0KSx0PWkodCx0Lm5leHQpO3JldHVybiB0fWZ1bmN0aW9uIHAoZSxuKXtyZXR1cm4gZS54LW4ueH1mdW5jdGlvbiBhKGUsbil7aWYobj1oKGUsbikpe3ZhciB0PUQobixlKTtpKHQsdC5uZXh0KX19ZnVuY3Rpb24gaChlLG4pe3ZhciB0LHI9bix4PWUueCxpPWUueSx1PS0oMS8wKTtkb3tpZihpPD1yLnkmJmk+PXIubmV4dC55KXt2YXIgZj1yLngrKGktci55KSooci5uZXh0Lngtci54KS8oci5uZXh0Lnktci55KTtpZih4Pj1mJiZmPnUpe2lmKHU9ZixmPT09eCl7aWYoaT09PXIueSlyZXR1cm4gcjtpZihpPT09ci5uZXh0LnkpcmV0dXJuIHIubmV4dH10PXIueDxyLm5leHQueD9yOnIubmV4dH19cj1yLm5leHR9d2hpbGUociE9PW4pO2lmKCF0KXJldHVybiBudWxsO2lmKHg9PT11KXJldHVybiB0LnByZXY7dmFyIG8sdj10LGw9dC54LHk9dC55LHA9MS8wO2ZvcihyPXQubmV4dDtyIT09djspeD49ci54JiZyLng+PWwmJmcoeT5pP3g6dSxpLGwseSx5Pmk/dTp4LGksci54LHIueSkmJihvPU1hdGguYWJzKGktci55KS8oeC1yLngpLChwPm98fG89PT1wJiZyLng+dC54KSYmcShyLGUpJiYodD1yLHA9bykpLHI9ci5uZXh0O3JldHVybiB0fWZ1bmN0aW9uIHMoZSxuLHQscil7dmFyIHg9ZTtkbyBudWxsPT09eC56JiYoeC56PWQoeC54LHgueSxuLHQscikpLHgucHJldlo9eC5wcmV2LHgubmV4dFo9eC5uZXh0LHg9eC5uZXh0O3doaWxlKHghPT1lKTt4LnByZXZaLm5leHRaPW51bGwseC5wcmV2Wj1udWxsLGMoeCl9ZnVuY3Rpb24gYyhlKXt2YXIgbix0LHIseCxpLHUsZixvLHY9MTtkb3tmb3IodD1lLGU9bnVsbCxpPW51bGwsdT0wO3Q7KXtmb3IodSsrLHI9dCxmPTAsbj0wO3Y+biYmKGYrKyxyPXIubmV4dFoscik7bisrKTtmb3Iobz12O2Y+MHx8bz4wJiZyOykwPT09Zj8oeD1yLHI9ci5uZXh0WixvLS0pOjAhPT1vJiZyP3Quejw9ci56Pyh4PXQsdD10Lm5leHRaLGYtLSk6KHg9cixyPXIubmV4dFosby0tKTooeD10LHQ9dC5uZXh0WixmLS0pLGk/aS5uZXh0Wj14OmU9eCx4LnByZXZaPWksaT14O3Q9cn1pLm5leHRaPW51bGwsdio9Mn13aGlsZSh1PjEpO3JldHVybiBlfWZ1bmN0aW9uIGQoZSxuLHQscix4KXtyZXR1cm4gZT0zMjc2NyooZS10KS94LG49MzI3NjcqKG4tcikveCxlPTE2NzExOTM1JihlfGU8PDgpLGU9MjUyNjQ1MTM1JihlfGU8PDQpLGU9ODU4OTkzNDU5JihlfGU8PDIpLGU9MTQzMTY1NTc2NSYoZXxlPDwxKSxuPTE2NzExOTM1JihufG48PDgpLG49MjUyNjQ1MTM1JihufG48PDQpLG49ODU4OTkzNDU5JihufG48PDIpLG49MTQzMTY1NTc2NSYobnxuPDwxKSxlfG48PDF9ZnVuY3Rpb24gWihlKXt2YXIgbj1lLHQ9ZTtkbyBuLng8dC54JiYodD1uKSxuPW4ubmV4dDt3aGlsZShuIT09ZSk7cmV0dXJuIHR9ZnVuY3Rpb24gZyhlLG4sdCxyLHgsaSx1LGYpe3JldHVybih4LXUpKihuLWYpLShlLXUpKihpLWYpPj0wJiYoZS11KSooci1mKS0odC11KSoobi1mKT49MCYmKHQtdSkqKGktZiktKHgtdSkqKHItZik+PTB9ZnVuY3Rpb24gdyhlLG4pe3JldHVybiBlLm5leHQuaSE9PW4uaSYmZS5wcmV2LmkhPT1uLmkmJiFtKGUsbikmJnEoZSxuKSYmcShuLGUpJiZPKGUsbil9ZnVuY3Rpb24gYihlLG4sdCl7cmV0dXJuKG4ueS1lLnkpKih0Lngtbi54KS0obi54LWUueCkqKHQueS1uLnkpfWZ1bmN0aW9uIHooZSxuKXtyZXR1cm4gZS54PT09bi54JiZlLnk9PT1uLnl9ZnVuY3Rpb24gTShlLG4sdCxyKXtyZXR1cm4geihlLG4pJiZ6KHQscil8fHooZSxyKSYmeih0LG4pPyEwOmIoZSxuLHQpPjAhPWIoZSxuLHIpPjAmJmIodCxyLGUpPjAhPWIodCxyLG4pPjB9ZnVuY3Rpb24gbShlLG4pe3ZhciB0PWU7ZG97aWYodC5pIT09ZS5pJiZ0Lm5leHQuaSE9PWUuaSYmdC5pIT09bi5pJiZ0Lm5leHQuaSE9PW4uaSYmTSh0LHQubmV4dCxlLG4pKXJldHVybiEwO3Q9dC5uZXh0fXdoaWxlKHQhPT1lKTtyZXR1cm4hMX1mdW5jdGlvbiBxKGUsbil7cmV0dXJuIGIoZS5wcmV2LGUsZS5uZXh0KTwwP2IoZSxuLGUubmV4dCk+PTAmJmIoZSxlLnByZXYsbik+PTA6YihlLG4sZS5wcmV2KTwwfHxiKGUsZS5uZXh0LG4pPDB9ZnVuY3Rpb24gTyhlLG4pe3ZhciB0PWUscj0hMSx4PShlLngrbi54KS8yLGk9KGUueStuLnkpLzI7ZG8gdC55PmkhPXQubmV4dC55PmkmJng8KHQubmV4dC54LXQueCkqKGktdC55KS8odC5uZXh0LnktdC55KSt0LngmJihyPSFyKSx0PXQubmV4dDt3aGlsZSh0IT09ZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gRChlLG4pe3ZhciB0PW5ldyBVKGUuaSxlLngsZS55KSxyPW5ldyBVKG4uaSxuLngsbi55KSx4PWUubmV4dCxpPW4ucHJldjtyZXR1cm4gZS5uZXh0PW4sbi5wcmV2PWUsdC5uZXh0PXgseC5wcmV2PXQsci5uZXh0PXQsdC5wcmV2PXIsaS5uZXh0PXIsci5wcmV2PWkscn1mdW5jdGlvbiBFKGUsbix0LHIpe3ZhciB4PW5ldyBVKGUsbix0KTtyZXR1cm4gcj8oeC5uZXh0PXIubmV4dCx4LnByZXY9cixyLm5leHQucHJldj14LHIubmV4dD14KTooeC5wcmV2PXgseC5uZXh0PXgpLHh9ZnVuY3Rpb24gTihlKXtlLm5leHQucHJldj1lLnByZXYsZS5wcmV2Lm5leHQ9ZS5uZXh0LGUucHJldlomJihlLnByZXZaLm5leHRaPWUubmV4dFopLGUubmV4dFomJihlLm5leHRaLnByZXZaPWUucHJldlopfWZ1bmN0aW9uIFUoZSxuLHQpe3RoaXMuaT1lLHRoaXMueD1uLHRoaXMueT10LHRoaXMucHJldj1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMuej1udWxsLHRoaXMucHJldlo9bnVsbCx0aGlzLm5leHRaPW51bGwsdGhpcy5zdGVpbmVyPSExfWZ1bmN0aW9uIF8oZSxuLHQscil7Zm9yKHZhciB4PTAsaT1uLHU9dC1yO3Q+aTtpKz1yKXgrPShlW3VdLWVbaV0pKihlW2krMV0rZVt1KzFdKSx1PWk7cmV0dXJuIHh9bi5leHBvcnRzPXIsci5kZXZpYXRpb249ZnVuY3Rpb24oZSxuLHQscil7dmFyIHg9biYmbi5sZW5ndGgsaT14P25bMF0qdDplLmxlbmd0aCx1PU1hdGguYWJzKF8oZSwwLGksdCkpO2lmKHgpZm9yKHZhciBmPTAsbz1uLmxlbmd0aDtvPmY7ZisrKXt2YXIgdj1uW2ZdKnQsbD1vLTE+Zj9uW2YrMV0qdDplLmxlbmd0aDt1LT1NYXRoLmFicyhfKGUsdixsLHQpKX12YXIgeT0wO2ZvcihmPTA7ZjxyLmxlbmd0aDtmKz0zKXt2YXIgcD1yW2ZdKnQsYT1yW2YrMV0qdCxoPXJbZisyXSp0O3krPU1hdGguYWJzKChlW3BdLWVbaF0pKihlW2ErMV0tZVtwKzFdKS0oZVtwXS1lW2FdKSooZVtoKzFdLWVbcCsxXSkpfXJldHVybiAwPT09dSYmMD09PXk/MDpNYXRoLmFicygoeS11KS91KX0sci5mbGF0dGVuPWZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1lWzBdWzBdLmxlbmd0aCx0PXt2ZXJ0aWNlczpbXSxob2xlczpbXSxkaW1lbnNpb25zOm59LHI9MCx4PTA7eDxlLmxlbmd0aDt4Kyspe2Zvcih2YXIgaT0wO2k8ZVt4XS5sZW5ndGg7aSsrKWZvcih2YXIgdT0wO24+dTt1KyspdC52ZXJ0aWNlcy5wdXNoKGVbeF1baV1bdV0pO3g+MCYmKHIrPWVbeC0xXS5sZW5ndGgsdC5ob2xlcy5wdXNoKHIpKX1yZXR1cm4gdH19LHt9XX0se30sWzFdKSgxKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3NoYXBlYmF0Y2gvZWFyY3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3Mjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgRGF0YUJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjE2Jyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG52YXIgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vc2hhZGVycy9UZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInKTtcclxuXHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgU3ByaXRlQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXHJcbntcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XHJcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcclxuICAgIHRoaXMubWF4U3ByaXRlcyA9IG51bGw7XHJcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3RGb3JNZXNoID0gbnVsbDtcclxuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xyXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXHJcblxyXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXHJcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICB0aGlzLmxhc3REcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICB0aGlzLmxhc3REcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcblxyXG4gICAgdGhpcy5pbml0KHRoaXMuZ2xDb250ZXh0KTtcclxufTtcclxuXHJcblNwcml0ZUJhdGNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZUJhdGNoO1xyXG5cclxuU3ByaXRlQmF0Y2gucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcclxuICAgIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgRGF0YUJ1ZmZlcjMyKENPTlNULlZFUlRFWF9TSVpFICogQ09OU1QuU1BSSVRFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9TUFJJVEVTKTtcclxuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IERhdGFCdWZmZXIxNihDT05TVC5JTkRFWF9TSVpFICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyJywgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUUkVBTV9EUkFXKTtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVFJFQU1fRFJBVyk7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9TUFJJVEVTICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBpbmRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaCA9IGluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2NvbG9yJyksIDMsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAxNik7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfYWxwaGEnKSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMjApO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd0luZGV4ZWQgIT0gdGhpcy5sYXN0RHJhd0luZGV4ZWQgfHwgdGhpcy5sYXN0RHJhd2luZ01lc2ggIT09IHRoaXMuZHJhd2luZ01lc2ggfHwgdGhpcy5pc0Z1bGwoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdERyYXdJbmRleGVkID0gdGhpcy5kcmF3SW5kZXhlZDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0RHJhd2luZ01lc2ggPSB0aGlzLmRyYXdpbmdNZXNoO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyLCByZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMCAmJiB0aGlzLnZlcnRleENvdW50ID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UodmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpLCAwKTtcclxuICAgICAgICBpZiAodGhpcy5kcmF3SW5kZXhlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdpbmdNZXNoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaC5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0Rm9yTWVzaC51cGRhdGVSZXNvdXJjZSh0aGlzLmluZGV4RGF0YUJ1ZmZlci5idWZmZXIsIDApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcblxyXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdGhpcy52ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbiwgc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xyXG4gICAgICAgIHZhciBhY3RpdmVTaGFkZXIgPSBzaGFkZXIgIT09IHVuZGVmaW5lZCA/IHNoYWRlciA6IHRoaXMuc2hhZGVyO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGFjdGl2ZVNoYWRlciA9PSB0aGlzLnNoYWRlciA/IHRoaXMudmlld01hdHJpeExvY2F0aW9uIDogYWN0aXZlU2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV92aWV3X21hdHJpeCcpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeChhY3RpdmVTaGFkZXIsIGxvY2F0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKHNoYWRlciwgbG9jYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgc2hhZGVyLnNldENvbnN0YW50TWF0cml4NHg0KFxyXG4gICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuZGVsZXRlU2hhZGVyKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE1lc2hJbmRleGVkOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdEYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdhbWVPYmplY3QudmVydGljZXM7XHJcbiAgICAgICAgdmFyIHV2ID0gZ2FtZU9iamVjdC51djtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0b3RhbFZlcnRpY2VzID0gKGxlbmd0aCAvIDIpfDA7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5pbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBnYW1lT2JqZWN0LmluZGljZXM7XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IGdhbWVPYmplY3QuY29sb3JzO1xyXG4gICAgICAgIHZhciBhbHBoYXMgPSBnYW1lT2JqZWN0LmFscGhhcztcclxuICAgICAgICB2YXIgaW5kZXhMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xyXG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XHJcbiAgICAgICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcclxuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xyXG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XHJcbiAgICAgICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIGNtYiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIGNtZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIG12YSA9IHNyYSAqIGNtYSArIHNyYiAqIGNtYztcclxuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XHJcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xyXG4gICAgICAgIG12ZCA9IHNyYyAqIGNtYiArIHNyZCAqIGNtZDtcclxuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XHJcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mOyBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0UmVuZGVyZXIodGhpcywgZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgZ2FtZU9iamVjdC5yZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIGluZGV4T2Zmc2V0ID0gdGhpcy52ZXJ0ZXhDb3VudDtcclxuICAgICAgICB0aGlzLmRyYXdJbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRyYXdpbmdNZXNoID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IHRvdGFsVmVydGljZXM7XHJcblxyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUodG90YWxWZXJ0aWNlcyAqIDYpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGluZGV4MCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpbmRleCArIDBdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgIHZhciB0eCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgICAgICB2YXIgdHkgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHk7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dltpbmRleCArIDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IGNvbG9yc1tpbmRleDBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGFzW2luZGV4MF07XHJcbiAgICAgICAgICAgIGluZGV4MCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWxlbWVudENvdW50ID0gdGhpcy5lbGVtZW50Q291bnQ7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZGV4TGVuZ3RoOyArK2luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbZWxlbWVudENvdW50ICsgaW5kZXhdID0gaW5kZXhPZmZzZXQgKyBpbmRpY2VzW2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IGluZGV4TGVuZ3RoO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRNZXNoOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBmcmFtZSA9IGdhbWVPYmplY3QuZnJhbWU7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdEYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZ2FtZU9iamVjdC54IC0gY2FtZXJhLnNjcm9sbFggKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBnYW1lT2JqZWN0LnkgLSBjYW1lcmEuc2Nyb2xsWSAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZ2FtZU9iamVjdC5zY2FsZVg7XHJcbiAgICAgICAgdmFyIHNjYWxlWSA9IGdhbWVPYmplY3Quc2NhbGVZO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1nYW1lT2JqZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4TWF0cml4ID0gdGVtcE1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdhbWVPYmplY3QudmVydGljZXM7XHJcbiAgICAgICAgdmFyIHV2ID0gZ2FtZU9iamVjdC51djtcclxuICAgICAgICB2YXIgY29sb3JzID0gZ2FtZU9iamVjdC5jb2xvcnM7XHJcbiAgICAgICAgdmFyIGFscGhhcyA9IGdhbWVPYmplY3QuYWxwaGFzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHRvdGFsVmVydGljZXMgPSAobGVuZ3RoIC8gMil8MDtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjsgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFJlbmRlcmVyKHRoaXMsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUsIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmRyYXdJbmRleGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCArPSB0b3RhbFZlcnRpY2VzO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKHRvdGFsVmVydGljZXMgKiA2KTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBpbmRleDAgPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdmVydGljZXNbaW5kZXggKyAwXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1tpbmRleCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgdHggPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICAgICAgdmFyIHR5ID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZbaW5kZXggKyAwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2W2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBjb2xvcnNbaW5kZXgwXTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhc1tpbmRleDBdO1xyXG4gICAgICAgICAgICBpbmRleDAgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFRpbGVUZXh0dXJlUmVjdDogZnVuY3Rpb24gKHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGFscGhhLCB0aW50LCBzY3JvbGxGYWN0b3JYLCBzY3JvbGxGYWN0b3JZLCB0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHQsIHJlY3RYLCByZWN0WSwgcmVjdFcsIHJlY3RILCBjYW1lcmEsIHJlbmRlclRhcmdldClcclxuICAgIHtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xyXG4gICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgaGFsZlRpbGVXaWR0aCA9ICh3aWR0aCkgKiAwLjU7XHJcbiAgICAgICAgdmFyIGhhbGZUaWxlSGVpZ2h0ID0gKGhlaWdodCkgKiAwLjU7XHJcbiAgICAgICAgdmFyIHUwID0gKHJlY3RYIC0gKGhhbGZUaWxlV2lkdGggLSAwLjUpKSAvIHRleHR1cmVXaWR0aDtcclxuICAgICAgICB2YXIgdjAgPSAocmVjdFkgLSAoaGFsZlRpbGVIZWlnaHQgLSAwLjUpKSAvIHRleHR1cmVIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHUxID0gKHJlY3RYICsgKGhhbGZUaWxlV2lkdGggLSAwLjUpKSAvIHRleHR1cmVXaWR0aDtcclxuICAgICAgICB2YXIgdjEgPSAocmVjdFkgKyAoaGFsZlRpbGVIZWlnaHQgLSAwLjUpKSAvIHRleHR1cmVIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbFggPSBjYW1lcmEuc2Nyb2xsWCAqIHNjcm9sbEZhY3Rvclg7XHJcbiAgICAgICAgdmFyIHNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWSAqIHNjcm9sbEZhY3Rvclk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbXZhID0gY2FtZXJhTWF0cml4WzBdO1xyXG4gICAgICAgIG12YiA9IGNhbWVyYU1hdHJpeFsxXTtcclxuICAgICAgICBtdmMgPSBjYW1lcmFNYXRyaXhbMl07XHJcbiAgICAgICAgbXZkID0gY2FtZXJhTWF0cml4WzNdO1xyXG4gICAgICAgIG12ZSA9IGNhbWVyYU1hdHJpeFs0XTtcclxuICAgICAgICBtdmYgPSBjYW1lcmFNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIHR4MCA9ICh4ICogbXZhICsgeSAqIG12YyArIG12ZSkgLSBzY3JvbGxYO1xyXG4gICAgICAgIHR5MCA9ICh4ICogbXZiICsgeSAqIG12ZCArIG12ZikgLSBzY3JvbGxZO1xyXG4gICAgICAgIHR4MSA9ICh4ICogbXZhICsgeWggKiBtdmMgKyBtdmUpIC0gc2Nyb2xsWDtcclxuICAgICAgICB0eTEgPSAoeCAqIG12YiArIHloICogbXZkICsgbXZmKSAtIHNjcm9sbFk7XHJcbiAgICAgICAgdHgyID0gKHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmUpIC0gc2Nyb2xsWDtcclxuICAgICAgICB0eTIgPSAoeHcgKiBtdmIgKyB5aCAqIG12ZCArIG12ZikgLSBzY3JvbGxZO1xyXG4gICAgICAgIHR4MyA9ICh4dyAqIG12YSArIHkgKiBtdmMgKyBtdmUpIC0gc2Nyb2xsWDtcclxuICAgICAgICB0eTMgPSAoeHcgKiBtdmIgKyB5ICogbXZkICsgbXZmKSAtIHNjcm9sbFk7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZHJhd2luZ01lc2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50OyBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50OyBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50OyBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0aW50O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlVGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNhbWVyYSwgdGV4dHVyZSwgdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBhbHBoYSA9IDE2Nzc3MjE2O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0VTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlV2lkdGggKiAoZ2FtZU9iamVjdC5mbGlwWCA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmVIZWlnaHQgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IGdhbWVPYmplY3QueSAtIGNhbWVyYS5zY3JvbGxZICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBnYW1lT2JqZWN0LnNjYWxlWDtcclxuICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgeCA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5YICsgKCh0ZXh0dXJlV2lkdGgpICogKGdhbWVPYmplY3QuZmxpcFggPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHkgPSAtZ2FtZU9iamVjdC5kaXNwbGF5T3JpZ2luWSArICgodGV4dHVyZUhlaWdodCkgKiAoZ2FtZU9iamVjdC5mbGlwWSA/IDEgOiAwLjApKTtcclxuICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcclxuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XHJcbiAgICAgICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xyXG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IGdhbWVPYmplY3QuYWxwaGE7XHJcblxyXG4gICAgICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XHJcbiAgICAgICAgc3JiID0gdGVtcE1hdHJpeE1hdHJpeFsxXTtcclxuICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xyXG4gICAgICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XHJcbiAgICAgICAgc3JlID0gdGVtcE1hdHJpeE1hdHJpeFs0XTtcclxuICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xyXG5cclxuICAgICAgICBjbWEgPSBjYW1lcmFNYXRyaXhbMF07XHJcbiAgICAgICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xyXG4gICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcclxuICAgICAgICBjbWQgPSBjYW1lcmFNYXRyaXhbM107XHJcbiAgICAgICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xyXG4gICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcclxuXHJcbiAgICAgICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xyXG4gICAgICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcclxuICAgICAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XHJcbiAgICAgICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xyXG4gICAgICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcclxuICAgICAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MCA9IHggKiBtdmIgKyB5ICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgyID0geHcgKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xyXG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcclxuICAgICAgICB0eTMgPSB4dyAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRSZW5kZXJlcih0aGlzLCB0ZXh0dXJlLCBnYW1lT2JqZWN0LnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5kcmF3SW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmF3aW5nTWVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHZlcnRleE9mZnNldCA9IHZlcnRleERhdGFCdWZmZXIuYWxsb2NhdGUoMjQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci50b3BMZWZ0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci5ib3R0b21MZWZ0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci5ib3R0b21SaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IudG9wUmlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRTcHJpdGU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXggPSB0aGlzLnRlbXBNYXRyaXg7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gZ2FtZU9iamVjdC5mcmFtZTtcclxuICAgICAgICB2YXIgYWxwaGEgPSAxNjc3NzIxNjtcclxuICAgICAgICB2YXIgZm9yY2VGbGlwWSA9IChmcmFtZS50ZXh0dXJlLnNvdXJjZVtmcmFtZS5zb3VyY2VJbmRleF0uZ2xUZXh0dXJlLmlzUmVuZGVyVGV4dHVyZSA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICAgICAgdmFyIGZsaXBYID0gZ2FtZU9iamVjdC5mbGlwWDtcclxuICAgICAgICB2YXIgZmxpcFkgPSBnYW1lT2JqZWN0LmZsaXBZIF4gZm9yY2VGbGlwWTtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0RjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck9iamVjdFUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcclxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aCAqIChmbGlwWCA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodCAqIChmbGlwWSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBnYW1lT2JqZWN0LnggLSBjYW1lcmEuc2Nyb2xsWCAqIGdhbWVPYmplY3Quc2Nyb2xsRmFjdG9yWDtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IGdhbWVPYmplY3QueSAtIGNhbWVyYS5zY3JvbGxZICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JZO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBnYW1lT2JqZWN0LnNjYWxlWDtcclxuICAgICAgICB2YXIgc2NhbGVZID0gZ2FtZU9iamVjdC5zY2FsZVk7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLWdhbWVPYmplY3Qucm90YXRpb247XHJcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgeCA9IC1nYW1lT2JqZWN0LmRpc3BsYXlPcmlnaW5YICsgZnJhbWUueCArICgoZnJhbWUud2lkdGgpICogKGZsaXBYID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB5ID0gLWdhbWVPYmplY3QuZGlzcGxheU9yaWdpblkgKyBmcmFtZS55ICsgKChmcmFtZS5oZWlnaHQpICogKGZsaXBZID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcclxuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcclxuICAgICAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XHJcbiAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XHJcbiAgICAgICAgdmFyIGFscGhhID0gZ2FtZU9iamVjdC5hbHBoYTtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjsgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdHgwID0geCAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgxID0geCAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MSA9IHggKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MiA9IHh3ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgzID0geHcgKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFJlbmRlcmVyKHRoaXMsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUsIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmRyYXdJbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRyYXdpbmdNZXNoID0gZmFsc2U7XHJcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgKz0gNjtcclxuICAgICAgICBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci50b3BMZWZ0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IuYm90dG9tTGVmdDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcblxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLmJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IudG9wUmlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3Nwcml0ZWJhdGNoL1Nwcml0ZUJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA3Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0ge1xyXG5cclxuICAgIC8vIFZFUlRFWF9TSVpFID0gKHNpemVvZih2ZWMyKSAqIDQpICsgKHNpemVvZihmbG9hdCkgKyBzaXplb2YodWludDMyKSlcclxuICAgIFZFUlRFWF9TSVpFOiAyNCxcclxuICAgIElOREVYX1NJWkU6IDIsXHJcbiAgICBTUFJJVEVfVkVSVEVYX0NPVU5UOiA0LFxyXG4gICAgU1BSSVRFX0lOREVYX0NPVU5UOiA2LFxyXG5cclxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxyXG4gICAgU1BSSVRFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gQ2FuJ3QgYmUgYmlnZ2VyIHNpbmNlIGluZGV4IGFyZSAxNi1iaXRcclxuICAgIE1BWF9TUFJJVEVTOiAyMDAwXHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3Nwcml0ZWJhdGNoL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgRGF0YUJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjE2Jyk7XHJcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xyXG52YXIgVGV4dHVyZWRBbmROb3JtYWxpemVkVGludGVkU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vc2hhZGVycy9UZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInKTtcclxuXHJcbnZhciBQSEFTRVJfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25zdCcpO1xyXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgVGlsZUJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xyXG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XHJcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xyXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XHJcbiAgICB0aGlzLm1heFNwcml0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcclxuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcclxuICAgIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuVGlsZUJhdGNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVCYXRjaDtcclxuXHJcblRpbGVCYXRjaC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBEYXRhQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5TUFJJVEVfVkVSVEVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xyXG4gICAgICAgIHZhciBpbmRleERhdGFCdWZmZXIgPSBuZXcgRGF0YUJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlU2hhZGVyKCdUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXInLCBUZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlck9iamVjdCA9IHRoaXMubWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0ID0gdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpLCBnbC5TVFJFQU1fRFJBVyk7XHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IHNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XHJcbiAgICAgICAgdmFyIG1heCA9IENPTlNULk1BWF9TUFJJVEVTICogQ09OU1QuU1BSSVRFX0lOREVYX0NPVU5UO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBpbmRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdCA9IHZlcnRleEJ1ZmZlck9iamVjdDtcclxuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfcG9zaXRpb24nKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfdGV4X2Nvb3JkJyksIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdC5hZGRBdHRyaWJ1dGUoc2hhZGVyLmdldEF0dHJpYkxvY2F0aW9uKCdhX2NvbG9yJyksIDMsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIENPTlNULlZFUlRFWF9TSVpFLCAxNik7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0LmFkZEF0dHJpYnV0ZShzaGFkZXIuZ2V0QXR0cmliTG9jYXRpb24oJ2FfYWxwaGEnKSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMjApO1xyXG5cclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgMl0gPSBpbmRleEIgKyAyO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhBICsgNV0gPSBpbmRleEIgKyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXhCdWZmZXJPYmplY3QudXBkYXRlUmVzb3VyY2UoaW5kZXhCdWZmZXIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdWxkRmx1c2g6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uLCBzaGFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0LmJpbmQoKTtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlck9iamVjdC5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyLCByZW5kZXJUYXJnZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJlbmRlclRhcmdldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYmluZChzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyT2JqZWN0LnVwZGF0ZVJlc291cmNlKHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSwgMCk7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24sIHNoYWRlcilcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcclxuICAgICAgICB2YXIgYWN0aXZlU2hhZGVyID0gc2hhZGVyICE9PSB1bmRlZmluZWQgPyBzaGFkZXIgOiB0aGlzLnNoYWRlcjtcclxuICAgICAgICB2YXIgbG9jYXRpb24gPSBhY3RpdmVTaGFkZXIgPT0gdGhpcy5zaGFkZXIgPyB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA6IGFjdGl2ZVNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oJ3Vfdmlld19tYXRyaXgnKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLnNldFByb2plY3Rpb25NYXRyaXgoYWN0aXZlU2hhZGVyLCBsb2NhdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChzaGFkZXIsIGxvY2F0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlc291cmNlTWFuYWdlci5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJPYmplY3QgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRUaWxlU3ByaXRlOiBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY2FtZXJhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xyXG4gICAgICAgIHZhciBhbHBoYSA9IDE2Nzc3MjE2O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyT2JqZWN0VTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcclxuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgd2lkdGggPSBnYW1lT2JqZWN0LndpZHRoICogKGdhbWVPYmplY3QuZmxpcFggPyAtMSA6IDEpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBnYW1lT2JqZWN0LmhlaWdodCAqIChnYW1lT2JqZWN0LmZsaXBZID8gLTEgOiAxKTtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlWCA9IGdhbWVPYmplY3QueCAtIGNhbWVyYS5zY3JvbGxYICogZ2FtZU9iamVjdC5zY3JvbGxGYWN0b3JYO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGVZID0gZ2FtZU9iamVjdC55IC0gY2FtZXJhLnNjcm9sbFkgKiBnYW1lT2JqZWN0LnNjcm9sbEZhY3Rvclk7XHJcbiAgICAgICAgdmFyIHNjYWxlWCA9IGdhbWVPYmplY3Quc2NhbGVYO1xyXG4gICAgICAgIHZhciBzY2FsZVkgPSBnYW1lT2JqZWN0LnNjYWxlWTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSAtZ2FtZU9iamVjdC5yb3RhdGlvbjtcclxuICAgICAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBkaXNwbGF5T3JpZ2luWCA9IGdhbWVPYmplY3Qub3JpZ2luWCAqIGdhbWVPYmplY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlPcmlnaW5ZID0gZ2FtZU9iamVjdC5vcmlnaW5ZICogZ2FtZU9iamVjdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHggPSAtZGlzcGxheU9yaWdpblggKyAoKGdhbWVPYmplY3Qud2lkdGgpICogKGdhbWVPYmplY3QuZmxpcFggPyAxIDogMC4wKSk7XHJcbiAgICAgICAgdmFyIHkgPSAtZGlzcGxheU9yaWdpblkgKyAoKGdhbWVPYmplY3QuaGVpZ2h0KSAqIChnYW1lT2JqZWN0LmZsaXBZID8gMSA6IDAuMCkpO1xyXG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcclxuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHZhciB1MCA9IDA7XHJcbiAgICAgICAgdmFyIHYwID0gMDtcclxuICAgICAgICB2YXIgdTEgPSB3aWR0aCAvIGdhbWVPYmplY3QuZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIHYxID0gaGVpZ2h0IC8gZ2FtZU9iamVjdC5mcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xyXG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcclxuICAgICAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcclxuICAgICAgICB2YXIgYWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xyXG4gICAgICAgIHZhciB0aWxlUG9zaXRpb25YID0gZ2FtZU9iamVjdC50aWxlUG9zaXRpb25YIC8gZ2FtZU9iamVjdC5mcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgdGlsZVBvc2l0aW9uWSA9IGdhbWVPYmplY3QudGlsZVBvc2l0aW9uWSAvIGdhbWVPYmplY3QuZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gZ2FtZU9iamVjdC50aWxlVGV4dHVyZTtcclxuXHJcbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgc3JhID0gdGVtcE1hdHJpeE1hdHJpeFswXTtcclxuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xyXG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XHJcbiAgICAgICAgc3JkID0gdGVtcE1hdHJpeE1hdHJpeFszXTtcclxuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xyXG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XHJcblxyXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcclxuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XHJcbiAgICAgICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xyXG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcclxuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XHJcbiAgICAgICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xyXG5cclxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XHJcbiAgICAgICAgbXZiID0gc3JhICogY21iICsgc3JiICogY21kO1xyXG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcclxuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XHJcbiAgICAgICAgbXZlID0gc3JlICogY21hICsgc3JmICogY21jICsgY21lO1xyXG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjsgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdHgwID0geCAqIG12YSArIHkgKiBtdmMgKyBtdmU7XHJcbiAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgxID0geCAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MSA9IHggKiBtdmIgKyB5aCAqIG12ZCArIG12ZjtcclxuICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MiA9IHh3ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XHJcbiAgICAgICAgdHgzID0geHcgKiBtdmEgKyB5ICogbXZjICsgbXZlO1xyXG4gICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFJlbmRlcmVyKHRoaXMsIHRleHR1cmUsIGdhbWVPYmplY3QucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSA2O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdTAgKyB0aWxlUG9zaXRpb25YO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB2MCArIHRpbGVQb3NpdGlvblk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0VTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLnRvcExlZnQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHUwICsgdGlsZVBvc2l0aW9uWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjEgKyB0aWxlUG9zaXRpb25ZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci5ib3R0b21MZWZ0O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcclxuXHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1MSArIHRpbGVQb3NpdGlvblg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHYxICsgdGlsZVBvc2l0aW9uWTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IuYm90dG9tUmlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xyXG5cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdEYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTM7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyT2JqZWN0RjMyW3ZlcnRleE9mZnNldCsrXSA9IHUxICsgdGlsZVBvc2l0aW9uWDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gdjAgKyB0aWxlUG9zaXRpb25ZO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlck9iamVjdFUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci50b3BSaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJPYmplY3RGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWxlQmF0Y2g7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL3RpbGViYXRjaC9UaWxlQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDczMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSB7XHJcblxyXG4gICAgLy8gVkVSVEVYX1NJWkUgPSAoc2l6ZW9mKHZlYzIpICogNCkgKyAoc2l6ZW9mKGZsb2F0KSArIHNpemVvZih1aW50MzIpKVxyXG4gICAgVkVSVEVYX1NJWkU6IDI0LFxyXG4gICAgSU5ERVhfU0laRTogMixcclxuICAgIFNQUklURV9WRVJURVhfQ09VTlQ6IDQsXHJcbiAgICBTUFJJVEVfSU5ERVhfQ09VTlQ6IDYsXHJcblxyXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXHJcbiAgICBTUFJJVEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNixcclxuXHJcbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxyXG4gICAgTUFYX1NQUklURVM6IDIwMDBcclxuICAgIFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvdGlsZWJhdGNoL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGFCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0RhdGFCdWZmZXIzMicpO1xyXG52YXIgRGF0YUJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvRGF0YUJ1ZmZlcjE2Jyk7XHJcbnZhciBUaWxlbWFwU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vc2hhZGVycy9UaWxlbWFwU2hhZGVyJyk7XHJcblxyXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xyXG5cclxudmFyIFRpbGVtYXBSZW5kZXJlciA9IGZ1bmN0aW9uIChnYW1lLCBnbCwgbWFuYWdlcilcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMudHlwZSA9IFBIQVNFUl9DT05TVC5XRUJHTDtcclxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcclxuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XHJcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xyXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xyXG5cclxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcclxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xyXG59O1xyXG5cclxuVGlsZW1hcFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVtYXBSZW5kZXJlcjtcclxuXHJcblRpbGVtYXBSZW5kZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZVNoYWRlcignVGlsZW1hcFNoYWRlcicsIFRpbGVtYXBTaGFkZXIpO1xyXG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3ZpZXdfbWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIHNjcm9sbExvY2F0aW9uID0gc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbigndV9zY3JvbGwnKTtcclxuICAgICAgICB2YXIgc2Nyb2xsRmFjdG9yTG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3Njcm9sbF9mYWN0b3InKTtcclxuICAgICAgICB2YXIgdGlsZW1hcFBvc2l0aW9uTG9jYXRpb24gPSBzaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKCd1X3RpbGVtYXBfcG9zaXRpb24nKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XHJcbiAgICAgICAgdGhpcy5zY3JvbGxMb2NhdGlvbiA9IHNjcm9sbExvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRmFjdG9yTG9jYXRpb24gPSBzY3JvbGxGYWN0b3JMb2NhdGlvbjtcclxuICAgICAgICB0aGlzLnRpbGVtYXBQb3NpdGlvbkxvY2F0aW9uID0gdGlsZW1hcFBvc2l0aW9uTG9jYXRpb247XHJcblxyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG91bGRGbHVzaDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxyXG4gICAge1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzaGFkZXIgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbiwgc2hhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGZsdXNoOiBmdW5jdGlvbiAoc2hhZGVyKVxyXG4gICAge1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCBzaGFkZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVNoYWRlciA9IHNoYWRlciAhPT0gdW5kZWZpbmVkID8gc2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XHJcblxyXG4gICAgICAgIGFjdGl2ZVNoYWRlci5zZXRDb25zdGFudE1hdHJpeDR4NChcclxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLmRlbGV0ZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZW1hcFJlbmRlcmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy90aWxlbWFwcmVuZGVyZXIvVGlsZW1hcFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uIChnbCwgYnVmZmVyT2JqZWN0KSBcclxue1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgdGhpcy5idWZmZXJUYXJnZXQgPSBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcclxuICAgIHRoaXMuYnVmZmVyT2JqZWN0ID0gYnVmZmVyT2JqZWN0O1xyXG59O1xyXG5cclxuSW5kZXhCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhCdWZmZXI7XHJcblxyXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUmVzb3VyY2U6IGZ1bmN0aW9uIChidWZmZXJEYXRhLCBvZmZzZXQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlck9iamVjdCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2Zmc2V0LCBidWZmZXJEYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4QnVmZmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9JbmRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoZnJhbWVidWZmZXJPYmplY3QsIHdpZHRoLCBoZWlnaHQsIGNvbG9yQnVmZmVyLCBkZXB0aFN0ZW5jaWxCdWZmZXIpXHJcbntcclxuICAgIHRoaXMuZnJhbWVidWZmZXJPYmplY3QgPSBmcmFtZWJ1ZmZlck9iamVjdDtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5jb2xvckJ1ZmZlciA9IGNvbG9yQnVmZmVyO1xyXG4gICAgdGhpcy5kZXB0aFN0ZW5jaWxCdWZmZXIgPSBkZXB0aFN0ZW5jaWxCdWZmZXI7XHJcbiAgICB0aGlzLnNob3VsZENsZWFyID0gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclRhcmdldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvUmVuZGVyVGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIGdsLCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSBcclxue1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xyXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxufTtcclxuXHJcblNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXI7XHJcblxyXG4vKiBGb3IgV2ViR0wyIHRoaXMgd29uJ3QgYmUgbmVjZXNzYXJ5ICovXHJcblNoYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uOiBmdW5jdGlvbihuYW1lKSBcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0QXR0cmliTG9jYXRpb246IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XHJcbiAgICB9LCAgXHJcblxyXG4gICAgc2V0Q29uc3RhbnRGbG9hdDE6IGZ1bmN0aW9uKGxvY2F0aW9uLCB4KSBcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihsb2NhdGlvbiwgeCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRDb25zdGFudEZsb2F0MjogZnVuY3Rpb24obG9jYXRpb24sIHgsIHkpIFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB4LCB5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50RmxvYXQzOiBmdW5jdGlvbihsb2NhdGlvbiwgeCwgeSwgeikge1xyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB4LCB5LCB6KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50RmxvYXQ0OiBmdW5jdGlvbihsb2NhdGlvbiwgeCwgeSwgeiwgdykge1xyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB4LCB5LCB6LCB3KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50SW50MTogZnVuY3Rpb24obG9jYXRpb24sIHgpIHtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgeCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRDb25zdGFudEludDI6IGZ1bmN0aW9uKGxvY2F0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMmkobG9jYXRpb24sIHgsIHkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0Q29uc3RhbnRJbnQzOiBmdW5jdGlvbihsb2NhdGlvbiwgeCwgeSwgeikge1xyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB4LCB5LCB6KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50SW50NDogZnVuY3Rpb24obG9jYXRpb24sIHgsIHksIHosIHcpIHtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm00aShsb2NhdGlvbiwgeCwgeSwgeiwgdyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRDb25zdGFudE1hdHJpeDJ4MjogZnVuY3Rpb24obG9jYXRpb24sIGZsb2F0QXJyYXkpIHtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCBmbG9hdEFycmF5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldENvbnN0YW50TWF0cml4M3gzOiBmdW5jdGlvbihsb2NhdGlvbiwgZmxvYXRBcnJheSkge1xyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIGZsb2F0QXJyYXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0Q29uc3RhbnRNYXRyaXg0eDQ6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmbG9hdEFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgZmxvYXRBcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3Jlc291cmNlcy9TaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KSBcclxue1xyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5pc1JlbmRlclRleHR1cmUgPSBmYWxzZTtcclxufTtcclxuXHJcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9yZXNvdXJjZXMvVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gNzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbiAoZ2wsIGJ1ZmZlck9iamVjdCkgXHJcbntcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIHRoaXMuYnVmZmVyVGFyZ2V0ID0gZ2wuQVJSQVlfQlVGRkVSO1xyXG4gICAgdGhpcy5idWZmZXJPYmplY3QgPSBidWZmZXJPYmplY3Q7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxufTtcclxuXHJcblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhCdWZmZXI7XHJcblxyXG5WZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaCh7XHJcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogbm9ybWFsaXplZCxcclxuICAgICAgICAgICAgc3RyaWRlOiBzdHJpZGUsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVJlc291cmNlOiBmdW5jdGlvbiAoYnVmZmVyRGF0YSwgb2Zmc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgb2Zmc2V0LCBidWZmZXJEYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBidWZmZXJPYmplY3QgPSB0aGlzLmJ1ZmZlck9iamVjdDtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgYXR0cmlidXRlc0xlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyT2JqZWN0KTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXR0cmlidXRlc0xlbmd0aDsgKytpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gYXR0cmlidXRlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudCAhPT0gbnVsbCkgXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGVsZW1lbnQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmluZGV4LCBcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNpemUsIFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudHlwZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ub3JtYWxpemVkLCBcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0cmlkZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhCdWZmZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvcmVzb3VyY2VzL1ZlcnRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVydDogW1xyXG4gICAgICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2FscGhhOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJyAgIHZfYWxwaGEgPSBhX2FscGhhOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgZnJhZzogW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKSAqIHZlYzQoMS4wLCAxLjAsIDEuMCwgdl9hbHBoYSk7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1RleHR1cmVkQW5kQWxwaGFTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHZlcnQ6IFtcclxuICAgICAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVfc2Nyb2xsOycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Njcm9sbF9mYWN0b3I7JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVfdGlsZW1hcF9wb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleF9jb29yZDsnLFxyXG4gICAgICAgICd2b2lkIG1haW4gKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQodV90aWxlbWFwX3Bvc2l0aW9uICsgYV9wb3NpdGlvbiArICh1X3Njcm9sbCAqIHVfc2Nyb2xsX2ZhY3RvciksIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X3RleF9jb29yZCA9IGFfdGV4X2Nvb3JkOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgZnJhZzogW1xyXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcclxuICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3NhbXBsZXIyRCwgdl90ZXhfY29vcmQpOycsXHJcbiAgICAgICAgJ30nXHJcbiAgICBdLmpvaW4oJ1xcbicpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9UaWxlbWFwU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB2ZXJ0OiBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbHBoYTsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxyXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcclxuICAgICAgICAndm9pZCBtYWluICgpIHsnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxyXG4gICAgICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICcgICB2X2FscGhhID0gYV9hbHBoYTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKSxcclxuICAgIGZyYWc6IFtcclxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcclxuICAgICAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZfY29sb3IuYmdyLCB2X2FscGhhKTsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgXS5qb2luKCdcXG4nKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVW50ZXh0dXJlZEFuZE5vcm1hbGl6ZWRUaW50ZWRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHZlcnQ6IFtcclxuICAgICAgICAndW5pZm9ybSBtYXQ0IHVfdmlld19tYXRyaXg7JyxcclxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxyXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yOycsXHJcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2X2NvbG9yOycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbiAoKSB7JyxcclxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB1X3ZpZXdfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjAsIDEuMCk7JyxcclxuICAgICAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJyksXHJcbiAgICBmcmFnOltcclxuICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcclxuICAgICAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcclxuICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7JyxcclxuICAgICAgICAnfSdcclxuICAgIF0uam9pbignXFxuJylcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1VudGV4dHVyZWRBbmRUaW50ZWRTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzU25hcHNob3QgPSBmdW5jdGlvbiAoY2FudmFzKSBcclxue1xyXG4gICAgdmFyIHNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgIHZhciBpbWFnZSA9ICBuZXcgSW1hZ2UoKTtcclxuICAgIGltYWdlLnNyYyA9IHNyYztcclxuICAgIHJldHVybiBpbWFnZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzU25hcHNob3Q7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc25hcHNob3QvQ2FudmFzU25hcHNob3QuanNcbi8vIG1vZHVsZSBpZCA9IDc0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2ViR0xTbmFwc2hvdCA9IGZ1bmN0aW9uIChjYW52YXMpIFxyXG57XHJcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XHJcbiAgICB2YXIgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAqIDQpO1xyXG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XHJcblxyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgdmFyIGltYWdlRGF0YTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xyXG5cclxuICAgIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8ICBjYW52YXMuaGVpZ2h0OyB5ICs9IDEpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHggKz0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzaSA9ICgoY2FudmFzLmhlaWdodCAtIHkpICogY2FudmFzLndpZHRoICsgeCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgZGkgPSAoeSAqIGNhbnZhcy53aWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgZGF0YVtkaSArIDBdID0gcGl4ZWxzW3NpICsgMF07XHJcbiAgICAgICAgICAgIGRhdGFbZGkgKyAxXSA9IHBpeGVsc1tzaSArIDFdO1xyXG4gICAgICAgICAgICBkYXRhW2RpICsgMl0gPSBwaXhlbHNbc2kgKyAyXTtcclxuICAgICAgICAgICAgZGF0YVtkaSArIDNdID0gcGl4ZWxzW3NpICsgM107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG5cclxuICAgIHZhciBzcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICB2YXIgaW1hZ2UgPSAgbmV3IEltYWdlKCk7XHJcbiAgICBpbWFnZS5zcmMgPSBzcmM7XHJcblxyXG4gICAgcmV0dXJuIGltYWdlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFNuYXBzaG90O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NuYXBzaG90L1dlYkdMU25hcHNob3QuanNcbi8vIG1vZHVsZSBpZCA9IDc0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxudmFyIEJldHdlZW4gPSByZXF1aXJlKCcuLi8uLi9tYXRoL0JldHdlZW4nKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWMuRlhcclxuXHJcbi8vICBCYXNlZCBvbiBTb3VuZC5qcyBieSBLaXR0eUthdEF0dGFja1xyXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL2tpdHR5a2F0YXR0YWNrL3NvdW5kLmpzXHJcblxyXG4vLyBmcmVxdWVuY3ksICAgICAgLy9UaGUgc291bmQncyBmZXF1ZW5jeSBwaXRjaCBpbiBIZXJ0elxyXG4vLyBhdHRhY2ssICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBpblxyXG4vLyBkZWNheSwgICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBvdXRcclxuLy8gdHlwZSwgICAgICAgICAgICAgICAgLy93YXZlZm9ybSB0eXBlOiBcInNpbmVcIiwgXCJ0cmlhbmdsZVwiLCBcInNxdWFyZVwiLCBcInNhd3Rvb3RoXCJcclxuLy8gdm9sdW1lLCAgICAgICAgIC8vVGhlIHNvdW5kJ3MgbWF4aW11bSB2b2x1bWVcclxuLy8gcGFuVmFsdWUsICAgICAgICAgICAgLy9UaGUgc3BlYWtlciBwYW4uIGxlZnQ6IC0xLCBtaWRkbGU6IDAsIHJpZ2h0OiAxXHJcbi8vIHdhaXQsICAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIHdhaXQgYmVmb3JlIHBsYXlpbmcgdGhlIHNvdW5kXHJcbi8vIHBpdGNoQmVuZCwgICAgIC8vVGhlIG51bWJlciBvZiBIeiBpbiB3aGljaCB0byBiZW5kIHRoZSBzb3VuZCdzIHBpdGNoIGRvd25cclxuLy8gcmV2ZXJzZSwgICAgICAgICAgICAgLy9JZiBgcmV2ZXJzZWAgaXMgdHJ1ZSB0aGUgcGl0Y2ggd2lsbCBiZW5kIHVwXHJcbi8vIHJhbmRvbSwgICAgICAgICAvL0EgcmFuZ2UsIGluIEh6LCB3aXRoaW4gd2hpY2ggdG8gcmFuZG9taXplIHRoZSBwaXRjaFxyXG4vLyBkaXNzb25hbmNlLCAgICAgICAgICAvL0EgdmFsdWUgaW4gSHouIEl0IGNyZWF0ZXMgMiBkaXNzb25hbnQgZnJlcXVlbmNpZXMgYWJvdmUgYW5kIGJlbG93IHRoZSB0YXJnZXQgcGl0Y2hcclxuLy8gZWNobywgICAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2RlbGF5VGltZUluU2Vjb25kcywgZmVlZGJhY2tUaW1lSW5TZWNvbmRzLCBmaWx0ZXJWYWx1ZUluSHpdXHJcbi8vIHJldmVyYiwgICAgICAgICAgICAgIC8vQW4gYXJyYXk6IFtkdXJhdGlvbkluU2Vjb25kcywgZGVjYXlSYXRlSW5TZWNvbmRzLCByZXZlcnNlXVxyXG4vLyB0aW1lb3V0ICAgICAgICAgICAgICAvL0EgbnVtYmVyLCBpbiBzZWNvbmRzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBkdXJhdGlvbiBmb3Igc291bmQgZWZmZWN0c1xyXG5cclxudmFyIEZYID0gZnVuY3Rpb24gKGN0eCwgY29uZmlnKVxyXG57XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGN0eDtcclxuXHJcbiAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlID0gR2V0VmFsdWUoY29uZmlnLCAnZnJlcXVlbmN5JywgMjAwKTtcclxuICAgIHRoaXMuYXR0YWNrID0gR2V0VmFsdWUoY29uZmlnLCAnYXR0YWNrJywgMCk7XHJcbiAgICB0aGlzLmRlY2F5ID0gR2V0VmFsdWUoY29uZmlnLCAnZGVjYXknLCAxKTtcclxuICAgIHRoaXMudHlwZSA9IEdldFZhbHVlKGNvbmZpZywgJ3R5cGUnLCAnc2luZScpO1xyXG4gICAgdGhpcy52b2x1bWVWYWx1ZSA9IEdldFZhbHVlKGNvbmZpZywgJ3ZvbHVtZScsIDEpO1xyXG4gICAgdGhpcy5wYW5WYWx1ZSA9IEdldFZhbHVlKGNvbmZpZywgJ3BhbicsIDApO1xyXG4gICAgdGhpcy53YWl0ID0gR2V0VmFsdWUoY29uZmlnLCAnd2FpdCcsIDApO1xyXG4gICAgdGhpcy5waXRjaEJlbmRBbW91bnQgPSBHZXRWYWx1ZShjb25maWcsICdwaXRjaEJlbmQnLCAwKTtcclxuICAgIHRoaXMucmV2ZXJzZSA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyc2UnLCBmYWxzZSk7XHJcbiAgICB0aGlzLnJhbmRvbVZhbHVlID0gR2V0VmFsdWUoY29uZmlnLCAncmFuZG9tJywgMCk7XHJcbiAgICB0aGlzLmRpc3NvbmFuY2UgPSBHZXRWYWx1ZShjb25maWcsICdkaXNzb25hbmNlJywgMCk7XHJcbiAgICB0aGlzLmVjaG8gPSBHZXRWYWx1ZShjb25maWcsICdlY2hvJywgZmFsc2UpO1xyXG4gICAgdGhpcy5lY2hvRGVsYXkgPSBHZXRWYWx1ZShjb25maWcsICdlY2hvLmRlbGF5JywgMCk7XHJcbiAgICB0aGlzLmVjaG9GZWVkYmFjayA9IEdldFZhbHVlKGNvbmZpZywgJ2VjaG8uZmVlZGJhY2snLCAwKTtcclxuICAgIHRoaXMuZWNob0ZpbHRlciA9IEdldFZhbHVlKGNvbmZpZywgJ2VjaG8uZmlsdGVyJywgMCk7XHJcbiAgICB0aGlzLnJldmVyYiA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyYicsIGZhbHNlKTtcclxuICAgIHRoaXMucmV2ZXJiRHVyYXRpb24gPSBHZXRWYWx1ZShjb25maWcsICdyZXZlcmIuZHVyYXRpb24nLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiRGVjYXkgPSBHZXRWYWx1ZShjb25maWcsICdyZXZlcmIuZGVjYXknLCAwKTtcclxuICAgIHRoaXMucmV2ZXJiUmV2ZXJzZSA9IEdldFZhbHVlKGNvbmZpZywgJ3JldmVyYi5yZXZlcnNlJywgZmFsc2UpO1xyXG4gICAgdGhpcy50aW1lb3V0ID0gR2V0VmFsdWUoY29uZmlnLCAndGltZW91dCcsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcbiAgICB0aGlzLnBhbiA9ICghY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcikgPyBjdHguY3JlYXRlUGFubmVyKCkgOiBjdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XHJcblxyXG4gICAgdGhpcy52b2x1bWUuY29ubmVjdCh0aGlzLnBhbik7XHJcbiAgICB0aGlzLnBhbi5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XHJcblxyXG4gICAgLy8gIFNldCB0aGUgdmFsdWVzXHJcblxyXG4gICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XHJcblxyXG4gICAgaWYgKCFjdHguY3JlYXRlU3RlcmVvUGFubmVyKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucGFuLnNldFBvc2l0aW9uKHRoaXMucGFuVmFsdWUsIDAsIDEgLSBNYXRoLmFicyh0aGlzLnBhblZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYW4ucGFuLnZhbHVlID0gdGhpcy5wYW5WYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQ3JlYXRlIGFuIG9zY2lsbGF0b3IsIGdhaW4gYW5kIHBhbiBub2RlcywgYW5kIGNvbm5lY3QgdGhlbSB0b2dldGhlciB0byB0aGUgZGVzdGluYXRpb25cclxuXHJcbiAgICB2YXIgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcblxyXG4gICAgb3NjaWxsYXRvci5jb25uZWN0KHRoaXMudm9sdW1lKTtcclxuICAgIG9zY2lsbGF0b3IudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcbiAgICAvLyAgT3B0aW9uYWxseSByYW5kb21pemUgdGhlIHBpdGNoIGlmIGByYW5kb21WYWx1ZWAgPiAwLlxyXG4gICAgLy8gIEEgcmFuZG9tIHBpdGNoIGlzIHNlbGVjdGVkIHRoYXQncyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSBgZnJlcXVlbmN5VmFsdWVgLlxyXG4gICAgLy8gIFRoZSByYW5kb20gcGl0Y2ggd2lsbCBiZSBlaXRoZXIgYWJvdmUgb3IgYmVsb3cgdGhlIHRhcmdldCBmcmVxdWVuY3kuXHJcblxyXG4gICAgaWYgKHRoaXMucmFuZG9tVmFsdWUgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gQmV0d2VlbihcclxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMucmFuZG9tVmFsdWUgLyAyLFxyXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5yYW5kb21WYWx1ZSAvIDJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQXBwbHkgZWZmZWN0c1xyXG5cclxuICAgIGlmICh0aGlzLmF0dGFjayA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5mYWRlSW4odGhpcy52b2x1bWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmFkZU91dCh0aGlzLnZvbHVtZSk7XHJcblxyXG4gICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBpdGNoQmVuZChvc2NpbGxhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lY2hvKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkRWNobyh0aGlzLnZvbHVtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmV2ZXJiKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuYWRkUmV2ZXJiKHRoaXMudm9sdW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaXNzb25hbmNlID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmFkZERpc3NvbmFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsYXkob3NjaWxsYXRvcik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBvc2NpbGxhdG9yLm9uZW5kZWQgPSBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIF90aGlzLnBhbi5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgX3RoaXMudm9sdW1lLmRpc2Nvbm5lY3QoKTtcclxuICAgIH07XHJcbn07XHJcblxyXG5GWC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGWDtcclxuXHJcbkZYLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBwbGF5OiBmdW5jdGlvbiAob3NjaWxsYXRvcilcclxuICAgIHtcclxuICAgICAgICBvc2NpbGxhdG9yLnN0YXJ0KHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcclxuXHJcbiAgICAgICAgLy9Pc2NpbGxhdG9ycyBoYXZlIHRvIGJlIHN0b3BwZWQgb3RoZXJ3aXNlIHRoZXkgYWNjdW11bGF0ZSBpbiBcclxuICAgICAgICAvL21lbW9yeSBhbmQgdGF4IHRoZSBDUFUuIFRoZXknbGwgYmUgc3RvcHBlZCBhZnRlciBhIGRlZmF1bHRcclxuICAgICAgICAvL3RpbWVvdXQgb2YgMiBzZWNvbmRzLCB3aGljaCBzaG91bGQgYmUgZW5vdWdoIGZvciBtb3N0IHNvdW5kIFxyXG4gICAgICAgIC8vZWZmZWN0cy4gT3ZlcnJpZGUgdGhpcyBpbiB0aGUgYHNvdW5kRWZmZWN0YCBwYXJhbWV0ZXJzIGlmIHlvdVxyXG4gICAgICAgIC8vbmVlZCBhIGxvbmdlciBzb3VuZFxyXG5cclxuICAgICAgICBvc2NpbGxhdG9yLnN0b3AodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyAyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmFkZUluOiBmdW5jdGlvbiAodm9sdW1lKVxyXG4gICAge1xyXG4gICAgICAgIHZvbHVtZS5nYWluLnZhbHVlID0gMDtcclxuXHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xyXG5cclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLnZvbHVtZVZhbHVlLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrKTtcclxuICAgIH0sXHJcblxyXG4gICAgZmFkZU91dDogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLnZvbHVtZVZhbHVlLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrKTtcclxuXHJcbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRSZXZlcmI6IGZ1bmN0aW9uICh2b2x1bWUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbnZvbHZlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xyXG5cclxuICAgICAgICBjb252b2x2ZXIuYnVmZmVyID0gdGhpcy5pbXB1bHNlUmVzcG9uc2UodGhpcy5yZXZlcmJEdXJhdGlvbiwgdGhpcy5yZXZlcmJEZWNheSwgdGhpcy5yZXZlcmJSZXZlcnNlLCB0aGlzLmF1ZGlvQ29udGV4dCk7XHJcblxyXG4gICAgICAgIHZvbHVtZS5jb25uZWN0KGNvbnZvbHZlcik7XHJcblxyXG4gICAgICAgIGNvbnZvbHZlci5jb25uZWN0KHRoaXMucGFuKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkRWNobzogZnVuY3Rpb24gKHZvbHVtZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZmVlZGJhY2sgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlRGVsYXkoKTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XHJcblxyXG4gICAgICAgIC8vICBTZXQgdGhlIG5vZGUgdmFsdWVzXHJcblxyXG4gICAgICAgIGZlZWRiYWNrLmdhaW4udmFsdWUgPSB0aGlzLmVjaG9GZWVkYmFjaztcclxuICAgICAgICBkZWxheS5kZWxheVRpbWUudmFsdWUgPSB0aGlzLmVjaG9EZWxheTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWNob0ZpbHRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbHRlci5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmVjaG9GaWx0ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ3JlYXRlIHRoZSBkZWxheSBmZWVkYmFjayBsb29wICh3aXRoIG9wdGlvbmFsIGZpbHRlcmluZylcclxuXHJcbiAgICAgICAgZGVsYXkuY29ubmVjdChmZWVkYmFjayk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVjaG9GaWx0ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmZWVkYmFjay5jb25uZWN0KGZpbHRlcik7XHJcbiAgICAgICAgICAgIGZpbHRlci5jb25uZWN0KGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmVlZGJhY2suY29ubmVjdChkZWxheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgZGVsYXkgbm9kZSB0byB0aGUgb3NjaWxsYXRvciB2b2x1bWUgbm9kZVxyXG5cclxuICAgICAgICB2b2x1bWUuY29ubmVjdChkZWxheSk7XHJcblxyXG4gICAgICAgIC8vICBDb25uZWN0IHRoZSBkZWxheSBub2RlIHRvIHRoZSBtYWluIHNvdW5kIGNoYWlucyBwYW4gbm9kZSxcclxuICAgICAgICAvLyAgc28gdGhhdCB0aGUgZWNobyBlZmZlY3QgaXMgZGlyZWN0ZWQgdG8gdGhlIGNvcnJlY3Qgc3BlYWtlclxyXG5cclxuICAgICAgICBkZWxheS5jb25uZWN0KHRoaXMucGFuKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGl0Y2hCZW5kOiBmdW5jdGlvbiAob3NjaWxsYXRvcilcclxuICAgIHtcclxuICAgICAgICB2YXIgZnJlcXVlbmN5ID0gb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5yZXZlcnNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIElmIHJldmVyc2UgaXMgZmFsc2UsIG1ha2UgdGhlIHNvdW5kIGRyb3AgaW4gcGl0Y2hcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSAtIHRoaXMucGl0Y2hCZW5kQW1vdW50LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBJZiByZXZlcnNlIGlzIHRydWUsIG1ha2UgdGhlIHNvdW5kIHJpc2UgaW4gcGl0Y2hcclxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XHJcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSArIHRoaXMucGl0Y2hCZW5kQW1vdW50LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkRGlzc29uYW5jZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyAgQ3JlYXRlIHR3byBtb3JlIG9zY2lsbGF0b3JzIGFuZCBnYWluIG5vZGVzXHJcblxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICAgICAgdmFyIGQxID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgICAgICB2YXIgZDIgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4gICAgICAgIHZhciBkMVZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdmFyIGQyVm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgdm9sdW1lIHRvIHRoZSBgdm9sdW1lVmFsdWVgXHJcbiAgICAgICAgZDFWb2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XHJcbiAgICAgICAgZDJWb2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XHJcblxyXG4gICAgICAgIC8vICBDb25uZWN0IHRoZSBvc2NpbGxhdG9ycyB0byB0aGUgZ2FpbiBhbmQgZGVzdGluYXRpb24gbm9kZXNcclxuICAgICAgICBkMS5jb25uZWN0KGQxVm9sdW1lKTtcclxuICAgICAgICBkMi5jb25uZWN0KGQyVm9sdW1lKTtcclxuXHJcbiAgICAgICAgZDFWb2x1bWUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xyXG4gICAgICAgIGQyVm9sdW1lLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgd2F2ZWZvcm0gdG8gXCJzYXd0b290aFwiIGZvciBhIGhhcnNoIGVmZmVjdFxyXG4gICAgICAgIGQxLnR5cGUgPSAnc2F3dG9vdGgnO1xyXG4gICAgICAgIGQyLnR5cGUgPSAnc2F3dG9vdGgnO1xyXG5cclxuICAgICAgICAvLyAgTWFrZSB0aGUgdHdvIG9zY2lsbGF0b3JzIHBsYXkgYXQgZnJlcXVlbmNpZXMgYWJvdmUgYW5kIGJlbG93IHRoZSBtYWluIHNvdW5kJ3MgZnJlcXVlbmN5LlxyXG4gICAgICAgIC8vICBVc2Ugd2hhdGV2ZXIgdmFsdWUgd2FzIHN1cHBsaWVkIGJ5IHRoZSBgZGlzc29uYW5jZWAgYXJndW1lbnRcclxuICAgICAgICBkMS5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5kaXNzb25hbmNlO1xyXG4gICAgICAgIGQyLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZnJlcXVlbmN5VmFsdWUgLSB0aGlzLmRpc3NvbmFuY2U7XHJcblxyXG4gICAgICAgIC8vICBGYWRlIGluIC8gb3V0LCBwaXRjaCBiZW5kIGFuZCBwbGF5IHRoZSBvc2NpbGxhdG9ycyB0byBtYXRjaCB0aGUgbWFpbiBzb3VuZFxyXG4gICAgICAgIGlmICh0aGlzLmF0dGFjayA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVJbihkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluKGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlY2F5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZU91dChkMVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZU91dChkMlZvbHVtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5waXRjaEJlbmRBbW91bnQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5waXRjaEJlbmQoZDEpO1xyXG4gICAgICAgICAgICB0aGlzLnBpdGNoQmVuZChkMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lY2hvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFY2hvKGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFY2hvKGQyVm9sdW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJldmVyYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmV2ZXJiKGQxVm9sdW1lKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXZlcmIoZDJWb2x1bWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wbGF5KGQxKTtcclxuICAgICAgICB0aGlzLnBsYXkoZDIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpbXB1bHNlUmVzcG9uc2U6IGZ1bmN0aW9uIChkdXJhdGlvbiwgZGVjYXksIHJldmVyc2UpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlci5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSAqIGR1cmF0aW9uO1xyXG5cclxuICAgICAgICAvLyAgQ3JlYXRlIGFuIGF1ZGlvIGJ1ZmZlciAoYW4gZW1wdHkgc291bmQgY29udGFpbmVyKSB0byBzdG9yZSB0aGUgcmV2ZXJiIGVmZmVjdC5cclxuICAgICAgICB2YXIgaW1wdWxzZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBsZW5ndGgsIHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xyXG5cclxuICAgICAgICAvLyAgVXNlIGBnZXRDaGFubmVsRGF0YWAgdG8gaW5pdGlhbGl6ZSBlbXB0eSBhcnJheXMgdG8gc3RvcmUgc291bmQgZGF0YSBmb3IgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzLlxyXG4gICAgICAgIHZhciBsZWZ0ID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgwKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDEpO1xyXG5cclxuICAgICAgICAvLyAgTG9vcCB0aHJvdWdoIGVhY2ggc2FtcGxlLWZyYW1lIGFuZCBmaWxsIHRoZSBjaGFubmVsIGRhdGEgd2l0aCByYW5kb20gbm9pc2UuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBBcHBseSB0aGUgcmV2ZXJzZSBlZmZlY3QsIGlmIGByZXZlcnNlYCBpcyBgdHJ1ZWAuXHJcbiAgICAgICAgICAgIHZhciBuID0gKHJldmVyc2UpID8gbGVuZ3RoIC0gaSA6IGk7XHJcblxyXG4gICAgICAgICAgICAvLyAgRmlsbCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMgd2l0aCByYW5kb20gd2hpdGUgbm9pc2Ugd2hpY2ggZGVjYXlzIGV4cG9uZW50aWFsbHkuXHJcbiAgICAgICAgICAgIGxlZnRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XHJcbiAgICAgICAgICAgIHJpZ2h0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIFJldHVybiB0aGUgYGltcHVsc2VgLlxyXG4gICAgICAgIHJldHVybiBpbXB1bHNlO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRlg7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291bmQvZHluYW1pYy9GWC5qc1xuLy8gbW9kdWxlIGlkID0gNzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuU291bmQuRHluYW1pY1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgRlg6IHJlcXVpcmUoJy4vRlgnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VuZC9keW5hbWljL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XHJcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4vU3RhdGUnKTtcclxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9nZW9tL3JlY3RhbmdsZS9SZWN0YW5nbGUnKTtcclxudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xyXG52YXIgQ2FudmFzSW50ZXJwb2xhdGlvbiA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNJbnRlcnBvbGF0aW9uJyk7XHJcbnZhciBHZXRDb250ZXh0ID0gcmVxdWlyZSgnLi4vY2FudmFzL0dldENvbnRleHQnKTtcclxuXHJcbi8qKlxyXG4qIFRoZSBTdGF0ZSBNYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLCBzZXR0aW5nIHVwIGFuZCBzd2l0Y2hpbmcgZ2FtZSBzdGF0ZXMuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlclxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cclxuKi9cclxudmFyIEdsb2JhbFN0YXRlTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lLCBzdGF0ZUNvbmZpZylcclxue1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuXHJcbiAgICAvLyAgRXZlcnl0aGluZyBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMua2V5cyA9IHt9O1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcclxuXHJcbiAgICAvLyAgT25seSBhY3RpdmUgc3RhdGVzIGFyZSBrZXB0IGluIGhlcmVcclxuICAgIHRoaXMuYWN0aXZlID0gW107XHJcblxyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG5cclxuICAgIGlmIChzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZUNvbmZpZykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlQ29uZmlnLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGkgPT09IDAgcGFydCBqdXN0IHN0YXJ0cyB0aGUgZmlyc3QgU3RhdGUgZ2l2ZW5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TdGFydDogKGkgPT09IDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGF1dG9TdGFydDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkdsb2JhbFN0YXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHbG9iYWxTdGF0ZU1hbmFnZXI7XHJcblxyXG5HbG9iYWxTdGF0ZU1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cclxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlciNib290XHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgYm9vdDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9wZW5kaW5nW2ldO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGQoZW50cnkua2V5LCBlbnRyeS5zdGF0ZSwgZW50cnkuYXV0b1N0YXJ0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBDbGVhciB0aGUgcGVuZGluZyBsaXN0XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgcHJpdmF0ZVxyXG4gICAgZ2V0S2V5OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoIWtleSkgeyBrZXkgPSAnZGVmYXVsdCc7IH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXRlQ29uZmlnIGluc3RhbmNlb2YgU3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBrZXkgPSBzdGF0ZUNvbmZpZy5zZXR0aW5ncy5rZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ29iamVjdCcgJiYgc3RhdGVDb25maWcuaGFzT3duUHJvcGVydHkoJ2tleScpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAga2V5ID0gc3RhdGVDb25maWcua2V5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gIEJ5IHRoaXMgcG9pbnQgaXQncyBlaXRoZXIgJ2RlZmF1bHQnIG9yIGV4dHJhY3RlZCBmcm9tIHRoZSBTdGF0ZVxyXG5cclxuICAgICAgICBpZiAodGhpcy5rZXlzLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYSBTdGF0ZSB3aXRoIGR1cGxpY2F0ZSBrZXk6ICcgKyBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZHMgYSBuZXcgU3RhdGUgaW50byB0aGUgR2xvYmFsU3RhdGVNYW5hZ2VyLiBZb3UgbXVzdCBnaXZlIGVhY2ggU3RhdGUgYSB1bmlxdWUga2V5IGJ5IHdoaWNoIHlvdSdsbCBpZGVudGlmeSBpdC5cclxuICAgICogVGhlIFN0YXRlIGNhbiBiZSBlaXRoZXIgYSBQaGFzZXIuU3RhdGUgb2JqZWN0IChvciBhbiBvYmplY3QgdGhhdCBleHRlbmRzIGl0KSwgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCBvciBhIGZ1bmN0aW9uLlxyXG4gICAgKiBJZiBhIGZ1bmN0aW9uIGlzIGdpdmVuIGEgbmV3IHN0YXRlIG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQgYnkgY2FsbGluZyBpdC5cclxuICAgICpcclxuICAgICogQG1ldGhvZCBQaGFzZXIuR2xvYmFsU3RhdGVNYW5hZ2VyI2FkZFxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSB1bmlxdWUga2V5IHlvdSB1c2UgdG8gcmVmZXJlbmNlIHRoaXMgc3RhdGUsIGkuZS4gXCJNYWluTWVudVwiLCBcIkxldmVsMVwiLlxyXG4gICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZXxvYmplY3R8ZnVuY3Rpb259IHN0YXRlICAtIFRoZSBzdGF0ZSB5b3Ugd2FudCB0byBzd2l0Y2ggdG8uXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9TdGFydD1mYWxzZV0gIC0gSWYgdHJ1ZSB0aGUgU3RhdGUgd2lsbCBiZSBzdGFydGVkIGltbWVkaWF0ZWx5IGFmdGVyIGFkZGluZyBpdC5cclxuICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnLCBhdXRvU3RhcnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGF1dG9TdGFydCA9PT0gdW5kZWZpbmVkKSB7IGF1dG9TdGFydCA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuX3BlbmRpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVDb25maWcsXHJcbiAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IGF1dG9TdGFydFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIgbm90IHlldCBib290ZWQsIGFkZGluZyB0byBsaXN0JywgdGhpcy5fcGVuZGluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkJywga2V5LCBzdGF0ZUNvbmZpZywgYXV0b1N0YXJ0KTtcclxuXHJcbiAgICAgICAgdmFyIG5ld1N0YXRlO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gaW5zdGFuY2U6Jywga2V5KTtcclxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUluc3RhbmNlKGtleSwgc3RhdGVDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhdGVDb25maWcgPT09ICdvYmplY3QnKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0dsb2JhbFN0YXRlTWFuYWdlci5hZGQgZnJvbSBvYmplY3Q6Jywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlQ29uZmlnLmtleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21PYmplY3Qoa2V5LCBzdGF0ZUNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gZnVuY3Rpb246Jywga2V5KTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21GdW5jdGlvbihrZXksIHN0YXRlQ29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMua2V5c1trZXldID0gbmV3U3RhdGU7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2gobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1N0YXRlLnNldHRpbmdzLmFjdGl2ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGtleSwgbmV3U3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgbmV3U3RhdGUuc2V0dGluZ3Mua2V5ID0ga2V5O1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRGlzcGxheShuZXdTdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU3RhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgU3RhdGUoc3RhdGVDb25maWcpO1xyXG5cclxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRGlzcGxheShuZXdTdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwQ2FsbGJhY2tzKG5ld1N0YXRlLCBzdGF0ZUNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVN0YXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbiAoa2V5LCBzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgc3RhdGUoKTtcclxuXHJcbiAgICAgICAgaWYgKG5ld1N0YXRlIGluc3RhbmNlb2YgU3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGF0ZUZyb21JbnN0YW5jZShrZXksIG5ld1N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzID0gbmV3IFN5c3RlbXMobmV3U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQodGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVEaXNwbGF5KG5ld1N0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBEZWZhdWx0IHJlcXVpcmVkIGZ1bmN0aW9uc1xyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5pbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pbml0ID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5wcmVsb2FkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5wcmVsb2FkID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5jcmVhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmNyZWF0ZSA9IE5PT1A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2h1dGRvd24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnNodXRkb3duID0gTk9PUDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS51cGRhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnVwZGF0ZSA9IE5PT1A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUucmVuZGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5yZW5kZXIgPSBOT09QO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXR1cENhbGxiYWNrczogZnVuY3Rpb24gKHN0YXRlLCBzdGF0ZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoc3RhdGVDb25maWcgPT09IHVuZGVmaW5lZCkgeyBzdGF0ZUNvbmZpZyA9IHN0YXRlOyB9XHJcblxyXG4gICAgICAgIC8vICBFeHRyYWN0IGNhbGxiYWNrcyBvciBzZXQgTk9PUFxyXG5cclxuICAgICAgICBzdGF0ZS5pbml0ID0gR2V0VmFsdWUoc3RhdGVDb25maWcsICdpbml0JywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUucHJlbG9hZCA9IEdldFZhbHVlKHN0YXRlQ29uZmlnLCAncHJlbG9hZCcsIE5PT1ApO1xyXG4gICAgICAgIHN0YXRlLmNyZWF0ZSA9IEdldFZhbHVlKHN0YXRlQ29uZmlnLCAnY3JlYXRlJywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUuc2h1dGRvd24gPSBHZXRWYWx1ZShzdGF0ZUNvbmZpZywgJ3NodXRkb3duJywgTk9PUCk7XHJcblxyXG4gICAgICAgIC8vICBHYW1lIExvb3AgbGV2ZWwgY2FsbGJhY2tzXHJcblxyXG4gICAgICAgIHN0YXRlLnVwZGF0ZSA9IEdldFZhbHVlKHN0YXRlQ29uZmlnLCAndXBkYXRlJywgTk9PUCk7XHJcbiAgICAgICAgc3RhdGUucmVuZGVyID0gR2V0VmFsdWUoc3RhdGVDb25maWcsICdyZW5kZXInLCBOT09QKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTdGF0ZURpc3BsYXk6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlU3RhdGVEaXNwbGF5Jywgc3RhdGUuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0gc3RhdGUuc3lzLnNldHRpbmdzO1xyXG5cclxuICAgICAgICAvLyB2YXIgeCA9IHNldHRpbmdzLng7XHJcbiAgICAgICAgLy8gdmFyIHkgPSBzZXR0aW5ncy55O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHNldHRpbmdzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdhbWUuY29uZmlnO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW5kZXJUb1RleHR1cmUnLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShzdGF0ZSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY29udGV4dCA9IEdldENvbnRleHQoc3RhdGUuc3lzLmNhbnZhcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gIFBpeGVsIEFydCBtb2RlP1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5waXhlbEFydClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDYW52YXNJbnRlcnBvbGF0aW9uLnNldENyaXNwKHN0YXRlLnN5cy5jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3VzaW5nIGdhbWUgY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubWFzayA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMuY2FudmFzID0gdGhpcy5nYW1lLmNhbnZhcztcclxuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jb250ZXh0ID0gdGhpcy5nYW1lLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gc3RhdGUuc3lzLmZibyA9IHRoaXMuZ2FtZS5yZW5kZXJlci5jcmVhdGVGQk8oc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXldO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBY3RpdmVTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IHN0YXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuYWN0aXZlW2ldLmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChzdGF0ZSAmJiBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUuaW5kZXhPZihzdGF0ZSkgIT09IC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgeyBkYXRhID0ge307IH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0OicsIGtleSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5kaXIoZGF0YSk7XHJcblxyXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXHJcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnR2xvYmFsU3RhdGVNYW5hZ2VyIG5vdCB5ZXQgYm9vdGVkLCBzZXR0aW5nIGF1dG9TdGFydCBvbiBwZW5kaW5nIGxpc3QnKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGVuZGluZy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgQWxyZWFkeSBzdGFydGVkPyBOb3RoaW5nIG1vcmUgdG8gZG8gaGVyZSAuLi5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoa2V5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gc3RhdGUuc3lzLmxvYWQ7XHJcblxyXG4gICAgICAgICAgICAvLyAgRmlsZXMgcGF5bG9hZD9cclxuICAgICAgICAgICAgaWYgKGxvYWRlciAmJiBBcnJheS5pc0FycmF5KHN0YXRlLnN5cy5zZXR0aW5ncy5maWxlcykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvYWRlci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZXIubG9hZEFycmF5KHN0YXRlLnN5cy5zZXR0aW5ncy5maWxlcykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLnBheWxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwYXlsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXlsb2FkQ29tcGxldGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBib290U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYm9vdFN0YXRlJywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSk7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZS5pbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3RhdGUuaW5pdC5jYWxsKHN0YXRlLCBzdGF0ZS5zeXMuc2V0dGluZ3MuZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbG9hZGVyID0gc3RhdGUuc3lzLmxvYWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGxvYWRlci5yZXNldCgpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUucHJlbG9hZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlLnByZWxvYWQodGhpcy5nYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBJcyB0aGUgbG9hZGVyIGVtcHR5P1xyXG4gICAgICAgICAgICBpZiAobG9hZGVyLmxpc3Quc2l6ZSA9PT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gIFN0YXJ0IHRoZSBsb2FkZXIgZ29pbmcgYXMgd2UgaGF2ZSBzb21ldGhpbmcgaW4gdGhlIHF1ZXVlXHJcblxyXG4gICAgICAgICAgICAgICAgbG9hZGVyLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLmxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2FkZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcclxuICAgIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2FkQ29tcGxldGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlJywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coc3RhdGUpO1xyXG5cclxuICAgICAgICAvLyAgSW5zZXJ0IGF0IHRoZSBjb3JyZWN0IGluZGV4LCBvciBpdCBqdXN0IGFsbCBnb2VzIHdyb25nIDopXHJcblxyXG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRTdGF0ZUluZGV4KHN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZS5pbmRleCcsIHN0YXRlLnN5cy5zZXR0aW5ncy5rZXksIGkpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKHsgaW5kZXg6IGksIHN0YXRlOiBzdGF0ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gIFNvcnQgdGhlICdhY3RpdmUnIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRleCBwcm9wZXJ0eVxyXG4gICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0U3RhdGVzKTtcclxuXHJcbiAgICAgICAgc3RhdGUuc3lzLnVwZGF0ZXMucnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZS5jcmVhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGF0ZS5jcmVhdGUuY2FsbChzdGF0ZSwgc3RhdGUuc3lzLnNldHRpbmdzLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcGF1c2U6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRBY3RpdmVTdGF0ZUluZGV4KHRoaXMuZ2V0U3RhdGUoa2V5KSk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRTdGF0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc29ydFN0YXRlczogZnVuY3Rpb24gKHN0YXRlQSwgc3RhdGVCKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0U3RhdGVzJywgc3RhdGVBLnN0YXRlLnN5cy5zZXR0aW5ncy5rZXksIHN0YXRlQS5pbmRleCwgc3RhdGVCLnN0YXRlLnN5cy5zZXR0aW5ncy5rZXksIHN0YXRlQi5pbmRleCk7XHJcblxyXG4gICAgICAgIC8vICBTb3J0IGRlc2NlbmRpbmdcclxuICAgICAgICBpZiAoc3RhdGVBLmluZGV4IDwgc3RhdGVCLmluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGF0ZUEuaW5kZXggPiBzdGF0ZUIuaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2xvYmFsU3RhdGVNYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XHJcbnZhciBHZXRWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9HZXRWYWx1ZScpO1xyXG5cclxudmFyIFNldHRpbmdzID0ge1xyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcgPSB7IGtleTogY29uZmlnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFBhc3MgdGhlICdoYXNPd25Qcm9wZXJ0eScgY2hlY2tzXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgICAgIHN0YXR1czogQ09OU1QuUEVORElORyxcclxuXHJcbiAgICAgICAgICAgIG9wOiBDT05TVC5CT09ULFxyXG5cclxuICAgICAgICAgICAga2V5OiBHZXRWYWx1ZShjb25maWcsICdrZXknLCAnJyksXHJcbiAgICAgICAgICAgIGFjdGl2ZTogR2V0VmFsdWUoY29uZmlnLCAnYWN0aXZlJywgZmFsc2UpLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBHZXRWYWx1ZShjb25maWcsICd2aXNpYmxlJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAvLyAgTG9hZGVyIHBheWxvYWQgYXJyYXlcclxuXHJcbiAgICAgICAgICAgIGRhdGE6IHt9LFxyXG5cclxuICAgICAgICAgICAgZmlsZXM6IEdldFZhbHVlKGNvbmZpZywgJ2ZpbGVzJywgZmFsc2UpLFxyXG5cclxuICAgICAgICAgICAgLy8gIC0xIG1lYW5zIHRoZSBTdGF0ZSBNYW5hZ2VyIHdpbGwgc2V0IGl0IHRvIGJlIHRoZSBHYW1lIGRpbWVuc2lvbnNcclxuXHJcbiAgICAgICAgICAgIHg6IEdldFZhbHVlKGNvbmZpZywgJ3gnLCAwKSxcclxuICAgICAgICAgICAgeTogR2V0VmFsdWUoY29uZmlnLCAneScsIDApLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogR2V0VmFsdWUoY29uZmlnLCAncm90YXRpb24nLCAwKSxcclxuICAgICAgICAgICAgd2lkdGg6IEdldFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgLTEpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IEdldFZhbHVlKGNvbmZpZywgJ2hlaWdodCcsIC0xKSxcclxuXHJcbiAgICAgICAgICAgIC8vICBTdGF0ZSBSZW5kZXIgU2V0dGluZ3MgKGFwcGxpZXMgb25seSB0byB0aGlzIFN0YXRlKVxyXG5cclxuICAgICAgICAgICAgc2NhbGVNb2RlOiBHZXRWYWx1ZShjb25maWcsICdzY2FsZU1vZGUnLCBTY2FsZU1vZGVzLkRFRkFVTFQpLFxyXG4gICAgICAgICAgICByb3VuZFBpeGVsczogR2V0VmFsdWUoY29uZmlnLCAncm91bmRQaXhlbHMnLCBmYWxzZSksXHJcblxyXG4gICAgICAgICAgICBkaXJ0eVJlbmRlcjogR2V0VmFsdWUoY29uZmlnLCAnZGlydHlSZW5kZXInLCBmYWxzZSksXHJcbiAgICAgICAgICAgIHJlbmRlclRvVGV4dHVyZTogR2V0VmFsdWUoY29uZmlnLCAncmVuZGVyVG9UZXh0dXJlJywgZmFsc2UpLFxyXG5cclxuICAgICAgICAgICAgLy8gIFRoZSBmb2xsb3dpbmcgb25seSBhcHBseSBpZiByZW5kZXJUb1RleHR1cmUgaXMgdHJ1ZVxyXG5cclxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogR2V0VmFsdWUoY29uZmlnLCAnYXV0b1Jlc2l6ZScsIGZhbHNlKSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IEdldFZhbHVlKGNvbmZpZywgJ3RyYW5zcGFyZW50JywgZmFsc2UpLFxyXG4gICAgICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogR2V0VmFsdWUoY29uZmlnLCAnY2xlYXJCZWZvcmVSZW5kZXInLCB0cnVlKSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBHZXRWYWx1ZShjb25maWcsICdiYWNrZ3JvdW5kQ29sb3InLCBmYWxzZSlcclxuXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgZ2FtZUNvbmZpZylcclxuICAgIHtcclxuICAgICAgICBpZiAoY29uZmlnLndpZHRoID09PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbmZpZy53aWR0aCA9IGdhbWVDb25maWcud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmhlaWdodCA9PT0gLTEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25maWcuaGVpZ2h0ID0gZ2FtZUNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2V0dGluZ3M7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDc0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgUEVORElORzogMCxcclxuICAgIElOU1RBTExFRDogMSxcclxuXHJcbiAgICBCT09UOiAwLFxyXG4gICAgSU5JVDogMSxcclxuICAgIFBSRUxPQUQ6IDIsXHJcbiAgICBDUkVBVEU6IDMsXHJcbiAgICBVUERBVEU6IDQsXHJcbiAgICBSRU5ERVI6IDUsXHJcbiAgICBTSFVURE9XTjogNlxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdGF0ZS9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW1lcmEgPSByZXF1aXJlKCcuLi8uLi9jYW1lcmEvQ2FtZXJhJyk7XHJcbnZhciBLZXlDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vY2FtZXJhL0tleUNvbnRyb2wnKTtcclxudmFyIFNtb290aGVkS2V5Q29udHJvbCA9IHJlcXVpcmUoJy4uLy4uL2NhbWVyYS9TbW9vdGhlZEtleUNvbnRyb2wnKTtcclxuXHJcbnZhciBDYW1lcmFNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5jYW1lcmFzID0gW107XHJcbiAgICB0aGlzLmNhbWVyYVBvb2wgPSBbXTtcclxuXHJcbiAgICB0aGlzLm1haW4gPSB0aGlzLmFkZCgpO1xyXG59O1xyXG5cclxuQ2FtZXJhTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmFNYW5hZ2VyO1xyXG5cclxuQ2FtZXJhTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gdGhpcy5zdGF0ZS5zeXMud2lkdGg7IH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gdGhpcy5zdGF0ZS5zeXMuaGVpZ2h0OyB9XHJcblxyXG4gICAgICAgIHZhciBjYW1lcmEgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jYW1lcmFQb29sLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYW1lcmEgPSB0aGlzLmNhbWVyYVBvb2wucG9wKCk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5zZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FtZXJhID0gbmV3IENhbWVyYSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goY2FtZXJhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbWVyYTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkS2V5Q29udHJvbDogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEtleUNvbnRyb2woY29uZmlnKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU21vb3RoZWRLZXlDb250cm9sOiBmdW5jdGlvbiAoY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgU21vb3RoZWRLZXlDb250cm9sKGNvbmZpZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFJlZmVyZW5jZTogZnVuY3Rpb24gKGNhbWVyYSlcclxuICAgIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNhbWVyYXMuaW5kZXhPZihjYW1lcmEpO1xyXG4gICAgICAgIHZhciBwb29sSW5kZXggPSB0aGlzLmNhbWVyYVBvb2wuaW5kZXhPZihjYW1lcmEpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAwICYmIHBvb2xJbmRleCA+PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goY2FtZXJhKTtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnNsaWNlKHBvb2xJbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW1lcmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjYW1lcmEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNhbWVyYUluZGV4ID0gdGhpcy5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcclxuXHJcbiAgICAgICAgaWYgKGNhbWVyYUluZGV4ID49IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYVBvb2wucHVzaCh0aGlzLmNhbWVyYXNbY2FtZXJhSW5kZXhdKTtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFzLnNwbGljZShjYW1lcmFJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNldEFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5jYW1lcmFzLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYVBvb2wucHVzaCh0aGlzLmNhbWVyYXMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tYWluID0gdGhpcy5hZGQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZXN0ZXAsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jYW1lcmFzLmxlbmd0aDsgaSA8IGw7ICsraSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhc1tpXS51cGRhdGUodGltZXN0ZXAsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKHJlbmRlcmVyLCBjaGlsZHJlbiwgaW50ZXJwb2xhdGlvbilcclxuICAgIHtcclxuICAgICAgICB2YXIgY2FtZXJhcyA9IHRoaXMuY2FtZXJhcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IGNhbWVyYXNbaV07XHJcblxyXG4gICAgICAgICAgICBjYW1lcmEucHJlUmVuZGVyKCk7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zdGF0ZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb24sIGNhbWVyYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLm1haW4gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jYW1lcmFzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhbWVyYVBvb2wubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYVBvb2xbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gW107XHJcbiAgICAgICAgdGhpcy5jYW1lcmFQb29sID0gW107XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvc3lzdGVtcy9DYW1lcmFNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5GYWN0b3J5XHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgR2FtZU9iamVjdENyZWF0b3IgPSBmdW5jdGlvbiAoc3RhdGUpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gc3RhdGUuc3lzLmNoaWxkcmVuO1xyXG5cclxuICAgIEZhY3RvcnlDb250YWluZXIubG9hZCh0aGlzLCBmYWxzZSk7XHJcbn07XHJcblxyXG5HYW1lT2JqZWN0Q3JlYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYW1lT2JqZWN0Q3JlYXRvcjtcclxuXHJcbkdhbWVPYmplY3RDcmVhdG9yLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0Q3JlYXRvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XHJcblxyXG4vKipcclxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5GYWN0b3J5XHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxyXG4qL1xyXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiAoc3RhdGUpXHJcbntcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gc3RhdGUuc3lzLmNoaWxkcmVuO1xyXG5cclxuICAgIEZhY3RvcnlDb250YWluZXIubG9hZCh0aGlzLCB0cnVlKTtcclxufTtcclxuXHJcbkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWVPYmplY3RGYWN0b3J5O1xyXG5cclxuR2FtZU9iamVjdEZhY3RvcnkucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGV4aXN0aW5nOiBmdW5jdGlvbiAoY2hpbGQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uYWRkKGNoaWxkKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdEZhY3Rvcnk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9jb25zdCcpO1xyXG52YXIgQmFzZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9CYXNlTG9hZGVyJyk7XHJcbnZhciBOdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5L051bWJlckFycmF5Jyk7XHJcblxyXG52YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUnKTtcclxudmFyIEFuaW1hdGlvbkpTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BbmltYXRpb25KU09ORmlsZScpO1xyXG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlJyk7XHJcbnZhciBYTUxGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlJyk7XHJcbnZhciBCaW5hcnlGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlJyk7XHJcbnZhciBHTFNMRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUnKTtcclxudmFyIFRleHRGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZScpO1xyXG52YXIgQXRsYXNKU09ORmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZScpO1xyXG52YXIgQml0bWFwRm9udEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpdG1hcEZvbnRGaWxlJyk7XHJcbnZhciBTcHJpdGVTaGVldCA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQnKTtcclxudmFyIFNWR0ZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1NWR0ZpbGUnKTtcclxudmFyIEhUTUxGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9IVE1MRmlsZScpO1xyXG5cclxudmFyIFBhcnNlWE1MQml0bWFwRm9udCA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250Jyk7XHJcblxyXG52YXIgTG9hZGVyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICBCYXNlTG9hZGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBGYWN0b3J5XHJcbiAgICAqIEBwcm90ZWN0ZWRcclxuICAgICovXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5fbXVsdGlsaXN0ID0ge307XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTG9hZGVyLnByb3RvdHlwZSk7XHJcbkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXI7XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmxvYWRBcnJheSA9IGZ1bmN0aW9uIChmaWxlcylcclxue1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUoZmlsZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHRoaXMubGlzdC5zaXplID4gMCk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmZpbGUgPSBmdW5jdGlvbiAoZmlsZSlcclxue1xyXG4gICAgdmFyIGVudHJ5O1xyXG5cclxuICAgIHN3aXRjaCAoZmlsZS50eXBlKVxyXG4gICAge1xyXG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICBjYXNlICd4bWwnOlxyXG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XHJcbiAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgY2FzZSAnZ2xzbCc6XHJcbiAgICAgICAgY2FzZSAnc3ZnJzpcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzW2ZpbGUudHlwZV0oZmlsZS5rZXksIGZpbGUudXJsLCBmaWxlLnhoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgJ3Nwcml0ZXNoZWV0JzpcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLnNwcml0ZXNoZWV0KGZpbGUua2V5LCBmaWxlLnVybCwgZmlsZS5jb25maWcsIGZpbGUueGhyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnYXRsYXMnOlxyXG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuYXRsYXMoZmlsZS5rZXksIGZpbGUudGV4dHVyZVVSTCwgZmlsZS5hdGxhc1VSTCwgZmlsZS50ZXh0dXJlWGhyU2V0dGluZ3MsIGZpbGUuYXRsYXNYaHJTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdiaXRtYXBGb250JzpcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmJpdG1hcEZvbnQoZmlsZS5rZXksIGZpbGUudGV4dHVyZVVSTCwgZmlsZS54bWxVUkwsIGZpbGUudGV4dHVyZVhoclNldHRpbmdzLCBmaWxlLnhtbFhoclNldHRpbmdzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgJ211bHRpYXRsYXMnOlxyXG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMubXVsdGlhdGxhcyhmaWxlLmtleSwgZmlsZS50ZXh0dXJlVVJMcywgZmlsZS5hdGxhc1VSTHMsIGZpbGUudGV4dHVyZVhoclNldHRpbmdzLCBmaWxlLmF0bGFzWGhyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5hbmltYXRpb24gPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBBbmltYXRpb25KU09ORmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IEpTT05GaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS54bWwgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBYTUxGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBCaW5hcnlGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG59O1xyXG5cclxuTG9hZGVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgVGV4dEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmdsc2wgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBHTFNMRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbi8vICBjb25maWcgY2FuIGluY2x1ZGU6IGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0LCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgbWFyZ2luLCBzcGFjaW5nXHJcbkxvYWRlci5wcm90b3R5cGUuc3ByaXRlc2hlZXQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGNvbmZpZywgeGhyU2V0dGluZ3MpXHJcbntcclxuICAgIHZhciBmaWxlID0gbmV3IFNwcml0ZVNoZWV0KGtleSwgdXJsLCBjb25maWcsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHdpZHRoLCBoZWlnaHQsIHhoclNldHRpbmdzKVxyXG57XHJcbiAgICB2YXIgZmlsZSA9IG5ldyBIVE1MRmlsZShrZXksIHVybCwgd2lkdGgsIGhlaWdodCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxyXG57XHJcbiAgICAvLyAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogJ3RleHR1cmUnIGFuZCAnZGF0YSdcclxuICAgIHZhciBmaWxlcyA9IG5ldyBBdGxhc0pTT05GaWxlKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMudGV4dHVyZSk7XHJcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMuZGF0YSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Mb2FkZXIucHJvdG90eXBlLmJpdG1hcEZvbnQgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCB4bWxVUkwsIHRleHR1cmVYaHJTZXR0aW5ncywgeG1sWGhyU2V0dGluZ3MpXHJcbntcclxuICAgIC8vICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiAndGV4dHVyZScgYW5kICdkYXRhJ1xyXG4gICAgdmFyIGZpbGVzID0gbmV3IEJpdG1hcEZvbnRGaWxlKGtleSwgdGV4dHVyZVVSTCwgeG1sVVJMLCB0aGlzLnBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgeG1sWGhyU2V0dGluZ3MpO1xyXG5cclxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy50ZXh0dXJlKTtcclxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy5kYXRhKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcclxue1xyXG4gICAgdmFyIGZpbGUgPSBuZXcgU1ZHRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcclxufTtcclxuXHJcbkxvYWRlci5wcm90b3R5cGUubXVsdGlhdGxhcyA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkxzLCBhdGxhc1VSTHMsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcclxue1xyXG4gICAgaWYgKHR5cGVvZiB0ZXh0dXJlVVJMcyA9PT0gJ251bWJlcicpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gdGV4dHVyZVVSTHM7XHJcbiAgICAgICAgdmFyIHN1ZmZpeCA9IChhdGxhc1VSTHMgPT09IHVuZGVmaW5lZCkgPyAnJyA6IGF0bGFzVVJMcztcclxuXHJcbiAgICAgICAgdGV4dHVyZVVSTHMgPSBOdW1iZXJBcnJheSgwLCB0b3RhbCwga2V5ICsgc3VmZml4LCAnLnBuZycpO1xyXG4gICAgICAgIGF0bGFzVVJMcyA9IE51bWJlckFycmF5KDAsIHRvdGFsLCBrZXkgKyBzdWZmaXgsICcuanNvbicpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0dXJlVVJMcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0ZXh0dXJlVVJMcyA9IFsgdGV4dHVyZVVSTHMgXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdGxhc1VSTHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXRsYXNVUkxzID0gWyBhdGxhc1VSTHMgXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpbGU7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbXVsdGlLZXk7XHJcblxyXG4gICAgdGhpcy5fbXVsdGlsaXN0W2tleV0gPSBbXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dHVyZVVSTHMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbXVsdGlLZXkgPSAnX01BX0lNR18nICsga2V5ICsgJ18nICsgaS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBmaWxlID0gbmV3IEltYWdlRmlsZShtdWx0aUtleSwgdGV4dHVyZVVSTHNbaV0sIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XS5wdXNoKG11bHRpS2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXRsYXNVUkxzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIG11bHRpS2V5ID0gJ19NQV9KU09OXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGZpbGUgPSBuZXcgSlNPTkZpbGUobXVsdGlLZXksIGF0bGFzVVJMc1tpXSwgdGhpcy5wYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XS5wdXNoKG11bHRpS2V5KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vICBUaGUgTG9hZGVyIGhhcyBmaW5pc2hlZFxyXG5Mb2FkZXIucHJvdG90eXBlLnByb2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnN0b3JhZ2Uuc2l6ZSA9PT0gMClcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIFRoZSBnbG9iYWwgVGV4dHVyZSBNYW5hZ2VyXHJcbiAgICB2YXIgY2FjaGUgPSB0aGlzLnN0YXRlLnN5cy5jYWNoZTtcclxuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMuc3RhdGUuc3lzLnRleHR1cmVzO1xyXG4gICAgdmFyIGFuaW1zID0gdGhpcy5zdGF0ZS5zeXMuYW5pbXM7XHJcblxyXG4gICAgLy8gIFByb2Nlc3MgbXVsdGlhdGxhcyBncm91cHMgZmlyc3RcclxuXHJcbiAgICB2YXIgZmlsZTtcclxuICAgIHZhciBmaWxlQTtcclxuICAgIHZhciBmaWxlQjtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fbXVsdGlsaXN0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5fbXVsdGlsaXN0W2tleV07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdrZXknLCBrZXlzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT09ICdqc29uJylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgRG8gd2UgaGF2ZSBldmVyeXRoaW5nIG5lZWRlZD9cclxuICAgICAgICBpZiAoaW1hZ2VzLmxlbmd0aCArIGRhdGEubGVuZ3RoID09PSBrZXlzLmxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBZdXAsIGFkZCB0aGVtIHRvIHRoZSBUZXh0dXJlIE1hbmFnZXJcclxuXHJcbiAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXS5mcmFtZXMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05IYXNoKGtleSwgaW1hZ2VzLCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgUHJvY2VzcyBhbGwgb2YgdGhlIGZpbGVzXHJcblxyXG4gICAgLy8gIEJlY2F1c2UgQW5pbWF0aW9uSlNPTiBtYXkgcmVxdWlyZSBpbWFnZXMgdG8gYmUgbG9hZGVkIGZpcnN0LCB3ZSBwcm9jZXNzIHRoZW0gbGFzdFxyXG4gICAgdmFyIGFuaW1KU09OID0gW107XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlLmVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgc3dpdGNoIChmaWxlLnR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb25KU09OJzpcclxuICAgICAgICAgICAgICAgIGFuaW1KU09OLnB1c2goZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcclxuICAgICAgICAgICAgY2FzZSAnaHRtbCc6XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRJbWFnZShmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYXRsYXNqc29uJzpcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxlQSA9IGZpbGUuZmlsZUE7XHJcbiAgICAgICAgICAgICAgICBmaWxlQiA9IGZpbGUuZmlsZUI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVBLnR5cGUgPT09ICdpbWFnZScpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXMoZmlsZUEua2V5LCBmaWxlQS5kYXRhLCBmaWxlQi5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhcyhmaWxlQi5rZXksIGZpbGVCLmRhdGEsIGZpbGVBLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdiaXRtYXBmb250JzpcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxlQSA9IGZpbGUuZmlsZUE7XHJcbiAgICAgICAgICAgICAgICBmaWxlQiA9IGZpbGUuZmlsZUI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVBLnR5cGUgPT09ICdpbWFnZScpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuYml0bWFwRm9udC5hZGQoZmlsZUIua2V5LCBQYXJzZVhNTEJpdG1hcEZvbnQoZmlsZUIuZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGVBLmtleSwgZmlsZUEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuYml0bWFwRm9udC5hZGQoZmlsZUEua2V5LCBQYXJzZVhNTEJpdG1hcEZvbnQoZmlsZUEuZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGVCLmtleSwgZmlsZUIuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3Nwcml0ZXNoZWV0JzpcclxuICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZFNwcml0ZVNoZWV0KGZpbGUua2V5LCBmaWxlLmRhdGEsIGZpbGUuY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnanNvbic6XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5qc29uLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAneG1sJzpcclxuICAgICAgICAgICAgICAgIGNhY2hlLnhtbC5hZGQoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgY2FjaGUudGV4dC5hZGQoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5iaW5hcnkuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdzb3VuZCc6XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zb3VuZC5hZGQoZmlsZS5rZXksIGZpbGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2dsc2wnOlxyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2hhZGVyLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGFuaW1KU09OLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpXHJcbiAgICB7XHJcbiAgICAgICAgYW5pbXMuZnJvbUpTT04oZmlsZS5kYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgQSBwcm94eSBjbGFzcyB0byB0aGUgR2xvYmFsIFN0YXRlIE1hbmFnZXJcclxuXHJcbnZhciBTdGF0ZU1hbmFnZXIgPSBmdW5jdGlvbiAoc3RhdGUsIGdhbWUpXHJcbntcclxuICAgIC8vICBUaGUgU3RhdGUgdGhhdCBvd25zIHRoaXMgU3RhdGVNYW5hZ2VyXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5rZXkgPSBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5O1xyXG5cclxuICAgIC8vICBHbG9iYWxTdGF0ZU1hbmFnZXJcclxuICAgIHRoaXMubWFuYWdlciA9IGdhbWUuc3RhdGU7XHJcbn07XHJcblxyXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGVNYW5hZ2VyO1xyXG5cclxuU3RhdGVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvLyAgU3RhcnQgdGhpcyBTdGF0ZSAob3IgdGhlIG9uZSBnaXZlbiB2aWEga2V5KVxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9IHRoaXMua2V5OyB9XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdGFydChrZXksIGRhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgUGF1c2UgdGhpcyBTdGF0ZSAob3IgdGhlIG9uZSBnaXZlbiB2aWEga2V5KVxyXG4gICAgcGF1c2U6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9IHRoaXMua2V5OyB9XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5wYXVzZShrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgU3RvcCB0aGlzIFN0YXRlIGFuZCBzdGFydCB0aGUgb25lIGdpdmVuXHJcbiAgICBzd2FwOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5wYXVzZSh0aGlzLmtleSk7XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdGFydChrZXkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtb3ZlVXA6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBtb3ZlRG93bjogZnVuY3Rpb24gKClcclxuICAgIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJyaW5nVG9Ub3A6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gIFRPRE9cclxuICAgIHRyYW5zaXRpb25UbzogZnVuY3Rpb24gKGtleSwgZHVyYXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKHRoaXMua2V5KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN0YXJ0KGtleSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgeyBrZXkgPSB0aGlzLmtleTsgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmlzQWN0aXZlKGtleSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvc3lzdGVtcy9TdGF0ZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBEaXJ0eSEgTWFuYWdlclxyXG4qXHJcbiogQGNsYXNzXHJcbiovXHJcbnZhciBVcGRhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlKVxyXG57XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgdGhpcy5saXN0ID0gW107XHJcblxyXG4gICAgLy8gdGhpcy5pID0gMTtcclxuXHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xyXG59O1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcGRhdGVNYW5hZ2VyO1xyXG5cclxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaSwgJ1VwZGF0ZU1hbmFnZXIuc3RvcCcsIHRoaXMucHJvY2Vzc2VkKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuaSsrO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdGFydCcsIGxlbik7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBCZWNhdXNlIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgKGFzIGEgY2hpbGQgb2YgYW5vdGhlciBUcmFuc2Zvcm0gdGhhdCB3YXMgdXBkYXRlZClcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXSAmJiB0aGlzLmxpc3RbaV0uX2RpcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGQ6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2godHJhbnNmb3JtKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZU1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3RhdGUvc3lzdGVtcy9VcGRhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIGtleXMgb2YgYSBNYXAgY2FuIGJlIGFyYml0cmFyeSB2YWx1ZXMuXHJcblxyXG4vKlxyXG52YXIgbWFwID0gbmV3IE1hcChbXHJcbiAgICBbIDEsICdvbmUnIF0sXHJcbiAgICBbIDIsICd0d28nIF0sXHJcbiAgICBbIDMsICd0aHJlZScgXVxyXG5dKTtcclxuKi9cclxuXHJcbnZhciBNYXAgPSBmdW5jdGlvbiAoZWxlbWVudHMpXHJcbntcclxuICAgIHRoaXMuZW50cmllcyA9IHt9O1xyXG5cclxuICAgIHRoaXMuc2l6ZSA9IDA7XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnNldChlbGVtZW50c1tpXVswXSwgZWxlbWVudHNbaV1bMV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbk1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXA7XHJcblxyXG5NYXAucHJvdG90eXBlID0ge1xyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRyaWVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbnRyaWVzLmhhc093blByb3BlcnR5KGtleSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbnRyaWVzW2tleV07XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZW50cmllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNbcHJvcF07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBrZXlzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmVudHJpZXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW50cmllcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVudHJpZXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuXHJcbiAgICBkdW1wOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xyXG5cclxuICAgICAgICBjb25zb2xlLmdyb3VwKCdNYXAnKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGVudHJpZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhrZXksIGVudHJpZXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGtleSwgZW50cmllc1trZXldKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YWx1ZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGVudHJpZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZW50cmllc1trZXldID09PSB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gIE1lcmdlcyBhbGwgbmV3IGtleXMgZnJvbSB0aGUgZ2l2ZW4gTWFwIGludG8gdGhpcyBvbmVcclxuICAgIC8vICBJZiBpdCBlbmNvdW50ZXJzIGEga2V5IHRoYXQgYWxyZWFkeSBleGlzdHMgaXQgd2lsbCBiZSBza2lwcGVkXHJcbiAgICAvLyAgdW5sZXNzIG92ZXJyaWRlID0gdHJ1ZVxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIChtYXAsIG92ZXJyaWRlKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJyaWRlID0gZmFsc2U7IH1cclxuXHJcbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5lbnRyaWVzO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXAuZW50cmllcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG92ZXJyaWRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHJ1Y3RzL01hcC5qc1xuLy8gbW9kdWxlIGlkID0gNzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XHJcblxyXG4vKipcclxuKiBBIEZyYW1lIGlzIGEgc2VjdGlvbiBvZiBhIFRleHR1cmUuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLkZyYW1lXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRoaXMgRnJhbWUgYmVsb25ncyB0by5cclxuKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSB1bmlxdWUgKHdpdGhpbiB0aGUgVGV4dHVyZSkgbmFtZSBvZiB0aGlzIEZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxyXG4qL1xyXG52YXIgRnJhbWUgPSBmdW5jdGlvbiAodGV4dHVyZSwgbmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdGhpcyBmcmFtZSBiZWxvbmdzIHRvLlxyXG4gICAgKi9cclxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZUluZGV4ID0gc291cmNlSW5kZXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRYIC0gWCBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQgZnJvbS5cclxuICAgICovXHJcbiAgICB0aGlzLmN1dFggPSB4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WSAtIFkgcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdXRZID0geTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dFdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxyXG4gICAgKi9cclxuICAgIHRoaXMuY3V0V2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dEhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGFyZWEgaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5jdXRIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIFggcmVuZGVyaW5nIG9mZnNldCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy54ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBUaGUgWSByZW5kZXJpbmcgb2Zmc2V0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLnkgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgcmVuZGVyaW5nIHdpZHRoIG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVuZGVyaW5nIGhlaWdodCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZW5kZXJpbmcgd2lkdGggb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIHRoaXMuY2VudGVyWCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJpbmcgaGVpZ2h0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cclxuICAgICovXHJcbiAgICB0aGlzLmNlbnRlclkgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJcyB0aGlzIGZyYW1lIGlzIHJvdGF0ZWQgb3Igbm90IGluIHRoZSBUZXh0dXJlP1xyXG4gICAgKiBSb3RhdGlvbiBhbGxvd3MgeW91IHRvIHVzZSByb3RhdGVkIGZyYW1lcyBpbiB0ZXh0dXJlIGF0bGFzIHBhY2tpbmcuXHJcbiAgICAqIEl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggU3ByaXRlIHJvdGF0aW9uLlxyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdGF0ZWRcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnJvdGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogSXMgdGhpcyBhIHRpbGluZyB0ZXh0dXJlPyBBcyB1c2VkIGJ5IHRoZSBsaWtlcyBvZiBhIFRpbGluZ1Nwcml0ZS5cclxuICAgICogVE9ETzogVHJ5IGFuZCByZW1vdmUgdGhpcywgaXQgc2hvdWxkbid0IGJlIGhlcmVcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1RpbGluZ1xyXG4gICAgKiBAZGVmYXVsdFxyXG4gICAgKi9cclxuICAgIHRoaXMuaXNUaWxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRpbnRlZCBwYXJlbnQgaGFzIHVwZGF0ZWQgaXRzIHRleHR1cmUuXHJcbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVxdWlyZXNSZVRpbnRcclxuICAgICogQGRlZmF1bHRcclxuICAgICovXHJcbiAgICB0aGlzLnJlcXVpcmVzUmVUaW50ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIE92ZXItcmlkZXMgdGhlIFJlbmRlcmVyIHNldHRpbmc/IC0xID0gdXNlIFJlbmRlcmVyIFNldHRpbmcsIDAgPSBObyByb3VuZGluZywgMSA9IFJvdW5kXHJcbiAgICB0aGlzLmF1dG9Sb3VuZCA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgdW4tbW9kaWZpZWQgc291cmNlIGZyYW1lLCB0cmltIGFuZCBVViBkYXRhLlxyXG4gICAgKlxyXG4gICAgKiBAcHJpdmF0ZVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YVxyXG4gICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IHtcclxuICAgICAgICBjdXQ6IHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgdzogd2lkdGgsXHJcbiAgICAgICAgICAgIGg6IGhlaWdodCxcclxuICAgICAgICAgICAgcjogeCArIHdpZHRoLFxyXG4gICAgICAgICAgICBiOiB5ICsgaGVpZ2h0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmltOiBmYWxzZSxcclxuICAgICAgICBzb3VyY2VTaXplOiB7XHJcbiAgICAgICAgICAgIHc6IHdpZHRoLFxyXG4gICAgICAgICAgICBoOiBoZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwcml0ZVNvdXJjZVNpemU6IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgdzogd2lkdGgsXHJcbiAgICAgICAgICAgIGg6IGhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXZzOiB7XHJcbiAgICAgICAgICAgIHgwOiAwLFxyXG4gICAgICAgICAgICB5MDogMCxcclxuICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICB4MjogMCxcclxuICAgICAgICAgICAgeTI6IDAsXHJcbiAgICAgICAgICAgIHgzOiAwLFxyXG4gICAgICAgICAgICB5MzogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmFkaXVzOiAwLjUgKiBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCksXHJcbiAgICAgICAgZHJhd0ltYWdlOiB7XHJcbiAgICAgICAgICAgIHN4OiB4LFxyXG4gICAgICAgICAgICBzeTogeSxcclxuICAgICAgICAgICAgc1dpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgc0hlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICBkV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBkSGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudXBkYXRlVVZzKCk7XHJcbn07XHJcblxyXG5GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmFtZTtcclxuXHJcbkZyYW1lLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICogSWYgdGhlIGZyYW1lIHdhcyB0cmltbWVkIHdoZW4gYWRkZWQgdG8gdGhlIFRleHR1cmUgQXRsYXMsIHRoaXMgcmVjb3JkcyB0aGUgdHJpbSBhbmQgc291cmNlIGRhdGEuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgUGhhc2VyLlRleHR1cmVGcmFtZSNzZXRUcmltXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWxXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWxIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBmcmFtZSBiZWZvcmUgYmVpbmcgdHJpbW1lZC5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RYIC0gVGhlIGRlc3RpbmF0aW9uIFggcG9zaXRpb24gb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0WSAtIFRoZSBkZXN0aW5hdGlvbiBZIHBvc2l0aW9uIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFdpZHRoIC0gVGhlIGRlc3RpbmF0aW9uIHdpZHRoIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdEhlaWdodCAtIFRoZSBkZXN0aW5hdGlvbiBoZWlnaHQgb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXHJcbiAgICAqL1xyXG4gICAgc2V0VHJpbTogZnVuY3Rpb24gKGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQsIGRlc3RYLCBkZXN0WSwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHZhciBzcyA9IGRhdGEuc3ByaXRlU291cmNlU2l6ZTtcclxuXHJcbiAgICAgICAgLy8gIFN0b3JlIGFjdHVhbCB2YWx1ZXNcclxuXHJcbiAgICAgICAgZGF0YS50cmltID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLncgPSBhY3R1YWxXaWR0aDtcclxuICAgICAgICBkYXRhLnNvdXJjZVNpemUuaCA9IGFjdHVhbEhlaWdodDtcclxuXHJcbiAgICAgICAgc3MueCA9IGRlc3RYO1xyXG4gICAgICAgIHNzLnkgPSBkZXN0WTtcclxuICAgICAgICBzcy53ID0gZGVzdFdpZHRoO1xyXG4gICAgICAgIHNzLmggPSBkZXN0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyAgQWRqdXN0IHByb3BlcnRpZXNcclxuICAgICAgICB0aGlzLnggPSBkZXN0WDtcclxuICAgICAgICB0aGlzLnkgPSBkZXN0WTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGRlc3RXaWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGRlc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyWCA9IE1hdGguZmxvb3IoZGVzdFdpZHRoIC8gMik7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJZID0gTWF0aC5mbG9vcihkZXN0SGVpZ2h0IC8gMik7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlVVZzKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgdXBkYXRlVVZzXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0dyA9IHRoaXMuc291cmNlLndpZHRoO1xyXG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcclxuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDAgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTAgPSB0aGlzLmN1dFkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngxID0gdGhpcy5jdXRYIC8gdHc7XHJcbiAgICAgICAgdXZzLnkxID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0SGVpZ2h0KSAvIHRoO1xyXG5cclxuICAgICAgICB1dnMueDIgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRXaWR0aCkgLyB0dztcclxuICAgICAgICB1dnMueTIgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRIZWlnaHQpIC8gdGg7XHJcblxyXG4gICAgICAgIHV2cy54MyA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dFdpZHRoKSAvIHR3O1xyXG4gICAgICAgIHV2cy55MyA9IHRoaXMuY3V0WSAvIHRoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc0ludmVydGVkXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVVZzSW52ZXJ0ZWQ6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ID0gdGhpcy5zb3VyY2Uud2lkdGg7XHJcbiAgICAgICAgdmFyIHRoID0gdGhpcy5zb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLmRhdGEudXZzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHV2cy54MyA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dEhlaWdodCkgLyB0dztcclxuICAgICAgICB1dnMueTMgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRXaWR0aCkgLyB0aDtcclxuXHJcbiAgICAgICAgdXZzLngyID0gdGhpcy5jdXRYIC8gdHc7ICAgICAgICBcclxuICAgICAgICB1dnMueTIgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRXaWR0aCkgLyB0aDtcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDEgPSB0aGlzLmN1dFggLyB0dztcclxuICAgICAgICB1dnMueTEgPSB0aGlzLmN1dFkgLyB0aDtcclxuICAgICAgICBcclxuICAgICAgICB1dnMueDAgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XHJcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgRnJhbWUodGhpcy50ZXh0dXJlLCB0aGlzLm5hbWUsIHRoaXMuc291cmNlSW5kZXgpO1xyXG5cclxuICAgICAgICBjbG9uZS5jdXRYID0gdGhpcy5jdXRYO1xyXG4gICAgICAgIGNsb25lLmN1dFkgPSB0aGlzLmN1dFk7XHJcbiAgICAgICAgY2xvbmUuY3V0V2lkdGggPSB0aGlzLmN1dFdpZHRoO1xyXG4gICAgICAgIGNsb25lLmN1dEhlaWdodCA9IHRoaXMuY3V0SGVpZ2h0O1xyXG5cclxuICAgICAgICBjbG9uZS54ID0gdGhpcy54O1xyXG4gICAgICAgIGNsb25lLnkgPSB0aGlzLnk7XHJcblxyXG4gICAgICAgIGNsb25lLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBjbG9uZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgY2xvbmUuY2VudGVyWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICBjbG9uZS5jZW50ZXJZID0gdGhpcy5jZW50ZXJZO1xyXG5cclxuICAgICAgICBjbG9uZS5yb3RhdGVkID0gdGhpcy5yb3RhdGVkO1xyXG5cclxuICAgICAgICBjbG9uZS5kYXRhID0gRXh0ZW5kKHRydWUsIGNsb25lLmRhdGEsIHRoaXMuZGF0YSk7XHJcblxyXG4gICAgICAgIGNsb25lLnVwZGF0ZVVWcygpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRnJhbWUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxyXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxXaWR0aFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbFdpZHRoXHJcbiAgICAqL1xyXG4gICAgcmVhbFdpZHRoOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS53O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBGcmFtZSBpbiBpdHMgdW4tdHJpbW1lZCwgdW4tcGFkZGVkIHN0YXRlLCBhcyBwcmVwYXJlZCBpbiB0aGUgYXJ0IHBhY2thZ2UsXHJcbiAgICAqIGJlZm9yZSBiZWluZyBwYWNrZWQuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjcmVhbEhlaWdodFxyXG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbEhlaWdodFxyXG4gICAgKi9cclxuICAgIHJlYWxIZWlnaHQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VTaXplLmg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFVWc1xyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3V2c1xyXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gdXZzXHJcbiAgICAqL1xyXG4gICAgdXZzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEudXZzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBGcmFtZSAoZGVyaXZlZCBmcm9tIHNxcnQodyAqIHcgKyBoICogaCkgLyAyKVxyXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JhZGl1c1xyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzXHJcbiAgICAqL1xyXG4gICAgcmFkaXVzOiB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEucmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJcyB0aGUgRnJhbWUgdHJpbW1lZD9cclxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSN0cmltbWVkXHJcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJpbW1lZFxyXG4gICAgKi9cclxuICAgIHRyaW1tZWQ6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50cmltO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYW52YXMgRHJhdyBJbWFnZSBkYXRhXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjY2FudmFzRGF0YVxyXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gY2FudmFzRGF0YVxyXG4gICAgKi9cclxuICAgIGNhbnZhc0RhdGE6IHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5kcmF3SW1hZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gNzU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBGcmFtZSA9IHJlcXVpcmUoJy4vRnJhbWUnKTtcclxudmFyIFRleHR1cmVTb3VyY2UgPSByZXF1aXJlKCcuL1RleHR1cmVTb3VyY2UnKTtcclxuXHJcbi8qKlxyXG4qIEEgVGV4dHVyZSBjb25zaXN0cyBvZiBhIHNvdXJjZSwgdXN1YWxseSBhbiBJbWFnZSBmcm9tIHRoZSBDYWNoZSwgb3IgYSBDYW52YXMsIGFuZCBhIGNvbGxlY3Rpb25cclxuKiBvZiBGcmFtZXMuIFRoZSBGcmFtZXMgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgYXJlYXMgb2YgdGhlIFRleHR1cmUuIEZvciBleGFtcGxlIGEgdGV4dHVyZSBhdGxhc1xyXG4qIG1heSBoYXZlIG1hbnkgRnJhbWVzLCBvbmUgZm9yIGVhY2ggZWxlbWVudCB3aXRoaW4gdGhlIGF0bGFzLiBXaGVyZS1hcyBhIHNpbmdsZSBpbWFnZSB3b3VsZCBoYXZlXHJcbioganVzdCBvbmUgZnJhbWUsIHRoYXQgZW5jb21wYXNzZXMgdGhlIHdob2xlIGltYWdlLlxyXG4qXHJcbiogVGV4dHVyZXMgYXJlIG1hbmFnZWQgYnkgdGhlIGdsb2JhbCBUZXh0dXJlTWFuYWdlci4gVGhpcyBpcyBhIHNpbmdsZXRvbiBjbGFzcyB0aGF0IGlzXHJcbiogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBkZWxpdmVyaW5nIFRleHR1cmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIEZyYW1lcyB0byBHYW1lIE9iamVjdHMuXHJcbipcclxuKiBTcHJpdGVzIGFuZCBvdGhlciBHYW1lIE9iamVjdHMgZ2V0IHRoZSB0ZXh0dXJlIGRhdGEgdGhleSBuZWVkIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlXHJcbiogQGNvbnN0cnVjdG9yXHJcbiogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGVcclxuKi9cclxudmFyIFRleHR1cmUgPSBmdW5jdGlvbiAobWFuYWdlciwga2V5LCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXHJcbiAgICB7XHJcbiAgICAgICAgc291cmNlID0gWyBzb3VyY2UgXTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHNvdXJjZSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxyXG4gICAgKiBVc3VhbGx5IGFuIEltYWdlLCBidXQgY2FuIGFsc28gYmUgYSBDYW52YXMuXHJcbiAgICAqXHJcbiAgICAqIEBwcm9wZXJ0eSBzb3VyY2VcclxuICAgICogQHR5cGUgYXJyYXlcclxuICAgICovXHJcbiAgICB0aGlzLnNvdXJjZSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZnJhbWVzIC0gRnJhbWVzXHJcbiAgICAqL1xyXG4gICAgdGhpcy5mcmFtZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLmZpcnN0RnJhbWUgPSAnX19CQVNFJztcclxuXHJcbiAgICB0aGlzLmZyYW1lVG90YWwgPSAwO1xyXG5cclxuICAgIC8vICBMb2FkIHRoZSBTb3VyY2VzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKG5ldyBUZXh0dXJlU291cmNlKHRoaXMsIHNvdXJjZVtpXSwgd2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlO1xyXG5cclxuVGV4dHVyZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gbmV3IEZyYW1lKHRoaXMsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZXNbbmFtZV0gPSBmcmFtZTtcclxuXHJcbiAgICAgICAgLy8gIFNldCB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIFRleHR1cmUgKG90aGVyIHRoYW4gX19CQVNFKVxyXG4gICAgICAgIC8vICBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHdlIGRvbid0IHNwYW0gdGhlIGRpc3BsYXkgd2l0aCBlbnRpcmVcclxuICAgICAgICAvLyAgYXRsYXNlcyBvZiBzcHJpdGUgc2hlZXRzLCBidXQgaW5zdGVhZCBqdXN0IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVtXHJcbiAgICAgICAgLy8gIHNob3VsZCB0aGUgZGV2IGluY29ycmVjdGx5IHNwZWNpZnkgdGhlIGZyYW1lIGluZGV4XHJcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZyYW1lVG90YWwrKztcclxuXHJcbiAgICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mcmFtZXNbbmFtZV0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAodGhpcy5mcmFtZVRvdGFsID09PSAxKSA/ICdfX0JBU0UnIDogdGhpcy5maXJzdEZyYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbbmFtZV07XHJcblxyXG4gICAgICAgIGlmICghZnJhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIFRleHR1cmUuZnJhbWUgZm91bmQgd2l0aCBuYW1lICcgKyBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1snX19CQVNFJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZyYW1lTmFtZXM6IGZ1bmN0aW9uIChpbmNsdWRlQmFzZSlcclxuICAgIHtcclxuICAgICAgICBpZiAoaW5jbHVkZUJhc2UgPT09IHVuZGVmaW5lZCkgeyBpbmNsdWRlQmFzZSA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIHZhciBvdXQgPSBPYmplY3Qua2V5cyh0aGlzLmZyYW1lcyk7XHJcblxyXG4gICAgICAgIGlmICghaW5jbHVkZUJhc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ19fQkFTRScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dC5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U291cmNlSW1hZ2U6IGZ1bmN0aW9uIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lVG90YWwgPT09IDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lID0gJ19fQkFTRSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lc1tuYW1lXTtcclxuXHJcbiAgICAgICAgaWYgKCFmcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gVGV4dHVyZS5mcmFtZSBmb3VuZCB3aXRoIG5hbWUgJyArIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzWydfX0JBU0UnXS5zb3VyY2UuaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmFtZS5zb3VyY2UuaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUZXh0dXJlSW5kZXg6IGZ1bmN0aW9uIChpbmRleClcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc291cmNlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VbaV0uZ2xUZXh0dXJlSW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuc291cmNlW2ldLmltYWdlLmN1cnJlbnRTcmMsICdpbmRleCA9ICcsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGRlc3Ryb3lcclxuICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBUT0RPXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZpbHRlcjogZnVuY3Rpb24gKGZpbHRlck1vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvdXJjZS5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlW2ldLnNldEZpbHRlcihmaWx0ZXJNb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RleHR1cmVzL1RleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDc1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XHJcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XHJcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBHZW5lcmF0ZVRleHR1cmUgPSByZXF1aXJlKCcuLi9jcmVhdGUvR2VuZXJhdGVUZXh0dXJlJyk7XHJcblxyXG4vKipcclxuKiBUZXh0dXJlcyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIFRleHR1cmVNYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcclxuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgVGV4dHVyZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgRnJhbWVzIHRvIEdhbWUgT2JqZWN0cy5cclxuKlxyXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIHRleHR1cmUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXHJcbipcclxuKiBBY2Nlc3MgaXQgdmlhIGBzdGF0ZS50ZXh0dXJlc2AuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVNYW5hZ2VyXHJcbiogQGNvbnN0cnVjdG9yXHJcbiovXHJcbnZhciBUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lKVxyXG57XHJcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xyXG5cclxuICAgIHRoaXMubGlzdCA9IHt9O1xyXG5cclxuICAgIHRoaXMuYWRkQmFzZTY0KCdfX0RFRkFVTFQnLCBnYW1lLmNvbmZpZy5kZWZhdWx0SW1hZ2UpO1xyXG4gICAgdGhpcy5hZGRCYXNlNjQoJ19fTUlTU0lORycsIGdhbWUuY29uZmlnLm1pc3NpbmdJbWFnZSk7XHJcbn07XHJcblxyXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlTWFuYWdlcjtcclxuXHJcblRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBhZGRCYXNlNjQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gX3RoaXMuY3JlYXRlKGtleSwgaW1hZ2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkSW1hZ2U6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gKGtleSwgY29uZmlnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzLCAxLCAxKTtcclxuXHJcbiAgICAgICAgY29uZmlnLmNhbnZhcyA9IGNhbnZhcztcclxuXHJcbiAgICAgICAgR2VuZXJhdGVUZXh0dXJlKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbnZhcyhrZXksIGNhbnZhcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gKGtleSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDI1NjsgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAyNTY7IH1cclxuXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRDYW52YXMoa2V5LCBjYW52YXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRDYW52YXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBQYXJzZXIuQ2FudmFzKHRleHR1cmUsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICAvLyAgSXMgaXQgYSBIYXNoIG9yIGFuIEFycmF5P1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBdGxhc0pTT05BcnJheShrZXksIHNvdXJjZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkhhc2goa2V5LCBzb3VyY2UsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNKU09OQXJyYXk6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OQXJyYXkodGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRBdGxhc0pTT05IYXNoOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYXJzZXIuSlNPTkhhc2godGV4dHVyZSwgaSwgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyc2VyLkpTT05IYXNoKHRleHR1cmUsIDAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogW2FkZFNwcml0ZVNoZWV0IGRlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IGtleSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gc291cmNlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25maWcgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5mcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5mcmFtZUhlaWdodF0gLSBUaGUgZml4ZWQgaGVpZ2h0IG9mIGVhY2ggZnJhbWUuIElmIG5vdCBzZXQgaXQgd2lsbCB1c2UgdGhlIGZyYW1lV2lkdGggYXMgdGhlIGhlaWdodC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnN0YXJ0RnJhbWU9MF0gLSBTa2lwIGEgbnVtYmVyIG9mIGZyYW1lcy4gVXNlZnVsIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNwcml0ZSBzaGVldHMgaW4gb25lIFRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5lbmRGcmFtZT0tMV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyB0byBleHRyYWN0IGZyb20gdGhlIFNwcml0ZSBTaGVldC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgbWVhbnMgXCJleHRyYWN0IGFsbCBmcmFtZXNcIi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc3BhY2luZz0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggc3BhY2luZyBiZXR3ZWVuIHRoZW0sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4gICAgICovXHJcbiAgICBhZGRTcHJpdGVTaGVldDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBjb25maWcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRleHR1cmUuc291cmNlWzBdLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlLnNvdXJjZVswXS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBjb25maWcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkU3ByaXRlU2hlZXRGcm9tQXRsYXM6IGZ1bmN0aW9uIChrZXksIGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgYXRsYXNLZXkgPSBHZXRWYWx1ZShjb25maWcsICdhdGxhcycsIG51bGwpO1xyXG4gICAgICAgIHZhciBhdGxhc0ZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAnZnJhbWUnLCBudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKCFhdGxhc0tleSB8fCAhYXRsYXNGcmFtZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdGxhcyA9IHRoaXMuZ2V0KGF0bGFzS2V5KTtcclxuICAgICAgICB2YXIgc2hlZXQgPSBhdGxhcy5nZXQoYXRsYXNGcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzaGVldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzaGVldC5zb3VyY2UuaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJmaWxlbmFtZVwiOiBcImV4cGxvc2lvblwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJmcmFtZVwiOiB7XCJ4XCI6MixcInlcIjoyLFwid1wiOjMxOSxcImhcIjozMTJ9LCA9IGN1dFgsIFksIFcsIEhcclxuICAgICAgICAgICAgLy8gICAgIFwicm90YXRlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwidHJpbW1lZFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzcHJpdGVTb3VyY2VTaXplXCI6IHtcInhcIjoxLFwieVwiOjYsXCJ3XCI6MzE5LFwiaFwiOjMxMn0sXHJcbiAgICAgICAgICAgIC8vICAgICBcInNvdXJjZVNpemVcIjoge1wid1wiOjMyMCxcImhcIjozMjB9LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwaXZvdFwiOiB7XCJ4XCI6MC41LFwieVwiOjAuNX1cclxuICAgICAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgICAgIC8vICBJZiB0cmltbWVkIHdlIG5lZWQgdG8gaGVscCB0aGUgcGFyc2VyIGFkanVzdFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNoZWV0LnRyaW1tZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldEZyb21BdGxhcyh0ZXh0dXJlLCBzaGVldCwgY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCBzaGVldC5jdXRYLCBzaGVldC5jdXRZLCBzaGVldC5jdXRXaWR0aCwgc2hlZXQuY3V0SGVpZ2h0LCBjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEF0bGFzU3RhcmxpbmdYTUw6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQXRsYXNQeXhlbDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUGFyc2VyLlB5eGVsKHRleHR1cmUsIGksIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgd2lkdGgsIGhlaWdodClcclxuICAgIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMsIGtleSwgc291cmNlLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0W2tleV0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH0sXHJcblxyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9ICdfX0RFRkFVTFQnOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFsnX19NSVNTSU5HJ107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZUZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV0uZ2V0KGZyYW1lKS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RnJhbWU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XS5nZXQoZnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSwgZnJhbWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2FtZU9iamVjdC50ZXh0dXJlID0gdGhpcy5saXN0W2tleV07XHJcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZnJhbWUgPSBnYW1lT2JqZWN0LnRleHR1cmUuZ2V0KGZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICogUGFzc2VzIGFsbCBUZXh0dXJlcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB0ZXh0dXJlIGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbdGV4dHVyZV07XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcbnZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvU2NhbGVNb2RlcycpO1xyXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IHJlcXVpcmUoJy4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvJyk7XHJcblxyXG4vKipcclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVNvdXJjZVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcclxuKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlXHJcbiovXHJcbnZhciBUZXh0dXJlU291cmNlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZSwgd2lkdGgsIGhlaWdodClcclxue1xyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcbiAgICB0aGlzLmltYWdlID0gc291cmNlO1xyXG5cclxuICAgIHRoaXMuY29tcHJlc3Npb25BbGdvcml0aG0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgUmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHJlc29sdXRpb25cclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqL1xyXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHdpZHRoXHJcbiAgICAqIEB0eXBlIE51bWJlclxyXG4gICAgKiBAcmVhZE9ubHlcclxuICAgICovXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgc291cmNlLm5hdHVyYWxXaWR0aCB8fCBzb3VyY2Uud2lkdGggfHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IGhlaWdodFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICogQHJlYWRPbmx5XHJcbiAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgc291cmNlLm5hdHVyYWxIZWlnaHQgfHwgc291cmNlLmhlaWdodCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlLlxyXG4gICAgKiBORUFSRVNUIG9yIERFRkFVTFRcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHNjYWxlTW9kZVxyXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgKiBAZGVmYXVsdCBQaGFzZXIuc2NhbGVNb2Rlcy5ERUZBVUxUO1xyXG4gICAgKi9cclxuICAgIHRoaXMuc2NhbGVNb2RlID0gU2NhbGVNb2Rlcy5ERUZBVUxUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDb250cm9scyBpZiBSR0IgY2hhbm5lbHMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIGJ5IEFscGhhICAoV2ViR0wgb25seSlcclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHByZW11bHRpcGxpZWRBbHBoYVxyXG4gICAgKiBAdHlwZSBCb29sZWFuXHJcbiAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICovXHJcbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcclxuICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xyXG4gICAgKlxyXG4gICAgKiBAcHJvcGVydHkgbWlwbWFwTGV2ZWxcclxuICAgICogQHR5cGUge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5taXBtYXBMZXZlbCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgQmFzZVRleHR1cmUgY2FuIGJlIHNldCB0byBza2lwIHRoZSByZW5kZXJpbmcgcGhhc2UgaW4gdGhlIFdlYkdMIFNwcml0ZSBCYXRjaC5cclxuICAgICpcclxuICAgICogWW91IG1heSB3YW50IHRvIGRvIHRoaXMgaWYgeW91IGhhdmUgYSBwYXJlbnQgU3ByaXRlIHdpdGggbm8gdmlzaWJsZSB0ZXh0dXJlIChpLmUuIHVzZXMgdGhlIGludGVybmFsIGBfX2RlZmF1bHRgIHRleHR1cmUpXHJcbiAgICAqIHRoYXQgaGFzIGNoaWxkcmVuIHRoYXQgeW91IGRvIHdhbnQgdG8gcmVuZGVyLCB3aXRob3V0IGNhdXNpbmcgYSBiYXRjaCBmbHVzaCBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICpcclxuICAgICogQHByb3BlcnR5IHJlbmRlcmFibGVcclxuICAgICogQHR5cGUgQm9vbGVhblxyXG4gICAgKi9cclxuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSBpc1Bvd2VyT2YyXHJcbiAgICAqIEB0eXBlIGJvb2xlYW5cclxuICAgICovXHJcbiAgICB0aGlzLmlzUG93ZXJPZjIgPSBJc1NpemVQb3dlck9mVHdvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAvKipcclxuICAgICogQHByb3BlcnR5IGdsVGV4dHVyZVxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xUZXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIG11bHRpIHRleHR1cmUgYmF0Y2hpbmcgaW5kZXggbnVtYmVyLlxyXG4gICAgKiBAcHJvcGVydHkgZ2xUZXh0dXJlSW5kZXhcclxuICAgICogQHR5cGUgTnVtYmVyXHJcbiAgICAqL1xyXG4gICAgdGhpcy5nbFRleHR1cmVJbmRleCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGlzIHRleHR1cmUgd2FzIGxhc3QgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXIuXHJcbiAgICAqIENhbiBiZSB1c2VkIHRvIHB1cmdlIG91dCAnZGVhZCcgdGV4dHVyZXMgZnJvbSBHUFUgbWVtb3J5LlxyXG4gICAgKiBAcHJvcGVydHkgZ2xMYXN0VXNlZFxyXG4gICAgKiBAdHlwZSBOdW1iZXJcclxuICAgICovXHJcbiAgICB0aGlzLmdsTGFzdFVzZWQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcHJvcGVydHkgZ2xEaXJ0eVxyXG4gICAgKi9cclxuICAgIHRoaXMuZ2xEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgdmFyIGdhbWUgPSB0ZXh0dXJlLm1hbmFnZXIuZ2FtZTtcclxuXHJcbiAgICBpZiAoZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXHJcbiAgICB7XHJcbiAgICAgICAgZ2FtZS5yZW5kZXJlci5jcmVhdGVUZXh0dXJlKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChnYW1lLmNvbmZpZy5waXhlbEFydClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNldEZpbHRlcigxKTtcclxuICAgIH1cclxufTtcclxuXHJcblRleHR1cmVTb3VyY2UucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJNb2RlKVxyXG57XHJcbiAgICB2YXIgZ2FtZSA9IHRoaXMudGV4dHVyZS5tYW5hZ2VyLmdhbWU7XHJcblxyXG4gICAgaWYgKGdhbWUuY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxyXG4gICAge1xyXG4gICAgICAgIGdhbWUucmVuZGVyZXIuc2V0VGV4dHVyZUZpbHRlck1vZGUodGhpcy5nbFRleHR1cmUsIGZpbHRlck1vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlU291cmNlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxyXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XHJcbiovXHJcblxyXG4vKipcclxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5JbWFnZVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIENhbnZhcyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcclxue1xyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuXHJcbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL0NhbnZhcy5qc1xuLy8gbW9kdWxlIGlkID0gNzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XHJcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cclxuKi9cclxuXHJcbi8qKlxyXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXHJcbiogQHN0YXRpY1xyXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXHJcbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgpXHJcbntcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgSlNPTiBBcnJheSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cclxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBBcnJheSBmb3JtYXQuXHJcbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXHJcbiovXHJcbnZhciBKU09OQXJyYXkgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gQXJyYXkgZ2l2ZW4sIG1pc3NpbmcgXFwnZnJhbWVzXFwnIGFycmF5Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgYXJyYXlcclxuICAgIHZhciBmcmFtZXMgPSBqc29uWydmcmFtZXMnXTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2ldO1xyXG5cclxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXHJcbiAgICAgICAgbmV3RnJhbWUgPSB0ZXh0dXJlLmFkZChzcmMuZmlsZW5hbWUsIHNvdXJjZUluZGV4LCBzcmMuZnJhbWUueCwgc3JjLmZyYW1lLnksIHNyYy5mcmFtZS53LCBzcmMuZnJhbWUuaCk7XHJcblxyXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xyXG4gICAgICAgIGlmIChzcmMudHJpbW1lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUuaCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS55LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUudyxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzcmMucm90YXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXdGcmFtZS51cGRhdGVVVnNJbnZlcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNPTkFycmF5O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RleHR1cmVzL3BhcnNlcnMvSlNPTkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgSlNPTiBBcnJheSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cclxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBKU09OIEhhc2ggZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgSlNPTkhhc2ggPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXHJcbntcclxuICAgIC8vICBNYWxmb3JtZWQ/XHJcbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxyXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcclxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyAgQnkgdGhpcyBzdGFnZSBmcmFtZXMgaXMgYSBmdWxseSBwYXJzZWQgT2JqZWN0XHJcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcclxuICAgIHtcclxuICAgICAgICB2YXIgc3JjID0gZnJhbWVzW2tleV07XHJcblxyXG4gICAgICAgIC8vICBUaGUgZnJhbWUgdmFsdWVzIGFyZSB0aGUgZXhhY3QgY29vcmRpbmF0ZXMgdG8gY3V0IHRoZSBmcmFtZSBvdXQgb2YgdGhlIGF0bGFzIGZyb21cclxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKGtleSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcclxuXHJcbiAgICAgICAgLy8gIFRoZXNlIGFyZSB0aGUgb3JpZ2luYWwgKG5vbi10cmltbWVkKSBzcHJpdGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShcclxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXHJcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueCxcclxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXHJcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxyXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUuaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmV3RnJhbWUucm90YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKU09OSGFzaDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05IYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIGEgUHl4ZWwgSlNPTiBGaWxlIGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIFB5eGVsIEpTT04gZm9ybWF0LlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgUHl4ZWwgPSBmdW5jdGlvbiAodGV4dHVyZSwganNvbilcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD8gVGhlcmUgYXJlIGEgZmV3IGtleXMgdG8gY2hlY2sgaGVyZS5cclxuICAgIHZhciBzaWduYXR1cmUgPSBbICdsYXllcnMnLCAndGlsZXdpZHRoJywgJ3RpbGVoZWlnaHQnLCAndGlsZXN3aWRlJywgJ3RpbGVzaGlnaCcgXTtcclxuXHJcbiAgICBzaWduYXR1cmUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxyXG4gICAge1xyXG4gICAgICAgIGlmICghanNvbltrZXldKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCdQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLkpTT05EYXRhUHl4ZWw6IEludmFsaWQgUHl4ZWwgVGlsZW1hcCBKU09OIGdpdmVuLCBtaXNzaW5nIFwiJyArIGtleSArICdcIiBrZXkuJyk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb24pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRm9yIHRoaXMgcHVycG9zZSwgSSBvbmx5IGNhcmUgYWJvdXQgcGFyc2luZyB0aWxlbWFwcyB3aXRoIGEgc2luZ2xlIGxheWVyLlxyXG4gICAgaWYgKGpzb25bJ2xheWVycyddLmxlbmd0aCAhPT0gMSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ1BoYXNlci5BbmltYXRpb25QYXJzZXIuSlNPTkRhdGFQeXhlbDogVG9vIG1hbnkgbGF5ZXJzLCB0aGlzIHBhcnNlciBvbmx5IHN1cHBvcnRzIGZsYXQgVGlsZW1hcHMuJyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coanNvbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRhID0gbmV3IFBoYXNlci5GcmFtZURhdGEoKTtcclxuXHJcbiAgICB2YXIgdGlsZWhlaWdodCA9IGpzb25bJ3RpbGVoZWlnaHQnXTtcclxuICAgIHZhciB0aWxld2lkdGggPSBqc29uWyd0aWxld2lkdGgnXTtcclxuXHJcbiAgICB2YXIgZnJhbWVzID0ganNvblsnbGF5ZXJzJ11bMF1bJ3RpbGVzJ107XHJcbiAgICB2YXIgbmV3RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgbmV3RnJhbWUgPSBkYXRhLmFkZEZyYW1lKG5ldyBQaGFzZXIuRnJhbWUoXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGZyYW1lc1tpXS54LFxyXG4gICAgICAgICAgICBmcmFtZXNbaV0ueSxcclxuICAgICAgICAgICAgdGlsZXdpZHRoLFxyXG4gICAgICAgICAgICB0aWxlaGVpZ2h0LFxyXG4gICAgICAgICAgICBcImZyYW1lX1wiICsgaSAgLy8gTm8gbmFtZXMgYXJlIGluY2x1ZGVkIGluIHB5eGVsIHRpbGVtYXAgZGF0YS5cclxuICAgICAgICApKTtcclxuXHJcbiAgICAgICAgLy8gTm8gdHJpbSBkYXRhIGlzIGluY2x1ZGVkLlxyXG4gICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQeXhlbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vKipcclxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TcHJpdGVTaGVldFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cclxuKiBAcGFyYW0ge251bWJlcn0gZnJhbWVXaWR0aCAtIFRoZSBmaXhlZCB3aWR0aCBvZiBlYWNoIGZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZUhlaWdodCAtIFRoZSBmaXhlZCBoZWlnaHQgb2YgZWFjaCBmcmFtZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0RnJhbWU9MF0gLSBTa2lwIGEgbnVtYmVyIG9mIGZyYW1lcy4gVXNlZnVsIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNwcml0ZSBzaGVldHMgaW4gb25lIFRleHR1cmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtlbmRGcmFtZT0tMV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyB0byBleHRyYWN0IGZyb20gdGhlIFNwcml0ZSBTaGVldC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgbWVhbnMgXCJleHRyYWN0IGFsbCBmcmFtZXNcIi5cclxuKiBAcGFyYW0ge251bWJlcn0gW21hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3BhY2luZz0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggc3BhY2luZyBiZXR3ZWVuIHRoZW0sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIGZyYW1lV2lkdGggPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZVdpZHRoJywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWVIZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZUhlaWdodCcsIGZyYW1lV2lkdGgpO1xyXG5cclxuICAgIC8vICBJZiBtaXNzaW5nIHdlIGNhbid0IHByb2NlZWRcclxuICAgIGlmIChmcmFtZVdpZHRoID09PSBudWxsKVxyXG4gICAge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZU1hbmFnZXIuU3ByaXRlU2hlZXQ6IEludmFsaWQgZnJhbWVXaWR0aCBnaXZlbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcclxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XHJcblxyXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG5cclxuICAgIHZhciBzdGFydEZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAnc3RhcnRGcmFtZScsIDApO1xyXG4gICAgdmFyIGVuZEZyYW1lID0gR2V0VmFsdWUoY29uZmlnLCAnZW5kRnJhbWUnLCAtMSk7XHJcbiAgICB2YXIgbWFyZ2luID0gR2V0VmFsdWUoY29uZmlnLCAnbWFyZ2luJywgMCk7XHJcbiAgICB2YXIgc3BhY2luZyA9IEdldFZhbHVlKGNvbmZpZywgJ3NwYWNpbmcnLCAwKTtcclxuXHJcbiAgICB2YXIgcm93ID0gTWF0aC5mbG9vcigod2lkdGggLSBtYXJnaW4pIC8gKGZyYW1lV2lkdGggKyBzcGFjaW5nKSk7XHJcbiAgICB2YXIgY29sdW1uID0gTWF0aC5mbG9vcigoaGVpZ2h0IC0gbWFyZ2luKSAvIChmcmFtZUhlaWdodCArIHNwYWNpbmcpKTtcclxuICAgIHZhciB0b3RhbCA9IHJvdyAqIGNvbHVtbjtcclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA+IHRvdGFsIHx8IHN0YXJ0RnJhbWUgPCAtdG90YWwpXHJcbiAgICB7XHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXJ0RnJhbWUgPCAwKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBBbGxvdyBuZWdhdGl2ZSBza2lwZnJhbWVzLlxyXG4gICAgICAgIHN0YXJ0RnJhbWUgPSB0b3RhbCArIHN0YXJ0RnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVuZEZyYW1lICE9PSAtMSlcclxuICAgIHtcclxuICAgICAgICB0b3RhbCA9IHN0YXJ0RnJhbWUgKyAoZW5kRnJhbWUgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZnggPSBtYXJnaW47XHJcbiAgICB2YXIgZnkgPSBtYXJnaW47XHJcbiAgICB2YXIgYXggPSAwO1xyXG4gICAgdmFyIGF5ID0gMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgYXggPSAwO1xyXG4gICAgICAgIGF5ID0gMDtcclxuXHJcbiAgICAgICAgdmFyIHcgPSBmeCArIGZyYW1lV2lkdGg7XHJcbiAgICAgICAgdmFyIGggPSBmeSArIGZyYW1lSGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAodyA+IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXggPSB3IC0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaCA+IGhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF5ID0gaCAtIGhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRleHR1cmUuYWRkKGksIHNvdXJjZUluZGV4LCB4ICsgZngsIHkgKyBmeSwgZnJhbWVXaWR0aCAtIGF4LCBmcmFtZUhlaWdodCAtIGF5KTtcclxuXHJcbiAgICAgICAgZnggKz0gZnJhbWVXaWR0aCArIHNwYWNpbmc7XHJcblxyXG4gICAgICAgIGlmIChmeCArIGZyYW1lV2lkdGggPiB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZ4ID0gbWFyZ2luO1xyXG4gICAgICAgICAgICBmeSArPSBmcmFtZUhlaWdodCArIHNwYWNpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVTaGVldDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxudmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcblxyXG4vKipcclxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TcHJpdGVTaGVldFxyXG4qIEBzdGF0aWNcclxuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cclxuKiBAcGFyYW0ge251bWJlcn0gZnJhbWVXaWR0aCAtIFRoZSBmaXhlZCB3aWR0aCBvZiBlYWNoIGZyYW1lLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZUhlaWdodCAtIFRoZSBmaXhlZCBoZWlnaHQgb2YgZWFjaCBmcmFtZS5cclxuKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0RnJhbWU9MF0gLSBTa2lwIGEgbnVtYmVyIG9mIGZyYW1lcy4gVXNlZnVsIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNwcml0ZSBzaGVldHMgaW4gb25lIFRleHR1cmUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtlbmRGcmFtZT0tMV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyB0byBleHRyYWN0IGZyb20gdGhlIFNwcml0ZSBTaGVldC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgbWVhbnMgXCJleHRyYWN0IGFsbCBmcmFtZXNcIi5cclxuKiBAcGFyYW0ge251bWJlcn0gW21hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3BhY2luZz0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggc3BhY2luZyBiZXR3ZWVuIHRoZW0sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxyXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxyXG4qL1xyXG52YXIgU3ByaXRlU2hlZXRGcm9tQXRsYXMgPSBmdW5jdGlvbiAodGV4dHVyZSwgZnJhbWUsIGNvbmZpZylcclxue1xyXG4gICAgdmFyIGZyYW1lV2lkdGggPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZVdpZHRoJywgbnVsbCk7XHJcbiAgICB2YXIgZnJhbWVIZWlnaHQgPSBHZXRWYWx1ZShjb25maWcsICdmcmFtZUhlaWdodCcsIGZyYW1lV2lkdGgpO1xyXG5cclxuICAgIC8vICBJZiBtaXNzaW5nIHdlIGNhbid0IHByb2NlZWRcclxuICAgIGlmICghZnJhbWVXaWR0aClcclxuICAgIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVNYW5hZ2VyLlNwcml0ZVNoZWV0RnJvbUF0bGFzOiBJbnZhbGlkIGZyYW1lV2lkdGggZ2l2ZW4uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXHJcbiAgICAvLyB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2VbMF07XHJcbiAgICAvLyB0ZXh0dXJlLmFkZCgnX19CQVNFJywgMCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuXHJcbiAgICB2YXIgc3RhcnRGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ3N0YXJ0RnJhbWUnLCAwKTtcclxuICAgIHZhciBlbmRGcmFtZSA9IEdldFZhbHVlKGNvbmZpZywgJ2VuZEZyYW1lJywgLTEpO1xyXG4gICAgdmFyIG1hcmdpbiA9IEdldFZhbHVlKGNvbmZpZywgJ21hcmdpbicsIDApO1xyXG4gICAgdmFyIHNwYWNpbmcgPSBHZXRWYWx1ZShjb25maWcsICdzcGFjaW5nJywgMCk7XHJcblxyXG4gICAgdmFyIHggPSBmcmFtZS5jdXRYO1xyXG4gICAgdmFyIHkgPSBmcmFtZS5jdXRZO1xyXG4gICAgdmFyIGN1dFdpZHRoID0gZnJhbWUuY3V0V2lkdGg7XHJcbiAgICB2YXIgY3V0SGVpZ2h0ID0gZnJhbWUuY3V0SGVpZ2h0O1xyXG4gICAgdmFyIHNoZWV0V2lkdGggPSBmcmFtZS5yZWFsV2lkdGg7XHJcbiAgICB2YXIgc2hlZXRIZWlnaHQgPSBmcmFtZS5yZWFsSGVpZ2h0O1xyXG5cclxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKChzaGVldFdpZHRoIC0gbWFyZ2luKSAvIChmcmFtZVdpZHRoICsgc3BhY2luZykpO1xyXG4gICAgdmFyIGNvbHVtbiA9IE1hdGguZmxvb3IoKHNoZWV0SGVpZ2h0IC0gbWFyZ2luKSAvIChmcmFtZUhlaWdodCArIHNwYWNpbmcpKTtcclxuICAgIHZhciB0b3RhbCA9IHJvdyAqIGNvbHVtbjtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnc3BsaXQgc2hlZXQgaW50byByb3dzL2NvbHM6Jywgcm93LCBjb2x1bW4sICd0b3RhbCBmcmFtZXM6JywgdG90YWwpO1xyXG5cclxuICAgIGlmIChzdGFydEZyYW1lID4gdG90YWwgfHwgc3RhcnRGcmFtZSA8IC10b3RhbClcclxuICAgIHtcclxuICAgICAgICBzdGFydEZyYW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEFsbG93IG5lZ2F0aXZlIHNraXBmcmFtZXMuXHJcbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxyXG4gICAge1xyXG4gICAgICAgIHRvdGFsID0gc3RhcnRGcmFtZSArIChlbmRGcmFtZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmeCA9IG1hcmdpbjtcclxuICAgIHZhciBmeSA9IG1hcmdpbjtcclxuICAgIHZhciBheCA9IDA7XHJcbiAgICB2YXIgYXkgPSAwO1xyXG4gICAgdmFyIHNoZWV0RnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGF4ID0gMDtcclxuICAgICAgICBheSA9IDA7XHJcblxyXG4gICAgICAgIHZhciB3ID0gZnggKyBmcmFtZVdpZHRoO1xyXG4gICAgICAgIHZhciBoID0gZnkgKyBmcmFtZUhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHcgPiB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4ID0gdyAtIHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGggPiBoZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheSA9IGggLSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzaGVldEZyYW1lID0gdGV4dHVyZS5hZGQoaSwgc291cmNlSW5kZXgsIHggKyBmeCwgeSArIGZ5LCBmcmFtZVdpZHRoIC0gYXgsIGZyYW1lSGVpZ2h0IC0gYXkpO1xyXG5cclxuICAgICAgICAvLyBzaGVldEZyYW1lLnNldFRyaW0oc2hlZXRXaWR0aCwgc2hlZXRIZWlnaHQsIClcclxuXHJcbiAgICAgICAgLy8gc2V0VHJpbTogZnVuY3Rpb24gKGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQsIGRlc3RYLCBkZXN0WSwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KVxyXG5cclxuXHJcbiAgICAgICAgZnggKz0gZnJhbWVXaWR0aCArIHNwYWNpbmc7XHJcblxyXG4gICAgICAgIGlmIChmeCArIGZyYW1lV2lkdGggPiB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZ4ID0gbWFyZ2luO1xyXG4gICAgICAgICAgICBmeSArPSBmcmFtZUhlaWdodCArIHNwYWNpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVTaGVldEZyb21BdGxhcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0RnJvbUF0bGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA3Njdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cclxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cclxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogUGFyc2VzIHRoZSBYTUwgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuU3RhcmxpbmdYTUxcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cclxuKiBAcGFyYW0ge29iamVjdH0geG1sIC0gVGhlIFhNTCBkYXRhIGZyb20gdGhlIFRleHR1cmUgQXRsYXMuIE11c3QgYmUgaW4gU3RhcmxpbmcgWE1MIGZvcm1hdC5cclxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cclxuKi9cclxudmFyIFN0YXJsaW5nWE1MID0gZnVuY3Rpb24gKHRleHR1cmUsIHhtbClcclxue1xyXG4gICAgLy8gIE1hbGZvcm1lZD9cclxuICAgIGlmICgheG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUZXh0dXJlQXRsYXMnKSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLlhNTERhdGE6IEludmFsaWQgVGV4dHVyZSBBdGxhcyBYTUwgZ2l2ZW4sIG1pc3NpbmcgPFRleHR1cmVBdGxhcz4gdGFnXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgTGV0J3MgY3JlYXRlIHNvbWUgZnJhbWVzIHRoZW5cclxuICAgIHZhciBkYXRhID0gbmV3IFBoYXNlci5GcmFtZURhdGEoKTtcclxuICAgIHZhciBmcmFtZXMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1N1YlRleHR1cmUnKTtcclxuICAgIHZhciBuZXdGcmFtZTtcclxuXHJcbiAgICB2YXIgbmFtZTtcclxuICAgIHZhciBmcmFtZTtcclxuICAgIHZhciB4O1xyXG4gICAgdmFyIHk7XHJcbiAgICB2YXIgd2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0O1xyXG4gICAgdmFyIGZyYW1lWDtcclxuICAgIHZhciBmcmFtZVk7XHJcbiAgICB2YXIgZnJhbWVXaWR0aDtcclxuICAgIHZhciBmcmFtZUhlaWdodDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICBuYW1lID0gZnJhbWUubmFtZS52YWx1ZTtcclxuICAgICAgICB4ID0gcGFyc2VJbnQoZnJhbWUueC52YWx1ZSwgMTApO1xyXG4gICAgICAgIHkgPSBwYXJzZUludChmcmFtZS55LnZhbHVlLCAxMCk7XHJcbiAgICAgICAgd2lkdGggPSBwYXJzZUludChmcmFtZS53aWR0aC52YWx1ZSwgMTApO1xyXG4gICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmhlaWdodC52YWx1ZSwgMTApO1xyXG5cclxuICAgICAgICBmcmFtZVggPSBudWxsO1xyXG4gICAgICAgIGZyYW1lWSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChmcmFtZS5mcmFtZVgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmcmFtZVggPSBNYXRoLmFicyhwYXJzZUludChmcmFtZS5mcmFtZVgudmFsdWUsIDEwKSk7XHJcbiAgICAgICAgICAgIGZyYW1lWSA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWS52YWx1ZSwgMTApKTtcclxuICAgICAgICAgICAgZnJhbWVXaWR0aCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lV2lkdGgudmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgZnJhbWVIZWlnaHQgPSBwYXJzZUludChmcmFtZS5mcmFtZUhlaWdodC52YWx1ZSwgMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV3RnJhbWUgPSBkYXRhLmFkZEZyYW1lKG5ldyBQaGFzZXIuRnJhbWUoaSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbmFtZSkpO1xyXG5cclxuICAgICAgICAvLyAgVHJpbW1lZD9cclxuICAgICAgICBpZiAoZnJhbWVYICE9PSBudWxsIHx8IGZyYW1lWSAhPT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0odHJ1ZSwgd2lkdGgsIGhlaWdodCwgZnJhbWVYLCBmcmFtZVksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdGFybGluZ1hNTDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXh0dXJlcy9wYXJzZXJzL1N0YXJsaW5nWE1MLmpzXG4vLyBtb2R1bGUgaWQgPSA3Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ2FudmFzOiByZXF1aXJlKCcuL0NhbnZhcycpLFxyXG4gICAgSW1hZ2U6IHJlcXVpcmUoJy4vSW1hZ2UnKSxcclxuICAgIEpTT05BcnJheTogcmVxdWlyZSgnLi9KU09OQXJyYXknKSxcclxuICAgIEpTT05IYXNoOiByZXF1aXJlKCcuL0pTT05IYXNoJyksXHJcbiAgICBQeXhlbDogcmVxdWlyZSgnLi9QeXhlbCcpLFxyXG4gICAgU3ByaXRlU2hlZXQ6IHJlcXVpcmUoJy4vU3ByaXRlU2hlZXQnKSxcclxuICAgIFNwcml0ZVNoZWV0RnJvbUF0bGFzOiByZXF1aXJlKCcuL1Nwcml0ZVNoZWV0RnJvbUF0bGFzJyksXHJcbiAgICBTdGFybGluZ1hNTDogcmVxdWlyZSgnLi9TdGFybGluZ1hNTCcpXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFYXNlTWFwID0gcmVxdWlyZSgnLi4vbWF0aC9lYXNpbmcvRWFzZU1hcCcpO1xyXG5cclxudmFyIEdldEVhc2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChlYXNlLCBlYXNlUGFyYW1zKVxyXG57XHJcbiAgICBpZiAodHlwZW9mIGVhc2UgPT09ICdzdHJpbmcnICYmIEVhc2VNYXAuaGFzT3duUHJvcGVydHkoZWFzZSkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGVhc2VQYXJhbXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVQYXJhbXMgPSBlYXNlUGFyYW1zLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAgICAgY2xvbmVQYXJhbXMudW5zaGlmdCgwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVQYXJhbXNbMF0gPSB2O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBFYXNlTWFwW2Vhc2VdLmFwcGx5KHRoaXMsIGNsb25lUGFyYW1zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gIFN0cmluZyBiYXNlZCBsb29rLXVwXHJcbiAgICAgICAgICAgIHJldHVybiBFYXNlTWFwW2Vhc2VdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlYXNlID09PSAnZnVuY3Rpb24nKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBDdXN0b20gZnVuY3Rpb25cclxuICAgICAgICByZXR1cm4gZWFzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgZWFzZS5sZW5ndGggPT09IDQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIEJlemllciBmdW5jdGlvbiAoVE9ETylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRWFzZU1hcC5Qb3dlcjA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldEVhc2VGdW5jdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9HZXRFYXNlRnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDc3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUkVTRVJWRUQgcHJvcGVydGllcyB0aGF0IGEgVHdlZW4gY29uZmlnIG9iamVjdCB1c2VzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAgICdjb21wbGV0ZURlbGF5JyxcclxuICAgICdkZWxheScsXHJcbiAgICAnZHVyYXRpb24nLFxyXG4gICAgJ2Vhc2UnLFxyXG4gICAgJ2Vhc2VQYXJhbXMnLFxyXG4gICAgJ2hvbGQnLFxyXG4gICAgJ2xvb3AnLFxyXG4gICAgJ2xvb3BEZWxheScsXHJcbiAgICAnb2Zmc2V0JyxcclxuICAgICdwYXVzZWQnLFxyXG4gICAgJ3Byb3BzJyxcclxuICAgICdyZXBlYXQnLFxyXG4gICAgJ3JlcGVhdERlbGF5JyxcclxuICAgICdzdGFydEF0JyxcclxuICAgICd0YXJnZXRzJyxcclxuICAgICd1c2VGcmFtZXMnLFxyXG4gICAgJ3lveW8nXHJcbl07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vUmVzZXJ2ZWRQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gNzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcclxuXHJcbnZhciBUd2VlbiA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBkYXRhKVxyXG57XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cclxuICAgIC8vICBBbiBhcnJheSBvZiBUd2VlbkRhdGEgb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGEgdW5pcXVlIHByb3BlcnR5IGFuZCB0YXJnZXQgYmVpbmcgdHdlZW5lZC5cclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgLy8gIGRhdGEgYXJyYXkgZG9lc24ndCBjaGFuZ2UsIHNvIHdlIGNhbiBjYWNoZSB0aGUgbGVuZ3RoXHJcbiAgICB0aGlzLnRvdGFsRGF0YSA9IGRhdGEubGVuZ3RoO1xyXG5cclxuICAgIC8vICBDYWNoZWQgdGFyZ2V0IHRvdGFsIChub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgYXMgdGhlIGRhdGEgdG90YWwpXHJcbiAgICB0aGlzLnRvdGFsVGFyZ2V0cyA9IDA7XHJcblxyXG4gICAgLy8gIElmIHRydWUgdGhlbiBkdXJhdGlvbiwgZGVsYXksIGV0YyB2YWx1ZXMgYXJlIGFsbCBmcmFtZSB0b3RhbHNcclxuICAgIHRoaXMudXNlRnJhbWVzID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIExvb3AgdGhpcyB0d2Vlbj8gQ2FuIGJlIC0xIGZvciBhbiBpbmZpbml0ZSBsb29wLCBvciBhbiBpbnRlZ2VyLlxyXG4gICAgLy8gIFdoZW4gZW5hYmxlZCBpdCB3aWxsIHBsYXkgdGhyb3VnaCBBTEwgVHdlZW5EYXRhcyBhZ2FpbiAodXNlIFR3ZWVuRGF0YS5yZXBlYXQgdG8gbG9vcCBhIHNpbmdsZSBURClcclxuICAgIHRoaXMubG9vcCA9IDA7XHJcblxyXG4gICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGJlZm9yZSB0aGUgdHdlZW4gbG9vcHMuXHJcbiAgICB0aGlzLmxvb3BEZWxheSA9IDA7XHJcblxyXG4gICAgLy8gIEhvdyBtYW55IGxvb3BzIGFyZSBsZWZ0IHRvIHJ1bj9cclxuICAgIHRoaXMubG9vcENvdW50ZXIgPSAwO1xyXG5cclxuICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBiZWZvcmUgdGhlICdvbkNvbXBsZXRlJyBldmVudCBmaXJlcy4gVGhpcyBuZXZlciBmaXJlcyBpZiBsb29wID0gdHJ1ZSAoYXMgaXQgbmV2ZXIgY29tcGxldGVzKVxyXG4gICAgdGhpcy5jb21wbGV0ZURlbGF5ID0gMDtcclxuXHJcbiAgICAvLyAgQ291bnRkb3duIHRpbWVyICh1c2VkIGJ5IGxvb3BEZWxheSBhbmQgY29tcGxldGVEZWxheSlcclxuICAgIHRoaXMuY291bnRkb3duID0gMDtcclxuXHJcbiAgICAvLyAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHR3ZWVuXHJcbiAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19BREQ7XHJcblxyXG4gICAgLy8gIFRoZSBzdGF0ZSBvZiB0aGUgdHdlZW4gd2hlbiBpdCB3YXMgcGF1c2VkICh1c2VkIGJ5IFJlc3VtZSlcclxuICAgIHRoaXMuX3BhdXNlZFN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19BREQ7XHJcblxyXG4gICAgLy8gIERvZXMgdGhlIFR3ZWVuIHN0YXJ0IG9mZiBwYXVzZWQ/IChpZiBzbyBpdCBuZWVkcyB0byBiZSBzdGFydGVkIHdpdGggVHdlZW4ucGxheSlcclxuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gIEVsYXBzZWQgdGltZSBpbiBtcy9mcmFtZXMgb2YgdGhpcyBydW4gdGhyb3VnaCB0aGUgVHdlZW4uXHJcbiAgICB0aGlzLmVsYXBzZWQgPSAwO1xyXG5cclxuICAgIC8vICBUb3RhbCBlbGFwc2VkIHRpbWUgaW4gbXMvZnJhbWVzIG9mIHRoZSBlbnRpcmUgVHdlZW4sIGluY2x1ZGluZyBsb29waW5nLlxyXG4gICAgdGhpcy50b3RhbEVsYXBzZWQgPSAwO1xyXG5cclxuICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBmb3IgdGhlIHdob2xlIFR3ZWVuIHRvIHBsYXkgdGhyb3VnaCBvbmNlLCBleGNsdWRpbmcgbG9vcCBhbW91bnRzIGFuZCBsb29wIGRlbGF5c1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XHJcblxyXG4gICAgLy8gIFZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVGhlIGFtb3VudCB0aHJvdWdoIHRoZSBUd2VlbiwgZXhjbHVkaW5nIGxvb3BzLlxyXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcblxyXG4gICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGZvciB0aGUgVHdlZW4gdG8gY29tcGxldGUgKGluY2x1ZGluZyBsb29waW5nKVxyXG4gICAgdGhpcy50b3RhbER1cmF0aW9uID0gMDtcclxuXHJcbiAgICAvLyAgVmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBUaGUgYW1vdW50IHRocm91Z2ggdGhlIGVudGlyZSBUd2VlbiwgaW5jbHVkaW5nIGxvb3BpbmcuXHJcbiAgICB0aGlzLnRvdGFsUHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xyXG4gICAgICAgIG9uU3RhcnQ6IHsgY2FsbGJhY2s6IG51bGwsIHNjb3BlOiBudWxsLCBwYXJhbXM6IG51bGwgfSxcclxuICAgICAgICBvblVwZGF0ZTogeyBjYWxsYmFjazogbnVsbCwgc2NvcGU6IG51bGwsIHBhcmFtczogbnVsbCB9LFxyXG4gICAgICAgIG9uUmVwZWF0OiB7IGNhbGxiYWNrOiBudWxsLCBzY29wZTogbnVsbCwgcGFyYW1zOiBudWxsIH0sXHJcbiAgICAgICAgb25Mb29wOiB7IGNhbGxiYWNrOiBudWxsLCBzY29wZTogbnVsbCwgcGFyYW1zOiBudWxsIH0sXHJcbiAgICAgICAgb25Db21wbGV0ZTogeyBjYWxsYmFjazogbnVsbCwgc2NvcGU6IG51bGwsIHBhcmFtczogbnVsbCB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tTY29wZTtcclxufTtcclxuXHJcblR3ZWVuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR3ZWVuO1xyXG5cclxuVHdlZW4ucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGNhbGNEdXJhdGlvbjogcmVxdWlyZSgnLi9jb21wb25lbnRzL0NhbGNEdXJhdGlvbicpLFxyXG4gICAgaW5pdDogcmVxdWlyZSgnLi9jb21wb25lbnRzL0luaXQnKSxcclxuICAgIGxvYWRWYWx1ZXM6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Mb2FkVmFsdWVzJyksXHJcbiAgICBuZXh0U3RhdGU6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9OZXh0U3RhdGUnKSxcclxuICAgIHBhdXNlOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvUGF1c2UnKSxcclxuICAgIHBsYXk6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9QbGF5JyksXHJcbiAgICByZXNldFR3ZWVuRGF0YTogcmVxdWlyZSgnLi9jb21wb25lbnRzL1Jlc2V0VHdlZW5EYXRhJyksXHJcbiAgICByZXN1bWU6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9SZXN1bWUnKSxcclxuICAgIHNlZWs6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9TZWVrJyksXHJcbiAgICBzZXRFdmVudENhbGxiYWNrOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvU2V0RXZlbnRDYWxsYmFjaycpLFxyXG4gICAgdXBkYXRlOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvVXBkYXRlJylcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFR3ZWVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL1R3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldFZhbHVlJyk7XHJcbnZhciBHZXRBZHZhbmNlZFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldEFkdmFuY2VkVmFsdWUnKTtcclxudmFyIFR3ZWVuID0gcmVxdWlyZSgnLi9Ud2VlbicpO1xyXG52YXIgUkVTRVJWRUQgPSByZXF1aXJlKCcuL1Jlc2VydmVkUHJvcHMnKTtcclxudmFyIEdldEVhc2VGdW5jdGlvbiA9IHJlcXVpcmUoJy4vR2V0RWFzZUZ1bmN0aW9uJyk7XHJcbnZhciBUd2VlbkRhdGEgPSByZXF1aXJlKCcuL1R3ZWVuRGF0YScpO1xyXG5cclxudmFyIEdldFRhcmdldHMgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIgdGFyZ2V0cyA9IEdldFZhbHVlKGNvbmZpZywgJ3RhcmdldHMnLCBudWxsKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHRhcmdldHMgPT09ICdmdW5jdGlvbicpXHJcbiAgICB7XHJcbiAgICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY2FsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRzKSlcclxuICAgIHtcclxuICAgICAgICB0YXJnZXRzID0gWyB0YXJnZXRzIF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldHM7XHJcbn07XHJcblxyXG52YXIgR2V0UHJvcHMgPSBmdW5jdGlvbiAoY29uZmlnKVxyXG57XHJcbiAgICB2YXIga2V5O1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAvLyAgRmlyc3Qgc2VlIGlmIHdlIGhhdmUgYSBwcm9wcyBvYmplY3RcclxuXHJcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdwcm9wcycpKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoa2V5IGluIGNvbmZpZy5wcm9wcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGtleXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogY29uZmlnLnByb3BzW2tleV0gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGZvciAoa2V5IGluIGNvbmZpZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSRVNFUlZFRC5pbmRleE9mKGtleSkgPT09IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IGNvbmZpZ1trZXldIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXlzO1xyXG59O1xyXG5cclxudmFyIEdldFZhbHVlT3AgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcclxue1xyXG4gICAgdmFyIHZhbHVlQ2FsbGJhY2s7XHJcbiAgICB2YXIgdCA9IHR5cGVvZih2YWx1ZSk7XHJcblxyXG4gICAgaWYgKHQgPT09ICdudW1iZXInKVxyXG4gICAge1xyXG4gICAgICAgIC8vIHByb3BzOiB7XHJcbiAgICAgICAgLy8gICAgIHg6IDQwMCxcclxuICAgICAgICAvLyAgICAgeTogMzAwXHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodCA9PT0gJ3N0cmluZycpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gcHJvcHM6IHtcclxuICAgICAgICAvLyAgICAgeDogJys9NDAwJyxcclxuICAgICAgICAvLyAgICAgeTogJy09MzAwJyxcclxuICAgICAgICAvLyAgICAgejogJyo9MicsXHJcbiAgICAgICAgLy8gICAgIHc6ICcvPTInXHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICB2YXIgb3AgPSB2YWx1ZVswXTtcclxuICAgICAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoMikpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG9wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBudW07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAtIG51bTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJyonOlxyXG4gICAgICAgICAgICAgICAgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uIChpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICogbnVtO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnLyc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgLyBudW07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0ID09PSAnZnVuY3Rpb24nKVxyXG4gICAge1xyXG4gICAgICAgIC8vIHByb3BzOiB7XHJcbiAgICAgICAgLy8gICAgIHg6IGZ1bmN0aW9uIChzdGFydFZhbHVlLCB0YXJnZXQsIGluZGV4LCB0b3RhbFRhcmdldHMpIHsgcmV0dXJuIHN0YXJ0VmFsdWUgKyAoaW5kZXggKiA1MCk7IH0sXHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHN0YXJ0VmFsdWUsIHRhcmdldCwgaW5kZXgsIHRvdGFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHN0YXJ0VmFsdWUsIHRhcmdldCwgaW5kZXgsIHRvdGFsKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFZhbHVlIG1heSBzdGlsbCBiZSBhIHN0cmluZywgZnVuY3Rpb24gb3IgYSBudW1iZXJcclxuICAgICAgICAvLyBwcm9wczoge1xyXG4gICAgICAgIC8vICAgICB4OiB7IHZhbHVlOiA0MDAsIC4uLiB9LFxyXG4gICAgICAgIC8vICAgICB5OiB7IHZhbHVlOiAzMDAsIC4uLiB9XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICB2YWx1ZUNhbGxiYWNrID0gR2V0VmFsdWVPcChrZXksIHZhbHVlLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWVDYWxsYmFjaztcclxufTtcclxuXHJcbnZhciBHZXRCb29sZWFuID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpXHJcbntcclxuICAgIGlmICghc291cmNlKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBHZXROZXdWYWx1ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKVxyXG57XHJcbiAgICB2YXIgdmFsdWVDYWxsYmFjaztcclxuXHJcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHQgPSB0eXBlb2Yoc291cmNlW2tleV0pO1xyXG5cclxuICAgICAgICBpZiAodCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgsIHRvdGFsVGFyZ2V0cywgdGFyZ2V0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlW2tleV0oaW5kZXgsIHRvdGFsVGFyZ2V0cywgdGFyZ2V0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKVxyXG4gICAge1xyXG4gICAgICAgIHZhbHVlQ2FsbGJhY2sgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlQ2FsbGJhY2s7XHJcbn07XHJcblxyXG52YXIgVHdlZW5CdWlsZGVyID0gZnVuY3Rpb24gKG1hbmFnZXIsIGNvbmZpZylcclxue1xyXG4gICAgLy8gIENyZWF0ZSBhcnJheXMgb2YgdGhlIFRhcmdldHMgYW5kIHRoZSBQcm9wZXJ0aWVzXHJcbiAgICB2YXIgdGFyZ2V0cyA9IEdldFRhcmdldHMoY29uZmlnKTtcclxuICAgIHZhciBwcm9wcyA9IEdldFByb3BzKGNvbmZpZyk7XHJcblxyXG4gICAgLy8gIERlZmF1bHQgVHdlZW4gdmFsdWVzXHJcbiAgICB2YXIgZWFzZVBhcmFtcyA9IEdldFZhbHVlKGNvbmZpZywgJ2Vhc2VQYXJhbXMnLCBudWxsKTtcclxuICAgIHZhciBlYXNlID0gR2V0RWFzZUZ1bmN0aW9uKEdldFZhbHVlKGNvbmZpZywgJ2Vhc2UnLCAnUG93ZXIwJyksIGVhc2VQYXJhbXMpO1xyXG4gICAgdmFyIGR1cmF0aW9uID0gR2V0TmV3VmFsdWUoY29uZmlnLCAnZHVyYXRpb24nLCAxMDAwKTtcclxuICAgIHZhciB5b3lvID0gR2V0Qm9vbGVhbihjb25maWcsICd5b3lvJywgZmFsc2UpO1xyXG4gICAgdmFyIGhvbGQgPSBHZXROZXdWYWx1ZShjb25maWcsICdob2xkJywgMCk7XHJcbiAgICB2YXIgcmVwZWF0ID0gR2V0TmV3VmFsdWUoY29uZmlnLCAncmVwZWF0JywgMCk7XHJcbiAgICB2YXIgcmVwZWF0RGVsYXkgPSBHZXROZXdWYWx1ZShjb25maWcsICdyZXBlYXREZWxheScsIDApO1xyXG4gICAgdmFyIGRlbGF5ID0gR2V0TmV3VmFsdWUoY29uZmlnLCAnZGVsYXknLCAwKTtcclxuICAgIHZhciBzdGFydEF0ID0gR2V0TmV3VmFsdWUoY29uZmlnLCAnc3RhcnRBdCcsIG51bGwpO1xyXG5cclxuICAgIHZhciBkYXRhID0gW107XHJcblxyXG4gICAgLy8gIExvb3AgdGhyb3VnaCBldmVyeSBwcm9wZXJ0eSBkZWZpbmVkIGluIHRoZSBUd2VlbiwgaS5lLjogcHJvcHMgeyB4LCB5LCBhbHBoYSB9XHJcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1twXS5rZXk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcF0udmFsdWU7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFyZ2V0cy5sZW5ndGg7IHQrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBTd2FwIGZvciBmYXN0ZXIgZ2V0dGVycywgaWYgdGhleSB3YW50IEFkdmFuY2VkIFZhbHVlIHN0eWxlIHRoaW5ncywgdGhleSBjYW4gZG8gaXQgdmlhIHRoZWlyIG93biBmdW5jdGlvbnNcclxuICAgICAgICAgICAgdmFyIHR3ZWVuRGF0YSA9IFR3ZWVuRGF0YShcclxuICAgICAgICAgICAgICAgIHRhcmdldHNbdF0sXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBHZXRWYWx1ZU9wKGtleSwgdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgR2V0RWFzZUZ1bmN0aW9uKEdldFZhbHVlKHZhbHVlLCAnZWFzZScsIGVhc2UpLCBlYXNlUGFyYW1zKSxcclxuICAgICAgICAgICAgICAgIEdldE5ld1ZhbHVlKHZhbHVlLCAnZGVsYXknLCBkZWxheSksXHJcbiAgICAgICAgICAgICAgICBHZXROZXdWYWx1ZSh2YWx1ZSwgJ2R1cmF0aW9uJywgZHVyYXRpb24pLFxyXG4gICAgICAgICAgICAgICAgR2V0Qm9vbGVhbih2YWx1ZSwgJ3lveW8nLCB5b3lvKSxcclxuICAgICAgICAgICAgICAgIEdldE5ld1ZhbHVlKHZhbHVlLCAnaG9sZCcsIGhvbGQpLFxyXG4gICAgICAgICAgICAgICAgR2V0TmV3VmFsdWUodmFsdWUsICdyZXBlYXQnLCByZXBlYXQpLFxyXG4gICAgICAgICAgICAgICAgR2V0TmV3VmFsdWUodmFsdWUsICdyZXBlYXREZWxheScsIHJlcGVhdERlbGF5KSxcclxuICAgICAgICAgICAgICAgIEdldE5ld1ZhbHVlKHZhbHVlLCAnc3RhcnRBdCcsIHN0YXJ0QXQpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyAgVE9ETzogQ2FsY3VsYXRlIHRvdGFsIGR1cmF0aW9uXHJcblxyXG4gICAgICAgICAgICBkYXRhLnB1c2godHdlZW5EYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHR3ZWVuID0gbmV3IFR3ZWVuKG1hbmFnZXIsIGRhdGEpO1xyXG5cclxuICAgIHR3ZWVuLnRvdGFsVGFyZ2V0cyA9IHRhcmdldHMubGVuZ3RoO1xyXG4gICAgdHdlZW4udXNlRnJhbWVzID0gR2V0Qm9vbGVhbihjb25maWcsICd1c2VGcmFtZXMnLCBmYWxzZSk7XHJcbiAgICB0d2Vlbi5sb29wID0gR2V0Qm9vbGVhbihjb25maWcsICdsb29wJywgMCk7XHJcbiAgICB0d2Vlbi5sb29wRGVsYXkgPSBHZXRBZHZhbmNlZFZhbHVlKGNvbmZpZywgJ2xvb3BEZWxheScsIDApO1xyXG4gICAgdHdlZW4uY29tcGxldGVEZWxheSA9IEdldEFkdmFuY2VkVmFsdWUoY29uZmlnLCAnY29tcGxldGVEZWxheScsIDApO1xyXG4gICAgdHdlZW4ucGF1c2VkID0gR2V0Qm9vbGVhbihjb25maWcsICdwYXVzZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIHR3ZWVuO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUd2VlbkJ1aWxkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vVHdlZW5CdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFR3ZWVuRGF0YSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIGVhc2UsIGRlbGF5LCBkdXJhdGlvbiwgeW95bywgaG9sZCwgcmVwZWF0LCByZXBlYXREZWxheSwgc3RhcnRBdClcclxue1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgLy8gIFRoZSB0YXJnZXQgdG8gdHdlZW5cclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuXHJcbiAgICAgICAgLy8gIFRoZSBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIHR3ZWVuXHJcbiAgICAgICAga2V5OiBrZXksXHJcblxyXG4gICAgICAgIC8vICBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBzdGFydGluZyB0aGUgdHdlZW4sIHBvcHVsYXRlcyB0aGUgJ3N0YXJ0JyBhbmQgJ2VuZCcgdmFsdWVzXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cclxuICAgICAgICAvLyAgVGhlIGVhc2UgZnVuY3Rpb24gdGhpcyB0d2VlbiB1c2VzLlxyXG4gICAgICAgIGVhc2U6IGVhc2UsXHJcblxyXG4gICAgICAgIC8vICBEdXJhdGlvbiBvZiB0aGUgdHdlZW4gaW4gbXMvZnJhbWVzLCBleGNsdWRlcyB0aW1lIGZvciB5b3lvIG9yIHJlcGVhdHMuXHJcbiAgICAgICAgZHVyYXRpb246IDAsXHJcblxyXG4gICAgICAgIC8vICBUaGUgdG90YWwgY2FsY3VsYXRlZCBkdXJhdGlvbiBvZiB0aGlzIFR3ZWVuRGF0YSAoYmFzZWQgb24gZHVyYXRpb24sIHJlcGVhdCwgZGVsYXkgYW5kIHlveW8pXHJcbiAgICAgICAgdG90YWxEdXJhdGlvbjogMCxcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgaW4gbXMvZnJhbWVzIGJlZm9yZSB0d2VlbiB3aWxsIHN0YXJ0LlxyXG4gICAgICAgIGRlbGF5OiAwLFxyXG5cclxuICAgICAgICAvLyAgQ2F1c2UgdGhlIHR3ZWVuIHRvIHJldHVybiBiYWNrIHRvIGl0cyBzdGFydCB2YWx1ZSBhZnRlciBob2xkIGhhcyBleHBpcmVkLlxyXG4gICAgICAgIHlveW86IHlveW8sXHJcblxyXG4gICAgICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyB0aGUgdHdlZW4gd2lsbCBwYXVzZSBiZWZvcmUgcnVubmluZyB0aGUgeW95byBvciBzdGFydGluZyBhIHJlcGVhdC5cclxuICAgICAgICBob2xkOiAwLFxyXG5cclxuICAgICAgICAvLyAgTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgdHdlZW4uIFRoZSB0d2VlbiB3aWxsIGFsd2F5cyBydW4gb25jZSByZWdhcmRsZXNzLCBzbyBhIHJlcGVhdCB2YWx1ZSBvZiAnMScgd2lsbCBwbGF5IHRoZSB0d2VlbiB0d2ljZS5cclxuICAgICAgICByZXBlYXQ6IDAsXHJcblxyXG4gICAgICAgIC8vICBUaW1lIGluIG1zL2ZyYW1lcyBiZWZvcmUgdGhlIHJlcGVhdCB3aWxsIHN0YXJ0LlxyXG4gICAgICAgIHJlcGVhdERlbGF5OiAwLFxyXG5cclxuICAgICAgICAvLyAgQ2hhbmdlcyB0aGUgcHJvcGVydHkgdG8gYmUgdGhpcyB2YWx1ZSBiZWZvcmUgc3RhcnRpbmcgdGhlIHR3ZWVuLlxyXG4gICAgICAgIHN0YXJ0QXQ6IHN0YXJ0QXQsXHJcblxyXG4gICAgICAgIC8vICBCZXR3ZWVuIDAgYW5kIDEgc2hvd2luZyBjb21wbGV0aW9uIG9mIHRoaXMgVHdlZW5EYXRhLlxyXG4gICAgICAgIHByb2dyZXNzOiAwLFxyXG5cclxuICAgICAgICAvLyAgRGVsdGEgY291bnRlci5cclxuICAgICAgICBlbGFwc2VkOiAwLFxyXG5cclxuICAgICAgICAvLyAgSG93IG1hbnkgcmVwZWF0cyBhcmUgbGVmdCB0byBydW4/XHJcbiAgICAgICAgcmVwZWF0Q291bnRlcjogMCxcclxuXHJcbiAgICAgICAgLy8gIEVhc2UgVmFsdWUgRGF0YTpcclxuXHJcbiAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgY3VycmVudDogMCxcclxuICAgICAgICBlbmQ6IDAsXHJcbiAgICAgICAgc3RhcnRDYWNoZTogMCxcclxuICAgICAgICBlbmRDYWNoZTogMCxcclxuXHJcbiAgICAgICAgLy8gIFRpbWUgRHVyYXRpb25zXHJcbiAgICAgICAgdDE6IDAsXHJcbiAgICAgICAgdDI6IDAsXHJcblxyXG4gICAgICAgIC8vICBMb2FkVmFsdWUgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcclxuICAgICAgICBnZW46IHtcclxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGhvbGQ6IGhvbGQsXHJcbiAgICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxyXG4gICAgICAgICAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAgVFdFRU5fQ09OU1QuQ1JFQVRFRFxyXG4gICAgICAgIHN0YXRlOiAwXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUd2VlbkRhdGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vVHdlZW5EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XHJcbnZhciBUd2VlbkJ1aWxkZXIgPSByZXF1aXJlKCcuL1R3ZWVuQnVpbGRlcicpO1xyXG5cclxudmFyIFR3ZWVuTWFuYWdlciA9IGZ1bmN0aW9uIChzdGF0ZSlcclxue1xyXG4gICAgLy8gIFRoZSBTdGF0ZSB0aGUgVHdlZW4gTWFuYWdlciBiZWxvbmdzIHRvICh0d2VlbnMgYXJlIFN0YXRlIHNwZWNpZmljLCBub3QgR2FtZSBnbG9iYWwpXHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwcm9wZXJ0eSB7RXZlbnREaXNwYXRjaGVyfSBldmVudHMgLSBHbG9iYWwgLyBHbG9iYWwgR2FtZSBTeXN0ZW0gRXZlbnRzXHJcbiAgICAqL1xyXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7IC8vIHNob3VsZCB1c2UgU3RhdGUgZXZlbnQgZGlzcGF0Y2hlcj9cclxuXHJcbiAgICAvLyAgVE9ETzpcclxuICAgIC8vICBBZGQgX3Bvb2wgYXJyYXkgYW5kIG1ha2UgdGhlIHF1ZXVlIHJlLXVzZSBvYmplY3RzIHdpdGhpbiBpdC5cclxuICAgIC8vICBBZGQgYSBwb29sIG1heCBzaXplLlxyXG5cclxuICAgIHRoaXMuX2FkZCA9IFtdO1xyXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gW107XHJcbiAgICB0aGlzLl9kZXN0cm95ID0gW107XHJcblxyXG4gICAgdGhpcy5fdG9Qcm9jZXNzID0gMDtcclxufTtcclxuXHJcblR3ZWVuTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd2Vlbk1hbmFnZXI7XHJcblxyXG5Ud2Vlbk1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFN0YXRlIGlzIHN0YXJ0aW5nIHVwXHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGNvbmZpZylcclxuICAgIHtcclxuICAgICAgICB2YXIgdHdlZW4gPSBUd2VlbkJ1aWxkZXIodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fYWRkLnB1c2godHdlZW4pO1xyXG5cclxuICAgICAgICB0aGlzLl90b1Byb2Nlc3MrKztcclxuXHJcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xyXG4gICAgfSxcclxuXHJcbiAgICB0aW1lbGluZTogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgICAgICAvLyByZXR1cm4gbmV3IFRpbWVsaW5lKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAgQWRkIGEgJ3RvJyBHU0FQIGVxdWl2YWxlbnQ/XHJcblxyXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAodHdlZW4pXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldDogZnVuY3Rpb24gKHRhcmdldClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgYmVnaW46IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RvUHJvY2VzcyA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBRdWljayBiYWlsXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fZGVzdHJveTtcclxuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0d2VlbjtcclxuXHJcbiAgICAgICAgLy8gIENsZWFyIHRoZSAnZGVzdHJveScgbGlzdFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW4gPSBsaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gIFJlbW92ZSBmcm9tIHRoZSAnYWN0aXZlJyBhcnJheVxyXG4gICAgICAgICAgICB2YXIgaWR4ID0gYWN0aXZlLmluZGV4T2YodHdlZW4pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAvLyAgUHJvY2VzcyB0aGUgYWRkaXRpb24gbGlzdFxyXG4gICAgICAgIC8vICBUaGlzIHN0b3BzIGNhbGxiYWNrcyBhbmQgb3V0IG9mIHN5bmMgZXZlbnRzIGZyb20gcG9wdWxhdGluZyB0aGUgYWN0aXZlIGFycmF5IG1pZC13YXkgZHVyaW5nIHRoZSB1cGRhdGVcclxuXHJcbiAgICAgICAgbGlzdCA9IHRoaXMuX2FkZDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0d2VlbiA9IGxpc3RbaV07XHJcblxyXG4gICAgICAgICAgICAvLyAgUmV0dXJuIHRydWUgaWYgdGhlIFR3ZWVuIHNob3VsZCBiZSBzdGFydGVkIHJpZ2h0IGF3YXksIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICAgICAgICBpZiAodHdlZW4uaW5pdCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5wbGF5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLnB1c2godHdlZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHR3ZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLl90b1Byb2Nlc3MgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGRlbHRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBQcm9jZXNzIGFjdGl2ZSB0d2VlbnNcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2FjdGl2ZTtcclxuICAgICAgICB2YXIgdHdlZW47XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuID0gbGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIC8vICBJZiBUd2Vlbi51cGRhdGUgcmV0dXJucyAndHJ1ZScgdGhlbiBpdCBtZWFucyBpdCBoYXMgY29tcGxldGVkLFxyXG4gICAgICAgICAgICAvLyAgc28gbW92ZSBpdCB0byB0aGUgZGVzdHJveSBsaXN0XHJcbiAgICAgICAgICAgIGlmICh0d2Vlbi51cGRhdGUodGltZXN0YW1wLCBkZWx0YSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3kucHVzaCh0d2Vlbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b1Byb2Nlc3MrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWFrZUFjdGl2ZTogZnVuY3Rpb24gKHR3ZWVuKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9wZW5kaW5nLmluZGV4T2YodHdlZW4pO1xyXG5cclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hZGQucHVzaCh0d2Vlbik7XHJcblxyXG4gICAgICAgIHRoaXMuX3RvUHJvY2VzcysrO1xyXG4gICAgfSxcclxuXHJcbiAgICBnbG9iYWxUaW1lU2NhbGU6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEFsbFR3ZWVuczogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VHdlZW5zT2Y6IGZ1bmN0aW9uICh0YXJnZXQpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzVHdlZW5pbmc6IGZ1bmN0aW9uICh0YXJnZXQpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGw6IGZ1bmN0aW9uICh2YXJzLCB0YXJnZXQpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGxBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIGtpbGxUd2VlbnNPZjogZnVuY3Rpb24gKHRhcmdldClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgcGF1c2VBbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VtZUFsbDogZnVuY3Rpb24gKClcclxuICAgIHtcclxuICAgIH0sXHJcblxyXG4gICAgZGVsYXllZENhbGw6IGZ1bmN0aW9uICgpXHJcbiAgICB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBQYXNzZXMgYWxsIFR3ZWVucyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgZWFjaFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cclxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXHJcbiAgICAqL1xyXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB0ZXh0dXJlIGluIHRoaXMubGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbdGV4dHVyZV07XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNodXRkb3duOiBmdW5jdGlvbiAoKVxyXG4gICAge1xyXG4gICAgICAgIC8vICBTdGF0ZSBpcyBzaHV0dGluZyBkb3duIChzd2FwcGluZyB0byBhbm90aGVyIFN0YXRlKVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHdlZW5NYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL1R3ZWVuTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYWxjRHVyYXRpb24gPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgbWF4ID0gMDtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ZWVuRGF0YSA9IGRhdGFbaV07XHJcblxyXG4gICAgICAgIC8vICBTZXQgdDEgKGR1cmF0aW9uICsgaG9sZCArIHlveW8pXHJcbiAgICAgICAgdHdlZW5EYXRhLnQxID0gdHdlZW5EYXRhLmR1cmF0aW9uICsgdHdlZW5EYXRhLmhvbGQ7XHJcblxyXG4gICAgICAgIGlmICh0d2VlbkRhdGEueW95bylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50MSArPSB0d2VlbkRhdGEuZHVyYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgU2V0IHQyIChyZXBlYXREZWxheSArIGR1cmF0aW9uICsgaG9sZCArIHlveW8pXHJcbiAgICAgICAgdHdlZW5EYXRhLnQyID0gdHdlZW5EYXRhLnQxICsgdHdlZW5EYXRhLnJlcGVhdERlbGF5O1xyXG5cclxuICAgICAgICAvLyAgVG90YWwgRHVyYXRpb25cclxuICAgICAgICB0d2VlbkRhdGEudG90YWxEdXJhdGlvbiA9IHR3ZWVuRGF0YS5kZWxheSArIHR3ZWVuRGF0YS50MTtcclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLnRvdGFsRHVyYXRpb24gKz0gdHdlZW5EYXRhLnQyICogKHR3ZWVuRGF0YS5yZXBlYXQgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHR3ZWVuRGF0YS5yZXBlYXQ7XHJcblxyXG4gICAgICAgIGlmICh0d2VlbkRhdGEudG90YWxEdXJhdGlvbiA+IG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1heCA9IHR3ZWVuRGF0YS50b3RhbER1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAgRXhjbHVkZXMgbG9vcCB2YWx1ZXNcclxuICAgIHRoaXMuZHVyYXRpb24gPSBtYXg7XHJcblxyXG4gICAgdGhpcy5sb29wQ291bnRlciA9ICh0aGlzLmxvb3AgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMubG9vcDtcclxuXHJcbiAgICBpZiAodGhpcy5sb29wQ291bnRlciA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy50b3RhbER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIHRoaXMuY29tcGxldGVEZWxheSArICgodGhpcy5kdXJhdGlvbiArIHRoaXMubG9vcERlbGF5KSAqIHRoaXMubG9vcENvdW50ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudG90YWxEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gKyB0aGlzLmNvbXBsZXRlRGVsYXk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbGNEdXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9jb21wb25lbnRzL0NhbGNEdXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vLyAgUmV0dXJuIHRydWUgaWYgdGhpcyBUd2VlbiBzaG91bGQgYmUgbW92ZWQgZnJvbSB0aGUgcGVuZGluZyBsaXN0IHRvIHRoZSBhY3RpdmUgbGlzdFxyXG52YXIgSW5pdCA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgdmFyIHRvdGFsVGFyZ2V0cyA9IHRoaXMudG90YWxUYXJnZXRzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b3RhbERhdGE7IGkrKylcclxuICAgIHtcclxuICAgICAgICB2YXIgdHdlZW5EYXRhID0gZGF0YVtpXTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdHdlZW5EYXRhLnRhcmdldDtcclxuICAgICAgICB2YXIgZ2VuID0gdHdlZW5EYXRhLmdlbjtcclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLmRlbGF5ID0gZ2VuLmRlbGF5KGksIHRvdGFsVGFyZ2V0cywgdGFyZ2V0KTtcclxuICAgICAgICB0d2VlbkRhdGEuZHVyYXRpb24gPSBnZW4uZHVyYXRpb24oaSwgdG90YWxUYXJnZXRzLCB0YXJnZXQpO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5ob2xkID0gZ2VuLmhvbGQoaSwgdG90YWxUYXJnZXRzLCB0YXJnZXQpO1xyXG4gICAgICAgIHR3ZWVuRGF0YS5yZXBlYXQgPSBnZW4ucmVwZWF0KGksIHRvdGFsVGFyZ2V0cywgdGFyZ2V0KTtcclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0RGVsYXkgPSBnZW4ucmVwZWF0RGVsYXkoaSwgdG90YWxUYXJnZXRzLCB0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsY0R1cmF0aW9uKCk7XHJcblxyXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XHJcbiAgICB0aGlzLnRvdGFsUHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdUd2VlbiBkdXJhdGlvbicsIHRoaXMuZHVyYXRpb24sICd0b3RhbER1cmF0aW9uJywgdGhpcy50b3RhbER1cmF0aW9uKTtcclxuXHJcbiAgICBpZiAodGhpcy5wYXVzZWQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbml0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL2NvbXBvbmVudHMvSW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gNzc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDYWxjdWxhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFuZCBzdG9yZSB0aGVtIGludG8gdGhlIFR3ZWVuVGFyZ2V0IG9iamVjdHNcclxuXHJcbnZhciBMb2FkVmFsdWVzID0gZnVuY3Rpb24gKHR3ZWVuRGF0YSlcclxue1xyXG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XHJcbiAgICB2YXIgcHJvcCA9IHR3ZWVuRGF0YS5rZXk7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coJy0tPiBMb2FkVmFsdWVzJywgcHJvcCk7XHJcblxyXG4gICAgLy8gIFRhcmdldHMgYXJyYXk6XHJcbiAgICAvLyAgMDpcclxuICAgIC8vICAgICAgcmVmOiBHYW1lT2JqZWN0LFxyXG4gICAgLy8gICAgICBrZXlzOiB7XHJcbiAgICAvLyAgICAgICAgICB4OiB7XHJcbiAgICAvLyAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAvLyAgICAgICAgICAgICAgY3VycmVudCxcclxuICAgIC8vICAgICAgICAgICAgICBlbmQsXHJcbiAgICAvLyAgICAgICAgICAgICAgc3RhcnRDYWNoZSxcclxuICAgIC8vICAgICAgICAgICAgICBlbmRDYWNoZVxyXG4gICAgLy8gICAgICAgICAgfSxcclxuICAgIC8vICAgICAgICAgIHk6IHtcclxuICAgIC8vICAgICAgICAgICAgICBzdGFydCxcclxuICAgIC8vICAgICAgICAgICAgICBjdXJyZW50LFxyXG4gICAgLy8gICAgICAgICAgICAgIGVuZCxcclxuICAgIC8vICAgICAgICAgICAgICBzdGFydENhY2hlLFxyXG4gICAgLy8gICAgICAgICAgICAgIGVuZENhY2hlXHJcbiAgICAvLyAgICAgICAgICB9XHJcbiAgICAvLyAgICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxUYXJnZXRzOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGtleXMgPSB0YXJnZXRzW2ldLmtleXM7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5c1twcm9wXTtcclxuICAgICAgICB2YXIgZ2FtZU9iamVjdCA9IHRhcmdldHNbaV0ucmVmO1xyXG5cclxuICAgICAgICBpZiAoZW50cnkuc3RhcnRDYWNoZSA9PT0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gZ2FtZU9iamVjdFtwcm9wXTtcclxuICAgICAgICAgICAgZW50cnkuY3VycmVudCA9IGVudHJ5LnN0YXJ0O1xyXG4gICAgICAgICAgICBlbnRyeS5lbmQgPSB0d2VlbkRhdGEudmFsdWUoZW50cnkuc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gIENhY2hlIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBzbyB3ZSBvbmx5IGRvIHRoaXMgb25jZSAobmVlZGVkPylcclxuICAgICAgICAgICAgZW50cnkuc3RhcnRDYWNoZSA9IGVudHJ5LnN0YXJ0O1xyXG4gICAgICAgICAgICBlbnRyeS5lbmRDYWNoZSA9IGVudHJ5LmVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBlbnRyeS5zdGFydENhY2hlO1xyXG4gICAgICAgICAgICBlbnRyeS5jdXJyZW50ID0gZW50cnkuc3RhcnQ7XHJcbiAgICAgICAgICAgIGVudHJ5LmVuZCA9IGVudHJ5LmVuZENhY2hlO1xyXG5cclxuICAgICAgICAgICAgZ2FtZU9iamVjdFtwcm9wXSA9IGVudHJ5LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RhcmdldCcsIGdhbWVPYmplY3QubmFtZSwgJ2tleScsIHByb3AsICdzdGFydCcsIGVudHJ5LnN0YXJ0LCAnZW5kJywgZW50cnkuZW5kKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZFZhbHVlcztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9jb21wb25lbnRzL0xvYWRWYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVFdFRU5fQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxudmFyIE5leHRTdGF0ZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLmxvb3BDb3VudGVyID4gMClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlc2V0VHdlZW5EYXRhKHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmVsYXBzZWQgPSAwO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMubG9vcENvdW50ZXItLTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubG9vcERlbGF5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnRkb3duID0gdGhpcy5sb29wRGVsYXk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5MT09QX0RFTEFZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuQUNUSVZFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuY29tcGxldGVEZWxheSA+IDApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5jb3VudGRvd24gPSB0aGlzLmNvbXBsZXRlRGVsYXk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkNPTVBMRVRFX0RFTEFZO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5QRU5ESU5HX1JFTU9WRTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmV4dFN0YXRlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL2NvbXBvbmVudHMvTmV4dFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBQYXVzZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9wYXVzZWRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULlBBVVNFRDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGF1c2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29tcG9uZW50cy9QYXVzZS5qc1xuLy8gbW9kdWxlIGlkID0gNzgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG52YXIgUGxheSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5BQ1RJVkUpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBhdXNlZClcclxuICAgIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLm1ha2VBY3RpdmUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFJlc2V0IHRoZSBUd2VlbkRhdGFcclxuICAgICAgICB0aGlzLnJlc2V0VHdlZW5EYXRhKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUV0VFTl9DT05TVC5BQ1RJVkU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29tcG9uZW50cy9QbGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3ODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBSZXNldFR3ZWVuRGF0YSA9IGZ1bmN0aW9uIChyZXNldEZyb21Mb29wKVxyXG57XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHR3ZWVuRGF0YSA9IGRhdGFbaV07XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSAwO1xyXG5cclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0Q291bnRlciA9ICh0d2VlbkRhdGEucmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0d2VlbkRhdGEucmVwZWF0O1xyXG5cclxuICAgICAgICBpZiAocmVzZXRGcm9tTG9vcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGFydCA9IHR3ZWVuRGF0YS5zdGFydENhY2hlO1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEuY3VycmVudCA9IHR3ZWVuRGF0YS5zdGFydDtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLmVuZCA9IHR3ZWVuRGF0YS5lbmRDYWNoZTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHdlZW5EYXRhLmRlbGF5ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gdHdlZW5EYXRhLmRlbGF5O1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBUV0VFTl9DT05TVC5ERUxBWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19SRU5ERVI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNldFR3ZWVuRGF0YTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9jb21wb25lbnRzL1Jlc2V0VHdlZW5EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3ODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxuXHJcbnZhciBQYXVzZSA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBUV0VFTl9DT05TVC5QQVVTRUQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX3BhdXNlZFN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXVzZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90d2Vlbi9jb21wb25lbnRzL1Jlc3VtZS5qc1xuLy8gbW9kdWxlIGlkID0gNzgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHZhciBUV0VFTl9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XHJcblxyXG4vLyAgRm9yIG5vdyBwcm9ncmVzcyA9IDAgdG8gMVxyXG52YXIgU2VlayA9IGZ1bmN0aW9uICh0b1Bvc2l0aW9uKVxyXG57XHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG90YWxEYXRhOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFRoaXMgd29uJ3Qgd29yayB3aXRoIGxvb3AgPiAwIHlldFxyXG4gICAgICAgIHZhciBtcyA9IHRoaXMudG90YWxEdXJhdGlvbiAqIHRvUG9zaXRpb247XHJcblxyXG4gICAgICAgIHZhciB0d2VlbkRhdGEgPSBkYXRhW2ldO1xyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdmFyIGVsYXBzZWQgPSAwO1xyXG5cclxuICAgICAgICBpZiAobXMgPD0gdHdlZW5EYXRhLmRlbGF5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICBlbGFwc2VkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobXMgPj0gdHdlZW5EYXRhLnRvdGFsRHVyYXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcm9ncmVzcyA9IDE7XHJcbiAgICAgICAgICAgIGVsYXBzZWQgPSB0d2VlbkRhdGEuZHVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1zID4gdHdlZW5EYXRhLmRlbGF5ICYmIG1zIDw9IHR3ZWVuRGF0YS50MSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICBLZWVwIGl0IHplcm8gYm91bmRcclxuICAgICAgICAgICAgbXMgPSBNYXRoLm1heCgwLCBtcyAtIHR3ZWVuRGF0YS5kZWxheSk7XHJcblxyXG4gICAgICAgICAgICAvLyAgU29tZXdoZXJlIGluIHRoZSBmaXJzdCBwbGF5dGhydSByYW5nZVxyXG4gICAgICAgICAgICBwcm9ncmVzcyA9IG1zIC8gdHdlZW5EYXRhLnQxO1xyXG4gICAgICAgICAgICBlbGFwc2VkID0gdHdlZW5EYXRhLmR1cmF0aW9uICogcHJvZ3Jlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1zID4gdHdlZW5EYXRhLnQxICYmIG1zIDwgdHdlZW5EYXRhLnRvdGFsRHVyYXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgU29tZXdoZXJlIGluIHJlcGVhdCBsYW5kXHJcbiAgICAgICAgICAgIG1zIC09IHR3ZWVuRGF0YS5kZWxheTtcclxuICAgICAgICAgICAgbXMgLT0gdHdlZW5EYXRhLnQxO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKG1zIC8gdHdlZW5EYXRhLnQyKTtcclxuXHJcbiAgICAgICAgICAgIC8vICByZW1haW5kZXJcclxuICAgICAgICAgICAgbXMgPSAoKG1zIC8gdHdlZW5EYXRhLnQyKSAlIDEpICogdHdlZW5EYXRhLnQyO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1zID4gdHdlZW5EYXRhLnJlcGVhdERlbGF5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG1zIC8gdHdlZW5EYXRhLnQxO1xyXG4gICAgICAgICAgICAgICAgZWxhcHNlZCA9IHR3ZWVuRGF0YS5kdXJhdGlvbiAqIHByb2dyZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0d2VlbkRhdGEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IGVsYXBzZWQ7XHJcblxyXG4gICAgICAgIHZhciB2ID0gdHdlZW5EYXRhLmVhc2UodHdlZW5EYXRhLnByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLmN1cnJlbnQgPSB0d2VlbkRhdGEuc3RhcnQgKyAoKHR3ZWVuRGF0YS5lbmQgLSB0d2VlbkRhdGEuc3RhcnQpICogdik7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHR3ZWVuRGF0YS5rZXksICdTZWVrJywgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSwgJ3RvJywgdHdlZW5EYXRhLmN1cnJlbnQsICdwcm8nLCB0d2VlbkRhdGEucHJvZ3Jlc3MsICdtYXJrZXInLCBtYXJrZXIsIHByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSA9IHR3ZWVuRGF0YS5jdXJyZW50O1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZWVrO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3R3ZWVuL2NvbXBvbmVudHMvU2Vlay5qc1xuLy8gbW9kdWxlIGlkID0gNzg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRFdmVudENhbGxiYWNrID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKVxyXG57XHJcbiAgICB2YXIgdHlwZXMgPSBbICdvblN0YXJ0JywgJ29uVXBkYXRlJywgJ29uUmVwZWF0JywgJ29uTG9vcCcsICdvbkNvbXBsZXRlJyBdO1xyXG5cclxuICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUsIHBhcmFtczogcGFyYW1zIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldEV2ZW50Q2FsbGJhY2s7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29tcG9uZW50cy9TZXRFdmVudENhbGxiYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA3ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRXRUVOX0NPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcclxudmFyIFVwZGF0ZVR3ZWVuRGF0YSA9IHJlcXVpcmUoJy4vVXBkYXRlVHdlZW5EYXRhJyk7XHJcblxyXG52YXIgVXBkYXRlID0gZnVuY3Rpb24gKHRpbWVzdGFtcCwgZGVsdGEpXHJcbntcclxuICAgIGlmICh0aGlzLnVzZUZyYW1lcylcclxuICAgIHtcclxuICAgICAgICBkZWx0YSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbGFwc2VkICs9IGRlbHRhO1xyXG4gICAgdGhpcy5wcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24sIDEpO1xyXG5cclxuICAgIHRoaXMudG90YWxFbGFwc2VkICs9IGRlbHRhO1xyXG4gICAgdGhpcy50b3RhbFByb2dyZXNzID0gTWF0aC5taW4odGhpcy50b3RhbEVsYXBzZWQgLyB0aGlzLnRvdGFsRHVyYXRpb24sIDEpO1xyXG5cclxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULkFDVElWRTpcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGlsbFJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b3RhbERhdGE7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFVwZGF0ZVR3ZWVuRGF0YSh0aGlzLCB0aGlzLmRhdGFbaV0sIGRlbHRhKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGlsbFJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAgQW55dGhpbmcgc3RpbGwgcnVubmluZz8gSWYgbm90LCB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmICghc3RpbGxSdW5uaW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5MT09QX0RFTEFZOlxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGRvd24gPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRXRUVOX0NPTlNULkFDVElWRTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuQ09NUExFVEVfREVMQVk6XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZG93biAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ZG93biA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19SRU1PVkU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gVFdFRU5fQ09OU1QuUEVORElOR19SRU1PVkUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29tcG9uZW50cy9VcGRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVFdFRU5fQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xyXG5cclxudmFyIFNldFN0YXRlRnJvbUVuZCA9IGZ1bmN0aW9uICh0d2VlbiwgdHdlZW5EYXRhKVxyXG57XHJcbiAgICBpZiAodHdlZW5EYXRhLnlveW8pXHJcbiAgICB7XHJcbiAgICAgICAgLy8gIFBsYXlpbmcgZm9yd2FyZCBhbmQgd2UgaGF2ZSBhIHlveW9cclxuXHJcbiAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gMDtcclxuICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IDA7XHJcblxyXG4gICAgICAgIHJldHVybiBUV0VFTl9DT05TVC5QTEFZSU5HX0JBQ0tXQVJEO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHdlZW5EYXRhLnJlcGVhdENvdW50ZXIgPiAwKVxyXG4gICAge1xyXG4gICAgICAgIHR3ZWVuRGF0YS5yZXBlYXRDb3VudGVyLS07XHJcblxyXG4gICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gMDtcclxuICAgICAgICB0d2VlbkRhdGEucHJvZ3Jlc3MgPSAwO1xyXG5cclxuICAgICAgICAvLyAgRGVsYXk/XHJcbiAgICAgICAgaWYgKHR3ZWVuRGF0YS5yZXBlYXREZWxheSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IHR3ZWVuRGF0YS5yZXBlYXREZWxheTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLnRhcmdldFt0d2VlbkRhdGEua2V5XSA9IHR3ZWVuRGF0YS5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlJFUEVBVF9ERUxBWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFRXRUVOX0NPTlNULkNPTVBMRVRFO1xyXG59O1xyXG5cclxuLy8gIFdhcyBQTEFZSU5HX0JBQ0tXQVJEIGFuZCBoYXMgaGl0IHRoZSBzdGFydFxyXG52YXIgU2V0U3RhdGVGcm9tU3RhcnQgPSBmdW5jdGlvbiAodHdlZW4sIHR3ZWVuRGF0YSlcclxue1xyXG4gICAgaWYgKHR3ZWVuRGF0YS5yZXBlYXRDb3VudGVyID4gMClcclxuICAgIHtcclxuICAgICAgICB0d2VlbkRhdGEucmVwZWF0Q291bnRlci0tO1xyXG5cclxuICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gMDtcclxuXHJcbiAgICAgICAgLy8gIERlbGF5P1xyXG4gICAgICAgIGlmICh0d2VlbkRhdGEucmVwZWF0RGVsYXkgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSB0d2VlbkRhdGEucmVwZWF0RGVsYXk7XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuY3VycmVudCA9IHR3ZWVuRGF0YS5zdGFydDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0gPSB0d2VlbkRhdGEuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBUV0VFTl9DT05TVC5SRVBFQVRfREVMQVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBUV0VFTl9DT05TVC5QTEFZSU5HX0ZPUldBUkQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBUV0VFTl9DT05TVC5DT01QTEVURTtcclxufTtcclxuXHJcbi8vICBEZWx0YSBpcyBlaXRoZXIgYSB2YWx1ZSBpbiBtcywgb3IgMSBpZiBUd2Vlbi51c2VGcmFtZXMgaXMgdHJ1ZVxyXG52YXIgVXBkYXRlVHdlZW5EYXRhID0gZnVuY3Rpb24gKHR3ZWVuLCB0d2VlbkRhdGEsIGRlbHRhKVxyXG57XHJcbiAgICBzd2l0Y2ggKHR3ZWVuRGF0YS5zdGF0ZSlcclxuICAgIHtcclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDpcclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULlBMQVlJTkdfQkFDS1dBUkQ6XHJcblxyXG4gICAgICAgICAgICB2YXIgZWxhcHNlZCA9IHR3ZWVuRGF0YS5lbGFwc2VkO1xyXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0d2VlbkRhdGEuZHVyYXRpb247XHJcblxyXG4gICAgICAgICAgICBlbGFwc2VkICs9IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBkdXJhdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZWxhcHNlZCA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9yd2FyZCA9ICh0d2VlbkRhdGEuc3RhdGUgPT09IFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGVsYXBzZWQgLyBkdXJhdGlvbjtcclxuICAgICAgICAgICAgdmFyIHY7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9yd2FyZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdiA9IHR3ZWVuRGF0YS5lYXNlKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHYgPSB0d2VlbkRhdGEuZWFzZSgxIC0gcHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuY3VycmVudCA9IHR3ZWVuRGF0YS5zdGFydCArICgodHdlZW5EYXRhLmVuZCAtIHR3ZWVuRGF0YS5zdGFydCkgKiB2KTtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0gPSB0d2VlbkRhdGEuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gZWxhcHNlZDtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLnByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuaG9sZCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCA9IHR3ZWVuRGF0YS5ob2xkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gVFdFRU5fQ09OU1QuSE9MRF9ERUxBWTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gU2V0U3RhdGVGcm9tRW5kKHR3ZWVuLCB0d2VlbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0d2VlbkRhdGEuc3RhdGUgPSBTZXRTdGF0ZUZyb21TdGFydCh0d2VlbiwgdHdlZW5EYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgVFdFRU5fQ09OU1QuREVMQVk6XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZWxhcHNlZCAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0d2VlbkRhdGEuZWxhcHNlZCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyAgVE9ETyAtIE1vdmUgZWxhcHNlZCBibG9jayBiZWxvdyBzd2l0Y2ggc3RhdGVtZW50IHNvIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFuZCBwbGF5IGhhcHBlbiB0aGlzIGZyYW1lLCBub3QgdGhlIG5leHQgb25lP1xyXG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgPSBNYXRoLmFicyh0d2VlbkRhdGEuZWxhcHNlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gVFdFRU5fQ09OU1QuUEVORElOR19SRU5ERVI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFRXRUVOX0NPTlNULlJFUEVBVF9ERUxBWTpcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR3ZWVuRGF0YS5lbGFwc2VkIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR3ZWVuRGF0YS5lbGFwc2VkID0gTWF0aC5hYnModHdlZW5EYXRhLmVsYXBzZWQpO1xyXG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gVFdFRU5fQ09OU1QuUExBWUlOR19GT1JXQVJEO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5IT0xEX0RFTEFZOlxyXG5cclxuICAgICAgICAgICAgdHdlZW5EYXRhLmVsYXBzZWQgLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodHdlZW5EYXRhLmVsYXBzZWQgPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhLnN0YXRlID0gU2V0U3RhdGVGcm9tRW5kKHR3ZWVuLCB0d2VlbkRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBUV0VFTl9DT05TVC5QRU5ESU5HX1JFTkRFUjpcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGFydCA9IHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV07XHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5jdXJyZW50ID0gdHdlZW5EYXRhLnN0YXJ0O1xyXG4gICAgICAgICAgICB0d2VlbkRhdGEuZW5kID0gdHdlZW5EYXRhLnZhbHVlKHR3ZWVuRGF0YS5zdGFydCk7XHJcblxyXG4gICAgICAgICAgICB0d2VlbkRhdGEuc3RhcnRDYWNoZSA9IHR3ZWVuRGF0YS5zdGFydDtcclxuICAgICAgICAgICAgdHdlZW5EYXRhLmVuZENhY2hlID0gdHdlZW5EYXRhLmVuZDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS50YXJnZXRbdHdlZW5EYXRhLmtleV0gPSB0d2VlbkRhdGEuY3VycmVudDtcclxuXHJcbiAgICAgICAgICAgIHR3ZWVuRGF0YS5zdGF0ZSA9IFRXRUVOX0NPTlNULlBMQVlJTkdfRk9SV0FSRDtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICBSZXR1cm4gVFJVRSBpZiB0aGlzIFR3ZWVuRGF0YSBzdGlsbCBwbGF5aW5nLCBvdGhlcndpc2UgcmV0dXJuIEZBTFNFXHJcbiAgICByZXR1cm4gKHR3ZWVuRGF0YS5zdGF0ZSAhPT0gVFdFRU5fQ09OU1QuQ09NUExFVEUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGVUd2VlbkRhdGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdHdlZW4vY29tcG9uZW50cy9VcGRhdGVUd2VlbkRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDc4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XHJcblxyXG52YXIgQWxpZ25Jbk1hcCA9IFtdO1xyXG5cclxuQWxpZ25Jbk1hcFtDT05TVC5CT1RUT01fQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5Cb3R0b21DZW50ZXInKTtcclxuQWxpZ25Jbk1hcFtDT05TVC5CT1RUT01fTEVGVF0gPSByZXF1aXJlKCcuL0luQm90dG9tTGVmdCcpO1xyXG5BbGlnbkluTWFwW0NPTlNULkJPVFRPTV9SSUdIVF0gPSByZXF1aXJlKCcuL0luQm90dG9tUmlnaHQnKTtcclxuQWxpZ25Jbk1hcFtDT05TVC5DRU5URVJdID0gcmVxdWlyZSgnLi9JbkNlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULkxFRlRfQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5MZWZ0Q2VudGVyJyk7XHJcbkFsaWduSW5NYXBbQ09OU1QuUklHSFRfQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5SaWdodENlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULlRPUF9DRU5URVJdID0gcmVxdWlyZSgnLi9JblRvcENlbnRlcicpO1xyXG5BbGlnbkluTWFwW0NPTlNULlRPUF9MRUZUXSA9IHJlcXVpcmUoJy4vSW5Ub3BMZWZ0Jyk7XHJcbkFsaWduSW5NYXBbQ09OU1QuVE9QX1JJR0hUXSA9IHJlcXVpcmUoJy4vSW5Ub3BSaWdodCcpO1xyXG5cclxudmFyIEFsaWduSW4gPSBmdW5jdGlvbiAoY2hpbGQsIGNvbnRhaW5lciwgcG9zaXRpb24sIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIHJldHVybiBBbGlnbkluTWFwW3Bvc2l0aW9uXShjaGlsZCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWxpZ25JbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9BbGlnbkluLmpzXG4vLyBtb2R1bGUgaWQgPSA3ODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21DZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKHBhcmVudCkgKyBvZmZzZXRYKTtcclxuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRCb3R0b20ocGFyZW50KSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb0JvdHRvbUNlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvQm90dG9tTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xyXG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvQm90dG9tTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDc5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XHJcblxyXG52YXIgVG9Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21SaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA3OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xyXG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcclxuXHJcbnZhciBUb0xlZnRCb3R0b20gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9MZWZ0Qm90dG9tO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xyXG52YXIgU2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0UmlnaHQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIFRvTGVmdENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRMZWZ0KHBhcmVudCkgLSBvZmZzZXRYKTtcclxuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvTGVmdENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRMZWZ0Jyk7XHJcbnZhciBHZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0VG9wJyk7XHJcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvTGVmdFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRMZWZ0KHBhcmVudCkgLSBvZmZzZXRYKTtcclxuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRUb3AocGFyZW50KSAtIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb0xlZnRUb3A7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSA3OTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFJpZ2h0Jyk7XHJcbnZhciBHZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Qm90dG9tJyk7XHJcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcclxudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcclxuXHJcbnZhciBUb1JpZ2h0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcclxue1xyXG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxyXG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxyXG5cclxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0UmlnaHQocGFyZW50KSArIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvUmlnaHRCb3R0b207XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYWxpZ24vVG9SaWdodEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNzk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xyXG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XHJcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcclxudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xyXG5cclxudmFyIFRvUmlnaHRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIEdldENlbnRlclkocGFyZW50KSArIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb1JpZ2h0VG9wO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL1RvUmlnaHRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xyXG5cclxudmFyIFRvUmlnaHRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRUb3AoZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodFRvcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSA3OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xyXG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xyXG52YXIgU2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJYJyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BDZW50ZXIgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxyXG57XHJcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XHJcbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XHJcblxyXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKHBhcmVudCkgKyBvZmZzZXRYKTtcclxuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRUb3AocGFyZW50KSAtIG9mZnNldFkpO1xyXG5cclxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUb1RvcENlbnRlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xyXG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xyXG5cclxudmFyIFRvVG9wTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xyXG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvVG9wTGVmdDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1RvcExlZnQuanNcbi8vIG1vZHVsZSBpZCA9IDc5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcclxudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcclxudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XHJcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XHJcblxyXG52YXIgVG9Ub3BSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXHJcbntcclxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cclxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cclxuXHJcbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XHJcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0VG9wKHBhcmVudCkgLSBvZmZzZXRZKTtcclxuXHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BSaWdodDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA4MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5VdGlscy5BbGlnblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgSW5Cb3R0b21DZW50ZXI6IHJlcXVpcmUoJy4vSW5Cb3R0b21DZW50ZXInKSxcclxuICAgIEluQm90dG9tTGVmdDogcmVxdWlyZSgnLi9JbkJvdHRvbUxlZnQnKSxcclxuICAgIEluQm90dG9tUmlnaHQ6IHJlcXVpcmUoJy4vSW5Cb3R0b21SaWdodCcpLFxyXG4gICAgSW5DZW50ZXI6IHJlcXVpcmUoJy4vSW5DZW50ZXInKSxcclxuICAgIEluTGVmdENlbnRlcjogcmVxdWlyZSgnLi9JbkxlZnRDZW50ZXInKSxcclxuICAgIEluUmlnaHRDZW50ZXI6IHJlcXVpcmUoJy4vSW5SaWdodENlbnRlcicpLFxyXG4gICAgSW5Ub3BDZW50ZXI6IHJlcXVpcmUoJy4vSW5Ub3BDZW50ZXInKSxcclxuICAgIEluVG9wTGVmdDogcmVxdWlyZSgnLi9JblRvcExlZnQnKSxcclxuICAgIEluVG9wUmlnaHQ6IHJlcXVpcmUoJy4vSW5Ub3BSaWdodCcpLFxyXG4gICAgVG9Cb3R0b21DZW50ZXI6IHJlcXVpcmUoJy4vVG9Cb3R0b21DZW50ZXInKSxcclxuICAgIFRvQm90dG9tTGVmdDogcmVxdWlyZSgnLi9Ub0JvdHRvbUxlZnQnKSxcclxuICAgIFRvQm90dG9tUmlnaHQ6IHJlcXVpcmUoJy4vVG9Cb3R0b21SaWdodCcpLFxyXG4gICAgVG9MZWZ0Qm90dG9tOiByZXF1aXJlKCcuL1RvTGVmdEJvdHRvbScpLFxyXG4gICAgVG9MZWZ0Q2VudGVyOiByZXF1aXJlKCcuL1RvTGVmdENlbnRlcicpLFxyXG4gICAgVG9MZWZ0VG9wOiByZXF1aXJlKCcuL1RvTGVmdFRvcCcpLFxyXG4gICAgVG9SaWdodEJvdHRvbTogcmVxdWlyZSgnLi9Ub1JpZ2h0Qm90dG9tJyksXHJcbiAgICBUb1JpZ2h0Q2VudGVyOiByZXF1aXJlKCcuL1RvUmlnaHRDZW50ZXInKSxcclxuICAgIFRvUmlnaHRUb3A6IHJlcXVpcmUoJy4vVG9SaWdodFRvcCcpLFxyXG4gICAgVG9Ub3BDZW50ZXI6IHJlcXVpcmUoJy4vVG9Ub3BDZW50ZXInKSxcclxuICAgIFRvVG9wTGVmdDogcmVxdWlyZSgnLi9Ub1RvcExlZnQnKSxcclxuICAgIFRvVG9wUmlnaHQ6IHJlcXVpcmUoJy4vVG9Ub3BSaWdodCcpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FsaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiogU25hcHMgYSB2YWx1ZSB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhbiBhcnJheS5cclxuKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGluIHRoZSByYW5nZSBgW2ZpcnN0X3ZhbHVlLCBsYXN0X3ZhbHVlXWAuXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCB2YWx1ZVxyXG4qIEBwYXJhbSB7bnVtYmVyW119IGFyciAtIFRoZSBpbnB1dCBhcnJheSB3aGljaCBfbXVzdF8gYmUgc29ydGVkLlxyXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgdmFsdWUgZm91bmQuXHJcbiovXHJcbnZhciBGaW5kQ2xvc2VzdEluU29ydGVkID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSlcclxue1xyXG4gICAgaWYgKCFhcnJheS5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSB8fCB2YWx1ZSA8IGFycmF5WzBdKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBhcnJheVswXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKGFycmF5W2ldIDwgdmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb3cgPSBhcnJheVtpIC0gMV07XHJcbiAgICB2YXIgaGlnaCA9IChpIDwgYXJyYXkubGVuZ3RoKSA/IGFycmF5W2ldIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuICAgIHJldHVybiAoKGhpZ2ggLSB2YWx1ZSkgPD0gKHZhbHVlIC0gbG93KSkgPyBoaWdoIDogbG93O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaW5kQ2xvc2VzdEluU29ydGVkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L0ZpbmRDbG9zZXN0SW5Tb3J0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDgwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuKiBGZXRjaCBhIHJhbmRvbSBlbnRyeSBmcm9tIHRoZSBnaXZlbiBhcnJheS5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZC5cclxuKi9cclxuXHJcbnZhciBHZXRSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxyXG57XHJcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cclxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cclxuXHJcbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XHJcblxyXG4gICAgcmV0dXJuIChhcnJheVtyYW5kb21JbmRleF0gPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRSYW5kb21FbGVtZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L0dldFJhbmRvbUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDgwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRBd2F5RnJvbVplcm8gPSByZXF1aXJlKCcuLi8uLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvJyk7XHJcblxyXG4vKipcclxuKiBDcmVhdGUgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tIGBzdGFydGBcclxuKiB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYCBieSBhZHZhbmNpbmcgYnkgYHN0ZXBgLlxyXG4qXHJcbiogSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYGVuZGAgYSB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXHJcbipcclxuKiBDZXJ0YWluIHZhbHVlcyBmb3IgYHN0YXJ0YCBhbmQgYGVuZGAgKGVnLiBOYU4vdW5kZWZpbmVkL251bGwpIGFyZSBjdXJyZW50bHkgY29lcmNlZCB0byAwO1xyXG4qIGZvciBmb3J3YXJkIGNvbXBhdGliaWxpdHkgbWFrZSBzdXJlIHRvIHBhc3MgaW4gYWN0dWFsIG51bWJlcnMuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5BcnJheVV0aWxzI251bWJlckFycmF5U3RlcFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIC0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXHJcbiogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgbnVtYmVycy5cclxuKiBAZXhhbXBsZVxyXG4qIE51bWJlckFycmF5U3RlcCg0KTtcclxuKiAvLyA9PiBbMCwgMSwgMiwgM11cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgxLCA1KTtcclxuKiAvLyA9PiBbMSwgMiwgMywgNF1cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgwLCAyMCwgNSk7XHJcbiogLy8gPT4gWzAsIDUsIDEwLCAxNV1cclxuKlxyXG4qIE51bWJlckFycmF5U3RlcCgwLCAtNCwgLTEpO1xyXG4qIC8vID0+IFswLCAtMSwgLTIsIC0zXVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDEsIDQsIDApO1xyXG4qIC8vID0+IFsxLCAxLCAxXVxyXG4qXHJcbiogTnVtYmVyQXJyYXlTdGVwKDApO1xyXG4qIC8vID0+IFtdXHJcbiovXHJcbnZhciBOdW1iZXJBcnJheVN0ZXAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcClcclxue1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XHJcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHsgZW5kID0gbnVsbDsgfVxyXG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMTsgfVxyXG5cclxuICAgIGlmIChlbmQgPT09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICB2YXIgdG90YWwgPSBNYXRoLm1heChSb3VuZEF3YXlGcm9tWmVybygoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXHJcbiAgICB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goc3RhcnQpO1xyXG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyQXJyYXlTdGVwO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L051bWJlckFycmF5U3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gODA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGZyb20gdGhlIHF1aWNrc2VsZWN0IG5wbSBwYWNrYWdlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9xdWlja3NlbGVjdFxyXG4vLyAgQ29kZWQgYnkgaHR0cHM6Ly93d3cubnBtanMuY29tL35tb3VybmVyIChWbGFkaW1pciBBZ2Fmb25raW4pXHJcblxyXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1JpdmVzdF9hbGdvcml0aG1cclxuXHJcbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxyXG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xyXG4vLyBUaGUgay10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgKGsgLSBsZWZ0ICsgMSl0aCBzbWFsbGVzdCB2YWx1ZSBpbiBbbGVmdCwgcmlnaHRdXHJcblxyXG52YXIgUXVpY2tTZWxlY3QgPSBmdW5jdGlvbiAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSlcclxue1xyXG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcclxuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcclxuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xyXG5cclxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcclxuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XHJcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XHJcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcclxuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xyXG5cclxuICAgICAgICAgICAgUXVpY2tTZWxlY3QoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdCA9IGFycltrXTtcclxuICAgICAgICB2YXIgaSA9IGxlZnQ7XHJcbiAgICAgICAgdmFyIGogPSByaWdodDtcclxuXHJcbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xyXG5cclxuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCBqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xyXG5cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBqLS07XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dhcChhcnIsIGxlZnQsIGopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaiA8PSBrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGVmdCA9IGogKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGsgPD0gailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gaiAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc3dhcCAoYXJyLCBpLCBqKVxyXG57XHJcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xyXG4gICAgYXJyW2ldID0gYXJyW2pdO1xyXG4gICAgYXJyW2pdID0gdG1wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZSAoYSwgYilcclxue1xyXG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFF1aWNrU2VsZWN0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1F1aWNrU2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNwbGljZU9uZSA9IHJlcXVpcmUoJy4vU3BsaWNlT25lJyk7XHJcblxyXG4vKipcclxuKiBSZW1vdmVzIGEgcmFuZG9tIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cclxuKlxyXG4qIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgYXJlIG5vIGFycmF5IGl0ZW1zIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZVxyXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXHJcbipcclxuKiBAbWV0aG9kXHJcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIC0gT3B0aW9uYWwgcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXHJcbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyByZW1vdmVkLlxyXG4qL1xyXG5cclxudmFyIFJlbW92ZVJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0LCBsZW5ndGgpXHJcbntcclxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxyXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgfVxyXG5cclxuICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gU3BsaWNlT25lKGFycmF5LCByYW5kb21JbmRleCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZVJhbmRvbUVsZW1lbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gODA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vISBzdGFibGUuanMgMC4xLjYsIGh0dHBzOi8vZ2l0aHViLmNvbS9Ud28tU2NyZWVuL3N0YWJsZVxyXG4vLyEgwqkgMjAxNyBBbmdyeSBCeXRlcyBhbmQgY29udHJpYnV0b3JzLiBNSVQgbGljZW5zZWQuXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4vLyBBIHN0YWJsZSBhcnJheSBzb3J0LCBiZWNhdXNlIGBBcnJheSNzb3J0KClgIGlzIG5vdCBndWFyYW50ZWVkIHN0YWJsZS5cclxuLy8gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBtZXJnZSBzb3J0LCB3aXRob3V0IHJlY3Vyc2lvbi5cclxuXHJcbnZhciBzdGFibGUgPSBmdW5jdGlvbihhcnIsIGNvbXApIHtcclxuICAgIHJldHVybiBleGVjKGFyci5zbGljZSgpLCBjb21wKTtcclxufTtcclxuXHJcbnN0YWJsZS5pbnBsYWNlID0gZnVuY3Rpb24oYXJyLCBjb21wKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZXhlYyhhcnIsIGNvbXApO1xyXG5cclxuICAgIC8vIFRoaXMgc2ltcGx5IGNvcGllcyBiYWNrIGlmIHRoZSByZXN1bHQgaXNuJ3QgaW4gdGhlIG9yaWdpbmFsIGFycmF5LFxyXG4gICAgLy8gd2hpY2ggaGFwcGVucyBvbiBhbiBvZGQgbnVtYmVyIG9mIHBhc3Nlcy5cclxuICAgIGlmIChyZXN1bHQgIT09IGFycikge1xyXG4gICAgICAgIHBhc3MocmVzdWx0LCBudWxsLCBhcnIubGVuZ3RoLCBhcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnI7XHJcbn07XHJcblxyXG4vLyBFeGVjdXRlIHRoZSBzb3J0IHVzaW5nIHRoZSBpbnB1dCBhcnJheSBhbmQgYSBzZWNvbmQgYnVmZmVyIGFzIHdvcmsgc3BhY2UuXHJcbi8vIFJldHVybnMgb25lIG9mIHRob3NlIHR3bywgY29udGFpbmluZyB0aGUgZmluYWwgcmVzdWx0LlxyXG5mdW5jdGlvbiBleGVjKGFyciwgY29tcCkge1xyXG4gICAgaWYgKHR5cGVvZihjb21wKSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbXAgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShiKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNob3J0LWNpcmN1aXQgd2hlbiB0aGVyZSdzIG5vdGhpbmcgdG8gc29ydC5cclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgaWYgKGxlbiA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSYXRoZXIgdGhhbiBkaXZpZGluZyBpbnB1dCwgc2ltcGx5IGl0ZXJhdGUgY2h1bmtzIG9mIDEsIDIsIDQsIDgsIGV0Yy5cclxuICAgIC8vIENodW5rcyBhcmUgdGhlIHNpemUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgaGFuZCBpbiBtZXJnZSBzb3J0LlxyXG4gICAgLy8gU3RvcCB3aGVuIHRoZSBsZWZ0LWhhbmQgY292ZXJzIGFsbCBvZiB0aGUgYXJyYXkuXHJcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGxlbik7XHJcbiAgICBmb3IgKHZhciBjaGsgPSAxOyBjaGsgPCBsZW47IGNoayAqPSAyKSB7XHJcbiAgICAgICAgcGFzcyhhcnIsIGNvbXAsIGNoaywgYnVmZmVyKTtcclxuXHJcbiAgICAgICAgdmFyIHRtcCA9IGFycjtcclxuICAgICAgICBhcnIgPSBidWZmZXI7XHJcbiAgICAgICAgYnVmZmVyID0gdG1wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbi8vIFJ1biBhIHNpbmdsZSBwYXNzIHdpdGggdGhlIGdpdmVuIGNodW5rIHNpemUuXHJcbnZhciBwYXNzID0gZnVuY3Rpb24oYXJyLCBjb21wLCBjaGssIHJlc3VsdCkge1xyXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICAvLyBTdGVwIHNpemUgLyBkb3VibGUgY2h1bmsgc2l6ZS5cclxuICAgIHZhciBkYmwgPSBjaGsgKiAyO1xyXG4gICAgLy8gQm91bmRzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBjaHVua3MuXHJcbiAgICB2YXIgbCwgciwgZTtcclxuICAgIC8vIEl0ZXJhdG9ycyBvdmVyIHRoZSBsZWZ0IGFuZCByaWdodCBjaHVuay5cclxuICAgIHZhciBsaSwgcmk7XHJcblxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHBhaXJzIG9mIGNodW5rcy5cclxuICAgIGZvciAobCA9IDA7IGwgPCBsZW47IGwgKz0gZGJsKSB7XHJcbiAgICAgICAgciA9IGwgKyBjaGs7XHJcbiAgICAgICAgZSA9IHIgKyBjaGs7XHJcbiAgICAgICAgaWYgKHIgPiBsZW4pIHIgPSBsZW47XHJcbiAgICAgICAgaWYgKGUgPiBsZW4pIGUgPSBsZW47XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgYm90aCBjaHVua3MgaW4gcGFyYWxsZWwuXHJcbiAgICAgICAgbGkgPSBsO1xyXG4gICAgICAgIHJpID0gcjtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBDb21wYXJlIHRoZSBjaHVua3MuXHJcbiAgICAgICAgICAgIGlmIChsaSA8IHIgJiYgcmkgPCBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdvcmtzIGZvciBhIHJlZ3VsYXIgYHNvcnQoKWAgY29tcGF0aWJsZSBjb21wYXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGFsc28gZm9yIGEgc2ltcGxlIGNvbXBhcmF0b3IgbGlrZTogYGEgPiBiYFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAoYXJyW2xpXSwgYXJyW3JpXSkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBhcnJbcmkrK107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm90aGluZyB0byBjb21wYXJlLCBqdXN0IGZsdXNoIHdoYXQncyBsZWZ0LlxyXG4gICAgICAgICAgICBlbHNlIGlmIChsaSA8IHIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpIDwgZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBhcnJbcmkrK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQm90aCBpdGVyYXRvcnMgYXJlIGF0IHRoZSBjaHVuayBlbmRzLlxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRXhwb3J0IHVzaW5nIENvbW1vbkpTIG9yIHRvIHRoZSB3aW5kb3cuXHJcbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhYmxlO1xyXG59XHJcbmVsc2Uge1xyXG4gICAgd2luZG93LnN0YWJsZSA9IHN0YWJsZTtcclxufVxyXG5cclxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL2FycmF5L1N0YWJsZVNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDgwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcclxuICAgIEdldFJhbmRvbUVsZW1lbnQ6IHJlcXVpcmUoJy4vR2V0UmFuZG9tRWxlbWVudCcpLFxyXG4gICAgTnVtYmVyQXJyYXk6IHJlcXVpcmUoJy4vTnVtYmVyQXJyYXknKSxcclxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcclxuICAgIFF1aWNrU2VsZWN0OiByZXF1aXJlKCcuL1F1aWNrU2VsZWN0JyksXHJcbiAgICBSYW5nZTogcmVxdWlyZSgnLi9SYW5nZScpLFxyXG4gICAgUmVtb3ZlUmFuZG9tRWxlbWVudDogcmVxdWlyZSgnLi9SZW1vdmVSYW5kb21FbGVtZW50JyksXHJcbiAgICBSb3RhdGVMZWZ0OiByZXF1aXJlKCcuL1JvdGF0ZUxlZnQnKSxcclxuICAgIFJvdGF0ZVJpZ2h0OiByZXF1aXJlKCcuL1JvdGF0ZVJpZ2h0JyksXHJcbiAgICBTaHVmZmxlOiByZXF1aXJlKCcuL1NodWZmbGUnKSxcclxuICAgIFNwbGljZU9uZTogcmVxdWlyZSgnLi9TcGxpY2VPbmUnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9hcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBhbW91bnQgdGhlIEdhbWUgT2JqZWN0IGlzIHZpc3VhbGx5IG9mZnNldCBmcm9tIGl0cyB4IGNvb3JkaW5hdGUuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgd2lkdGggKiBvcmlnaW4ueGAuXHJcbiogSXQgd2lsbCBvbmx5IGJlID4gMCBpZiBvcmlnaW4ueCBpcyBub3QgZXF1YWwgdG8gemVyby5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRYXHJcbiogQHJlYWRPbmx5XHJcbiovXHJcblxyXG52YXIgR2V0T2Zmc2V0WCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0T2Zmc2V0WDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gODA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRoZSBhbW91bnQgdGhlIEdhbWUgT2JqZWN0IGlzIHZpc3VhbGx5IG9mZnNldCBmcm9tIGl0cyB4IGNvb3JkaW5hdGUuXHJcbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgd2lkdGggKiBvcmlnaW4ueGAuXHJcbiogSXQgd2lsbCBvbmx5IGJlID4gMCBpZiBvcmlnaW4ueCBpcyBub3QgZXF1YWwgdG8gemVyby5cclxuKlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRYXHJcbiogQHJlYWRPbmx5XHJcbiovXHJcblxyXG52YXIgR2V0T2Zmc2V0WSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxyXG57XHJcbiAgICByZXR1cm4gZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9mZnNldFk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL0dldE9mZnNldFkuanNcbi8vIG1vZHVsZSBpZCA9IDgxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzLkJvdW5kc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2VudGVyT246IHJlcXVpcmUoJy4vQ2VudGVyT24nKSxcclxuICAgIEdldEJvdHRvbTogcmVxdWlyZSgnLi9HZXRCb3R0b20nKSxcclxuICAgIEdldENlbnRlclg6IHJlcXVpcmUoJy4vR2V0Q2VudGVyWCcpLFxyXG4gICAgR2V0Q2VudGVyWTogcmVxdWlyZSgnLi9HZXRDZW50ZXJZJyksXHJcbiAgICBHZXRMZWZ0OiByZXF1aXJlKCcuL0dldExlZnQnKSxcclxuICAgIEdldE9mZnNldFg6IHJlcXVpcmUoJy4vR2V0T2Zmc2V0WCcpLFxyXG4gICAgR2V0T2Zmc2V0WTogcmVxdWlyZSgnLi9HZXRPZmZzZXRZJyksXHJcbiAgICBHZXRSaWdodDogcmVxdWlyZSgnLi9HZXRSaWdodCcpLFxyXG4gICAgR2V0VG9wOiByZXF1aXJlKCcuL0dldFRvcCcpLFxyXG4gICAgU2V0Qm90dG9tOiByZXF1aXJlKCcuL1NldEJvdHRvbScpLFxyXG4gICAgU2V0Q2VudGVyWDogcmVxdWlyZSgnLi9TZXRDZW50ZXJYJyksXHJcbiAgICBTZXRDZW50ZXJZOiByZXF1aXJlKCcuL1NldENlbnRlclknKSxcclxuICAgIFNldExlZnQ6IHJlcXVpcmUoJy4vU2V0TGVmdCcpLFxyXG4gICAgU2V0UmlnaHQ6IHJlcXVpcmUoJy4vU2V0UmlnaHQnKSxcclxuICAgIFNldFRvcDogcmVxdWlyZSgnLi9TZXRUb3AnKVxyXG4gICAgXHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvYm91bmRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFZhbHVlID0gcmVxdWlyZSgnLi9HZXRWYWx1ZScpO1xyXG52YXIgQ2xhbXAgPSByZXF1aXJlKCcuLi8uLi9tYXRoL0NsYW1wJyk7XHJcblxyXG52YXIgR2V0TWluTWF4VmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIG1pbiwgbWF4LCBkZWZhdWx0VmFsdWUpXHJcbntcclxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkgeyBkZWZhdWx0VmFsdWUgPSBtaW47IH1cclxuXHJcbiAgICB2YXIgdmFsdWUgPSBHZXRWYWx1ZShzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcclxuXHJcbiAgICByZXR1cm4gQ2xhbXAodmFsdWUsIG1pbiwgbWF4KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2V0TWluTWF4VmFsdWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L0dldE1pbk1heFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIENyZWF0ZXMgYSBuZXcgT2JqZWN0IHVzaW5nIGFsbCB2YWx1ZXMgZnJvbSBvYmoxIGFuZCBvYmoyLlxyXG4vLyAgSWYgYSB2YWx1ZSBleGlzdHMgaW4gYm90aCBvYmoxIGFuZCBvYmoyLCB0aGUgdmFsdWUgaW4gb2JqMSBpcyB1c2VkLlxyXG5cclxudmFyIENsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5cclxudmFyIE1lcmdlID0gZnVuY3Rpb24gKG9iajEsIG9iajIpXHJcbntcclxuICAgIHZhciBjbG9uZSA9IENsb25lKG9iajEpO1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmoyKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghY2xvbmUuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBvYmoyW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbG9uZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVyZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L01lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIENyZWF0ZXMgYSBuZXcgT2JqZWN0IHVzaW5nIGFsbCB2YWx1ZXMgZnJvbSBvYmoxLlxyXG4vLyAgXHJcbi8vICBUaGVuIHNjYW5zIG9iajIuIElmIGEgcHJvcGVydHkgaXMgZm91bmQgaW4gb2JqMiB0aGF0ICphbHNvKiBleGlzdHMgaW4gb2JqMSxcclxuLy8gIHRoZSB2YWx1ZSBmcm9tIG9iajIgaXMgdXNlZCwgb3RoZXJ3aXNlIHRoZSBwcm9wZXJ0eSBpcyBza2lwcGVkLlxyXG5cclxudmFyIENsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xyXG5cclxudmFyIE1lcmdlUmlnaHQgPSBmdW5jdGlvbiAob2JqMSwgb2JqMilcclxue1xyXG4gICAgdmFyIGNsb25lID0gQ2xvbmUob2JqMSk7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIG9iajIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKGNsb25lLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbG9uZVtrZXldID0gb2JqMltrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2xvbmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUmlnaHQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvb2JqZWN0L01lcmdlUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDgxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUGhhc2VyLlV0aWxzLk9iamVjdFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgQ2xvbmU6IHJlcXVpcmUoJy4vQ2xvbmUnKSxcclxuICAgIEV4dGVuZDogcmVxdWlyZSgnLi9FeHRlbmQnKSxcclxuICAgIEdldEFkdmFuY2VkVmFsdWU6IHJlcXVpcmUoJy4vR2V0QWR2YW5jZWRWYWx1ZScpLFxyXG4gICAgR2V0TWluTWF4VmFsdWU6IHJlcXVpcmUoJy4vR2V0TWluTWF4VmFsdWUnKSxcclxuICAgIEdldFZhbHVlOiByZXF1aXJlKCcuL0dldFZhbHVlJyksXHJcbiAgICBJc1BsYWluT2JqZWN0OiByZXF1aXJlKCcuL0lzUGxhaW5PYmplY3QnKSxcclxuICAgIE1lcmdlOiByZXF1aXJlKCcuL01lcmdlJyksXHJcbiAgICBNZXJnZVJpZ2h0OiByZXF1aXJlKCcuL01lcmdlUmlnaHQnKVxyXG5cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9vYmplY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogUmVwbGFjZXMgJTEsICUyLCAlMyBldGMgaW4gdGhlIFN0cmluZyB3aXRoIHRoZSB2YWx1ZXNcclxuICogZ2l2ZW4gaW4gdGhlIGFycmF5LiBWYWx1ZXMgYXJlIGNhc3QgdG8gc3RyaW5ncy5cclxuICogSWYgbm8gdmFsdWUgZXhpc3RzIGFuIGVtcHR5IHN0cmluZyBpcyBpbnNlcnRlZC5cclxuICogXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1hcmtlcnNcclxuICogQHBhcmFtIHthcnJheX0gdmFsdWVzIC0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIHRvIHJlcGxhY2UgdGhlIG1hcmtlcnMgd2l0aFxyXG4qL1xyXG52YXIgRm9ybWF0ID0gZnVuY3Rpb24gKHN0cmluZywgdmFsdWVzKVxyXG57XHJcbiAgICBzdHJpbmcucmVwbGFjZSgvJShbMC05XSspL2csIGZ1bmN0aW9uIChzLCBuKVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXNbTnVtYmVyKG4pIC0gMV07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc3RyaW5nO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGb3JtYXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdXRpbHMvc3RyaW5nL0Zvcm1hdC5qc1xuLy8gbW9kdWxlIGlkID0gODE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4qIFRha2VzIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldmVyc2VzIGl0LCByZXR1cm5pbmcgdGhlIHJldmVyc2VkIHN0cmluZy5cclxuKiBGb3IgZXhhbXBsZSBpZiBnaXZlbiB0aGUgc3RyaW5nIGBBdGFyaSA1MjBTVGAgaXQgd291bGQgcmV0dXJuIGBUUzAyNSBpcmF0QWAuXHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5yZXZlcnNlU3RyaW5nXHJcbiogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gYmUgcmV2ZXJzZWQuXHJcbiogQHJldHVybiB7c3RyaW5nfSBUaGUgcmV2ZXJzZWQgc3RyaW5nLlxyXG4qL1xyXG52YXIgUmV2ZXJzZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpXHJcbntcclxuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmV2ZXJzZVN0cmluZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi91dGlscy9zdHJpbmcvUmV2ZXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gODE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIFBhZDogcmVxdWlyZSgnLi9QYWQnKSxcclxuICAgIEZvcm1hdDogcmVxdWlyZSgnLi9Gb3JtYXQnKSxcclxuICAgIFJldmVyc2U6IHJlcXVpcmUoJy4vUmV2ZXJzZScpXHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3V0aWxzL3N0cmluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=