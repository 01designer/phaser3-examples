(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 330);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ },
/* 1 */
/***/ function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,

    IMAGE: 20,

    state: {

        PENDING: 0,
        INSTALLED: 1,

        BOOT: 0,
        INIT: 1,
        PRELOAD: 2,
        CREATE: 3,
        UPDATE: 4,
        RENDER: 5,
        SHUTDOWN: 6

    },

    blendModes: {

        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16

    },

    scaleModes: {

        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1

    }

};

module.exports = CONST;


/***/ },
/* 2 */
/***/ function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ },
/* 3 */
/***/ function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(329)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ },
/* 6 */
/***/ function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ },
/* 7 */
/***/ function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Rectangle;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(209);
var CONST = __webpack_require__(3);
var XHRLoader = __webpack_require__(210);
var XHRSettings = __webpack_require__(25);
var MergeXHRSettings = __webpack_require__(46);

var File = function (type, key, url, responseType, xhrSettings)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ },
/* 9 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    // console.log('FactoryContainer is alive');

    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            // console.log('Already registered', factory.KEY);

            return this.getType(factory.KEY);
        }

        // console.log('registering', factory.KEY);

        factories[factory.KEY] = {
            add: factory.add,
            make: factory.make
        };

        return factory;
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                // console.log('Loading', factory);

                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ },
/* 10 */
/***/ function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    if (range <= 0)
    {
        return 0;
    }

    var result = (value - min) % range;

    if (result < 0)
    {
        result += range;
    }

    return result + min;
};

module.exports = Wrap;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(10);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ },
/* 12 */
/***/ function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetObjectValue = function (source, key, defaultValue)
{
    if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                break;
            }
        }

        return value;
    }
    else
    {
        return (source.hasOwnProperty(key)) ? source[key] : defaultValue;
    }
};

module.exports = GetObjectValue;


/***/ },
/* 13 */
/***/ function(module, exports) {

var Event = function (type)
{
    this.type = type;

    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(90);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var ImageFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(62);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Children: __webpack_require__(27),
    Color: __webpack_require__(78),
    Data: __webpack_require__(79),
    Transform: __webpack_require__(80)

};


/***/ },
/* 18 */
/***/ function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ },
/* 19 */
/***/ function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ },
/* 20 */
/***/ function(module, exports) {

/**
* Convert a distance along this curve into a `time` value which will be between 0 and 1.
* 
* For example if this curve has a length of 100 pixels then `findT(50)` would return `0.5`.
*
* @method Phaser.Hermite#findT
* @param {integer} distance - The distance into the curve in pixels. Should be a positive integer.
* @return {number} The time (`t`) value, a float between 0 and 1.
*/
var FindT = function (curve, distance)
{
    if (distance <= 0)
    {
        return 0;
    }

    //  Find the _points which bracket the distance value
    var ti = Math.floor(distance / curve.length * curve._accuracy);

    while (ti > 0 && curve._points[ti] > distance)
    {
        ti--;
    }

    while (ti < curve._accuracy && curve._points[ti] < distance)
    {
        ti++;
    }

    //  Linear interpolation to get a more accurate fix
    var dt = curve._points[ti] - curve._points[ti - 1];
    var d = distance - curve._points[ti - 1];

    return ((ti - 1) / curve._accuracy) + d / (dt * curve._accuracy);
};

module.exports = FindT;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Get a point on the curve using the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getPoint
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} An Object with the x, y coordinate of the curve at the specified `t` value set in its `x` and `y` properties.
*/
var GetPoint = function (curve, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    if (t < 0)
    {
        t = 0;
    }

    if (t > 1)
    {
        t = 1;
    }

    var t2 = t * t;
    var t3 = t * t2;

    out.x = t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x;
    out.y = t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y;

    return out;
};

module.exports = GetPoint;


/***/ },
/* 22 */
/***/ function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ },
/* 23 */
/***/ function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ },
/* 24 */
/***/ function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ },
/* 25 */
/***/ function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ },
/* 26 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 27 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child, skipTransform)
    {
        if (skipTransform === undefined) { skipTransform = false; }

        // console.log('--->', this.gameObject.name, 'adds new child:', child.name);

        if (child.parent === this)
        {
            // console.log('Children.add 1');
            return child;
        }
        else if (child.parent)
        {
            // console.log('Children.add 2');
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            // console.log(this.gameObject.name, 'adds transform from', child.name);
            this.gameObject.transform.add(child.transform);
        }

        // console.log('<--- end');

        return child;
    },

    addAt: function (child, index, skipTransform)
    {
        if (index === undefined) { index = 0; }
        if (skipTransform === undefined) { skipTransform = false; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        if (!skipTransform && this.gameObject.transform && child.transform)
        {
            this.gameObject.transform.add(child.transform);
        }

        return child;

    },

    addMultiple: function (children, skipTransform)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i], skipTransform);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child, skipTransform)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }
        
        return child;
    },

    removeAt: function (index, skipTransform)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);

            if (!skipTransform && this.gameObject.transform && child.transform)
            {
                this.gameObject.transform.remove(child.transform);
            }
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild, skipTransform)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild, skipTransform);
            }

            this.remove(oldChild, skipTransform);

            this.addAt(newChild, index, skipTransform);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2, skipTransform)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1, skipTransform);

        parentChildren.remove(child2, skipTransform);

        this.addAt(child2, index1, skipTransform);

        parentChildren.addAt(child1, index2, skipTransform);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var CanvasPool = __webpack_require__(29);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    console.log('Features.init');

    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    * 
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    * 
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    return {
        create: create,
        create2D: create2D,
        createWebGL: createWebGL,
        first: first,
        remove: remove,
        total: total,
        free: free,
        pool: pool
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ },
/* 30 */
/***/ function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var MATH_CONST = __webpack_require__(2);
var Component = __webpack_require__(17);
var WrapAngle = __webpack_require__(11);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
* It hides away the 'private' stuff and exposes only the useful getters, setters and properties.
*
* @class
*/

//  Phaser.Texture and Phaser.Frame objects passed in here, instead of looked-up.
//  Allows override from non-standard GO types

var GameObject = function (state, x, y, texture, frame, parent)
{
    this.state = state;

    this.game = state.game;

    this.name = '';

    this.type = 0;

    this.parent = parent;

    //  Texture is globally shared between GameObjects, not specific to this one
    this.texture = texture;

    //  Frame is globally shared between GameObjects, not specific to this one
    this.frame = frame;

    //  All GameObjects have the following components, always:
    this.transform = new Component.Transform(this, x, y);

    //  Optional? Maybe set on a per GO basis?
    this.data = new Component.Data(this);

    this.color = new Component.Color(this);

    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------
    //  The following properties are debatable to have in this class
    //  ----------------------------------------------------------------
    //  ----------------------------------------------------------------

    this.scaleMode = CONST.scaleModes.DEFAULT;

    //  Allows you to turn off a GameObject from rendering, but still render its children (if it has any)
    //  Maybe this should move?
    // this.skipRender = (key === undefined);
    this.skipRender = false;

    this.visible = true;

    //  Either null, or the Children component
    this.children = null;

    this.exists = true;
};

GameObject.prototype.constructor = GameObject;

GameObject.prototype = {

    preUpdate: function ()
    {
        //  NOOP
    },

    update: function ()
    {
        //  NOOP
    },

    postUpdate: function ()
    {
        //  NOOP
    },

    render: function ()
    {
        //  NOOP
    },

    destroy: function ()
    {
        //  NOOP
    }

};

Object.defineProperties(GameObject.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorX;
        },

        set: function (value)
        {
            this.transform._anchorX = value;
            this.transform.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._anchorY;
        },

        set: function (value)
        {
            this.transform._anchorY = value;
            this.transform.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

    //  Color getters / setters

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.color._alpha;
        },

        set: function (value)
        {
            this.color.alpha = value;
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this.color._blendMode;
        },

        set: function (value)
        {
            this.color.blendMode = value;
        }

    }

});

module.exports = GameObject;


/***/ },
/* 32 */
/***/ function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ },
/* 33 */
/***/ function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

var GetPoint = __webpack_require__(21);

/**
* Calculate and return the angle, in radians, of the curves tangent based on time.
*
* @method Phaser.Hermite#getAngle
* @param {number} [t=0] - The `t` (time) value at which to find the angle. Must be between 0 and 1.
* @return {number} The angle of the line at the specified `t` time value along the curve. The value is in radians.
*/
var GetAngle = function (curve, t)
{
    if (t === undefined) { t = 0; }

    GetPoint(curve, t - 0.01, curve._temp1);
    GetPoint(curve, t + 0.01, curve._temp2);

    return Math.atan2(curve._temp2.y - curve._temp1.y, curve._temp2.x - curve._temp1.x);
};

module.exports = GetAngle;


/***/ },
/* 35 */
/***/ function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ },
/* 36 */
/***/ function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ },
/* 37 */
/***/ function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    if (x1 === undefined) { x1 = 0; }
    if (y1 === undefined) { y1 = 0; }
    if (x2 === undefined) { x2 = 0; }
    if (y2 === undefined) { y2 = 0; }

    this.x1 = x1;

    this.y1 = y1;

    this.x2 = x2;

    this.y2 = y2;
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Wrap = __webpack_require__(10);
var Angle = __webpack_require__(6);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ },
/* 39 */
/***/ function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ },
/* 40 */
/***/ function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ },
/* 41 */
/***/ function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(39);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ },
/* 43 */
/***/ function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ },
/* 44 */
/***/ function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ },
/* 45 */
/***/ function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(25);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;

};

module.exports = MergeXHRSettings;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(51);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ },
/* 49 */
/***/ function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ },
/* 50 */
/***/ function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ },
/* 51 */
/***/ function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ },
/* 52 */
/***/ function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ },
/* 53 */
/***/ function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ },
/* 54 */
/***/ function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ },
/* 55 */
/***/ function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ },
/* 56 */
/***/ function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(1);
var GetObjectValue = __webpack_require__(12);

var Settings = function (state, config)
{
    if (typeof config === 'string')
    {
        config = { key: config };
    }
    else if (config === undefined)
    {
        //  Pass the 'hasOwnProperty' checks
        config = {};
    }

    this.state = state; //  Do we actually need this reference? This could just be a property bucket

    this.status = CONST.state.PENDING;

    //  Which part of this State is currently being processed?
    //  preload, create, update, shutdown, etc
    this.op = CONST.state.BOOT;

    this.key = GetObjectValue(config, 'key', '');
    this.active = GetObjectValue(config, 'active', false);
    this.visible = GetObjectValue(config, 'visible', true);
    this.scaleMode = GetObjectValue(config, 'scaleMode', CONST.scaleModes.DEFAULT);
    this.fps = GetObjectValue(config, 'fps', 60);
    this.x = GetObjectValue(config, 'x', 0);
    this.y = GetObjectValue(config, 'y', 0);

    //  -1 means the State Manager will set it to be the Game dimensions
    this.width = GetObjectValue(config, 'width', -1);
    this.height = GetObjectValue(config, 'height', -1);
};

//  Unless we add some actual functions in here, we'll make this just return an Object instead of an instance
Settings.prototype.constructor = Settings;

module.exports = Settings;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var EventDispatcher = __webpack_require__(14);
var GameObjectFactory = __webpack_require__(305);
// var GameObjectCreator = require('./systems/GameObjectCreator');
var Loader = __webpack_require__(306);
var MainLoop = __webpack_require__(307);
var UpdateManager = __webpack_require__(308);
var Component = __webpack_require__(17);
var Camera = __webpack_require__(76);

var Systems = function (state, config)
{
    this.state = state;

    this.config = config;

    this.events;

    //  Reference to the global Game level TextureManager.
    this.textures;

    //  State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.make;
    this.input;
    this.load;
    this.tweens;
    this.mainloop;
    this.updates;

    //  State specific properties (transform, data, children, etc)
    this.camera;
    this.children;
    this.color;
    this.data;
    this.fbo;
    this.time;
    this.transform;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function ()
    {
        console.log('State.Systems.init');

        this.textures = this.state.game.textures;

        //  All of the systems can use the State level EventDispatcher, or their own
        this.events = new EventDispatcher();

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)
        //  All these to be set by a State Config package

        this.add = new GameObjectFactory(this.state);
        // this.make = GameObjectCreator(this.state);
        this.mainloop = new MainLoop(this.state, this.state.settings.fps);
        this.updates = new UpdateManager(this.state);
        this.load = new Loader(this.state);

        // this.tweens = new Phaser.TweenManager(this.state);
        // this.input = new Phaser.State.Input(this.state);
        // this.physics = new Phaser.Physics.Arcade(this.state, 800, 600);

        //  State specific properties (transform, data, children, etc)
        this.camera = new Camera(this.state, 0, 0, 800, 600);
        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);
        this.transform = this.camera.transform;

        //  Boot

        // this.input.init();

        //  Defaults

        this.state.events = this.events;
        this.state.add = this.add;
        this.state.load = this.load;
        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
        this.state.camera = this.camera;
        this.state.transform = this.camera.transform;
        this.state.textures = this.textures;



        // this.state.input = this.input;
        // this.state.state = this.state.game.state;

        //  Here we can check which Systems to install as properties into the State object
        //  (default systems always exist in here, regardless)
    },

    begin: function (timestamp, frameDelta)
    {
    },

    update: function (timestep, physicsStep)
    {
    },

    preRender: function ()
    {
    },

    end: function (fps, panic)
    {
        if (panic)
        {
            // This pattern introduces non-deterministic behavior, but in this case
            // it's better than the alternative (the application would look like it
            // was running very quickly until the simulation caught up to real
            // time).
            var discardedTime = Math.round(this.mainloop.resetFrameDelta());

            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
};

module.exports = Systems;


/***/ },
/* 59 */
/***/ function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ },
/* 60 */
/***/ function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ },
/* 61 */
/***/ function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ },
/* 62 */
/***/ function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf"))
        {
            return false;
        }
    } catch (e) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Config = __webpack_require__(73);
var DebugHeader = __webpack_require__(75);
var Device = __webpack_require__(85);

var AddToDOM = __webpack_require__(86);
var RequestAnimationFrame = __webpack_require__(89);
var DOMContentLoaded = __webpack_require__(87);

var CreateRenderer = __webpack_require__(74);
var RandomDataGenerator = __webpack_require__(275);
var StateManager = __webpack_require__(304);
var TextureManager = __webpack_require__(312);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
    * @protected
    */
    this.raf = new RequestAnimationFrame(this);

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager();

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    // this.cache = new Cache();

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = null;

    /**
    * @property {Phaser.StateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new StateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    //  Move this somewhere else? Math perhaps? Doesn't need to be a Game level system.
    this.rnd;

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        //  Probably move within Math
        this.rnd = new RandomDataGenerator(this.config.seed);

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.state.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.raf.start();
    },

    //  timestamp = DOMHighResTimeStamp
    update: function (timestamp)
    {
        this.state.step(timestamp);
    }

};

module.exports = Game;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Container = __webpack_require__(92);
var FactoryContainer = __webpack_require__(9);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Image = __webpack_require__(94);
var FactoryContainer = __webpack_require__(9);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Image(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(109),
    Ellipse: __webpack_require__(120),
    Hermite: __webpack_require__(127),
    Intersects: __webpack_require__(135),
    Line: __webpack_require__(155),
    Point: __webpack_require__(175),
    Polygon: __webpack_require__(180),
    Rectangle: __webpack_require__(207)

};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(246),
    Distance: __webpack_require__(249),
    Easing: __webpack_require__(261),
    Fuzzy: __webpack_require__(267),
    Interpolation: __webpack_require__(271),
    Pow2: __webpack_require__(274),
    Snap: __webpack_require__(279),

    //  Single functions
    Average: __webpack_require__(219),
    Bernstein: __webpack_require__(48),
    Between: __webpack_require__(49),
    CatmullRom: __webpack_require__(50),
    CeilTo: __webpack_require__(220),
    Clamp: __webpack_require__(221),
    DegToRad: __webpack_require__(222),
    Difference: __webpack_require__(223),
    Factorial: __webpack_require__(51),
    FloatBetween: __webpack_require__(224),
    FloorTo: __webpack_require__(225),
    Linear: __webpack_require__(52),
    MaxAdd: __webpack_require__(226),
    MinSub: __webpack_require__(227),
    Percent: __webpack_require__(228),
    RadToDeg: __webpack_require__(229),
    Rotate: __webpack_require__(230),
    RotateAround: __webpack_require__(231),
    RotateAroundDistance: __webpack_require__(232),
    RoundAwayFromZero: __webpack_require__(53),
    RoundTo: __webpack_require__(233),
    SinCosTableGenerator: __webpack_require__(234),
    SmootherStep: __webpack_require__(236),
    SmoothStep: __webpack_require__(235),
    Within: __webpack_require__(237),
    Wrap: __webpack_require__(10)

};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(286);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(285);


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(302)

};


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(322),
    GetRandomElement: __webpack_require__(323),
    NumberArray: __webpack_require__(60),
    NumberArrayStep: __webpack_require__(324),
    RemoveRandomElement: __webpack_require__(325),
    RotateLeft: __webpack_require__(326),
    RotateRight: __webpack_require__(327),
    Shuffle: __webpack_require__(328),
    SpliceOne: __webpack_require__(61)

};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Extend: __webpack_require__(16),
    IsPlainObject: __webpack_require__(62)

};


/***/ },
/* 72 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(59);
var GetObjectValue = __webpack_require__(12);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetObjectValue(config, 'width', 1024);
    this.height = GetObjectValue(config, 'height', 768);

    this.resolution = GetObjectValue(config, 'resolution', 1);

    this.renderType = GetObjectValue(config, 'type', CONST.AUTO);

    this.parent = GetObjectValue(config, 'parent', null);
    this.canvas = GetObjectValue(config, 'canvas', null);
    this.canvasStyle = GetObjectValue(config, 'canvasStyle', null);

    this.stateConfig = GetObjectValue(config, 'state', null);

    this.seed = GetObjectValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    this.gameTitle = GetObjectValue(config, 'title', '');
    this.gameURL = GetObjectValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetObjectValue(config, 'version', '');

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetObjectValue(config, 'banner', null) === false);

    this.hidePhaser = GetObjectValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetObjectValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetObjectValue(config, 'banner.background', defaultBannerColor);
   
    this.forceSetTimeOut = GetObjectValue(config, 'forceSetTimeOut', false);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.pixelArt = GetObjectValue(config, 'pixelArt', false);

    //  Callbacks
    this.preBoot = GetObjectValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetObjectValue(config, 'callbacks.postBoot', NOOP);
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CanvasPool = __webpack_require__(29);
var Features = __webpack_require__(28);
var CanvasRenderer = __webpack_require__(289);
var WebGLRenderer = __webpack_require__(291);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        console.log('Creating WEBGL Renderer');
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        console.log('Creating Canvas Renderer');
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.context;
    }
};

module.exports = CreateRenderer;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var CHECKSUM = __webpack_require__(77);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Component = __webpack_require__(17);
var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(11);

/**
* A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
* The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
*
* @class Phaser.Camera
* @constructor
* @param {Phaser.Game} game - Game reference to the currently running game.
* @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera
* @param {number} x - Position of the camera on the X axis
* @param {number} y - Position of the camera on the Y axis
* @param {number} width - The width of the view rectangle
* @param {number} height - The height of the view rectangle
*/
var Camera = function (state, x, y, viewportWidth, viewportHeight)
{
    /**
     * The State that this Camera belongs to. A Camera can only belong to one State, and a State only
     * has one Camera.
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    this.viewportWidth = viewportWidth;

    this.viewportHeight = viewportHeight;

    this.transform = new Component.Transform(this, x, y);

    /**
    * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
    * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
    * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
    *
    * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
    */
    // this.bounds = new Phaser.Rectangle(x, y, width, height);

    // this.bounds = new Phaser.Circle(x, y)

    /**
    * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.
    */
    this.atLimit = { x: false, y: false };
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    /**
    * Method called to ensure the camera doesn't venture outside of the game world.
    * Called automatically by Camera.update.
    *
    * @method Phaser.Camera#checkBounds
    * @protected
    */
    checkBounds: function ()
    {
        this.atLimit.x = false;
        this.atLimit.y = false;

        // var vx = this.view.x + this._shake.x;
        // var vw = this.view.right + this._shake.x;
        // var vy = this.view.y + this._shake.y;
        // var vh = this.view.bottom + this._shake.y;

        var vx = this.x;
        var vw = this.x + this.viewportWidth;
        var vy = this.y;
        var vh = this.y + this.viewportHeight;

        //  Make sure we didn't go outside the cameras bounds
        if (vx <= this.bounds.x * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = this.bounds.x * this.scale.x;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vw >= this.bounds.right * this.scale.x)
        {
            this.atLimit.x = true;
            this.view.x = (this.bounds.right * this.scale.x) - this.width;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.x = 0;
            }
        }

        if (vy <= this.bounds.top * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = this.bounds.top * this.scale.y;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

        if (vh >= this.bounds.bottom * this.scale.y)
        {
            this.atLimit.y = true;
            this.view.y = (this.bounds.bottom * this.scale.y) - this.height;

            if (!this._shake.shakeBounds)
            {
                //  The camera is up against the bounds, so reset the shake
                this._shake.y = 0;
            }
        }

    }

};

Object.defineProperties(Camera.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX;
        },

        set: function (value)
        {
            this.transform._posX = value;
            this.transform.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY;
        },

        set: function (value)
        {
            this.transform._posY = value;
            this.transform.dirty = true;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posX + (this.viewportWidth * this.transform._scaleX);
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.transform._posY + (this.viewportHeight * this.transform._scaleY);
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX;
        },

        set: function (value)
        {
            this.transform._scaleX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY;
        },

        set: function (value)
        {
            this.transform._scaleY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotX;
        },

        set: function (value)
        {
            this.transform._pivotX = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this.transform._pivotY;
        },

        set: function (value)
        {
            this.transform._pivotY = value;
            this.transform.dirty = true;
            this.transform.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this.transform._rotation;
        },

        set: function (value)
        {
            if (this.transform._rotation === value)
            {
                return;
            }

            this.transform._rotation = value;
            this.transform.dirty = true;

            if (this.transform._rotation % MATH_CONST.PI2)
            {
                this.transform.cache.sr = Math.sin(this.transform._rotation);
                this.transform.cache.cr = Math.cos(this.transform._rotation);
                this.transform.updateCache();
                this.transform.hasLocalRotation = true;
            }
            else
            {
                this.transform.hasLocalRotation = false;
            }
        }

    },

});

module.exports = Camera;


/***/ },
/* 77 */
/***/ function(module, exports) {

var CHECKSUM = {
build: 'bb3f6b90-dd1b-11e6-9f7f-6937ccaffca9'
};
module.exports = CHECKSUM;

/***/ },
/* 78 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ },
/* 79 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH_CONST = __webpack_require__(2);
var WrapAngle = __webpack_require__(11);

/**
* 2D Transformation Component.
*
* @class
*/
var Transform = function (gameObject, x, y, scaleX, scaleY)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }

    this.gameObject = gameObject;

    this.state = (gameObject.state) ? gameObject.state : gameObject.parent.state;

    this.game = this.state.game;

    //  a = scale X
    //  b = shear Y
    //  c = shear X
    //  d = scale Y
    //  tx / ty = translation

    //  World Transform
    this.world = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Previous Transform (used for interpolation)
    this.old = { a: scaleX, b: 0, c: 0, d: scaleY, tx: x, ty: y };

    //  Cached Transform Calculations
    this.cache = { a: 1, b: 0, c: 0, d: 1, sr: 0, cr: 0 };

    //  GL Vertex Data
    this.glVertextData = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };

    //  Canvas SetTransform data
    this.canvasData = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0, dx: 0, dy: 0 };

    this.immediate = false;

    this.interpolate = false;

    this.hasLocalRotation = false;

    //  Private value holders, accessed via the getters and setters
    this._posX = x;
    this._posY = y;
    this._scaleX = scaleX;
    this._scaleY = scaleY;
    this._rotation = 0;
    this._pivotX = 0;
    this._pivotY = 0;
    this._anchorX = 0;
    this._anchorY = 0;

    this._worldRotation = 0;
    this._worldScaleX = scaleX;
    this._worldScaleY = scaleY;

    this._dirty = true;
    this._dirtyVertex = true;

    this.state.sys.updates.add(this);

    //  The parent Transform (NOT the parent GameObject, although very often they are related)
    this.parent = null;

    //  Any child Transforms of this one - note that they don't have to belong to Game Objects
    //  that are children of the owner of this Transform
    this.children = [];
};

Transform.prototype.constructor = Transform;

Transform.prototype = {

    add: function (child)
    {
        return this.addAt(child, this.children.length);
    },

    addAt: function (child, index)
    {
        //  Invalid child?
        if (child === this || child.parent === this || index < 0 || index > this.children.length)
        {
            console.log('Invalid child');
            return child;
        }

        //  Child already parented? Remove it
        if (child.parent)
        {
            child.parent.remove(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        this.dirty = true;

        this.updateAncestors();

        return child;
    },

    remove: function (child)
    {
        //  Invalid child?
        if (child === this || child.parent !== this)
        {
            return child;
        }

        var index = this.children.indexOf(child);

        if (index !== -1)
        {
            return this.removeAt(index);
        }
    },

    removeAt: function (index)
    {
        //  Valid index?
        if (index >= 0 && index < this.children.length)
        {
            var child = this.children.splice(index, 1);

            if (child[0])
            {
                child[0].parent = null;

                return child[0];
            }
        }
    },

    enableInterpolation: function ()
    {
        this.interpolate = true;

        this.syncInterpolation();
    },

    syncInterpolation: function ()
    {
        this._dirty = true;

        this.update();

        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;
    },

    disableInterpolation: function ()
    {
        this.interpolate = false;
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._posX = x;
        this._posY = y;

        return this.update();
    },

    setScale: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._scaleX = x;
        this._scaleY = y;
        this.updateCache();

        return this.update();
    },

    setPivot: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._pivotX = x;
        this._pivotY = y;

        return this.update();
    },

    setAnchor: function (x, y)
    {
        if (y === undefined) { y = x; }

        this._anchorX = x;
        this._anchorY = y;

        this.dirty = true;
    },

    setRotation: function (rotation)
    {
        this.rotation = rotation;

        return this.update();
    },

    //  Updates the Transform.world object, ready for rendering
    //  Assuming this Transform is a root node (i.e. no transform parent)
    updateFromRoot: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromRoot');

            world.a = this.cache.a;
            world.b = this.cache.b;
            world.c = this.cache.c;
            world.d = this.cache.d;
            world.tx = this._posX - ((this._pivotX * this.cache.a) + (this._pivotY * this.cache.c));
            world.ty = this._posY - ((this._pivotX * this.cache.b) + (this._pivotY * this.cache.d));

            this._worldRotation = Math.atan2(-this.cache.c, this.cache.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromRoot FAST');

            world.a = this._scaleX;
            world.b = 0;
            world.c = 0;
            world.d = this._scaleY;
            world.tx = this._posX - (this._pivotX * this._scaleX);
            world.ty = this._posY - (this._pivotY * this._scaleY);

            this._worldRotation = 0;
        }

        this._worldScaleX = this._scaleX;
        this._worldScaleY = this._scaleY;

        return this;
    },

    updateFromParent: function ()
    {
        var old = this.old;
        var world = this.world;

        old.a = world.a;
        old.b = world.b;
        old.c = world.c;
        old.d = world.d;
        old.tx = world.tx;
        old.ty = world.ty;

        var parent = this.parent.world;
        var tx = 0;
        var ty = 0;

        if (this.hasLocalRotation)
        {
            // console.log(this.name, 'Transform.updateFromParent', this.parent.name);

            var a = this.cache.a;
            var b = this.cache.b;
            var c = this.cache.c;
            var d = this.cache.d;

            tx = this._posX - ((this._pivotX * a) + (this._pivotY * c));
            ty = this._posY - ((this._pivotX * b) + (this._pivotY * d));

            world.a = (a * parent.a) + (b * parent.c);
            world.b = (a * parent.b) + (b * parent.d);
            world.c = (c * parent.a) + (d * parent.c);
            world.d = (c * parent.b) + (d * parent.d);
        }
        else
        {
            // console.log(this.name, 'Transform.updateFromParent FAST', this.parent.name);

            tx = this._posX - (this._pivotX * this._scaleX);
            ty = this._posY - (this._pivotY * this._scaleY);

            world.a = this._scaleX * parent.a;
            world.b = this._scaleX * parent.b;
            world.c = this._scaleY * parent.c;
            world.d = this._scaleY * parent.d;
        }

        this._worldRotation = Math.atan2(-this.world.c, this.world.d);

        world.tx = (tx * parent.a) + (ty * parent.c) + parent.tx;
        world.ty = (tx * parent.b) + (ty * parent.d) + parent.ty;

        this._worldScaleX = this._scaleX * Math.sqrt((world.a * world.a) + (world.c * world.c));
        this._worldScaleY = this._scaleY * Math.sqrt((world.b * world.b) + (world.d * world.d));

        return this;
    },

    updateAncestors: function ()
    {
        // console.log(this.name, 'Transform.updateAncestors');

        //  No parent? Then just update the children and leave, our job is done
        if (!this.parent)
        {
            // console.log(this.name, 'updateAncestors has no parent Transform');

            this.updateFromRoot();

            this.updateChildren();

            this.dirty = false;

            return this;
        }

        // console.log(this.name, 'start updateAncestors while');

        //  Gets all parent nodes, starting from this Transform.
        //  Then updates from the top, down, but only on the ancestors,
        //  not any other children - will give us accurate worldX etc properties

        var node = this.parent;
        var nodes = [];

        do
        {
            nodes.push(node);
            node = node.parent;
        }
        while (node);

        //  We've got all the ancestors in the 'nodes' array, let's loop it

        while (nodes.length)
        {
            node = nodes.pop();

            if (node.parent)
            {
                node.updateFromParent();
            }
            else
            {
                node.updateFromRoot();
            }
        }

        //  By this point all of this Transforms ancestors have been
        //  updated, in the correct order, so we can now do this one
        //  and any of its children too

        this.update();
    },

    updateChildren: function ()
    {
        // console.log(this.name, 'Transform.updateChildren');

        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i].update();
        }
    },

    updateFromDirtyParent: function ()
    {
        // console.log(this.name, 'is updateFromDirtyParent', this.parent.name);

        this.updateFromParent();

        if (this.children.length)
        {
            for (var i = 0; i < this.children.length; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    update: function ()
    {
        if (!this._dirty)
        {
            return;
        }

        //  If we got this far then this Transform is dirty
        //  so we need to update it from its parent
        //  and then force the update to all children

        if (this.parent)
        {
            this.updateFromParent();
        }
        else
        {
            this.updateFromRoot();
        }

        var len = this.children.length;

        if (len)
        {
            for (var i = 0; i < len; i++)
            {
                this.children[i].updateFromDirtyParent();
            }
        }

        this._dirty = false;
        this._dirtyVertex = true;
    },

    updateCache: function ()
    {
        this.cache.a = this.cache.cr * this._scaleX;
        this.cache.b = this.cache.sr * this._scaleX;
        this.cache.c = -this.cache.sr * this._scaleY;
        this.cache.d = this.cache.cr * this._scaleY;
    },

    updateVertexData: function (interpolationPercentage, renderer)
    {
        if (!this.gameObject.frame || (!this._dirtyVertex && !this.interpolate))
        {
            return;
        }

        var frame = this.gameObject.frame;

        var w0;
        var h0;
        var w1;
        var h1;

        if (frame.data.trim)
        {
            //  If the sprite is trimmed, add the extra space before transforming
            w1 = frame.x - (this._anchorX * frame.width);
            w0 = w1 + frame.cutWidth;

            h1 = frame.y - (this._anchorY * frame.height);
            h0 = h1 + frame.cutHeight;
        }
        else
        {
            w0 = frame.cutWidth * (1 - this._anchorX);
            w1 = frame.cutWidth * -this._anchorX;

            h0 = frame.cutHeight * (1 - this._anchorY);
            h1 = frame.cutHeight * -this._anchorY;
        }

        var resolution = frame.source.resolution;

        var wt = this.world;

        var a = wt.a / resolution;
        var b = wt.b / resolution;
        var c = wt.c / resolution;
        var d = wt.d / resolution;
        var tx = wt.tx;
        var ty = wt.ty;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            a = old.a + ((a - old.a) * interpolationPercentage);
            b = old.b + ((b - old.b) * interpolationPercentage);
            c = old.c + ((c - old.c) * interpolationPercentage);
            d = old.d + ((d - old.d) * interpolationPercentage);
            tx = old.tx + ((tx - old.tx) * interpolationPercentage);
            ty = old.ty + ((ty - old.ty) * interpolationPercentage);
        }

        if (frame.rotated)
        {
            // var cw = frame.cutWidth;
            var ch = frame.height;
            var a0 = a;
            var b0 = b;
            var c0 = c;
            var d0 = d;
            var _w1 = w1;
            var _w0 = w0;

            //  Offset before rotating
            tx = (wt.c * ch) + tx;
            ty = (wt.d * ch) + ty;
            
            //  Rotate matrix by 90 degrees with precalc values for sine and cosine of rad(90)
            a = (a0 * 6.123233995736766e-17) + -c0;
            b = (b0 * 6.123233995736766e-17) + -d0;
            c = a0 + (c0 * 6.123233995736766e-17);
            d = b0 + (d0 * 6.123233995736766e-17);

            // Update UV coordinates
            frame.updateUVsInverted();

            // Rotate dimensions
            w0 = h0;
            w1 = h1;
            h0 = _w0;
            h1 = _w1;
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            tx |= 0;
            ty |= 0;
        }

        var vert = this.glVertextData;

        //  Top Left Vert
        vert.x0 = (a * w1) + (c * h1) + tx;
        vert.y0 = (d * h1) + (b * w1) + ty;

        //  Top Right Vert
        vert.x1 = (a * w0) + (c * h1) + tx;
        vert.y1 = (d * h1) + (b * w0) + ty;

        //  Bottom Right Vert
        vert.x2 = (a * w0) + (c * h0) + tx;
        vert.y2 = (d * h0) + (b * w0) + ty;

        //  Bottom Left Vert
        vert.x3 = (a * w1) + (c * h0) + tx;
        vert.y3 = (d * h0) + (b * w1) + ty;
        
        return vert;
    },

    getVertexData: function (interpolationPercentage)
    {
        if (this.interpolate || this._dirtyVertex)
        {
            this.updateVertexData(interpolationPercentage);

            this._dirtyVertex = false;
        }

        return this.glVertextData;
    },

    cloneVertexData: function ()
    {
        var src = this.glVertextData;

        return {
            x0: src.x0,
            y0: src.y0,
            x1: src.x1,
            y1: src.y1,
            x2: src.x2,
            y2: src.y2,
            x3: src.x3,
            y3: src.y3
        };
    },

    getCanvasTransformData: function (interpolationPercentage, renderer)
    {
        var frame = this.gameObject.frame;

        var world = this.world;
        var data = this.canvasData;

        if (this.interpolate)
        {
            var old = this.old;

            // Interpolate with the last position to reduce stuttering.
            data.a = old.a + ((world.a - old.a) * interpolationPercentage);
            data.b = old.b + ((world.b - old.b) * interpolationPercentage);
            data.c = old.c + ((world.c - old.c) * interpolationPercentage);
            data.d = old.d + ((world.d - old.d) * interpolationPercentage);
            data.tx = old.tx + ((world.tx - old.tx) * interpolationPercentage);
            data.ty = old.ty + ((world.ty - old.ty) * interpolationPercentage);
            data.dx = old.dx + ((frame.x - (this.anchorX * frame.width)) * interpolationPercentage);
            data.dy = old.dy + ((frame.y - (this.anchorY * frame.height)) * interpolationPercentage);
        }
        else
        {
            //  Copy over the values to the canvasData object, in case the renderer needs to adjust them
            data.a = world.a;
            data.b = world.b;
            data.c = world.c;
            data.d = world.d;
            data.tx = world.tx;
            data.ty = world.ty;
            data.dx = frame.x - (this.anchorX * frame.width);
            data.dy = frame.y - (this.anchorY * frame.height);
        }

        if (frame.autoRound === 1 || (frame.autoRound === -1 && renderer.roundPixels))
        {
            data.tx |= 0;
            data.ty |= 0;
            data.dx |= 0;
            data.dy |= 0;
        }

        return data;
    }

};

Object.defineProperties(Transform.prototype, {

    //  Transform getters / setters

    x: {

        enumerable: true,

        get: function ()
        {
            return this._posX;
        },

        set: function (value)
        {
            this._posX = value;
            this.dirty = true;
        }

    },

    y: {

        enumerable: true,

        get: function ()
        {
            return this._posY;
        },

        set: function (value)
        {
            this._posY = value;
            this.dirty = true;
        }

    },

    scale: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleX: {

        enumerable: true,

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    scaleY: {

        enumerable: true,

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            this.dirty = true;
            this.updateCache();
        }

    },

    anchor: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this.setAnchor(value);
        }

    },

    anchorX: {

        enumerable: true,

        get: function ()
        {
            return this._anchorX;
        },

        set: function (value)
        {
            this._anchorX = value;
            this.dirty = true;
        }

    },

    anchorY: {

        enumerable: true,

        get: function ()
        {
            return this._anchorY;
        },

        set: function (value)
        {
            this._anchorY = value;
            this.dirty = true;
        }

    },

    pivotX: {

        enumerable: true,

        get: function ()
        {
            return this._pivotX;
        },

        set: function (value)
        {
            this._pivotX = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    pivotY: {

        enumerable: true,

        get: function ()
        {
            return this._pivotY;
        },

        set: function (value)
        {
            this._pivotY = value;
            this.dirty = true;
            this.updateCache();
        }

    },

    angle: {

        enumerable: true,

        get: function ()
        {
            return WrapAngle(this.rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            this.rotation = WrapAngle(value) * MATH_CONST.DEG_TO_RAD;
        }

    },

    rotation: {

        enumerable: true,

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            if (this._rotation === value)
            {
                return;
            }

            this._rotation = value;
            this.dirty = true;

            if (this._rotation % MATH_CONST.PI2)
            {
                this.cache.sr = Math.sin(this._rotation);
                this.cache.cr = Math.cos(this._rotation);
                this.updateCache();
                this.hasLocalRotation = true;
            }
            else
            {
                this.hasLocalRotation = false;
            }
        }

    },

    //  Sets this *component* as being dirty
    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    if (this.immediate)
                    {
                        this.update();
                    }
                    else
                    {
                        this._dirtyVertex = true;
                        this.state.sys.updates.add(this);
                    }
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    //  GLOBAL read-only properties from here on
    //  Need *all* parents taken into account to get the correct values

    name: {

        enumerable: true,

        get: function ()
        {
            return (this.gameObject) ? this.gameObject.name : '';
        }

    },

    worldRotation: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldRotation;
        }

    },

    worldScaleX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleX;
        }

    },

    worldScaleY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this._worldScaleY;
        }

    },

    worldX: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.tx;
        }

    },

    worldY: {

        enumerable: true,

        get: function ()
        {
            this.updateAncestors();

            return this.world.ty;
        }

    }

});

module.exports = Transform;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(4);
var Browser = __webpack_require__(5);
var Features = __webpack_require__(28);
var Input = __webpack_require__(83);
var Audio = __webpack_require__(81);
var Video = __webpack_require__(84);
var Fullscreen = __webpack_require__(82);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen

};


/***/ },
/* 86 */
/***/ function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(4);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ },
/* 88 */
/***/ function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ },
/* 89 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
function RequestAnimationFrame (game)
{
    /**
    * @property {Phaser.Game} game - The currently running game.
    */
    this.game = game;

    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.timeOutID = window.requestAnimationFrame(step);

        _this.game.update(timestamp);
    };

    var stepTimeout = function ()
    {
        _this.tick = Date.now();

        // _this.game.update(_this.tick);

        // _this.timeOutID = window.setTimeout(stepTimeout, _this.game.time.timeToCall);
    };

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    this.start = function ()
    {
        this.isRunning = true;

        if (this.game.config.forceSetTimeOut)
        {
            this.isSetTimeOut = true;

            this.timeOutID = window.setTimeout(stepTimeout, 0);
        }
        else
        {
            this.isSetTimeOut = false;

            this.timeOutID = window.requestAnimationFrame(step);
        }
    };

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    this.stop = function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    };

    this.destroy = function ()
    {
        this.stop();

        this.game = undefined;
    };

}

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

module.exports = RequestAnimationFrame;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(30);
var EventListener = __webpack_require__(91);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(30);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(31);
var ContainerWebGLRenderer = __webpack_require__(93);
var Children = __webpack_require__(27);

var Container = function (state, parent, x, y)
{
    GameObject.call(this, state, x, y, null, null, parent);

    this.type = CONST.CONTAINER;

    this.render = ContainerWebGLRenderer;

    this.children = new Children(this);
};

Container.prototype = Object.create(GameObject.prototype);
Container.prototype.constructor = Container;

Container.prototype.preUpdate = function ()
{
    this.children.preUpdate();
};

module.exports = Container;


/***/ },
/* 93 */
/***/ function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || src.children.list.length === 0)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.render(renderer, child);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var GameObject = __webpack_require__(31);
var ImageWebGLRenderer = __webpack_require__(96);
var ImageCanvasRenderer = __webpack_require__(95);

/**
* An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
* It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
*
* @class Phaser.GameObject.Image
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/
var Image = function (state, x, y, key, frame)
{
    var _texture = state.game.textures.get(key);
    var _frame = _texture.get(frame);

    GameObject.call(this, state, x, y, _texture, _frame);

    this.type = CONST.IMAGE;

    // this.render = ImageWebGLRenderer;
    this.render = ImageCanvasRenderer;
};

Image.prototype = Object.create(GameObject.prototype);
Image.prototype.constructor = Image;

Object.defineProperties(Image.prototype, {

    width: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    height: {

        enumerable: true,

        get: function ()
        {
            return this.transform._scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    }

});

module.exports = Image;


/***/ },
/* 95 */
/***/ function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    var data = src.transform.getCanvasTransformData(interpolationPercentage, renderer);
    var tint = src.color._glTint;
    var bg = src.color._glBg;

    renderer.drawImage(frame, src.blendMode, data, alpha, tint, bg);
};

module.exports = ImageCanvasRenderer;


/***/ },
/* 96 */
/***/ function(module, exports) {


var ImageWebGLRenderer = function (renderer, src, interpolationPercentage)
{
    var frame = src.frame;
    var alpha = src.color.worldAlpha * 255 << 24;

    //  Skip rendering?

    if (src.skipRender || !src.visible || alpha === 0 || !frame.cutWidth || !frame.cutHeight)
    {
        return;
    }

    var verts = src.transform.getVertexData(interpolationPercentage, renderer);
    var index = src.frame.source.glTextureIndex;
    var tint = src.color._glTint;
    var bg = src.color._glBg;

    renderer.batch.add(frame.source, src.blendMode, verts, frame.uvs, index, alpha, tint, bg);
};

module.exports = ImageWebGLRenderer;


/***/ },
/* 97 */
/***/ function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ },
/* 98 */
/***/ function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ },
/* 99 */
/***/ function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(32);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(18);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(18);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 103 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ },
/* 104 */
/***/ function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 106 */
/***/ function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ },
/* 107 */
/***/ function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(32);

Circle.Area = __webpack_require__(97);
Circle.Circumference = __webpack_require__(98);
Circle.CircumferencePoint = __webpack_require__(99);
Circle.Clone = __webpack_require__(100);
Circle.Contains = __webpack_require__(18);
Circle.ContainsPoint = __webpack_require__(101);
Circle.ContainsRect = __webpack_require__(102);
Circle.CopyFrom = __webpack_require__(103);
Circle.Equals = __webpack_require__(104);
Circle.GetBounds = __webpack_require__(105);
Circle.Offset = __webpack_require__(106);
Circle.OffsetPoint = __webpack_require__(107);
Circle.Random = __webpack_require__(108);

module.exports = Circle;


/***/ },
/* 110 */
/***/ function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(33);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(19);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(19);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 114 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 115 */
/***/ function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 117 */
/***/ function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ },
/* 118 */
/***/ function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(33);

Ellipse.Area = __webpack_require__(110);
Ellipse.Clone = __webpack_require__(111);
Ellipse.Contains = __webpack_require__(19);
Ellipse.ContainsPoint = __webpack_require__(112);
Ellipse.ContainsRect = __webpack_require__(113);
Ellipse.CopyFrom = __webpack_require__(114);
Ellipse.Equals = __webpack_require__(115);
Ellipse.GetBounds = __webpack_require__(116);
Ellipse.Offset = __webpack_require__(117);
Ellipse.OffsetPoint = __webpack_require__(118);
Ellipse.Random = __webpack_require__(119);

module.exports = Ellipse;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

var GetAngle = __webpack_require__(34);
var FindT = __webpack_require__(20);

/**
* Calculate and return the angle, in radians, of the curves tangent at the given pixel distance along the curves length.
*
* @method Phaser.Hermite#getAngleWithDistance
* @param {number} [distance=0] - The distance along the curve to get the angle from, in pixels.
* @return {number} The angle of the line at the specified distance along the curve. The value is in radians.
*/
var GetAngleWithDistance = function (curve, distance)
{
    if (distance === undefined) { distance = 0; }

    if (distance <= 0)
    {
        return Math.atan2(this._v1y, this._v1x);
    }
    else
    {
        return GetAngle(curve, FindT(curve, distance));
    }
};

module.exports = GetAngleWithDistance;


/***/ },
/* 122 */
/***/ function(module, exports) {

/**
* Get the angle of the curves entry point.
*
* @method Phaser.Hermite#getEntryTangent
* @param {Phaser.Point|Object} point - The Phaser.Point object, or an Object with public `x` and `y` properties, in which the tangent vector values will be stored.
* @return {Phaser.Point} A Point object containing the tangent vector of this Hermite curve.
*/
var GetEntryTangent = function (curve, point)
{
    point.x = curve._v1x;
    point.y = curve._v1y;

    return point;
};

module.exports = GetEntryTangent;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);
var GetPoint = __webpack_require__(21);
var FindT = __webpack_require__(20);

/**
* Get a point on the curve using the distance, in pixels, along the curve.
*
* @method Phaser.Hermite#getPointWithDistance
* @param {integer} [distance=0] - The distance along the curve to get the point from, given in pixels.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} The point on the line at the specified 'distance' along the curve.
*/
var GetPointWithDistance = function (curve, distance, out)
{
    if (distance === undefined) { distance = 0; }
    if (out === undefined) { out = new Point(); }

    if (distance <= 0)
    {
        out.x = this._p1x;
        out.y = this._p1y;
    }
    else
    {
        GetPoint(curve, FindT(curve, distance), out);
    }
    
    return out;
};

module.exports = GetPointWithDistance;


/***/ },
/* 124 */
/***/ function(module, exports) {

/**
* Get the X component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getX
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The X component of a point on the curve based on the `t` (time) value.
*/
var GetX = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x);
};

module.exports = GetX;


/***/ },
/* 125 */
/***/ function(module, exports) {

/**
* Get the Y component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getY
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The Y component of a point on the curve based on the `t` (time) value.
*/
var GetY = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y);
};

module.exports = GetY;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Pete Baron <pete@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A data representation of a Hermite Curve (see http://en.wikipedia.org/wiki/Cubic_Hermite_spline)
* 
* A Hermite curve has a start and end point and tangent vectors for both of them.
* The curve will always pass through the two control points and the shape of it is controlled
* by the length and direction of the tangent vectors.  At the control points the curve will
* be facing exactly in the vector direction.
* 
* As these curves change speed (speed = distance between points separated by an equal change in
* 't' value - see Hermite.getPoint) this class attempts to reduce the variation by pre-calculating
* the `accuracy` number of points on the curve. The straight-line distances to these points are stored
* in the private 'points' array, and this information is used by Hermite.findT() to convert a pixel
* distance along the curve into a 'time' value.
* 
* Higher `accuracy` values will result in more even movement, but require more memory for the points
* list. 5 works, but 10 seems to be an ideal value for the length of curves found in most games on
* a desktop screen. If you use very long curves (more than 400 pixels) you may need to increase
* this value further.
*
* @class Phaser.Hermite
* @constructor
* @param {number} p1x - The x coordinate of the start of the curve.
* @param {number} p1y - The y coordinate of the start of the curve.
* @param {number} p2x - The x coordinate of the end of the curve.
* @param {number} p2y - The y coordinate of the end of the curve.
* @param {number} v1x - The x component of the tangent vector for the start of the curve.
* @param {number} v1y - The y component of the tangent vector for the start of the curve.
* @param {number} v2x - The x component of the tangent vector for the end of the curve.
* @param {number} v2y - The y component of the tangent vector for the end of the curve.
* @param {number} [accuracy=10] The amount of points to pre-calculate on the curve.
*/
var Hermite = function (p1x, p1y, p2x, p2y, v1x, v1y, v2x, v2y, accuracy)
{
    if (accuracy === undefined) { accuracy = 10; }

    /**
    * @property {number} _accuracy - The amount of points to pre-calculate on the curve.
    * @private
    */
    this._accuracy = accuracy;

    /**
    * @property {number} _p1x - The x coordinate of the start of the curve.
    * @private
    */
    this._p1x = p1x;

    /**
    * @property {number} _p1y - The y coordinate of the start of the curve.
    * @private
    */
    this._p1y = p1y;

    /**
    * @property {number} _p2x - The x coordinate of the end of the curve.
    * @private
    */
    this._p2x = p2x;

    /**
    * @property {number} _p2y - The y coordinate of the end of the curve.
    * @private
    */
    this._p2y = p2y;

    /**
    * @property {number} _v1x - The x component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1x = v1x;

    /**
    * @property {number} _v1y - The y component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1y = v1y;

    /**
    * @property {number} _v2x - The x component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2x = v2x;

    /**
    * @property {number} _v2y - The y component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2y = v2y;
    
    /**
    * @property {array} _points - A local array of cached points.
    * @private
    */
    this._points = [];

    /**
    * @property {Phaser.Point} _temp1 - A local cached Point object.
    * @private
    */
    this._temp1 = new Point();

    /**
    * @property {Phaser.Point} _temp2 - A local cached Point object.
    * @private
    */
    this._temp2 = new Point();

    this.recalculate();
};

Hermite.prototype.constructor = Hermite;

Hermite.prototype = {

    /**
    * Performs the curve calculations.
    *
    * This is called automatically if you change any of the curves public properties, such as `Hermite.p1x` or `Hermite.v2y`.
    *
    * If you adjust any of the internal private values, then call this to update the points.
    *
    * @method Phaser.Hermite#recalculate
    * @return {Phaser.Hermite} This object.
    */
    recalculate: function () {

        this._ax = (2 * this._p1x - 2 * this._p2x + this._v1x + this._v2x);
        this._ay = (2 * this._p1y - 2 * this._p2y + this._v1y + this._v2y);
        this._bx = (-3 * this._p1x + 3 * this._p2x - 2 * this._v1x - this._v2x);
        this._by = (-3 * this._p1y + 3 * this._p2y - 2 * this._v1y - this._v2y);

        this.length = this.calculateEvenPoints();

        return this;

    },

    /**
    * Calculate a number of points along the curve, based on `Hermite.accuracy`, and stores them in the private `_points` array.
    *
    * @method Phaser.Hermite#calculateEvenPoints
    * @return {number} The total length of the curve approximated as straight line distances between the points.
    */
    calculateEvenPoints: function () {

        var totalLength = 0;

        this._temp1.setTo(0, 0);                    //  pnt
        this._temp2.setTo(this._p1x, this._p1y);    //  lastPnt

        this._points[0] = 0;

        for (var i = 1; i <= this._accuracy; i++)
        {
            this.getPoint(i / this._accuracy, this._temp1);
            totalLength += this._temp1.distance(this._temp2);
            this._points[i] = totalLength;
            this._temp2.copyFrom(this._temp1);
        }

        return totalLength;

    }

};

Object.defineProperties(Hermite.prototype, {

    /**
    * @name Phaser.Hermite#accuracy
    * @property {number} accuracy - The amount of points to pre-calculate on the curve.
    */
    accuracy: {

        enumerable: true,

        get: function ()
        {
            return this._accuracy;
        },

        set: function (value)
        {
            if (value !== this._accuracy)
            {
                this._accuracy = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1x
    * @property {number} p1x - The x coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1x: {

        enumerable: true,

        get: function () {

            return this._p1x;

        },

        set: function (value) {

            if (value !== this._p1x)
            {
                this._p1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p1y
    * @property {number} p1y - The y coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1y: {

        enumerable: true,

        get: function () {

            return this._p1y;

        },

        set: function (value) {

            if (value !== this._p1y)
            {
                this._p1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2x
    * @property {number} p2x - The x coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2x: {

        enumerable: true,

        get: function () {

            return this._p2x;

        },

        set: function (value) {

            if (value !== this._p2x)
            {
                this._p2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#p2y
    * @property {number} p2y - The y coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2y: {

        enumerable: true,

        get: function () {

            return this._p2y;

        },

        set: function (value) {

            if (value !== this._p2y)
            {
                this._p2y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1x
    * @property {number} v1x - The x component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1x: {

        enumerable: true,

        get: function () {

            return this._v1x;

        },

        set: function (value) {

            if (value !== this._v1x)
            {
                this._v1x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v1y
    * @property {number} v1y - The y component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1y: {

        enumerable: true,

        get: function () {

            return this._v1y;

        },

        set: function (value) {

            if (value !== this._v1y)
            {
                this._v1y = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2x
    * @property {number} v2x - The x component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2x: {

        enumerable: true,

        get: function () {

            return this._v2x;

        },

        set: function (value) {

            if (value !== this._v2x)
            {
                this._v2x = value;
                this.recalculate();
            }

        }

    },

    /**
    * @name Phaser.Hermite#v2y
    * @property {number} v2y - The y component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2y: {

        enumerable: true,

        get: function () {

            return this._v2y;

        },

        set: function (value) {

            if (value !== this._v2y)
            {
                this._v2y = value;
                this.recalculate();
            }

        }

    }

});

module.exports = Hermite;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Hermite

var Hermite = __webpack_require__(126);

Hermite.FindT = __webpack_require__(20);
Hermite.GetAngle = __webpack_require__(34);
Hermite.GetAngleWithDistance = __webpack_require__(121);
Hermite.GetEntryTangent = __webpack_require__(122);
Hermite.GetPoint = __webpack_require__(21);
Hermite.GetPointWithDistance = __webpack_require__(123);
Hermite.GetX = __webpack_require__(124);
Hermite.GetY = __webpack_require__(125);

module.exports = Hermite;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(55);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ },
/* 129 */
/***/ function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);
var RectangleToRectangle = __webpack_require__(36);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var LineToLine = function (line1, line2, asSegment, out)
{
    if (asSegment === undefined) { asSegment = true; }
    if (out === undefined) { out = new Point(); }

    var a = line1.x1;
    var b = line1.y1;

    var e = line1.x2;
    var f = line1.y2;

    var a1 = b.y - a.y;
    var a2 = f.y - e.y;
    var b1 = a.x - b.x;
    var b2 = e.x - f.x;
    var c1 = (b.x * a.y) - (a.x * b.y);
    var c2 = (f.x * e.y) - (e.x * f.y);
    var denom = (a1 * b2) - (a2 * b1);

    if (denom === 0)
    {
        return null;
    }

    out.x = ((b1 * c2) - (b2 * c1)) / denom;
    out.y = ((a2 * c1) - (a1 * c2)) / denom;

    if (asSegment)
    {
        var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y));
        var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc;
        var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc;

        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)
        {
            return out;
        }
        else
        {
            return null;
        }
    }

    return out;
};

module.exports = LineToLine;


/***/ },
/* 132 */
/***/ function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(35);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ },
/* 134 */
/***/ function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {

    CircleToCircle: __webpack_require__(128),
    CircleToRectangle: __webpack_require__(129),
    GetRectangleIntersection: __webpack_require__(130),
    LineToLine: __webpack_require__(131),
    LineToRectangle: __webpack_require__(132),
    PointToLine: __webpack_require__(35),
    PointToLineSegment: __webpack_require__(133),
    RectangleToRectangle: __webpack_require__(36),
    RectangleToValues: __webpack_require__(134)

};


/***/ },
/* 136 */
/***/ function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

var Line = __webpack_require__(37);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ },
/* 138 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ },
/* 139 */
/***/ function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);
var Point = __webpack_require__(0);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ },
/* 142 */
/***/ function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ },
/* 143 */
/***/ function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ },
/* 144 */
/***/ function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);
var Angle = __webpack_require__(6);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ },
/* 147 */
/***/ function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(6);
var NormalAngle = __webpack_require__(38);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(22);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(22);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 152 */
/***/ function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ },
/* 153 */
/***/ function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ },
/* 154 */
/***/ function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(37);

Line.Angle = __webpack_require__(6);
Line.CenterOn = __webpack_require__(136);
Line.Clone = __webpack_require__(137);
Line.CopyFrom = __webpack_require__(138);
Line.Equals = __webpack_require__(139);
Line.GetMidPoint = __webpack_require__(140);
Line.GetNormal = __webpack_require__(141);
Line.GetPointsOnLine = __webpack_require__(142);
Line.Height = __webpack_require__(143);
Line.Length = __webpack_require__(144);
Line.NormalAngle = __webpack_require__(38);
Line.NormalX = __webpack_require__(145);
Line.NormalY = __webpack_require__(146);
Line.PerpSlope = __webpack_require__(147);
Line.Random = __webpack_require__(148);
Line.ReflectAngle = __webpack_require__(149);
Line.Rotate = __webpack_require__(150);
Line.RotateAroundPoint = __webpack_require__(151);
Line.RotateAroundXY = __webpack_require__(22);
Line.SetToAngle = __webpack_require__(152);
Line.Slope = __webpack_require__(153);
Line.Width = __webpack_require__(154);

module.exports = Line;


/***/ },
/* 156 */
/***/ function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ },
/* 157 */
/***/ function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ },
/* 159 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ },
/* 160 */
/***/ function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ },
/* 161 */
/***/ function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ },
/* 162 */
/***/ function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ },
/* 163 */
/***/ function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ },
/* 166 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ },
/* 168 */
/***/ function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ },
/* 169 */
/***/ function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(23);
var Point = __webpack_require__(0);
var GetMagnitudeSq = __webpack_require__(40);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(23);
var Point = __webpack_require__(0);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ },
/* 172 */
/***/ function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(42);
var Multiply = __webpack_require__(41);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ },
/* 174 */
/***/ function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(0);

Point.Add = __webpack_require__(156);
Point.Ceil = __webpack_require__(157);
Point.Clone = __webpack_require__(158);
Point.CopyFrom = __webpack_require__(159);
Point.Cross = __webpack_require__(160);
Point.Divide = __webpack_require__(161);
Point.Dot = __webpack_require__(23);
Point.Equals = __webpack_require__(162);
Point.Floor = __webpack_require__(163);
Point.GetCentroid = __webpack_require__(164);
Point.GetMagnitude = __webpack_require__(39);
Point.GetMagnitudeSq = __webpack_require__(40);
Point.Interpolate = __webpack_require__(165);
Point.Invert = __webpack_require__(166);
Point.Multiply = __webpack_require__(41);
Point.Negative = __webpack_require__(167);
Point.Normalize = __webpack_require__(42);
Point.NormalizeRightHand = __webpack_require__(168);
Point.Perp = __webpack_require__(169);
Point.Project = __webpack_require__(170);
Point.ProjectUnit = __webpack_require__(171);
Point.RPerp = __webpack_require__(172);
Point.SetMagnitude = __webpack_require__(173);
Point.Subtract = __webpack_require__(174);

module.exports = Point;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(44);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(43);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 178 */
/***/ function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ },
/* 179 */
/***/ function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(44);

Polygon.Clone = __webpack_require__(176);
Polygon.Contains = __webpack_require__(43);
Polygon.ContainsPoint = __webpack_require__(177);
Polygon.GetAABB = __webpack_require__(178);
Polygon.GetNumberArray = __webpack_require__(179);

module.exports = Polygon;


/***/ },
/* 181 */
/***/ function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ },
/* 182 */
/***/ function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ },
/* 183 */
/***/ function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ },
/* 184 */
/***/ function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(45);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 187 */
/***/ function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return
        (
            (rectB.x > rectA.x && rectB.x < rectA.right) && 
            (rectB.right > rectA.x && rectB.right < rectA.right)
        ) && (
            (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
            (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
        );
    
};

module.exports = ContainsRect;


/***/ },
/* 188 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 189 */
/***/ function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(24);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(24);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ },
/* 192 */
/***/ function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ },
/* 193 */
/***/ function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ },
/* 194 */
/***/ function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ },
/* 195 */
/***/ function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ },
/* 196 */
/***/ function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ },
/* 197 */
/***/ function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ },
/* 198 */
/***/ function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ },
/* 199 */
/***/ function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ },
/* 200 */
/***/ function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ },
/* 201 */
/***/ function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ },
/* 202 */
/***/ function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ },
/* 203 */
/***/ function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(0);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ },
/* 205 */
/***/ function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(7);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(7);

Rectangle.Area = __webpack_require__(181);
Rectangle.Ceil = __webpack_require__(182);
Rectangle.CeilAll = __webpack_require__(183);
Rectangle.CenterOn = __webpack_require__(184);
Rectangle.Clone = __webpack_require__(185);
Rectangle.Contains = __webpack_require__(45);
Rectangle.ContainsPoint = __webpack_require__(186);
Rectangle.ContainsRect = __webpack_require__(187);
Rectangle.CopyFrom = __webpack_require__(188);
Rectangle.Equals = __webpack_require__(189);
Rectangle.FitInside = __webpack_require__(190);
Rectangle.FitOutside = __webpack_require__(191);
Rectangle.Floor = __webpack_require__(192);
Rectangle.FloorAll = __webpack_require__(193);
Rectangle.GetAspectRatio = __webpack_require__(24);
Rectangle.GetCenter = __webpack_require__(194);
Rectangle.GetSize = __webpack_require__(195);
Rectangle.Inflate = __webpack_require__(196);
Rectangle.MergePoints = __webpack_require__(197);
Rectangle.MergeRect = __webpack_require__(198);
Rectangle.MergeXY = __webpack_require__(199);
Rectangle.Offset = __webpack_require__(200);
Rectangle.OffsetPoint = __webpack_require__(201);
Rectangle.Overlaps = __webpack_require__(202);
Rectangle.Perimeter = __webpack_require__(203);
Rectangle.Random = __webpack_require__(204);
Rectangle.Scale = __webpack_require__(205);
Rectangle.Union = __webpack_require__(206);

module.exports = Rectangle;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var Set = __webpack_require__(309);
var XHRSettings = __webpack_require__(25);
var Event = __webpack_require__(213);
var EventDispatcher = __webpack_require__(14);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update
    //  4) JSON loader
    //  5) XML Loader
    //  6) Multi File support (atlas + data)
    //  7) Atlas Loader

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log('BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log('Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ },
/* 209 */
/***/ function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(46);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(13);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(13);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(212),
    LOADER_COMPLETE_EVENT: __webpack_require__(211)

};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(15);
var JSONFile = __webpack_require__(47);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(3);
var File = __webpack_require__(8);
var ParseXML = __webpack_require__(88);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ },
/* 219 */
/***/ function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ },
/* 220 */
/***/ function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ },
/* 221 */
/***/ function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ },
/* 223 */
/***/ function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 224 */
/***/ function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ },
/* 225 */
/***/ function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ },
/* 226 */
/***/ function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ },
/* 227 */
/***/ function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ },
/* 228 */
/***/ function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ },
/* 230 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ },
/* 231 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ },
/* 232 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ },
/* 233 */
/***/ function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ },
/* 234 */
/***/ function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ },
/* 235 */
/***/ function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ },
/* 236 */
/***/ function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ },
/* 237 */
/***/ function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ },
/* 238 */
/***/ function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ },
/* 239 */
/***/ function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ },
/* 240 */
/***/ function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ },
/* 241 */
/***/ function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(54);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(2);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ },
/* 244 */
/***/ function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(10);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(238),
    BetweenY: __webpack_require__(241),
    BetweenPoints: __webpack_require__(239),
    BetweenPointsY: __webpack_require__(240),
    Reverse: __webpack_require__(242),
    RotateTo: __webpack_require__(243),
    ShortestBetween: __webpack_require__(244),
    Normalize: __webpack_require__(54),
    Wrap: __webpack_require__(11),
    WrapDegrees: __webpack_require__(245)

};


/***/ },
/* 247 */
/***/ function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ },
/* 248 */
/***/ function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(55),
    Power: __webpack_require__(247),
    Squared: __webpack_require__(248)

};


/***/ },
/* 250 */
/***/ function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 251 */
/***/ function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 252 */
/***/ function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 253 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 254 */
/***/ function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 255 */
/***/ function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 256 */
/***/ function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ },
/* 257 */
/***/ function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 258 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 259 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 260 */
/***/ function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(250),
    Bounce: __webpack_require__(251),
    Circular: __webpack_require__(252),
    Cubic: __webpack_require__(253),
    Elastic: __webpack_require__(254),
    Expo: __webpack_require__(255),
    Linear: __webpack_require__(256),
    Quadratic: __webpack_require__(257),
    Quartic: __webpack_require__(258),
    Quintic: __webpack_require__(259),
    Sine: __webpack_require__(260)

};


/***/ },
/* 262 */
/***/ function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ },
/* 263 */
/***/ function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ },
/* 264 */
/***/ function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ },
/* 265 */
/***/ function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ },
/* 266 */
/***/ function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(262),
    Equal: __webpack_require__(263),
    Floor: __webpack_require__(264),
    GreaterThan: __webpack_require__(265),
    LessThan: __webpack_require__(266)

};


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(48);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(50);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(52);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(268),
    CatmullRom: __webpack_require__(269),
    Linear: __webpack_require__(270)

};


/***/ },
/* 272 */
/***/ function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ },
/* 273 */
/***/ function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {module.export = {

    GetNext: __webpack_require__(272),
    IsSize: __webpack_require__(56),
    IsValue: __webpack_require__(273)

};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72)(module)))

/***/ },
/* 275 */
/***/ function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (typeof seeds === 'string')
    {
        this.state(seeds);
    }
    else
    {
        this.sow(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ },
/* 276 */
/***/ function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ },
/* 277 */
/***/ function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ },
/* 278 */
/***/ function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(276),
    Floor: __webpack_require__(277),
    To: __webpack_require__(278)

};


/***/ },
/* 280 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ },
/* 281 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ },
/* 282 */
/***/ function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ },
/* 283 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 284 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ },
/* 285 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ },
/* 286 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ },
/* 287 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

var DrawImage = __webpack_require__(290);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    //  Needed?
    this.game = game;

    // this.type = CONST.CANVAS;

    //  Read all the following from game config
    this.clearBeforeRender = true;

    this.transparent = false;

    this.autoResize = false;

    this.preserveDrawingBuffer = false;

    this.width = game.config.width * game.config.resolution;

    this.height = game.config.height * game.config.resolution;

    this.resolution = game.config.resolution;

    this.view = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.context = this.view.getContext('2d', { alpha: true });

    // this.smoothProperty = Phaser.Canvas.getSmoothingPrefix(this.context);

    this.roundPixels = false;

    //  Map to the required function
    this.drawImage = DrawImage;

    var so = 'source-over';

    this.blendModes = [ so, 'lighter', so, so, so, so, so, so, so, so, so, so, so, so, so, so, so ];

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    this.startTime = 0;
    this.endTime = 0;
    this.drawCount = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.mapBlendModes();

        this.resize(this.width, this.height);
    },

    /**
     * Maps Blend modes to Canvas blend modes.
     *
     * @method mapBlendModes
     * @private
     */
    mapBlendModes: function ()
    {
        // var modes = Phaser.blendModes;

        // this.blendModes[modes.MULTIPLY] = 'multiply';
        // this.blendModes[modes.SCREEN] = 'screen';
        // this.blendModes[modes.OVERLAY] = 'overlay';
        // this.blendModes[modes.DARKEN] = 'darken';
        // this.blendModes[modes.LIGHTEN] = 'lighten';
        // this.blendModes[modes.COLOR_DODGE] = 'color-dodge';
        // this.blendModes[modes.COLOR_BURN] = 'color-burn';
        // this.blendModes[modes.HARD_LIGHT] = 'hard-light';
        // this.blendModes[modes.SOFT_LIGHT] = 'soft-light';
        // this.blendModes[modes.DIFFERENCE] = 'difference';
        // this.blendModes[modes.EXCLUSION] = 'exclusion';
        // this.blendModes[modes.HUE] = 'hue';
        // this.blendModes[modes.SATURATION] = 'saturation';
        // this.blendModes[modes.COLOR] = 'color';
        // this.blendModes[modes.LUMINOSITY] = 'luminosity';
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        // if (this.smoothProperty)
        // {
        //     this.context[this.smoothProperty] = (this.scaleMode === Phaser.scaleModes.LINEAR);
        // }
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, interpolationPercentage)
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        //  Add Pre-render hook

        //  TODO: A State should have the option of having its own canvas to draw to

        this.startTime = Date.now();

        this.context.setTransform(1, 0, 0, 1, 0, 0);

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            this.context.globalAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            this.context.globalCompositeOperation = 'source-over';
        }

        this.currentBlendMode = 0;
        this.currentScaleMode = 0;
        this.currentAlpha = 1;

        if (this.clearBeforeRender)
        {
            this.context.clearRect(0, 0, this.width, this.height);
        }

        this.drawCount = 0;

        //  Could move to the State Systems or MainLoop
        this.game.state.renderChildren(this, state, interpolationPercentage);

        this.endTime = Date.now();

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        //  Add Post-render hook
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.view = null;
        this.context = null;
    }

};

module.exports = CanvasRenderer;


/***/ },
/* 290 */
/***/ function(module, exports) {


var DrawImage = function (frame, blendMode, transform, alpha, tint, bg)
{
    var ctx = this.context;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== blendMode)
    {
        this.currentBlendMode = blendMode;
        ctx.globalCompositeOperation = this.blendModes[blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== alpha)
    {
        this.currentAlpha = alpha;
        ctx.globalAlpha = alpha;
    }

    //  Smoothing (should this be a Game Object, or Frame / Texture level property?)

    if (this.currentScaleMode !== frame.source.scaleMode)
    {
        // this.currentScaleMode = source.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === Phaser.scaleModes.LINEAR);
    }

    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, transform.dx, transform.dy, cd.dWidth, cd.dHeight);

};

module.exports = DrawImage;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(293);
var CreateProgram = __webpack_require__(296);
var CreateShader = __webpack_require__(297);
var CreateBuffer = __webpack_require__(295);
var CreateAttribDesc = __webpack_require__(294);
var VertexBuffer = __webpack_require__(300);
var IndexBuffer = __webpack_require__(298);
var VertexArray = __webpack_require__(299);
var CONST = __webpack_require__(1);

var ParticleRenderer = function (game)
{
    this.game = game;
    this.glContext = null;
    this.maxParticles = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.type = CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.init();
};

// VERTEX_SIZE = sizeof(vec2) + sizeof(vec2)
ParticleRenderer.VERTEX_SIZE = 16;
ParticleRenderer.INDEX_SIZE = 2;
ParticleRenderer.PARTICLE_VERTEX_COUNT = 4;
ParticleRenderer.PARTICLE_INDEX_COUNT = 6;

// How many 32-bit components does the vertex have.
ParticleRenderer.PARTICLE_VERTEX_COMPONENT_COUNT = 4;

// Can't be bigger since index are 16-bit
ParticleRenderer.MAX_PARTICLES = 10000;
ParticleRenderer.VERTEX_SHADER_SOURCE = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'varying vec2 v_tex_coord;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '}'
].join('\n');
ParticleRenderer.FRAGMENT_SHADER_SOURCE = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord);',
    '}'
].join('\n');

ParticleRenderer.prototype.init = function ()
{
    if (this.glContext === null)
    {
        var gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);
        var vertexDataBuffer = new VertexBuffer(ParticleRenderer.VERTEX_SIZE * ParticleRenderer.PARTICLE_VERTEX_COUNT * ParticleRenderer.MAX_PARTICLES);
        var indexDataBuffer = new IndexBuffer(ParticleRenderer.INDEX_SIZE * ParticleRenderer.PARTICLE_INDEX_COUNT * ParticleRenderer.MAX_PARTICLES);
        var vertShader = CreateShader(gl, ParticleRenderer.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, ParticleRenderer.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER_SOURCE);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var vertexArray = new VertexArray(gl,
                CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()),
                [
                    CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, ParticleRenderer.VERTEX_SIZE, 0),
                    CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, ParticleRenderer.VERTEX_SIZE, 8)
                ]
            );
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var view = this.view;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.glContext = gl;
        this.viewMatrixLocation = viewMatrixLocation;
       
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        var indexBuffer = indexDataBuffer.wordView;

        // Populate the index buffer only once
        for (var indexA = indexB = 0;
            indexA < ParticleRenderer.MAX_PARTICLES * ParticleRenderer.PARTICLE_INDEX_COUNT;
            indexA += ParticleRenderer.PARTICLE_INDEX_COUNT, indexB += ParticleRenderer.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }
        this.resize(this.width, this.height);
    }
    else
    {
        console.error('ParticleRenderer already initialized');
    }
};

ParticleRenderer.prototype.destroy = function ()
{
    var gl = this.glContext;
    if (gl)
    {
        gl.deleteShader(this.vertShader);
        gl.deleteShader(this.fragShader);
        gl.deleteProgram(this.program);
        gl.deleteBuffer(this.indexBufferObject);
        gl.deleteBuffer(this.vertexArray.buffer);
    }
};

ParticleRenderer.prototype.isFull = function ()
{
    var vertexDataBuffer = this.vertexDataBuffer;
    return (vertexDataBuffer.getByteLength() >= vertexDataBuffer.getByteCapacity());
};

ParticleRenderer.prototype.add = function (x, y, width, height, umin, vmin, umax, vmax)
{
    // The user must check if the buffers are full before flushing
    // this is to give freedom of when should the renderer flush.
    var vertexDataBuffer = this.vertexDataBuffer;
    var indexDataBuffer = this.indexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = vertexDataBuffer.allocate(ParticleRenderer.PARTICLE_VERTEX_COMPONENT_COUNT * ParticleRenderer.PARTICLE_VERTEX_COUNT);

    vertexBuffer[vertexOffset++] = x;
    vertexBuffer[vertexOffset++] = y;
    vertexBuffer[vertexOffset++] = umin;
    vertexBuffer[vertexOffset++] = vmin;
    
    vertexBuffer[vertexOffset++] = x;
    vertexBuffer[vertexOffset++] = y + height;
    vertexBuffer[vertexOffset++] = umin;
    vertexBuffer[vertexOffset++] = vmax;

    vertexBuffer[vertexOffset++] = x + width;
    vertexBuffer[vertexOffset++] = y + height;
    vertexBuffer[vertexOffset++] = umax;
    vertexBuffer[vertexOffset++] = vmax;

    vertexBuffer[vertexOffset++] = x + width;
    vertexBuffer[vertexOffset++] = y;
    vertexBuffer[vertexOffset++] = umax;
    vertexBuffer[vertexOffset++] = vmin;

    this.elementCount += ParticleRenderer.PARTICLE_INDEX_COUNT;
};

ParticleRenderer.prototype.setTexture2D = function (texture2D)
{
    var gl = this.glContext;
    if (this.currentTexture2D !== texture2D)
    {
        this.flush();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture2D);
        this.currentTexture2D = texture2D;
    }
};

ParticleRenderer.prototype.render = function ()
{
    //  Stops it breaking
};

ParticleRenderer.prototype.bind = function ()
{
    var gl = this.glContext;
    gl.useProgram(this.program);
    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
    BindVertexArray(this.vertexArray);
};

ParticleRenderer.prototype.unbind = function ()
{
    var gl = this.glContext;
    gl.useProgram(null);
    gl.disable(gl.BLEND);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};

ParticleRenderer.prototype.flush = function ()
{
    var gl = this.glContext;
    var vertexDataBuffer = this.vertexDataBuffer;
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
    gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
    vertexDataBuffer.clear();
    this.elementCount = 0;
};

ParticleRenderer.prototype.resize = function (width, height)
{
    var gl = this.glContext;
    var res = this.game.config.resolution;
    
    this.width = width * res;
    this.height = height * res;
    
    this.view.width = this.width;
    this.view.height = this.height;
    
    if (this.autoResize)
    {
        this.view.style.width = (this.width / res) + 'px';
        this.view.style.height = (this.height / res) + 'px';
    }
    gl.viewport(0, 0, this.width, this.height);
    gl.uniformMatrix4fv(
        this.viewMatrixLocation,
        false,
        new Float32Array([
            2 / this.view.width, 0, 0, 0,
            0, -2 / this.view.height, 0, 0,
            0, 0, 1, 1,
            -1, 1, 0, 0
        ])
    );
};

module.exports = ParticleRenderer;


/***/ },
/* 292 */
/***/ function(module, exports) {

var Attribute = function (location, size, type, normalize, stride, offset)
{
    this.location = location;
    this.size = size;
    this.type = type;
    this.normalize = normalize;
    this.stride = stride;
    this.offset = offset;
};

module.exports = Attribute;


/***/ },
/* 293 */
/***/ function(module, exports) {

var BindVertexArray = function (gl, vao)
{
    var attributes = vao.attributes;
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.buffer);
    for (var index = 0, length = attributes.length; index < length; ++index)
    {
        var attrib = attributes[index];
        var location = attrib.location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(
            location,
            attrib.size,
            attrib.type,
            attrib.normalized,
            attrib.stride,
            attrib.offset
        );
    }
};

module.exports = BindVertexArray;


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

var Attribute = __webpack_require__(292);

var CreateAttribDesc = function (gl, program, name, size, type, normalized, stride, offset)
{
    return new Attribute(
        gl.getAttribLocation(program, name),
        size,
        type,
        normalized,
        stride,
        offset
    );
};

module.exports = CreateAttribDesc;


/***/ },
/* 295 */
/***/ function(module, exports) {

var CreateBuffer = function (gl, bufferType, usage, bufferData, bufferSize)
{
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    if (bufferData && ArrayBuffer.isView(bufferData))
    {
        gl.bufferData(bufferType, bufferData, usage);
    }
    else
    {
        gl.bufferData(bufferType, bufferSize, usage);
    }
    return buffer;
};

module.exports = CreateBuffer;


/***/ },
/* 296 */
/***/ function(module, exports) {

var CreateProgram = function (gl, vertexShader, fragmentShader)
{
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Failed to link program. Error: \n' + gl.getProgramInfoLog(program));
        return null;
    }
    return program;
};

module.exports = CreateProgram;


/***/ },
/* 297 */
/***/ function(module, exports) {

var CreateShader = function (gl, shaderSource, shaderType)
{
    var shader = null;
    shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.error('Failed ' + (shaderType === gl.VERTEX_SHADER ? 'vertex' : shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'invalid') + ' shader compilation. Error: \n' + gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
};

module.exports = CreateShader;


/***/ },
/* 298 */
/***/ function(module, exports) {

var IndexBuffer = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.shortView = new Int16Array(this.buffer);
    this.wordView = new Uint16Array(this.buffer);
};

IndexBuffer.prototype.clear = function ()
{
    this.wordLength = 0;
};

IndexBuffer.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

IndexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

IndexBuffer.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

IndexBuffer.prototype.getUsedBufferAsShort = function ()
{
    return this.shortView.subarray(0, this.dwordLength);
};

IndexBuffer.prototype.getUsedBufferAsWord = function ()
{
    return this.wordView.subarray(0, this.dwordLength);
};

module.exports = IndexBuffer;


/***/ },
/* 299 */
/***/ function(module, exports) {

var VertexArray = function (vbo, attributes)
{
    this.buffer = vbo;
    this.attributes = attributes;
};

module.exports = VertexArray;


/***/ },
/* 300 */
/***/ function(module, exports) {

var VertexBuffer = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

VertexBuffer.prototype.clear = function ()
{
    this.dwordLength = 0;
};

VertexBuffer.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

VertexBuffer.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

VertexBuffer.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

VertexBuffer.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

VertexBuffer.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = VertexBuffer;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {


var Between = __webpack_require__(49);
var GetObjectValue = __webpack_require__(12);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetObjectValue(config, 'frequency', 200);
    this.attack = GetObjectValue(config, 'attack', 0);
    this.decay = GetObjectValue(config, 'decay', 1);
    this.type = GetObjectValue(config, 'type', 'sine');
    this.volumeValue = GetObjectValue(config, 'volume', 1);
    this.panValue = GetObjectValue(config, 'pan', 0);
    this.wait = GetObjectValue(config, 'wait', 0);
    this.pitchBendAmount = GetObjectValue(config, 'pitchBend', 0);
    this.reverse = GetObjectValue(config, 'reverse', false);
    this.randomValue = GetObjectValue(config, 'random', 0);
    this.dissonance = GetObjectValue(config, 'dissonance', 0);
    this.echo = GetObjectValue(config, 'echo', false);
    this.echoDelay = GetObjectValue(config, 'echo.delay', 0);
    this.echoFeedback = GetObjectValue(config, 'echo.feedback', 0);
    this.echoFilter = GetObjectValue(config, 'echo.filter', 0);
    this.reverb = GetObjectValue(config, 'reverb', false);
    this.reverbDuration = GetObjectValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetObjectValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetObjectValue(config, 'reverb.reverse', false);
    this.timeout = GetObjectValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        console.log('onended');
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(301)

};


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Settings = __webpack_require__(57);
var Systems = __webpack_require__(58);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The properties a State *must* have, that cannot be changed without breaking it:

    this.game = null;

    //  Maybe just an object? Doesn't have to instantiate I don't think ...
    this.settings = new Settings(this, config);

    this.sys = new Systems(this, config);

    //  Reference to sys.children, set during sys.init only
    this.children;
};

State.prototype.constructor = State;

State.prototype = {

    //  Can be overridden by your own States
    preUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    update: function ()
    {
    },

    //  Can be overridden by your own States
    postUpdate: function ()
    {
    },

    //  Can be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var NOOP = __webpack_require__(59);
var State = __webpack_require__(303);
var Settings = __webpack_require__(57);
var Systems = __webpack_require__(58);
var GetObjectValue = __webpack_require__(12);
// var LoaderEvent = require('../loader/events/');

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.StateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var StateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0)
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true
            });
        }
    }
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.StateManager#boot
    * @private
    */
    boot: function ()
    {
        // this.game.onPause.add(this.pause, this);
        // this.game.onResume.add(this.resume, this);

        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.StateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            // console.log('StateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('StateManager.add from instance', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('StateManager.add from object', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('StateManager.add from function', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.game = this.game;

        newState.settings.key = key;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.game = this.game;

        newState.sys.init();

        if (this.game.config.renderType === CONST.WEBGL)
        {
            this.createStateFrameBuffer(newState);
        }

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.game = this.game;

            newState.settings = new Settings(newState, key);
            newState.sys = new Systems(newState);

            newState.sys.init();

            if (this.game.config.renderType === CONST.WEBGL)
            {
                this.createStateFrameBuffer(newState);
            }

            //  Default required functions
            return this.setupCallbacks(newState);
        }
    },

    setupCallbacks: function (newState, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = newState; }

        //  Extract callbacks or set NOOP

        newState.init = GetObjectValue(stateConfig, 'init', NOOP);
        newState.preload = GetObjectValue(stateConfig, 'preload', NOOP);
        newState.create = GetObjectValue(stateConfig, 'create', NOOP);
        newState.shutdown = GetObjectValue(stateConfig, 'shutdown', NOOP);

        newState.preUpdate = GetObjectValue(stateConfig, 'preUpdate', NOOP);
        newState.update = GetObjectValue(stateConfig, 'update', NOOP);
        newState.postUpdate = GetObjectValue(stateConfig, 'postUpdate', NOOP);
        newState.render = GetObjectValue(stateConfig, 'render', NOOP);

        return newState;
    },

    createStateFrameBuffer: function (newState)
    {
        var x = newState.settings.x;
        var y = newState.settings.y;

        if (newState.settings.width === -1)
        {
            newState.settings.width = this.game.config.width;
        }

        if (newState.settings.height === -1)
        {
            newState.settings.height = this.game.config.height;
        }

        var width = newState.settings.width;
        var height = newState.settings.height;

        newState.sys.fbo = this.game.renderer.createFBO(newState, x, y, width, height);
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                return this.active[i].index;
            }
        }

        return -1;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key)
    {
        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('StateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            //  + arguments
            if (state.init)
            {
                state.init.call(state);
            }

            if (state.preload && state.sys.load)
            {
                state.sys.load.reset();

                state.preload.call(state, this.game);

                //  Is the loader empty?
                if (state.sys.load.list.size === 0)
                {
                    this.startCreate(state);
                }
                else
                {
                    //  Start the loader going as we have something in the queue

                    state.sys.load.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                    state.sys.load.start();
                }
            }
            else
            {
                //  No preload? Then there was nothing to load either
                this.startCreate(state);
            }

        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        //  Make sure to do load-update one last time before state is set to _created

        //  Stop doing this ...
        if (state.hasOwnProperty('loadUpdate'))
        {
            state.loadUpdate.call(state);
        }

        this.startCreate(state);
    },

    startCreate: function (state)
    {
        if (state.create)
        {
            state.create.call(state);
        }

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates.bind(this));

        state.sys.updates.running = true;

        state.sys.mainloop.start();
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(key);

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates.bind(this));
        }
    },

    sortStates: function (stateA, stateB)
    {
        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    //  See if we can reduce this down to just update and render

    step: function (timestamp)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            if (state.sys.mainloop.running)
            {
                state.sys.mainloop.step(timestamp);
            }
        }
    },

    /*
    preUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].preUpdate();
            }

            state.preUpdate();
        }
    },

    update: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Invoke State Main Loop here - updating all of its systems (tweens, physics, etc)

            //  This shouldn't be called if the State is still loading
            //  Have a State.STATUS const in the Settings, dictating what is going on

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                var child = state.sys.children.list[c];

                if (child.exists)
                {
                    child.update();
                }
            }

            state.update();
        }
    },

    postUpdate: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            for (var c = 0; c < state.sys.children.list.length; c++)
            {
                state.sys.children.list[c].postUpdate();
            }

            state.postUpdate();
        }
    },

    render: function ()
    {
        for (var i = 0; i < this.active.length; i++)
        {
            var state = this.active[i].state;

            //  Can put all kinds of other checks in here, like MainLoop, FPS, etc.
            if (!state.settings.visible || state.sys.color.alpha === 0 || state.sys.children.list.length === 0)
            {
                continue;
            }

            this.game.renderer.render(state);
        }
    },
    */

    renderChildren: function (renderer, state, interpolationPercentage)
    {
        //  Populates the display list
        for (var c = 0; c < state.sys.children.list.length; c++)
        {
            var child = state.sys.children.list[c];

            child.render(renderer, child, interpolationPercentage);
        }
    }

};

module.exports = StateManager;


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(9);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var GameObjectFactory = {

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    state: null

};

function init (state)
{
    console.log('Creating GameObjectFactory instance for State');

    GameObjectFactory.state = state;

    //   Load the factories into this Object

    return FactoryContainer.load(GameObjectFactory, true);

    // return GameObjectFactory;
}

module.exports = init;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(3);
var BaseLoader = __webpack_require__(208);
var NumberArray = __webpack_require__(60);

var ImageFile = __webpack_require__(15);
var JSONFile = __webpack_require__(47);
var XMLFile = __webpack_require__(218);
var BinaryFile = __webpack_require__(215);
var GLSLFile = __webpack_require__(216);
var TextFile = __webpack_require__(217);
var AtlasJSONFile = __webpack_require__(214);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;

        textureURLs = NumberArray(0, total, key + '-', '.png');
        atlasURLs = NumberArray(0, total, key + '-', '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var textures = this.state.sys.textures;

    //  Process multiatlas groups first

    var file;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    this.storage.each(function (file)
    {
        if (file.type === 'image')
        {
            textures.addImage(file.key, file.data);
        }
        else if (file.type === 'atlasjson')
        {
            var fileA = file.fileA;
            var fileB = file.fileB;

            if (fileA.type === 'image')
            {
                textures.addAtlas(fileA.key, fileA.data, fileB.data);
            }
            else
            {
                textures.addAtlas(fileB.key, fileB.data, fileA.data);
            }
        }
        else if (file.type === 'json')
        {
            // console.dir(file.data);
        }
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ },
/* 307 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// My thanks to Isaac Sukin for creating MainLoop.js, on which lots of this is based.

var MainLoop = function (state, framerate)
{
    /**
    * @property {Phaser.State} state
    */
    this.state = state;

    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = state.game;

    // The amount of time (in milliseconds) to simulate each time update() runs.
    this.timestep = 1000 / framerate;

    this.physicsStep = 1 / framerate;

    // The cumulative amount of in-app time that hasn't been simulated yet.
    // See the comments inside animate() for details.
    this.frameDelta = 0;

    // The timestamp in milliseconds of the last time the main loop was run.
    // Used to compute the time elapsed between frames.
    this.lastFrameTimeMs = 0;

    // An exponential moving average of the frames per second.
    this.fps = 60;

    // The timestamp (in milliseconds) of the last time the `fps` moving
    // average was updated.
    this.lastFpsUpdate = 0;

    // The number of frames delivered in the current second.
    this.framesThisSecond = 0;

    // The number of times update() is called in a given frame. This is only
    // relevant inside of animate(), but a reference is held externally so that
    // this variable is not marked for garbage collection every time the main
    // loop runs.
    this.numUpdateSteps = 0;

    // The minimum amount of time in milliseconds that must pass since the last
    // frame was executed before another frame can be executed. The
    // multiplicative inverse caps the FPS (the default of zero means there is
    // no cap).
    this.minFrameDelay = 0;

    // Whether the main loop is running.
    this.running = false;

    // `true` if `MainLoop.start()` has been called and the most recent time it
    // was called has not been followed by a call to `MainLoop.stop()`. This is
    // different than `running` because there is a delay of a few milliseconds
    // after `MainLoop.start()` is called before the application is considered
    // "running." This delay is due to waiting for the next frame.
    this.started = false;

    // Whether the simulation has fallen too far behind real time.
    // Specifically, `panic` will be set to `true` if too many updates occur in
    // one frame. This is only relevant inside of animate(), but a reference is
    // held externally so that this variable is not marked for garbage
    // collection every time the main loop runs.
    this.panic = false;
};

MainLoop.prototype.constructor = MainLoop;

MainLoop.prototype = {

    setMaxFPS: function (fps)
    {
        if (fps === 0)
        {
            this.stop();
        }
        else
        {
            this.minFrameDelay = 1000 / fps;
        }
    },

    getMaxFPS: function ()
    {
        return 1000 / this.minFrameDelay;
    },

    resetFrameDelta: function ()
    {
        var oldFrameDelta = this.frameDelta;

        this.frameDelta = 0;

        return oldFrameDelta;
    },

    start: function ()
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.lastFrameTimeMs = window.performance.now();
        this.lastFpsUpdate = window.performance.now();
        this.framesThisSecond = 0;
    },

    //  timestamp = DOMHighResTimeStamp
    step: function (timestamp)
    {
        // Throttle the frame rate (if minFrameDelay is set to a non-zero value by
        // `MainLoop.setMaxAllowedFPS()`).
        if (timestamp < this.lastFrameTimeMs + this.minFrameDelay)
        {
            return;
        }

        // frameDelta is the cumulative amount of in-app time that hasn't been
        // simulated yet. Add the time since the last frame. We need to track total
        // not-yet-simulated time (as opposed to just the time elapsed since the
        // last frame) because not all actually elapsed time is guaranteed to be
        // simulated each frame. See the comments below for details.
        this.frameDelta += timestamp - this.lastFrameTimeMs;
        this.lastFrameTimeMs = timestamp;

        // Run any updates that are not dependent on time in the simulation.

        //  Here we'll need to run things like tween.update, input.update, etc.
        this.state.sys.begin(timestamp, this.frameDelta);

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        if (timestamp > this.lastFpsUpdate + 1000)
        {
            // Compute the new exponential moving average with an alpha of 0.25.
            // Using constants inline is okay here.
            this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;

            this.lastFpsUpdate = timestamp;
            this.framesThisSecond = 0;
        }

        this.framesThisSecond++;

        this.numUpdateSteps = 0;

        var step = this.timestep;

        while (this.frameDelta >= step)
        {
            // this.update(this.timestep);

            this.state.sys.update(step, this.physicsStep);

            for (var c = 0; c < this.state.sys.children.list.length; c++)
            {
                var child = this.state.sys.children.list[c];

                if (child.exists)
                {
                    child.update(step);
                }
            }

            //  Dev level callback
            this.state.update(step);

            this.frameDelta -= this.timestep;

            if (++this.numUpdateSteps >= 240)
            {
                this.panic = true;
                break;
            }
        }

        this.state.sys.preRender();

        this.state.sys.updates.start();

        if (this.state.settings.visible && this.state.sys.color.alpha !== 0)
        {
            this.game.renderer.render(this.state, this.frameDelta / this.timestep);
        }

        this.state.sys.updates.stop();

        // Run any updates that are not dependent on time in the simulation.
        this.state.sys.end(this.fps, this.panic);

        this.panic = false;
    },

    /*
    update: function (timestep)
    {
        this.state.sys.update(timestep);

        var c;
        var child;

        for (var c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }

        //  Dev level callback
        this.state.update(timestep);

        for (c = 0; c < this.state.sys.children.list.length; c++)
        {
            var child = this.state.sys.children.list[c];

            if (child.exists)
            {
                child.update(timestep);
            }
        }
    },
    */

    stop: function ()
    {
        this.running = false;
        this.started = false;

        return this;
    }

};

module.exports = MainLoop;


/***/ },
/* 308 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.game = state.game;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ },
/* 309 */
/***/ function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.add(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(16);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;
        var di = data.drawImage;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;
        this.width = destWidth;
        this.height = destHeight;

        //  drawImage data
        di.sx = destX;
        di.sy = destY;
        di.sWidth = destWidth;
        di.sHeight = destHeight;
        di.dWidth = destWidth;
        di.dHeight = destHeight;

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = (this.cutX + this.cutWidth) / tw;
        uvs.y1 = this.cutY / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = this.cutX / tw;
        uvs.y3 = (this.cutY + this.cutHeight) / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = (this.cutX + this.cutHeight) / tw;
        uvs.y1 = this.cutY / th;

        uvs.x2 = (this.cutX + this.cutHeight) / tw;
        uvs.y2 = (this.cutY + this.cutWidth) / th;

        uvs.x3 = this.cutX / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;
        clone.width = this.width;
        clone.height = this.height;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(310);
var TextureSource = __webpack_require__(313);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i]));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        this.frameTotal++;

        return frame;
    },

    get: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  Need to iterate though the TextureSources, and unload each one
        //  then clear out the frames

        /*
        if (this.source)
        {
            Phaser.CanvasPool.removeByCanvas(this.source);
        }

        this.source = null;
        */
    }

};

/**
* Helper function that creates a base texture from the given canvas element.
*
* @static
* @method fromCanvas
* @param canvas {Canvas} The canvas element source of the texture
* @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}Phaser.scaleModes{{/crossLink}} for possible values
* @return {BaseTexture}
Phaser.Texture.fromCanvas = function (canvas, scaleMode)
{
    if (canvas.width === 0)
    {
        canvas.width = 1;
    }

    if (canvas.height === 0)
    {
        canvas.height = 1;
    }

    return new Phaser.Texture(canvas, scaleMode);
};
*/

module.exports = Texture;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(321);
var Texture = __webpack_require__(311);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function ()
{
    this.list = {};
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    addSpriteSheet: function (key, source, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, atlasKey, atlasFrame, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
    {
        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, frameWidth, frameHeight, startFrame, endFrame, margin, spacing);

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source)
    {
        var texture = new Texture(this, key, source);

        this.list[key] = texture;

        return texture;

    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(1);
var IsSizePowerOfTwo = __webpack_require__(56);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = CONST.scaleModes.DEFAULT;
    // this.scaleMode = CONST.scaleModes.NEAREST;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmap
    * @type {Boolean}
    */
    this.mipmap = false;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;
};

module.exports = TextureSource;


/***/ },
/* 314 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var CanvasTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = CanvasTextureParser;


/***/ },
/* 315 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var ImageTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = ImageTextureParser;


/***/ },
/* 316 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArrayTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
        }
    }

    return texture;
};

module.exports = JSONArrayTextureParser;


/***/ },
/* 317 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHashTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
        }
    }

    return texture;
};

module.exports = JSONHashTextureParser;


/***/ },
/* 318 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var PyxelTextureParser = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = PyxelTextureParser;


/***/ },
/* 319 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetTextureParser = function (texture, sourceIndex, x, y, width, height, frameWidth, frameHeight, startFrame, endFrame, margin, spacing)
{
    if (startFrame === undefined) { startFrame = 0; }
    if (endFrame === undefined) { endFrame = -1; }
    if (margin === undefined) { margin = 0; }
    if (spacing === undefined) { spacing = 0; }

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetTextureParser;


/***/ },
/* 320 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXMLTextureParser = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXMLTextureParser;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(314),
    Image: __webpack_require__(315),
    SpriteSheet: __webpack_require__(319),
    JSONArray: __webpack_require__(316),
    JSONHash: __webpack_require__(317),
    StarlingXML: __webpack_require__(320),
    Pyxel: __webpack_require__(318)
};


/***/ },
/* 322 */
/***/ function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ },
/* 323 */
/***/ function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(53);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(61);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ },
/* 326 */
/***/ function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ },
/* 327 */
/***/ function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ },
/* 328 */
/***/ function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ },
/* 329 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(68);

var CONST = __webpack_require__(1);
var Extend = __webpack_require__(16);

//  This object is exported globally

var Phaser = {

    Game: __webpack_require__(63),

    Event: __webpack_require__(13),
    EventDispatcher: __webpack_require__(14),

    Math: __webpack_require__(67),

    Geom: __webpack_require__(66),

    GameObjects: {

        Factory: __webpack_require__(9)

    },

    Loader: {

        ImageFile: __webpack_require__(15)

    },

    Sound: __webpack_require__(69),

    Utils: {

        Array: __webpack_require__(70),
        Objects: __webpack_require__(71)

    }

};

//  Required, but don't need Phaser level exports

__webpack_require__(65);
__webpack_require__(64);

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * “Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function.”
 * - John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyZDg2MTRmZjJlYzFkZDYwZDEwMCIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9PUy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL09TLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9Ccm93c2VyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0ZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9XcmFwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2FuZ2xlL1dyYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL0dldE9iamVjdFZhbHVlLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9GaW5kVC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRG90LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9HZXRBc3BlY3RSYXRpby5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0NhbnZhc1Bvb2wuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kb20vQ2FudmFzUG9vbC5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldEFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9HZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9CZXJuc3RlaW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL0Jlcm5zdGVpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmFjdG9yaWFsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVyby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvU3lzdGVtcy5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL1N5c3RlbXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL05PT1AuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L051bWJlckFycmF5LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9TcGxpY2VPbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL29iamVjdC9Jc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ib290L0dhbWUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L0dhbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvcG9seWZpbGxzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3NvdW5kL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvc291bmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9ib290L0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvQ29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9DcmVhdGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvRGVidWdIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhbWVyYS9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jYW1lcmEvQ2FtZXJhLmpzIiwid2VicGFjazovLy8uLi9jaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9EYXRhLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQXVkaW8uanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvQXVkaW8uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9GdWxsc2NyZWVuLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0Z1bGxzY3JlZW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL1ZpZGVvLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL1ZpZGVvLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9BZGRUb0RPTS5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0RPTUNvbnRlbnRMb2FkZWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL1BhcnNlWE1MLmpzIiwid2VicGFjazovLy8uLi9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZVdlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9PZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldEVudHJ5VGFuZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50V2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0WC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaGVybWl0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL0NpcmNsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVmFsdWVzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9HZXRNaWRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9HZXRQb2ludHNPbkxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9IZWlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9MZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxYLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxZLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9QZXJwU2xvcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1NldFRvQW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9TbG9wZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1dpZHRoLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQWRkLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Nyb3NzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvR2V0Q2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9JbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvTmVnYXRpdmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05vcm1hbGl6ZVJpZ2h0SGFuZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9QZXJwLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1JQZXJwLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1N1YnRyYWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2x5Z29uL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9seWdvbi9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vR2V0QUFCQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlaWxBbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9GaXRJbnNpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GbG9vci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3JBbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvR2V0U2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvSW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VYWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXRQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT3ZlcmxhcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0Jhc2VMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvQmFzZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL0dldFVSTC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL1hIUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9ldmVudHMvTG9hZGVyQ29tcGxldGVFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9ldmVudHMvTG9hZGVyQ29tcGxldGVFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2VpbFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0NsYW1wLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0RlZ1RvUmFkLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9EZWdUb1JhZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9EaWZmZXJlbmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Zsb2F0QmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9GbG9vclRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL01heEFkZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9NaW5TdWIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUGVyY2VudC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9SYWRUb0RlZy5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvUmFkVG9EZWcuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm90YXRlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZUFyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3VuZFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1NpbkNvc1RhYmxlR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1Ntb290aFN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvU21vb3RoZXJTdGVwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1dpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50c1kuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblkuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9Sb3RhdGVUby5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VQb3dlci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVNxdWFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZGlzdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9CYWNrLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9Cb3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9DdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvRWxhc3RpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvRXhwby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvTGluZWFyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9RdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL1F1YXJ0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL1F1aW50aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL1NpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9lYXNpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZnV6enkvQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9FcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9GbG9vci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9HcmVhdGVyVGhhbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9MZXNzVGhhbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvZnV6enkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3by5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9wb3cyL0lzVmFsdWVQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9wb3cyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvc25hcC9TbmFwQ2VpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9zbmFwL1NuYXBGbG9vci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9zbmFwL1NuYXBUby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9zbmFwL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9zbmFwL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvQXJyYXkuZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0FycmF5LmlzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9BdWRpb0NvbnRleHRNb25rZXlQYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0Z1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9NYXRoLnRydW5jLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvVWludDMyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9jb25zb2xlLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvcGVyZm9ybWFuY2Uubm93LmpzIiwid2VicGFjazovLy9zcmMvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci9jYW52YXMvdXRpbHMvRHJhd0ltYWdlLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvUGFydGljbGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9QYXJ0aWNsZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9BdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0JpbmRWZXJ0ZXhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlQXR0cmliRGVzYy5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlU2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9JbmRleEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvVmVydGV4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL1ZlcnRleEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCJ3ZWJwYWNrOi8vLy4uL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL1N0YXRlLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9TdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3N0YXRlL3N5c3RlbXMvTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL01haW5Mb29wLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL1VwZGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0cnVjdHMvU2V0LmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9GcmFtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL0ZyYW1lLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9JbWFnZVRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkFycmF5VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OSGFzaFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvUHl4ZWxUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9TdGFybGluZ1hNTFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9HZXRSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9Sb3RhdGVSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvU2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3JpY2gvRG9jdW1lbnRzL3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoYXNlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGhhc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTzs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN6REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN2QkEsK0NDQUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUcsdUJBQXVCLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3JRQSxTQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPLHNHQUFzRztBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUU1S0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDSkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87QUFDakMsOEJBQThCLFdBQVc7QUFDekMsK0JBQStCLFlBQVk7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNyS0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTdJQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUMzQkEsbUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHFDQUFxQyxjQUFjOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHFDQUFxQyxjQUFjOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFF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QzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyT0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0MsbUNBQW1DLFlBQVk7QUFDL0MsaUNBQWlDLHFCQUFxQjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUVyTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUU1V0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPO0FBQ2pDLCtCQUErQixZQUFZOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDeEpBO0FBQ0E7QUFDQSwwQkFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFOUNBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTtBRENBLG1CQ0FBLENEQUEsR0NBQTs7Ozs7OztBQ1JBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7O0FBRUEseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7O0FBRUQ7Ozs7Ozs7QUV0VkE7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUVwK0JBLFNDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7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QUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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QTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7O0FBRUEsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTNCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWJBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVUQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbkJBLFVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWxCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEs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QSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBLGdCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVsQkE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLDBCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7Ozs7QUVoQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGLHFCQUFxQjs7QUFFckc7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLHlEQUF5RDs7QUFFM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSx1QkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXJDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBOzs7Ozs7OztBRWxCQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFdENBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixXQUFXOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUV0Q0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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Q0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFYkE7QUFDQTtBQUNBLDRCQUE0QixTQUFTOztBQUVyQztBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRU5BO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCwrQkFBK0IsY0FBYzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3REQTs7QUFFQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFZEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFUkEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFZkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFakNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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LFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsUUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVOQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2RBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FDL0JELDhDQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHFEQUFxRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakVBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7O0FBRTdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDOUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUUxVUE7O0FBRUE7O0FBRUEsUUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVOQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV4REE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1COztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLHlCQUF5Qjs7QUFFbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV2aUJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSx1QkNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXZDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7Ozs7OztBRTFOQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQix5Q0FBeUM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHlDQUF5QztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNoRkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuTEE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRTdXQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLE9BQU8sT0FBTyx1Q0FBdUMsbUJBQW1CLFlBQVk7QUFDeEcsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUzSkE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV2UEE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFMUhBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs4Q0NuTHRDLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxZREFBLG1CQ0FBLENEQUEsQ0NBQTtBQUNBLGFEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFdEQUEsbUJDQUEsQ0RBQSxFQ0FBO0FBQ0EscUJEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBLGlCREFBLG1CQ0FBLENEQUEsQ0NBQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLG1CREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQSxLQUFLOztBQUVMLFdEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBLGVEQUEsbUJDQUEsQ0RBQSxFQ0FBO0FBQ0EsaUJEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBOztBQUVBOztBQUVBOztBREVBLG1CQ0FBLENEQUEsRUNBQTtBRENBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InBoYXNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiUGhhc2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlBoYXNlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQaGFzZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vcnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9yeSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0fSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMzMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMmQ4NjE0ZmYyZWMxZGQ2MGQxMDAiLCJ2YXIgUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcblxuICAgIFZFUlNJT046ICczLjAuMCcsXG5cbiAgICBBVVRPOiAwLFxuICAgIENBTlZBUzogMSxcbiAgICBXRUJHTDogMixcblxuICAgIElNQUdFOiAyMCxcblxuICAgIHN0YXRlOiB7XG5cbiAgICAgICAgUEVORElORzogMCxcbiAgICAgICAgSU5TVEFMTEVEOiAxLFxuXG4gICAgICAgIEJPT1Q6IDAsXG4gICAgICAgIElOSVQ6IDEsXG4gICAgICAgIFBSRUxPQUQ6IDIsXG4gICAgICAgIENSRUFURTogMyxcbiAgICAgICAgVVBEQVRFOiA0LFxuICAgICAgICBSRU5ERVI6IDUsXG4gICAgICAgIFNIVVRET1dOOiA2XG5cbiAgICB9LFxuXG4gICAgYmxlbmRNb2Rlczoge1xuXG4gICAgICAgIE5PUk1BTDogMCxcbiAgICAgICAgQUREOiAxLFxuICAgICAgICBNVUxUSVBMWTogMixcbiAgICAgICAgU0NSRUVOOiAzLFxuICAgICAgICBPVkVSTEFZOiA0LFxuICAgICAgICBEQVJLRU46IDUsXG4gICAgICAgIExJR0hURU46IDYsXG4gICAgICAgIENPTE9SX0RPREdFOiA3LFxuICAgICAgICBDT0xPUl9CVVJOOiA4LFxuICAgICAgICBIQVJEX0xJR0hUOiA5LFxuICAgICAgICBTT0ZUX0xJR0hUOiAxMCxcbiAgICAgICAgRElGRkVSRU5DRTogMTEsXG4gICAgICAgIEVYQ0xVU0lPTjogMTIsXG4gICAgICAgIEhVRTogMTMsXG4gICAgICAgIFNBVFVSQVRJT046IDE0LFxuICAgICAgICBDT0xPUjogMTUsXG4gICAgICAgIExVTUlOT1NJVFk6IDE2XG5cbiAgICB9LFxuXG4gICAgc2NhbGVNb2Rlczoge1xuXG4gICAgICAgIERFRkFVTFQ6IDAsXG4gICAgICAgIExJTkVBUjogMCxcbiAgICAgICAgTkVBUkVTVDogMVxuXG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSB7XG5cbiAgICBQSTI6IE1hdGguUEkgKiAyLFxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcbiAgICBFUFNJTE9OOiAxLjBlLTYsXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTUFUSF9DT05TVDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZJTEVfQ09OU1QgPSB7XG5cbiAgICBMT0FERVJfSURMRTogMCxcbiAgICBMT0FERVJfTE9BRElORzogMSxcbiAgICBMT0FERVJfUFJPQ0VTU0lORzogMixcbiAgICBMT0FERVJfQ09NUExFVEU6IDMsXG4gICAgTE9BREVSX0RFU1RST1lFRDogNCxcblxuICAgIEZJTEVfUEVORElORzogNSwgICAgICAvLyBmaWxlIGlzIGluIHRoZSBsb2FkIHF1ZXVlIGJ1dCBub3QgeWV0IHN0YXJ0ZWRcbiAgICBGSUxFX0xPQURJTkc6IDYsICAgICAgLy8gZmlsZSBoYXMgYmVlbiBzdGFydGVkIHRvIGxvYWQgYnkgdGhlIGxvYWRlciAob25Mb2FkIGNhbGxlZClcbiAgICBGSUxFX0xPQURFRDogNywgICAgICAgLy8gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgYXdhaXRpbmcgcHJvY2Vzc2luZ1xuICAgIEZJTEVfRkFJTEVEOiA4LCAgICAgICAvLyBmaWxlIGZhaWxlZCB0byBsb2FkXG4gICAgRklMRV9QUk9DRVNTSU5HOiA5LCAgIC8vIGZpbGUgaXMgYmVpbmcgcHJvY2Vzc2VkIChvblByb2Nlc3MgY2FsbGJhY2spXG4gICAgRklMRV9XQUlUSU5HX0xJTktGSUxFOiAxMCwgICAvLyBmaWxlIGlzIGJlaW5nIHByb2Nlc3NlZCAob25Qcm9jZXNzIGNhbGxiYWNrKVxuICAgIEZJTEVfRVJST1JFRDogMTEsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcbiAgICBGSUxFX0NPTVBMRVRFOiAxMiwgICAgIC8vIGZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcbiAgICBGSUxFX0RFU1RST1lFRDogMTMsICAgICAvLyBmaWxlIGhhcyBiZWVuIGRlc3Ryb3llZFxuXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0FSUkFZOiAyMCxcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fSEFTSDogMjFcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGSUxFX0NPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9PUy5qcyIsInZhciBPUyA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBkZXNrdG9wIC0gSXMgcnVubmluZyBvbiBhIGRlc2t0b3A/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgZGVza3RvcDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXBwIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBhcyBhIFdlYkFwcCwgaS5lLiB3aXRoaW4gYSBXZWJWaWV3XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgd2ViQXBwOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpT1MgLSBJcyBydW5uaW5nIG9uIGlPUz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpT1M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gaU9TVmVyc2lvbiAtIElmIHJ1bm5pbmcgaW4gaU9TIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpT1NWZXJzaW9uOiAwLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlQaG9uZSAtIElzIHJ1bm5pbmcgb24gaVBob25lP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGlQaG9uZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaVBhZCAtIElzIHJ1bm5pbmcgb24gaVBhZD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpUGFkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2Nvb25KUyAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgQ29jb29uSlM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgY29jb29uSlM6IGZhbHNlLFxuICAgIFxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2Nvb25KU0FwcCAtIElzIHRoaXMgZ2FtZSBydW5uaW5nIHdpdGggQ29jb29uSlMuQXBwP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNvY29vbkpTQXBwOiBmYWxzZSxcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29yZG92YSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgQXBhY2hlIENvcmRvdmE/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgY29yZG92YTogZmFsc2UsXG4gICAgXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vZGUgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIE5vZGUuanM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbm9kZTogZmFsc2UsXG4gICAgXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vZGVXZWJraXQgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIE5vZGUtV2Via2l0P1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG5vZGVXZWJraXQ6IGZhbHNlLFxuICAgIFxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbGVjdHJvbiAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgR2l0SHViIEVsZWN0cm9uP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVsZWN0cm9uOiBmYWxzZSxcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWplY3RhIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBFamVjdGE/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgZWplY3RhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjcm9zc3dhbGsgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIHRoZSBJbnRlbCBDcm9zc3dhbGsgWERLP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNyb3Nzd2FsazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5kcm9pZCAtIElzIHJ1bm5pbmcgb24gYW5kcm9pZD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBhbmRyb2lkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBjaHJvbWVPUyAtIElzIHJ1bm5pbmcgb24gY2hyb21lT1M/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgY2hyb21lT1M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpbnV4IC0gSXMgcnVubmluZyBvbiBsaW51eD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBsaW51eDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFjT1MgLSBJcyBydW5uaW5nIG9uIG1hY09TP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG1hY09TOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3aW5kb3dzIC0gSXMgcnVubmluZyBvbiB3aW5kb3dzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdpbmRvd3M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdpbmRvd3NQaG9uZSAtIElzIHJ1bm5pbmcgb24gYSBXaW5kb3dzIFBob25lP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdpbmRvd3NQaG9uZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdml0YSAtIElzIHJ1bm5pbmcgb24gYSBQbGF5U3RhdGlvbiBWaXRhP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHZpdGE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGtpbmRsZSAtIElzIHJ1bm5pbmcgb24gYW4gQW1hem9uIEtpbmRsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBraW5kbGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbyAtIFBpeGVsUmF0aW8gb2YgdGhlIGhvc3QgZGV2aWNlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHBpeGVsUmF0aW86IDFcblxufTtcblxuZnVuY3Rpb24gaW5pdCAoKVxue1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAoL1dpbmRvd3MvLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1Mud2luZG93cyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9NYWMgT1MvLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MubWFjT1MgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgvTGludXgvLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MubGludXggPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy5hbmRyb2lkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL2lQW2FvXWR8aVBob25lL2kudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy5pT1MgPSB0cnVlO1xuICAgICAgICAobmF2aWdhdG9yLmFwcFZlcnNpb24pLm1hdGNoKC9PUyAoXFxkKykvKTtcbiAgICAgICAgT1MuaU9TVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgvS2luZGxlLy50ZXN0KHVhKSB8fCAoL1xcYktGW0EtWl1bQS1aXSsvKS50ZXN0KHVhKSB8fCAoL1NpbGsuKk1vYmlsZSBTYWZhcmkvKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLmtpbmRsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyB3aWxsIE5PVCBkZXRlY3QgZWFybHkgZ2VuZXJhdGlvbnMgb2YgS2luZGxlIEZpcmUsIEkgdGhpbmsgdGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5Li4uXG4gICAgICAgIC8vIEUuZy4gXCJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBVOyBJbnRlbCBNYWMgT1MgWCAxMF82XzM7IGVuLXVzOyBTaWxrLzEuMS4wLTgwKSBBcHBsZVdlYktpdC81MzMuMTYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzUuMCBTYWZhcmkvNTMzLjE2IFNpbGstQWNjZWxlcmF0ZWQ9dHJ1ZVwiXG4gICAgfVxuICAgIGVsc2UgaWYgKC9Dck9TLy50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLmNocm9tZU9TID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKC9QbGF5c3RhdGlvbiBWaXRhLykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy52aXRhID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoL1dpbmRvd3MgUGhvbmUvaS50ZXN0KHVhKSB8fCAoL0lFTW9iaWxlL2kpLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MuYW5kcm9pZCA9IGZhbHNlO1xuICAgICAgICBPUy5pT1MgPSBmYWxzZTtcbiAgICAgICAgT1MubWFjT1MgPSBmYWxzZTtcbiAgICAgICAgT1Mud2luZG93cyA9IHRydWU7XG4gICAgICAgIE9TLndpbmRvd3NQaG9uZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNpbGsgPSAoL1NpbGsvKS50ZXN0KHVhKTtcblxuICAgIGlmIChPUy53aW5kb3dzIHx8IE9TLm1hY09TIHx8IChPUy5saW51eCAmJiAhc2lsaykgfHwgT1MuY2hyb21lT1MpXG4gICAge1xuICAgICAgICBPUy5kZXNrdG9wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAgV2luZG93cyBQaG9uZSAvIFRhYmxlIHJlc2V0XG4gICAgaWYgKE9TLndpbmRvd3NQaG9uZSB8fCAoKC9XaW5kb3dzIE5UL2kudGVzdCh1YSkpICYmICgvVG91Y2gvaS50ZXN0KHVhKSkpKVxuICAgIHtcbiAgICAgICAgT1MuZGVza3RvcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vICBXZWJBcHAgbW9kZSBpbiBpT1NcbiAgICBpZiAobmF2aWdhdG9yLnN0YW5kYWxvbmUpXG4gICAge1xuICAgICAgICBPUy53ZWJBcHAgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAod2luZG93LmNvcmRvdmEgIT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIE9TLmNvcmRvdmEgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKSlcbiAgICB7XG4gICAgICAgIE9TLm5vZGUgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoT1Mubm9kZSAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PT0gJ29iamVjdCcpXG4gICAge1xuICAgICAgICBPUy5ub2RlV2Via2l0ID0gISFwcm9jZXNzLnZlcnNpb25zWydub2RlLXdlYmtpdCddO1xuICAgICAgICBcbiAgICAgICAgT1MuZWxlY3Ryb24gPSAhIXByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247XG4gICAgfVxuICAgIFxuICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUylcbiAgICB7XG4gICAgICAgIE9TLmNvY29vbkpTID0gdHJ1ZTtcblxuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgT1MuY29jb29uSlNBcHAgPSAodHlwZW9mIENvY29vbkpTICE9PSAndW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKVxuICAgICAgICB7XG4gICAgICAgICAgICBPUy5jb2Nvb25KU0FwcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5lamVjdGEgIT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIE9TLmVqZWN0YSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCgvQ3Jvc3N3YWxrLykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy5jcm9zc3dhbGsgPSB0cnVlO1xuICAgIH1cblxuICAgIE9TLmlQaG9uZSA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaXBob25lJykgIT09IC0xO1xuICAgIE9TLmlQYWQgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwYWQnKSAhPT0gLTE7XG5cbiAgICBPUy5waXhlbFJhdGlvID0gd2luZG93WydkZXZpY2VQaXhlbFJhdGlvJ10gfHwgMTtcblxuICAgIHJldHVybiBPUztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvT1MuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xuXG52YXIgQnJvd3NlciA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhcm9yYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQXJvcmEuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgYXJvcmE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQ2hyb21lLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNocm9tZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaHJvbWVWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBDaHJvbWUgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNocm9tZVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXBpcGhhbnkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEVwaXBoYW55LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVwaXBoYW55OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaXJlZm94IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBGaXJlZm94LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGZpcmVmb3g6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gZmlyZWZveFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEZpcmVmb3ggdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGZpcmVmb3hWZXJzaW9uOiAwLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vYmlsZVNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gTW9iaWxlIFNhZmFyaS5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBtb2JpbGVTYWZhcmk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGllIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gQmV5b25kIElFMTAgeW91IHNob3VsZCB1c2UgRGV2aWNlLnRyaWRlbnQgYW5kIERldmljZS50cmlkZW50VmVyc2lvbi5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpZVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWlkb3JpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWRvcmkuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbWlkb3JpOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvcGVyYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gT3BlcmEuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgb3BlcmE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gU2FmYXJpLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHNhZmFyaTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYWZhcmlWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBTYWZhcmkgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHNhZmFyaVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJpZGVudCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYSBUcmlkZW50IHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXIgKElFMTErKVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRyaWRlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdHJpZGVudFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIDExIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gU2VlIHtAbGluayBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1Mzc1MDModj12cy44NSkuYXNweH1cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0cmlkZW50VmVyc2lvbjogMCxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlZGdlIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWNyb3NvZnQgRWRnZSBicm93c2VyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVkZ2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNpbGsgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIHRoZSBTaWxrIGJyb3dzZXIgKGFzIHVzZWQgb24gdGhlIEFtYXpvbiBLaW5kbGUpXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgc2lsazogZmFsc2VcblxufTtcblxuZnVuY3Rpb24gaW5pdCAoKVxue1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAoKC9Bcm9yYS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5hcm9yYSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9FZGdlXFwvXFxkKy8udGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0Nocm9tZVxcLyhcXGQrKS8pLnRlc3QodWEpICYmICFPUy53aW5kb3dzUGhvbmUpXG4gICAge1xuICAgICAgICBCcm93c2VyLmNocm9tZSA9IHRydWU7XG4gICAgICAgIEJyb3dzZXIuY2hyb21lVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0VwaXBoYW55LykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLmVwaXBoYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKC9GaXJlZm94XFxEKyhcXGQrKS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgQnJvd3Nlci5maXJlZm94VmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0FwcGxlV2ViS2l0LykudGVzdCh1YSkgJiYgT1MuaU9TKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5tb2JpbGVTYWZhcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL01TSUUgKFxcZCtcXC5cXGQrKTsvKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLmllVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL01pZG9yaS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5taWRvcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL09wZXJhLykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLm9wZXJhID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKC9TYWZhcmkvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL1RyaWRlbnRcXC8oXFxkK1xcLlxcZCspKC4qKXJ2OihcXGQrXFwuXFxkKykvKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLnRyaWRlbnQgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLnRyaWRlbnRWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQzLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gIFNpbGsgZ2V0cyBpdHMgb3duIGlmIGNsYXVzZSBiZWNhdXNlIGl0cyB1YSBhbHNvIGNvbnRhaW5zICdTYWZhcmknXG4gICAgaWYgKCgvU2lsay8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gQnJvd3Nlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQnJvd3Nlci5qcyIsInZhciBBbmdsZSA9IGZ1bmN0aW9uIChsaW5lKVxue1xuICAgIHJldHVybiBNYXRoLmF0YW4yKGxpbmUueTIgLSBsaW5lLnkxLCBsaW5lLngyIC0gbGluZS54MSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLy8gIEVuY2Fwc3VsYXRlcyBhIDJEIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb3JuZXIgcG9pbnQgaW4gdGhlIHRvcC1sZWZ0XG4vLyAgYW5kIGl0cyBleHRlbmRzIGluIHggKHdpZHRoKSBhbmQgeSAoaGVpZ2h0KVxuXG52YXIgUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDA7IH1cbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG5cblJlY3RhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cblxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCk7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWN0YW5nbGUucHJvdG90eXBlLCB7XG5cbiAgICBsZWZ0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLnJpZ2h0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0IC0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmlnaHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLngpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHZhbHVlIC0gdGhpcy54O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9wOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLmJvdHRvbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5ib3R0b20gLSB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBib3R0b206IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy55KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHZhbHVlIC0gdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0VVJMID0gcmVxdWlyZSgnLi9HZXRVUkwnKTtcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbnZhciBYSFJMb2FkZXIgPSByZXF1aXJlKCcuL1hIUkxvYWRlcicpO1xudmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xudmFyIE1lcmdlWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL01lcmdlWEhSU2V0dGluZ3MnKTtcblxudmFyIEZpbGUgPSBmdW5jdGlvbiAodHlwZSwga2V5LCB1cmwsIHJlc3BvbnNlVHlwZSwgeGhyU2V0dGluZ3MpXG57XG4gICAgLy8gIGZpbGUgdHlwZSAoaW1hZ2UsIGpzb24sIGV0YykgZm9yIHNvcnRpbmcgd2l0aGluIHRoZSBMb2FkZXJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLy8gIHVuaXF1ZSBjYWNoZSBrZXkgKHVuaXF1ZSB3aXRoaW4gaXRzIGZpbGUgdHlwZSlcbiAgICB0aGlzLmtleSA9IGtleTtcblxuICAgIC8vICBUaGUgVVJMIG9mIHRoZSBmaWxlLCBub3QgaW5jbHVkaW5nIGJhc2VVUkxcbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8vICBTZXQgd2hlbiB0aGUgTG9hZGVyIGNhbGxzICdsb2FkJyBvbiB0aGlzIGZpbGVcbiAgICB0aGlzLnNyYyA9ICcnO1xuXG4gICAgdGhpcy54aHJTZXR0aW5ncyA9IFhIUlNldHRpbmdzKHJlc3BvbnNlVHlwZSk7XG5cbiAgICBpZiAoeGhyU2V0dGluZ3MpXG4gICAge1xuICAgICAgICB0aGlzLnhoclNldHRpbmdzID0gTWVyZ2VYSFJTZXR0aW5ncyh0aGlzLnhoclNldHRpbmdzLCB4aHJTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgdGhpcy54aHJMb2FkZXIgPSBudWxsO1xuXG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUEVORElORztcblxuICAgIC8vICBTZXQgYnkgb25Qcm9ncmVzcyAob25seSBpZiBsb2FkaW5nIHZpYSBYSFIpXG4gICAgdGhpcy5ieXRlc1RvdGFsID0gMDtcbiAgICB0aGlzLmJ5dGVzTG9hZGVkID0gLTE7XG4gICAgdGhpcy5wZXJjZW50Q29tcGxldGUgPSAtMTtcblxuICAgIC8vICBGb3IgQ09ScyBiYXNlZCBsb2FkaW5nLlxuICAgIC8vICBJZiB0aGlzIGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBGaWxlIHdpbGwgY2hlY2sgQmFzZUxvYWRlci5jcm9zc09yaWdpbiBhbmQgdXNlIHRoYXQgKGlmIHNldClcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gIFRoZSBhY3R1YWwgcHJvY2Vzc2VkIGZpbGUgZGF0YVxuICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcblxuICAgIC8vICBNdWx0aXBhcnQgZmlsZT8gKGkuZS4gYW4gYXRsYXMgYW5kIGl0cyBqc29uIHRvZ2V0aGVyKVxuICAgIHRoaXMubGlua0ZpbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5rVHlwZSA9ICcnO1xuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG59O1xuXG5GaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGU7XG5cbkZpbGUucHJvdG90eXBlID0ge1xuXG4gICAgcmVzZXRYSFI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnhockxvYWRlci5vbmxvYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9uZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ucHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8vICBDYWxsZWQgd2hlbiB0aGUgSW1hZ2UgbG9hZHNcbiAgICAvLyAgUHJvZ3Jlc3NFdmVudFxuICAgIG9uTG9hZDogZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIHRoaXMucmVzZXRYSFIoKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNMb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzVG90YWwgPSBldmVudC50b3RhbDtcblxuICAgICAgICAgICAgdGhpcy5wZXJjZW50Q29tcGxldGUgPSBNYXRoLm1pbigodGhpcy5ieXRlc0xvYWRlZCAvIHRoaXMuYnl0ZXNUb3RhbCksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wZXJjZW50Q29tcGxldGUgKyAnJSAoJyArIHRoaXMuYnl0ZXNMb2FkZWQgKyAnIGJ5dGVzKScpO1xuICAgIH0sXG5cbiAgICBvblByb2Nlc3M6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XG5cbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG5cbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgfSxcblxuICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5saW5rRmlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlua0ZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfV0FJVElOR19MSU5LRklMRSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGxpbmtmaWxlIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLCBhbmQgaXMgd2FpdGluZyBmb3IgdGhpcyBmaWxlLCBzbyBsZXQncyBkbyB0aGVtIGJvdGhcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtGaWxlLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGxpbmtmaWxlIHN0aWxsIGhhc24ndCBmaW5pc2hlZCBsb2FkaW5nIGFuZC9vciBwcm9jZXNzaW5nIHlldFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1dBSVRJTkdfTElOS0ZJTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9DT01QTEVURTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBMb2FkZXIsIHN0YXJ0cyB0aGUgYWN0dWFsIGZpbGUgZG93bmxvYWRpbmdcbiAgICBsb2FkOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2VVUkwsIGdsb2JhbFhIUilcbiAgICB7XG4gICAgICAgIGlmIChiYXNlVVJMID09PSB1bmRlZmluZWQpIHsgYmFzZVVSTCA9ICcnOyB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMuc3JjID0gR2V0VVJMKHRoaXMsIGJhc2VVUkwpO1xuXG4gICAgICAgIGlmICh0aGlzLnNyYy5pbmRleE9mKCdkYXRhOicpID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9jYWwgZGF0YSBVUkknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueGhyTG9hZGVyID0gWEhSTG9hZGVyKHRoaXMsIGdsb2JhbFhIUik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvRmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvRmlsZS5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgZ2xvYmFsIGxldmVsIGNvbnRhaW5lciBvZiBGYWN0b3J5IGluc3RhbmNlcy5cbiogRmFjdG9yaWVzIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB0aGlzIGNvbnRhaW5lciAod2hlbiByZXF1aXJlZClcbipcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiovXG5cbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIEZhY3RvcnlDb250YWluZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKCdGYWN0b3J5Q29udGFpbmVyIGlzIGFsaXZlJyk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZhY3RvcnkpXG4gICAge1xuICAgICAgICBpZiAoZmFjdG9yaWVzLmhhc093blByb3BlcnR5KGZhY3RvcnkuS0VZKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FscmVhZHkgcmVnaXN0ZXJlZCcsIGZhY3RvcnkuS0VZKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShmYWN0b3J5LktFWSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcnLCBmYWN0b3J5LktFWSk7XG5cbiAgICAgICAgZmFjdG9yaWVzW2ZhY3RvcnkuS0VZXSA9IHtcbiAgICAgICAgICAgIGFkZDogZmFjdG9yeS5hZGQsXG4gICAgICAgICAgICBtYWtlOiBmYWN0b3J5Lm1ha2VcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRUeXBlID0gZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWN0b3JpZXNba2V5XTtcbiAgICB9O1xuXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24gKGRlc3QsIGlzRmFjdG9yeSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGZhY3RvcnkgaW4gZmFjdG9yaWVzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmFjdG9yaWVzLmhhc093blByb3BlcnR5KGZhY3RvcnkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2FkaW5nJywgZmFjdG9yeSk7XG5cbiAgICAgICAgICAgICAgICBkZXN0W2ZhY3RvcnldID0gKGlzRmFjdG9yeSkgPyBmYWN0b3JpZXNbZmFjdG9yeV0uYWRkIDogZmFjdG9yaWVzW2ZhY3RvcnldLm1ha2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdyYXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KVxue1xuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbjtcblxuICAgIGlmIChyYW5nZSA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSAtIG1pbikgJSByYW5nZTtcblxuICAgIGlmIChyZXN1bHQgPCAwKVxuICAgIHtcbiAgICAgICAgcmVzdWx0ICs9IHJhbmdlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyBtaW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXRoV3JhcCA9IHJlcXVpcmUoJy4uL1dyYXAnKTtcblxudmFyIFdyYXAgPSBmdW5jdGlvbiAoYW5nbGUpXG57XG4gICAgcmV0dXJuIE1hdGhXcmFwKGFuZ2xlLCAtTWF0aC5QSSwgTWF0aC5QSSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1dyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsIi8vICBTb3VyY2Ugb2JqZWN0XG4vLyAgVGhlIGtleSBhcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Yga2V5cywgaS5lLiAnYmFubmVyJywgb3IgJ2Jhbm5lci5oaWRlQmFubmVyJ1xuLy8gIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RcblxudmFyIEdldE9iamVjdFZhbHVlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpXG57XG4gICAgaWYgKGtleS5pbmRleE9mKCcuJykpXG4gICAge1xuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgcGFyZW50ID0gc291cmNlO1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgLy8gIFVzZSBmb3IgbG9vcCBoZXJlIHNvIHdlIGNhbiBicmVhayBlYXJseVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gIFllcyBpdCBoYXMgYSBrZXkgcHJvcGVydHksIGxldCdzIGNhcnJ5IG9uIGRvd25cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmVudFtrZXlzW2ldXTtcblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkgPyBzb3VyY2Vba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9iamVjdFZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvR2V0T2JqZWN0VmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IGZ1bmN0aW9uICh0eXBlKVxue1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICB0aGlzLnRhcmdldDtcblxuICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IHRydWU7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudDtcblxuRXZlbnQucHJvdG90eXBlID0ge1xuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICh0YXJnZXQpXG4gICAge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGUgPSBmYWxzZTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudEJpbmRpbmcgPSByZXF1aXJlKCcuL0V2ZW50QmluZGluZycpO1xuXG52YXIgRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXZlbnREaXNwYXRjaGVyO1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0QmluZGluZzogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlQmluZGluZzogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0QmluZGluZyh0eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlXSA9IG5ldyBFdmVudEJpbmRpbmcodGhpcywgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXG4gICAge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkgeyBwcmlvcml0eSA9IDA7IH1cblxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5hZGQobGlzdGVuZXIsIHByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25jZTogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCBwcmlvcml0eSlcbiAgICB7XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7IHByaW9yaXR5ID0gMDsgfVxuXG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5jcmVhdGVCaW5kaW5nKHR5cGUpO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nLmFkZChsaXN0ZW5lciwgcHJpb3JpdHksIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBBZGQgYSBjYWxsYmFjayB0aGF0IGlzIG5vdGlmaWVkIGV2ZXJ5IHRpbWUgdGhpcyBFdmVudERpc3BhdGNoZXIgZGlzcGF0Y2hlcyBhbiBldmVudFxuICAgIC8vICBubyBtYXR0ZXIgd2hhdCB0aGUgZXZlbnQgdHlwZSBpcy4gRmlsdGVycyBhcmUgaW52b2tlZCBmaXJzdCwgYmVmb3JlIGFueSBiaW5kaW5ncyxcbiAgICAvLyAgYW5kIGNhbiBzdG9wIGV2ZW50cyBpZiB0aGV5IHdpc2ggKGluIHdoaWNoIGNhc2UgdGhleSdsbCBuZXZlciByZWFjaCB0aGUgYmluZGluZ3MpXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spXG4gICAge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZmlsdGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblxuICAgICAgICBpZiAoaSA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBBZGQgdGhlIGZpbHRlclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFJlbW92ZSB0aGUgZmlsdGVyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSAodGhpcy5maWx0ZXJzLmxlbmd0aCA+IDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcilcbiAgICB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy5oYXMobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvdGFsOiBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy50b3RhbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgIC8vICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggdGhlIEV2ZW50RGlzcGF0Y2hlciwgYSBjYWxsIHRvIHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3QuXG4gICAgb2ZmOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpXG4gICAge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5yZW1vdmUobGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXNwYXRjaEhhbmRsZXI6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIGV2ZW50LnJlc2V0KHRoaXMpO1xuXG4gICAgICAgIC8vICBQYXNzIHRoZSBldmVudCB0aHJvdWdoIHRoZSBmaWx0ZXJzIGZpcnN0XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRmlsdGVycylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gIERpZCB0aGUgZmlsdGVyIGtpbGwgdGhlIGV2ZW50PyBJZiBzbywgd2UgY2FuIGFib3J0IG5vd1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuX3Byb3BhZ2F0ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhldmVudC50eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5kaXNwYXRjaChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEhhbmRsZXIoZXZlbnRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBidXQgcmV0YWlucyB0aGUgZXZlbnQgdHlwZSBlbnRyaWVzXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nLnJlbW92ZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZUFsbEZpbHRlcnM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmZpbHRlcnMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmhhc0ZpbHRlcnMgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKHR5cGUpO1xuXG4gICAgICAgIGlmIChiaW5kaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZGVsZXRlQWxsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgYmluZGluZyBpbiB0aGlzLmJpbmRpbmdzKVxuICAgICAgICB7XG4gICAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuZGVsZXRlQWxsKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRmlsdGVycygpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwiXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XG5cbnZhciBJbWFnZUZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxue1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XG5cbiAgICBpZiAoIWtleSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuaW1hZ2VcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5wbmcnO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAnaW1hZ2UnLCBrZXksIHVybCwgJ2Jsb2InLCB4aHJTZXR0aW5ncyk7XG59O1xuXG5JbWFnZUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XG5JbWFnZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VGaWxlO1xuXG5JbWFnZUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcbntcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xuXG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XG5cbiAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XG5cbiAgICAgICAgX3RoaXMub25Db21wbGV0ZSgpO1xuXG4gICAgICAgIGNhbGxiYWNrKF90aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kYXRhLm9uZXJyb3IgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XG5cbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xuICAgIH07XG5cbiAgICB0aGlzLmRhdGEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnhockxvYWRlci5yZXNwb25zZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsInZhciBJc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9Jc1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmV4dGVuZC9cbiogXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLmV4dGVuZFxuKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXAgLSBQZXJmb3JtIGEgZGVlcCBjb3B5P1xuKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gY29weSB0by5cbiogQHJldHVybiB7b2JqZWN0fSBUaGUgZXh0ZW5kZWQgb2JqZWN0LlxuKi9cbnZhciBFeHRlbmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBpID0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIilcbiAgICB7XG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICBpID0gMjtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgUGhhc2VyIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgIGlmIChsZW5ndGggPT09IGkpXG4gICAge1xuICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAtLWk7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKElzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb3B5KSkpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBJc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBFeHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0V4dGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQ2hpbGRyZW46IHJlcXVpcmUoJy4vQ2hpbGRyZW4nKSxcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxuICAgIERhdGE6IHJlcXVpcmUoJy4vRGF0YScpLFxuICAgIFRyYW5zZm9ybTogcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9pbmRleC5qcyIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXG57XG4gICAgLy8gIENoZWNrIGlmIHgveSBhcmUgd2l0aGluIHRoZSBib3VuZHMgZmlyc3RcbiAgICBpZiAoY2lyY2xlLnJhZGl1cyA+IDAgJiYgeCA+PSBjaXJjbGUubGVmdCAmJiB4IDw9IGNpcmNsZS5yaWdodCAmJiB5ID49IGNpcmNsZS50b3AgJiYgeSA8PSBjaXJjbGUuYm90dG9tKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gKGNpcmNsZS54IC0geCkgKiAoY2lyY2xlLnggLSB4KTtcbiAgICAgICAgdmFyIGR5ID0gKGNpcmNsZS55IC0geSkgKiAoY2lyY2xlLnkgLSB5KTtcblxuICAgICAgICByZXR1cm4gKGR4ICsgZHkpIDw9IChjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChlbGxpcHNlLCB4LCB5KVxue1xuICAgIGlmIChlbGxpcHNlLndpZHRoIDw9IDAgfHwgZWxsaXBzZS5oZWlnaHQgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gXG4gICAgLy8gIE5vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwIGFuZCBhIHJhZGl1cyBvZiAwLjVcbiAgICB2YXIgbm9ybXggPSAoKHggLSBlbGxpcHNlLngpIC8gZWxsaXBzZS53aWR0aCkgLSAwLjU7XG4gICAgdmFyIG5vcm15ID0gKCh5IC0gZWxsaXBzZS55KSAvIGVsbGlwc2UuaGVpZ2h0KSAtIDAuNTtcbiBcbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcbiBcbiAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPCAwLjI1KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBDb252ZXJ0IGEgZGlzdGFuY2UgYWxvbmcgdGhpcyBjdXJ2ZSBpbnRvIGEgYHRpbWVgIHZhbHVlIHdoaWNoIHdpbGwgYmUgYmV0d2VlbiAwIGFuZCAxLlxuKiBcbiogRm9yIGV4YW1wbGUgaWYgdGhpcyBjdXJ2ZSBoYXMgYSBsZW5ndGggb2YgMTAwIHBpeGVscyB0aGVuIGBmaW5kVCg1MClgIHdvdWxkIHJldHVybiBgMC41YC5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNmaW5kVFxuKiBAcGFyYW0ge2ludGVnZXJ9IGRpc3RhbmNlIC0gVGhlIGRpc3RhbmNlIGludG8gdGhlIGN1cnZlIGluIHBpeGVscy4gU2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgdGltZSAoYHRgKSB2YWx1ZSwgYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4qL1xudmFyIEZpbmRUID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSlcbntcbiAgICBpZiAoZGlzdGFuY2UgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vICBGaW5kIHRoZSBfcG9pbnRzIHdoaWNoIGJyYWNrZXQgdGhlIGRpc3RhbmNlIHZhbHVlXG4gICAgdmFyIHRpID0gTWF0aC5mbG9vcihkaXN0YW5jZSAvIGN1cnZlLmxlbmd0aCAqIGN1cnZlLl9hY2N1cmFjeSk7XG5cbiAgICB3aGlsZSAodGkgPiAwICYmIGN1cnZlLl9wb2ludHNbdGldID4gZGlzdGFuY2UpXG4gICAge1xuICAgICAgICB0aS0tO1xuICAgIH1cblxuICAgIHdoaWxlICh0aSA8IGN1cnZlLl9hY2N1cmFjeSAmJiBjdXJ2ZS5fcG9pbnRzW3RpXSA8IGRpc3RhbmNlKVxuICAgIHtcbiAgICAgICAgdGkrKztcbiAgICB9XG5cbiAgICAvLyAgTGluZWFyIGludGVycG9sYXRpb24gdG8gZ2V0IGEgbW9yZSBhY2N1cmF0ZSBmaXhcbiAgICB2YXIgZHQgPSBjdXJ2ZS5fcG9pbnRzW3RpXSAtIGN1cnZlLl9wb2ludHNbdGkgLSAxXTtcbiAgICB2YXIgZCA9IGRpc3RhbmNlIC0gY3VydmUuX3BvaW50c1t0aSAtIDFdO1xuXG4gICAgcmV0dXJuICgodGkgLSAxKSAvIGN1cnZlLl9hY2N1cmFjeSkgKyBkIC8gKGR0ICogY3VydmUuX2FjY3VyYWN5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmluZFQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvRmluZFQuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbi8qKlxuKiBHZXQgYSBwb2ludCBvbiB0aGUgY3VydmUgdXNpbmcgdGhlIGB0YCAodGltZSkgdmFsdWUsIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50XG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8T2JqZWN0fSBbcG9pbnRdIC0gQW4gb3B0aW9uYWwgUGhhc2VyLlBvaW50LCBvciBPYmplY3QgY29udGFpbmluZyBwdWJsaWMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgZ2l2ZW4gdGhlIHJlc3VsdGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIE9iamVjdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgb21pdHRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQW4gT2JqZWN0IHdpdGggdGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgYXQgdGhlIHNwZWNpZmllZCBgdGAgdmFsdWUgc2V0IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxuKi9cbnZhciBHZXRQb2ludCA9IGZ1bmN0aW9uIChjdXJ2ZSwgdCwgb3V0KVxue1xuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIGlmICh0IDwgMClcbiAgICB7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0ID4gMSlcbiAgICB7XG4gICAgICAgIHQgPSAxO1xuICAgIH1cblxuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciB0MyA9IHQgKiB0MjtcblxuICAgIG91dC54ID0gdDMgKiBjdXJ2ZS5fYXggKyB0MiAqIGN1cnZlLl9ieCArIHQgKiBjdXJ2ZS5fdjF4ICsgY3VydmUuX3AxeDtcbiAgICBvdXQueSA9IHQzICogY3VydmUuX2F5ICsgdDIgKiBjdXJ2ZS5fYnkgKyB0ICogY3VydmUuX3YxeSArIGN1cnZlLl9wMXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwiXG52YXIgUm90YXRlQXJvdW5kWFkgPSBmdW5jdGlvbiAobGluZSwgeCwgeSwgYW5nbGUpXG57XG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICB2YXIgdHggPSBsaW5lLngxIC0geDtcbiAgICB2YXIgdHkgPSBsaW5lLnkxIC0geTtcblxuICAgIGxpbmUueDEgPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xuICAgIGxpbmUueTEgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgdHggPSBsaW5lLngyIC0geDtcbiAgICB0eSA9IGxpbmUueTIgLSB5O1xuXG4gICAgbGluZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XG4gICAgbGluZS55MiA9IHR4ICogcyArIHR5ICogYyArIHk7XG5cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlQXJvdW5kWFk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEb3QgPSBmdW5jdGlvbiAocG9pbnRBLCBwb2ludEIpXG57XG4gICAgcmV0dXJuICgocG9pbnRBLnggKiBwb2ludEIueCkgKyAocG9pbnRBLnkgKiBwb2ludEIueSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0RvdC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldEFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKHJlY3QpXG57XG4gICAgcmV0dXJuIChyZWN0LmhlaWdodCA9PT0gMCkgPyBOYU4gOiByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldEFzcGVjdFJhdGlvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBDcmVhdGVzIGFuIFhIUlNldHRpbmdzIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXG5cbnZhciBYSFJTZXR0aW5ncyA9IGZ1bmN0aW9uIChyZXNwb25zZVR5cGUsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCwgdGltZW91dClcbntcbiAgICBpZiAocmVzcG9uc2VUeXBlID09PSB1bmRlZmluZWQpIHsgcmVzcG9uc2VUeXBlID0gJyc7IH1cbiAgICBpZiAoYXN5bmMgPT09IHVuZGVmaW5lZCkgeyBhc3luYyA9IHRydWU7IH1cbiAgICBpZiAodXNlciA9PT0gdW5kZWZpbmVkKSB7IHVzZXIgPSAnJzsgfVxuICAgIGlmIChwYXNzd29yZCA9PT0gdW5kZWZpbmVkKSB7IHBhc3N3b3JkID0gJyc7IH1cbiAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7IHRpbWVvdXQgPSAwOyB9XG5cbiAgICAvLyBCZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QsIHNldCB0aGUgeGhyLnJlc3BvbnNlVHlwZSB0byBcInRleHRcIiwgXG4gICAgLy8gXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgb3IgXCJkb2N1bWVudFwiLCBkZXBlbmRpbmcgb24geW91ciBkYXRhIG5lZWRzLiBcbiAgICAvLyBOb3RlLCBzZXR0aW5nIHhoci5yZXNwb25zZVR5cGUgPSAnJyAob3Igb21pdHRpbmcpIHdpbGwgZGVmYXVsdCB0aGUgcmVzcG9uc2UgdG8gXCJ0ZXh0XCIuXG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIC8vICBJZ25vcmVkIGJ5IHRoZSBMb2FkZXIsIG9ubHkgdXNlZCBieSBGaWxlLlxuICAgICAgICByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZSxcblxuICAgICAgICBhc3luYzogYXN5bmMsXG5cbiAgICAgICAgLy8gIGNyZWRlbnRpYWxzXG4gICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcblxuICAgICAgICAvLyAgdGltZW91dCBpbiBtcyAoMCA9IG5vIHRpbWVvdXQpXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG5cbiAgICAgICAgLy8gIHNldFJlcXVlc3RIZWFkZXJcbiAgICAgICAgaGVhZGVyOiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlclZhbHVlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gIG92ZXJyaWRlTWltZVR5cGVcbiAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogdW5kZWZpbmVkXG5cbiAgICB9O1xuICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJTZXR0aW5ncztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9YSFJTZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFRoZSBDaGlsZHJlbiBDb21wb25lbnQgZmVhdHVyZXMgcXVpY2sgYWNjZXNzIHRvIEdyb3VwIHNvcnRpbmcgcmVsYXRlZCBtZXRob2RzLlxuKlxuKiBAY2xhc3NcbiovXG52YXIgQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcbntcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xuXG4gICAgLy8gIFRoZSBvYmplY3RzIHRoYXQgYmVsb25nIHRvIHRoaXMgY29sbGVjdGlvbi5cbiAgICAvLyAgVGhlIGVxdWl2YWxlbnQgb2YgdGhlIG9sZCBgU3ByaXRlLmNoaWxkcmVuYCBhcnJheS5cbiAgICB0aGlzLmxpc3QgPSBbXTtcblxuICAgIHRoaXMucG9zaXRpb24gPSAwO1xufTtcblxuQ2hpbGRyZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpbGRyZW47XG5cbkNoaWxkcmVuLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkLCBza2lwVHJhbnNmb3JtKVxuICAgIHtcbiAgICAgICAgaWYgKHNraXBUcmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgeyBza2lwVHJhbnNmb3JtID0gZmFsc2U7IH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPicsIHRoaXMuZ2FtZU9iamVjdC5uYW1lLCAnYWRkcyBuZXcgY2hpbGQ6JywgY2hpbGQubmFtZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NoaWxkcmVuLmFkZCAxJyk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2hpbGRyZW4uYWRkIDInKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcy5nYW1lT2JqZWN0O1xuXG4gICAgICAgIHRoaXMubGlzdC5wdXNoKGNoaWxkKTtcblxuICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0gJiYgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybSAmJiBjaGlsZC50cmFuc2Zvcm0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2FtZU9iamVjdC5uYW1lLCAnYWRkcyB0cmFuc2Zvcm0gZnJvbScsIGNoaWxkLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybS5hZGQoY2hpbGQudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc8LS0tIGVuZCcpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgYWRkQXQ6IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgsIHNraXBUcmFuc2Zvcm0pXG4gICAge1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKHNraXBUcmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgeyBza2lwVHJhbnNmb3JtID0gZmFsc2U7IH1cblxuICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMubGlzdC5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LmNoaWxkcmVuLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSAmJiB0aGlzLmdhbWVPYmplY3QudHJhbnNmb3JtICYmIGNoaWxkLnRyYW5zZm9ybSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0LnRyYW5zZm9ybS5hZGQoY2hpbGQudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcblxuICAgIH0sXG5cbiAgICBhZGRNdWx0aXBsZTogZnVuY3Rpb24gKGNoaWxkcmVuLCBza2lwVHJhbnNmb3JtKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNoaWxkcmVuW2ldLCBza2lwVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgZ2V0QXQ6IGZ1bmN0aW9uIChpbmRleClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbaW5kZXhdO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKGNoaWxkKVxuICAgIHtcbiAgICAgICAgLy8gIFJldHVybiAtMSBpZiBnaXZlbiBjaGlsZCBpc24ndCBhIGNoaWxkIG9mIHRoaXMgcGFyZW50XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBzZXQgYmFzZWQgb24gdGhlIHByb3BlcnR5IHN0cmljdGx5IGVxdWFsaW5nIHRoZSB2YWx1ZSBnaXZlbi5cbiAgICAqIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjZ2V0QnlLZXlcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byBjaGVjayBhZ2FpbnN0IHRoZSB2YWx1ZS5cbiAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjayBpZiB0aGUgcHJvcGVydHkgc3RyaWN0bHkgZXF1YWxzLlxuICAgICogQHJldHVybiB7YW55fSBUaGUgaXRlbSB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbCBpZiBub3RoaW5nIG1hdGNoZWQuXG4gICAgKi9cbiAgICBnZXRCeUtleTogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldW3Byb3BlcnR5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNlYXJjaGVzIHRoZSBHcm91cCBmb3IgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY2hpbGQgd2l0aCB0aGUgYG5hbWVgXG4gICAgKiBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgZ2l2ZW4gYXJndW1lbnQuIFNob3VsZCBtb3JlIHRoYW4gb25lIGNoaWxkIGhhdmVcbiAgICAqIHRoZSBzYW1lIG5hbWUgb25seSB0aGUgZmlyc3QgaW5zdGFuY2UgaXMgcmV0dXJuZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0QnlOYW1lXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIHRvIHNlYXJjaCBmb3IuXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBmaXJzdCBjaGlsZCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgb3IgbnVsbCBpZiBub25lIHdlcmUgZm91bmQuXG4gICAgKi9cbiAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnlLZXkoJ25hbWUnLCBuYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGNoaWxkIGZyb20gdGhlIGdyb3VwLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2dldFJhbmRvbVxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnRJbmRleD0wXSAtIE9mZnNldCBmcm9tIHRoZSBmcm9udCBvZiB0aGUgZ3JvdXAgKGxvd2VzdCBjaGlsZCkuXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9KHRvIHRvcCldIC0gUmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiB2YWx1ZXMgeW91IHdhbnQgdG8gcmFuZG9tbHkgc2VsZWN0IGZyb20uXG4gICAgKiBAcmV0dXJuIHthbnl9IEEgcmFuZG9tIGNoaWxkIG9mIHRoaXMgR3JvdXAuXG4gICAgKi9cbiAgICBnZXRSYW5kb206IGZ1bmN0aW9uIChzdGFydEluZGV4LCBsZW5ndGgpXG4gICAge1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPiB0aGlzLmxpc3QubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0SW5kZXggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbcmFuZG9tSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYWxsIGNoaWxkcmVuIGluIHRoaXMgR3JvdXAuXG4gICAgKlxuICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBtYXRjaGluZyBjcml0ZXJpYSB1c2luZyB0aGUgYHByb3BlcnR5YCBhbmQgYHZhbHVlYCBhcmd1bWVudHMuXG4gICAgKlxuICAgICogRm9yIGV4YW1wbGU6IGBnZXRBbGwoJ2V4aXN0cycsIHRydWUpYCB3b3VsZCByZXR1cm4gb25seSBjaGlsZHJlbiB0aGF0IGhhdmUgdGhlaXIgZXhpc3RzIHByb3BlcnR5IHNldC5cbiAgICAqXG4gICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3BlY2lmeSBhIHN0YXJ0IGFuZCBlbmQgaW5kZXguIEZvciBleGFtcGxlIGlmIHRoaXMgR3JvdXAgaGFkIDEwMCBjaGlsZHJlbixcbiAgICAqIGFuZCB5b3Ugc2V0IGBzdGFydEluZGV4YCB0byAwIGFuZCBgZW5kSW5kZXhgIHRvIDUwLCBpdCB3b3VsZCByZXR1cm4gbWF0Y2hlcyBmcm9tIG9ubHlcbiAgICAqIHRoZSBmaXJzdCA1MCBjaGlsZHJlbiBpbiB0aGUgR3JvdXAuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0QWxsXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEFuIG9wdGlvbmFsIHByb3BlcnR5IHRvIHRlc3QgYWdhaW5zdCB0aGUgdmFsdWUgYXJndW1lbnQuXG4gICAgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXSAtIElmIHByb3BlcnR5IGlzIHNldCB0aGVuIENoaWxkLnByb3BlcnR5IG11c3Qgc3RyaWN0bHkgZXF1YWwgdGhpcyB2YWx1ZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cy5cbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0SW5kZXg9MF0gLSBUaGUgZmlyc3QgY2hpbGQgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBmcm9tLlxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kSW5kZXhdIC0gVGhlIGxhc3QgY2hpbGQgaW5kZXggdG8gc2VhcmNoIHVwIHVudGlsLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBleGlzdGluZyBjaGlsZCBvZiB0aGlzIEdyb3VwLlxuICAgICovXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcbiAgICB7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQpIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydHkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW3Byb3BlcnR5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIHN3YXA6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMilcbiAgICB7XG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQyKTtcblxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgc2FtZSBwYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDFdID0gY2hpbGQyO1xuICAgICAgICB0aGlzLmxpc3RbaW5kZXgyXSA9IGNoaWxkMTtcbiAgICB9LFxuXG4gICAgLy8gICB3YXMgc2V0SW5kZXhcbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGlzdC5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4ubW92ZVRvOiBUaGUgc3VwcGxpZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFJlbW92ZVxuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XG5cbiAgICAgICAgLy8gIEFkZCBpbiBuZXcgbG9jYXRpb25cbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQsIHNraXBUcmFuc2Zvcm0pXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtICYmIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0gJiYgY2hpbGQudHJhbnNmb3JtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0ucmVtb3ZlKGNoaWxkLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChpbmRleCwgc2tpcFRyYW5zZm9ybSlcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMubGlzdFtpbmRleF07XG5cbiAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtICYmIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0gJiYgY2hpbGQudHJhbnNmb3JtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdC50cmFuc2Zvcm0ucmVtb3ZlKGNoaWxkLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIHJlbW92ZUJldHdlZW46IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleClcbiAgICB7XG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB1bmRlZmluZWQpIHsgYmVnaW5JbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XG5cbiAgICAgICAgdmFyIHJhbmdlID0gZW5kSW5kZXggLSBiZWdpbkluZGV4O1xuXG4gICAgICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5saXN0LnNwbGljZShiZWdpbkluZGV4LCByYW5nZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5saXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZHJlbi5yZW1vdmVCZXR3ZWVuOiBSYW5nZSBFcnJvciwgbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlbW92ZXMgYWxsIHRoZSBpdGVtcy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNyZW1vdmVBbGxcbiAgICAqL1xuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmxpc3RbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIGdpdmVuIGNoaWxkIGlzIGEgY2hpbGQgb2YgdGhpcyBvYmplY3QsIGF0IGFueSBkZXB0aCAocmVjdXJzaXZlbHkgc2NhbnMgdXAgdGhlIHRyZWUpXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoY2hpbGQucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEJyaW5ncyB0aGUgZ2l2ZW4gY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGlzIGdyb3VwIHNvIGl0IHJlbmRlcnMgYWJvdmUgYWxsIG90aGVyIGNoaWxkcmVuLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI2JyaW5nVG9Ub3BcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBicmluZyB0byB0aGUgdG9wIG9mIHRoaXMgZ3JvdXAuXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cbiAgICAqL1xuICAgIGJyaW5nVG9Ub3A6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPCB0aGlzLmxpc3QubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmFkZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogU2VuZHMgdGhlIGdpdmVuIGNoaWxkIHRvIHRoZSBib3R0b20gb2YgdGhpcyBncm91cCBzbyBpdCByZW5kZXJzIGJlbG93IGFsbCBvdGhlciBjaGlsZHJlbi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNzZW5kVG9CYWNrXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gc2VuZCB0byB0aGUgYm90dG9tIG9mIHRoaXMgZ3JvdXAuXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBjaGlsZCB0aGF0IHdhcyBtb3ZlZC5cbiAgICAqL1xuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMgJiYgdGhpcy5nZXRJbmRleChjaGlsZCkgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmFkZEF0KGNoaWxkLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBNb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgdXAgb25lIHBsYWNlIGluIHRoaXMgZ3JvdXAgdW5sZXNzIGl0J3MgYWxyZWFkeSBhdCB0aGUgdG9wLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVVcFxuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIG1vdmUgdXAgaW4gdGhlIGdyb3VwLlxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXG4gICAgKi9cbiAgICBtb3ZlVXA6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGEgIT09IC0xICYmIGEgPCB0aGlzLmxpc3QubGVuZ3RoIC0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmdldEF0KGEgKyAxKTtcblxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwKGNoaWxkLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBNb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgZG93biBvbmUgcGxhY2UgaW4gdGhpcyBncm91cCB1bmxlc3MgaXQncyBhbHJlYWR5IGF0IHRoZSBib3R0b20uXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjbW92ZURvd25cbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBtb3ZlIGRvd24gaW4gdGhlIGdyb3VwLlxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXG4gICAgKi9cbiAgICBtb3ZlRG93bjogZnVuY3Rpb24gKGNoaWxkKVxuICAgIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEluZGV4KGNoaWxkKTtcblxuICAgICAgICBpZiAoYSA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXRBdChhIC0gMSk7XG5cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV2ZXJzZXMgYWxsIGNoaWxkcmVuIGluIHRoaXMgZ3JvdXAuXG4gICAgKlxuICAgICogVGhpcyBvcGVyYXRpb24gYXBwbGllcyBvbmx5IHRvIGltbWVkaWF0ZSBjaGlsZHJlbiBhbmQgZG9lcyBub3QgcHJvcGFnYXRlIHRvIHN1Ymdyb3Vwcy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXZlcnNlXG4gICAgKi9cbiAgICByZXZlcnNlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5saXN0LnJldmVyc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5saXN0W2ldO1xuICAgICAgICAgICAgdGhpcy5saXN0W2ldID0gdGhpcy5saXN0W2pdO1xuICAgICAgICAgICAgdGhpcy5saXN0W2pdID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlcGxhY2VzIGEgY2hpbGQgb2YgdGhpcyBHcm91cCB3aXRoIHRoZSBnaXZlbiBuZXdDaGlsZC4gVGhlIG5ld0NoaWxkIGNhbm5vdCBiZSBhIG1lbWJlciBvZiB0aGlzIEdyb3VwLlxuICAgICpcbiAgICAqIElmIGBHcm91cC5lbmFibGVCb2R5YCBpcyBzZXQsIHRoZW4gYSBwaHlzaWNzIGJvZHkgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZSBvYmplY3QsIHNvIGxvbmcgYXMgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgKlxuICAgICogSWYgYEdyb3VwLmlucHV0RW5hYmxlQ2hpbGRyZW5gIGlzIHNldCwgdGhlbiBhbiBJbnB1dCBIYW5kbGVyIHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBzbyBsb25nIGFzIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI3JlcGxhY2VcbiAgICAqIEBwYXJhbSB7YW55fSBvbGRDaGlsZCAtIFRoZSBjaGlsZCBpbiB0aGlzIGdyb3VwIHRoYXQgd2lsbCBiZSByZXBsYWNlZC5cbiAgICAqIEBwYXJhbSB7YW55fSBuZXdDaGlsZCAtIFRoZSBjaGlsZCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoaXMgZ3JvdXAuXG4gICAgKiBAcmV0dXJuIHthbnl9IFJldHVybnMgdGhlIG9sZENoaWxkIHRoYXQgd2FzIHJlcGxhY2VkIHdpdGhpbiB0aGlzIGdyb3VwLlxuICAgICovXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9sZENoaWxkLCBuZXdDaGlsZCwgc2tpcFRyYW5zZm9ybSlcbiAgICB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgob2xkQ2hpbGQpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5wYXJlbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50LnJlbW92ZShuZXdDaGlsZCwgc2tpcFRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG9sZENoaWxkLCBza2lwVHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBdChuZXdDaGlsZCwgaW5kZXgsIHNraXBUcmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb2xkQ2hpbGQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFN3YXBzIGEgY2hpbGQgZnJvbSBhbm90aGVyIHBhcmVudCwgd2l0aCBvbmUgZnJvbSB0aGlzIHBhcmVudC5cbiAgICAvLyAgY2hpbGQxID0gdGhlIGNoaWxkIG9mIFRISVMgcGFyZW50XG4gICAgLy8gIGNoaWxkMiA9IHRoZSBjaGlsZCBvZiB0aGUgT1RIRVIgcGFyZW50XG4gICAgZXhjaGFuZ2U6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMiwgc2tpcFRyYW5zZm9ybSlcbiAgICB7XG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMiB8fCBjaGlsZDEucGFyZW50ID09PSBjaGlsZDIucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50Q2hpbGRyZW4gPSBjaGlsZDIucGFyZW50LmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBpbmRleDEgPSB0aGlzLmdldEluZGV4KGNoaWxkMSk7XG4gICAgICAgIHZhciBpbmRleDIgPSBwYXJlbnRDaGlsZHJlbi5nZXRJbmRleChjaGlsZDIpO1xuXG4gICAgICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4uc3dhcDogU3VwcGxpZWQgb2JqZWN0cyBtdXN0IGJlIGNoaWxkcmVuIG9mIHBhcmVudHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkMSwgc2tpcFRyYW5zZm9ybSk7XG5cbiAgICAgICAgcGFyZW50Q2hpbGRyZW4ucmVtb3ZlKGNoaWxkMiwgc2tpcFRyYW5zZm9ybSk7XG5cbiAgICAgICAgdGhpcy5hZGRBdChjaGlsZDIsIGluZGV4MSwgc2tpcFRyYW5zZm9ybSk7XG5cbiAgICAgICAgcGFyZW50Q2hpbGRyZW4uYWRkQXQoY2hpbGQxLCBpbmRleDIsIHNraXBUcmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENoZWNrcyBmb3IgdGhlIGl0ZW0gd2l0aGluIHRoaXMgbGlzdC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNleGlzdHNcbiAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBsaXN0IGluZGV4IGZvci5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGxpc3QsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAqL1xuICAgIGV4aXN0czogZnVuY3Rpb24gKGNoaWxkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCkgPiAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGtleWAgdG8gdGhlIGdpdmVuIHZhbHVlIG9uIGFsbCBtZW1iZXJzIG9mIHRoaXMgbGlzdC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNzZXRBbGxcbiAgICAqIEBwYXJhbSB7YW55fSBrZXkgLSBUaGUgcHJvcGVydHkgb2YgdGhlIGl0ZW0gdG8gc2V0LlxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG8uXG4gICAgKi9cbiAgICBzZXRBbGw6IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFBhc3NlcyBhbGwgY2hpbGRyZW4gdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBtZXRob2QgZWFjaFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXG4gICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXG4gICAge1xuICAgICAgICB2YXIgYXJncyA9IFsgbnVsbCBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbaV07XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIE1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgR3JvdXAgdG8gdGhlIEdyb3VwIGdpdmVuLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVBbGxcbiAgICAqIEBwYXJhbSB7UGhhc2VyLkdyb3VwfSBncm91cCAtIFRoZSBuZXcgR3JvdXAgdG8gd2hpY2ggdGhlIGNoaWxkcmVuIHdpbGwgYmUgbW92ZWQgdG8uXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgY2hpbGRyZW4gd2lsbCBub3QgZGlzcGF0Y2ggdGhlIGBvbkFkZGVkVG9Hcm91cGAgZXZlbnQgZm9yIHRoZSBuZXcgR3JvdXAuXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuR3JvdXB9IFRoZSBHcm91cCB0byB3aGljaCBhbGwgdGhlIGNoaWxkcmVuIHdlcmUgbW92ZWQuXG4gICAgKi9cbiAgICByZXBhcmVudDogZnVuY3Rpb24gKG5ld1BhcmVudClcbiAgICB7XG4gICAgICAgIGlmIChuZXdQYXJlbnQgIT09IHRoaXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMucmVtb3ZlKHRoaXMubGlzdFtpXSk7XG5cbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdQYXJlbnQ7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGlsZHJlbi5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBhbmQgcmVzZXRzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0LlxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNmaXJzdFxuICAgICogQHByb3BlcnR5IHthbnl9IGZpcnN0XG4gICAgKi9cbiAgICBsZW5ndGg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjZmlyc3RcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaXJzdFxuICAgICovXG4gICAgZmlyc3Q6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQuXG4gICAgKlxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2xhc3RcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBsYXN0XG4gICAgKi9cbiAgICBsYXN0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMucG9zaXRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSB0aGUgbmV4dCBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgYWR2YW5jZXMgdGhlIGN1cnNvci5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjbmV4dFxuICAgICogQHByb3BlcnR5IHthbnl9IG5leHRcbiAgICAqL1xuICAgIG5leHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPCB0aGlzLmxpc3QubGVuZ3RoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHRoZSBwcmV2aW91cyBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgcmV0cmVhdHMgdGhlIGN1cnNvci5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjcHJldmlvdXNcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcmV2aW91c1xuICAgICovXG4gICAgcHJldmlvdXM6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24tLTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hpbGRyZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL0NoaWxkcmVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xuXG52YXIgRmVhdHVyZXMgPSB7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FudmFzIC0gSXMgY2FudmFzIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjYW52YXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgez9ib29sZWFufSBjYW52YXNCaXRCbHRTaGlmdCAtIFRydWUgaWYgY2FudmFzIHN1cHBvcnRzIGEgJ2NvcHknIGJpdGJsdCBvbnRvIGl0c2VsZiB3aGVuIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHJlZ2lvbnMgb3ZlcmxhcC5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjYW52YXNCaXRCbHRTaGlmdDogbnVsbCxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJHTCAtIElzIHdlYkdMIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3ZWJHTDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsZSAtIElzIGZpbGUgYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGZpbGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGVTeXN0ZW0gLSBJcyBmaWxlU3lzdGVtIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBmaWxlU3lzdGVtOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsb2NhbFN0b3JhZ2UgLSBJcyBsb2NhbFN0b3JhZ2UgYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGxvY2FsU3RvcmFnZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd29ya2VyIC0gSXMgd29ya2VyIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3b3JrZXI6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHBvaW50ZXJMb2NrIC0gSXMgUG9pbnRlciBMb2NrIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBwb2ludGVyTG9jazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlicmF0aW9uIC0gRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgdGhlIFZpYnJhdGlvbiBBUEk/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdmlicmF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBnZXRVc2VyTWVkaWEgLSBEb2VzIHRoZSBkZXZpY2Ugc3VwcG9ydCB0aGUgZ2V0VXNlck1lZGlhIEFQST9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBnZXRVc2VyTWVkaWE6IHRydWUsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIC0gSXMgdGhlIGRldmljZSBiaWcgb3IgbGl0dGxlIGVuZGlhbj8gKG9ubHkgZGV0ZWN0ZWQgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWRBcnJheXMpXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbGl0dGxlRW5kaWFuOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBzdXBwb3J0MzJiaXQgLSBEb2VzIHRoZSBkZXZpY2UgY29udGV4dCBzdXBwb3J0IDMyYml0IHBpeGVsIG1hbmlwdWxhdGlvbiB1c2luZyBhcnJheSBidWZmZXIgdmlld3M/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgc3VwcG9ydDMyYml0OiBmYWxzZVxuXG59O1xuXG4vKipcbiogQ2hlY2sgTGl0dGxlIG9yIEJpZyBFbmRpYW4gc3lzdGVtLlxuKlxuKiBAYXV0aG9yIE1hdHQgRGVzTGF1cmllcnMgKEBtYXR0ZGVzbClcbiovXG5mdW5jdGlvbiBjaGVja0lzTGl0dGxlRW5kaWFuICgpXG57XG4gICAgdmFyIGEgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICB2YXIgYyA9IG5ldyBVaW50MzJBcnJheShhKTtcblxuICAgIGJbMF0gPSAweGExO1xuICAgIGJbMV0gPSAweGIyO1xuICAgIGJbMl0gPSAweGMzO1xuICAgIGJbM10gPSAweGQ0O1xuXG4gICAgaWYgKGNbMF0gPT09IDB4ZDRjM2IyYTEpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY1swXSA9PT0gMHhhMWIyYzNkNClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gIENvdWxkIG5vdCBkZXRlcm1pbmUgZW5kaWFubmVzc1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICBjb25zb2xlLmxvZygnRmVhdHVyZXMuaW5pdCcpO1xuXG4gICAgRmVhdHVyZXMuY2FudmFzID0gISF3aW5kb3dbJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCddIHx8IE9TLmNvY29vbkpTO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBGZWF0dXJlcy5maWxlID0gISF3aW5kb3dbJ0ZpbGUnXSAmJiAhIXdpbmRvd1snRmlsZVJlYWRlciddICYmICEhd2luZG93WydGaWxlTGlzdCddICYmICEhd2luZG93WydCbG9iJ107XG4gICAgRmVhdHVyZXMuZmlsZVN5c3RlbSA9ICEhd2luZG93WydyZXF1ZXN0RmlsZVN5c3RlbSddO1xuXG4gICAgdmFyIGlzVWludDggPSBmYWxzZTtcblxuICAgIHZhciB0ZXN0V2ViR0wgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHdpbmRvd1snV2ViR0xSZW5kZXJpbmdDb250ZXh0J10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZVdlYkdMKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKE9TLmNvY29vbkpTKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNjcmVlbmNhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzMkQgPSBDYW52YXNQb29sLmNyZWF0ZTJEKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN0eDJEID0gY2FudmFzMkQuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIC8vICBDYW4ndCBiZSBkb25lIG9uIGEgd2ViZ2wgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGN0eDJELmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFRlc3QgdG8gc2VlIGlmIEltYWdlRGF0YSB1c2VzIENhbnZhc1BpeGVsQXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXkuXG4gICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpc1VpbnQ4ID0gaW1hZ2UuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5O1xuXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcbiAgICAgICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMyRCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGN0eCAhPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgRmVhdHVyZXMud2ViR0wgPSB0ZXN0V2ViR0woKTtcblxuICAgIEZlYXR1cmVzLndvcmtlciA9ICEhd2luZG93WydXb3JrZXInXTtcblxuICAgIEZlYXR1cmVzLnBvaW50ZXJMb2NrID0gJ3BvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ21velBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQgfHwgJ3dlYmtpdFBvaW50ZXJMb2NrRWxlbWVudCcgaW4gZG9jdW1lbnQ7XG5cbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5vR2V0VXNlck1lZGlhO1xuXG4gICAgd2luZG93LlVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IEZlYXR1cmVzLmdldFVzZXJNZWRpYSAmJiAhIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgISF3aW5kb3cuVVJMO1xuXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgZmlyZWZveCAoPCAyMSkgYXBwYXJlbnRseSBjbGFpbSBzdXBwb3J0IGJ1dCB1c2VyIG1lZGlhIGRvZXMgbm90IGFjdHVhbGx5IHdvcmtcbiAgICBpZiAoQnJvd3Nlci5maXJlZm94ICYmIEJyb3dzZXIuZmlyZWZveFZlcnNpb24gPCAyMSlcbiAgICB7XG4gICAgICAgIEZlYXR1cmVzLmdldFVzZXJNZWRpYSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEV4Y2x1ZGVzIGlPUyB2ZXJzaW9ucyBhcyB0aGV5IGdlbmVyYWxseSB3cmFwIFVJV2ViVmlldyAoZWcuIFNhZmFyaSBXZWJLaXQpIGFuZCBpdFxuICAgIC8vIGlzIHNhZmVyIHRvIG5vdCB0cnkgYW5kIHVzZSB0aGUgZmFzdCBjb3B5LW92ZXIgbWV0aG9kLlxuICAgIGlmICghT1MuaU9TICYmIChCcm93c2VyLmllIHx8IEJyb3dzZXIuZmlyZWZveCB8fCBCcm93c2VyLmNocm9tZSkpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gS25vd24gbm90IHRvIHdvcmtcbiAgICBpZiAoQnJvd3Nlci5zYWZhcmkgfHwgQnJvd3Nlci5tb2JpbGVTYWZhcmkpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5jYW52YXNCaXRCbHRTaGlmdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHwgbmF2aWdhdG9yLndlYmtpdFZpYnJhdGUgfHwgbmF2aWdhdG9yLm1velZpYnJhdGUgfHwgbmF2aWdhdG9yLm1zVmlicmF0ZTtcblxuICAgIGlmIChuYXZpZ2F0b3IudmlicmF0ZSlcbiAgICB7XG4gICAgICAgIEZlYXR1cmVzLnZpYnJhdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gPSBjaGVja0lzTGl0dGxlRW5kaWFuKCk7XG4gICAgfVxuXG4gICAgRmVhdHVyZXMuc3VwcG9ydDMyYml0ID0gKFxuICAgICAgICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIEZlYXR1cmVzLmxpdHRsZUVuZGlhbiAhPT0gbnVsbCAmJlxuICAgICAgICBpc1VpbnQ4XG4gICAgKTtcblxuICAgIHJldHVybiBGZWF0dXJlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvRmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogVGhlIHBvb2wgaW50byB3aGljaCB0aGUgY2FudmFzIGVsZW1lbnRzIGFyZSBwbGFjZWQuXG4gKlxuICogQHByb3BlcnR5IHBvb2xcbiAqIEB0eXBlIEFycmF5XG4gKi9cbnZhciBwb29sID0gW107XG5cbi8vICBUaGlzIHNpbmdsZXRvbiBpcyBpbnN0YW50aWF0ZWQgYXMgc29vbiBhcyBQaGFzZXIgbG9hZHMsXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIG9uIHRoZSBzYW1lIHBhZ2Vcbi8vICBjYW4gc2hhcmUgdGhlIG9uZSBzaW5nbGUgcG9vbFxuXG4vKipcbiogVGhlIENhbnZhc1Bvb2wgaXMgYSBnbG9iYWwgc3RhdGljIG9iamVjdCwgdGhhdCBhbGxvd3MgUGhhc2VyIHRvIHJlY3ljbGUgYW5kIHBvb2wgQ2FudmFzIERPTSBlbGVtZW50cy5cbipcbiogQGNsYXNzIFBoYXNlci5DYW52YXNQb29sXG4qIEBzdGF0aWNcbiovXG52YXIgQ2FudmFzUG9vbCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IENhbnZhcyBET00gZWxlbWVudCwgb3IgcHVsbHMgb25lIGZyb20gdGhlIHBvb2wgaWYgZnJlZS5cbiAgICAqIFxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5jcmVhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7YW55fSBwYXJlbnQgLSBUaGUgcGFyZW50IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIGNhbnZhcyBlbGVtZW50LlxuICAgICovXG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIHR5cGUpXG4gICAge1xuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDE7IH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XG5cbiAgICAgICAgdmFyIGNhbnZhcztcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZpcnN0KHR5cGUpO1xuXG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLmNyZWF0ZSBuZXcnKTtcblxuICAgICAgICAgICAgY29udGFpbmVyID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgIGNhbnZhczogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcG9vbC5wdXNoKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGNhbnZhcyA9IGNvbnRhaW5lci5jYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5jcmVhdGUgZXhpc3RpbmcnKTtcblxuICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZTJEID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5DQU5WQVMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV2ViR0wgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZShwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIENPTlNULldFQkdMKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBmcmVlIGNhbnZhcyBpbmRleCBmcm9tIHRoZSBwb29sLlxuICAgICogXG4gICAgKiBAc3RhdGljXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldEZpcnN0XG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICB2YXIgZmlyc3QgPSBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IENPTlNULkNBTlZBUzsgfVxuXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5wYXJlbnQgJiYgY29udGFpbmVyLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogTG9va3MgdXAgYSBjYW52YXMgYmFzZWQgb24gaXRzIHBhcmVudCwgYW5kIGlmIGZvdW5kIHB1dHMgaXQgYmFjayBpbiB0aGUgcG9vbCwgZnJlZWluZyBpdCB1cCBmb3IgcmUtdXNlLlxuICAgICogVGhlIGNhbnZhcyBoYXMgaXRzIHdpZHRoIGFuZCBoZWlnaHQgc2V0IHRvIDEsIGFuZCBpdHMgcGFyZW50IGF0dHJpYnV0ZSBudWxsZWQuXG4gICAgKiBcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhc1Bvb2wucmVtb3ZlXG4gICAgKiBAcGFyYW0ge2FueXxIVE1MQ2FudmFzRWxlbWVudH0gcGFyZW50IC0gVGhlIHBhcmVudCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgKi9cbiAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudClcbiAgICB7XG4gICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHBhcmVudCBpcyBhIGNhbnZhcyBvYmplY3RcbiAgICAgICAgdmFyIGlzQ2FudmFzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoaXNDYW52YXMgJiYgY29udGFpbmVyLmNhbnZhcyA9PT0gcGFyZW50KSB8fCAoIWlzQ2FudmFzICYmIGNvbnRhaW5lci5wYXJlbnQgPT09IHBhcmVudCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhc1Bvb2wucmVtb3ZlIGZvdW5kIGFuZCByZW1vdmVkJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy5oZWlnaHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgdXNlZCBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXG4gICAgKiBcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhc1Bvb2wuZ2V0VG90YWxcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBpbi11c2UgKHBhcmVudGVkKSBjYW52YXMgZWxlbWVudHMgaW4gdGhlIHBvb2wuXG4gICAgKi9cbiAgICB2YXIgdG90YWwgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICAgIHBvb2wuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnBhcmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmVlIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cbiAgICAqIFxuICAgICogQHN0YXRpY1xuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRGcmVlXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJlZSAodW4tcGFyZW50ZWQpIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cbiAgICAqL1xuICAgIHZhciBmcmVlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBwb29sLmxlbmd0aCAtIHRvdGFsKCk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgICAgICBjcmVhdGUyRDogY3JlYXRlMkQsXG4gICAgICAgIGNyZWF0ZVdlYkdMOiBjcmVhdGVXZWJHTCxcbiAgICAgICAgZmlyc3Q6IGZpcnN0LFxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgICBmcmVlOiBmcmVlLFxuICAgICAgICBwb29sOiBwb29sXG4gICAgfTtcbn07XG5cbi8vICBJZiB3ZSBleHBvcnQgdGhlIGNhbGxlZCBmdW5jdGlvbiBoZXJlLCBpdCdsbCBvbmx5IGJlIGludm9rZWQgb25jZSAobm90IGV2ZXJ5IHRpbWUgaXQncyByZXF1aXJlZCkuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1Bvb2woKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9DYW52YXNQb29sLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb20vQ2FudmFzUG9vbC5qcyIsInZhciBFVkVOVF9DT05TVCA9IHtcblxuICAgIERJU1BBVENIRVJfSURMRTogMCxcbiAgICBESVNQQVRDSEVSX0RJU1BBVENISU5HOiAxLFxuICAgIERJU1BBVENIRVJfUkVNT1ZJTkc6IDIsXG4gICAgRElTUEFUQ0hFUl9ERVNUUk9ZRUQ6IDMsXG5cbiAgICBMSVNURU5FUl9QRU5ESU5HOiA0LFxuICAgIExJU1RFTkVSX0FDVElWRTogNSxcbiAgICBMSVNURU5FUl9SRU1PVklORzogNlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVWRU5UX0NPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9tYXRoL2NvbnN0Jyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xudmFyIFdyYXBBbmdsZSA9IHJlcXVpcmUoJy4uL21hdGgvYW5nbGUvV3JhcCcpO1xuXG4vKipcbiogVGhpcyBpcyB0aGUgYmFzZSBHYW1lIE9iamVjdCBjbGFzcyB0aGF0IHlvdSBjYW4gdXNlIHdoZW4gY3JlYXRpbmcgeW91ciBvd24gZXh0ZW5kZWQgR2FtZSBPYmplY3RzLlxuKiBJdCBoaWRlcyBhd2F5IHRoZSAncHJpdmF0ZScgc3R1ZmYgYW5kIGV4cG9zZXMgb25seSB0aGUgdXNlZnVsIGdldHRlcnMsIHNldHRlcnMgYW5kIHByb3BlcnRpZXMuXG4qXG4qIEBjbGFzc1xuKi9cblxuLy8gIFBoYXNlci5UZXh0dXJlIGFuZCBQaGFzZXIuRnJhbWUgb2JqZWN0cyBwYXNzZWQgaW4gaGVyZSwgaW5zdGVhZCBvZiBsb29rZWQtdXAuXG4vLyAgQWxsb3dzIG92ZXJyaWRlIGZyb20gbm9uLXN0YW5kYXJkIEdPIHR5cGVzXG5cbnZhciBHYW1lT2JqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSwgcGFyZW50KVxue1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIHRoaXMuZ2FtZSA9IHN0YXRlLmdhbWU7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcblxuICAgIHRoaXMudHlwZSA9IDA7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vICBUZXh0dXJlIGlzIGdsb2JhbGx5IHNoYXJlZCBiZXR3ZWVuIEdhbWVPYmplY3RzLCBub3Qgc3BlY2lmaWMgdG8gdGhpcyBvbmVcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLy8gIEZyYW1lIGlzIGdsb2JhbGx5IHNoYXJlZCBiZXR3ZWVuIEdhbWVPYmplY3RzLCBub3Qgc3BlY2lmaWMgdG8gdGhpcyBvbmVcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG5cbiAgICAvLyAgQWxsIEdhbWVPYmplY3RzIGhhdmUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzLCBhbHdheXM6XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgQ29tcG9uZW50LlRyYW5zZm9ybSh0aGlzLCB4LCB5KTtcblxuICAgIC8vICBPcHRpb25hbD8gTWF5YmUgc2V0IG9uIGEgcGVyIEdPIGJhc2lzP1xuICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzKTtcblxuICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMpO1xuXG4gICAgLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGRlYmF0YWJsZSB0byBoYXZlIGluIHRoaXMgY2xhc3NcbiAgICAvLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0aGlzLnNjYWxlTW9kZSA9IENPTlNULnNjYWxlTW9kZXMuREVGQVVMVDtcblxuICAgIC8vICBBbGxvd3MgeW91IHRvIHR1cm4gb2ZmIGEgR2FtZU9iamVjdCBmcm9tIHJlbmRlcmluZywgYnV0IHN0aWxsIHJlbmRlciBpdHMgY2hpbGRyZW4gKGlmIGl0IGhhcyBhbnkpXG4gICAgLy8gIE1heWJlIHRoaXMgc2hvdWxkIG1vdmU/XG4gICAgLy8gdGhpcy5za2lwUmVuZGVyID0gKGtleSA9PT0gdW5kZWZpbmVkKTtcbiAgICB0aGlzLnNraXBSZW5kZXIgPSBmYWxzZTtcblxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvLyAgRWl0aGVyIG51bGwsIG9yIHRoZSBDaGlsZHJlbiBjb21wb25lbnRcbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcblxuICAgIHRoaXMuZXhpc3RzID0gdHJ1ZTtcbn07XG5cbkdhbWVPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2FtZU9iamVjdDtcblxuR2FtZU9iamVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICBwcmVVcGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAgTk9PUFxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAgTk9PUFxuICAgIH0sXG5cbiAgICBwb3N0VXBkYXRlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gIE5PT1BcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gIE5PT1BcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBOT09QXG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhHYW1lT2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xuXG4gICAgeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9wb3NYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1kgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHNjYWxlOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVDYWNoZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2NhbGVYOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVDYWNoZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2NhbGVZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fc2NhbGVZID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVDYWNoZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYW5jaG9yOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2V0QW5jaG9yKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFuY2hvclg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9hbmNob3JYO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fYW5jaG9yWCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYW5jaG9yWToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX2FuY2hvclk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9hbmNob3JZID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwaXZvdFg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9waXZvdFggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwaXZvdFk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9waXZvdFkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhbmdsZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKiBNQVRIX0NPTlNULlJBRF9UT19ERUcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlKHZhbHVlKSAqIE1BVEhfQ09OU1QuREVHX1RPX1JBRDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJvdGF0aW9uOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gJSBNQVRIX0NPTlNULlBJMilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uY2FjaGUuY3IgPSBNYXRoLmNvcyh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gIENvbG9yIGdldHRlcnMgLyBzZXR0ZXJzXG5cbiAgICBhbHBoYToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5fYWxwaGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IuYWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJsZW5kTW9kZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5fYmxlbmRNb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yLmJsZW5kTW9kZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwidmFyIENpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHsgcmFkaXVzID0gMDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xufTtcblxuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcblxuQ2lyY2xlLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHJhZGl1cyAqIDI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCk7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpdXMgPD0gMCk7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaXJjbGUucHJvdG90eXBlLCB7XG5cbiAgICByYWRpdXM6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHZhbHVlICogMjtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRpYW1ldGVyOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFtZXRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlICogMC41O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbGVmdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSArIHRoaXMuX3JhZGl1cztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9wOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgLSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYm90dG9tOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7IHdpZHRoID0gMDsgfVxuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSAwOyB9XG5cbiAgICB0aGlzLnggPSB4O1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuRWxsaXBzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlO1xuXG5FbGxpcHNlLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCwgMCk7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB3aWR0aDsgfVxuXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKTtcbiAgICB9LFxuXG4gICAgLy8gIEFLQSBTZW1pIE1pbm9yIEF4aXNcbiAgICBnZXRNaW5vclJhZGl1czogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xuICAgIH0sXG5cbiAgICAvLyAgQUtBIFNlbWkgTWFqb3IgQXhpc1xuICAgIGdldE1ham9yUmFkaXVzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDI7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGxpcHNlLnByb3RvdHlwZSwge1xuXG4gICAgbGVmdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5yaWdodClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy54KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB2YWx1ZSAtIHRoaXMueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvcDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5ib3R0b20pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYm90dG9tOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB2YWx1ZSAtIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGxpcHNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcblxuLyoqXG4qIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBhbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIGN1cnZlcyB0YW5nZW50IGJhc2VkIG9uIHRpbWUuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0QW5nbGVcbiogQHBhcmFtIHtudW1iZXJ9IFt0PTBdIC0gVGhlIGB0YCAodGltZSkgdmFsdWUgYXQgd2hpY2ggdG8gZmluZCB0aGUgYW5nbGUuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB0aGUgbGluZSBhdCB0aGUgc3BlY2lmaWVkIGB0YCB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZS4gVGhlIHZhbHVlIGlzIGluIHJhZGlhbnMuXG4qL1xudmFyIEdldEFuZ2xlID0gZnVuY3Rpb24gKGN1cnZlLCB0KVxue1xuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHsgdCA9IDA7IH1cblxuICAgIEdldFBvaW50KGN1cnZlLCB0IC0gMC4wMSwgY3VydmUuX3RlbXAxKTtcbiAgICBHZXRQb2ludChjdXJ2ZSwgdCArIDAuMDEsIGN1cnZlLl90ZW1wMik7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMihjdXJ2ZS5fdGVtcDIueSAtIGN1cnZlLl90ZW1wMS55LCBjdXJ2ZS5fdGVtcDIueCAtIGN1cnZlLl90ZW1wMS54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0QW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qcyIsInZhciBQb2ludFRvTGluZSA9IGZ1bmN0aW9uIChwb2ludCwgbGluZSlcbntcbiAgICByZXR1cm4gKChwb2ludC54IC0gbGluZS54MSkgKiAobGluZS55MiAtIGxpbmUueTEpID09PSAobGluZS54MiAtIGxpbmUueDEpICogKHBvaW50LnkgLSBsaW5lLnkxKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9MaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxue1xuICAgIGlmIChyZWN0QS53aWR0aCA8PSAwIHx8IHJlY3RBLmhlaWdodCA8PSAwIHx8IHJlY3RCLndpZHRoIDw9IDAgfHwgcmVjdEIuaGVpZ2h0IDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEocmVjdEEucmlnaHQgPCByZWN0Qi54IHx8IHJlY3RBLmJvdHRvbSA8IHJlY3RCLnkgfHwgcmVjdEEueCA+IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLnkgPiByZWN0Qi5ib3R0b20pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1JlY3RhbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIERlZmluZXMgYSBMaW5lIHNlZ21lbnQsIGEgcGFydCBvZiBhIGxpbmUgYmV0d2VlbiB0d28gZW5kcG9pbnRzXG5cbnZhciBMaW5lID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxue1xuICAgIGlmICh4MSA9PT0gdW5kZWZpbmVkKSB7IHgxID0gMDsgfVxuICAgIGlmICh5MSA9PT0gdW5kZWZpbmVkKSB7IHkxID0gMDsgfVxuICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxuICAgIGlmICh5MiA9PT0gdW5kZWZpbmVkKSB7IHkyID0gMDsgfVxuXG4gICAgdGhpcy54MSA9IHgxO1xuXG4gICAgdGhpcy55MSA9IHkxO1xuXG4gICAgdGhpcy54MiA9IHgyO1xuXG4gICAgdGhpcy55MiA9IHkyO1xufTtcblxuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lO1xuXG5MaW5lLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG4gICAge1xuICAgICAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxuICAgICAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cblxuICAgICAgICB0aGlzLngxID0geDE7XG4gICAgICAgIHRoaXMueTEgPSB5MTtcblxuICAgICAgICB0aGlzLngyID0geDI7XG4gICAgICAgIHRoaXMueTIgPSB5MjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKExpbmUucHJvdG90eXBlLCB7XG5cbiAgICBsZWZ0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMueDEgPD0gdGhpcy54MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmlnaHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueDEsIHRoaXMueDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy54MSA+IHRoaXMueDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvcDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy55MSwgdGhpcy55Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnkxIDw9IHRoaXMueTIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJvdHRvbToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy55MSwgdGhpcy55Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnkxID4gdGhpcy55MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG52YXIgV3JhcCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvV3JhcCcpO1xudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xuXG52YXIgTm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xuXG4gICAgcmV0dXJuIFdyYXAoYW5nbGUsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsQW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsInZhciBHZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAocG9pbnQpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgocG9pbnQueCAqIHBvaW50LngpICsgKHBvaW50LnkgKiBwb2ludC55KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1hZ25pdHVkZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlU3EgPSBmdW5jdGlvbiAocG9pbnQpXG57XG4gICAgcmV0dXJuIChwb2ludC54ICogcG9pbnQueCkgKyAocG9pbnQueSAqIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGVTcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlU3EuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54ICo9IHg7XG4gICAgcG9pbnQueSAqPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGUgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZScpO1xuXG52YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIGlmIChwb2ludC54ICE9PSAwICYmIHBvaW50LnkgIT09IDApXG4gICAge1xuICAgICAgICB2YXIgbSA9IEdldE1hZ25pdHVkZShwb2ludCk7XG5cbiAgICAgICAgcG9pbnQueCAvPSBtO1xuICAgICAgICBwb2ludC55IC89IG07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxpemU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9Ob3JtYWxpemUuanMiLCIvKipcbiogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5Qb2x5Z29uI2NvbnRhaW5zXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGVzdC5cbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbiwgb3RoZXJ3aXNlIGZhbHNlLlxuKi9cbnZhciBDb250YWlucyA9IGZ1bmN0aW9uIChwb2x5Z29uLCB4LCB5KVxue1xuICAgIC8vICBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbCBieSBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmFcblxuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAtMSwgaiA9IHBvbHlnb24ucG9pbnRzLmxlbmd0aCAtIDE7ICsraSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaiA9IGkpXG4gICAge1xuICAgICAgICB2YXIgaXggPSBwb2x5Z29uLnBvaW50c1tpXS54O1xuICAgICAgICB2YXIgaXkgPSBwb2x5Z29uLnBvaW50c1tpXS55O1xuXG4gICAgICAgIHZhciBqeCA9IHBvbHlnb24ucG9pbnRzW2pdLng7XG4gICAgICAgIHZhciBqeSA9IHBvbHlnb24ucG9pbnRzW2pdLnk7XG5cbiAgICAgICAgaWYgKCgoaXkgPD0geSAmJiB5IDwgankpIHx8IChqeSA8PSB5ICYmIHkgPCBpeSkpICYmICh4IDwgKGp4IC0gaXgpICogKHkgLSBpeSkgLyAoankgLSBpeSkgKyBpeCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9seWdvbi9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKVxue1xuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyZWEgLSBUaGUgYXJlYSBvZiB0aGlzIFBvbHlnb24uXG4gICAgKi9cbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXIgcGFpciBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGlzIHBvbHlnb24uIEkuZS4gWyB7eCx5fSwge3gseX0sIHt4LHl9IF1cbiAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICBpZiAocG9pbnRzKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRUbyhwb2ludHMpO1xuICAgIH1cbn07XG5cblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcblxuUG9seWdvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgUG9seWdvbiB0byB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICAqXG4gICAgICogVGhlIHBvaW50cyBjYW4gYmUgc2V0IGZyb20gYSB2YXJpZXR5IG9mIGZvcm1hdHM6XG4gICAgICpcbiAgICAgKiAtIEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHM6IGBbbmV3IFBoYXNlci5Qb2ludCh4MSwgeTEpLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllczogYFtvYmoxLCBvYmoyLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2YgcGFpcmVkIG51bWJlcnMgdGhhdCByZXByZXNlbnQgcG9pbnQgY29vcmRpbmF0ZXM6IGBbeDEseTEsIHgyLHkyLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdHdvIGVsZW1lbnRzIHJlcHJlc2VudGluZyB4L3kgY29vcmRpbmF0ZXM6IGBbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dYFxuICAgICAqXG4gICAgICogYHNldFRvYCBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzIHRvIHJlbW92ZSBhbGwgcG9pbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNzZXRUb1xuICAgICAqIEBwYXJhbSB7UGhhc2VyLlBvaW50W118bnVtYmVyW118Li4uUGhhc2VyLlBvaW50fC4uLm51bWJlcn0gcG9pbnRzIC0gVGhlIHBvaW50cyB0byBzZXQuXG4gICAgICogQHJldHVybiB7UGhhc2VyLlBvbHlnb259IFRoaXMgUG9seWdvbiBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRUbzogZnVuY3Rpb24gKHBvaW50cylcbiAgICB7XG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB2YXIgeTAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICAvLyAgVGhlIHBvaW50cyBhcmd1bWVudCBpcyBhbiBhcnJheSwgc28gaXRlcmF0ZSB0aHJvdWdoIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzW2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgQW4gYXJyYXkgb2YgYXJyYXlzP1xuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICBwLnkgPSBwb2ludHNbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldLng7XG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgIC8vICBMb3dlc3QgYm91bmRhcnlcbiAgICAgICAgICAgIGlmIChwLnkgPCB5MClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5MCA9IHAueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQXJlYSh5MCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uIFRoaXMgaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9wZXJ0eSBQb2x5Z29uLmFyZWFcbiAgICAgKlxuICAgICAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY2FsY3VsYXRlQXJlYVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIGxvd2VzdCBib3VuZGFyeVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uXG4gICAgICovXG4gICAgY2FsY3VsYXRlQXJlYTogZnVuY3Rpb24gKHkwKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIHAxO1xuICAgICAgICB2YXIgcDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgc3VtICs9IChwMi54IC0gcDEueCkgKiAocDEueSArIHAyLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcDEgPSB0aGlzLnBvaW50c1swXTtcbiAgICAgICAgcDIgPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBzdW0gKz0gKHAxLnggLSBwMi54KSAqIChwMi55ICsgcDEueSk7XG5cbiAgICAgICAgdGhpcy5hcmVhID0gLXN1bSAqIDAuNTtcblxuICAgICAgICAvLyB2YXIgcDE7XG4gICAgICAgIC8vIHZhciBwMjtcbiAgICAgICAgLy8gdmFyIGF2Z0hlaWdodDtcbiAgICAgICAgLy8gdmFyIHdpZHRoO1xuXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcblxuICAgICAgICAvLyAgICAgaWYgKGkgPT09IGxlbiAtIDEpXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1swXTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGVsc2VcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcbiAgICAgICAgLy8gICAgIH1cblxuICAgICAgICAvLyAgICAgYXZnSGVpZ2h0ID0gKChwMS55IC0geTApICsgKHAyLnkgLSB5MCkpIC8gMjtcbiAgICAgICAgLy8gICAgIHdpZHRoID0gcDEueCAtIHAyLng7XG4gICAgICAgIC8vICAgICB0aGlzLmFyZWEgKz0gYXZnSGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxue1xuICAgIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHJlY3QueCA8PSB4ICYmIHJlY3QueCArIHJlY3Qud2lkdGggPj0geCAmJiByZWN0LnkgPD0geSAmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFhIUlNldHRpbmdzID0gcmVxdWlyZSgnLi9YSFJTZXR0aW5ncycpO1xuXG4vLyAgVGFrZXMgdHdvIFhIUiBPYmplY3RzIGFuZCBjcmVhdGVzIGEgbmV3IG9iamVjdFxuXG4vLyAgVGhlIG5ldyBvYmplY3QgaXMgYmFzZWQgb24gZ2xvYmFsIGluaXRpYWxseSwgYnV0IGFueSBzZXR0aW5nIGluXG4vLyAgbG9jYWwgb3ZlcnJpZGVzIHRoZSBnbG9iYWwgdmFsdWUuXG5cbnZhciBNZXJnZVhIUlNldHRpbmdzID0gZnVuY3Rpb24gKGdsb2JhbCwgbG9jYWwpXG57XG4gICAgdmFyIG91dHB1dCA9IChnbG9iYWwgPT09IHVuZGVmaW5lZCkgPyBYSFJTZXR0aW5ncygpIDogT2JqZWN0LmFzc2lnbihnbG9iYWwpO1xuXG4gICAgaWYgKGxvY2FsKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgc2V0dGluZyBpbiBsb2NhbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGxvY2FsW3NldHRpbmddICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W3NldHRpbmddID0gbG9jYWxbc2V0dGluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlWEhSU2V0dGluZ3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanMiLCJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcblxudmFyIEpTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcbntcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxuXG4gICAgaWYgKCFrZXkpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmpzb25cXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5qc29uJztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcbiAgICB9XG5cbiAgICBGaWxlLmNhbGwodGhpcywgJ2pzb24nLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XG59O1xuXG5KU09ORmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcbkpTT05GaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpTT05GaWxlO1xuXG5KU09ORmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxue1xuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XG5cbiAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dCk7XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09ORmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanMiLCJ2YXIgRmFjdG9yaWFsID0gcmVxdWlyZSgnLi9GYWN0b3JpYWwnKTtcblxudmFyIEJlcm5zdGVpbiA9IGZ1bmN0aW9uIChuLCBpKVxue1xuICAgIHJldHVybiBGYWN0b3JpYWwobikgLyBGYWN0b3JpYWwoaSkgLyBGYWN0b3JpYWwobiAtIGkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXJuc3RlaW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0Jlcm5zdGVpbi5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9CZXJuc3RlaW4uanMiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcbntcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENhdG11bGxSb20gPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHQpXG57XG4gICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41LCB2MSA9IChwMyAtIHAxKSAqIDAuNSwgdDIgPSB0ICogdCwgdDMgPSB0ICogdDI7XG5cbiAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdG11bGxSb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0NhdG11bGxSb20uanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGYWN0b3JpYWwgPSBmdW5jdGlvbiAodmFsdWUpXG57XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHZhbHVlO1xuXG4gICAgd2hpbGUgKC0tdmFsdWUpXG4gICAge1xuICAgICAgICByZXMgKj0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yaWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9GYWN0b3JpYWwuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaW5lYXIgPSBmdW5jdGlvbiAocDAsIHAxLCB0KVxue1xuICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvTGluZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRBd2F5RnJvbVplcm8gPSBmdW5jdGlvbiAodmFsdWUpXG57XG4gICAgLy8gXCJPcHBvc2l0ZVwiIG9mIHRydW5jYXRlLlxuICAgIHJldHVybiAodmFsdWUgPiAwKSA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm91bmRBd2F5RnJvbVplcm87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTm9ybWFsaXplID0gZnVuY3Rpb24gKGFuZ2xlKVxue1xuICAgIGFuZ2xlID0gYW5nbGUgJSAoMiAqIE1hdGguUEkpO1xuXG4gICAgaWYgKGFuZ2xlID49IDApXG4gICAge1xuICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBhbmdsZSArIDIgKiBNYXRoLlBJO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZUJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgdmFyIGR4ID0geDEgLSB4MjtcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkaW1lbnNpb25zIG1ha2UgYSBwb3dlciBvZiB0d28gdGV4dHVyZS5cbiogXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjaXNQb3dlck9mVHdvXG4qIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byBjaGVjay5cbiogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gY2hlY2suXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgcG93ZXIgb2YgdHdvLlxuKi9cbnZhciBJc1NpemVQb3dlck9mVHdvID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgcmV0dXJuICh3aWR0aCA+IDAgJiYgKHdpZHRoICYgKHdpZHRoIC0gMSkpID09PSAwICYmIGhlaWdodCA+IDAgJiYgKGhlaWdodCAmIChoZWlnaHQgLSAxKSkgPT09IDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc1NpemVQb3dlck9mVHdvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0lzU2l6ZVBvd2VyT2ZUd28uanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9HZXRPYmplY3RWYWx1ZScpO1xuXG52YXIgU2V0dGluZ3MgPSBmdW5jdGlvbiAoc3RhdGUsIGNvbmZpZylcbntcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpXG4gICAge1xuICAgICAgICBjb25maWcgPSB7IGtleTogY29uZmlnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgLy8gIFBhc3MgdGhlICdoYXNPd25Qcm9wZXJ0eScgY2hlY2tzXG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTsgLy8gIERvIHdlIGFjdHVhbGx5IG5lZWQgdGhpcyByZWZlcmVuY2U/IFRoaXMgY291bGQganVzdCBiZSBhIHByb3BlcnR5IGJ1Y2tldFxuXG4gICAgdGhpcy5zdGF0dXMgPSBDT05TVC5zdGF0ZS5QRU5ESU5HO1xuXG4gICAgLy8gIFdoaWNoIHBhcnQgb2YgdGhpcyBTdGF0ZSBpcyBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkP1xuICAgIC8vICBwcmVsb2FkLCBjcmVhdGUsIHVwZGF0ZSwgc2h1dGRvd24sIGV0Y1xuICAgIHRoaXMub3AgPSBDT05TVC5zdGF0ZS5CT09UO1xuXG4gICAgdGhpcy5rZXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdrZXknLCAnJyk7XG4gICAgdGhpcy5hY3RpdmUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgdGhpcy52aXNpYmxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndmlzaWJsZScsIHRydWUpO1xuICAgIHRoaXMuc2NhbGVNb2RlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc2NhbGVNb2RlJywgQ09OU1Quc2NhbGVNb2Rlcy5ERUZBVUxUKTtcbiAgICB0aGlzLmZwcyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZwcycsIDYwKTtcbiAgICB0aGlzLnggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd4JywgMCk7XG4gICAgdGhpcy55ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAneScsIDApO1xuXG4gICAgLy8gIC0xIG1lYW5zIHRoZSBTdGF0ZSBNYW5hZ2VyIHdpbGwgc2V0IGl0IHRvIGJlIHRoZSBHYW1lIGRpbWVuc2lvbnNcbiAgICB0aGlzLndpZHRoID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2lkdGgnLCAtMSk7XG4gICAgdGhpcy5oZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdoZWlnaHQnLCAtMSk7XG59O1xuXG4vLyAgVW5sZXNzIHdlIGFkZCBzb21lIGFjdHVhbCBmdW5jdGlvbnMgaW4gaGVyZSwgd2UnbGwgbWFrZSB0aGlzIGp1c3QgcmV0dXJuIGFuIE9iamVjdCBpbnN0ZWFkIG9mIGFuIGluc3RhbmNlXG5TZXR0aW5ncy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXR0aW5ncztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TZXR0aW5ncy5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnknKTtcbi8vIHZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xudmFyIExvYWRlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9Mb2FkZXInKTtcbnZhciBNYWluTG9vcCA9IHJlcXVpcmUoJy4vc3lzdGVtcy9NYWluTG9vcCcpO1xudmFyIFVwZGF0ZU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvVXBkYXRlTWFuYWdlcicpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMnKTtcbnZhciBDYW1lcmEgPSByZXF1aXJlKCcuLi9jYW1lcmEvQ2FtZXJhJyk7XG5cbnZhciBTeXN0ZW1zID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXG57XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICB0aGlzLmV2ZW50cztcblxuICAgIC8vICBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBHYW1lIGxldmVsIFRleHR1cmVNYW5hZ2VyLlxuICAgIHRoaXMudGV4dHVyZXM7XG5cbiAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXG4gICAgdGhpcy5hZGQ7XG4gICAgdGhpcy5tYWtlO1xuICAgIHRoaXMuaW5wdXQ7XG4gICAgdGhpcy5sb2FkO1xuICAgIHRoaXMudHdlZW5zO1xuICAgIHRoaXMubWFpbmxvb3A7XG4gICAgdGhpcy51cGRhdGVzO1xuXG4gICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcbiAgICB0aGlzLmNhbWVyYTtcbiAgICB0aGlzLmNoaWxkcmVuO1xuICAgIHRoaXMuY29sb3I7XG4gICAgdGhpcy5kYXRhO1xuICAgIHRoaXMuZmJvO1xuICAgIHRoaXMudGltZTtcbiAgICB0aGlzLnRyYW5zZm9ybTtcbn07XG5cblN5c3RlbXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3lzdGVtcztcblxuU3lzdGVtcy5wcm90b3R5cGUgPSB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0YXRlLlN5c3RlbXMuaW5pdCcpO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLnN0YXRlLmdhbWUudGV4dHVyZXM7XG5cbiAgICAgICAgLy8gIEFsbCBvZiB0aGUgc3lzdGVtcyBjYW4gdXNlIHRoZSBTdGF0ZSBsZXZlbCBFdmVudERpc3BhdGNoZXIsIG9yIHRoZWlyIG93blxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblxuICAgICAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXG4gICAgICAgIC8vICBBbGwgdGhlc2UgdG8gYmUgc2V0IGJ5IGEgU3RhdGUgQ29uZmlnIHBhY2thZ2VcblxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBHYW1lT2JqZWN0RmFjdG9yeSh0aGlzLnN0YXRlKTtcbiAgICAgICAgLy8gdGhpcy5tYWtlID0gR2FtZU9iamVjdENyZWF0b3IodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMubWFpbmxvb3AgPSBuZXcgTWFpbkxvb3AodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZS5zZXR0aW5ncy5mcHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBuZXcgVXBkYXRlTWFuYWdlcih0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5sb2FkID0gbmV3IExvYWRlcih0aGlzLnN0YXRlKTtcblxuICAgICAgICAvLyB0aGlzLnR3ZWVucyA9IG5ldyBQaGFzZXIuVHdlZW5NYW5hZ2VyKHRoaXMuc3RhdGUpO1xuICAgICAgICAvLyB0aGlzLmlucHV0ID0gbmV3IFBoYXNlci5TdGF0ZS5JbnB1dCh0aGlzLnN0YXRlKTtcbiAgICAgICAgLy8gdGhpcy5waHlzaWNzID0gbmV3IFBoYXNlci5QaHlzaWNzLkFyY2FkZSh0aGlzLnN0YXRlLCA4MDAsIDYwMCk7XG5cbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKHRoaXMuc3RhdGUsIDAsIDAsIDgwMCwgNjAwKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDb21wb25lbnQuQ2hpbGRyZW4odGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQ29tcG9uZW50LkNvbG9yKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQ29tcG9uZW50LkRhdGEodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5jYW1lcmEudHJhbnNmb3JtO1xuXG4gICAgICAgIC8vICBCb290XG5cbiAgICAgICAgLy8gdGhpcy5pbnB1dC5pbml0KCk7XG5cbiAgICAgICAgLy8gIERlZmF1bHRzXG5cbiAgICAgICAgdGhpcy5zdGF0ZS5ldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgdGhpcy5zdGF0ZS5hZGQgPSB0aGlzLmFkZDtcbiAgICAgICAgdGhpcy5zdGF0ZS5sb2FkID0gdGhpcy5sb2FkO1xuICAgICAgICB0aGlzLnN0YXRlLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIHRoaXMuc3RhdGUuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgdGhpcy5zdGF0ZS50cmFuc2Zvcm0gPSB0aGlzLmNhbWVyYS50cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuc3RhdGUudGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG5cblxuICAgICAgICAvLyB0aGlzLnN0YXRlLmlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgLy8gdGhpcy5zdGF0ZS5zdGF0ZSA9IHRoaXMuc3RhdGUuZ2FtZS5zdGF0ZTtcblxuICAgICAgICAvLyAgSGVyZSB3ZSBjYW4gY2hlY2sgd2hpY2ggU3lzdGVtcyB0byBpbnN0YWxsIGFzIHByb3BlcnRpZXMgaW50byB0aGUgU3RhdGUgb2JqZWN0XG4gICAgICAgIC8vICAoZGVmYXVsdCBzeXN0ZW1zIGFsd2F5cyBleGlzdCBpbiBoZXJlLCByZWdhcmRsZXNzKVxuICAgIH0sXG5cbiAgICBiZWdpbjogZnVuY3Rpb24gKHRpbWVzdGFtcCwgZnJhbWVEZWx0YSlcbiAgICB7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwLCBwaHlzaWNzU3RlcClcbiAgICB7XG4gICAgfSxcblxuICAgIHByZVJlbmRlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gKGZwcywgcGFuaWMpXG4gICAge1xuICAgICAgICBpZiAocGFuaWMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0dGVybiBpbnRyb2R1Y2VzIG5vbi1kZXRlcm1pbmlzdGljIGJlaGF2aW9yLCBidXQgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAvLyBpdCdzIGJldHRlciB0aGFuIHRoZSBhbHRlcm5hdGl2ZSAodGhlIGFwcGxpY2F0aW9uIHdvdWxkIGxvb2sgbGlrZSBpdFxuICAgICAgICAgICAgLy8gd2FzIHJ1bm5pbmcgdmVyeSBxdWlja2x5IHVudGlsIHRoZSBzaW11bGF0aW9uIGNhdWdodCB1cCB0byByZWFsXG4gICAgICAgICAgICAvLyB0aW1lKS5cbiAgICAgICAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLm1haW5sb29wLnJlc2V0RnJhbWVEZWx0YSgpKTtcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWluIGxvb3AgcGFuaWNrZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIHdhcyBwdXQgaW4gdGhlIGJhY2tncm91bmQuIERpc2NhcmRpbmcgJyArIGRpc2NhcmRlZFRpbWUgKyAnbXMnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N5c3RlbXMuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL1N5c3RlbXMuanMiLCJcbnZhciBOT09QID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyAgTk9PUCAoTm8gT3BlcmF0aW9uKSBDYWxsYmFja1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOT09QO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvTk9PUC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENyZWF0ZSBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHJhbmdlIG9mIG51bWJlcnMgKHVzdWFsbHkgaW50ZWdlcnMpLCBiZXR3ZWVuLCBhbmQgaW5jbHVzaXZlIG9mLFxuKiB0aGUgZ2l2ZW4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJndW1lbnRzLiBGb3IgZXhhbXBsZTpcbipcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDIsIDQpOyAvLyBhcnJheSA9IFsyLCAzLCA0XWBcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDAsIDkpOyAvLyBhcnJheSA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XWBcbiogXG4qIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgbnVtYmVyQXJyYXlTdGVwKHN0YXJ0LCBlbmQsIDEpYC5cbiogXG4qIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgcHJlZml4IGFuZCAvIG9yIHN1ZmZpeCBzdHJpbmcuIElmIGdpdmVuIHRoZSBhcnJheSB3aWxsIGNvbnRhaW5cbiogc3RyaW5ncywgbm90IGludGVnZXJzLiBGb3IgZXhhbXBsZTpcbiogXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgxLCA0LCAnTGV2ZWwgJyk7IC8vIGFycmF5ID0gW1wiTGV2ZWwgMVwiLCBcIkxldmVsIDJcIiwgXCJMZXZlbCAzXCIsIFwiTGV2ZWwgNFwiXWBcbiogYHZhciBhcnJheSA9IG51bWJlckFycmF5KDUsIDcsICdIRC0nLCAnLnBuZycpOyAvLyBhcnJheSA9IFtcIkhELTUucG5nXCIsIFwiSEQtNi5wbmdcIiwgXCJIRC03LnBuZ1wiXWBcbipcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVxuKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgbWluaW11bSB2YWx1ZSB0aGUgYXJyYXkgc3RhcnRzIHdpdGguXG4qIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgYXJyYXkgY29udGFpbnMuXG4qIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSAtIE9wdGlvbmFsIHByZWZpeCB0byBwbGFjZSBiZWZvcmUgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXG4qIEBwYXJhbSB7c3RyaW5nfSBbc3VmZml4XSAtIE9wdGlvbmFsIHN1ZmZpeCB0byBwbGFjZSBhZnRlciB0aGUgbnVtYmVyLiBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBjb250YWluIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy5cbiogQHJldHVybiB7bnVtYmVyW118c3RyaW5nW119IFRoZSBhcnJheSBvZiBudW1iZXIgdmFsdWVzLCBvciBzdHJpbmdzIGlmIGEgcHJlZml4IG9yIHN1ZmZpeCB3YXMgcHJvdmlkZWQuXG4qL1xudmFyIE51bWJlckFycmF5ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHByZWZpeCwgc3VmZml4KVxue1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIga2V5ID0gKHByZWZpeCkgPyBwcmVmaXggKyBpLnRvU3RyaW5nKCkgOiBpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChzdWZmaXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LmNvbmNhdChzdWZmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L051bWJlckFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgUmVtb3ZlcyBhIHNpbmdsZSBpdGVtIGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXRcbi8vICB3aXRob3V0IGNyZWF0aW5nIGdjIChsaWtlIHRoZSBuYXRpdmUgc3BsaWNlIGRvZXMpXG4vLyAgQmFzZWQgb24gY29kZSBieSBNaWtlIFJlaW5zdGVpblxuXG52YXIgU3BsaWNlT25lID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleClcbntcbiAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGl0ZW0gPSBhcnJheVtpbmRleF07XG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIH1cblxuICAgIGFycmF5Lmxlbmd0aCA9IGxlbjtcblxuICAgIHJldHVybiBpdGVtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGxpY2VPbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9TcGxpY2VPbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkuaXNQbGFpbk9iamVjdC5cbiogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdob3NlIGludGVybmFsIGNsYXNzIHByb3BlcnR5IGlzIFtvYmplY3QgT2JqZWN0XS5cbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMuaXNQbGFpbk9iamVjdFxuKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCBpcyBwbGFpbiwgb3RoZXJ3aXNlIGZhbHNlLlxuKi9cbnZhciBJc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKG9iailcbntcbiAgICAvLyBOb3QgcGxhaW4gb2JqZWN0czpcbiAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgLy8gLSBET00gbm9kZXNcbiAgICAvLyAtIHdpbmRvd1xuICAgIGlmICh0eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgb2JqID09PSBvYmoud2luZG93KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPDIwXG4gICAgLy8gVGhlIHRyeS9jYXRjaCBzdXBwcmVzc2VzIGV4Y2VwdGlvbnMgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhY2Nlc3NcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04MTQ2MjJcbiAgICB0cnkge1xuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICEoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9vYmplY3QvSXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIENvbmZpZyA9IHJlcXVpcmUoJy4vQ29uZmlnJyk7XG52YXIgRGVidWdIZWFkZXIgPSByZXF1aXJlKCcuL0RlYnVnSGVhZGVyJyk7XG52YXIgRGV2aWNlID0gcmVxdWlyZSgnLi4vZGV2aWNlJyk7XG5cbnZhciBBZGRUb0RPTSA9IHJlcXVpcmUoJy4uL2RvbS9BZGRUb0RPTScpO1xudmFyIFJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcbnZhciBET01Db250ZW50TG9hZGVkID0gcmVxdWlyZSgnLi4vZG9tL0RPTUNvbnRlbnRMb2FkZWQnKTtcblxudmFyIENyZWF0ZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9DcmVhdGVSZW5kZXJlcicpO1xudmFyIFJhbmRvbURhdGFHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9tYXRoL3JhbmRvbS1kYXRhLWdlbmVyYXRvci9SYW5kb21EYXRhR2VuZXJhdG9yJyk7XG52YXIgU3RhdGVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vc3RhdGUvU3RhdGVNYW5hZ2VyJyk7XG52YXIgVGV4dHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlcicpO1xuXG52YXIgR2FtZSA9IGZ1bmN0aW9uIChjb25maWcpXG57XG4gICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKGNvbmZpZyk7XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuaXNCb290ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5SZXF1ZXN0QW5pbWF0aW9uRnJhbWV9IHJhZiAtIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyB0aGUgY29yZSBnYW1lIGxvb3AgdmlhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBvciBzZXRUaW1lb3V0XG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgICB0aGlzLnJhZiA9IG5ldyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmVNYW5hZ2VyfSB0ZXh0dXJlcyAtIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIFRleHR1cmUgTWFuYWdlci5cbiAgICAqL1xuICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgVGV4dHVyZU1hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuQ2FjaGV9IGNhY2hlIC0gUmVmZXJlbmNlIHRvIHRoZSBhc3NldHMgY2FjaGUuXG4gICAgKi9cbiAgICAvLyB0aGlzLmNhY2hlID0gbmV3IENhY2hlKCk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLklucHV0fSBpbnB1dCAtIFJlZmVyZW5jZSB0byB0aGUgaW5wdXQgbWFuYWdlclxuICAgICovXG4gICAgdGhpcy5pbnB1dCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlTWFuYWdlcn0gc3RhdGUgLSBUaGUgU3RhdGVNYW5hZ2VyLiBQaGFzZXIgaW5zdGFuY2Ugc3BlY2lmaWMuXG4gICAgKi9cbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlTWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZy5zdGF0ZUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkRldmljZX0gZGV2aWNlIC0gQ29udGFpbnMgZGV2aWNlIGluZm9ybWF0aW9uIGFuZCBjYXBhYmlsaXRpZXMgKHNpbmdsZXRvbilcbiAgICAqL1xuICAgIHRoaXMuZGV2aWNlID0gRGV2aWNlO1xuXG4gICAgLy8gIE1vdmUgdGhpcyBzb21ld2hlcmUgZWxzZT8gTWF0aCBwZXJoYXBzPyBEb2Vzbid0IG5lZWQgdG8gYmUgYSBHYW1lIGxldmVsIHN5c3RlbS5cbiAgICB0aGlzLnJuZDtcblxuICAgIC8vICBXYWl0IGZvciB0aGUgRE9NIFJlYWR5IGV2ZW50LCB0aGVuIGNhbGwgYm9vdC5cbiAgICBET01Db250ZW50TG9hZGVkKHRoaXMuYm9vdC5iaW5kKHRoaXMpKTtcblxuICAgIC8vICBGb3IgZGVidWdnaW5nIG9ubHlcbiAgICB3aW5kb3cuZ2FtZSA9IHRoaXM7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWU7XG5cbkdhbWUucHJvdG90eXBlID0ge1xuXG4gICAgYm9vdDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY29uZmlnLnByZUJvb3QoKTtcblxuICAgICAgICAvLyAgUHJvYmFibHkgbW92ZSB3aXRoaW4gTWF0aFxuICAgICAgICB0aGlzLnJuZCA9IG5ldyBSYW5kb21EYXRhR2VuZXJhdG9yKHRoaXMuY29uZmlnLnNlZWQpO1xuXG4gICAgICAgIERlYnVnSGVhZGVyKHRoaXMpO1xuXG4gICAgICAgIENyZWF0ZVJlbmRlcmVyKHRoaXMpO1xuXG4gICAgICAgIEFkZFRvRE9NKHRoaXMuY2FudmFzLCB0aGlzLmNvbmZpZy5wYXJlbnQpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUuYm9vdCgpO1xuXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbmZpZy5wb3N0Qm9vdCgpO1xuXG4gICAgICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gICAgfSxcblxuICAgIC8vICB0aW1lc3RhbXAgPSBET01IaWdoUmVzVGltZVN0YW1wXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodGltZXN0YW1wKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGVwKHRpbWVzdGFtcCk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0dhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvR2FtZS5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDb250YWluZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lcicpO1xudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XG5cbnZhciBDb250YWluZXJGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnY29udGFpbmVyJyxcblxuICAgIGFkZDogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcbiAgICB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgeyBwYXJlbnQgPSB0aGlzLnN0YXRlOyB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpKTtcbiAgICB9LFxuXG4gICAgbWFrZTogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKHRoaXMuc3RhdGUsIHBhcmVudCwgeCwgeSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoQ29udGFpbmVyRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKCcuL0ltYWdlJyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIEltYWdlRmFjdG9yeSA9IHtcblxuICAgIEtFWTogJ2ltYWdlJyxcblxuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IGBJbWFnZWAgb2JqZWN0LlxuICAgICpcbiAgICAqIEFuIEltYWdlIGlzIGEgbGlnaHQtd2VpZ2h0IG9iamVjdCB5b3UgY2FuIHVzZSB0byBkaXNwbGF5IGFueXRoaW5nIHRoYXQgZG9lc24ndCBuZWVkIHBoeXNpY3Mgb3IgYW5pbWF0aW9uLlxuICAgICpcbiAgICAqIEl0IGNhbiBzdGlsbCByb3RhdGUsIHNjYWxlLCBjcm9wIGFuZCByZWNlaXZlIGlucHV0IGV2ZW50cy5cbiAgICAqIFRoaXMgbWFrZXMgaXQgcGVyZmVjdCBmb3IgbG9nb3MsIGJhY2tncm91bmRzLCBzaW1wbGUgYnV0dG9ucyBhbmQgb3RoZXIgbm9uLVNwcml0ZSBncmFwaGljcy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnkjaW1hZ2VcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfFBoYXNlci5SZW5kZXJUZXh0dXJlfFBoYXNlci5CaXRtYXBEYXRhfFBoYXNlci5WaWRlb3xQSVhJLlRleHR1cmV9IFtrZXldIC0gVGhlIGltYWdlIHVzZWQgYXMgYSB0ZXh0dXJlIGJ5IHRoaXMgZGlzcGxheSBvYmplY3QgZHVyaW5nIHJlbmRlcmluZy4gSWYgYSBzdHJpbmcgUGhhc2VyIHdpbGwgZ2V0IGZvciBhbiBlbnRyeSBpbiB0aGUgSW1hZ2UgQ2FjaGUuIE9yIGl0IGNhbiBiZSBhbiBpbnN0YW5jZSBvZiBhIFJlbmRlclRleHR1cmUsIEJpdG1hcERhdGEsIFZpZGVvIG9yIFBJWEkuVGV4dHVyZS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2ZyYW1lXSAtIElmIGEgVGV4dHVyZSBBdGxhcyBvciBTcHJpdGUgU2hlZXQgaXMgdXNlZCB0aGlzIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZnJhbWUgdG8gYmUgdXNlZC4gVXNlIGVpdGhlciBhbiBpbnRlZ2VyIGZvciBhIEZyYW1lIElEIG9yIGEgc3RyaW5nIGZvciBhIGZyYW1lIG5hbWUuXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gW2dyb3VwXSAtIE9wdGlvbmFsIEdyb3VwIHRvIGFkZCB0aGUgb2JqZWN0IHRvLiBJZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFdvcmxkIGdyb3VwLlxuICAgICogQHJldHVybiB7UGhhc2VyLkltYWdlfSBUaGUgbmV3bHkgY3JlYXRlZCBJbWFnZSBvYmplY3QuXG4gICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lLCBncm91cClcbiAgICB7XG4gICAgICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkKSB7IGdyb3VwID0gdGhpcy5zdGF0ZTsgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkuYWRkJywga2V5LCB4LCB5LCBmcmFtZSwgZ3JvdXApO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50byBTdGF0ZScsIHRoaXMuc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBncm91cC5jaGlsZHJlbi5hZGQobmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcbiAgICB9LFxuXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnSW1hZ2VGYWN0b3J5Lm1ha2UnLCBrZXksIHgsIHksIGZyYW1lKTtcblxuICAgICAgICByZXR1cm4gbmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKEltYWdlRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlRmFjdG9yeS5qcyIsIi8vICBQaGFzZXIuR2VvbVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcbiAgICBDaXJjbGU6IHJlcXVpcmUoJy4vY2lyY2xlJyksXG4gICAgRWxsaXBzZTogcmVxdWlyZSgnLi9lbGxpcHNlJyksXG4gICAgSGVybWl0ZTogcmVxdWlyZSgnLi9oZXJtaXRlJyksXG4gICAgSW50ZXJzZWN0czogcmVxdWlyZSgnLi9pbnRlcnNlY3RzJyksXG4gICAgTGluZTogcmVxdWlyZSgnLi9saW5lJyksXG4gICAgUG9pbnQ6IHJlcXVpcmUoJy4vcG9pbnQnKSxcbiAgICBQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKSxcbiAgICBSZWN0YW5nbGU6IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vICBDT05TVHMgKG1ha2VzIHRoZW0gdmlzaWJsZSB1bmRlciBQaGFzZXIuTWF0aClcbiAgICBQSTI6IE1hdGguUEkgKiAyLFxuICAgIFRBVTogTWF0aC5QSSAqIDAuNSxcbiAgICBFUFNJTE9OOiAxLjBlLTYsXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxuXG4gICAgLy8gIENvbGxlY3Rpb25zIG9mIGZ1bmN0aW9uc1xuICAgIEFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlLycpLFxuICAgIERpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlLycpLFxuICAgIEVhc2luZzogcmVxdWlyZSgnLi9lYXNpbmcvJyksXG4gICAgRnV6enk6IHJlcXVpcmUoJy4vZnV6enkvJyksXG4gICAgSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9pbnRlcnBvbGF0aW9uLycpLFxuICAgIFBvdzI6IHJlcXVpcmUoJy4vcG93Mi8nKSxcbiAgICBTbmFwOiByZXF1aXJlKCcuL3NuYXAvJyksXG5cbiAgICAvLyAgU2luZ2xlIGZ1bmN0aW9uc1xuICAgIEF2ZXJhZ2U6IHJlcXVpcmUoJy4vQXZlcmFnZScpLFxuICAgIEJlcm5zdGVpbjogcmVxdWlyZSgnLi9CZXJuc3RlaW4nKSxcbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0JldHdlZW4nKSxcbiAgICBDYXRtdWxsUm9tOiByZXF1aXJlKCcuL0NhdG11bGxSb20nKSxcbiAgICBDZWlsVG86IHJlcXVpcmUoJy4vQ2VpbFRvJyksXG4gICAgQ2xhbXA6IHJlcXVpcmUoJy4vQ2xhbXAnKSxcbiAgICBEZWdUb1JhZDogcmVxdWlyZSgnLi9EZWdUb1JhZCcpLFxuICAgIERpZmZlcmVuY2U6IHJlcXVpcmUoJy4vRGlmZmVyZW5jZScpLFxuICAgIEZhY3RvcmlhbDogcmVxdWlyZSgnLi9GYWN0b3JpYWwnKSxcbiAgICBGbG9hdEJldHdlZW46IHJlcXVpcmUoJy4vRmxvYXRCZXR3ZWVuJyksXG4gICAgRmxvb3JUbzogcmVxdWlyZSgnLi9GbG9vclRvJyksXG4gICAgTGluZWFyOiByZXF1aXJlKCcuL0xpbmVhcicpLFxuICAgIE1heEFkZDogcmVxdWlyZSgnLi9NYXhBZGQnKSxcbiAgICBNaW5TdWI6IHJlcXVpcmUoJy4vTWluU3ViJyksXG4gICAgUGVyY2VudDogcmVxdWlyZSgnLi9QZXJjZW50JyksXG4gICAgUmFkVG9EZWc6IHJlcXVpcmUoJy4vUmFkVG9EZWcnKSxcbiAgICBSb3RhdGU6IHJlcXVpcmUoJy4vUm90YXRlJyksXG4gICAgUm90YXRlQXJvdW5kOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZCcpLFxuICAgIFJvdGF0ZUFyb3VuZERpc3RhbmNlOiByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZERpc3RhbmNlJyksXG4gICAgUm91bmRBd2F5RnJvbVplcm86IHJlcXVpcmUoJy4vUm91bmRBd2F5RnJvbVplcm8nKSxcbiAgICBSb3VuZFRvOiByZXF1aXJlKCcuL1JvdW5kVG8nKSxcbiAgICBTaW5Db3NUYWJsZUdlbmVyYXRvcjogcmVxdWlyZSgnLi9TaW5Db3NUYWJsZUdlbmVyYXRvcicpLFxuICAgIFNtb290aGVyU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhlclN0ZXAnKSxcbiAgICBTbW9vdGhTdGVwOiByZXF1aXJlKCcuL1Ntb290aFN0ZXAnKSxcbiAgICBXaXRoaW46IHJlcXVpcmUoJy4vV2l0aGluJyksXG4gICAgV3JhcDogcmVxdWlyZSgnLi9XcmFwJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW5kZXguanMiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9wb2x5ZmlsbHMvaW5kZXguanMiLCJyZXF1aXJlKCcuL0FycmF5LmZvckVhY2gnKTtcbnJlcXVpcmUoJy4vQXJyYXkuaXNBcnJheScpO1xucmVxdWlyZSgnLi9BdWRpb0NvbnRleHRNb25rZXlQYXRjaCcpO1xucmVxdWlyZSgnLi9jb25zb2xlJyk7XG5yZXF1aXJlKCcuL0Z1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vTWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9wZXJmb3JtYW5jZS5ub3cnKTtcbnJlcXVpcmUoJy4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5yZXF1aXJlKCcuL1VpbnQzMkFycmF5Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuU291bmRcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBEeW5hbWljOiByZXF1aXJlKCcuL2R5bmFtaWMnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcbiAgICBHZXRSYW5kb21FbGVtZW50OiByZXF1aXJlKCcuL0dldFJhbmRvbUVsZW1lbnQnKSxcbiAgICBOdW1iZXJBcnJheTogcmVxdWlyZSgnLi9OdW1iZXJBcnJheScpLFxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcbiAgICBSZW1vdmVSYW5kb21FbGVtZW50OiByZXF1aXJlKCcuL1JlbW92ZVJhbmRvbUVsZW1lbnQnKSxcbiAgICBSb3RhdGVMZWZ0OiByZXF1aXJlKCcuL1JvdGF0ZUxlZnQnKSxcbiAgICBSb3RhdGVSaWdodDogcmVxdWlyZSgnLi9Sb3RhdGVSaWdodCcpLFxuICAgIFNodWZmbGU6IHJlcXVpcmUoJy4vU2h1ZmZsZScpLFxuICAgIFNwbGljZU9uZTogcmVxdWlyZSgnLi9TcGxpY2VPbmUnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBFeHRlbmQ6IHJlcXVpcmUoJy4vRXh0ZW5kJyksXG4gICAgSXNQbGFpbk9iamVjdDogcmVxdWlyZSgnLi9Jc1BsYWluT2JqZWN0JylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL29iamVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvb2JqZWN0L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUubDsgfVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZS5pOyB9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvR2V0T2JqZWN0VmFsdWUnKTtcblxudmFyIGRlZmF1bHRCYW5uZXJDb2xvciA9IFtcbiAgICAnI2ZmMDAwMCcsXG4gICAgJyNmZmZmMDAnLFxuICAgICcjMDBmZjAwJyxcbiAgICAnIzAwZmZmZicsXG4gICAgJyMwMDAwMDAnXG5dO1xuXG52YXIgZGVmYXVsdEJhbm5lclRleHRDb2xvciA9ICcjZmZmZmZmJztcblxudmFyIENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpXG57XG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IGNvbmZpZyA9IHt9OyB9XG5cbiAgICB0aGlzLndpZHRoID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2lkdGgnLCAxMDI0KTtcbiAgICB0aGlzLmhlaWdodCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2hlaWdodCcsIDc2OCk7XG5cbiAgICB0aGlzLnJlc29sdXRpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXNvbHV0aW9uJywgMSk7XG5cbiAgICB0aGlzLnJlbmRlclR5cGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0eXBlJywgQ09OU1QuQVVUTyk7XG5cbiAgICB0aGlzLnBhcmVudCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BhcmVudCcsIG51bGwpO1xuICAgIHRoaXMuY2FudmFzID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FudmFzJywgbnVsbCk7XG4gICAgdGhpcy5jYW52YXNTdHlsZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NhbnZhc1N0eWxlJywgbnVsbCk7XG5cbiAgICB0aGlzLnN0YXRlQ29uZmlnID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc3RhdGUnLCBudWxsKTtcblxuICAgIHRoaXMuc2VlZCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3NlZWQnLCBbIChEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKSBdKTtcblxuICAgIHRoaXMuZ2FtZVRpdGxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndGl0bGUnLCAnJyk7XG4gICAgdGhpcy5nYW1lVVJMID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndXJsJywgJ2h0dHA6Ly9waGFzZXIuaW8nKTtcbiAgICB0aGlzLmdhbWVWZXJzaW9uID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndmVyc2lvbicsICcnKTtcblxuICAgIC8vICBJZiB5b3UgZG86IHsgYmFubmVyOiBmYWxzZSB9IGl0IHdvbid0IGRpc3BsYXkgYW55IGJhbm5lciBhdCBhbGxcbiAgICB0aGlzLmhpZGVCYW5uZXIgPSAoR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYmFubmVyJywgbnVsbCkgPT09IGZhbHNlKTtcblxuICAgIHRoaXMuaGlkZVBoYXNlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5oaWRlUGhhc2VyJywgZmFsc2UpO1xuICAgIHRoaXMuYmFubmVyVGV4dENvbG9yID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYmFubmVyLnRleHQnLCBkZWZhdWx0QmFubmVyVGV4dENvbG9yKTtcbiAgICB0aGlzLmJhbm5lckJhY2tncm91bmRDb2xvciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci5iYWNrZ3JvdW5kJywgZGVmYXVsdEJhbm5lckNvbG9yKTtcbiAgIFxuICAgIHRoaXMuZm9yY2VTZXRUaW1lT3V0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZm9yY2VTZXRUaW1lT3V0JywgZmFsc2UpO1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0cmFuc3BhcmVudCcsIGZhbHNlKTtcbiAgICB0aGlzLnBpeGVsQXJ0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGl4ZWxBcnQnLCBmYWxzZSk7XG5cbiAgICAvLyAgQ2FsbGJhY2tzXG4gICAgdGhpcy5wcmVCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnByZUJvb3QnLCBOT09QKTtcbiAgICB0aGlzLnBvc3RCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnBvc3RCb290JywgTk9PUCk7XG59O1xuXG5Db25maWcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZmlnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvQ29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0NvbmZpZy5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XG52YXIgRmVhdHVyZXMgPSByZXF1aXJlKCcuLi9kZXZpY2UvRmVhdHVyZXMnKTtcbnZhciBDYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlcicpO1xudmFyIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlci93ZWJnbC9yZW5kZXJlcnMvUGFydGljbGVSZW5kZXJlcicpO1xuXG4vKipcbiogQ2hlY2tzIGlmIHRoZSBkZXZpY2UgaXMgY2FwYWJsZSBvZiB1c2luZyB0aGUgcmVxdWVzdGVkIHJlbmRlcmVyIGFuZCBzZXRzIGl0IHVwIG9yIGFuIGFsdGVybmF0aXZlIGlmIG5vdC5cbipcbiogQG1ldGhvZCBQaGFzZXIuR2FtZSNzZXRVcFJlbmRlcmVyXG4qIEBwcm90ZWN0ZWRcbiovXG52YXIgQ3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoZ2FtZSlcbntcbiAgICB2YXIgY29uZmlnID0gZ2FtZS5jb25maWc7XG5cbiAgICAvLyAgR2FtZSBlaXRoZXIgcmVxdWVzdGVkIENhbnZhcyxcbiAgICAvLyAgb3IgcmVxdWVzdGVkIEFVVE8gb3IgV0VCR0wgYnV0IHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdCwgc28gZmFsbCBiYWNrIHRvIENhbnZhc1xuICAgIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTIHx8IChjb25maWcucmVuZGVyVHlwZSAhPT0gQ09OU1QuQ0FOVkFTICYmICFGZWF0dXJlcy53ZWJHTCkpXG4gICAge1xuICAgICAgICBpZiAoRmVhdHVyZXMuY2FudmFzKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhleSByZXF1ZXN0ZWQgQ2FudmFzIGFuZCB0aGVpciBicm93c2VyIHN1cHBvcnRzIGl0XG4gICAgICAgICAgICBjb25maWcucmVuZGVyVHlwZSA9IENPTlNULkNBTlZBUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBDYW52YXMgb3IgV2ViR0wgY29udGV4dCwgYWJvcnRpbmcuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gIEdhbWUgcmVxdWVzdGVkIFdlYkdMIGFuZCBicm93c2VyIHNheXMgaXQgc3VwcG9ydHMgaXRcbiAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5XRUJHTDtcbiAgICB9XG5cbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBpdHMgb3duIGNhbnZhcyBlbGVtZW50IHRvIHVzZT9cbiAgICBpZiAoY29uZmlnLmNhbnZhcylcbiAgICB7XG4gICAgICAgIGdhbWUuY2FudmFzID0gY29uZmlnLmNhbnZhcztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2FtZS5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShnYW1lLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQsIGNvbmZpZy5yZW5kZXJUeXBlKTtcbiAgICB9XG5cbiAgICAvLyAgRG9lcyB0aGUgZ2FtZSBjb25maWcgcHJvdmlkZSBzb21lIGNhbnZhcyBjc3Mgc3R5bGVzIHRvIHVzZT9cbiAgICBpZiAoY29uZmlnLmNhbnZhc1N0eWxlKVxuICAgIHtcbiAgICAgICAgZ2FtZS5jYW52YXMuc3R5bGUgPSBjb25maWcuY2FudmFzU3R5bGU7XG4gICAgfVxuXG4gICAgLy8gIENyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIFdFQkdMIFJlbmRlcmVyJyk7XG4gICAgICAgIGdhbWUucmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcihnYW1lKTtcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIENhbnZhcyBSZW5kZXJlcicpO1xuICAgICAgICBnYW1lLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKGdhbWUpO1xuICAgICAgICBnYW1lLmNvbnRleHQgPSBnYW1lLnJlbmRlcmVyLmNvbnRleHQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIENIRUNLU1VNID0gcmVxdWlyZSgnLi4vY2hlY2tzdW0nKTtcblxudmFyIERlYnVnSGVhZGVyID0gZnVuY3Rpb24gKGdhbWUpXG57XG4gICAgdmFyIGNvbmZpZyA9IGdhbWUuY29uZmlnO1xuXG4gICAgaWYgKGNvbmZpZy5oaWRlQmFubmVyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJUeXBlID0gKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5DQU5WQVMpID8gJ0NhbnZhcycgOiAnV2ViR0wnO1xuXG4gICAgdmFyIGllID0gZmFsc2U7XG5cbiAgICBpZiAoIWllKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSAnJztcbiAgICAgICAgdmFyIGFyZ3MgPSBbY107XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sb3I7XG5cbiAgICAgICAgICAgIGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IuZm9yRWFjaChmdW5jdGlvbihjb2xvcikge1xuXG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCclYyAnKTtcblxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnYmFja2dyb3VuZDogJyArIGNvbG9yKTtcblxuICAgICAgICAgICAgICAgIGxhc3RDb2xvciA9IGNvbG9yO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gIGluamVjdCB0aGUgdGV4dCBjb2xvclxuICAgICAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBsYXN0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjID0gYy5jb25jYXQoJyVjICcpO1xuXG4gICAgICAgICAgICBhcmdzLnB1c2goJ2NvbG9yOiAnICsgY29uZmlnLmJhbm5lclRleHRDb2xvciArICc7IGJhY2tncm91bmQ6ICcgKyBjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBVUkwgbGluayBiYWNrZ3JvdW5kIGNvbG9yIChhbHdheXMgd2hpdGUpXG4gICAgICAgIGFyZ3MucHVzaCgnYmFja2dyb3VuZDogI2ZmZicpO1xuXG4gICAgICAgIGlmIChjb25maWcuZ2FtZVRpdGxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjID0gYy5jb25jYXQoY29uZmlnLmdhbWVUaXRsZSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuZ2FtZVZlcnNpb24pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYyA9IGMuY29uY2F0KCcgdicgKyBjb25maWcuZ2FtZVZlcnNpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnIC8gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZy5oaWRlUGhhc2VyKVxuICAgICAgICB7XG4gICAgICAgICAgICBjID0gYy5jb25jYXQoJ1BoYXNlciB2JyArIENPTlNULlZFUlNJT04gKyAnICgnICsgcmVuZGVyVHlwZSArICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjID0gYy5jb25jYXQoJyAlYyAnICsgY29uZmlnLmdhbWVVUkwpO1xuXG4gICAgICAgIC8vICBJbmplY3QgdGhlIG5ldyBzdHJpbmcgYmFjayBpbnRvIHRoZSBhcmdzIGFycmF5XG4gICAgICAgIGFyZ3NbMF0gPSBjO1xuXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3dbJ2NvbnNvbGUnXSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQaGFzZXIgdicgKyBDT05TVC5WRVJTSU9OICsgJyAvIGh0dHA6Ly9waGFzZXIuaW8nKTtcbiAgICB9XG5cbiAgICAvLyBLZWVwIHRoaXMgZHVyaW5nIGRldiBidWlsZCBvbmx5XG4gICAgY29uc29sZS5sb2coQ0hFQ0tTVU0uYnVpbGQpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnSGVhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9EZWJ1Z0hlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzJyk7XG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL21hdGgvY29uc3QnKTtcbnZhciBXcmFwQW5nbGUgPSByZXF1aXJlKCcuLi9tYXRoL2FuZ2xlL1dyYXAnKTtcblxuLyoqXG4qIEEgQ2FtZXJhIGlzIHlvdXIgdmlldyBpbnRvIHRoZSBnYW1lIHdvcmxkLiBJdCBoYXMgYSBwb3NpdGlvbiBhbmQgc2l6ZSBhbmQgcmVuZGVycyBvbmx5IHRob3NlIG9iamVjdHMgd2l0aGluIGl0cyBmaWVsZCBvZiB2aWV3LlxuKiBUaGUgZ2FtZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBzaW5nbGUgU3RhZ2Ugc2l6ZWQgY2FtZXJhIG9uIGJvb3QuIE1vdmUgdGhlIGNhbWVyYSBhcm91bmQgdGhlIHdvcmxkIHdpdGggUGhhc2VyLkNhbWVyYS54L3lcbipcbiogQGNsYXNzIFBoYXNlci5DYW1lcmFcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBHYW1lIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiogQHBhcmFtIHtudW1iZXJ9IGlkIC0gTm90IGJlaW5nIHVzZWQgYXQgdGhlIG1vbWVudCwgd2lsbCBiZSB3aGVuIFBoYXNlciBzdXBwb3J0cyBtdWx0aXBsZSBjYW1lcmFcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBQb3NpdGlvbiBvZiB0aGUgY2FtZXJhIG9uIHRoZSBYIGF4aXNcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBvZiB0aGUgY2FtZXJhIG9uIHRoZSBZIGF4aXNcbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB2aWV3IHJlY3RhbmdsZVxuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlldyByZWN0YW5nbGVcbiovXG52YXIgQ2FtZXJhID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBUaGUgU3RhdGUgdGhhdCB0aGlzIENhbWVyYSBiZWxvbmdzIHRvLiBBIENhbWVyYSBjYW4gb25seSBiZWxvbmcgdG8gb25lIFN0YXRlLCBhbmQgYSBTdGF0ZSBvbmx5XG4gICAgICogaGFzIG9uZSBDYW1lcmEuXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5TdGF0ZX0gc3RhdGVcbiAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBHYW1lLlxuICAgICovXG4gICAgdGhpcy5nYW1lID0gc3RhdGUuZ2FtZTtcblxuICAgIHRoaXMudmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGg7XG5cbiAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XG5cbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBDb21wb25lbnQuVHJhbnNmb3JtKHRoaXMsIHgsIHkpO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgQ2FtZXJhIGlzIGJvdW5kIHRvIHRoaXMgUmVjdGFuZ2xlIGFuZCBjYW5ub3QgbW92ZSBvdXRzaWRlIG9mIGl0LiBCeSBkZWZhdWx0IGl0IGlzIGVuYWJsZWQgYW5kIHNldCB0byB0aGUgc2l6ZSBvZiB0aGUgV29ybGQuXG4gICAgKiBUaGUgUmVjdGFuZ2xlIGNhbiBiZSBsb2NhdGVkIGFueXdoZXJlIGluIHRoZSB3b3JsZCBhbmQgdXBkYXRlZCBhcyBvZnRlbiBhcyB5b3UgbGlrZS4gSWYgeW91IGRvbid0IHdpc2ggdGhlIENhbWVyYSB0byBiZSBib3VuZFxuICAgICogYXQgYWxsIHRoZW4gc2V0IHRoaXMgdG8gbnVsbC4gVGhlIHZhbHVlcyBjYW4gYmUgYW55dGhpbmcgYW5kIGFyZSBpbiBXb3JsZCBjb29yZGluYXRlcywgd2l0aCAwLDAgYmVpbmcgdGhlIHRvcC1sZWZ0IG9mIHRoZSB3b3JsZC5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5SZWN0YW5nbGV9IGJvdW5kcyAtIFRoZSBSZWN0YW5nbGUgaW4gd2hpY2ggdGhlIENhbWVyYSBpcyBib3VuZGVkLiBTZXQgdG8gbnVsbCB0byBhbGxvdyBmb3IgbW92ZW1lbnQgYW55d2hlcmUuXG4gICAgKi9cbiAgICAvLyB0aGlzLmJvdW5kcyA9IG5ldyBQaGFzZXIuUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gdGhpcy5ib3VuZHMgPSBuZXcgUGhhc2VyLkNpcmNsZSh4LCB5KVxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGF0TGltaXQgLSBXaGV0aGVyIHRoaXMgY2FtZXJhIGlzIGZsdXNoIHdpdGggdGhlIFdvcmxkIEJvdW5kcyBvciBub3QuXG4gICAgKi9cbiAgICB0aGlzLmF0TGltaXQgPSB7IHg6IGZhbHNlLCB5OiBmYWxzZSB9O1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYTtcblxuQ2FtZXJhLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogTWV0aG9kIGNhbGxlZCB0byBlbnN1cmUgdGhlIGNhbWVyYSBkb2Vzbid0IHZlbnR1cmUgb3V0c2lkZSBvZiB0aGUgZ2FtZSB3b3JsZC5cbiAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IENhbWVyYS51cGRhdGUuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FtZXJhI2NoZWNrQm91bmRzXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgICBjaGVja0JvdW5kczogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuYXRMaW1pdC54ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXRMaW1pdC55ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gdmFyIHZ4ID0gdGhpcy52aWV3LnggKyB0aGlzLl9zaGFrZS54O1xuICAgICAgICAvLyB2YXIgdncgPSB0aGlzLnZpZXcucmlnaHQgKyB0aGlzLl9zaGFrZS54O1xuICAgICAgICAvLyB2YXIgdnkgPSB0aGlzLnZpZXcueSArIHRoaXMuX3NoYWtlLnk7XG4gICAgICAgIC8vIHZhciB2aCA9IHRoaXMudmlldy5ib3R0b20gKyB0aGlzLl9zaGFrZS55O1xuXG4gICAgICAgIHZhciB2eCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHZ3ID0gdGhpcy54ICsgdGhpcy52aWV3cG9ydFdpZHRoO1xuICAgICAgICB2YXIgdnkgPSB0aGlzLnk7XG4gICAgICAgIHZhciB2aCA9IHRoaXMueSArIHRoaXMudmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgLy8gIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgZ28gb3V0c2lkZSB0aGUgY2FtZXJhcyBib3VuZHNcbiAgICAgICAgaWYgKHZ4IDw9IHRoaXMuYm91bmRzLnggKiB0aGlzLnNjYWxlLngpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXRMaW1pdC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmlldy54ID0gdGhpcy5ib3VuZHMueCAqIHRoaXMuc2NhbGUueDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGNhbWVyYSBpcyB1cCBhZ2FpbnN0IHRoZSBib3VuZHMsIHNvIHJlc2V0IHRoZSBzaGFrZVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZ3ID49IHRoaXMuYm91bmRzLnJpZ2h0ICogdGhpcy5zY2FsZS54KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmF0TGltaXQueCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZpZXcueCA9ICh0aGlzLmJvdW5kcy5yaWdodCAqIHRoaXMuc2NhbGUueCkgLSB0aGlzLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWtlLnNoYWtlQm91bmRzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBUaGUgY2FtZXJhIGlzIHVwIGFnYWluc3QgdGhlIGJvdW5kcywgc28gcmVzZXQgdGhlIHNoYWtlXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2UueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodnkgPD0gdGhpcy5ib3VuZHMudG9wICogdGhpcy5zY2FsZS55KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmF0TGltaXQueSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZpZXcueSA9IHRoaXMuYm91bmRzLnRvcCAqIHRoaXMuc2NhbGUueTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFrZS5zaGFrZUJvdW5kcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGNhbWVyYSBpcyB1cCBhZ2FpbnN0IHRoZSBib3VuZHMsIHNvIHJlc2V0IHRoZSBzaGFrZVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZoID49IHRoaXMuYm91bmRzLmJvdHRvbSAqIHRoaXMuc2NhbGUueSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hdExpbWl0LnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnkgPSAodGhpcy5ib3VuZHMuYm90dG9tICogdGhpcy5zY2FsZS55KSAtIHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWtlLnNoYWtlQm91bmRzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBUaGUgY2FtZXJhIGlzIHVwIGFnYWluc3QgdGhlIGJvdW5kcywgc28gcmVzZXQgdGhlIHNoYWtlXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2UueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FtZXJhLnByb3RvdHlwZSwge1xuXG4gICAgLy8gIFRyYW5zZm9ybSBnZXR0ZXJzIC8gc2V0dGVyc1xuXG4gICAgeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9wb3NYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3Bvc1kgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcG9zWCArICh0aGlzLnZpZXdwb3J0V2lkdGggKiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJvdHRvbToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3Bvc1kgKyAodGhpcy52aWV3cG9ydEhlaWdodCAqIHRoaXMudHJhbnNmb3JtLl9zY2FsZVkpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2NhbGU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzY2FsZVg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzY2FsZVk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9zY2FsZVk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9zY2FsZVkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwaXZvdFg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9waXZvdFggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwaXZvdFk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLl9waXZvdFk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLl9waXZvdFkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhbmdsZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKiBNQVRIX0NPTlNULlJBRF9UT19ERUcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlKHZhbHVlKSAqIE1BVEhfQ09OU1QuREVHX1RPX1JBRDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJvdGF0aW9uOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fcm90YXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24gJSBNQVRIX0NPTlNULlBJMilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMudHJhbnNmb3JtLl9yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uY2FjaGUuY3IgPSBNYXRoLmNvcyh0aGlzLnRyYW5zZm9ybS5fcm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGFzTG9jYWxSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYW1lcmEvQ2FtZXJhLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jYW1lcmEvQ2FtZXJhLmpzIiwidmFyIENIRUNLU1VNID0ge1xuYnVpbGQ6ICdiYjNmNmI5MC1kZDFiLTExZTYtOWY3Zi02OTM3Y2NhZmZjYTknXG59O1xubW9kdWxlLmV4cG9ydHMgPSBDSEVDS1NVTTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jaGVja3N1bS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFRoZSBDb2xvciBDb21wb25lbnQgYWxsb3dzIHlvdSB0byBjb250cm9sIHRoZSBhbHBoYSwgYmxlbmQgbW9kZSwgdGludCBhbmQgYmFja2dyb3VuZCBjb2xvclxuKiBvZiBhIEdhbWUgT2JqZWN0LlxuKlxuKiBAY2xhc3NcbiovXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcbntcbiAgICB0aGlzLmdhbWVPYmplY3QgPSBnYW1lT2JqZWN0O1xuXG4gICAgdGhpcy5zdGF0ZSA9IGdhbWVPYmplY3Quc3RhdGU7XG5cbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYWxwaGEgPSAxO1xuICAgIHRoaXMuX3dvcmxkQWxwaGEgPSAxO1xuXG4gICAgdGhpcy5fYmxlbmRNb2RlID0gMDtcblxuICAgIHRoaXMuX3RpbnQgPSB7IHRvcExlZnQ6IDB4ZmZmZmZmLCB0b3BSaWdodDogMHhmZmZmZmYsIGJvdHRvbUxlZnQ6IDB4ZmZmZmZmLCBib3R0b21SaWdodDogMHhmZmZmZmYgfTtcbiAgICB0aGlzLl9nbFRpbnQgPSB7IHRvcExlZnQ6IDE2Nzc3MjE1LCB0b3BSaWdodDogMTY3NzcyMTUsIGJvdHRvbUxlZnQ6IDE2Nzc3MjE1LCBib3R0b21SaWdodDogMTY3NzcyMTUgfTtcbiAgICB0aGlzLl9oYXNUaW50ID0gZmFsc2U7XG5cbiAgICAvLyAgQmV0d2VlbiAwIGFuZCAyNTVcbiAgICB0aGlzLl9yID0gMDtcbiAgICB0aGlzLl9nID0gMDtcbiAgICB0aGlzLl9iID0gMDtcblxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDFcbiAgICB0aGlzLl9hID0gMTtcblxuICAgIC8vICBTdHJpbmcgdmVyc2lvbiBvZiBSR0JBXG4gICAgdGhpcy5fcmdiYSA9ICcnO1xuXG4gICAgLy8gIDMyLWJpdCB2ZXJzaW9uIG9mIEFSR0JcbiAgICB0aGlzLl9nbEJnID0gMDtcblxuICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSBmYWxzZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yO1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRCYWNrZ3JvdW5kOiBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXG4gICAge1xuICAgICAgICBpZiAocmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yID0gcmVkO1xuICAgICAgICAgICAgdGhpcy5fZyA9IChncmVlbikgPyBncmVlbiA6IDA7XG4gICAgICAgICAgICB0aGlzLl9iID0gKGJsdWUpID8gYmx1ZSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9hID0gKGFscGhhKSA/IGFscGhhIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBjbGVhclRpbnQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnNldFRpbnQoMHhmZmZmZmYpO1xuXG4gICAgICAgIHRoaXMuX2hhc1RpbnQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgc2V0VGludDogZnVuY3Rpb24gKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcbiAgICB7XG4gICAgICAgIGlmICh0b3BSaWdodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0b3BSaWdodCA9IHRvcExlZnQ7XG4gICAgICAgICAgICBib3R0b21MZWZ0ID0gdG9wTGVmdDtcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gdG9wTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGludFRvcExlZnQgPSB0b3BMZWZ0O1xuICAgICAgICB0aGlzLnRpbnRUb3BSaWdodCA9IHRvcFJpZ2h0O1xuICAgICAgICB0aGlzLnRpbnRCb3R0b21MZWZ0ID0gYm90dG9tTGVmdDtcbiAgICAgICAgdGhpcy50aW50Qm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcblxuICAgICAgICB0aGlzLl9oYXNUaW50ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gIENhbGxlZCBieSB0aGUgRGlydHkgTWFuYWdlclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc0JhY2tncm91bmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3JnYmEgPSAncmdiYSgnICsgdGhpcy5fciArICcsJyArIHRoaXMuX2cgKyAnLCcgKyB0aGlzLl9iICsgJywnICsgdGhpcy5fYSArICcpJztcbiAgICAgICAgICAgIHRoaXMuX2dsQmcgPSB0aGlzLmdldENvbG9yMzIodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgVGludCBtdWx0cz9cblxuICAgIH0sXG5cbiAgICBnZXRDb2xvcjogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sb3IzMjogZnVuY3Rpb24gKHIsIGcsIGIsIGEpXG4gICAge1xuICAgICAgICBhICo9IDI1NTtcblxuICAgICAgICByZXR1cm4gKChhIDw8IDI0KSB8IChiIDw8IDE2KSB8IChnIDw8IDgpIHwgcikgPj4+IDA7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGludCA9IFtdO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICBkaXJ0eToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlydHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGludFRvcExlZnQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQudG9wTGVmdDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGludC50b3BMZWZ0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQudG9wTGVmdCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0aW50VG9wUmlnaHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQudG9wUmlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbnQudG9wUmlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC50b3BSaWdodCA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0aW50Qm90dG9tTGVmdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC5ib3R0b21MZWZ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aW50LmJvdHRvbUxlZnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC5ib3R0b21MZWZ0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRpbnRCb3R0b21SaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC5ib3R0b21SaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGludC5ib3R0b21SaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LmJvdHRvbVJpZ2h0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRpbnQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGludCh2YWx1ZSwgdmFsdWUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhbHBoYToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYWxwaGEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJsZW5kTW9kZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2JsZW5kTW9kZSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd29ybGRBbHBoYToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lT2JqZWN0LnBhcmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZEFscGhhID0gdGhpcy5fYWxwaGEgKiB0aGlzLmdhbWVPYmplY3QucGFyZW50LmNvbG9yLndvcmxkQWxwaGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3JsZEFscGhhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl93b3JsZEFscGhhID0gdGhpcy5fYWxwaGEgKiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJhY2tncm91bmRBbHBoYToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2EgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJlZDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3IgPSB2YWx1ZSB8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBncmVlbjoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9nKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2cgPSB2YWx1ZSB8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBibHVlOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYiA9IHZhbHVlIHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBUaGUgRGF0YSBDb21wb25lbnQgZmVhdHVyZXMgYSBtZWFucyB0byBzdG9yZSBwaWVjZXMgb2YgZGF0YSBzcGVjaWZpYyB0byBhIEdhbWUgT2JqZWN0LFxuKiBzZWFyY2ggaXQsIHF1ZXJ5IGl0LCBhbmQgcmV0cmlldmUgaXQuXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBEYXRhID0gZnVuY3Rpb24gKHBhcmVudClcbntcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMubGlzdCA9IHt9O1xuXG4gICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3MgPSB7fTtcblxuICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xufTtcblxuRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuICAgIC8vICBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV07XG4gICAgfSxcblxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdGhpcy5saXN0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgcXVlcnk6IGZ1bmN0aW9uIChzZWFyY2gpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goc2VhcmNoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZnJvemVuKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYmVmb3JlJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XG5cbiAgICAgICAgLy8gIElmIHRoZXJlIGlzIGEgJ2FmdGVyJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcblxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBzY29wZSlcbiAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZnRlcjogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHNjb3BlKVxuICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBSZW1vdmUgZW50cnlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFBhc3NlcyBhbGwgZGF0YSBlbnRyaWVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay4gU3RvcmVzIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBtZXRob2QgZWFjaFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGVdIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3VtZW50c10gLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgYWZ0ZXIgdGhlIGdhbWUgb2JqZWN0LCBrZXksIGFuZCBkYXRhLlxuICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSlcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gWyB0aGlzLnBhcmVudCwgbnVsbCwgdW5kZWZpbmVkIF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgYXJnc1sxXSA9IGtleTtcbiAgICAgICAgICAgIGFyZ3NbMl0gPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZGF0YSwgb3ZlcndyaXRlKVxuICAgIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJ3cml0ZSA9IHRydWU7IH1cblxuICAgICAgICAvLyAgTWVyZ2UgZGF0YSBmcm9tIGFub3RoZXIgY29tcG9uZW50IGludG8gdGhpcyBvbmVcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvdmVyd3JpdGUgfHwgKCFvdmVyd3JpdGUgJiYgIXRoaXMuaGFzKGtleSkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2Zyb3plbiAmJiB0aGlzLmhhcyhrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWZ0ZXJDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIEdldHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiAna2V5JywgZGVsZXRlcyBpdCBmcm9tIHRoaXMgRGF0YSBzdG9yZSwgdGhlbiByZXR1cm5zIGl0LlxuICAgIHBvcDogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdFtrZXldO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9iZWZvcmVDYWxsYmFja3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2FmdGVyQ2FsbGJhY2tzKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0YS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogRnJlZXplIHRoaXMgRGF0YSBjb21wb25lbnQsIHNvIG5vIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gdG8gaXQuXG4gICAgKlxuICAgICogQG5hbWUgZnJlZXplXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZyZWV6ZVxuICAgICovXG4gICAgZnJlZXplOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm96ZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb3plbiA9ICh2YWx1ZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb3VudDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL21hdGgvY29uc3QnKTtcbnZhciBXcmFwQW5nbGUgPSByZXF1aXJlKCcuLi9tYXRoL2FuZ2xlL1dyYXAnKTtcblxuLyoqXG4qIDJEIFRyYW5zZm9ybWF0aW9uIENvbXBvbmVudC5cbipcbiogQGNsYXNzXG4qL1xudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCB4LCB5LCBzY2FsZVgsIHNjYWxlWSlcbntcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxuICAgIGlmIChzY2FsZVggPT09IHVuZGVmaW5lZCkgeyBzY2FsZVggPSAxOyB9XG4gICAgaWYgKHNjYWxlWSA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlWSA9IDE7IH1cblxuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XG5cbiAgICB0aGlzLnN0YXRlID0gKGdhbWVPYmplY3Quc3RhdGUpID8gZ2FtZU9iamVjdC5zdGF0ZSA6IGdhbWVPYmplY3QucGFyZW50LnN0YXRlO1xuXG4gICAgdGhpcy5nYW1lID0gdGhpcy5zdGF0ZS5nYW1lO1xuXG4gICAgLy8gIGEgPSBzY2FsZSBYXG4gICAgLy8gIGIgPSBzaGVhciBZXG4gICAgLy8gIGMgPSBzaGVhciBYXG4gICAgLy8gIGQgPSBzY2FsZSBZXG4gICAgLy8gIHR4IC8gdHkgPSB0cmFuc2xhdGlvblxuXG4gICAgLy8gIFdvcmxkIFRyYW5zZm9ybVxuICAgIHRoaXMud29ybGQgPSB7IGE6IHNjYWxlWCwgYjogMCwgYzogMCwgZDogc2NhbGVZLCB0eDogeCwgdHk6IHkgfTtcblxuICAgIC8vICBQcmV2aW91cyBUcmFuc2Zvcm0gKHVzZWQgZm9yIGludGVycG9sYXRpb24pXG4gICAgdGhpcy5vbGQgPSB7IGE6IHNjYWxlWCwgYjogMCwgYzogMCwgZDogc2NhbGVZLCB0eDogeCwgdHk6IHkgfTtcblxuICAgIC8vICBDYWNoZWQgVHJhbnNmb3JtIENhbGN1bGF0aW9uc1xuICAgIHRoaXMuY2FjaGUgPSB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHNyOiAwLCBjcjogMCB9O1xuXG4gICAgLy8gIEdMIFZlcnRleCBEYXRhXG4gICAgdGhpcy5nbFZlcnRleHREYXRhID0geyB4MDogMCwgeTA6IDAsIHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAwLCB4MzogMCwgeTM6IDAgfTtcblxuICAgIC8vICBDYW52YXMgU2V0VHJhbnNmb3JtIGRhdGFcbiAgICB0aGlzLmNhbnZhc0RhdGEgPSB7IGE6IDEsIGI6IDAsIGM6IDAsIGQ6IDEsIHR4OiAwLCB0eTogMCwgZHg6IDAsIGR5OiAwIH07XG5cbiAgICB0aGlzLmltbWVkaWF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5oYXNMb2NhbFJvdGF0aW9uID0gZmFsc2U7XG5cbiAgICAvLyAgUHJpdmF0ZSB2YWx1ZSBob2xkZXJzLCBhY2Nlc3NlZCB2aWEgdGhlIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICB0aGlzLl9wb3NYID0geDtcbiAgICB0aGlzLl9wb3NZID0geTtcbiAgICB0aGlzLl9zY2FsZVggPSBzY2FsZVg7XG4gICAgdGhpcy5fc2NhbGVZID0gc2NhbGVZO1xuICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgICB0aGlzLl9waXZvdFggPSAwO1xuICAgIHRoaXMuX3Bpdm90WSA9IDA7XG4gICAgdGhpcy5fYW5jaG9yWCA9IDA7XG4gICAgdGhpcy5fYW5jaG9yWSA9IDA7XG5cbiAgICB0aGlzLl93b3JsZFJvdGF0aW9uID0gMDtcbiAgICB0aGlzLl93b3JsZFNjYWxlWCA9IHNjYWxlWDtcbiAgICB0aGlzLl93b3JsZFNjYWxlWSA9IHNjYWxlWTtcblxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9kaXJ0eVZlcnRleCA9IHRydWU7XG5cbiAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLmFkZCh0aGlzKTtcblxuICAgIC8vICBUaGUgcGFyZW50IFRyYW5zZm9ybSAoTk9UIHRoZSBwYXJlbnQgR2FtZU9iamVjdCwgYWx0aG91Z2ggdmVyeSBvZnRlbiB0aGV5IGFyZSByZWxhdGVkKVxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8vICBBbnkgY2hpbGQgVHJhbnNmb3JtcyBvZiB0aGlzIG9uZSAtIG5vdGUgdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gYmVsb25nIHRvIEdhbWUgT2JqZWN0c1xuICAgIC8vICB0aGF0IGFyZSBjaGlsZHJlbiBvZiB0aGUgb3duZXIgb2YgdGhpcyBUcmFuc2Zvcm1cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtO1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRBdChjaGlsZCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICBhZGRBdDogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcbiAgICB7XG4gICAgICAgIC8vICBJbnZhbGlkIGNoaWxkP1xuICAgICAgICBpZiAoY2hpbGQgPT09IHRoaXMgfHwgY2hpbGQucGFyZW50ID09PSB0aGlzIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBjaGlsZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIENoaWxkIGFscmVhZHkgcGFyZW50ZWQ/IFJlbW92ZSBpdFxuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICAvLyAgSW52YWxpZCBjaGlsZD9cbiAgICAgICAgaWYgKGNoaWxkID09PSB0aGlzIHx8IGNoaWxkLnBhcmVudCAhPT0gdGhpcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChpbmRleClcbiAgICB7XG4gICAgICAgIC8vICBWYWxpZCBpbmRleD9cbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRbMF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hpbGRbMF0ucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmFibGVJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5zeW5jSW50ZXJwb2xhdGlvbigpO1xuICAgIH0sXG5cbiAgICBzeW5jSW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcblxuICAgICAgICBvbGQuYSA9IHdvcmxkLmE7XG4gICAgICAgIG9sZC5iID0gd29ybGQuYjtcbiAgICAgICAgb2xkLmMgPSB3b3JsZC5jO1xuICAgICAgICBvbGQuZCA9IHdvcmxkLmQ7XG4gICAgICAgIG9sZC50eCA9IHdvcmxkLnR4O1xuICAgICAgICBvbGQudHkgPSB3b3JsZC50eTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZUludGVycG9sYXRpb246IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmludGVycG9sYXRlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLl9wb3NYID0geDtcbiAgICAgICAgdGhpcy5fcG9zWSA9IHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLl9zY2FsZVggPSB4O1xuICAgICAgICB0aGlzLl9zY2FsZVkgPSB5O1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHNldFBpdm90OiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLl9waXZvdFggPSB4O1xuICAgICAgICB0aGlzLl9waXZvdFkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRBbmNob3I6IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxuXG4gICAgICAgIHRoaXMuX2FuY2hvclggPSB4O1xuICAgICAgICB0aGlzLl9hbmNob3JZID0geTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbilcbiAgICB7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gIFVwZGF0ZXMgdGhlIFRyYW5zZm9ybS53b3JsZCBvYmplY3QsIHJlYWR5IGZvciByZW5kZXJpbmdcbiAgICAvLyAgQXNzdW1pbmcgdGhpcyBUcmFuc2Zvcm0gaXMgYSByb290IG5vZGUgKGkuZS4gbm8gdHJhbnNmb3JtIHBhcmVudClcbiAgICB1cGRhdGVGcm9tUm9vdDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcblxuICAgICAgICBvbGQuYSA9IHdvcmxkLmE7XG4gICAgICAgIG9sZC5iID0gd29ybGQuYjtcbiAgICAgICAgb2xkLmMgPSB3b3JsZC5jO1xuICAgICAgICBvbGQuZCA9IHdvcmxkLmQ7XG4gICAgICAgIG9sZC50eCA9IHdvcmxkLnR4O1xuICAgICAgICBvbGQudHkgPSB3b3JsZC50eTtcblxuICAgICAgICBpZiAodGhpcy5oYXNMb2NhbFJvdGF0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVJvb3QnKTtcblxuICAgICAgICAgICAgd29ybGQuYSA9IHRoaXMuY2FjaGUuYTtcbiAgICAgICAgICAgIHdvcmxkLmIgPSB0aGlzLmNhY2hlLmI7XG4gICAgICAgICAgICB3b3JsZC5jID0gdGhpcy5jYWNoZS5jO1xuICAgICAgICAgICAgd29ybGQuZCA9IHRoaXMuY2FjaGUuZDtcbiAgICAgICAgICAgIHdvcmxkLnR4ID0gdGhpcy5fcG9zWCAtICgodGhpcy5fcGl2b3RYICogdGhpcy5jYWNoZS5hKSArICh0aGlzLl9waXZvdFkgKiB0aGlzLmNhY2hlLmMpKTtcbiAgICAgICAgICAgIHdvcmxkLnR5ID0gdGhpcy5fcG9zWSAtICgodGhpcy5fcGl2b3RYICogdGhpcy5jYWNoZS5iKSArICh0aGlzLl9waXZvdFkgKiB0aGlzLmNhY2hlLmQpKTtcblxuICAgICAgICAgICAgdGhpcy5fd29ybGRSb3RhdGlvbiA9IE1hdGguYXRhbjIoLXRoaXMuY2FjaGUuYywgdGhpcy5jYWNoZS5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVGcm9tUm9vdCBGQVNUJyk7XG5cbiAgICAgICAgICAgIHdvcmxkLmEgPSB0aGlzLl9zY2FsZVg7XG4gICAgICAgICAgICB3b3JsZC5iID0gMDtcbiAgICAgICAgICAgIHdvcmxkLmMgPSAwO1xuICAgICAgICAgICAgd29ybGQuZCA9IHRoaXMuX3NjYWxlWTtcbiAgICAgICAgICAgIHdvcmxkLnR4ID0gdGhpcy5fcG9zWCAtICh0aGlzLl9waXZvdFggKiB0aGlzLl9zY2FsZVgpO1xuICAgICAgICAgICAgd29ybGQudHkgPSB0aGlzLl9wb3NZIC0gKHRoaXMuX3Bpdm90WSAqIHRoaXMuX3NjYWxlWSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUm90YXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd29ybGRTY2FsZVggPSB0aGlzLl9zY2FsZVg7XG4gICAgICAgIHRoaXMuX3dvcmxkU2NhbGVZID0gdGhpcy5fc2NhbGVZO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1cGRhdGVGcm9tUGFyZW50OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMub2xkO1xuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xuXG4gICAgICAgIG9sZC5hID0gd29ybGQuYTtcbiAgICAgICAgb2xkLmIgPSB3b3JsZC5iO1xuICAgICAgICBvbGQuYyA9IHdvcmxkLmM7XG4gICAgICAgIG9sZC5kID0gd29ybGQuZDtcbiAgICAgICAgb2xkLnR4ID0gd29ybGQudHg7XG4gICAgICAgIG9sZC50eSA9IHdvcmxkLnR5O1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudC53b3JsZDtcbiAgICAgICAgdmFyIHR4ID0gMDtcbiAgICAgICAgdmFyIHR5ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5oYXNMb2NhbFJvdGF0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVBhcmVudCcsIHRoaXMucGFyZW50Lm5hbWUpO1xuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2FjaGUuYTtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5jYWNoZS5iO1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNhY2hlLmM7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY2FjaGUuZDtcblxuICAgICAgICAgICAgdHggPSB0aGlzLl9wb3NYIC0gKCh0aGlzLl9waXZvdFggKiBhKSArICh0aGlzLl9waXZvdFkgKiBjKSk7XG4gICAgICAgICAgICB0eSA9IHRoaXMuX3Bvc1kgLSAoKHRoaXMuX3Bpdm90WCAqIGIpICsgKHRoaXMuX3Bpdm90WSAqIGQpKTtcblxuICAgICAgICAgICAgd29ybGQuYSA9IChhICogcGFyZW50LmEpICsgKGIgKiBwYXJlbnQuYyk7XG4gICAgICAgICAgICB3b3JsZC5iID0gKGEgKiBwYXJlbnQuYikgKyAoYiAqIHBhcmVudC5kKTtcbiAgICAgICAgICAgIHdvcmxkLmMgPSAoYyAqIHBhcmVudC5hKSArIChkICogcGFyZW50LmMpO1xuICAgICAgICAgICAgd29ybGQuZCA9IChjICogcGFyZW50LmIpICsgKGQgKiBwYXJlbnQuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlRnJvbVBhcmVudCBGQVNUJywgdGhpcy5wYXJlbnQubmFtZSk7XG5cbiAgICAgICAgICAgIHR4ID0gdGhpcy5fcG9zWCAtICh0aGlzLl9waXZvdFggKiB0aGlzLl9zY2FsZVgpO1xuICAgICAgICAgICAgdHkgPSB0aGlzLl9wb3NZIC0gKHRoaXMuX3Bpdm90WSAqIHRoaXMuX3NjYWxlWSk7XG5cbiAgICAgICAgICAgIHdvcmxkLmEgPSB0aGlzLl9zY2FsZVggKiBwYXJlbnQuYTtcbiAgICAgICAgICAgIHdvcmxkLmIgPSB0aGlzLl9zY2FsZVggKiBwYXJlbnQuYjtcbiAgICAgICAgICAgIHdvcmxkLmMgPSB0aGlzLl9zY2FsZVkgKiBwYXJlbnQuYztcbiAgICAgICAgICAgIHdvcmxkLmQgPSB0aGlzLl9zY2FsZVkgKiBwYXJlbnQuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dvcmxkUm90YXRpb24gPSBNYXRoLmF0YW4yKC10aGlzLndvcmxkLmMsIHRoaXMud29ybGQuZCk7XG5cbiAgICAgICAgd29ybGQudHggPSAodHggKiBwYXJlbnQuYSkgKyAodHkgKiBwYXJlbnQuYykgKyBwYXJlbnQudHg7XG4gICAgICAgIHdvcmxkLnR5ID0gKHR4ICogcGFyZW50LmIpICsgKHR5ICogcGFyZW50LmQpICsgcGFyZW50LnR5O1xuXG4gICAgICAgIHRoaXMuX3dvcmxkU2NhbGVYID0gdGhpcy5fc2NhbGVYICogTWF0aC5zcXJ0KCh3b3JsZC5hICogd29ybGQuYSkgKyAod29ybGQuYyAqIHdvcmxkLmMpKTtcbiAgICAgICAgdGhpcy5fd29ybGRTY2FsZVkgPSB0aGlzLl9zY2FsZVkgKiBNYXRoLnNxcnQoKHdvcmxkLmIgKiB3b3JsZC5iKSArICh3b3JsZC5kICogd29ybGQuZCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1cGRhdGVBbmNlc3RvcnM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdUcmFuc2Zvcm0udXBkYXRlQW5jZXN0b3JzJyk7XG5cbiAgICAgICAgLy8gIE5vIHBhcmVudD8gVGhlbiBqdXN0IHVwZGF0ZSB0aGUgY2hpbGRyZW4gYW5kIGxlYXZlLCBvdXIgam9iIGlzIGRvbmVcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLCAndXBkYXRlQW5jZXN0b3JzIGhhcyBubyBwYXJlbnQgVHJhbnNmb3JtJyk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVJvb3QoKTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbigpO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLCAnc3RhcnQgdXBkYXRlQW5jZXN0b3JzIHdoaWxlJyk7XG5cbiAgICAgICAgLy8gIEdldHMgYWxsIHBhcmVudCBub2Rlcywgc3RhcnRpbmcgZnJvbSB0aGlzIFRyYW5zZm9ybS5cbiAgICAgICAgLy8gIFRoZW4gdXBkYXRlcyBmcm9tIHRoZSB0b3AsIGRvd24sIGJ1dCBvbmx5IG9uIHRoZSBhbmNlc3RvcnMsXG4gICAgICAgIC8vICBub3QgYW55IG90aGVyIGNoaWxkcmVuIC0gd2lsbCBnaXZlIHVzIGFjY3VyYXRlIHdvcmxkWCBldGMgcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgICAgIGRvXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUpO1xuXG4gICAgICAgIC8vICBXZSd2ZSBnb3QgYWxsIHRoZSBhbmNlc3RvcnMgaW4gdGhlICdub2RlcycgYXJyYXksIGxldCdzIGxvb3AgaXRcblxuICAgICAgICB3aGlsZSAobm9kZXMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXMucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUZyb21Sb290KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQnkgdGhpcyBwb2ludCBhbGwgb2YgdGhpcyBUcmFuc2Zvcm1zIGFuY2VzdG9ycyBoYXZlIGJlZW5cbiAgICAgICAgLy8gIHVwZGF0ZWQsIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzbyB3ZSBjYW4gbm93IGRvIHRoaXMgb25lXG4gICAgICAgIC8vICBhbmQgYW55IG9mIGl0cyBjaGlsZHJlbiB0b29cblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSwgJ1RyYW5zZm9ybS51cGRhdGVDaGlsZHJlbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVGcm9tRGlydHlQYXJlbnQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsICdpcyB1cGRhdGVGcm9tRGlydHlQYXJlbnQnLCB0aGlzLnBhcmVudC5uYW1lKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUZyb21QYXJlbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZUZyb21EaXJ0eVBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlydHlWZXJ0ZXggPSB0cnVlO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gdGhpcyBUcmFuc2Zvcm0gaXMgZGlydHlcbiAgICAgICAgLy8gIHNvIHdlIG5lZWQgdG8gdXBkYXRlIGl0IGZyb20gaXRzIHBhcmVudFxuICAgICAgICAvLyAgYW5kIHRoZW4gZm9yY2UgdGhlIHVwZGF0ZSB0byBhbGwgY2hpbGRyZW5cblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUm9vdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVGcm9tRGlydHlQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmNhY2hlLmEgPSB0aGlzLmNhY2hlLmNyICogdGhpcy5fc2NhbGVYO1xuICAgICAgICB0aGlzLmNhY2hlLmIgPSB0aGlzLmNhY2hlLnNyICogdGhpcy5fc2NhbGVYO1xuICAgICAgICB0aGlzLmNhY2hlLmMgPSAtdGhpcy5jYWNoZS5zciAqIHRoaXMuX3NjYWxlWTtcbiAgICAgICAgdGhpcy5jYWNoZS5kID0gdGhpcy5jYWNoZS5jciAqIHRoaXMuX3NjYWxlWTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmVydGV4RGF0YTogZnVuY3Rpb24gKGludGVycG9sYXRpb25QZXJjZW50YWdlLCByZW5kZXJlcilcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5nYW1lT2JqZWN0LmZyYW1lIHx8ICghdGhpcy5fZGlydHlWZXJ0ZXggJiYgIXRoaXMuaW50ZXJwb2xhdGUpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmdhbWVPYmplY3QuZnJhbWU7XG5cbiAgICAgICAgdmFyIHcwO1xuICAgICAgICB2YXIgaDA7XG4gICAgICAgIHZhciB3MTtcbiAgICAgICAgdmFyIGgxO1xuXG4gICAgICAgIGlmIChmcmFtZS5kYXRhLnRyaW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBJZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQsIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZ1xuICAgICAgICAgICAgdzEgPSBmcmFtZS54IC0gKHRoaXMuX2FuY2hvclggKiBmcmFtZS53aWR0aCk7XG4gICAgICAgICAgICB3MCA9IHcxICsgZnJhbWUuY3V0V2lkdGg7XG5cbiAgICAgICAgICAgIGgxID0gZnJhbWUueSAtICh0aGlzLl9hbmNob3JZICogZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgICAgIGgwID0gaDEgKyBmcmFtZS5jdXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3MCA9IGZyYW1lLmN1dFdpZHRoICogKDEgLSB0aGlzLl9hbmNob3JYKTtcbiAgICAgICAgICAgIHcxID0gZnJhbWUuY3V0V2lkdGggKiAtdGhpcy5fYW5jaG9yWDtcblxuICAgICAgICAgICAgaDAgPSBmcmFtZS5jdXRIZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvclkpO1xuICAgICAgICAgICAgaDEgPSBmcmFtZS5jdXRIZWlnaHQgKiAtdGhpcy5fYW5jaG9yWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gZnJhbWUuc291cmNlLnJlc29sdXRpb247XG5cbiAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZDtcblxuICAgICAgICB2YXIgYSA9IHd0LmEgLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgYiA9IHd0LmIgLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgYyA9IHd0LmMgLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgZCA9IHd0LmQgLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgdHggPSB3dC50eDtcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLm9sZDtcblxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgd2l0aCB0aGUgbGFzdCBwb3NpdGlvbiB0byByZWR1Y2Ugc3R1dHRlcmluZy5cbiAgICAgICAgICAgIGEgPSBvbGQuYSArICgoYSAtIG9sZC5hKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGIgPSBvbGQuYiArICgoYiAtIG9sZC5iKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGMgPSBvbGQuYyArICgoYyAtIG9sZC5jKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGQgPSBvbGQuZCArICgoZCAtIG9sZC5kKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIHR4ID0gb2xkLnR4ICsgKCh0eCAtIG9sZC50eCkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XG4gICAgICAgICAgICB0eSA9IG9sZC50eSArICgodHkgLSBvbGQudHkpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYW1lLnJvdGF0ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHZhciBjdyA9IGZyYW1lLmN1dFdpZHRoO1xuICAgICAgICAgICAgdmFyIGNoID0gZnJhbWUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGEwID0gYTtcbiAgICAgICAgICAgIHZhciBiMCA9IGI7XG4gICAgICAgICAgICB2YXIgYzAgPSBjO1xuICAgICAgICAgICAgdmFyIGQwID0gZDtcbiAgICAgICAgICAgIHZhciBfdzEgPSB3MTtcbiAgICAgICAgICAgIHZhciBfdzAgPSB3MDtcblxuICAgICAgICAgICAgLy8gIE9mZnNldCBiZWZvcmUgcm90YXRpbmdcbiAgICAgICAgICAgIHR4ID0gKHd0LmMgKiBjaCkgKyB0eDtcbiAgICAgICAgICAgIHR5ID0gKHd0LmQgKiBjaCkgKyB0eTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gIFJvdGF0ZSBtYXRyaXggYnkgOTAgZGVncmVlcyB3aXRoIHByZWNhbGMgdmFsdWVzIGZvciBzaW5lIGFuZCBjb3NpbmUgb2YgcmFkKDkwKVxuICAgICAgICAgICAgYSA9IChhMCAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNykgKyAtYzA7XG4gICAgICAgICAgICBiID0gKGIwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3KSArIC1kMDtcbiAgICAgICAgICAgIGMgPSBhMCArIChjMCAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNyk7XG4gICAgICAgICAgICBkID0gYjAgKyAoZDAgKiA2LjEyMzIzMzk5NTczNjc2NmUtMTcpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgVVYgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZVVWc0ludmVydGVkKCk7XG5cbiAgICAgICAgICAgIC8vIFJvdGF0ZSBkaW1lbnNpb25zXG4gICAgICAgICAgICB3MCA9IGgwO1xuICAgICAgICAgICAgdzEgPSBoMTtcbiAgICAgICAgICAgIGgwID0gX3cwO1xuICAgICAgICAgICAgaDEgPSBfdzE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhbWUuYXV0b1JvdW5kID09PSAxIHx8IChmcmFtZS5hdXRvUm91bmQgPT09IC0xICYmIHJlbmRlcmVyLnJvdW5kUGl4ZWxzKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdHggfD0gMDtcbiAgICAgICAgICAgIHR5IHw9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydCA9IHRoaXMuZ2xWZXJ0ZXh0RGF0YTtcblxuICAgICAgICAvLyAgVG9wIExlZnQgVmVydFxuICAgICAgICB2ZXJ0LngwID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0LnkwID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xuXG4gICAgICAgIC8vICBUb3AgUmlnaHQgVmVydFxuICAgICAgICB2ZXJ0LngxID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0LnkxID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xuXG4gICAgICAgIC8vICBCb3R0b20gUmlnaHQgVmVydFxuICAgICAgICB2ZXJ0LngyID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0LnkyID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xuXG4gICAgICAgIC8vICBCb3R0b20gTGVmdCBWZXJ0XG4gICAgICAgIHZlcnQueDMgPSAoYSAqIHcxKSArIChjICogaDApICsgdHg7XG4gICAgICAgIHZlcnQueTMgPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdmVydDtcbiAgICB9LFxuXG4gICAgZ2V0VmVydGV4RGF0YTogZnVuY3Rpb24gKGludGVycG9sYXRpb25QZXJjZW50YWdlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGUgfHwgdGhpcy5fZGlydHlWZXJ0ZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmVydGV4RGF0YShpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RpcnR5VmVydGV4ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nbFZlcnRleHREYXRhO1xuICAgIH0sXG5cbiAgICBjbG9uZVZlcnRleERhdGE6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgc3JjID0gdGhpcy5nbFZlcnRleHREYXRhO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MDogc3JjLngwLFxuICAgICAgICAgICAgeTA6IHNyYy55MCxcbiAgICAgICAgICAgIHgxOiBzcmMueDEsXG4gICAgICAgICAgICB5MTogc3JjLnkxLFxuICAgICAgICAgICAgeDI6IHNyYy54MixcbiAgICAgICAgICAgIHkyOiBzcmMueTIsXG4gICAgICAgICAgICB4Mzogc3JjLngzLFxuICAgICAgICAgICAgeTM6IHNyYy55M1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDYW52YXNUcmFuc2Zvcm1EYXRhOiBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIHJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5nYW1lT2JqZWN0LmZyYW1lO1xuXG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5vbGQ7XG5cbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHdpdGggdGhlIGxhc3QgcG9zaXRpb24gdG8gcmVkdWNlIHN0dXR0ZXJpbmcuXG4gICAgICAgICAgICBkYXRhLmEgPSBvbGQuYSArICgod29ybGQuYSAtIG9sZC5hKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGRhdGEuYiA9IG9sZC5iICsgKCh3b3JsZC5iIC0gb2xkLmIpICogaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgZGF0YS5jID0gb2xkLmMgKyAoKHdvcmxkLmMgLSBvbGQuYykgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XG4gICAgICAgICAgICBkYXRhLmQgPSBvbGQuZCArICgod29ybGQuZCAtIG9sZC5kKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGRhdGEudHggPSBvbGQudHggKyAoKHdvcmxkLnR4IC0gb2xkLnR4KSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGRhdGEudHkgPSBvbGQudHkgKyAoKHdvcmxkLnR5IC0gb2xkLnR5KSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGRhdGEuZHggPSBvbGQuZHggKyAoKGZyYW1lLnggLSAodGhpcy5hbmNob3JYICogZnJhbWUud2lkdGgpKSAqIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgICAgIGRhdGEuZHkgPSBvbGQuZHkgKyAoKGZyYW1lLnkgLSAodGhpcy5hbmNob3JZICogZnJhbWUuaGVpZ2h0KSkgKiBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgQ29weSBvdmVyIHRoZSB2YWx1ZXMgdG8gdGhlIGNhbnZhc0RhdGEgb2JqZWN0LCBpbiBjYXNlIHRoZSByZW5kZXJlciBuZWVkcyB0byBhZGp1c3QgdGhlbVxuICAgICAgICAgICAgZGF0YS5hID0gd29ybGQuYTtcbiAgICAgICAgICAgIGRhdGEuYiA9IHdvcmxkLmI7XG4gICAgICAgICAgICBkYXRhLmMgPSB3b3JsZC5jO1xuICAgICAgICAgICAgZGF0YS5kID0gd29ybGQuZDtcbiAgICAgICAgICAgIGRhdGEudHggPSB3b3JsZC50eDtcbiAgICAgICAgICAgIGRhdGEudHkgPSB3b3JsZC50eTtcbiAgICAgICAgICAgIGRhdGEuZHggPSBmcmFtZS54IC0gKHRoaXMuYW5jaG9yWCAqIGZyYW1lLndpZHRoKTtcbiAgICAgICAgICAgIGRhdGEuZHkgPSBmcmFtZS55IC0gKHRoaXMuYW5jaG9yWSAqIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhbWUuYXV0b1JvdW5kID09PSAxIHx8IChmcmFtZS5hdXRvUm91bmQgPT09IC0xICYmIHJlbmRlcmVyLnJvdW5kUGl4ZWxzKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YS50eCB8PSAwO1xuICAgICAgICAgICAgZGF0YS50eSB8PSAwO1xuICAgICAgICAgICAgZGF0YS5keCB8PSAwO1xuICAgICAgICAgICAgZGF0YS5keSB8PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm0ucHJvdG90eXBlLCB7XG5cbiAgICAvLyAgVHJhbnNmb3JtIGdldHRlcnMgLyBzZXR0ZXJzXG5cbiAgICB4OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NYO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9wb3NYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1k7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc1kgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2NhbGU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZVkgPSB2YWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzY2FsZVg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2NhbGVZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWSA9IHZhbHVlO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFuY2hvcjoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRBbmNob3IodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYW5jaG9yWDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yWCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhbmNob3JZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JZO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JZID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHBpdm90WDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RYO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcGl2b3RZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waXZvdFk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhbmdsZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKiBNQVRIX0NPTlNULlJBRF9UT19ERUcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlKHZhbHVlKSAqIE1BVEhfQ09OU1QuREVHX1RPX1JBRDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJvdGF0aW9uOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uICUgTUFUSF9DT05TVC5QSTIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zciA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmNyID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0xvY2FsUm90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzTG9jYWxSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gIFNldHMgdGhpcyAqY29tcG9uZW50KiBhcyBiZWluZyBkaXJ0eVxuICAgIGRpcnR5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1tZWRpYXRlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHlWZXJ0ZXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlcy5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vICBHTE9CQUwgcmVhZC1vbmx5IHByb3BlcnRpZXMgZnJvbSBoZXJlIG9uXG4gICAgLy8gIE5lZWQgKmFsbCogcGFyZW50cyB0YWtlbiBpbnRvIGFjY291bnQgdG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlc1xuXG4gICAgbmFtZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZ2FtZU9iamVjdCkgPyB0aGlzLmdhbWVPYmplY3QubmFtZSA6ICcnO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgd29ybGRSb3RhdGlvbjoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRSb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdvcmxkU2NhbGVYOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3JsZFNjYWxlWDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdvcmxkU2NhbGVZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5jZXN0b3JzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3JsZFNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdvcmxkWDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3JsZC50eDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHdvcmxkWToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2VzdG9ycygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3JsZC50eTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xuXG52YXIgQXVkaW8gPSB7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXVkaW9EYXRhIC0gQXJlIEF1ZGlvIHRhZ3MgYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGF1ZGlvRGF0YTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViQXVkaW8gLSBJcyB0aGUgV2ViQXVkaW8gQVBJIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3ZWJBdWRpbzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2dnIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG9nZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B1cyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9wdXMgZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgb3B1czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXAzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbXAzIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG1wMzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2F2IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2F2IGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdhdjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIENhbiB0aGlzIGRldmljZSBwbGF5IG00YSBmaWxlcz9cbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbTRhIC0gVHJ1ZSBpZiB0aGlzIGRldmljZSBjYW4gcGxheSBtNGEgZmlsZXMuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbTRhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJtIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgd2VibSBmaWxlcz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3ZWJtOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBkb2xieSAtIENhbiB0aGlzIGRldmljZSBwbGF5IEVDLTMgRG9sYnkgRGlnaXRhbCBQbHVzIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGRvbGJ5OiBmYWxzZVxuXG59O1xuXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgQXVkaW8uYXVkaW9EYXRhID0gISEod2luZG93WydBdWRpbyddKTtcbiAgICBBdWRpby53ZWJBdWRpbyA9ICEhKHdpbmRvd1snQXVkaW9Db250ZXh0J10gfHwgd2luZG93Wyd3ZWJraXRBdWRpb0NvbnRleHQnXSk7XG5cbiAgICB2YXIgYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcblxuICAgIHZhciByZXN1bHQgPSAhIWF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZTtcblxuICAgIHRyeVxuICAgIHtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ub2dnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJvcHVzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpIHx8IGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vb3B1czsnKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEF1ZGlvLm9wdXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ubXAzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIE1pbWV0eXBlcyBhY2NlcHRlZDpcbiAgICAgICAgICAgIC8vICBkZXZlbG9wZXIubW96aWxsYS5vcmcvRW4vTWVkaWFfZm9ybWF0c19zdXBwb3J0ZWRfYnlfdGhlX2F1ZGlvX2FuZF92aWRlb19lbGVtZW50c1xuICAgICAgICAgICAgLy8gIGJpdC5seS9pcGhvbmVvc2NvZGVjc1xuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEF1ZGlvLndhdiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtbTRhOycpIHx8IGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ubTRhID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8vd2VibTsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEF1ZGlvLndlYm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7Y29kZWNzPVwiZWMtM1wiJykgIT09ICcnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChCcm93c2VyLmVkZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBBdWRpby5kb2xieSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIuc2FmYXJpVmVyc2lvbiA+PSA5KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgvTWFjIE9TIFggKFxcZCspXyhcXGQrKS8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYWpvciA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbm9yID0gcGFyc2VJbnQoUmVnRXhwLiQyLCAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWFqb3IgPT09IDEwICYmIG1pbm9yID49IDExKSB8fCBtYWpvciA+IDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvIGhlcmVcbiAgICB9XG5cbiAgICByZXR1cm4gQXVkaW87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0F1ZGlvLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQXVkaW8uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xuXG52YXIgRnVsbHNjcmVlbiA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdmFpbGFibGUgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgdGhlIEZ1bGwgU2NyZWVuIEFQST9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBhdmFpbGFibGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gcmVxdWVzdCAtIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBGdWxsIFNjcmVlbiBBUEkgdGhpcyBob2xkcyB0aGUgY2FsbCB5b3UgbmVlZCB0byB1c2UgdG8gYWN0aXZhdGUgaXQuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgcmVxdWVzdDogJycsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYW5jZWwgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGNhbmNlbCBpdC5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjYW5jZWw6ICcnLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGtleWJvYXJkIC0gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFjY2VzcyB0byB0aGUgS2V5Ym9hcmQgZHVyaW5nIEZ1bGwgU2NyZWVuIG1vZGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAga2V5Ym9hcmQ6IGZhbHNlXG5cbn07XG5cbi8qKlxuKiBDaGVja3MgZm9yIHN1cHBvcnQgb2YgdGhlIEZ1bGwgU2NyZWVuIEFQSS5cbiovXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgdmFyIGZzID0gW1xuICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAncmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgICAgICdtc1JlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21velJlcXVlc3RGdWxsc2NyZWVuJ1xuICAgIF07XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChlbGVtZW50W2ZzW2ldXSlcbiAgICAgICAge1xuICAgICAgICAgICAgRnVsbHNjcmVlbi5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgRnVsbHNjcmVlbi5yZXF1ZXN0ID0gZnNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZnMgPSBbXG4gICAgICAgICdjYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgJ2V4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICAgICAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnbXNDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgICAgICdtb3pFeGl0RnVsbHNjcmVlbidcbiAgICBdO1xuXG4gICAgaWYgKEZ1bGxzY3JlZW4uYXZhaWxhYmxlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtjZnNbaV1dKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEZ1bGxzY3JlZW4uY2FuY2VsID0gY2ZzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gIEtleWJvYXJkIElucHV0P1xuICAgIGlmICh3aW5kb3dbJ0VsZW1lbnQnXSAmJiBFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKVxuICAgIHtcbiAgICAgICAgRnVsbHNjcmVlbi5rZXlib2FyZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZ1bGxzY3JlZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0Z1bGxzY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcblxudmFyIElucHV0ID0ge1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHRvdWNoIC0gSXMgdG91Y2ggYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRvdWNoOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtc3BvaW50ZXIgLSBJcyBtc3BvaW50ZXIgYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG1zcG9pbnRlcjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gd2hlZWxUeXBlIC0gVGhlIG5ld2VzdCB0eXBlIG9mIFdoZWVsL1Njcm9sbCBldmVudCBzdXBwb3J0ZWQ6ICd3aGVlbCcsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJ1xuICAgICogQGRlZmF1bHRcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICAgIHdoZWVsRXZlbnQ6IG51bGxcbiAgICBcbn07XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8ICh3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPj0gMSkpXG4gICAge1xuICAgICAgICBJbnB1dC50b3VjaCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCB8fCB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKVxuICAgIHtcbiAgICAgICAgSW5wdXQubXNwb2ludGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIU9TLmNvY29vbkpTKVxuICAgIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbFxuICAgICAgICBpZiAoJ29ud2hlZWwnIGluIHdpbmRvdyB8fCAoQnJvd3Nlci5pZSAmJiAnV2hlZWxFdmVudCcgaW4gd2luZG93KSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gRE9NMyBXaGVlbCBFdmVudDogRkYgMTcrLCBJRSA5KywgQ2hyb21lIDMxKywgU2FmYXJpIDcrXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ3doZWVsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnb25tb3VzZXdoZWVsJyBpbiB3aW5kb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5vbi1GRiBsZWdhY3k6IElFIDYtOSwgQ2hyb21lIDEtMzEsIFNhZmFyaSA1LTcuXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ21vdXNld2hlZWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXIuZmlyZWZveCAmJiAnTW91c2VTY3JvbGxFdmVudCcgaW4gd2luZG93KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBGRiBwcmlvciB0byAxNy4gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgc2NydWJiZWQuXG4gICAgICAgICAgICBJbnB1dC53aGVlbEV2ZW50ID0gJ0RPTU1vdXNlU2Nyb2xsJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnB1dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvSW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9JbnB1dC5qcyIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XG5cbnZhciBWaWRlbyA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvZ2dWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IG9nZyB2aWRlbyBmaWxlcz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBvZ2dWaWRlbzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaDI2NFZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgaDI2NCBtcDQgdmlkZW8gZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgaDI2NFZpZGVvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtcDRWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IGgyNjQgbXA0IHZpZGVvIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG1wNFZpZGVvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJtVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIHZpZGVvIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdlYm1WaWRlbzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdnA5VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB2cDkgdmlkZW8gZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdnA5VmlkZW86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhsc1ZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgaGxzIHZpZGVvIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGhsc1ZpZGVvOiBmYWxzZVxuXG59O1xuXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdmFyIHJlc3VsdCA9ICEhdmlkZW9FbGVtZW50LmNhblBsYXlUeXBlO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBWaWRlby5vZ2dWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCBRdWlja1RpbWUsIHRoaXMgdmFsdWUgd2lsbCBiZSBgdW5kZWZpbmVkYC4gZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2lzc3Vlcy81NDZcbiAgICAgICAgICAgICAgICBWaWRlby5oMjY0VmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIFZpZGVvLm1wNFZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgVmlkZW8ud2VibVZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vd2VibTsgY29kZWNzPVwidnA5XCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFZpZGVvLnZwOVZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24veC1tcGVnVVJMOyBjb2RlY3M9XCJhdmMxLjQyRTAxRVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBWaWRlby5obHNWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpXG4gICAge1xuICAgICAgICAvLyAgTm90aGluZyB0byBkb1xuICAgIH1cblxuICAgIHJldHVybiBWaWRlbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvVmlkZW8uanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9WaWRlby5qcyIsIi8vICBUaGlzIHNpbmdsZXRvbiBpcyBpbnN0YW50aWF0ZWQgYXMgc29vbiBhcyBQaGFzZXIgbG9hZHMsXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIGNhbiBzaGFyZSBpdCxcbi8vICB3aXRob3V0IGhhdmluZyB0byByZS1wb2xsIHRoZSBkZXZpY2UgYWxsIG92ZXIgYWdhaW5cblxudmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4vRmVhdHVyZXMnKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vSW5wdXQnKTtcbnZhciBBdWRpbyA9IHJlcXVpcmUoJy4vQXVkaW8nKTtcbnZhciBWaWRlbyA9IHJlcXVpcmUoJy4vVmlkZW8nKTtcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9GdWxsc2NyZWVuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgT1M6IE9TLFxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXG4gICAgRmVhdHVyZXM6IEZlYXR1cmVzLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBBdWRpbzogQXVkaW8sXG4gICAgVmlkZW86IFZpZGVvLFxuICAgIEZ1bGxzY3JlZW46IEZ1bGxzY3JlZW5cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL2luZGV4LmpzIiwidmFyIEFkZFRvRE9NID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCwgb3ZlcmZsb3dIaWRkZW4pXG57XG4gICAgaWYgKG92ZXJmbG93SGlkZGVuID09PSB1bmRlZmluZWQpIHsgb3ZlcmZsb3dIaWRkZW4gPSB0cnVlOyB9XG5cbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgaWYgKHBhcmVudClcbiAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEhvcGVmdWxseSBhbiBlbGVtZW50IElEXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFF1aWNrIHRlc3QgZm9yIGEgSFRNTGVsZW1lbnRcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICBGYWxsYmFjaywgY292ZXJzIGFuIGludmFsaWQgSUQgYW5kIGEgbm9uIEhUTUxlbGVtZW50IG9iamVjdFxuICAgIGlmICghdGFyZ2V0KVxuICAgIHtcbiAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gJiYgdGFyZ2V0LnN0eWxlKVxuICAgIHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkZFRvRE9NO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0FkZFRvRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgT1MgPSByZXF1aXJlKCcuLi9kZXZpY2UvT1MnKTtcblxudmFyIGlzQm9vdGVkID0gZmFsc2U7XG5cbnZhciBET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxue1xuICAgIGlmIChpc0Jvb3RlZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKVxuICAgIHtcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgY2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlzQm9vdGVkID0gdHJ1ZTtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNoZWNrLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjaGVjaywgdHJ1ZSk7XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5KVxuICAgIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2ssIDIwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT1MuY29yZG92YSAmJiAhT1MuY29jb29uSlMpXG4gICAge1xuICAgICAgICAvLyAgUmVmLiBodHRwOi8vZG9jcy5waG9uZWdhcC5jb20vZW4vMy41LjAvY29yZG92YV9ldmVudHNfZXZlbnRzLm1kLmh0bWwjZGV2aWNlcmVhZHlcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBjaGVjaywgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNoZWNrLCB0cnVlKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNvbnRlbnRMb2FkZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vRE9NQ29udGVudExvYWRlZC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9tL0RPTUNvbnRlbnRMb2FkZWQuanMiLCJ2YXIgUGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSlcbntcbiAgICB2YXIgeG1sID0gJyc7XG5cbiAgICB0cnlcbiAgICB7XG4gICAgICAgIGlmICh3aW5kb3dbJ0RPTVBhcnNlciddKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgeG1sID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhLCAndGV4dC94bWwnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICAgICAgICB4bWwubG9hZFhNTChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHhtbCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4geG1sO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VYTUw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vUGFyc2VYTUwuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBBYnN0cmFjdHMgYXdheSB0aGUgdXNlIG9mIFJBRiBvciBzZXRUaW1lT3V0IGZvciB0aGUgY29yZSBnYW1lIHVwZGF0ZSBsb29wLlxuKlxuKiBAY2xhc3MgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxuKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVNldFRpbWVPdXQ9ZmFsc2VdIC0gVGVsbCBQaGFzZXIgdG8gdXNlIHNldFRpbWVPdXQgZXZlbiBpZiByYWYgaXMgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIFJlcXVlc3RBbmltYXRpb25GcmFtZSAoZ2FtZSlcbntcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBUaGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiAgICAqL1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNSdW5uaW5nIC0gdHJ1ZSBpZiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaXMgcnVubmluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnRpY2sgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU2V0VGltZU91dCAgLSBUcnVlIGlmIHRoZSBicm93c2VyIGlzIHVzaW5nIHNldFRpbWVvdXQgaW5zdGVhZCBvZiByQWYuXG4gICAgKi9cbiAgICB0aGlzLmlzU2V0VGltZU91dCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZU91dElEIC0gVGhlIGNhbGxiYWNrIHNldFRpbWVvdXQgb3IgckFmIGNhbGxiYWNrIElEIHVzZWQgd2hlbiBjYWxsaW5nIGNhbmNlbC5cbiAgICAqL1xuICAgIHRoaXMudGltZU91dElEID0gbnVsbDtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyAgdGltZXN0YW1wID0gRE9NSGlnaFJlc1RpbWVTdGFtcFxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcbiAgICB7XG4gICAgICAgIF90aGlzLnRpY2sgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgX3RoaXMudGltZU91dElEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICBfdGhpcy5nYW1lLnVwZGF0ZSh0aW1lc3RhbXApO1xuICAgIH07XG5cbiAgICB2YXIgc3RlcFRpbWVvdXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgX3RoaXMudGljayA9IERhdGUubm93KCk7XG5cbiAgICAgICAgLy8gX3RoaXMuZ2FtZS51cGRhdGUoX3RoaXMudGljayk7XG5cbiAgICAgICAgLy8gX3RoaXMudGltZU91dElEID0gd2luZG93LnNldFRpbWVvdXQoc3RlcFRpbWVvdXQsIF90aGlzLmdhbWUudGltZS50aW1lVG9DYWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBTdGFydHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5uaW5nIG9yIHNldFRpbWVvdXQgaWYgdW5hdmFpbGFibGUgaW4gYnJvd3NlclxuICAgICogQG1ldGhvZCBQaGFzZXIuUmVxdWVzdEFuaW1hdGlvbkZyYW1lI3N0YXJ0XG4gICAgKi9cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5nYW1lLmNvbmZpZy5mb3JjZVNldFRpbWVPdXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChzdGVwVGltZW91dCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmlzU2V0VGltZU91dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnRpbWVPdXRJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBTdG9wcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gcnVubmluZy5cbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdG9wXG4gICAgKi9cbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB0aGlzLmdhbWUgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxufVxuXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9FdmVudExpc3RlbmVyJyk7XG5cbnZhciBFdmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlciwgdHlwZSlcbntcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcbiAgICB0aGlzLmFjdGl2ZSA9IFtdO1xufTtcblxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50QmluZGluZztcblxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgIHRvdGFsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiAoY2FsbGJhY2spXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0KGNhbGxiYWNrKSk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcbiAgICB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhlIGxpc3RlbmVyIGRvZXNuJ3QgZXhpc3QsIHNvIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgIGxpc3RlbmVyID0gRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgTGlzdGVuZXIgYWxyZWFkeSBleGlzdHMsIGFib3J0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGRvbid0IG5lZWQgYSBwZW5kaW5nIHN0YXRlXG4gICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX0FDVElWRTtcblxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEFkZCBpdCB0byB0aGUgbGlzdCwgYnV0IGtlZXAgdGhlIHN0YXRlIGFzIHBlbmRpbmcuXG4gICAgICAgICAgICAvLyAgVGhlIGNhbGwgdG8gJ3RpZHknIHdpbGwgc29ydCBpdCBvdXQgYXQgdGhlIGVuZCBvZiB0aGUgZGlzcGF0Y2guXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzb3J0SGFuZGxlcjogZnVuY3Rpb24gKGxpc3RlbmVyQSwgbGlzdGVuZXJCKVxuICAgIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA8IGxpc3RlbmVyQS5wcmlvcml0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA+IGxpc3RlbmVyQS5wcmlvcml0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgY2FuIHJlbW92ZSByaWdodCBhd2F5XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzIHdvcmtpbmcsIHNvIHdlIGZsYWcgdGhlIGxpc3RlbmVyIGZvciByZW1vdmFsIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IEZhaWxlZCB0byBleGVjdXRlIFxcJ0V2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaFxcJyBvbiBcXCcnICsgdGhpcy50eXBlICsgJ1xcJzogVGhlIGV2ZW50IGlzIGFscmVhZHkgYmVpbmcgZGlzcGF0Y2hlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGlzIHdhcyBhIHZhbGlkIGRpc3BhdGNoIGNhbGwsIHdlIGp1c3QgaGFkIG5vdGhpbmcgdG8gZG8gLi4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORztcblxuICAgICAgICB2YXIgbGlzdGVuZXI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLmFjdGl2ZVtpXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9BQ1RJVkUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcy5kaXNwYXRjaGVyLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vICBIYXMgdGhlIGNhbGxiYWNrIGNoYW5nZWQgdGhlIHN0YXRlIG9mIHRoaXMgYmluZGluZz9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBZdXAhIExldCdzIGJyZWFrIG91dFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgV2FzIGl0IGEgJ29uY2UnIGxpc3RlbmVyP1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9SRU1PVklORztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgZXZlbnQgYmVlbiBoYWx0ZWQgYnkgdGhlIGNhbGxiYWNrP1xuICAgICAgICAgICAgaWYgKCFldmVudC5fcHJvcGFnYXRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBCcmVhayBvdXQsIGEgbGlzdGVuZXIgaGFzIGNhbGxlZCBFdmVudC5zdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBEaXNwYXRjaCBvdmVyLCBvciBhYm9ydGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX1JFTU9WSU5HKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICAvLyAgQWxsIGRvbmUsIHRpZHkgdGhlIGxpc3QgaW4gY2FzZSB0aGVyZSB3ZXJlIGFueSBwZW5kaW5nIGV2ZW50cyBhZGRlZFxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5kZWxldGUodGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwganVzdCBwdXJnZSB0aGUgbGlzdFxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgIC8vICBJZiB0aGlzIGlzIGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIHRoZW4gZG9uJ3QgcmVtb3ZlICdwZW5kaW5nJyBsaXN0ZW5lcnNcbiAgICAvLyAgKGkuZS4gb25lcyB0aGF0IHdlcmUgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaCksIG9ubHkgYWN0aXZlIG9uZXNcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfUEVORElORylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0aWR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGFkZGVkID0gMDtcblxuICAgICAgICB2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgZG9cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBDT05TVC5MSVNURU5FUl9SRU1PVklORylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfUEVORElORylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfQUNUSVZFO1xuICAgICAgICAgICAgICAgIGFkZGVkKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA+PSAwKTtcblxuICAgICAgICBpZiAoYWRkZWQgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQ7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50QmluZGluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9FdmVudEJpbmRpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2V2ZW50cy9FdmVudEJpbmRpbmcuanMiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbnZhciBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcbntcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgc3RhdGU6IENPTlNULkxJU1RFTkVSX1BFTkRJTkdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vR2FtZU9iamVjdCcpO1xudmFyIENvbnRhaW5lcldlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lcldlYkdMUmVuZGVyZXInKTtcbnZhciBDaGlsZHJlbiA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvQ2hpbGRyZW4nKTtcblxudmFyIENvbnRhaW5lciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50LCB4LCB5KVxue1xuICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSwgeCwgeSwgbnVsbCwgbnVsbCwgcGFyZW50KTtcblxuICAgIHRoaXMudHlwZSA9IENPTlNULkNPTlRBSU5FUjtcblxuICAgIHRoaXMucmVuZGVyID0gQ29udGFpbmVyV2ViR0xSZW5kZXJlcjtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ2hpbGRyZW4odGhpcyk7XG59O1xuXG5Db250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHYW1lT2JqZWN0LnByb3RvdHlwZSk7XG5Db250YWluZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFpbmVyO1xuXG5Db250YWluZXIucHJvdG90eXBlLnByZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5jaGlsZHJlbi5wcmVVcGRhdGUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIlxudmFyIENvbnRhaW5lcldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXG57XG4gICAgdmFyIGFscGhhID0gc3JjLmNvbG9yLndvcmxkQWxwaGEgKiAyNTUgPDwgMjQ7XG5cbiAgICAvLyAgU2tpcCByZW5kZXJpbmc/XG5cbiAgICBpZiAoc3JjLnNraXBSZW5kZXIgfHwgIXNyYy52aXNpYmxlIHx8IGFscGhhID09PSAwIHx8IHNyYy5jaGlsZHJlbi5saXN0Lmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgUmVuZGVyIGNoaWxkcmVuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHNyYy5jaGlsZHJlbi5saXN0W2ldO1xuXG4gICAgICAgIGNoaWxkLnJlbmRlcihyZW5kZXJlciwgY2hpbGQpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyV2ViR0xSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XG52YXIgSW1hZ2VXZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi9JbWFnZVdlYkdMUmVuZGVyZXInKTtcbnZhciBJbWFnZUNhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9JbWFnZUNhbnZhc1JlbmRlcmVyJyk7XG5cbi8qKlxuKiBBbiBJbWFnZSBpcyBhIGxpZ2h0LXdlaWdodCBvYmplY3QgeW91IGNhbiB1c2UgdG8gZGlzcGxheSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgbmVlZCBwaHlzaWNzIG9yIGFuaW1hdGlvbi5cbiogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLiBUaGlzIG1ha2VzIGl0IHBlcmZlY3QgZm9yIGxvZ29zLCBiYWNrZ3JvdW5kcywgc2ltcGxlIGJ1dHRvbnMgYW5kIG90aGVyIG5vbi1TcHJpdGUgZ3JhcGhpY3MuXG4qXG4qIEBjbGFzcyBQaGFzZXIuR2FtZU9iamVjdC5JbWFnZVxuKiBAZXh0ZW5kcyBQaGFzZXIuR2FtZU9iamVjdFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxuKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBJbWFnZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBJbWFnZSBtYXkgYmUgaW4uXG4qIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cbiogQHBhcmFtIHtzdHJpbmd9IFtrZXldIC0gVGhlIHRleHR1cmUgdXNlZCBieSB0aGUgSW1hZ2UgZHVyaW5nIHJlbmRlcmluZy4gSXQgY2FuIGJlIGEgc3RyaW5nIHdoaWNoIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBDYWNoZSBlbnRyeSwgb3IgYW4gaW5zdGFuY2Ugb2YgYSBSZW5kZXJUZXh0dXJlLCBCaXRtYXBEYXRhIG9yIFBJWEkuVGV4dHVyZS5cbiogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZnJhbWVdIC0gSWYgdGhpcyBJbWFnZSBpcyB1c2luZyBwYXJ0IG9mIGEgc3ByaXRlIHNoZWV0IG9yIHRleHR1cmUgYXRsYXMgeW91IGNhbiBzcGVjaWZ5IHRoZSBleGFjdCBmcmFtZSB0byB1c2UgYnkgZ2l2aW5nIGEgc3RyaW5nIG9yIG51bWVyaWMgaW5kZXguXG4qL1xudmFyIEltYWdlID0gZnVuY3Rpb24gKHN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKVxue1xuICAgIHZhciBfdGV4dHVyZSA9IHN0YXRlLmdhbWUudGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgdmFyIF9mcmFtZSA9IF90ZXh0dXJlLmdldChmcmFtZSk7XG5cbiAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUsIHgsIHksIF90ZXh0dXJlLCBfZnJhbWUpO1xuXG4gICAgdGhpcy50eXBlID0gQ09OU1QuSU1BR0U7XG5cbiAgICAvLyB0aGlzLnJlbmRlciA9IEltYWdlV2ViR0xSZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlciA9IEltYWdlQ2FudmFzUmVuZGVyZXI7XG59O1xuXG5JbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdhbWVPYmplY3QucHJvdG90eXBlKTtcbkltYWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbWFnZS5wcm90b3R5cGUsIHtcblxuICAgIHdpZHRoOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fc2NhbGVYICogdGhpcy5mcmFtZS5yZWFsV2lkdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gdmFsdWUgLyB0aGlzLmZyYW1lLnJlYWxXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGhlaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uX3NjYWxlWSAqIHRoaXMuZnJhbWUucmVhbEhlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZS5qcyIsIlxudmFyIEltYWdlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpXG57XG4gICAgdmFyIGZyYW1lID0gc3JjLmZyYW1lO1xuICAgIHZhciBhbHBoYSA9IHNyYy5jb2xvci53b3JsZEFscGhhICogMjU1IDw8IDI0O1xuXG4gICAgLy8gIFNraXAgcmVuZGVyaW5nP1xuXG4gICAgaWYgKHNyYy5za2lwUmVuZGVyIHx8ICFzcmMudmlzaWJsZSB8fCBhbHBoYSA9PT0gMCB8fCAhZnJhbWUuY3V0V2lkdGggfHwgIWZyYW1lLmN1dEhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNyYy50cmFuc2Zvcm0uZ2V0Q2FudmFzVHJhbnNmb3JtRGF0YShpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgcmVuZGVyZXIpO1xuICAgIHZhciB0aW50ID0gc3JjLmNvbG9yLl9nbFRpbnQ7XG4gICAgdmFyIGJnID0gc3JjLmNvbG9yLl9nbEJnO1xuXG4gICAgcmVuZGVyZXIuZHJhd0ltYWdlKGZyYW1lLCBzcmMuYmxlbmRNb2RlLCBkYXRhLCBhbHBoYSwgdGludCwgYmcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhbnZhc1JlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgSW1hZ2VXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlKVxue1xuICAgIHZhciBmcmFtZSA9IHNyYy5mcmFtZTtcbiAgICB2YXIgYWxwaGEgPSBzcmMuY29sb3Iud29ybGRBbHBoYSAqIDI1NSA8PCAyNDtcblxuICAgIC8vICBTa2lwIHJlbmRlcmluZz9cblxuICAgIGlmIChzcmMuc2tpcFJlbmRlciB8fCAhc3JjLnZpc2libGUgfHwgYWxwaGEgPT09IDAgfHwgIWZyYW1lLmN1dFdpZHRoIHx8ICFmcmFtZS5jdXRIZWlnaHQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZlcnRzID0gc3JjLnRyYW5zZm9ybS5nZXRWZXJ0ZXhEYXRhKGludGVycG9sYXRpb25QZXJjZW50YWdlLCByZW5kZXJlcik7XG4gICAgdmFyIGluZGV4ID0gc3JjLmZyYW1lLnNvdXJjZS5nbFRleHR1cmVJbmRleDtcbiAgICB2YXIgdGludCA9IHNyYy5jb2xvci5fZ2xUaW50O1xuICAgIHZhciBiZyA9IHNyYy5jb2xvci5fZ2xCZztcblxuICAgIHJlbmRlcmVyLmJhdGNoLmFkZChmcmFtZS5zb3VyY2UsIHNyYy5ibGVuZE1vZGUsIHZlcnRzLCBmcmFtZS51dnMsIGluZGV4LCBhbHBoYSwgdGludCwgYmcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVdlYkdMUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZVdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcmVhID0gZnVuY3Rpb24gKGNpcmNsZSlcbntcbiAgICByZXR1cm4gKGNpcmNsZS5yYWRpdXMgPiAwKSA/IE1hdGguUEkgKiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyA6IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2lyY3VtZmVyZW5jZSA9IGZ1bmN0aW9uIChjaXJjbGUpXG57XG4gICAgcmV0dXJuIDIgKiAoTWF0aC5QSSAqIGNpcmNsZS5yYWRpdXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1mZXJlbmNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFJldHVybnMgYSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgQ2lyY2xlIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlLmNpcmN1bWZlcmVuY2VQb2ludFxuKiBAcGFyYW0ge1BoYXNlci5DaXJjbGV9IGEgLSBUaGUgZmlyc3QgQ2lyY2xlIG9iamVjdC5cbiogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMgKHVubGVzcyBhc0RlZ3JlZXMgaXMgdHJ1ZSkgdG8gcmV0dXJuIHRoZSBwb2ludCBmcm9tLlxuKiBAcGFyYW0ge1BoYXNlci5Qb2ludH0gW291dF0gLSBBbiBvcHRpb25hbCBQb2ludCBvYmplY3QgdG8gcHV0IHRoZSByZXN1bHQgaW4gdG8uIElmIG5vbmUgc3BlY2lmaWVkIGEgbmV3IFBvaW50IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gVGhlIFBvaW50IG9iamVjdCBob2xkaW5nIHRoZSByZXN1bHQuXG4qL1xudmFyIENpcmN1bWZlcmVuY2VQb2ludCA9IGZ1bmN0aW9uIChjaXJjbGUsIGFuZ2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XG5cbiAgICBvdXQueCA9IGNpcmNsZS54ICsgKGNpcmNsZS5yYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICAgIG91dC55ID0gY2lyY2xlLnkgKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1mZXJlbmNlUG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9DaXJjdW1mZXJlbmNlUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xuXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxue1xuICAgIHJldHVybiBuZXcgQ2lyY2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcbntcbiAgICByZXR1cm4gQ29udGFpbnMoY2lyY2xlLCBwb2ludC54LCBwb2ludC55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xuXG52YXIgQ29udGFpbnNSZWN0ID0gZnVuY3Rpb24gKGNpcmNsZSwgcmVjdClcbntcbiAgICByZXR1cm4gKFxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC55KSAmJlxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxue1xuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGNpcmNsZSwgdG9Db21wYXJlKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIGNpcmNsZS54ID09PSB0b0NvbXBhcmUueCAmJlxuICAgICAgICBjaXJjbGUueSA9PT0gdG9Db21wYXJlLnkgJiZcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XG5cbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxuXG4gICAgb3V0LnggPSBjaXJjbGUubGVmdDtcbiAgICBvdXQueSA9IGNpcmNsZS50b3A7XG4gICAgb3V0LndpZHRoID0gY2lyY2xlLmRpYW1ldGVyO1xuICAgIG91dC5oZWlnaHQgPSBjaXJjbGUuZGlhbWV0ZXI7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRCb3VuZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGNpcmNsZSwgeCwgeSlcbntcbiAgICBjaXJjbGUueCArPSB4O1xuICAgIGNpcmNsZS55ICs9IHk7XG5cbiAgICByZXR1cm4gY2lyY2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcbntcbiAgICBjaXJjbGUueCArPSBwb2ludC54O1xuICAgIGNpcmNsZS55ICs9IHBvaW50Lnk7XG5cbiAgICByZXR1cm4gY2lyY2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcblxuLyoqXG4qIFJldHVybnMgYSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIHBvaW50IGZyb20gYW55d2hlcmUgd2l0aGluIHRoaXMgQ2lyY2xlLlxuKiBcbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI3JhbmRvbVxuKiBAcGFyYW0ge1BoYXNlci5Qb2ludHxvYmplY3R9IFtvdXRdIC0gQSBQaGFzZXIuUG9pbnQsIG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXMsIHRoYXQgdGhlIHZhbHVlcyB3aWxsIGJlIHNldCBpbi5cbiogICAgIElmIG5vIG9iamVjdCBpcyBwcm92aWRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC4gSW4gaGlnaCBwZXJmb3JtYW5jZSBhcmVhcyBhdm9pZCB0aGlzIGJ5IHJlLXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdC5cbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmFuZG9tIHBvaW50IGluIGl0cyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxuKi9cbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICB2YXIgdCA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgdSA9IE1hdGgucmFuZG9tKCkgKyBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciByID0gKHUgPiAxKSA/IDIgLSB1IDogdTtcbiAgICB2YXIgeCA9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB2YXIgeSA9IHIgKiBNYXRoLnNpbih0KTtcblxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoeCAqIGNpcmNsZS5yYWRpdXMpO1xuICAgIG91dC55ID0gY2lyY2xlLnkgKyAoeSAqIGNpcmNsZS5yYWRpdXMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvUmFuZG9tLmpzIiwiLy8gIFBoYXNlci5HZW9tLkNpcmNsZVxuXG52YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxuQ2lyY2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcbkNpcmNsZS5DaXJjdW1mZXJlbmNlID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlJyk7XG5DaXJjbGUuQ2lyY3VtZmVyZW5jZVBvaW50ID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlUG9pbnQnKTtcbkNpcmNsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcbkNpcmNsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcbkNpcmNsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XG5DaXJjbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcbkNpcmNsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcbkNpcmNsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xuQ2lyY2xlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XG5DaXJjbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcbkNpcmNsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcbkNpcmNsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ2YXIgQXJlYSA9IGZ1bmN0aW9uIChlbGxpcHNlKVxue1xuICAgIGlmIChlbGxpcHNlLmlzRW1wdHkoKSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vICB1bml0cyBzcXVhcmVkXG4gICAgcmV0dXJuIChlbGxpcHNlLmdldE1ham9yUmFkaXVzKCkgKiBlbGxpcHNlLmdldE1pbm9yUmFkaXVzKCkgKiBNYXRoLlBJKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcblxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcbntcbiAgICByZXR1cm4gbmV3IEVsbGlwc2Uoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgcG9pbnQpXG57XG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LnJpZ2h0LCByZWN0LnkpICYmXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC5ib3R0b20pICYmXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwiLyoqXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0VsbGlwc2V9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxue1xuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGVsbGlwc2UsIHRvQ29tcGFyZSlcbntcbiAgICByZXR1cm4gKFxuICAgICAgICBlbGxpcHNlLnggPT09IHRvQ29tcGFyZS54ICYmXG4gICAgICAgIGVsbGlwc2UueSA9PT0gdG9Db21wYXJlLnkgJiZcbiAgICAgICAgZWxsaXBzZS53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXG4gICAgICAgIGVsbGlwc2UuaGVpZ2h0ID09PSB0b0NvbXBhcmUuaGVpZ2h0XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XG5cbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cblxuICAgIG91dC54ID0gZWxsaXBzZS54IC0gZWxsaXBzZS53aWR0aDtcbiAgICBvdXQueSA9IGVsbGlwc2UueSAtIGVsbGlwc2UuaGVpZ2h0O1xuICAgIG91dC53aWR0aCA9IGVsbGlwc2Uud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IGVsbGlwc2UuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHgsIHkpXG57XG4gICAgZWxsaXBzZS54ICs9IHg7XG4gICAgZWxsaXBzZS55ICs9IHk7XG5cbiAgICByZXR1cm4gZWxsaXBzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcbntcbiAgICBlbGxpcHNlLnggKz0gcG9pbnQueDtcbiAgICBlbGxpcHNlLnkgKz0gcG9pbnQueTtcblxuICAgIHJldHVybiBlbGxpcHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbnZhciBSYW5kb20gPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIHAgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoTWF0aC5yYW5kb20oKSk7XG5cbiAgICBvdXQueCA9IGVsbGlwc2UueCArICgocyAqIE1hdGguY29zKHApKSAqIGVsbGlwc2Uud2lkdGggLyAyKTtcbiAgICBvdXQueSA9IGVsbGlwc2UueSArICgocyAqIE1hdGguc2luKHApKSAqIGVsbGlwc2UuaGVpZ2h0IC8gMik7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9lbGxpcHNlL1JhbmRvbS5qcyIsIi8vICBQaGFzZXIuR2VvbS5FbGxpcHNlXG5cbnZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XG5cbkVsbGlwc2UuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xuRWxsaXBzZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcbkVsbGlwc2UuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5FbGxpcHNlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcbkVsbGlwc2UuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcbkVsbGlwc2UuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XG5FbGxpcHNlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XG5FbGxpcHNlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XG5FbGxpcHNlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XG5FbGxpcHNlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xuRWxsaXBzZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ2YXIgR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XG52YXIgRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XG5cbi8qKlxuKiBDYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgYW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSBjdXJ2ZXMgdGFuZ2VudCBhdCB0aGUgZ2l2ZW4gcGl4ZWwgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlcyBsZW5ndGguXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0QW5nbGVXaXRoRGlzdGFuY2VcbiogQHBhcmFtIHtudW1iZXJ9IFtkaXN0YW5jZT0wXSAtIFRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdG8gZ2V0IHRoZSBhbmdsZSBmcm9tLCBpbiBwaXhlbHMuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cbiovXG52YXIgR2V0QW5nbGVXaXRoRGlzdGFuY2UgPSBmdW5jdGlvbiAoY3VydmUsIGRpc3RhbmNlKVxue1xuICAgIGlmIChkaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7IGRpc3RhbmNlID0gMDsgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl92MXksIHRoaXMuX3YxeCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBHZXRBbmdsZShjdXJ2ZSwgRmluZFQoY3VydmUsIGRpc3RhbmNlKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZVdpdGhEaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIi8qKlxuKiBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBjdXJ2ZXMgZW50cnkgcG9pbnQuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0RW50cnlUYW5nZW50XG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gcG9pbnQgLSBUaGUgUGhhc2VyLlBvaW50IG9iamVjdCwgb3IgYW4gT2JqZWN0IHdpdGggcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIGluIHdoaWNoIHRoZSB0YW5nZW50IHZlY3RvciB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgdGFuZ2VudCB2ZWN0b3Igb2YgdGhpcyBIZXJtaXRlIGN1cnZlLlxuKi9cbnZhciBHZXRFbnRyeVRhbmdlbnQgPSBmdW5jdGlvbiAoY3VydmUsIHBvaW50KVxue1xuICAgIHBvaW50LnggPSBjdXJ2ZS5fdjF4O1xuICAgIHBvaW50LnkgPSBjdXJ2ZS5fdjF5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRFbnRyeVRhbmdlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcbnZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcbnZhciBGaW5kVCA9IHJlcXVpcmUoJy4vRmluZFQnKTtcblxuLyoqXG4qIEdldCBhIHBvaW50IG9uIHRoZSBjdXJ2ZSB1c2luZyB0aGUgZGlzdGFuY2UsIGluIHBpeGVscywgYWxvbmcgdGhlIGN1cnZlLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50V2l0aERpc3RhbmNlXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2Rpc3RhbmNlPTBdIC0gVGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0byBnZXQgdGhlIHBvaW50IGZyb20sIGdpdmVuIGluIHBpeGVscy5cbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8T2JqZWN0fSBbcG9pbnRdIC0gQW4gb3B0aW9uYWwgUGhhc2VyLlBvaW50LCBvciBPYmplY3QgY29udGFpbmluZyBwdWJsaWMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgZ2l2ZW4gdGhlIHJlc3VsdGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIE9iamVjdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgb21pdHRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gVGhlIHBvaW50IG9uIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgY3VydmUuXG4qL1xudmFyIEdldFBvaW50V2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSwgb3V0KVxue1xuICAgIGlmIChkaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7IGRpc3RhbmNlID0gMDsgfVxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXG4gICAge1xuICAgICAgICBvdXQueCA9IHRoaXMuX3AxeDtcbiAgICAgICAgb3V0LnkgPSB0aGlzLl9wMXk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIEdldFBvaW50KGN1cnZlLCBGaW5kVChjdXJ2ZSwgZGlzdGFuY2UpLCBvdXQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludFdpdGhEaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qcyIsIi8qKlxuKiBHZXQgdGhlIFggY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLCB3aGljaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRYXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWCBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXG4qL1xudmFyIEdldFggPSBmdW5jdGlvbiAoY3VydmUsIHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAodCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPiAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciB0MyA9IHQgKiB0MjtcblxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXggKyB0MiAqIGN1cnZlLl9ieCArIHQgKiBjdXJ2ZS5fdjF4ICsgY3VydmUuX3AxeCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBHZXQgdGhlIFkgY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLCB3aGljaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRZXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWSBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXG4qL1xudmFyIEdldFkgPSBmdW5jdGlvbiAoY3VydmUsIHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAodCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPiAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciB0MyA9IHQgKiB0MjtcblxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXkgKyB0MiAqIGN1cnZlLl9ieSArIHQgKiBjdXJ2ZS5fdjF5ICsgY3VydmUuX3AxeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WS5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAYXV0aG9yICAgICAgIFBldGUgQmFyb24gPHBldGVAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBBIGRhdGEgcmVwcmVzZW50YXRpb24gb2YgYSBIZXJtaXRlIEN1cnZlIChzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSlcbiogXG4qIEEgSGVybWl0ZSBjdXJ2ZSBoYXMgYSBzdGFydCBhbmQgZW5kIHBvaW50IGFuZCB0YW5nZW50IHZlY3RvcnMgZm9yIGJvdGggb2YgdGhlbS5cbiogVGhlIGN1cnZlIHdpbGwgYWx3YXlzIHBhc3MgdGhyb3VnaCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIGFuZCB0aGUgc2hhcGUgb2YgaXQgaXMgY29udHJvbGxlZFxuKiBieSB0aGUgbGVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIHRhbmdlbnQgdmVjdG9ycy4gIEF0IHRoZSBjb250cm9sIHBvaW50cyB0aGUgY3VydmUgd2lsbFxuKiBiZSBmYWNpbmcgZXhhY3RseSBpbiB0aGUgdmVjdG9yIGRpcmVjdGlvbi5cbiogXG4qIEFzIHRoZXNlIGN1cnZlcyBjaGFuZ2Ugc3BlZWQgKHNwZWVkID0gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgc2VwYXJhdGVkIGJ5IGFuIGVxdWFsIGNoYW5nZSBpblxuKiAndCcgdmFsdWUgLSBzZWUgSGVybWl0ZS5nZXRQb2ludCkgdGhpcyBjbGFzcyBhdHRlbXB0cyB0byByZWR1Y2UgdGhlIHZhcmlhdGlvbiBieSBwcmUtY2FsY3VsYXRpbmdcbiogdGhlIGBhY2N1cmFjeWAgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmUuIFRoZSBzdHJhaWdodC1saW5lIGRpc3RhbmNlcyB0byB0aGVzZSBwb2ludHMgYXJlIHN0b3JlZFxuKiBpbiB0aGUgcHJpdmF0ZSAncG9pbnRzJyBhcnJheSwgYW5kIHRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCBieSBIZXJtaXRlLmZpbmRUKCkgdG8gY29udmVydCBhIHBpeGVsXG4qIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSBpbnRvIGEgJ3RpbWUnIHZhbHVlLlxuKiBcbiogSGlnaGVyIGBhY2N1cmFjeWAgdmFsdWVzIHdpbGwgcmVzdWx0IGluIG1vcmUgZXZlbiBtb3ZlbWVudCwgYnV0IHJlcXVpcmUgbW9yZSBtZW1vcnkgZm9yIHRoZSBwb2ludHNcbiogbGlzdC4gNSB3b3JrcywgYnV0IDEwIHNlZW1zIHRvIGJlIGFuIGlkZWFsIHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIGN1cnZlcyBmb3VuZCBpbiBtb3N0IGdhbWVzIG9uXG4qIGEgZGVza3RvcCBzY3JlZW4uIElmIHlvdSB1c2UgdmVyeSBsb25nIGN1cnZlcyAobW9yZSB0aGFuIDQwMCBwaXhlbHMpIHlvdSBtYXkgbmVlZCB0byBpbmNyZWFzZVxuKiB0aGlzIHZhbHVlIGZ1cnRoZXIuXG4qXG4qIEBjbGFzcyBQaGFzZXIuSGVybWl0ZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtudW1iZXJ9IHAxeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHAxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXG4qIEBwYXJhbSB7bnVtYmVyfSBwMnkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuKiBAcGFyYW0ge251bWJlcn0gdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXG4qIEBwYXJhbSB7bnVtYmVyfSB2MnggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHYyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuKiBAcGFyYW0ge251bWJlcn0gW2FjY3VyYWN5PTEwXSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cbiovXG52YXIgSGVybWl0ZSA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgcDJ4LCBwMnksIHYxeCwgdjF5LCB2MngsIHYyeSwgYWNjdXJhY3kpXG57XG4gICAgaWYgKGFjY3VyYWN5ID09PSB1bmRlZmluZWQpIHsgYWNjdXJhY3kgPSAxMDsgfVxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX2FjY3VyYWN5IC0gVGhlIGFtb3VudCBvZiBwb2ludHMgdG8gcHJlLWNhbGN1bGF0ZSBvbiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fYWNjdXJhY3kgPSBhY2N1cmFjeTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fcDF4ID0gcDF4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3AxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMXkgPSBwMXk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMnggPSBwMng7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMnkgPSBwMnk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl92MXggPSB2MXg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl92MXkgPSB2MXk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fdjJ4ID0gdjJ4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3YyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX3YyeSA9IHYyeTtcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IF9wb2ludHMgLSBBIGxvY2FsIGFycmF5IG9mIGNhY2hlZCBwb2ludHMuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fcG9pbnRzID0gW107XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlBvaW50fSBfdGVtcDEgLSBBIGxvY2FsIGNhY2hlZCBQb2ludCBvYmplY3QuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fdGVtcDEgPSBuZXcgUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IF90ZW1wMiAtIEEgbG9jYWwgY2FjaGVkIFBvaW50IG9iamVjdC5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl90ZW1wMiA9IG5ldyBQb2ludCgpO1xuXG4gICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xufTtcblxuSGVybWl0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZXJtaXRlO1xuXG5IZXJtaXRlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogUGVyZm9ybXMgdGhlIGN1cnZlIGNhbGN1bGF0aW9ucy5cbiAgICAqXG4gICAgKiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIHlvdSBjaGFuZ2UgYW55IG9mIHRoZSBjdXJ2ZXMgcHVibGljIHByb3BlcnRpZXMsIHN1Y2ggYXMgYEhlcm1pdGUucDF4YCBvciBgSGVybWl0ZS52MnlgLlxuICAgICpcbiAgICAqIElmIHlvdSBhZGp1c3QgYW55IG9mIHRoZSBpbnRlcm5hbCBwcml2YXRlIHZhbHVlcywgdGhlbiBjYWxsIHRoaXMgdG8gdXBkYXRlIHRoZSBwb2ludHMuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNyZWNhbGN1bGF0ZVxuICAgICogQHJldHVybiB7UGhhc2VyLkhlcm1pdGV9IFRoaXMgb2JqZWN0LlxuICAgICovXG4gICAgcmVjYWxjdWxhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLl9heCA9ICgyICogdGhpcy5fcDF4IC0gMiAqIHRoaXMuX3AyeCArIHRoaXMuX3YxeCArIHRoaXMuX3YyeCk7XG4gICAgICAgIHRoaXMuX2F5ID0gKDIgKiB0aGlzLl9wMXkgLSAyICogdGhpcy5fcDJ5ICsgdGhpcy5fdjF5ICsgdGhpcy5fdjJ5KTtcbiAgICAgICAgdGhpcy5fYnggPSAoLTMgKiB0aGlzLl9wMXggKyAzICogdGhpcy5fcDJ4IC0gMiAqIHRoaXMuX3YxeCAtIHRoaXMuX3YyeCk7XG4gICAgICAgIHRoaXMuX2J5ID0gKC0zICogdGhpcy5fcDF5ICsgMyAqIHRoaXMuX3AyeSAtIDIgKiB0aGlzLl92MXkgLSB0aGlzLl92MnkpO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVFdmVuUG9pbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBDYWxjdWxhdGUgYSBudW1iZXIgb2YgcG9pbnRzIGFsb25nIHRoZSBjdXJ2ZSwgYmFzZWQgb24gYEhlcm1pdGUuYWNjdXJhY3lgLCBhbmQgc3RvcmVzIHRoZW0gaW4gdGhlIHByaXZhdGUgYF9wb2ludHNgIGFycmF5LlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjY2FsY3VsYXRlRXZlblBvaW50c1xuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBjdXJ2ZSBhcHByb3hpbWF0ZWQgYXMgc3RyYWlnaHQgbGluZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgcG9pbnRzLlxuICAgICovXG4gICAgY2FsY3VsYXRlRXZlblBvaW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdGVtcDEuc2V0VG8oMCwgMCk7ICAgICAgICAgICAgICAgICAgICAvLyAgcG50XG4gICAgICAgIHRoaXMuX3RlbXAyLnNldFRvKHRoaXMuX3AxeCwgdGhpcy5fcDF5KTsgICAgLy8gIGxhc3RQbnRcblxuICAgICAgICB0aGlzLl9wb2ludHNbMF0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMuX2FjY3VyYWN5OyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UG9pbnQoaSAvIHRoaXMuX2FjY3VyYWN5LCB0aGlzLl90ZW1wMSk7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0aGlzLl90ZW1wMS5kaXN0YW5jZSh0aGlzLl90ZW1wMik7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3RlbXAyLmNvcHlGcm9tKHRoaXMuX3RlbXAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b3RhbExlbmd0aDtcblxuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVybWl0ZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjYWNjdXJhY3lcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhY2N1cmFjeSAtIFRoZSBhbW91bnQgb2YgcG9pbnRzIHRvIHByZS1jYWxjdWxhdGUgb24gdGhlIGN1cnZlLlxuICAgICovXG4gICAgYWNjdXJhY3k6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjY3VyYWN5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FjY3VyYWN5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjY3VyYWN5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMXhcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHAxeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMXg7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AxeClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wMXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDF5XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDF5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXG4gICAgKi9cbiAgICBwMXk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDF5O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wMXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcDF5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AyeFxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHAyeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMng7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AyeClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wMnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDJ5XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgcDJ5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3AyeTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDJ5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSN2MXhcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2MXggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXG4gICAgKi9cbiAgICB2MXg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjF4O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdjF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YxeVxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHYxeToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92MXk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YxeSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92MXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjJ4XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHYyeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92Mng7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YyeClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92MnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjJ5XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjJ5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHYyeToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92Mnk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YyeSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92MnkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZXJtaXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qcyIsIi8vICBQaGFzZXIuR2VvbS5IZXJtaXRlXG5cbnZhciBIZXJtaXRlID0gcmVxdWlyZSgnLi9IZXJtaXRlJyk7XG5cbkhlcm1pdGUuRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XG5IZXJtaXRlLkdldEFuZ2xlID0gcmVxdWlyZSgnLi9HZXRBbmdsZScpO1xuSGVybWl0ZS5HZXRBbmdsZVdpdGhEaXN0YW5jZSA9IHJlcXVpcmUoJy4vR2V0QW5nbGVXaXRoRGlzdGFuY2UnKTtcbkhlcm1pdGUuR2V0RW50cnlUYW5nZW50ID0gcmVxdWlyZSgnLi9HZXRFbnRyeVRhbmdlbnQnKTtcbkhlcm1pdGUuR2V0UG9pbnQgPSByZXF1aXJlKCcuL0dldFBvaW50Jyk7XG5IZXJtaXRlLkdldFBvaW50V2l0aERpc3RhbmNlID0gcmVxdWlyZSgnLi9HZXRQb2ludFdpdGhEaXN0YW5jZScpO1xuSGVybWl0ZS5HZXRYID0gcmVxdWlyZSgnLi9HZXRYJyk7XG5IZXJtaXRlLkdldFkgPSByZXF1aXJlKCcuL0dldFknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZXJtaXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwidmFyIERpc3RhbmNlQmV0d2VlbiA9IHJlcXVpcmUoJy4uLy4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuJyk7XG5cbnZhciBDaXJjbGVUb0NpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKVxue1xuICAgIHJldHVybiAoRGlzdGFuY2VCZXR3ZWVuKGNpcmNsZUEueCwgY2lyY2xlQS55LCBjaXJjbGVCLngsIGNpcmNsZUIueSkgPD0gKGNpcmNsZUEucmFkaXVzICsgY2lyY2xlQi5yYWRpdXMpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlVG9DaXJjbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ2YXIgQ2lyY2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAoY2lyY2xlLCByZWN0KVxue1xuICAgIHZhciBoYWxmV2lkdGggPSByZWN0LndpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gMjtcblxuICAgIHZhciBjeCA9IE1hdGguYWJzKGNpcmNsZS54IC0gcmVjdC54IC0gaGFsZldpZHRoKTtcbiAgICB2YXIgeERpc3QgPSBoYWxmV2lkdGggKyBjaXJjbGUucmFkaXVzO1xuXG4gICAgaWYgKGN4IDw9IGhhbGZXaWR0aCB8fCBjeCA+IHhEaXN0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjeSA9IE1hdGguYWJzKGNpcmNsZS55IC0gcmVjdC55IC0gaGFsZkhlaWdodCk7XG4gICAgdmFyIHlEaXN0ID0gaGFsZkhlaWdodCArIGNpcmNsZS5yYWRpdXM7XG5cbiAgICBpZiAoY3kgPD0gaGFsZkhlaWdodCB8fCBjeSA+IHlEaXN0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB4Q29ybmVyRGlzdCA9IGN4IC0gaGFsZldpZHRoO1xuICAgIHZhciB5Q29ybmVyRGlzdCA9IGN5IC0gaGFsZkhlaWdodDtcbiAgICB2YXIgeENvcm5lckRpc3RTcSA9IHhDb3JuZXJEaXN0ICogeENvcm5lckRpc3Q7XG4gICAgdmFyIHlDb3JuZXJEaXN0U3EgPSB5Q29ybmVyRGlzdCAqIHlDb3JuZXJEaXN0O1xuICAgIHZhciBtYXhDb3JuZXJEaXN0U3EgPSBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cztcblxuICAgIHJldHVybiAoeENvcm5lckRpc3RTcSArIHlDb3JuZXJEaXN0U3EgPD0gbWF4Q29ybmVyRGlzdFNxKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlVG9SZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi4vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xudmFyIFJlY3RhbmdsZVRvUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1JlY3RhbmdsZScpO1xuXG52YXIgR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxue1xuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cblxuICAgIGlmIChSZWN0YW5nbGVUb1JlY3RhbmdsZShyZWN0QSwgcmVjdEIpKVxuICAgIHtcbiAgICAgICAgb3V0cHV0LnggPSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcbiAgICAgICAgb3V0cHV0LnkgPSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KTtcbiAgICAgICAgb3V0cHV0LndpZHRoID0gTWF0aC5taW4ocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIG91dHB1dC54O1xuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0gTWF0aC5taW4ocmVjdEEuYm90dG9tLCByZWN0Qi5ib3R0b20pIC0gb3V0cHV0Lnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgTGluZVRvTGluZSA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIsIGFzU2VnbWVudCwgb3V0KVxue1xuICAgIGlmIChhc1NlZ21lbnQgPT09IHVuZGVmaW5lZCkgeyBhc1NlZ21lbnQgPSB0cnVlOyB9XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICB2YXIgYSA9IGxpbmUxLngxO1xuICAgIHZhciBiID0gbGluZTEueTE7XG5cbiAgICB2YXIgZSA9IGxpbmUxLngyO1xuICAgIHZhciBmID0gbGluZTEueTI7XG5cbiAgICB2YXIgYTEgPSBiLnkgLSBhLnk7XG4gICAgdmFyIGEyID0gZi55IC0gZS55O1xuICAgIHZhciBiMSA9IGEueCAtIGIueDtcbiAgICB2YXIgYjIgPSBlLnggLSBmLng7XG4gICAgdmFyIGMxID0gKGIueCAqIGEueSkgLSAoYS54ICogYi55KTtcbiAgICB2YXIgYzIgPSAoZi54ICogZS55KSAtIChlLnggKiBmLnkpO1xuICAgIHZhciBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuICAgIGlmIChkZW5vbSA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG91dC54ID0gKChiMSAqIGMyKSAtIChiMiAqIGMxKSkgLyBkZW5vbTtcbiAgICBvdXQueSA9ICgoYTIgKiBjMSkgLSAoYTEgKiBjMikpIC8gZGVub207XG5cbiAgICBpZiAoYXNTZWdtZW50KVxuICAgIHtcbiAgICAgICAgdmFyIHVjID0gKChmLnkgLSBlLnkpICogKGIueCAtIGEueCkgLSAoZi54IC0gZS54KSAqIChiLnkgLSBhLnkpKTtcbiAgICAgICAgdmFyIHVhID0gKCgoZi54IC0gZS54KSAqIChhLnkgLSBlLnkpKSAtIChmLnkgLSBlLnkpICogKGEueCAtIGUueCkpIC8gdWM7XG4gICAgICAgIHZhciB1YiA9ICgoKGIueCAtIGEueCkgKiAoYS55IC0gZS55KSkgLSAoKGIueSAtIGEueSkgKiAoYS54IC0gZS54KSkpIC8gdWM7XG5cbiAgICAgICAgaWYgKHVhID49IDAgJiYgdWEgPD0gMSAmJiB1YiA+PSAwICYmIHViIDw9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb0xpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzIiwiLyoqXG4qIENoZWNrcyBmb3IgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIExpbmUgYW5kIGEgUmVjdGFuZ2xlIHNoYXBlLCBvciBhIHJlY3RhbmdsZS1saWtlXG4qIG9iamVjdCwgd2l0aCBwdWJsaWMgYHhgLCBgeWAsIGByaWdodGAgYW5kIGBib3R0b21gIHByb3BlcnRpZXMsIHN1Y2ggYXMgYSBTcHJpdGUgb3IgQm9keS5cbipcbiogQW4gaW50ZXJzZWN0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQgaWY6XG4qXG4qIFRoZSBsaW5lIHN0YXJ0cyB3aXRoaW4sIG9yIGVuZHMgd2l0aGluLCB0aGUgUmVjdGFuZ2xlLlxuKiBUaGUgbGluZSBzZWdtZW50IGludGVyc2VjdHMgb25lIG9mIHRoZSA0IHJlY3RhbmdsZSBlZGdlcy5cbipcbiogVGhlIGZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBmdW5jdGlvbiByZWN0YW5nbGVzIGFyZSBjb25zaWRlcmVkICdzb2xpZCcuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUuaW50ZXJzZWN0c1JlY3RhbmdsZVxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBsaW5lIC0gVGhlIGxpbmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoLlxuKiBAcGFyYW0ge1BoYXNlci5SZWN0YW5nbGV8b2JqZWN0fSByZWN0IC0gVGhlIHJlY3RhbmdsZSwgb3IgcmVjdGFuZ2xlLWxpa2Ugb2JqZWN0LCB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGguXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGxpbmUgaW50ZXJzZWN0cyB3aXRoIHRoZSByZWN0YW5nbGUgZWRnZXMsIG9yIHN0YXJ0cyBvciBlbmRzIHdpdGhpbiB0aGUgcmVjdGFuZ2xlLlxuKi9cbnZhciBMaW5lVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAobGluZSwgcmVjdClcbntcbiAgICB2YXIgeDEgPSBsaW5lLngxO1xuICAgIHZhciB5MSA9IGxpbmUueTI7XG5cbiAgICB2YXIgeDIgPSBsaW5lLngyO1xuICAgIHZhciB5MiA9IGxpbmUueTI7XG5cbiAgICB2YXIgYngxID0gcmVjdC54O1xuICAgIHZhciBieTEgPSByZWN0Lnk7XG4gICAgdmFyIGJ4MiA9IHJlY3QucmlnaHQ7XG4gICAgdmFyIGJ5MiA9IHJlY3QuYm90dG9tO1xuXG4gICAgdmFyIHQgPSAwO1xuXG4gICAgLy8gIElmIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGxpbmUgaXMgaW5zaWRlIHRoZSByZWN0IHRoZW4gd2UgYXNzdW1lXG4gICAgLy8gIGNvbGxpc2lvbiwgYXMgcmVjdHMgYXJlIHNvbGlkIGZvciBvdXIgdXNlLWNhc2UuXG5cbiAgICBpZiAoKHgxID49IGJ4MSAmJiB4MSA8PSBieDIgJiYgeTEgPj0gYnkxICYmIHkxIDw9IGJ5MikgfHxcbiAgICAgICAgKHgyID49IGJ4MSAmJiB4MiA8PSBieDIgJiYgeTIgPj0gYnkxICYmIHkyIDw9IGJ5MikpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoeDEgPCBieDEgJiYgeDIgPj0gYngxKVxuICAgIHtcbiAgICAgICAgLy8gIExlZnQgZWRnZVxuICAgICAgICB0ID0geTEgKyAoeTIgLSB5MSkgKiAoYngxIC0geDEpIC8gKHgyIC0geDEpO1xuXG4gICAgICAgIGlmICh0ID4gYnkxICYmIHQgPD0gYnkyKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh4MSA+IGJ4MiAmJiB4MiA8PSBieDIpXG4gICAge1xuICAgICAgICAvLyAgUmlnaHQgZWRnZVxuICAgICAgICB0ID0geTEgKyAoeTIgLSB5MSkgKiAoYngyIC0geDEpIC8gKHgyIC0geDEpO1xuXG4gICAgICAgIGlmICh0ID49IGJ5MSAmJiB0IDw9IGJ5MilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeTEgPCBieTEgJiYgeTIgPj0gYnkxKVxuICAgIHtcbiAgICAgICAgLy8gIFRvcCBlZGdlXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTEgLSB5MSkgLyAoeTIgLSB5MSk7XG5cbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh5MSA+IGJ5MiAmJiB5MiA8PSBieTIpXG4gICAge1xuICAgICAgICAvLyAgQm90dG9tIGVkZ2VcbiAgICAgICAgdCA9IHgxICsgKHgyIC0geDEpICogKGJ5MiAtIHkxKSAvICh5MiAtIHkxKTtcblxuICAgICAgICBpZiAodCA+PSBieDEgJiYgdCA8PSBieDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9SZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvTGluZVRvUmVjdGFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50VG9MaW5lID0gcmVxdWlyZSgnLi9Qb2ludFRvTGluZScpO1xuXG52YXIgUG9pbnRUb0xpbmVTZWdtZW50ID0gZnVuY3Rpb24gKHBvaW50LCBsaW5lKVxue1xuICAgIGlmICghUG9pbnRUb0xpbmUocG9pbnQsIGxpbmUpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB4TWluID0gTWF0aC5taW4obGluZS54MSwgbGluZS54Mik7XG4gICAgdmFyIHhNYXggPSBNYXRoLm1heChsaW5lLngxLCBsaW5lLngyKTtcbiAgICB2YXIgeU1pbiA9IE1hdGgubWluKGxpbmUueTEsIGxpbmUueTIpO1xuICAgIHZhciB5TWF4ID0gTWF0aC5tYXgobGluZS55MSwgbGluZS55Mik7XG5cbiAgICByZXR1cm4gKChwb2ludC54ID49IHhNaW4gJiYgcG9pbnQueCA8PSB4TWF4KSAmJiAocG9pbnQueSA+PSB5TWluICYmIHBvaW50LnkgPD0geU1heCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFRvTGluZVNlZ21lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qcyIsInZhciBSZWN0YW5nbGVUb1ZhbHVlcyA9IGZ1bmN0aW9uIChyZWN0LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRvbGVyYW5jZSlcbntcbiAgICBpZiAodG9sZXJhbmNlID09PSB1bmRlZmluZWQpIHsgdG9sZXJhbmNlID0gMDsgfVxuXG4gICAgcmV0dXJuICEoXG4gICAgICAgIGxlZnQgPiByZWN0LnJpZ2h0ICsgdG9sZXJhbmNlIHx8XG4gICAgICAgIHJpZ2h0IDwgcmVjdC5sZWZ0IC0gdG9sZXJhbmNlIHx8XG4gICAgICAgIHRvcCA+IHJlY3QuYm90dG9tICsgdG9sZXJhbmNlIHx8XG4gICAgICAgIGJvdHRvbSA8IHJlY3QudG9wIC0gdG9sZXJhbmNlXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlVG9WYWx1ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQ2lyY2xlVG9DaXJjbGU6IHJlcXVpcmUoJy4vQ2lyY2xlVG9DaXJjbGUnKSxcbiAgICBDaXJjbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9DaXJjbGVUb1JlY3RhbmdsZScpLFxuICAgIEdldFJlY3RhbmdsZUludGVyc2VjdGlvbjogcmVxdWlyZSgnLi9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24nKSxcbiAgICBMaW5lVG9MaW5lOiByZXF1aXJlKCcuL0xpbmVUb0xpbmUnKSxcbiAgICBMaW5lVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vTGluZVRvUmVjdGFuZ2xlJyksXG4gICAgUG9pbnRUb0xpbmU6IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmUnKSxcbiAgICBQb2ludFRvTGluZVNlZ21lbnQ6IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmVTZWdtZW50JyksXG4gICAgUmVjdGFuZ2xlVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9SZWN0YW5nbGUnKSxcbiAgICBSZWN0YW5nbGVUb1ZhbHVlczogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1ZhbHVlcycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvaW5kZXguanMiLCJcbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5KVxue1xuICAgIHZhciB0eCA9IHggLSAoKGxpbmUueDEgKyBsaW5lLngyKSAvIDIpO1xuICAgIHZhciB0eSA9IHkgLSAoKGxpbmUueTEgKyBsaW5lLnkyKSAvIDIpO1xuXG4gICAgbGluZS54MSArPSB0eDtcbiAgICBsaW5lLnkxICs9IHR5O1xuXG4gICAgbGluZS54MiArPSB0eDtcbiAgICBsaW5lLnkyICs9IHR5O1xuXG4gICAgcmV0dXJuIGxpbmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbnRlck9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcblxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcbntcbiAgICByZXR1cm4gbmV3IExpbmUoc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvQ2xvbmUuanMiLCIvKipcbiogQ29waWVzIHRoZSB4LCB5IGFuZCBkaWFtZXRlciBwcm9wZXJ0aWVzIGZyb20gYW55IGdpdmVuIG9iamVjdCB0byB0aGlzIENpcmNsZS5cbiogQG1ldGhvZCBQaGFzZXIuQ2lyY2xlI2NvcHlGcm9tXG4qIEBwYXJhbSB7YW55fSBzb3VyY2UgLSBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbS5cbiogQHJldHVybiB7Q2lyY2xlfSBUaGlzIENpcmNsZSBvYmplY3QuXG4qL1xudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcbntcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAobGluZSwgdG9Db21wYXJlKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIGxpbmUueDEgPT09IHRvQ29tcGFyZS54MSAmJlxuICAgICAgICBsaW5lLnkxID09PSB0b0NvbXBhcmUueTEgJiZcbiAgICAgICAgbGluZS54MiA9PT0gdG9Db21wYXJlLngyICYmXG4gICAgICAgIGxpbmUueTIgPT09IHRvQ29tcGFyZS55MlxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgR2V0TWlkUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgb3V0LnggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcbiAgICBvdXQueSA9IChsaW5lLnkxICsgbGluZS55MikgLyAyO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0TWlkUG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbnZhciBHZXROb3JtYWwgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIGEgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xuXG4gICAgb3V0LnggPSBNYXRoLmNvcyhhKTtcbiAgICBvdXQueSA9IE1hdGguc2luKGEpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Tm9ybWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldE5vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCIvKipcbiogVXNpbmcgQnJlc2VuaGFtJ3MgbGluZSBhbGdvcml0aG0gdGhpcyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMgb24gdGhpcyBsaW5lLlxuKiBUaGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHJvdW5kZWQgYmVmb3JlIHRoaXMgcnVucyBhcyB0aGUgYWxnb3JpdGhtIHdvcmtzIG9uIGludGVnZXJzLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5MaW5lI2Nvb3JkaW5hdGVzT25MaW5lXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcFJhdGU9MV0gLSBIb3cgbWFueSBzdGVwcyB3aWxsIHdlIHJldHVybj8gMSA9IGV2ZXJ5IGNvb3JkaW5hdGUgb24gdGhlIGxpbmUsIDIgPSBldmVyeSBvdGhlciBjb29yZGluYXRlLCBldGMuXG4qIEBwYXJhbSB7YXJyYXl9IFtyZXN1bHRzXSAtIFRoZSBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9uZSB3aWxsIGJlIGdlbmVyYXRlZC5cbiogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGNvb3JkaW5hdGVzLlxuKi9cbnZhciBHZXRQb2ludHNPbkxpbmUgPSBmdW5jdGlvbiAobGluZSwgc3RlcFJhdGUsIHJlc3VsdHMpXG57XG4gICAgaWYgKHN0ZXBSYXRlID09PSB1bmRlZmluZWQpIHsgc3RlcFJhdGUgPSAxOyB9XG4gICAgaWYgKHJlc3VsdHMgPT09IHVuZGVmaW5lZCkgeyByZXN1bHRzID0gW107IH1cblxuICAgIHZhciB4MSA9IE1hdGgucm91bmQobGluZS54MSk7XG4gICAgdmFyIHkxID0gTWF0aC5yb3VuZChsaW5lLnkxKTtcbiAgICB2YXIgeDIgPSBNYXRoLnJvdW5kKGxpbmUueDIpO1xuICAgIHZhciB5MiA9IE1hdGgucm91bmQobGluZS55Mik7XG5cbiAgICB2YXIgZHggPSBNYXRoLmFicyh4MiAtIHgxKTtcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh5MiAtIHkxKTtcbiAgICB2YXIgc3ggPSAoeDEgPCB4MikgPyAxIDogLTE7XG4gICAgdmFyIHN5ID0gKHkxIDwgeTIpID8gMSA6IC0xO1xuICAgIHZhciBlcnIgPSBkeCAtIGR5O1xuXG4gICAgcmVzdWx0cy5wdXNoKFsgeDEsIHkxIF0pO1xuXG4gICAgdmFyIGkgPSAxO1xuXG4gICAgd2hpbGUgKCEoKHgxID09PSB4MikgJiYgKHkxID09PSB5MikpKVxuICAgIHtcbiAgICAgICAgdmFyIGUyID0gZXJyIDw8IDE7XG5cbiAgICAgICAgaWYgKGUyID4gLWR5KVxuICAgICAgICB7XG4gICAgICAgICAgICBlcnIgLT0gZHk7XG4gICAgICAgICAgICB4MSArPSBzeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlMiA8IGR4KVxuICAgICAgICB7XG4gICAgICAgICAgICBlcnIgKz0gZHg7XG4gICAgICAgICAgICB5MSArPSBzeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpICUgc3RlcFJhdGUgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChbIHgxLCB5MSBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnRzT25MaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIZWlnaHQgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gTWF0aC5hYnMobGluZS55MSAtIGxpbmUueTIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvSGVpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlbmd0aCA9IGZ1bmN0aW9uIChsaW5lKVxue1xuICAgIHJldHVybiBNYXRoLnNxcnQoKGxpbmUueDIgLSBsaW5lLngxKSAqIChsaW5lLngyIC0gbGluZS54MSkgKyAobGluZS55MiAtIGxpbmUueTEpICogKGxpbmUueTIgLSBsaW5lLnkxKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlbmd0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9MZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcblxudmFyIE5vcm1hbFggPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gTWF0aC5jb3MoQW5nbGUobGluZSkgLSBNQVRIX0NPTlNULlRBVSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbFg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsWC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Ob3JtYWxYLmpzIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XG5cbnZhciBOb3JtYWxZID0gZnVuY3Rpb24gKGxpbmUpXG57XG4gICAgcmV0dXJuIE1hdGguc2luKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL05vcm1hbFkuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvTm9ybWFsWS5qcyIsInZhciBQZXJwU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gLSgobGluZS54MiAtIGxpbmUueDEpIC8gKGxpbmUueTIgLSBsaW5lLnkxKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnBTbG9wZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9QZXJwU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGxpbmUsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIHZhciB0ID0gTWF0aC5yYW5kb20oKTtcblxuICAgIG91dC54ID0gbGluZS54MSArIHQgKiAobGluZS54MiAtIGxpbmUueDEpO1xuICAgIG91dC55ID0gbGluZS55MSArIHQgKiAobGluZS55MiAtIGxpbmUueTEpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9SYW5kb20uanMiLCJ2YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XG52YXIgTm9ybWFsQW5nbGUgPSByZXF1aXJlKCcuL05vcm1hbEFuZ2xlJyk7XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSByZWZsZWN0ZWQgYW5nbGUgYmV0d2VlbiB0d28gbGluZXMuXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUucmVmbGVjdFxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBhIC0gVGhlIGJhc2UgbGluZS5cbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gYiAtIFRoZSBsaW5lIHRvIGJlIHJlZmxlY3RlZCBmcm9tIHRoZSBiYXNlIGxpbmUuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHJlZmxlY3RlZCBhbmdsZSBpbiByYWRpYW5zLlxuKi9cbnZhciBSZWZsZWN0QW5nbGUgPSBmdW5jdGlvbiAobGluZUEsIGxpbmVCKVxue1xuICAgIHJldHVybiAoMiAqIE5vcm1hbEFuZ2xlKGxpbmVCKSAtIE1hdGguUEkgLSBBbmdsZShsaW5lQSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0QW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChsaW5lLCBhbmdsZSlcbntcbiAgICB2YXIgeCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xuICAgIHZhciB5ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XG5cbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgeCwgeSwgYW5nbGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JvdGF0ZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxudmFyIFJvdGF0ZUFyb3VuZFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIHBvaW50LCBhbmdsZSlcbntcbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgcG9pbnQueCwgcG9pbnQueSwgYW5nbGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsInZhciBTZXRUb0FuZ2xlID0gZnVuY3Rpb24gKGxpbmUsIHgsIHksIGFuZ2xlLCBsZW5ndGgpXG57XG4gICAgbGluZS54MSA9IHg7XG4gICAgbGluZS55MSA9IHk7XG5cbiAgICBsaW5lLngyID0geCArIChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgpO1xuICAgIGxpbmUueTIgPSB5ICsgKE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aCk7XG5cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0VG9BbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9TZXRUb0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNsb3BlID0gZnVuY3Rpb24gKGxpbmUpXG57XG4gICAgcmV0dXJuIChsaW5lLnkyIC0gbGluZS55MSkgLyAobGluZS54MiAtIGxpbmUueDEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbG9wZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9TbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXaWR0aCA9IGZ1bmN0aW9uIChsaW5lKVxue1xuICAgIHJldHVybiBNYXRoLmFicyhsaW5lLngxIC0gbGluZS54Mik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZHRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1dpZHRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkxpbmVcblxudmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcblxuTGluZS5BbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcbkxpbmUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XG5MaW5lLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xuTGluZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcbkxpbmUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcbkxpbmUuR2V0TWlkUG9pbnQgPSByZXF1aXJlKCcuL0dldE1pZFBvaW50Jyk7XG5MaW5lLkdldE5vcm1hbCA9IHJlcXVpcmUoJy4vR2V0Tm9ybWFsJyk7XG5MaW5lLkdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRzT25MaW5lJyk7XG5MaW5lLkhlaWdodCA9IHJlcXVpcmUoJy4vSGVpZ2h0Jyk7XG5MaW5lLkxlbmd0aCA9IHJlcXVpcmUoJy4vTGVuZ3RoJyk7XG5MaW5lLk5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xuTGluZS5Ob3JtYWxYID0gcmVxdWlyZSgnLi9Ob3JtYWxYJyk7XG5MaW5lLk5vcm1hbFkgPSByZXF1aXJlKCcuL05vcm1hbFknKTtcbkxpbmUuUGVycFNsb3BlID0gcmVxdWlyZSgnLi9QZXJwU2xvcGUnKTtcbkxpbmUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcbkxpbmUuUmVmbGVjdEFuZ2xlID0gcmVxdWlyZSgnLi9SZWZsZWN0QW5nbGUnKTtcbkxpbmUuUm90YXRlID0gcmVxdWlyZSgnLi9Sb3RhdGUnKTtcbkxpbmUuUm90YXRlQXJvdW5kUG9pbnQgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFBvaW50Jyk7XG5MaW5lLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xuTGluZS5TZXRUb0FuZ2xlID0gcmVxdWlyZSgnLi9TZXRUb0FuZ2xlJyk7XG5MaW5lLlNsb3BlID0gcmVxdWlyZSgnLi9TbG9wZScpO1xuTGluZS5XaWR0aCA9IHJlcXVpcmUoJy4vV2lkdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwidmFyIEFkZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54ICs9IHg7XG4gICAgcG9pbnQueSArPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhNYXRoLmNlaWwocG9pbnQueCksIE1hdGguY2VpbChwb2ludC55KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXG57XG4gICAgcmV0dXJuIG5ldyBQb2ludChzb3VyY2UueCwgc291cmNlLnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L0Nsb25lLmpzIiwiLyoqXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxuKi9cbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXG57XG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyb3NzID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCKVxue1xuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLnkpIC0gKHBvaW50QS55ICogcG9pbnRCLngpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Nyb3NzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpdmlkZSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54IC89IHg7XG4gICAgcG9pbnQueSAvPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXZpZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0RpdmlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocG9pbnQsIHRvQ29tcGFyZSlcbntcbiAgICByZXR1cm4gKHBvaW50LnggPT09IHRvQ29tcGFyZS54ICYmIHBvaW50LnkgPT09IHRvQ29tcGFyZS55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAocG9pbnQpXG57XG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguZmxvb3IocG9pbnQueCksIE1hdGguZmxvb3IocG9pbnQueSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBHZXRDZW50cm9pZCA9IGZ1bmN0aW9uIChwb2ludHMsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA8IDEpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcnJheSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPT09IDEpXG4gICAge1xuICAgICAgICBvdXQueCA9IHBvaW50c1swXS54O1xuICAgICAgICBvdXQueSA9IHBvaW50c1swXS55O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBvdXQueCArPSBwb2ludHNbaV0ueDtcbiAgICAgICAgICAgIG91dC55ICs9IHBvaW50c1tpXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LnggLz0gbGVuO1xuICAgICAgICBvdXQueSAvPSBsZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudHJvaWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIEludGVycG9sYXRlID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCB0LCBvdXQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgb3V0LnggPSBwb2ludEEueCArICgocG9pbnRCLnggLSBwb2ludEEueCkgKiB0KTtcbiAgICBvdXQueSA9IHBvaW50QS55ICsgKChwb2ludEIueSAtIHBvaW50QS55KSAqIHQpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJwb2xhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgSW52ZXJ0ID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCBwb2ludC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW52ZXJ0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBOZWdhdGl2ZSA9IGZ1bmN0aW9uIChwb2ludCwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTmVnYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwidmFyIE5vcm1hbGl6ZVJpZ2h0SGFuZCA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSAqIC0xLCBwb2ludC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplUmlnaHRIYW5kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVycCA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9QZXJwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG52YXIgR2V0TWFnbml0dWRlU3EgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZVNxJyk7XG5cbnZhciBQcm9qZWN0ID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKSAvIEdldE1hZ25pdHVkZVNxKHBvaW50Qik7XG5cbiAgICBpZiAoYW10ICE9PSAwKVxuICAgIHtcbiAgICAgICAgb3V0LnggPSBhbXQgKiBwb2ludEIueDtcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBQcm9qZWN0VW5pdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50Qik7XG5cbiAgICBpZiAoYW10ICE9PSAwKVxuICAgIHtcbiAgICAgICAgb3V0LnggPSBhbXQgKiBwb2ludEIueDtcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0VW5pdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwidmFyIFJQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCAtcG9pbnQueCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJQZXJwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9SUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xudmFyIE11bHRpcGx5ID0gcmVxdWlyZSgnLi9NdWx0aXBseScpO1xuXG52YXIgU2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50LCBtYWduaXR1ZGUpXG57XG4gICAgTm9ybWFsaXplKHBvaW50KTtcblxuICAgIHJldHVybiBNdWx0aXBseShwb2ludCwgbWFnbml0dWRlLCBtYWduaXR1ZGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRNYWduaXR1ZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwidmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxue1xuICAgIHBvaW50LnggLT0geDtcbiAgICBwb2ludC55IC09IHk7XG5cbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxuXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cblBvaW50LkFkZCA9IHJlcXVpcmUoJy4vQWRkJyk7XG5Qb2ludC5DZWlsID0gcmVxdWlyZSgnLi9DZWlsJyk7XG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcblBvaW50LkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xuUG9pbnQuQ3Jvc3MgPSByZXF1aXJlKCcuL0Nyb3NzJyk7XG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xuUG9pbnQuRG90ID0gcmVxdWlyZSgnLi9Eb3QnKTtcblBvaW50LkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcblBvaW50LkdldENlbnRyb2lkID0gcmVxdWlyZSgnLi9HZXRDZW50cm9pZCcpO1xuUG9pbnQuR2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGUnKTtcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xuUG9pbnQuSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL0ludGVycG9sYXRlJyk7XG5Qb2ludC5JbnZlcnQgPSByZXF1aXJlKCcuL0ludmVydCcpO1xuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XG5Qb2ludC5OZWdhdGl2ZSA9IHJlcXVpcmUoJy4vTmVnYXRpdmUnKTtcblBvaW50Lk5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vTm9ybWFsaXplJyk7XG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xuUG9pbnQuUGVycCA9IHJlcXVpcmUoJy4vUGVycCcpO1xuUG9pbnQuUHJvamVjdCA9IHJlcXVpcmUoJy4vUHJvamVjdCcpO1xuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XG5Qb2ludC5SUGVycCA9IHJlcXVpcmUoJy4vUlBlcnAnKTtcblBvaW50LlNldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vU2V0TWFnbml0dWRlJyk7XG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L2luZGV4LmpzIiwidmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblxudmFyIENsb25lID0gZnVuY3Rpb24gKHBvbHlnb24pXG57XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvbHlnb24ucG9pbnRzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5cbi8qKlxuKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4qXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXG4qL1xudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXG57XG4gICAgcmV0dXJuIENvbnRhaW5zKHBvbHlnb24sIHBvaW50LngsIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIlxudmFyIEdldEFBQkIgPSBmdW5jdGlvbiAocG9seWdvbilcbntcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtbWluWDtcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xuICAgIHZhciBwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHAgPSBwb2x5Z29uLnBvaW50c1tpXTtcblxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcC54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHAueSk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcC55KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBtaW5YLFxuICAgICAgICB5OiBtaW5ZLFxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldEFBQkIuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEV4cG9ydCB0aGUgcG9pbnRzIGFzIGFuIGFycmF5IG9mIGZsYXQgbnVtYmVycywgZm9sbG93aW5nIHRoZSBzZXF1ZW5jZSBbIHgseSwgeCx5LCB4LHkgXVxuICpcbiAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jdG9OdW1iZXJBcnJheVxuICogQHBhcmFtIHthcnJheX0gW291dHB1dF0gLSBUaGUgYXJyYXkgdG8gYXBwZW5kIHRoZSBwb2ludHMgdG8uIElmIG5vdCBzcGVjaWZpZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbnZhciBHZXROdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChwb2x5Z29uLCBvdXRwdXQpXG57XG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFtdOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocG9seWdvbi5wb2ludHNbaV0ueCk7XG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE51bWJlckFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLlBvbHlnb25cblxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblxuUG9seWdvbi5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcblBvbHlnb24uQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5Qb2x5Z29uLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcblBvbHlnb24uR2V0QUFCQiA9IHJlcXVpcmUoJy4vR2V0QUFCQicpO1xuUG9seWdvbi5HZXROdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4vR2V0TnVtYmVyQXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZXR1cm4gcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHJlY3QpXG57XG4gICAgcmVjdC54ID0gTWF0aC5jZWlsKHJlY3QueCk7XG4gICAgcmVjdC55ID0gTWF0aC5jZWlsKHJlY3QueSk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbEFsbCA9IGZ1bmN0aW9uIChyZWN0KVxue1xuICAgIHJlY3QueCA9IE1hdGguY2VpbChyZWN0LngpO1xuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xuICAgIHJlY3Qud2lkdGggPSBNYXRoLmNlaWwocmVjdC53aWR0aCk7XG4gICAgcmVjdC5oZWlnaHQgPSBNYXRoLmNlaWwocmVjdC5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxBbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENlbnRlcnMgdGhpcyBSZWN0YW5nbGUgc28gdGhhdCB0aGUgY2VudGVyIGNvb3JkaW5hdGVzIG1hdGNoIHRoZSBnaXZlbiB4IGFuZCB5IHZhbHVlcy5cbipcbiogQG1ldGhvZCBQaGFzZXIuUmVjdGFuZ2xlI2NlbnRlck9uXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXG4qIEByZXR1cm4ge1BoYXNlci5SZWN0YW5nbGV9IFRoaXMgUmVjdGFuZ2xlIG9iamVjdFxuKi9cbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxue1xuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xuICAgIHJlY3QueSA9IHkgLSAocmVjdC5oZWlnaHQgLyAyKTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5cbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHJlY3QsIHBvaW50KVxue1xuICAgIHJldHVybiBDb250YWlucyhyZWN0LCBwb2ludC54LCBwb2ludC55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzIiwiLy8gIENoZWNrcyBpZiByZWN0QiBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIHJlY3RBXG5cbnZhciBDb250YWluc1JlY3QgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxue1xuICAgIC8vICBWb2x1bWUgY2hlY2sgKGlmIHJlY3RCIHZvbHVtZSA+IHJlY3RBIHRoZW4gcmVjdEEgY2Fubm90IGNvbnRhaW4gaXQpXG4gICAgaWYgKChyZWN0Qi53aWR0aCAqIHJlY3RCLmhlaWdodCkgPiAocmVjdEEud2lkdGggKiByZWN0QS5oZWlnaHQpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVyblxuICAgICAgICAoXG4gICAgICAgICAgICAocmVjdEIueCA+IHJlY3RBLnggJiYgcmVjdEIueCA8IHJlY3RBLnJpZ2h0KSAmJiBcbiAgICAgICAgICAgIChyZWN0Qi5yaWdodCA+IHJlY3RBLnggJiYgcmVjdEIucmlnaHQgPCByZWN0QS5yaWdodClcbiAgICAgICAgKSAmJiAoXG4gICAgICAgICAgICAocmVjdEIueSA+IHJlY3RBLnkgJiYgcmVjdEIueSA8IHJlY3RBLmJvdHRvbSkgJiYgXG4gICAgICAgICAgICAocmVjdEIuYm90dG9tID4gcmVjdEEueSAmJiByZWN0Qi5ib3R0b20gPCByZWN0QS5ib3R0b20pXG4gICAgICAgICk7XG4gICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxue1xuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocmVjdCwgdG9Db21wYXJlKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIHJlY3QueCA9PT0gdG9Db21wYXJlLnggJiZcbiAgICAgICAgcmVjdC55ID09PSB0b0NvbXBhcmUueSAmJlxuICAgICAgICByZWN0LndpZHRoID09PSB0b0NvbXBhcmUud2lkdGggJiZcbiAgICAgICAgcmVjdC5oZWlnaHQgPT09IHRvQ29tcGFyZS5oZWlnaHRcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0QXNwZWN0UmF0aW8gPSByZXF1aXJlKCcuL0dldEFzcGVjdFJhdGlvJyk7XG5cbi8vICBGaXRzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIGludG8gdGhlIHNvdXJjZSByZWN0YW5nbGUuXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpby5cbi8vICBTY2FsZXMgYW5kIGNlbnRlcnMgdGhlIHRhcmdldCByZWN0YW5nbGUgdG8gdGhlIHNvdXJjZSByZWN0YW5nbGVcblxudmFyIEZpdEluc2lkZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcbntcbiAgICB2YXIgcmF0aW8gPSBHZXRBc3BlY3RSYXRpbyh0YXJnZXQpO1xuXG4gICAgaWYgKHJhdGlvIDwgR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcbiAgICB7XG4gICAgICAgIC8vICBUYWxsZXIgdGhhbiBXaWRlXG4gICAgICAgIHRhcmdldC5zZXRTaXplKHNvdXJjZS5oZWlnaHQgKiByYXRpbywgc291cmNlLmhlaWdodCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vICBXaWRlciB0aGFuIFRhbGxcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLndpZHRoLCBzb3VyY2Uud2lkdGggKiByYXRpbyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zZXRQb3NpdGlvbihcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gKHRhcmdldC53aWR0aCAvIDIpLFxuICAgICAgICAoc291cmNlLmJvdHRvbSAvIDIpIC0gKHRhcmdldC5oZWlnaHQgLyAyKVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpdEluc2lkZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdEluc2lkZS5qcyIsInZhciBHZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcblxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgYXJvdW5kIHRoZSBzb3VyY2UgcmVjdGFuZ2xlLlxuLy8gIFByZXNlcnZlcyBhc3BlY3QgcmF0aW9uLlxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxuXG52YXIgRml0T3V0c2lkZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSlcbntcbiAgICB2YXIgcmF0aW8gPSBHZXRBc3BlY3RSYXRpbyh0YXJnZXQpO1xuXG4gICAgaWYgKHJhdGlvID4gR2V0QXNwZWN0UmF0aW8oc291cmNlKSlcbiAgICB7XG4gICAgICAgIC8vICBXaWRlciB0aGFuIFRhbGxcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gIFRhbGxlciB0aGFuIFdpZGVcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLndpZHRoLCBzb3VyY2Uud2lkdGggKiByYXRpbyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zZXRQb3NpdGlvbihcbiAgICAgICAgKHNvdXJjZS5yaWdodCAvIDIpIC0gdGFyZ2V0LndpZHRoIC8gMixcbiAgICAgICAgKHNvdXJjZS5ib3R0b20gLyAyKSAtIHRhcmdldC5oZWlnaHQgLyAyXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRml0T3V0c2lkZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKHJlY3QpXG57XG4gICAgcmVjdC54ID0gTWF0aC5mbG9vcihyZWN0LngpO1xuICAgIHJlY3QueSA9IE1hdGguZmxvb3IocmVjdC55KTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yQWxsID0gZnVuY3Rpb24gKHJlY3QpXG57XG4gICAgcmVjdC54ID0gTWF0aC5mbG9vcihyZWN0LngpO1xuICAgIHJlY3QueSA9IE1hdGguZmxvb3IocmVjdC55KTtcbiAgICByZWN0LndpZHRoID0gTWF0aC5mbG9vcihyZWN0LndpZHRoKTtcbiAgICByZWN0LmhlaWdodCA9IE1hdGguZmxvb3IocmVjdC5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yQWxsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3JBbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIGNlbnRlciBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxuXG52YXIgR2V0Q2VudGVyID0gZnVuY3Rpb24gKHJlY3QsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cblxuICAgIG91dC54ID0gcmVjdC5yaWdodCAvIDI7XG4gICAgb3V0LnkgPSByZWN0LmJvdHRvbSAvIDI7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRDZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgVGhlIHNpemUgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QsIGV4cHJlc3NlZCBhcyBhIFBvaW50IG9iamVjdCBcbi8vICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cblxudmFyIEdldFNpemUgPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxuXG4gICAgb3V0LnggPSByZWN0LndpZHRoO1xuICAgIG91dC55ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRTaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvR2V0U2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBJbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3QgYnkgdGhlIHNwZWNpZmllZCBhbW91bnRzLlxuLy8gIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIFJlY3RhbmdsZSBvYmplY3Qgc3RheXMgdGhlIHNhbWUsIGFuZCBpdHMgc2l6ZSBpbmNyZWFzZXMgXG4vLyAgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IHRoZSB4IHZhbHVlLCBhbmQgdG8gdGhlIHRvcCBhbmQgdGhlIGJvdHRvbSBieSB0aGUgeSB2YWx1ZS5cblxudmFyIEluZmxhdGUgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcbntcbiAgICAvLyAgR2V0IHRoZSBjdXJyZW50IGNlbnRlclxuICAgIHZhciBjeCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XG4gICAgdmFyIGN5ID0gcmVjdC55ICsgKHJlY3QuaGVpZ2h0IC8gMik7XG5cbiAgICAvLyAgSW5mbGF0ZVxuICAgIHJlY3Qud2lkdGggPSAyICogeDtcbiAgICByZWN0LmhlaWdodCA9IDIgKiB5O1xuXG4gICAgcmVjdC54ID0geCAtIChyZWN0LndpZHRoIC8gMik7XG4gICAgcmVjdC55ID0geSAtIChyZWN0LmhlaWdodCAvIDIpO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZmxhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9JbmZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE1lcmdlcyB0aGUgdGFyZ2V0IFJlY3RhbmdsZSB3aXRoIGEgbGlzdCBvZiBwb2ludHMuXG4vLyAgVGhlIHBvaW50cyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLlxuXG52YXIgTWVyZ2VQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBwb2ludHMpXG57XG4gICAgdmFyIG1pblggPSB0YXJnZXQueDtcbiAgICB2YXIgbWF4WCA9IHRhcmdldC5yaWdodDtcbiAgICB2YXIgbWluWSA9IHRhcmdldC55O1xuICAgIHZhciBtYXhZID0gdGFyZ2V0LmJvdHRvbTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHBvaW50c1tpXS54KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHBvaW50c1tpXS54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHBvaW50c1tpXS55KTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHBvaW50c1tpXS55KTtcbiAgICB9XG5cbiAgICB0YXJnZXQueCA9IG1pblg7XG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUG9pbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VQb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgTWVyZ2VzIHNvdXJjZSByZWN0YW5nbGUgaW50byB0YXJnZXQgcmVjdGFuZ2xlIGFuZCByZXR1cm5zIHRhcmdldFxuLy8gIE5laXRoZXIgcmVjdCBzaG91bGQgaGF2ZSBuZWdhdGl2ZSB3aWR0aHMgb3IgaGVpZ2h0c1xuXG52YXIgTWVyZ2VSZWN0ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxue1xuICAgIHZhciBtaW5YID0gTWF0aC5taW4odGFyZ2V0LngsIHNvdXJjZS54KTtcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KHRhcmdldC5yaWdodCwgc291cmNlLnJpZ2h0KTtcblxuICAgIHRhcmdldC54ID0gbWluWDtcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIHZhciBtaW5ZID0gTWF0aC5taW4odGFyZ2V0LnksIHNvdXJjZS55KTtcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHRhcmdldC5ib3R0b20sIHNvdXJjZS5ib3R0b20pO1xuXG4gICAgdGFyZ2V0LnkgPSBtaW5ZO1xuICAgIHRhcmdldC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIE1lcmdlWFkgPSBmdW5jdGlvbiAodGFyZ2V0LCB4LCB5KVxue1xuICAgIHZhciBtaW5YID0gTWF0aC5taW4odGFyZ2V0LngsIHgpO1xuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCB4KTtcblxuICAgIHRhcmdldC54ID0gbWluWDtcbiAgICB0YXJnZXQud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIHZhciBtaW5ZID0gTWF0aC5taW4odGFyZ2V0LnksIHkpO1xuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgeSk7XG5cbiAgICB0YXJnZXQueSA9IG1pblk7XG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VYWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXG57XG4gICAgcmVjdC54ICs9IHg7XG4gICAgcmVjdC55ICs9IHk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9mZnNldFBvaW50ID0gZnVuY3Rpb24gKHJlY3QsIHBvaW50KVxue1xuICAgIHJlY3QueCArPSBwb2ludC54O1xuICAgIHJlY3QueSArPSBwb2ludC55O1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9mZnNldFBvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIHJlY3RBLnggPCByZWN0Qi5yaWdodCAmJiBcbiAgICAgICAgcmVjdEEucmlnaHQgPiByZWN0Qi54ICYmIFxuICAgICAgICByZWN0QS55IDwgcmVjdEIuYm90dG9tICYmIFxuICAgICAgICByZWN0QS5ib3R0b20gPiByZWN0Qi55XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PdmVybGFwcy5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJpbWV0ZXIgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZXR1cm4gMiAqIChyZWN0LndpZHRoICsgcmVjdC5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJpbWV0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKHJlY3QsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIG91dC54ID0gcmVjdC54ICsgKE1hdGgucmFuZG9tKCkgKiByZWN0LndpZHRoKTtcbiAgICBvdXQueSA9IHJlY3QueSArIChNYXRoLnJhbmRvbSgpICogcmVjdC5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwiLyoqXG4qIFNjYWxlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGlzIFJlY3RhbmdsZSBieSB0aGUgZ2l2ZW4gYW1vdW50cy5cbiogXG4qIEBtZXRob2QgUGhhc2VyLlJlY3RhbmdsZSNzY2FsZVxuKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUgYnkuIEEgdmFsdWUgb2YgMC41IHdvdWxkIHJlZHVjZSBieSBoYWxmLCBhIHZhbHVlIG9mIDIgd291bGQgZG91YmxlIHRoZSB3aWR0aCwgZXRjLlxuKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUgYnkuIEEgdmFsdWUgb2YgMC41IHdvdWxkIHJlZHVjZSBieSBoYWxmLCBhIHZhbHVlIG9mIDIgd291bGQgZG91YmxlIHRoZSBoZWlnaHQsIGV0Yy5cbiogQHJldHVybiB7UGhhc2VyLlJlY3RhbmdsZX0gVGhpcyBSZWN0YW5nbGUgb2JqZWN0XG4qL1xudmFyIFNjYWxlID0gZnVuY3Rpb24gKHJlY3QsIHgsIHkpXG57XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxuXG4gICAgcmVjdC53aWR0aCAqPSB4O1xuICAgIHJlY3QuaGVpZ2h0ICo9IHk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG52YXIgVW5pb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXG57XG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFJlY3RhbmdsZSgpOyB9XG5cbiAgICB2YXIgeCA9IE1hdGgubWluKHJlY3RBLngsIHJlY3RCLngpO1xuICAgIHZhciB5ID0gTWF0aC5taW4ocmVjdEEueSwgcmVjdEIueSk7XG5cbiAgICByZXR1cm4gb3V0cHV0LnNldChcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgTWF0aC5tYXgocmVjdEEucmlnaHQsIHJlY3RCLnJpZ2h0KSAtIHgsXG4gICAgICAgIE1hdGgubWF4KHJlY3RBLmJvdHRvbSwgcmVjdEIuYm90dG9tKSAtIHlcbiAgICApO1xuICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCIvLyAgUGhhc2VyLkdlb20uUmVjdGFuZ2xlXG5cbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpO1xuXG5SZWN0YW5nbGUuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xuUmVjdGFuZ2xlLkNlaWwgPSByZXF1aXJlKCcuL0NlaWwnKTtcblJlY3RhbmdsZS5DZWlsQWxsID0gcmVxdWlyZSgnLi9DZWlsQWxsJyk7XG5SZWN0YW5nbGUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XG5SZWN0YW5nbGUuQ2xvbmUgPSByZXF1aXJlKCcuL0Nsb25lJyk7XG5SZWN0YW5nbGUuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5SZWN0YW5nbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xuUmVjdGFuZ2xlLkNvbnRhaW5zUmVjdCA9IHJlcXVpcmUoJy4vQ29udGFpbnNSZWN0Jyk7XG5SZWN0YW5nbGUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XG5SZWN0YW5nbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcblJlY3RhbmdsZS5GaXRJbnNpZGUgPSByZXF1aXJlKCcuL0ZpdEluc2lkZScpO1xuUmVjdGFuZ2xlLkZpdE91dHNpZGUgPSByZXF1aXJlKCcuL0ZpdE91dHNpZGUnKTtcblJlY3RhbmdsZS5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcblJlY3RhbmdsZS5GbG9vckFsbCA9IHJlcXVpcmUoJy4vRmxvb3JBbGwnKTtcblJlY3RhbmdsZS5HZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcblJlY3RhbmdsZS5HZXRDZW50ZXIgPSByZXF1aXJlKCcuL0dldENlbnRlcicpO1xuUmVjdGFuZ2xlLkdldFNpemUgPSByZXF1aXJlKCcuL0dldFNpemUnKTtcblJlY3RhbmdsZS5JbmZsYXRlID0gcmVxdWlyZSgnLi9JbmZsYXRlJyk7XG5SZWN0YW5nbGUuTWVyZ2VQb2ludHMgPSByZXF1aXJlKCcuL01lcmdlUG9pbnRzJyk7XG5SZWN0YW5nbGUuTWVyZ2VSZWN0ID0gcmVxdWlyZSgnLi9NZXJnZVJlY3QnKTtcblJlY3RhbmdsZS5NZXJnZVhZID0gcmVxdWlyZSgnLi9NZXJnZVhZJyk7XG5SZWN0YW5nbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcblJlY3RhbmdsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcblJlY3RhbmdsZS5PdmVybGFwcyA9IHJlcXVpcmUoJy4vT3ZlcmxhcHMnKTtcblJlY3RhbmdsZS5QZXJpbWV0ZXIgPSByZXF1aXJlKCcuL1BlcmltZXRlcicpO1xuUmVjdGFuZ2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XG5SZWN0YW5nbGUuU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5SZWN0YW5nbGUuVW5pb24gPSByZXF1aXJlKCcuL1VuaW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4uL3N0cnVjdHMvU2V0Jyk7XG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50cy8nKTtcbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XG5cbnZhciBCYXNlTG9hZGVyID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyAgVG8gZmluaXNoIHRoZSBsb2FkZXIgLi4uXG4gICAgLy8gIFxuICAgIC8vICAzKSBQcm9ncmVzcyB1cGRhdGVcbiAgICAvLyAgNCkgSlNPTiBsb2FkZXJcbiAgICAvLyAgNSkgWE1MIExvYWRlclxuICAgIC8vICA2KSBNdWx0aSBGaWxlIHN1cHBvcnQgKGF0bGFzICsgZGF0YSlcbiAgICAvLyAgNykgQXRsYXMgTG9hZGVyXG5cbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIC8vICBNb3ZlIHRvIGEgJ3NldFVSTCcgbWV0aG9kP1xuICAgIHRoaXMuYmFzZVVSTCA9ICcnO1xuICAgIHRoaXMucGF0aCA9ICcnO1xuXG4gICAgLy8gIFJlYWQgZnJvbSBHYW1lIC8gU3RhdGUgQ29uZmlnXG4gICAgdGhpcy5lbmFibGVQYXJhbGxlbCA9IHRydWU7XG4gICAgdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcyA9IDQ7XG5cbiAgICAvLyAgeGhyIHNwZWNpZmljIGdsb2JhbCBzZXR0aW5ncyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXItZmlsZSBiYXNpcylcbiAgICB0aGlzLnhociA9IFhIUlNldHRpbmdzKCk7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5saXN0ID0gbmV3IFNldCgpO1xuICAgIHRoaXMuaW5mbGlnaHQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5mYWlsZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgU2V0KCk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xufTtcblxuQmFzZUxvYWRlci5wcm90b3R5cGUuY29udHJ1Y3RvciA9IEJhc2VMb2FkZXI7XG5cbkJhc2VMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgYWRkRmlsZTogZnVuY3Rpb24gKGZpbGUpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWFkeSgpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBmaWxlLnBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgICAgdGhpcy5saXN0LnNldChmaWxlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIElzIHRoZSBMb2FkZXIgYWN0aXZlbHkgbG9hZGluZyAob3IgcHJvY2Vzc2luZyBsb2FkZWQgZmlsZXMpXG4gICAgaXNMb2FkaW5nOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0xPQURJTkcgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9QUk9DRVNTSU5HKTtcbiAgICB9LFxuXG4gICAgLy8gIElzIHRoZSBMb2FkZXIgcmVhZHkgdG8gc3RhcnQgYSBuZXcgbG9hZD9cbiAgICBpc1JlYWR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0lETEUgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9DT01QTEVURSB8fCB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX0ZBSUxFRCk7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Jhc2VMb2FkZXIgc3RhcnQuIEZpbGVzIHRvIGxvYWQ6JywgdGhpcy5saXN0LnNpemUpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudC5MT0FERVJfU1RBUlRfRVZFTlQodGhpcykpO1xuXG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2l6ZSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX0xPQURJTkc7XG5cbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHRoaXMucXVldWUuZGVidWcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKCk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoKVxuICAgIHtcblxuICAgIH0sXG5cbiAgICBwcm9jZXNzTG9hZFF1ZXVlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09PT09PT09IEJhc2VMb2FkZXIgcHJvY2Vzc0xvYWRRdWV1ZScpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTGlzdCBzaXplJywgdGhpcy5saXN0LnNpemUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmluZmxpZ2h0LnNpemUsICdpdGVtcyBzdGlsbCBpbiBmbGlnaHQuIENhbiBsb2FkIGFub3RoZXInLCAodGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcyAtIHRoaXMuaW5mbGlnaHQuc2l6ZSkpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5saXN0LmVhY2goZnVuY3Rpb24gKGZpbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX1BFTkRJTkcgJiYgX3RoaXMuaW5mbGlnaHQuc2l6ZSA8IF90aGlzLm1heFBhcmFsbGVsRG93bmxvYWRzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzLmluZmxpZ2h0LnNldChmaWxlKTtcblxuICAgICAgICAgICAgICAgIF90aGlzLmxpc3QuZGVsZXRlKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pbmZsaWdodC5zaXplID09PSBfdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGVsbHMgdGhlIFNldCBpdGVyYXRvciB0byBhYm9ydFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gIHByaXZhdGVcbiAgICBsb2FkRmlsZTogZnVuY3Rpb24gKGZpbGUpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTE9BRElORycsIGZpbGUua2V5KTtcblxuICAgICAgICAvLyAgSWYgdGhlIGZpbGUgZG9lc24ndCBoYXZlIGl0cyBvd24gY3Jvc3NPcmlnaW4gc2V0LFxuICAgICAgICAvLyAgd2UnbGwgdXNlIHRoZSBMb2FkZXJzICh3aGljaCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdClcbiAgICAgICAgaWYgKCFmaWxlLmNyb3NzT3JpZ2luKVxuICAgICAgICB7XG4gICAgICAgICAgICBmaWxlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGUubG9hZCh0aGlzLm5leHRGaWxlLmJpbmQodGhpcyksIHRoaXMuYmFzZVVSTCk7XG4gICAgfSxcblxuICAgIG5leHRGaWxlOiBmdW5jdGlvbiAocHJldmlvdXNGaWxlLCBzdWNjZXNzKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPQURFRDonLCBwcmV2aW91c0ZpbGUuc3JjLCBzdWNjZXNzKTtcblxuICAgICAgICAvLyAgTW92ZSB0aGUgZmlsZSB0aGF0IGp1c3QgbG9hZGVkIGZyb20gdGhlIGluZmxpZ2h0IGxpc3QgdG8gdGhlIHF1ZXVlIG9yIGZhaWxlZCBTZXRcblxuICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5zZXQocHJldmlvdXNGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChwcmV2aW91c0ZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbmZsaWdodC5kZWxldGUocHJldmlvdXNGaWxlKTtcblxuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV4dEZpbGUgLSBzdGlsbCBzb21ldGhpbmcgaW4gdGhlIGxpc3QnKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xvYWRRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5mbGlnaHQuc2l6ZSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIGNhbGxpbmcgZmluaXNoZWRMb2FkaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkTG9hZGluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaGVkTG9hZGluZzogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IEJhc2VMb2FkZXIuZmluaXNoZWRMb2FkaW5nIFBST0NFU1NJTkcnLCB0aGlzLnF1ZXVlLnNpemUsICdmaWxlcycpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkc7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLnF1ZXVlLmVhY2goZnVuY3Rpb24gKGZpbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyBDYWxsaW5nIHByb2Nlc3Mgb24gJyArIGZpbGUua2V5LCAnY29sb3I6ICMwMDAwMDA7IGJhY2tncm91bmQ6ICNmZmZmMDA7Jyk7XG5cbiAgICAgICAgICAgIGZpbGUub25Qcm9jZXNzKF90aGlzLnByb2Nlc3NVcGRhdGUuYmluZChfdGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBGaWxlIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcbiAgICBwcm9jZXNzVXBkYXRlOiBmdW5jdGlvbiAoZmlsZSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctPiBwcm9jZXNzVXBkYXRlJywgZmlsZS5rZXksIGZpbGUuc3RhdGUpO1xuXG4gICAgICAgIC8vICBUaGlzIGZpbGUgaGFzIGZhaWxlZCB0byBsb2FkLCBzbyBtb3ZlIGl0IHRvIHRoZSBmYWlsZWQgU2V0XG4gICAgICAgIGlmIChmaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0VSUk9SRUQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkLnNldChmaWxlKTtcblxuICAgICAgICAgICAgaWYgKGZpbGUubGlua0ZpbGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZS5saW5rRmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB0aGUgZmlsZSBsb2FkZWRcblxuICAgICAgICAvLyAgU3BlY2lhbCBoYW5kbGluZyBmb3IgbXVsdGktcGFydCBmaWxlc1xuXG4gICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9DT01QTEVURSAmJiBmaWxlLmxpbmtGaWxlLnN0YXRlID09PSBDT05TVC5GSUxFX0NPTVBMRVRFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBQYXJ0bmVyIGhhcyBsb2FkZWQsIHNvIGFkZCB0aGVtIGJvdGggdG8gU3RvcmFnZVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh7IHR5cGU6IGZpbGUubGlua1R5cGUsIGZpbGVBOiBmaWxlLCBmaWxlQjogZmlsZS5saW5rRmlsZSB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUubGlua0ZpbGUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShmaWxlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tUXVldWU6IGZ1bmN0aW9uIChmaWxlKVxuICAgIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5kZWxldGUoZmlsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUuc2l6ZSA9PT0gMCAmJiB0aGlzLl9zdGF0ZSA9PT0gQ09OU1QuTE9BREVSX1BST0NFU1NJTkcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBXZSd2ZSBwcm9jZXNzZWQgYWxsIHRoZSBmaWxlcyB3ZSBsb2FkZWRcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvY2Vzc0NvbXBsZXRlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRlciBDb21wbGV0ZS4gTG9hZGVkOicsIHRoaXMuc3RvcmFnZS5zaXplLCAnRmFpbGVkOicsIHRoaXMuZmFpbGVkLnNpemUpO1xuXG4gICAgICAgIHRoaXMubGlzdC5jbGVhcigpO1xuICAgICAgICB0aGlzLmluZmxpZ2h0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMucXVldWUuY2xlYXIoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzQ2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9DT01QTEVURTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX0NPTVBMRVRFX0VWRU5UKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xuICAgICAgICB0aGlzLmZhaWxlZC5jbGVhcigpO1xuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMudGFnID0gJyc7XG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSAnJztcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9ERVNUUk9ZRUQ7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwidmFyIEdldFVSTCA9IGZ1bmN0aW9uIChmaWxlLCBiYXNlVVJMKVxue1xuICAgIGlmICghZmlsZS51cmwpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZpbGUudXJsLm1hdGNoKC9eKD86YmxvYjp8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfFxcL1xcLykvKSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmaWxlLnVybDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBmaWxlLnVybDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFVSTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xuXG52YXIgWEhSTG9hZGVyID0gZnVuY3Rpb24gKGZpbGUsIGdsb2JhbFhIUlNldHRpbmdzKVxue1xuICAgIHZhciBjb25maWcgPSBNZXJnZVhIUlNldHRpbmdzKGdsb2JhbFhIUlNldHRpbmdzLCBmaWxlLnhoclNldHRpbmdzKTtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLnNyYywgY29uZmlnLmFzeW5jLCBjb25maWcudXNlciwgY29uZmlnLnBhc3N3b3JkKTtcblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmaWxlLnhoclNldHRpbmdzLnJlc3BvbnNlVHlwZTtcbiAgICB4aHIudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgaWYgKGNvbmZpZy5oZWFkZXIgJiYgY29uZmlnLmhlYWRlclZhbHVlKVxuICAgIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXG4gICAge1xuICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShjb25maWcub3ZlcnJpZGVNaW1lVHlwZSk7XG4gICAgfVxuXG4gICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlcXVlc3QsIHRoZSB4aHIucmVzcG9uc2UgcHJvcGVydHkgd2lsbCBjb250YWluIHRoZSByZXF1ZXN0ZWQgZGF0YSBhcyBhIERPTVN0cmluZywgQXJyYXlCdWZmZXIsIEJsb2IsIG9yIERvY3VtZW50IChkZXBlbmRpbmcgb24gd2hhdCB3YXMgc2V0IGZvciByZXNwb25zZVR5cGUuKVxuXG4gICAgeGhyLm9ubG9hZCA9IGZpbGUub25Mb2FkLmJpbmQoZmlsZSk7XG4gICAgeGhyLm9uZXJyb3IgPSBmaWxlLm9uRXJyb3IuYmluZChmaWxlKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xuXG4gICAgLy8gIFRoaXMgaXMgdGhlIG9ubHkgc3RhbmRhcmQgbWV0aG9kLCB0aGUgb25lcyBhYm92ZSBhcmUgYnJvd3NlciBhZGRpdGlvbnMgKG1heWJlIG5vdCB1bml2ZXJzYWw/KVxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcblxuICAgIHhoci5zZW5kKCk7XG5cbiAgICByZXR1cm4geGhyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvWEhSTG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL1hIUkxvYWRlci5qcyIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudCcpO1xuXG52YXIgTG9hZGVyQ29tcGxldGVFdmVudCA9IGZ1bmN0aW9uIChsb2FkZXIpXG57XG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XG5cbiAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbn07XG5cbkxvYWRlckNvbXBsZXRlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlckNvbXBsZXRlRXZlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcblxudmFyIExvYWRlclN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAobG9hZGVyKVxue1xuICAgIEV2ZW50LmNhbGwodGhpcywgJ0xPQURFUl9TVEFSVF9FVkVOVCcpO1xuXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG59O1xuXG5Mb2FkZXJTdGFydEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcbkxvYWRlclN0YXJ0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyU3RhcnRFdmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJTdGFydEV2ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBMT0FERVJfU1RBUlRfRVZFTlQ6IHJlcXVpcmUoJy4vTG9hZGVyU3RhcnRFdmVudCcpLFxuICAgIExPQURFUl9DT01QTEVURV9FVkVOVDogcmVxdWlyZSgnLi9Mb2FkZXJDb21wbGV0ZUV2ZW50JylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuL0pTT05GaWxlLmpzJyk7XG5cbnZhciBBdGxhc0pTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcbntcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdGV4dHVyZVVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcbiAgICB2YXIgZGF0YSA9IG5ldyBKU09ORmlsZShrZXksIGF0bGFzVVJMLCBwYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcblxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcbiAgICBpbWFnZS5saW5rRmlsZSA9IGRhdGE7XG4gICAgZGF0YS5saW5rRmlsZSA9IGltYWdlO1xuXG4gICAgLy8gIFNldCB0aGUgdHlwZVxuICAgIGltYWdlLmxpbmtUeXBlID0gJ2F0bGFzanNvbic7XG4gICAgZGF0YS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xuXG4gICAgcmV0dXJuIHsgdGV4dHVyZTogaW1hZ2UsIGRhdGE6IGRhdGEgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXRsYXNKU09ORmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xuXG52YXIgQmluYXJ5RmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cblxuICAgIGlmICgha2V5KVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5iaW5hcnlcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5iaW4nO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAnYmluYXJ5Jywga2V5LCB1cmwsICdhcnJheWJ1ZmZlcicsIHhoclNldHRpbmdzKTtcbn07XG5cbkJpbmFyeUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XG5CaW5hcnlGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeUZpbGU7XG5cbkJpbmFyeUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcbntcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xuXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2U7XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwiXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XG5cbnZhciBHTFNMRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cblxuICAgIGlmICgha2V5KVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci50ZXh0XFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIGlmICghdXJsKVxuICAgIHtcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcuZ2xzbCc7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XG4gICAgfVxuXG4gICAgRmlsZS5jYWxsKHRoaXMsICdnbHNsJywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xufTtcblxuR0xTTEZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XG5HTFNMRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFNMRmlsZTtcblxuR0xTTEZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcbntcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xuXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0O1xuXG4gICAgdGhpcy5vbkNvbXBsZXRlKCk7XG5cbiAgICBjYWxsYmFjayh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR0xTTEZpbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xuXG52YXIgVGV4dEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxue1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XG5cbiAgICBpZiAoIWtleSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIudGV4dFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXVybClcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnRleHQnO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAndGV4dCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcbn07XG5cblRleHRGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xuVGV4dEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEZpbGU7XG5cblRleHRGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXG57XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcblxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dDtcblxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xuXG4gICAgY2FsbGJhY2sodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcbnZhciBQYXJzZVhNTCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9QYXJzZVhNTCcpO1xuXG52YXIgWE1MRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cblxuICAgIGlmICgha2V5KVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci54bWxcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy54bWwnO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAneG1sJywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xufTtcblxuWE1MRmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcblhNTEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWE1MRmlsZTtcblxuWE1MRmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxue1xuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XG5cbiAgICB0aGlzLmRhdGEgPSBQYXJzZVhNTCh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xuXG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYTUxGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwidmFyIEF2ZXJhZ2UgPSBmdW5jdGlvbiAodmFsdWVzKVxue1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBzdW0gKz0gKCt2YWx1ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdW0gLyB2YWx1ZXMubGVuZ3RoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdmVyYWdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9BdmVyYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENlaWxUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcGxhY2UsIGJhc2UpXG57XG4gICAgaWYgKHBsYWNlID09PSB1bmRlZmluZWQpIHsgcGxhY2UgPSAwOyB9XG4gICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkgeyBiYXNlID0gMTA7IH1cblxuICAgIHZhciBwID0gTWF0aC5wb3coYmFzZSwgLXBsYWNlKTtcblxuICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUgKiBwKSAvIHA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxUbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2VpbFRvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEZvcmNlIGEgdmFsdWUgd2l0aGluIHRoZSBib3VuZGFyaWVzIGJ5IGNsYW1waW5nIGl0IHRvIHRoZSByYW5nZSBgbWluYCwgYG1heGAuXG4qXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjY2xhbXBcbiogQHBhcmFtIHtmbG9hdH0gdiAtIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkLlxuKiBAcGFyYW0ge2Zsb2F0fSBtaW4gLSBUaGUgbWluaW11bSBib3VuZHMuXG4qIEBwYXJhbSB7ZmxvYXR9IG1heCAtIFRoZSBtYXhpbXVtIGJvdW5kcy5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCB2YWx1ZS5cbiovXG52YXIgQ2xhbXAgPSBmdW5jdGlvbiAodiwgbWluLCBtYXgpXG57XG4gICAgaWYgKHYgPCBtaW4pXG4gICAge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXggPCB2KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFtcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2xhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbnZhciBEZWdUb1JhZCA9IGZ1bmN0aW9uIChkZWdyZWVzKVxue1xuICAgIHJldHVybiBkZWdyZWVzICogQ09OU1QuREVHX1RPX1JBRDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVnVG9SYWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0RlZ1RvUmFkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9EZWdUb1JhZC5qcyIsInZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9hdEJldHdlZW4gPSBmdW5jdGlvbiAobWluLCBtYXgpXG57XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb2F0QmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvYXRCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxue1xuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XG5cbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAqIHApIC8gcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvb3JUbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvb3JUby5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIE1heEFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtYXgpXG57XG4gICAgcmV0dXJuIE1hdGgubWluKHZhbHVlICsgYW1vdW50LCBtYXgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXhBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL01heEFkZC5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNaW5TdWIgPSBmdW5jdGlvbiAodmFsdWUsIGFtb3VudCwgbWluKVxue1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAtIGFtb3VudCwgbWluKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWluU3ViO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9NaW5TdWIuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyY2VudCA9IGZ1bmN0aW9uIChhLCBiLCBiYXNlKVxue1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDA7IH1cblxuICAgIGlmIChhID4gYiB8fCBiYXNlID4gYilcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIDwgYmFzZSB8fCBiYXNlID4gYSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gKGEgLSBiYXNlKSAvIGI7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJjZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9QZXJjZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG52YXIgUmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucylcbntcbiAgICByZXR1cm4gcmFkaWFucyAqIENPTlNULlJBRF9UT19ERUc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhZFRvRGVnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9SYWRUb0RlZy5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvUmFkVG9EZWcuanMiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcblxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChwb2ludCwgYW5nbGUpXG57XG4gICAgdmFyIHggPSBwb2ludC54O1xuICAgIHZhciB5ID0gcG9pbnQueTtcblxuICAgIHBvaW50LnggPSAoeCAqIE1hdGguY29zKGFuZ2xlKSkgLSAoeSAqIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgcG9pbnQueSA9ICh4ICogTWF0aC5zaW4oYW5nbGUpKSArICh5ICogTWF0aC5jb3MoYW5nbGUpKTtcblxuICAgIHJldHVybiBwb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcblxudmFyIFJvdGF0ZUFyb3VuZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSwgYW5nbGUpXG57XG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICB2YXIgdHggPSBwb2ludC54IC0geDtcbiAgICB2YXIgdHkgPSBwb2ludC55IC0geTtcblxuICAgIHBvaW50LnggPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xuICAgIHBvaW50LnkgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdGF0ZUFyb3VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBwID0gUG9pbnQgb3IgYW55IG9iamVjdCB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xuXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAocG9pbnQsIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSlcbntcbiAgICB2YXIgdCA9IGFuZ2xlICsgTWF0aC5hdGFuMihwb2ludC55IC0geSwgcG9pbnQueCAtIHgpO1xuXG4gICAgcG9pbnQueCA9IHggKyAoZGlzdGFuY2UgKiBNYXRoLmNvcyh0KSk7XG4gICAgcG9pbnQueSA9IHkgKyAoZGlzdGFuY2UgKiBNYXRoLnNpbih0KSk7XG5cbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZERpc3RhbmNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcbntcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxuXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwKSAvIHA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kVG87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kVG8uanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBTaW5Db3NUYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIChsZW5ndGgsIHNpbkFtcCwgY29zQW1wLCBmcmVxdWVuY3kpXG57XG4gICAgaWYgKHNpbkFtcCA9PT0gdW5kZWZpbmVkKSB7IHNpbkFtcCA9IDE7IH1cbiAgICBpZiAoY29zQW1wID09PSB1bmRlZmluZWQpIHsgY29zQW1wID0gMTsgfVxuICAgIGlmIChmcmVxdWVuY3kgPT09IHVuZGVmaW5lZCkgeyBmcmVxdWVuY3kgPSAxOyB9XG5cbiAgICBmcmVxdWVuY3kgKj0gTWF0aC5QSSAvIGxlbmd0aDtcblxuICAgIHZhciBjb3MgPSBbXTtcbiAgICB2YXIgc2luID0gW107XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbmd0aDsgYysrKVxuICAgIHtcbiAgICAgICAgY29zQW1wIC09IHNpbkFtcCAqIGZyZXF1ZW5jeTtcbiAgICAgICAgc2luQW1wICs9IGNvc0FtcCAqIGZyZXF1ZW5jeTtcblxuICAgICAgICBjb3NbY10gPSBjb3NBbXA7XG4gICAgICAgIHNpbltjXSA9IHNpbkFtcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaW46IHNpbixcbiAgICAgICAgY29zOiBjb3MsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2luQ29zVGFibGVHZW5lcmF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1NpbkNvc1RhYmxlR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aFN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXG57XG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XG5cbiAgICByZXR1cm4geCAqIHggKiAoMyAtIDIgKiB4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhlclN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXG57XG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XG5cbiAgICByZXR1cm4geCAqIHggKiB4ICogKHggKiAoeCAqIDYgLSAxNSkgKyAxMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aGVyU3RlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENoZWNrcyBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZSBvZiBlYWNoIG90aGVyLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3dpdGhpblxuKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gY2hlY2tcbiogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgc2Vjb25kIG51bWJlciB0byBjaGVja1xuKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIC0gVGhlIHRvbGVyYW5jZS4gQW55dGhpbmcgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIHRoaXMgaXMgY29uc2lkZXJlZCB3aXRoaW4gdGhlIHJhbmdlLlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgaXMgPD0gdG9sZXJhbmNlIG9mIGIuXG4qIEBzZWUge0BsaW5rIFBoYXNlci5NYXRoLmZ1enp5RXF1YWx9XG4qL1xudmFyIFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBiLCB0b2xlcmFuY2UpXG57XG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2l0aGluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9XaXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcbntcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxue1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi55IC0gcG9pbnQxLnksIHBvaW50Mi54IC0gcG9pbnQxLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5Qb2ludHNZID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxue1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi54IC0gcG9pbnQxLngsIHBvaW50Mi55IC0gcG9pbnQxLnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50c1kuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblkgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeDIgLSB4MSwgeTIgLSB5MSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5ZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xuXG52YXIgUmV2ZXJzZSA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICByZXR1cm4gTm9ybWFsaXplKGFuZ2xlICsgTWF0aC5QSSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldmVyc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1JldmVyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JldmVyc2UuanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuKiBSb3RhdGVzIGN1cnJlbnRBbmdsZSB0b3dhcmRzIHRhcmdldEFuZ2xlLCB0YWtpbmcgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGRpc3RhbmNlLlxuKiBUaGUgbGVycCBhcmd1bWVudCBpcyB0aGUgYW1vdW50IHRvIHJvdGF0ZSBieSBpbiB0aGlzIGNhbGwuXG4qIFxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3JvdGF0ZVRvQW5nbGVcbiogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRBbmdsZSAtIFRoZSBjdXJyZW50IGFuZ2xlLCBpbiByYWRpYW5zLlxuKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0QW5nbGUgLSBUaGUgdGFyZ2V0IGFuZ2xlIHRvIHJvdGF0ZSB0bywgaW4gcmFkaWFucy5cbiogQHBhcmFtIHtudW1iZXJ9IFtsZXJwPTAuMDVdIC0gVGhlIGxlcnAgdmFsdWUgdG8gYWRkIHRvIHRoZSBjdXJyZW50IGFuZ2xlLlxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhZGp1c3RlZCBhbmdsZS5cbiovXG52YXIgUm90YXRlVG8gPSBmdW5jdGlvbiAoY3VycmVudEFuZ2xlLCB0YXJnZXRBbmdsZSwgbGVycClcbntcbiAgICBpZiAobGVycCA9PT0gdW5kZWZpbmVkKSB7IGxlcnAgPSAwLjA1OyB9XG5cbiAgICBpZiAoY3VycmVudEFuZ2xlID09PSB0YXJnZXRBbmdsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBjdXJyZW50QW5nbGU7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA8PSBsZXJwIHx8IE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+PSAoTUFUSF9DT05TVC5QSTIgLSBsZXJwKSlcbiAgICB7XG4gICAgICAgIGN1cnJlbnRBbmdsZSA9IHRhcmdldEFuZ2xlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpID4gTWF0aC5QSSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRhcmdldEFuZ2xlIDwgY3VycmVudEFuZ2xlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlICs9IE1BVEhfQ09OU1QuUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlIC09IE1BVEhfQ09OU1QuUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldEFuZ2xlID4gY3VycmVudEFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gbGVycDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgY3VycmVudEFuZ2xlIC09IGxlcnA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVUbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvUm90YXRlVG8uanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwiLyoqXG4qIEdldHMgdGhlIHNob3J0ZXN0IGFuZ2xlIGJldHdlZW4gYGFuZ2xlMWAgYW5kIGBhbmdsZTJgLlxuKiBCb3RoIGFuZ2xlcyBtdXN0IGJlIGluIHRoZSByYW5nZSAtMTgwIHRvIDE4MCwgd2hpY2ggaXMgdGhlIHNhbWUgY2xhbXBlZFxuKiByYW5nZSB0aGF0IGBzcHJpdGUuYW5nbGVgIHVzZXMsIHNvIHlvdSBjYW4gcGFzcyBpbiB0d28gc3ByaXRlIGFuZ2xlcyB0b1xuKiB0aGlzIG1ldGhvZCwgYW5kIGdldCB0aGUgc2hvcnRlc3QgYW5nbGUgYmFjayBiZXR3ZWVuIHRoZSB0d28gb2YgdGhlbS5cbipcbiogVGhlIGFuZ2xlIHJldHVybmVkIHdpbGwgYmUgaW4gdGhlIHNhbWUgcmFuZ2UuIElmIHRoZSByZXR1cm5lZCBhbmdsZSBpc1xuKiBncmVhdGVyIHRoYW4gMCB0aGVuIGl0J3MgYSBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbiwgaWYgPCAwIHRoZW4gaXQnc1xuKiBhIGNsb2Nrd2lzZSByb3RhdGlvbi5cbiogXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjZ2V0U2hvcnRlc3RBbmdsZVxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUxIC0gVGhlIGZpcnN0IGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTIgLSBUaGUgc2Vjb25kIGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHNob3J0ZXN0IGFuZ2xlLCBpbiBkZWdyZWVzLiBJZiBncmVhdGVyIHRoYW4gemVybyBpdCdzIGEgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24uXG4qL1xudmFyIFNob3J0ZXN0QmV0d2VlbiA9IGZ1bmN0aW9uIChhbmdsZTEsIGFuZ2xlMilcbntcbiAgICB2YXIgZGlmZmVyZW5jZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcblxuICAgIGlmIChkaWZmZXJlbmNlID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigoZGlmZmVyZW5jZSAtICgtMTgwKSkgLyAzNjApO1xuXG4gICAgcmV0dXJuIGRpZmZlcmVuY2UgLSAodGltZXMgKiAzNjApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0ZXN0QmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdyYXAgPSByZXF1aXJlKCcuLi9XcmFwJyk7XG5cbnZhciBXcmFwRGVncmVlcyA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICByZXR1cm4gV3JhcChhbmdsZSwgLTE4MCwgMTgwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcERlZ3JlZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1dyYXBEZWdyZWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXG4gICAgQmV0d2Vlblk6IHJlcXVpcmUoJy4vQmV0d2VlblknKSxcbiAgICBCZXR3ZWVuUG9pbnRzOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHMnKSxcbiAgICBCZXR3ZWVuUG9pbnRzWTogcmVxdWlyZSgnLi9CZXR3ZWVuUG9pbnRzWScpLFxuICAgIFJldmVyc2U6IHJlcXVpcmUoJy4vUmV2ZXJzZScpLFxuICAgIFJvdGF0ZVRvOiByZXF1aXJlKCcuL1JvdGF0ZVRvJyksXG4gICAgU2hvcnRlc3RCZXR3ZWVuOiByZXF1aXJlKCcuL1Nob3J0ZXN0QmV0d2VlbicpLFxuICAgIE5vcm1hbGl6ZTogcmVxdWlyZSgnLi9Ob3JtYWxpemUnKSxcbiAgICBXcmFwOiByZXF1aXJlKCcuL1dyYXAnKSxcbiAgICBXcmFwRGVncmVlczogcmVxdWlyZSgnLi9XcmFwRGVncmVlcycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9hbmdsZS9pbmRleC5qcyIsInZhciBEaXN0YW5jZVBvd2VyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCBwb3cpXG57XG4gICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKSB7IHBvdyA9IDI7IH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgcG93KSArIE1hdGgucG93KHkyIC0geTEsIHBvdykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZVBvd2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVBvd2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcbntcbiAgICB2YXIgZHggPSB4MSAtIHgyO1xuICAgIHZhciBkeSA9IHkxIC0geTI7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlU3F1YXJlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VTcXVhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0Rpc3RhbmNlQmV0d2VlbicpLFxuICAgIFBvd2VyOiByZXF1aXJlKCcuL0Rpc3RhbmNlUG93ZXInKSxcbiAgICBTcXVhcmVkOiByZXF1aXJlKCcuL0Rpc3RhbmNlU3F1YXJlZCcpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsImZ1bmN0aW9uIEluICh2LCBvdmVyc2hvb3QpXG57XG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cblxuICAgIHJldHVybiB2ICogdiAqICgob3ZlcnNob290ICsgMSkgKiB2IC0gb3ZlcnNob290KTtcbn1cblxuZnVuY3Rpb24gT3V0ICh2LCBvdmVyc2hvb3QpXG57XG4gICAgaWYgKG92ZXJzaG9vdCA9PT0gdW5kZWZpbmVkKSB7IG92ZXJzaG9vdCA9IDEuNzAxNTg7IH1cblxuICAgIHJldHVybiAtLXYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgKyBvdmVyc2hvb3QpICsgMTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYsIG92ZXJzaG9vdClcbntcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxuXG4gICAgdmFyIHMgPSBvdmVyc2hvb3QgKiAxLjUyNTtcblxuICAgIGlmICgodiAqPSAyKSA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKHYgKiB2ICogKChzICsgMSkgKiB2IC0gcykpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqICgocyArIDEpICogdiArIHMpICsgMik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0JhY2suanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcbntcbiAgICB2ID0gMSAtIHY7XG5cbiAgICBpZiAodiA8IDEgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogdiAqIHYpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXG4gICAge1xuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXG4gICAge1xuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgLSAoNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgaWYgKHYgPCAxIC8gMi43NSlcbiAgICB7XG4gICAgICAgIHJldHVybiA3LjU2MjUgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcblxuICAgIGlmICh2IDwgMC41KVxuICAgIHtcbiAgICAgICAgdiA9IDEgLSAodiAqIDIpO1xuICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdiA9ICh2ICogMikgLSAxO1xuICAgIH1cblxuICAgIGlmICh2IDwgMSAvIDIuNzUpXG4gICAge1xuICAgICAgICB2ID0gNy41NjI1ICogdiAqIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcbiAgICB7XG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAxLjUgLyAyLjc1KSAqIHYgKyAwLjc1O1xuICAgIH1cbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcbiAgICB7XG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAyLjI1IC8gMi43NSkgKiB2ICsgMC45Mzc1O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2ID0gNy41NjI1ICogKHYgLT0gMi42MjUgLyAyLjc1KSAqIHYgKyAwLjk4NDM3NTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSlcbiAgICB7XG4gICAgICAgIHJldHVybiAoMSAtIHYpICogMC41O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gdiAqIDAuNSArIDAuNTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvQm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXG57XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHYgKiB2KTtcbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXYgKiB2KSk7XG59XG5cbmZ1bmN0aW9uIEluT3V0ICh2KVxue1xuICAgIGlmICgodiAqPSAyKSA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHYgKiB2KSAtIDEpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHYgLT0gMikgKiB2KSArIDEpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBJbjogSW4sXG4gICAgT3V0OiBPdXQsXG4gICAgSW5PdXQ6IEluT3V0XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9DaXJjdWxhci5qc1xuLy8gbW9kdWxlIGlkID0gMjUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHJldHVybiB2ICogdiAqIHY7XG59XG5cbmZ1bmN0aW9uIE91dCAodilcbntcbiAgICByZXR1cm4gLS12ICogdiAqIHYgKyAxO1xufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICsgMik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxue1xuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XG5cbiAgICBpZiAodiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ID09PSAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcblxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcbiAgICAgICAge1xuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0oYW1wbGl0dWRlICogTWF0aC5wb3coMiwgMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcbntcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxuXG4gICAgaWYgKHYgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XG5cbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoYW1wbGl0dWRlICogTWF0aC5wb3coMiwgLTEwICogdikgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkgKyAxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEluT3V0ICh2LCBhbXBsaXR1ZGUsIHBlcmlvZClcbntcbiAgICBpZiAoYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgYW1wbGl0dWRlID0gMC4xOyB9XG4gICAgaWYgKHBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7IHBlcmlvZCA9IDAuMTsgfVxuXG4gICAgaWYgKHYgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgcyA9IHBlcmlvZCAvIDQ7XG5cbiAgICAgICAgaWYgKGFtcGxpdHVkZSA8IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFtcGxpdHVkZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBzID0gcGVyaW9kICogTWF0aC5hc2luKDEgLyBhbXBsaXR1ZGUpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodiAqPSAyKSA8IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogKHYgLT0gMSkpICogTWF0aC5zaW4oKHYgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwZXJpb2QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkgKiAwLjUgKyAxO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0VsYXN0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcbntcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodiAtIDEpKSAtIDAuMDAxO1xufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB2KTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAodiAtIDEpKSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0V4cG8uanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogTGluZWFyIEVhc2luZyAobm8gdmFyaWF0aW9uKS5cbipcbiogQG1ldGhvZCBMYXplci5FYXNpbmcuTGluZWFyI05vbmVcbiogQHBhcmFtIHtudW1iZXJ9IHYgLSBUaGUgdmFsdWUgdG8gYmUgdHdlZW5lZC5cbiogQHJldHVybnMge251bWJlcn0gdi5cbiovXG52YXIgTGluZWFyID0gZnVuY3Rpb24gKHYpXG57XG4gICAgcmV0dXJuIHY7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0xpbmVhci5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHJldHVybiB2ICogdjtcbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIHJldHVybiB2ICogKDIgLSB2KTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS12ICogKHYgLSAyKSAtIDEpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBJbjogSW4sXG4gICAgT3V0OiBPdXQsXG4gICAgSW5PdXQ6IEluT3V0XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9RdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcbntcbiAgICByZXR1cm4gdiAqIHYgKiB2ICogdjtcbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIHJldHVybiAxIC0gKC0tdiAqIHYgKiB2ICogdik7XG59XG5cbmZ1bmN0aW9uIEluT3V0ICh2KVxue1xuICAgIGlmICgodiAqPSAyKSA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoKHYgLT0gMikgKiB2ICogdiAqIHYgLSAyKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHJldHVybiB2ICogdiAqIHYgKiB2ICogdjtcbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIHJldHVybiAtLXYgKiB2ICogdiAqIHYgKiB2ICsgMTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdiAqIHYgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAqIHYgKyAyKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvUXVpbnRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIGlmICh2ID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPT09IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh2ICogTWF0aC5QSSAvIDIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIGlmICh2ID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPT09IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHYgKiBNYXRoLlBJIC8gMik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICBpZiAodiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ID09PSAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiB2KSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1NpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEJhY2s6IHJlcXVpcmUoJy4vQmFjaycpLFxuICAgIEJvdW5jZTogcmVxdWlyZSgnLi9Cb3VuY2UnKSxcbiAgICBDaXJjdWxhcjogcmVxdWlyZSgnLi9DaXJjdWxhcicpLFxuICAgIEN1YmljOiByZXF1aXJlKCcuL0N1YmljJyksXG4gICAgRWxhc3RpYzogcmVxdWlyZSgnLi9FbGFzdGljJyksXG4gICAgRXhwbzogcmVxdWlyZSgnLi9FeHBvJyksXG4gICAgTGluZWFyOiByZXF1aXJlKCcuL0xpbmVhcicpLFxuICAgIFF1YWRyYXRpYzogcmVxdWlyZSgnLi9RdWFkcmF0aWMnKSxcbiAgICBRdWFydGljOiByZXF1aXJlKCcuL1F1YXJ0aWMnKSxcbiAgICBRdWludGljOiByZXF1aXJlKCcuL1F1aW50aWMnKSxcbiAgICBTaW5lOiByZXF1aXJlKCcuL1NpbmUnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Vhc2luZy9pbmRleC5qcyIsInZhciBDZWlsID0gZnVuY3Rpb24gKHZhbHVlLCBlcHNpbG9uKVxue1xuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxuXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAtIGVwc2lsb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9mdXp6eS9DZWlsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFsID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXG57XG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXG57XG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSArIGVwc2lsb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR3JlYXRlclRoYW4gPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcbntcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cblxuICAgIHJldHVybiBhID4gYiAtIGVwc2lsb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyZWF0ZXJUaGFuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9mdXp6eS9HcmVhdGVyVGhhbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMZXNzVGhhbiA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxue1xuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxuXG4gICAgcmV0dXJuIGEgPCBiICsgZXBzaWxvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGVzc1RoYW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBDZWlsOiByZXF1aXJlKCcuL0NlaWwnKSxcbiAgICBFcXVhbDogcmVxdWlyZSgnLi9FcXVhbCcpLFxuICAgIEZsb29yOiByZXF1aXJlKCcuL0Zsb29yJyksXG4gICAgR3JlYXRlclRoYW46IHJlcXVpcmUoJy4vR3JlYXRlclRoYW4nKSxcbiAgICBMZXNzVGhhbjogcmVxdWlyZSgnLi9MZXNzVGhhbicpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9mdXp6eS9pbmRleC5qcyIsInZhciBCZXJuc3RlaW4gPSByZXF1aXJlKCcuLi9CZXJuc3RlaW4nKTtcblxudmFyIEJlemllckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcbntcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKyspXG4gICAge1xuICAgICAgICBiICs9IE1hdGgucG93KDEgLSBrLCBuIC0gaSkgKiBNYXRoLnBvdyhrLCBpKSAqIHZbaV0gKiBCZXJuc3RlaW4obiwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlemllckludGVycG9sYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzIiwidmFyIENhdG11bGxSb20gPSByZXF1aXJlKCcuLi9DYXRtdWxsUm9tJyk7XG5cbnZhciBDYXRtdWxsUm9tSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxue1xuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgIHZhciBmID0gbSAqIGs7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuXG4gICAgaWYgKHZbMF0gPT09IHZbbV0pXG4gICAge1xuICAgICAgICBpZiAoayA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGkgPSBNYXRoLmZsb29yKGYgPSBtICogKDEgKyBrKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ2F0bXVsbFJvbSh2WyhpIC0gMSArIG0pICUgbV0sIHZbaV0sIHZbKGkgKyAxKSAlIG1dLCB2WyhpICsgMikgJSBtXSwgZiAtIGkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoayA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdIC0gKENhdG11bGxSb20odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoayA+IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB2W21dIC0gKENhdG11bGxSb20odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYXRtdWxsUm9tKHZbaSA/IGkgLSAxIDogMF0sIHZbaV0sIHZbbSA8IGkgKyAxID8gbSA6IGkgKyAxXSwgdlttIDwgaSArIDIgPyBtIDogaSArIDJdLCBmIC0gaSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRtdWxsUm9tSW50ZXJwb2xhdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbi5qcyIsInZhciBMaW5lYXIgPSByZXF1aXJlKCcuLi9MaW5lYXInKTtcblxudmFyIExpbmVhckludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodiwgaylcbntcbiAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcbiAgICB2YXIgZiA9IG0gKiBrO1xuICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcblxuICAgIGlmIChrIDwgMClcbiAgICB7XG4gICAgICAgIHJldHVybiBMaW5lYXIodlswXSwgdlsxXSwgZik7XG4gICAgfVxuXG4gICAgaWYgKGsgPiAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIExpbmVhcih2W21dLCB2W20gLSAxXSwgbSAtIGYpO1xuICAgIH1cblxuICAgIHJldHVybiBMaW5lYXIodltpXSwgdlsoaSArIDEgPiBtKSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFySW50ZXJwb2xhdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEJlemllcjogcmVxdWlyZSgnLi9CZXppZXJJbnRlcnBvbGF0aW9uJyksXG4gICAgQ2F0bXVsbFJvbTogcmVxdWlyZSgnLi9DYXRtdWxsUm9tSW50ZXJwb2xhdGlvbicpLFxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXJJbnRlcnBvbGF0aW9uJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9pbmRleC5qcyIsIi8vICBUYWtlcyB2YWx1ZSBhbmQgcmV0dXJucyB0aGUgbmVhcmVzdCBwb3dlciBvZiAyXG5cbnZhciBHZXRQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxue1xuICAgIC8vICBNYXRoLmxvZygyKVxuICAgIHZhciBpbmRleCA9IE1hdGgubG9nKHZhbHVlKSAvIDAuNjkzMTQ3MTgwNTU5OTQ1MztcblxuICAgIHJldHVybiAoMSA8PCBNYXRoLmNlaWwoaW5kZXgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0UG93ZXJPZlR3bztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9HZXRQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIElzIHZhbHVlIGEgcG93ZXIgb2YgMj9cblxudmFyIElzVmFsdWVQb3dlck9mVHdvID0gZnVuY3Rpb24gKHZhbHVlKVxue1xuICAgIHJldHVybiAodmFsdWUgPiAwICYmICh2YWx1ZSAmICh2YWx1ZSAtIDEpKSA9PT0gMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzVmFsdWVQb3dlck9mVHdvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL0lzVmFsdWVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9wb3cyL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydCA9IHtcblxuICAgIEdldE5leHQ6IHJlcXVpcmUoJy4vR2V0UG93ZXJPZlR3bycpLFxuICAgIElzU2l6ZTogcmVxdWlyZSgnLi9Jc1NpemVQb3dlck9mVHdvJyksXG4gICAgSXNWYWx1ZTogcmVxdWlyZSgnLi9Jc1ZhbHVlUG93ZXJPZlR3bycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3BvdzIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGMgLSBJbnRlcm5hbCB2YXIuXG4qIEBwcml2YXRlXG4qL1xudmFyIGMgPSAxO1xuXG4vKipcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMwIC0gSW50ZXJuYWwgdmFyLlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBzMCA9IDA7XG5cbi8qKlxuKiBAcHJvcGVydHkge251bWJlcn0gczEgLSBJbnRlcm5hbCB2YXIuXG4qIEBwcml2YXRlXG4qL1xudmFyIHMxID0gMDtcblxuLyoqXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMiAtIEludGVybmFsIHZhci5cbiogQHByaXZhdGVcbiovXG52YXIgczIgPSAwO1xuXG4vKipcbiogQHByb3BlcnR5IHtBcnJheX0gc2lnbiAtIEludGVybmFsIHZhci5cbiogQHByaXZhdGVcbiovXG52YXIgc2lnbiA9IFsgLTEsIDEgXTtcblxuLyoqXG4qIFByaXZhdGUgcmFuZG9tIGhlbHBlci5cbipcbiogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNybmRcbiogQHByaXZhdGVcbiogQHJldHVybiB7bnVtYmVyfVxuKi9cbnZhciBybmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG5cbiAgICBjID0gdCB8IDA7XG4gICAgczAgPSBzMTtcbiAgICBzMSA9IHMyO1xuICAgIHMyID0gdCAtIGM7XG5cbiAgICByZXR1cm4gczI7XG59O1xuXG4vKipcbiogSW50ZXJuYWwgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHNlZWQgaGFzaC5cbipcbiogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNoYXNoXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7YW55fSBkYXRhXG4qIEByZXR1cm4ge251bWJlcn0gaGFzaGVkIHZhbHVlLlxuKi9cbnZhciBoYXNoID0gZnVuY3Rpb24gKGRhdGEpXG57XG4gICAgdmFyIGgsIGksIG47XG4gICAgbiA9IDB4ZWZjODI0OWQ7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgaCAqPSBuO1xuICAgICAgICBuID0gaCA+Pj4gMDtcbiAgICAgICAgaCAtPSBuO1xuICAgICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsvLyAyXjMyXG4gICAgfVxuXG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7Ly8gMl4tMzJcbn07XG5cblxudmFyIFJhbmRvbURhdGFHZW5lcmF0b3IgPSBmdW5jdGlvbiAoc2VlZHMpXG57XG4gICAgaWYgKHR5cGVvZiBzZWVkcyA9PT0gJ3N0cmluZycpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlKHNlZWRzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3coc2VlZHMpO1xuICAgIH1cbn07XG5cblJhbmRvbURhdGFHZW5lcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZG9tRGF0YUdlbmVyYXRvcjtcblxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAqIFJlc2V0IHRoZSBzZWVkIG9mIHRoZSByYW5kb20gZGF0YSBnZW5lcmF0b3IuXG4gICAgKlxuICAgICogX05vdGVfOiB0aGUgc2VlZCBhcnJheSBpcyBvbmx5IHByb2Nlc3NlZCB1cCB0byB0aGUgZmlyc3QgYHVuZGVmaW5lZGAgKG9yIGBudWxsYCkgdmFsdWUsIHNob3VsZCBzdWNoIGJlIHByZXNlbnQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzb3dcbiAgICAqIEBwYXJhbSB7YW55W119IHNlZWRzIC0gVGhlIGFycmF5IG9mIHNlZWRzOiB0aGUgYHRvU3RyaW5nKClgIG9mIGVhY2ggdmFsdWUgaXMgdXNlZC5cbiAgICAqL1xuICAgIHNvdzogZnVuY3Rpb24gKHNlZWRzKVxuICAgIHtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IHRvIGRlZmF1bHQgc2VlZFxuICAgICAgICBzMCA9IGhhc2goJyAnKTtcbiAgICAgICAgczEgPSBoYXNoKHMwKTtcbiAgICAgICAgczIgPSBoYXNoKHMxKTtcbiAgICAgICAgYyA9IDE7XG5cbiAgICAgICAgaWYgKCFzZWVkcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgYW55IHNlZWRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VlZHMubGVuZ3RoICYmIChzZWVkc1tpXSAhPSBudWxsKTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VlZCA9IHNlZWRzW2ldO1xuXG4gICAgICAgICAgICBzMCAtPSBoYXNoKHNlZWQpO1xuICAgICAgICAgICAgczAgKz0gfn4oczAgPCAwKTtcbiAgICAgICAgICAgIHMxIC09IGhhc2goc2VlZCk7XG4gICAgICAgICAgICBzMSArPSB+fihzMSA8IDApO1xuICAgICAgICAgICAgczIgLT0gaGFzaChzZWVkKTtcbiAgICAgICAgICAgIHMyICs9IH5+KHMyIDwgMCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxuICAgICovXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIDJeMzJcbiAgICAgICAgcmV0dXJuIHJuZCgpICogMHgxMDAwMDAwMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNmcmFjXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICAqL1xuICAgIGZyYWM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAyXi01M1xuICAgICAgICByZXR1cm4gcm5kKCkgKyAocm5kKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMl4zMi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JlYWxcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxuICAgICovXG4gICAgcmVhbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoKSArIHRoaXMuZnJhYygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VySW5SYW5nZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgICovXG4gICAgaW50ZWdlckluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmVhbEluUmFuZ2UoMCwgbWF4IC0gbWluICsgMSkgKyBtaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXG4gICAgKiBUaGlzIG1ldGhvZCBpcyBhbiBhbGlhcyBmb3IgUmFuZG9tRGF0YUdlbmVyYXRvci5pbnRlZ2VySW5SYW5nZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2JldHdlZW5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAgICAqL1xuICAgIGJldHdlZW46IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKG1pbiwgbWF4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyZWFsSW5SYW5nZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgICovXG4gICAgcmVhbEluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWMoKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI25vcm1hbFxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLlxuICAgICovXG4gICAgbm9ybWFsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgLSAoMiAqIHRoaXMuZnJhYygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTMwODM2OFxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdXVpZFxuICAgICogQHJldHVybiB7c3RyaW5nfSBBIHZhbGlkIFJGQzQxMjIgdmVyc2lvbjQgSUQgaGV4IHN0cmluZ1xuICAgICovXG4gICAgdXVpZDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBhID0gJyc7XG4gICAgICAgIHZhciBiID0gJyc7XG5cbiAgICAgICAgZm9yIChiID0gYSA9ICcnOyBhKysgPCAzNjsgYiArPX5hICUgNSB8IGEgKiAzJjQgPyAoYV4xNSA/IDhedGhpcy5mcmFjKCkgKiAoYV4yMCA/IDE2IDogNCkgOiA0KS50b1N0cmluZygxNikgOiAnLScpXG4gICAgICAgIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNwaWNrXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxuICAgICovXG4gICAgcGljazogZnVuY3Rpb24gKGFycmF5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlckluUmFuZ2UoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSBzaWduIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvci5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3NpZ25cbiAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgb3IgKzEuXG4gICAgKi9cbiAgICBzaWduOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayhzaWduKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIG1lbWJlciBvZiBgYXJyYXlgLCBmYXZvcmluZyB0aGUgZWFybGllciBlbnRyaWVzLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijd2VpZ2h0ZWRQaWNrXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxuICAgICovXG4gICAgd2VpZ2h0ZWRQaWNrOiBmdW5jdGlvbiAoYXJyYXkpXG4gICAge1xuICAgICAgICByZXR1cm4gYXJyYXlbfn4oTWF0aC5wb3codGhpcy5mcmFjKCksIDIpICogKGFycmF5Lmxlbmd0aCAtIDEpICsgMC41KV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIHJhbmRvbSB0aW1lc3RhbXAgYmV0d2VlbiBtaW4gYW5kIG1heCwgb3IgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIDIwMDAgYW5kIHRoZSBlbmQgb2YgMjAyMCBpZiBtaW4gYW5kIG1heCBhcmVuJ3Qgc3BlY2lmaWVkLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdGltZXN0YW1wXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgKi9cbiAgICB0aW1lc3RhbXA6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKG1pbiB8fCA5NDY2ODQ4MDAwMDAsIG1heCB8fCAxNTc3ODYyMDAwMDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGFuZ2xlIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjYW5nbGVcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICovXG4gICAgYW5nbGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZSgtMTgwLCAxODApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gcm90YXRpb24gaW4gcmFkaWFucywgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyb3RhdGlvblxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXG4gICAgKi9cbiAgICByb3RhdGlvbjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKC0zLjE0MTU5MjY1MzU4OTc5MywgMy4xNDE1OTI2NTM1ODk3OTMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEdldHMgb3IgU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldGFpbiB0aGUgdmFsdWVzXG4gICAgKiB0aGF0IHRoZSBnZW5lcmF0b3IgaXMgdXNpbmcgYmV0d2VlbiBnYW1lcywgaS5lLiBpbiBhIGdhbWUgc2F2ZSBmaWxlLlxuICAgICpcbiAgICAqIFRvIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2l0aCBhIHByZXZpb3VzbHkgc2F2ZWQgc3RhdGUgeW91IGNhbiBwYXNzIGl0IGFzIHRoZVxuICAgICogYHNlZWRgIHZhbHVlIGluIHlvdXIgZ2FtZSBjb25maWcsIG9yIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHkgYWZ0ZXIgUGhhc2VyIGhhcyBib290ZWQuXG4gICAgKlxuICAgICogQ2FsbCB0aGlzIG1ldGhvZCB3aXRoIG5vIHBhcmFtZXRlcnMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICpcbiAgICAqIElmIHByb3ZpZGluZyBhIHN0YXRlIGl0IHNob3VsZCBtYXRjaCB0aGUgc2FtZSBmb3JtYXQgdGhhdCB0aGlzIG1ldGhvZFxuICAgICogcmV0dXJucywgd2hpY2ggaXMgYSBzdHJpbmcgd2l0aCBhIGhlYWRlciBgIXJuZGAgZm9sbG93ZWQgYnkgdGhlIGBjYCxcbiAgICAqIGBzMGAsIGBzMWAgYW5kIGBzMmAgdmFsdWVzIHJlc3BlY3RpdmVseSwgZWFjaCBjb21tYS1kZWxpbWl0ZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzdGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV0gLSBHZW5lcmF0b3Igc3RhdGUgdG8gYmUgc2V0LlxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxuICAgICovXG4gICAgc3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIHN0YXRlLm1hdGNoKC9eIXJuZC8pKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgIGMgPSBwYXJzZUZsb2F0KHN0YXRlWzFdKTtcbiAgICAgICAgICAgIHMwID0gcGFyc2VGbG9hdChzdGF0ZVsyXSk7XG4gICAgICAgICAgICBzMSA9IHBhcnNlRmxvYXQoc3RhdGVbM10pO1xuICAgICAgICAgICAgczIgPSBwYXJzZUZsb2F0KHN0YXRlWzRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbICchcm5kJywgYywgczAsIHMxLCBzMiBdLmpvaW4oJywnKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tRGF0YUdlbmVyYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU25hcENlaWwgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5jZWlsKHZhbHVlIC8gZ2FwKTtcblxuICAgIHJldHVybiBzdGFydCArIHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbmFwQ2VpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5mbG9vcih2YWx1ZSAvIGdhcCk7XG5cbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL1NuYXBGbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwVG8gPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5yb3VuZCh2YWx1ZSAvIGdhcCk7XG5cbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU25hcFRvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL1NuYXBUby5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9TbmFwQ2VpbCcpLFxuICAgIEZsb29yOiByZXF1aXJlKCcuL1NuYXBGbG9vcicpLFxuICAgIFRvOiByZXF1aXJlKCcuL1NuYXBUbycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL3NuYXAvaW5kZXguanMiLCIvKipcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxuKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4qL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcbntcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pXG4gICAge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcbiovXG5pZiAoIUFycmF5LmlzQXJyYXkpXG57XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpXG4gICAge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogQ29weXJpZ2h0IDIwMTMgQ2hyaXMgV2lsc29uXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLypcblxuVGhpcyBtb25rZXlwYXRjaCBsaWJyYXJ5IGlzIGludGVuZGVkIHRvIGJlIGluY2x1ZGVkIGluIHByb2plY3RzIHRoYXQgYXJlXG53cml0dGVuIHRvIHRoZSBwcm9wZXIgQXVkaW9Db250ZXh0IHNwZWMgKGluc3RlYWQgb2Ygd2Via2l0QXVkaW9Db250ZXh0KSxcbmFuZCB0aGF0IHVzZSB0aGUgbmV3IG5hbWluZyBhbmQgcHJvcGVyIGJpdHMgb2YgdGhlIFdlYiBBdWRpbyBBUEkgKGUuZy5cbnVzaW5nIEJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpbnN0ZWFkIG9mIEJ1ZmZlclNvdXJjZU5vZGUubm90ZU9uKCkpLCBidXQgbWF5XG5oYXZlIHRvIHJ1biBvbiBzeXN0ZW1zIHRoYXQgb25seSBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIGJpdHMuXG5cblRoaXMgbGlicmFyeSBzaG91bGQgYmUgaGFybWxlc3MgdG8gaW5jbHVkZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0c1xudW5wcmVmaXhlZCBcIkF1ZGlvQ29udGV4dFwiLCBhbmQvb3IgaWYgaXQgc3VwcG9ydHMgdGhlIG5ldyBuYW1lcy5cblxuVGhlIHBhdGNoZXMgdGhpcyBsaWJyYXJ5IGhhbmRsZXM6XG5pZiB3aW5kb3cuQXVkaW9Db250ZXh0IGlzIHVuc3VwcG9ydGVkLCBpdCB3aWxsIGJlIGFsaWFzZWQgdG8gd2Via2l0QXVkaW9Db250ZXh0KCkuXG5pZiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpcyB1bmltcGxlbWVudGVkLCBpdCB3aWxsIGJlIHJvdXRlZCB0byBub3RlT24oKSBvclxubm90ZUdyYWluT24oKSwgZGVwZW5kaW5nIG9uIHBhcmFtZXRlcnMuXG5cblRoZSBmb2xsb3dpbmcgYWxpYXNlcyBvbmx5IHRha2UgZWZmZWN0IGlmIHRoZSBuZXcgbmFtZXMgYXJlIG5vdCBhbHJlYWR5IGluIHBsYWNlOlxuXG5BdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5BdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlR2Fpbk5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCkgaXMgYWxpYXNlZCB0byBjcmVhdGVEZWxheU5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlSmF2YVNjcmlwdE5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZSgpIGlzIGFsaWFzZWQgdG8gY3JlYXRlV2F2ZVRhYmxlKClcbk9zY2lsbGF0b3JOb2RlLnN0YXJ0KCkgaXMgYWxpYXNlZCB0byBub3RlT24oKVxuT3NjaWxsYXRvck5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5Pc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIHNldFdhdmVUYWJsZSgpXG5BdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSgpIGlzIGFsaWFzZWQgdG8gc2V0VGFyZ2V0VmFsdWVBdFRpbWUoKVxuXG5UaGlzIGxpYnJhcnkgZG9lcyBOT1QgcGF0Y2ggdGhlIGVudW1lcmF0ZWQgdHlwZSBjaGFuZ2VzLCBhcyBpdCBpc1xucmVjb21tZW5kZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gdGhhdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCBib3RoIGludGVnZXJcbmFuZCBzdHJpbmcgdHlwZXMgZm9yIEF1ZGlvUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwsIEF1ZGlvUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsXG5CaXF1YWRGaWx0ZXJOb2RlLnR5cGUgYW5kIE9zY2lsbGF0b3JOb2RlLnR5cGUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZXhwb3J0cywgcGVyZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZml4U2V0VGFyZ2V0KHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbSlcdC8vIGlmIE5ZSSwganVzdCByZXR1cm5cbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXBhcmFtLnNldFRhcmdldEF0VGltZSlcbiAgICAgIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykgJiZcbiAgICAgICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpKSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdlYmtpdEF1ZGlvQ29udGV4dDtcblxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlR2FpbicpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZURlbGF5JykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVTY3JpcHRQcm9jZXNzb3InKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0Tm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZVBlcmlvZGljV2F2ZScpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcblxuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUdhaW4oKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBmdW5jdGlvbihtYXhEZWxheVRpbWUpIHtcbiAgICAgIHZhciBub2RlID0gbWF4RGVsYXlUaW1lID8gdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheShtYXhEZWxheVRpbWUpIDogdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheSgpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbiApIHtcbiAgICAgICAgICBpZiAoIG9mZnNldCB8fCBkdXJhdGlvbiApXG4gICAgICAgICAgICB0aGlzLm5vdGVHcmFpbk9uKCB3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24gKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uKCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgZHVyYXRpb24gIT09ICd1bmRlZmluZWQnIClcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0IHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICB0aGlzLm5vdGVPZmYoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS50aHJlc2hvbGQpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUua25lZSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yZWR1Y3Rpb24pO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuYXR0YWNrKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXI7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBpZiAoQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSggJ2NyZWF0ZU9zY2lsbGF0b3InICkpIHtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgdGhpcy5ub3RlT24oIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuc3RvcCkge1xuICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnNldFBlcmlvZGljV2F2ZSlcbiAgICAgICAgICBub2RlLnNldFBlcmlvZGljV2F2ZSA9IG5vZGUuc2V0V2F2ZVRhYmxlO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpICYmXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gIH1cblxufSh3aW5kb3cpKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXG5pZiAoIU1hdGgudHJ1bmMpIHtcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xuICAgIH07XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuKi9cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcblxuICAgIC8qIGpzaGludCBmcmVlemU6IGZhbHNlICovXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gdGhpcyA6IHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSAoZnVuY3Rpb24gRihwcm90bykge1xuICAgICAgICAgICAgICAgIGlmIChwcm90bylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEYpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IHN1cGVybmV3OiB0cnVlICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSh0YXJnZXQucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5pc0FycmF5XG4qL1xuaWYgKCFBcnJheS5pc0FycmF5KVxue1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAoYXJnKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5mb3JFYWNoXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcbiovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKVxue1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICAgIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiogTG93LWJ1ZGdldCBGbG9hdDMyQXJyYXkga25vY2stb2ZmLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggUDIuanMgaW4gSUU5XG4qIFNvdXJjZTogaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy81OTg4LXBoYXNlci0xMi1pZTkvXG4qIENhbWVyb24gRm9hbGUgKGh0dHA6Ly93d3cua2liaWJ1LmNvbSlcbiovXG5pZiAodHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwib2JqZWN0XCIpXG57XG4gICAgdmFyIENoZWFwQXJyYXkgPSBmdW5jdGlvbih0eXBlKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IEFycmF5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgIHdpbmRvd1t0eXBlXSA9IGZ1bmN0aW9uKGFyZykge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gYXJnW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3dbdHlwZV0ucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHdpbmRvd1t0eXBlXS5jb25zdHJ1Y3RvciA9IHdpbmRvd1t0eXBlXTtcbiAgICB9O1xuXG4gICAgQ2hlYXBBcnJheSgnRmxvYXQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ1VpbnQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ1VpbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ0ludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgQ2hlYXBBcnJheSgnQXJyYXlCdWZmZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cbi8qKlxuICogQWxzbyBmaXggZm9yIHRoZSBhYnNlbnQgY29uc29sZSBpbiBJRTlcbiAqL1xuaWYgKCF3aW5kb3cuY29uc29sZSlcbntcbiAgICB3aW5kb3cuY29uc29sZSA9IHt9O1xuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB3aW5kb3cuY29uc29sZS53YXJuID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xufVxuXG4vKipcbiAqIHBlcmZvcm1hbmNlLm5vd1xuICovXG4oZnVuY3Rpb24oKXtcblxuICBpZiAoXCJwZXJmb3JtYW5jZVwiIGluIHdpbmRvdyA9PSBmYWxzZSkge1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XG4gIH1cbiAgXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfSk7XG5cbiAgaWYgKFwibm93XCIgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IGZhbHNlKVxuICB7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgXG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcbiAgICB9XG5cbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9XG4gIH1cblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXG5pZiAoIU1hdGgudHJ1bmMpIHtcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cblxuLyoqXG4qIExvdy1idWRnZXQgRmxvYXQzMkFycmF5IGtub2NrLW9mZiwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFAyLmpzIGluIElFOVxuKiBTb3VyY2U6IGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvNTk4OC1waGFzZXItMTItaWU5L1xuKiBDYW1lcm9uIEZvYWxlIChodHRwOi8vd3d3LmtpYmlidS5jb20pXG4qL1xuaWYgKHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcIm9iamVjdFwiKVxue1xuICAgIHZhciBDaGVhcEFycmF5ID0gZnVuY3Rpb24odHlwZSlcbiAgICB7XG4gICAgICAgIHZhciBwcm90byA9IG5ldyBBcnJheSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICB3aW5kb3dbdHlwZV0gPSBmdW5jdGlvbihhcmcpIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93W3R5cGVdLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB3aW5kb3dbdHlwZV0uY29uc3RydWN0b3IgPSB3aW5kb3dbdHlwZV07XG4gICAgfTtcblxuICAgIENoZWFwQXJyYXkoJ0Zsb2F0MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdVaW50MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdVaW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdJbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ0FycmF5QnVmZmVyJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxuICovXG5pZiAoIXdpbmRvdy5jb25zb2xlKVxue1xuICAgIHdpbmRvdy5jb25zb2xlID0ge307XG4gICAgd2luZG93LmNvbnNvbGUubG9nID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuICogcGVyZm9ybWFuY2Uubm93XG4gKi9cbihmdW5jdGlvbigpe1xuXG4gIGlmIChcInBlcmZvcm1hbmNlXCIgaW4gd2luZG93ID09IGZhbHNlKSB7XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgfVxuICBcbiAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyAgLy8gdGhhbmtzIElFOFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9KTtcblxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXG4gIHtcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydFxuICAgIH1cblxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3coKXtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL3BlcmZvcm1hbmNlLm5vdy5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCIvLyBSZWZlcmVuY2VzOlxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE1Nzk2NzFcbi8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS90cmVlL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XG4vLyBCcm93c2VyaWZ5IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgdXNlIG9mIGBnbG9iYWxgIGFuZCBwYXNzZXMgdGhlXG4vLyBjb3JyZWN0IHJlZmVyZW5jZSBvZiBgZ2xvYmFsYCwgYHNlbGZgLCBhbmQgZmluYWxseSBgd2luZG93YFxuXG4vLyBEYXRlLm5vd1xuaWYgKCEoRGF0ZS5ub3cgJiYgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSkpIHtcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5cbi8vIHBlcmZvcm1hbmNlLm5vd1xuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKCFnbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XG4gICAgfVxuICAgIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG59XG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbn1cblxuaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJ2lzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjYWxsYmFjayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xufVxuXG5pZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRHJhd0ltYWdlID0gcmVxdWlyZSgnLi91dGlscy9EcmF3SW1hZ2UnKTtcblxudmFyIENhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXG57XG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXG4gICAgKi9cbiAgICAvLyAgTmVlZGVkP1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG5cbiAgICAvLyB0aGlzLnR5cGUgPSBDT05TVC5DQU5WQVM7XG5cbiAgICAvLyAgUmVhZCBhbGwgdGhlIGZvbGxvd2luZyBmcm9tIGdhbWUgY29uZmlnXG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XG5cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG5cbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcblxuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiB0cnVlIH0pO1xuXG4gICAgLy8gdGhpcy5zbW9vdGhQcm9wZXJ0eSA9IFBoYXNlci5DYW52YXMuZ2V0U21vb3RoaW5nUHJlZml4KHRoaXMuY29udGV4dCk7XG5cbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XG5cbiAgICAvLyAgTWFwIHRvIHRoZSByZXF1aXJlZCBmdW5jdGlvblxuICAgIHRoaXMuZHJhd0ltYWdlID0gRHJhd0ltYWdlO1xuXG4gICAgdmFyIHNvID0gJ3NvdXJjZS1vdmVyJztcblxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFsgc28sICdsaWdodGVyJywgc28sIHNvLCBzbywgc28sIHNvLCBzbywgc28sIHNvLCBzbywgc28sIHNvLCBzbywgc28sIHNvLCBzbyBdO1xuXG4gICAgdGhpcy5jdXJyZW50QWxwaGEgPSAxO1xuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gMDtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmVuZFRpbWUgPSAwO1xuICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcblxuICAgIC8vIHRoaXMudGludE1ldGhvZCA9IHRoaXMudGludFdpdGhQZXJQaXhlbDtcblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVuZGVyZXI7XG5cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLm1hcEJsZW5kTW9kZXMoKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcHMgQmxlbmQgbW9kZXMgdG8gQ2FudmFzIGJsZW5kIG1vZGVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBtYXBCbGVuZE1vZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYXBCbGVuZE1vZGVzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gdmFyIG1vZGVzID0gUGhhc2VyLmJsZW5kTW9kZXM7XG5cbiAgICAgICAgLy8gdGhpcy5ibGVuZE1vZGVzW21vZGVzLk1VTFRJUExZXSA9ICdtdWx0aXBseSc7XG4gICAgICAgIC8vIHRoaXMuYmxlbmRNb2Rlc1ttb2Rlcy5TQ1JFRU5dID0gJ3NjcmVlbic7XG4gICAgICAgIC8vIHRoaXMuYmxlbmRNb2Rlc1ttb2Rlcy5PVkVSTEFZXSA9ICdvdmVybGF5JztcbiAgICAgICAgLy8gdGhpcy5ibGVuZE1vZGVzW21vZGVzLkRBUktFTl0gPSAnZGFya2VuJztcbiAgICAgICAgLy8gdGhpcy5ibGVuZE1vZGVzW21vZGVzLkxJR0hURU5dID0gJ2xpZ2h0ZW4nO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuQ09MT1JfRE9ER0VdID0gJ2NvbG9yLWRvZGdlJztcbiAgICAgICAgLy8gdGhpcy5ibGVuZE1vZGVzW21vZGVzLkNPTE9SX0JVUk5dID0gJ2NvbG9yLWJ1cm4nO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuSEFSRF9MSUdIVF0gPSAnaGFyZC1saWdodCc7XG4gICAgICAgIC8vIHRoaXMuYmxlbmRNb2Rlc1ttb2Rlcy5TT0ZUX0xJR0hUXSA9ICdzb2Z0LWxpZ2h0JztcbiAgICAgICAgLy8gdGhpcy5ibGVuZE1vZGVzW21vZGVzLkRJRkZFUkVOQ0VdID0gJ2RpZmZlcmVuY2UnO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuRVhDTFVTSU9OXSA9ICdleGNsdXNpb24nO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuSFVFXSA9ICdodWUnO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuU0FUVVJBVElPTl0gPSAnc2F0dXJhdGlvbic7XG4gICAgICAgIC8vIHRoaXMuYmxlbmRNb2Rlc1ttb2Rlcy5DT0xPUl0gPSAnY29sb3InO1xuICAgICAgICAvLyB0aGlzLmJsZW5kTW9kZXNbbW9kZXMuTFVNSU5PU0lUWV0gPSAnbHVtaW5vc2l0eSc7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlcztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXM7XG5cbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IC8gcmVzKSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAodGhpcy5zbW9vdGhQcm9wZXJ0eSlcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5jb250ZXh0W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHRoaXMuc2NhbGVNb2RlID09PSBQaGFzZXIuc2NhbGVNb2Rlcy5MSU5FQVIpO1xuICAgICAgICAvLyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIFN0YXRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVycG9sYXRpb25QZXJjZW50YWdlIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LCBkaXZpZGVkXG4gICAgICogICBieSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB3aWxsIGJlIHNpbXVsYXRlZCB0aGUgbmV4dCB0aW1lIHVwZGF0ZSgpXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKHN0YXRlLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCclYyByZW5kZXIgc3RhcnQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjMDBmZjAwOycpO1xuXG4gICAgICAgIC8vICBBZGQgUHJlLXJlbmRlciBob29rXG5cbiAgICAgICAgLy8gIFRPRE86IEEgU3RhdGUgc2hvdWxkIGhhdmUgdGhlIG9wdGlvbiBvZiBoYXZpbmcgaXRzIG93biBjYW52YXMgdG8gZHJhdyB0b1xuXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgIC8vICBJZiB0aGUgYWxwaGEgb3IgYmxlbmQgbW9kZSBkaWRuJ3QgY2hhbmdlIHNpbmNlIHRoZSBsYXN0IHJlbmRlciwgdGhlbiBkb24ndCBzZXQgdGhlbSBhZ2FpbiAoc2F2ZXMgMiBvcHMpXG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuXG4gICAgICAgIC8vICBDb3VsZCBtb3ZlIHRvIHRoZSBTdGF0ZSBTeXN0ZW1zIG9yIE1haW5Mb29wXG4gICAgICAgIHRoaXMuZ2FtZS5zdGF0ZS5yZW5kZXJDaGlsZHJlbih0aGlzLCBzdGF0ZSwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UpO1xuXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBlbmQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjZmYwMDAwOycpO1xuXG4gICAgICAgIC8vICBBZGQgUG9zdC1yZW5kZXIgaG9va1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICogQHBhcmFtIFtyZW1vdmVWaWV3PXRydWVdIHtib29sZWFufSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBDYW52YXNQb29sXG5cbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJcbnZhciBEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoZnJhbWUsIGJsZW5kTW9kZSwgdHJhbnNmb3JtLCBhbHBoYSwgdGludCwgYmcpXG57XG4gICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xuXG4gICAgLy8gIEJsZW5kIE1vZGVcblxuICAgIGlmICh0aGlzLmN1cnJlbnRCbGVuZE1vZGUgIT09IGJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tibGVuZE1vZGVdO1xuICAgIH1cblxuICAgIC8vICBBbHBoYVxuXG4gICAgaWYgKHRoaXMuY3VycmVudEFscGhhICE9PSBhbHBoYSlcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gYWxwaGE7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cblxuICAgIC8vICBTbW9vdGhpbmcgKHNob3VsZCB0aGlzIGJlIGEgR2FtZSBPYmplY3QsIG9yIEZyYW1lIC8gVGV4dHVyZSBsZXZlbCBwcm9wZXJ0eT8pXG5cbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBmcmFtZS5zb3VyY2Uuc2NhbGVNb2RlKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gc291cmNlLnNjYWxlTW9kZTtcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFBoYXNlci5zY2FsZU1vZGVzLkxJTkVBUik7XG4gICAgfVxuXG4gICAgY3R4LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuICAgIGN0eC5kcmF3SW1hZ2UoZnJhbWUuc291cmNlLmltYWdlLCBjZC5zeCwgY2Quc3ksIGNkLnNXaWR0aCwgY2Quc0hlaWdodCwgdHJhbnNmb3JtLmR4LCB0cmFuc2Zvcm0uZHksIGNkLmRXaWR0aCwgY2QuZEhlaWdodCk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhd0ltYWdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi91dGlscy9CaW5kVmVydGV4QXJyYXknKTtcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vdXRpbHMvQ3JlYXRlUHJvZ3JhbScpO1xudmFyIENyZWF0ZVNoYWRlciA9IHJlcXVpcmUoJy4uL3V0aWxzL0NyZWF0ZVNoYWRlcicpO1xudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWxzL0NyZWF0ZUJ1ZmZlcicpO1xudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi91dGlscy9DcmVhdGVBdHRyaWJEZXNjJyk7XG52YXIgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vdXRpbHMvVmVydGV4QnVmZmVyJyk7XG52YXIgSW5kZXhCdWZmZXIgPSByZXF1aXJlKCcuLi91dGlscy9JbmRleEJ1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbHMvVmVydGV4QXJyYXknKTtcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbnZhciBQYXJ0aWNsZVJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXG57XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICB0aGlzLmdsQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5tYXhQYXJ0aWNsZXMgPSBudWxsO1xuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnR5cGUgPSBDT05TVC5XRUJHTDtcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSBnYW1lLmNvbmZpZy53aWR0aCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSBnYW1lLmNvbmZpZy5oZWlnaHQgKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcblxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vLyBWRVJURVhfU0laRSA9IHNpemVvZih2ZWMyKSArIHNpemVvZih2ZWMyKVxuUGFydGljbGVSZW5kZXJlci5WRVJURVhfU0laRSA9IDE2O1xuUGFydGljbGVSZW5kZXJlci5JTkRFWF9TSVpFID0gMjtcblBhcnRpY2xlUmVuZGVyZXIuUEFSVElDTEVfVkVSVEVYX0NPVU5UID0gNDtcblBhcnRpY2xlUmVuZGVyZXIuUEFSVElDTEVfSU5ERVhfQ09VTlQgPSA2O1xuXG4vLyBIb3cgbWFueSAzMi1iaXQgY29tcG9uZW50cyBkb2VzIHRoZSB2ZXJ0ZXggaGF2ZS5cblBhcnRpY2xlUmVuZGVyZXIuUEFSVElDTEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCA9IDQ7XG5cbi8vIENhbid0IGJlIGJpZ2dlciBzaW5jZSBpbmRleCBhcmUgMTYtYml0XG5QYXJ0aWNsZVJlbmRlcmVyLk1BWF9QQVJUSUNMRVMgPSAxMDAwMDtcblBhcnRpY2xlUmVuZGVyZXIuVkVSVEVYX1NIQURFUl9TT1VSQ0UgPSBbXG4gICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhfY29vcmQ7JyxcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXG4gICAgJ3ZvaWQgbWFpbiAoKSB7JyxcbiAgICAnICAgZ2xfUG9zaXRpb24gPSB1X3ZpZXdfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAxLjAsIDEuMCk7JyxcbiAgICAnICAgdl90ZXhfY29vcmQgPSBhX3RleF9jb29yZDsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcblBhcnRpY2xlUmVuZGVyZXIuRlJBR01FTlRfU0hBREVSX1NPVVJDRSA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKTsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcblxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuZ2xDb250ZXh0ID09PSBudWxsKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgdGhpcy5jb25maWcuV2ViR0xDb250ZXh0T3B0aW9ucykgfHwgdGhpcy52aWV3LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpO1xuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoUGFydGljbGVSZW5kZXJlci5WRVJURVhfU0laRSAqIFBhcnRpY2xlUmVuZGVyZXIuUEFSVElDTEVfVkVSVEVYX0NPVU5UICogUGFydGljbGVSZW5kZXJlci5NQVhfUEFSVElDTEVTKTtcbiAgICAgICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcihQYXJ0aWNsZVJlbmRlcmVyLklOREVYX1NJWkUgKiBQYXJ0aWNsZVJlbmRlcmVyLlBBUlRJQ0xFX0lOREVYX0NPVU5UICogUGFydGljbGVSZW5kZXJlci5NQVhfUEFSVElDTEVTKTtcbiAgICAgICAgdmFyIHZlcnRTaGFkZXIgPSBDcmVhdGVTaGFkZXIoZ2wsIFBhcnRpY2xlUmVuZGVyZXIuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgUGFydGljbGVSZW5kZXJlci5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVJfU09VUkNFKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XG4gICAgICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBWZXJ0ZXhBcnJheShnbCxcbiAgICAgICAgICAgICAgICBDcmVhdGVCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RSRUFNX0RSQVcsIG51bGwsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIFBhcnRpY2xlUmVuZGVyZXIuVkVSVEVYX1NJWkUsIDApLFxuICAgICAgICAgICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV90ZXhfY29vcmQnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIFBhcnRpY2xlUmVuZGVyZXIuVkVSVEVYX1NJWkUsIDgpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV92aWV3X21hdHJpeCcpO1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcblxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5ID0gdmVydGV4QXJyYXk7XG4gICAgICAgIHRoaXMuZ2xDb250ZXh0ID0gZ2w7XG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xuICAgICAgIFxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlck9iamVjdCk7XG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlci53b3JkVmlldztcblxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgaW5kZXggYnVmZmVyIG9ubHkgb25jZVxuICAgICAgICBmb3IgKHZhciBpbmRleEEgPSBpbmRleEIgPSAwO1xuICAgICAgICAgICAgaW5kZXhBIDwgUGFydGljbGVSZW5kZXJlci5NQVhfUEFSVElDTEVTICogUGFydGljbGVSZW5kZXJlci5QQVJUSUNMRV9JTkRFWF9DT1VOVDtcbiAgICAgICAgICAgIGluZGV4QSArPSBQYXJ0aWNsZVJlbmRlcmVyLlBBUlRJQ0xFX0lOREVYX0NPVU5ULCBpbmRleEIgKz0gUGFydGljbGVSZW5kZXJlci5QQVJUSUNMRV9WRVJURVhfQ09VTlQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BhcnRpY2xlUmVuZGVyZXIgYWxyZWFkeSBpbml0aWFsaXplZCcpO1xuICAgIH1cbn07XG5cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xuICAgIGlmIChnbClcbiAgICB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XG4gICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEFycmF5LmJ1ZmZlcik7XG4gICAgfVxufTtcblxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuaXNGdWxsID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICByZXR1cm4gKHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xufTtcblxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHVtaW4sIHZtaW4sIHVtYXgsIHZtYXgpXG57XG4gICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcbiAgICAvLyB0aGlzIGlzIHRvIGdpdmUgZnJlZWRvbSBvZiB3aGVuIHNob3VsZCB0aGUgcmVuZGVyZXIgZmx1c2guXG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG4gICAgdmFyIGluZGV4RGF0YUJ1ZmZlciA9IHRoaXMuaW5kZXhEYXRhQnVmZmVyO1xuICAgIHZhciB2ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcbiAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShQYXJ0aWNsZVJlbmRlcmVyLlBBUlRJQ0xFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQgKiBQYXJ0aWNsZVJlbmRlcmVyLlBBUlRJQ0xFX1ZFUlRFWF9DT1VOVCk7XG5cbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geTtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1pbjtcbiAgICBcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geDtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcblxuICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB4ICsgd2lkdGg7XG4gICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XG4gICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtYXg7XG4gICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtYXg7XG5cbiAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xuICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xuICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xuICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWluO1xuXG4gICAgdGhpcy5lbGVtZW50Q291bnQgKz0gUGFydGljbGVSZW5kZXJlci5QQVJUSUNMRV9JTkRFWF9DT1VOVDtcbn07XG5cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHR1cmUyRCA9IGZ1bmN0aW9uICh0ZXh0dXJlMkQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmUyRCAhPT0gdGV4dHVyZTJEKVxuICAgIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZTJEKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gdGV4dHVyZTJEO1xuICAgIH1cbn07XG5cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gIFN0b3BzIGl0IGJyZWFraW5nXG59O1xuXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xuICAgIEJpbmRWZXJ0ZXhBcnJheSh0aGlzLnZlcnRleEFycmF5KTtcbn07XG5cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG59O1xuXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xufTtcblxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICBcbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXM7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXM7XG4gICAgXG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgXG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIC8gcmVzKSArICdweCc7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcbiAgICB9XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAyIC8gdGhpcy52aWV3LndpZHRoLCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgLTIgLyB0aGlzLnZpZXcuaGVpZ2h0LCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMSwgMSxcbiAgICAgICAgICAgIC0xLCAxLCAwLCAwXG4gICAgICAgIF0pXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3JlbmRlcmVycy9QYXJ0aWNsZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXJzL1BhcnRpY2xlUmVuZGVyZXIuanMiLCJ2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBzaXplLCB0eXBlLCBub3JtYWxpemUsIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0F0dHJpYnV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaW5kVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAoZ2wsIHZhbylcbntcbiAgICB2YXIgYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2YW8uYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWIgPSBhdHRyaWJ1dGVzW2luZGV4XTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gYXR0cmliLmxvY2F0aW9uO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIGF0dHJpYi5zaXplLFxuICAgICAgICAgICAgYXR0cmliLnR5cGUsXG4gICAgICAgICAgICBhdHRyaWIubm9ybWFsaXplZCxcbiAgICAgICAgICAgIGF0dHJpYi5zdHJpZGUsXG4gICAgICAgICAgICBhdHRyaWIub2Zmc2V0XG4gICAgICAgICk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5kVmVydGV4QXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9CaW5kVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi9BdHRyaWJ1dGUnKTtcblxudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSBmdW5jdGlvbiAoZ2wsIHByb2dyYW0sIG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIHJldHVybiBuZXcgQXR0cmlidXRlKFxuICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbm9ybWFsaXplZCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBvZmZzZXRcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVBdHRyaWJEZXNjO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlQXR0cmliRGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ2YXIgQ3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKGdsLCBidWZmZXJUeXBlLCB1c2FnZSwgYnVmZmVyRGF0YSwgYnVmZmVyU2l6ZSlcbntcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xuICAgIGlmIChidWZmZXJEYXRhICYmIEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXJEYXRhKSlcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyRGF0YSwgdXNhZ2UpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlclR5cGUsIGJ1ZmZlclNpemUsIHVzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlQnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXG57XG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW0uIEVycm9yOiBcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVByb2dyYW07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVQcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyZWF0ZVNoYWRlciA9IGZ1bmN0aW9uIChnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlKVxue1xuICAgIHZhciBzaGFkZXIgPSBudWxsO1xuICAgIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCAnICsgKHNoYWRlclR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6IHNoYWRlclR5cGUgPT09IGdsLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAnaW52YWxpZCcpICsgJyBzaGFkZXIgY29tcGlsYXRpb24uIEVycm9yOiBcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVNoYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL0NyZWF0ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uIChieXRlU2l6ZSlcbntcbiAgICB0aGlzLndvcmRMZW5ndGggPSAwO1xuICAgIHRoaXMud29yZENhcGFjaXR5ID0gYnl0ZVNpemUgLyAyO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcbiAgICB0aGlzLnNob3J0VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLndvcmRWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYnVmZmVyKTtcbn07XG5cbkluZGV4QnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy53b3JkTGVuZ3RoID0gMDtcbn07XG5cbkluZGV4QnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy53b3JkTGVuZ3RoICogMjtcbn07XG5cbkluZGV4QnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcbntcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbn07XG5cbkluZGV4QnVmZmVyLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uICh3b3JkU2l6ZSlcbntcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMud29yZExlbmd0aDtcbiAgICB0aGlzLndvcmRMZW5ndGggKz0gd29yZFNpemU7XG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XG59O1xuXG5JbmRleEJ1ZmZlci5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzU2hvcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLnNob3J0Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcbn07XG5cbkluZGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNXb3JkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy53b3JkVmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9JbmRleEJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2Ym8sIGF0dHJpYnV0ZXMpXG57XG4gICAgdGhpcy5idWZmZXIgPSB2Ym87XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9WZXJ0ZXhBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbiAoYnl0ZVNpemUpXG57XG4gICAgdGhpcy5kd29yZExlbmd0aCA9IDA7XG4gICAgdGhpcy5kd29yZENhcGFjaXR5ID0gYnl0ZVNpemUgLyA0O1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcbiAgICB0aGlzLmZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5idWZmZXIpO1xuICAgIHRoaXMuaW50VmlldyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcbn07XG5cblZlcnRleEJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuZHdvcmRMZW5ndGggPSAwO1xufTtcblxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5kd29yZExlbmd0aCAqIDQ7XG59O1xuXG5WZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVDYXBhY2l0eSA9IGZ1bmN0aW9uICgpIFxue1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xufTtcblxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIChkd29yZFNpemUpXG57XG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLmR3b3JkTGVuZ3RoO1xuICAgIHRoaXMuZHdvcmRMZW5ndGggKz0gZHdvcmRTaXplO1xuICAgIHJldHVybiBjdXJyZW50TGVuZ3RoO1xufTtcblxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNGbG9hdCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xufTtcblxuVmVydGV4QnVmZmVyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNJbnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy5kd29yZExlbmd0aCk7XG59O1xuXG5WZXJ0ZXhCdWZmZXIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc1VpbnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLnVpbnRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9WZXJ0ZXhCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9CZXR3ZWVuJyk7XG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9HZXRPYmplY3RWYWx1ZScpO1xuXG4vLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWMuRlhcblxuLy8gIEJhc2VkIG9uIFNvdW5kLmpzIGJ5IEtpdHR5S2F0QXR0YWNrXG4vLyAgaHR0cHM6Ly9naXRodWIuY29tL2tpdHR5a2F0YXR0YWNrL3NvdW5kLmpzXG5cbi8vIGZyZXF1ZW5jeSwgICAgICAvL1RoZSBzb3VuZCdzIGZlcXVlbmN5IHBpdGNoIGluIEhlcnR6XG4vLyBhdHRhY2ssICAgICAgICAgICAgICAvL1RoZSB0aW1lLCBpbiBzZWNvbmRzLCB0byBmYWRlIHRoZSBzb3VuZCBpblxuLy8gZGVjYXksICAgICAgICAgICAgICAgLy9UaGUgdGltZSwgaW4gc2Vjb25kcywgdG8gZmFkZSB0aGUgc291bmQgb3V0XG4vLyB0eXBlLCAgICAgICAgICAgICAgICAvL3dhdmVmb3JtIHR5cGU6IFwic2luZVwiLCBcInRyaWFuZ2xlXCIsIFwic3F1YXJlXCIsIFwic2F3dG9vdGhcIlxuLy8gdm9sdW1lLCAgICAgICAgIC8vVGhlIHNvdW5kJ3MgbWF4aW11bSB2b2x1bWVcbi8vIHBhblZhbHVlLCAgICAgICAgICAgIC8vVGhlIHNwZWFrZXIgcGFuLiBsZWZ0OiAtMSwgbWlkZGxlOiAwLCByaWdodDogMVxuLy8gd2FpdCwgICAgICAgICAgICAgICAgLy9UaGUgdGltZSwgaW4gc2Vjb25kcywgdG8gd2FpdCBiZWZvcmUgcGxheWluZyB0aGUgc291bmRcbi8vIHBpdGNoQmVuZCwgICAgIC8vVGhlIG51bWJlciBvZiBIeiBpbiB3aGljaCB0byBiZW5kIHRoZSBzb3VuZCdzIHBpdGNoIGRvd25cbi8vIHJldmVyc2UsICAgICAgICAgICAgIC8vSWYgYHJldmVyc2VgIGlzIHRydWUgdGhlIHBpdGNoIHdpbGwgYmVuZCB1cFxuLy8gcmFuZG9tLCAgICAgICAgIC8vQSByYW5nZSwgaW4gSHosIHdpdGhpbiB3aGljaCB0byByYW5kb21pemUgdGhlIHBpdGNoXG4vLyBkaXNzb25hbmNlLCAgICAgICAgICAvL0EgdmFsdWUgaW4gSHouIEl0IGNyZWF0ZXMgMiBkaXNzb25hbnQgZnJlcXVlbmNpZXMgYWJvdmUgYW5kIGJlbG93IHRoZSB0YXJnZXQgcGl0Y2hcbi8vIGVjaG8sICAgICAgICAgICAgICAgIC8vQW4gYXJyYXk6IFtkZWxheVRpbWVJblNlY29uZHMsIGZlZWRiYWNrVGltZUluU2Vjb25kcywgZmlsdGVyVmFsdWVJbkh6XVxuLy8gcmV2ZXJiLCAgICAgICAgICAgICAgLy9BbiBhcnJheTogW2R1cmF0aW9uSW5TZWNvbmRzLCBkZWNheVJhdGVJblNlY29uZHMsIHJldmVyc2VdXG4vLyB0aW1lb3V0ICAgICAgICAgICAgICAvL0EgbnVtYmVyLCBpbiBzZWNvbmRzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBkdXJhdGlvbiBmb3Igc291bmQgZWZmZWN0c1xuXG52YXIgRlggPSBmdW5jdGlvbiAoY3R4LCBjb25maWcpXG57XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBjdHg7XG5cbiAgICB0aGlzLmZyZXF1ZW5jeVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZnJlcXVlbmN5JywgMjAwKTtcbiAgICB0aGlzLmF0dGFjayA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2F0dGFjaycsIDApO1xuICAgIHRoaXMuZGVjYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdkZWNheScsIDEpO1xuICAgIHRoaXMudHlwZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3R5cGUnLCAnc2luZScpO1xuICAgIHRoaXMudm9sdW1lVmFsdWUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2b2x1bWUnLCAxKTtcbiAgICB0aGlzLnBhblZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGFuJywgMCk7XG4gICAgdGhpcy53YWl0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2FpdCcsIDApO1xuICAgIHRoaXMucGl0Y2hCZW5kQW1vdW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGl0Y2hCZW5kJywgMCk7XG4gICAgdGhpcy5yZXZlcnNlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmV2ZXJzZScsIGZhbHNlKTtcbiAgICB0aGlzLnJhbmRvbVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmFuZG9tJywgMCk7XG4gICAgdGhpcy5kaXNzb25hbmNlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZGlzc29uYW5jZScsIDApO1xuICAgIHRoaXMuZWNobyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8nLCBmYWxzZSk7XG4gICAgdGhpcy5lY2hvRGVsYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvLmRlbGF5JywgMCk7XG4gICAgdGhpcy5lY2hvRmVlZGJhY2sgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvLmZlZWRiYWNrJywgMCk7XG4gICAgdGhpcy5lY2hvRmlsdGVyID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZWNoby5maWx0ZXInLCAwKTtcbiAgICB0aGlzLnJldmVyYiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYicsIGZhbHNlKTtcbiAgICB0aGlzLnJldmVyYkR1cmF0aW9uID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncmV2ZXJiLmR1cmF0aW9uJywgMCk7XG4gICAgdGhpcy5yZXZlcmJEZWNheSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5kZWNheScsIDApO1xuICAgIHRoaXMucmV2ZXJiUmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5yZXZlcnNlJywgZmFsc2UpO1xuICAgIHRoaXMudGltZW91dCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3RpbWVvdXQnLCBmYWxzZSk7XG5cbiAgICB0aGlzLnZvbHVtZSA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5wYW4gPSAoIWN0eC5jcmVhdGVTdGVyZW9QYW5uZXIpID8gY3R4LmNyZWF0ZVBhbm5lcigpIDogY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpO1xuXG4gICAgdGhpcy52b2x1bWUuY29ubmVjdCh0aGlzLnBhbik7XG4gICAgdGhpcy5wYW4uY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuXG4gICAgLy8gIFNldCB0aGUgdmFsdWVzXG5cbiAgICB0aGlzLnZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcblxuICAgIGlmICghY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcilcbiAgICB7XG4gICAgICAgIHRoaXMucGFuLnNldFBvc2l0aW9uKHRoaXMucGFuVmFsdWUsIDAsIDEgLSBNYXRoLmFicyh0aGlzLnBhblZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMucGFuLnBhbi52YWx1ZSA9IHRoaXMucGFuVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gIENyZWF0ZSBhbiBvc2NpbGxhdG9yLCBnYWluIGFuZCBwYW4gbm9kZXMsIGFuZCBjb25uZWN0IHRoZW0gdG9nZXRoZXIgdG8gdGhlIGRlc3RpbmF0aW9uXG5cbiAgICB2YXIgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG5cbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QodGhpcy52b2x1bWUpO1xuICAgIG9zY2lsbGF0b3IudHlwZSA9IHRoaXMudHlwZTtcblxuICAgIC8vICBPcHRpb25hbGx5IHJhbmRvbWl6ZSB0aGUgcGl0Y2ggaWYgYHJhbmRvbVZhbHVlYCA+IDAuXG4gICAgLy8gIEEgcmFuZG9tIHBpdGNoIGlzIHNlbGVjdGVkIHRoYXQncyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCBieSBgZnJlcXVlbmN5VmFsdWVgLlxuICAgIC8vICBUaGUgcmFuZG9tIHBpdGNoIHdpbGwgYmUgZWl0aGVyIGFib3ZlIG9yIGJlbG93IHRoZSB0YXJnZXQgZnJlcXVlbmN5LlxuXG4gICAgaWYgKHRoaXMucmFuZG9tVmFsdWUgPiAwKVxuICAgIHtcbiAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSBCZXR3ZWVuKFxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMucmFuZG9tVmFsdWUgLyAyLFxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSArIHRoaXMucmFuZG9tVmFsdWUgLyAyXG4gICAgICAgICk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyAgQXBwbHkgZWZmZWN0c1xuXG4gICAgaWYgKHRoaXMuYXR0YWNrID4gMClcbiAgICB7XG4gICAgICAgIHRoaXMuZmFkZUluKHRoaXMudm9sdW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmZhZGVPdXQodGhpcy52b2x1bWUpO1xuXG4gICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcbiAgICB7XG4gICAgICAgIHRoaXMucGl0Y2hCZW5kKG9zY2lsbGF0b3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVjaG8pXG4gICAge1xuICAgICAgICB0aGlzLmFkZEVjaG8odGhpcy52b2x1bWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJldmVyYilcbiAgICB7XG4gICAgICAgIHRoaXMuYWRkUmV2ZXJiKHRoaXMudm9sdW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXNzb25hbmNlID4gMClcbiAgICB7XG4gICAgICAgIHRoaXMuYWRkRGlzc29uYW5jZSgpO1xuICAgIH1cblxuICAgIHRoaXMucGxheShvc2NpbGxhdG9yKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBvc2NpbGxhdG9yLm9uZW5kZWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uZW5kZWQnKTtcbiAgICAgICAgX3RoaXMucGFuLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgX3RoaXMudm9sdW1lLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xufTtcblxuRlgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRlg7XG5cbkZYLnByb3RvdHlwZSA9IHtcblxuICAgIHBsYXk6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxuICAgIHtcbiAgICAgICAgb3NjaWxsYXRvci5zdGFydCh0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XG5cbiAgICAgICAgLy9Pc2NpbGxhdG9ycyBoYXZlIHRvIGJlIHN0b3BwZWQgb3RoZXJ3aXNlIHRoZXkgYWNjdW11bGF0ZSBpbiBcbiAgICAgICAgLy9tZW1vcnkgYW5kIHRheCB0aGUgQ1BVLiBUaGV5J2xsIGJlIHN0b3BwZWQgYWZ0ZXIgYSBkZWZhdWx0XG4gICAgICAgIC8vdGltZW91dCBvZiAyIHNlY29uZHMsIHdoaWNoIHNob3VsZCBiZSBlbm91Z2ggZm9yIG1vc3Qgc291bmQgXG4gICAgICAgIC8vZWZmZWN0cy4gT3ZlcnJpZGUgdGhpcyBpbiB0aGUgYHNvdW5kRWZmZWN0YCBwYXJhbWV0ZXJzIGlmIHlvdVxuICAgICAgICAvL25lZWQgYSBsb25nZXIgc291bmRcblxuICAgICAgICBvc2NpbGxhdG9yLnN0b3AodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyAyKTtcbiAgICB9LFxuXG4gICAgZmFkZUluOiBmdW5jdGlvbiAodm9sdW1lKVxuICAgIHtcbiAgICAgICAgdm9sdW1lLmdhaW4udmFsdWUgPSAwO1xuXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcblxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLnZvbHVtZVZhbHVlLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrKTtcbiAgICB9LFxuXG4gICAgZmFkZU91dDogZnVuY3Rpb24gKHZvbHVtZSlcbiAgICB7XG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMudm9sdW1lVmFsdWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2spO1xuXG4gICAgICAgIHZvbHVtZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgdGhpcy5hdHRhY2sgKyB0aGlzLmRlY2F5KTtcbiAgICB9LFxuXG4gICAgYWRkUmV2ZXJiOiBmdW5jdGlvbiAodm9sdW1lKVxuICAgIHtcbiAgICAgICAgdmFyIGNvbnZvbHZlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuXG4gICAgICAgIGNvbnZvbHZlci5idWZmZXIgPSB0aGlzLmltcHVsc2VSZXNwb25zZSh0aGlzLnJldmVyYkR1cmF0aW9uLCB0aGlzLnJldmVyYkRlY2F5LCB0aGlzLnJldmVyYlJldmVyc2UsIHRoaXMuYXVkaW9Db250ZXh0KTtcblxuICAgICAgICB2b2x1bWUuY29ubmVjdChjb252b2x2ZXIpO1xuXG4gICAgICAgIGNvbnZvbHZlci5jb25uZWN0KHRoaXMucGFuKTtcbiAgICB9LFxuXG4gICAgYWRkRWNobzogZnVuY3Rpb24gKHZvbHVtZSlcbiAgICB7XG4gICAgICAgIHZhciBmZWVkYmFjayA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlRGVsYXkoKTtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXG4gICAgICAgIC8vICBTZXQgdGhlIG5vZGUgdmFsdWVzXG5cbiAgICAgICAgZmVlZGJhY2suZ2Fpbi52YWx1ZSA9IHRoaXMuZWNob0ZlZWRiYWNrO1xuICAgICAgICBkZWxheS5kZWxheVRpbWUudmFsdWUgPSB0aGlzLmVjaG9EZWxheTtcblxuICAgICAgICBpZiAodGhpcy5lY2hvRmlsdGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBmaWx0ZXIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5lY2hvRmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgZGVsYXkgZmVlZGJhY2sgbG9vcCAod2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcpXG5cbiAgICAgICAgZGVsYXkuY29ubmVjdChmZWVkYmFjayk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWNob0ZpbHRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZmVlZGJhY2suY29ubmVjdChmaWx0ZXIpO1xuICAgICAgICAgICAgZmlsdGVyLmNvbm5lY3QoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmVlZGJhY2suY29ubmVjdChkZWxheSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgZGVsYXkgbm9kZSB0byB0aGUgb3NjaWxsYXRvciB2b2x1bWUgbm9kZVxuXG4gICAgICAgIHZvbHVtZS5jb25uZWN0KGRlbGF5KTtcblxuICAgICAgICAvLyAgQ29ubmVjdCB0aGUgZGVsYXkgbm9kZSB0byB0aGUgbWFpbiBzb3VuZCBjaGFpbnMgcGFuIG5vZGUsXG4gICAgICAgIC8vICBzbyB0aGF0IHRoZSBlY2hvIGVmZmVjdCBpcyBkaXJlY3RlZCB0byB0aGUgY29ycmVjdCBzcGVha2VyXG5cbiAgICAgICAgZGVsYXkuY29ubmVjdCh0aGlzLnBhbik7XG4gICAgfSxcblxuICAgIHBpdGNoQmVuZDogZnVuY3Rpb24gKG9zY2lsbGF0b3IpXG4gICAge1xuICAgICAgICB2YXIgZnJlcXVlbmN5ID0gb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBJZiByZXZlcnNlIGlzIGZhbHNlLCBtYWtlIHRoZSBzb3VuZCBkcm9wIGluIHBpdGNoXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSAtIHRoaXMucGl0Y2hCZW5kQW1vdW50LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyB0cnVlLCBtYWtlIHRoZSBzb3VuZCByaXNlIGluIHBpdGNoXG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3ksIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0KTtcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGZyZXF1ZW5jeSArIHRoaXMucGl0Y2hCZW5kQW1vdW50LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBhZGREaXNzb25hbmNlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gIENyZWF0ZSB0d28gbW9yZSBvc2NpbGxhdG9ycyBhbmQgZ2FpbiBub2Rlc1xuXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmF1ZGlvQ29udGV4dDtcblxuICAgICAgICB2YXIgZDEgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICB2YXIgZDIgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICB2YXIgZDFWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xuICAgICAgICB2YXIgZDJWb2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xuXG4gICAgICAgIC8vICBTZXQgdGhlIHZvbHVtZSB0byB0aGUgYHZvbHVtZVZhbHVlYFxuICAgICAgICBkMVZvbHVtZS5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVWYWx1ZTtcbiAgICAgICAgZDJWb2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XG5cbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIG9zY2lsbGF0b3JzIHRvIHRoZSBnYWluIGFuZCBkZXN0aW5hdGlvbiBub2Rlc1xuICAgICAgICBkMS5jb25uZWN0KGQxVm9sdW1lKTtcbiAgICAgICAgZDIuY29ubmVjdChkMlZvbHVtZSk7XG5cbiAgICAgICAgZDFWb2x1bWUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuICAgICAgICBkMlZvbHVtZS5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgLy8gIFNldCB0aGUgd2F2ZWZvcm0gdG8gXCJzYXd0b290aFwiIGZvciBhIGhhcnNoIGVmZmVjdFxuICAgICAgICBkMS50eXBlID0gJ3Nhd3Rvb3RoJztcbiAgICAgICAgZDIudHlwZSA9ICdzYXd0b290aCc7XG5cbiAgICAgICAgLy8gIE1ha2UgdGhlIHR3byBvc2NpbGxhdG9ycyBwbGF5IGF0IGZyZXF1ZW5jaWVzIGFib3ZlIGFuZCBiZWxvdyB0aGUgbWFpbiBzb3VuZCdzIGZyZXF1ZW5jeS5cbiAgICAgICAgLy8gIFVzZSB3aGF0ZXZlciB2YWx1ZSB3YXMgc3VwcGxpZWQgYnkgdGhlIGBkaXNzb25hbmNlYCBhcmd1bWVudFxuICAgICAgICBkMS5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlICsgdGhpcy5kaXNzb25hbmNlO1xuICAgICAgICBkMi5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmZyZXF1ZW5jeVZhbHVlIC0gdGhpcy5kaXNzb25hbmNlO1xuXG4gICAgICAgIC8vICBGYWRlIGluIC8gb3V0LCBwaXRjaCBiZW5kIGFuZCBwbGF5IHRoZSBvc2NpbGxhdG9ycyB0byBtYXRjaCB0aGUgbWFpbiBzb3VuZFxuICAgICAgICBpZiAodGhpcy5hdHRhY2sgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZhZGVJbihkMVZvbHVtZSk7XG4gICAgICAgICAgICB0aGlzLmZhZGVJbihkMlZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kZWNheSA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmFkZU91dChkMVZvbHVtZSk7XG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDJWb2x1bWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGl0Y2hCZW5kQW1vdW50ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5waXRjaEJlbmQoZDEpO1xuICAgICAgICAgICAgdGhpcy5waXRjaEJlbmQoZDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZWNobylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGRFY2hvKGQxVm9sdW1lKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMlZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZXZlcmIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUmV2ZXJiKGQxVm9sdW1lKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmV2ZXJiKGQyVm9sdW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxheShkMSk7XG4gICAgICAgIHRoaXMucGxheShkMik7XG4gICAgfSxcblxuICAgIGltcHVsc2VSZXNwb25zZTogZnVuY3Rpb24gKGR1cmF0aW9uLCBkZWNheSwgcmV2ZXJzZSlcbiAgICB7XG4gICAgICAgIC8vICBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlICogZHVyYXRpb247XG5cbiAgICAgICAgLy8gIENyZWF0ZSBhbiBhdWRpbyBidWZmZXIgKGFuIGVtcHR5IHNvdW5kIGNvbnRhaW5lcikgdG8gc3RvcmUgdGhlIHJldmVyYiBlZmZlY3QuXG4gICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDIsIGxlbmd0aCwgdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG5cbiAgICAgICAgLy8gIFVzZSBgZ2V0Q2hhbm5lbERhdGFgIHRvIGluaXRpYWxpemUgZW1wdHkgYXJyYXlzIHRvIHN0b3JlIHNvdW5kIGRhdGEgZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscy5cbiAgICAgICAgdmFyIGxlZnQgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICB2YXIgcmlnaHQgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDEpO1xuXG4gICAgICAgIC8vICBMb29wIHRocm91Z2ggZWFjaCBzYW1wbGUtZnJhbWUgYW5kIGZpbGwgdGhlIGNoYW5uZWwgZGF0YSB3aXRoIHJhbmRvbSBub2lzZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEFwcGx5IHRoZSByZXZlcnNlIGVmZmVjdCwgaWYgYHJldmVyc2VgIGlzIGB0cnVlYC5cbiAgICAgICAgICAgIHZhciBuID0gKHJldmVyc2UpID8gbGVuZ3RoIC0gaSA6IGk7XG5cbiAgICAgICAgICAgIC8vICBGaWxsIHRoZSBsZWZ0IGFuZCByaWdodCBjaGFubmVscyB3aXRoIHJhbmRvbSB3aGl0ZSBub2lzZSB3aGljaCBkZWNheXMgZXhwb25lbnRpYWxseS5cbiAgICAgICAgICAgIGxlZnRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XG4gICAgICAgICAgICByaWdodFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBSZXR1cm4gdGhlIGBpbXB1bHNlYC5cbiAgICAgICAgcmV0dXJuIGltcHVsc2U7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZYO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvZHluYW1pYy9GWC5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCIvLyAgUGhhc2VyLlNvdW5kLkR5bmFtaWNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBGWDogcmVxdWlyZSgnLi9GWCcpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zb3VuZC9keW5hbWljL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc291bmQvZHluYW1pYy9pbmRleC5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vU2V0dGluZ3MnKTtcbnZhciBTeXN0ZW1zID0gcmVxdWlyZSgnLi9TeXN0ZW1zJyk7XG5cbi8qKlxuKiBBIEJhc2UgU3RhdGUgQ2xhc3MuXG4qXG4qIEBjbGFzcyBQaGFzZXIuU3RhdGVcbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIFN0YXRlID0gZnVuY3Rpb24gKGNvbmZpZylcbntcbiAgICAvLyAgVGhlIHByb3BlcnRpZXMgYSBTdGF0ZSAqbXVzdCogaGF2ZSwgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCB3aXRob3V0IGJyZWFraW5nIGl0OlxuXG4gICAgdGhpcy5nYW1lID0gbnVsbDtcblxuICAgIC8vICBNYXliZSBqdXN0IGFuIG9iamVjdD8gRG9lc24ndCBoYXZlIHRvIGluc3RhbnRpYXRlIEkgZG9uJ3QgdGhpbmsgLi4uXG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyh0aGlzLCBjb25maWcpO1xuXG4gICAgdGhpcy5zeXMgPSBuZXcgU3lzdGVtcyh0aGlzLCBjb25maWcpO1xuXG4gICAgLy8gIFJlZmVyZW5jZSB0byBzeXMuY2hpbGRyZW4sIHNldCBkdXJpbmcgc3lzLmluaXQgb25seVxuICAgIHRoaXMuY2hpbGRyZW47XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZTtcblxuU3RhdGUucHJvdG90eXBlID0ge1xuXG4gICAgLy8gIENhbiBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgfSxcblxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgIH0sXG5cbiAgICAvLyAgQ2FuIGJlIG92ZXJyaWRkZW4gYnkgeW91ciBvd24gU3RhdGVzXG4gICAgcG9zdFVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgfSxcblxuICAgIC8vICBDYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvU3RhdGUuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XG52YXIgU3RhdGUgPSByZXF1aXJlKCcuL1N0YXRlJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL1NldHRpbmdzJyk7XG52YXIgU3lzdGVtcyA9IHJlcXVpcmUoJy4vU3lzdGVtcycpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvR2V0T2JqZWN0VmFsdWUnKTtcbi8vIHZhciBMb2FkZXJFdmVudCA9IHJlcXVpcmUoJy4uL2xvYWRlci9ldmVudHMvJyk7XG5cbi8qKlxuKiBUaGUgU3RhdGUgTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZywgc2V0dGluZyB1cCBhbmQgc3dpdGNoaW5nIGdhbWUgc3RhdGVzLlxuKlxuKiBAY2xhc3MgUGhhc2VyLlN0YXRlTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxuKi9cbnZhciBTdGF0ZU1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSwgc3RhdGVDb25maWcpXG57XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcblxuICAgIC8vICBFdmVyeXRoaW5nIGtlcHQgaW4gaGVyZVxuICAgIHRoaXMua2V5cyA9IHt9O1xuICAgIHRoaXMuc3RhdGVzID0gW107XG5cbiAgICAvLyAgT25seSBhY3RpdmUgc3RhdGVzIGFyZSBrZXB0IGluIGhlcmVcbiAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuXG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xuXG4gICAgaWYgKHN0YXRlQ29uZmlnKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGVDb25maWcpKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlQ29uZmlnLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBUaGUgaSA9PT0gMCBwYXJ0IGp1c3Qgc3RhcnRzIHRoZSBmaXJzdCBTdGF0ZSBnaXZlblxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnW2ldLFxuICAgICAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IChpID09PSAwKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVDb25maWcsXG4gICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN0YXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZU1hbmFnZXI7XG5cblN0YXRlTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAqIFRoZSBCb290IGhhbmRsZXIgaXMgY2FsbGVkIGJ5IFBoYXNlci5HYW1lIHdoZW4gaXQgZmlyc3Qgc3RhcnRzIHVwLlxuICAgICogVGhlIHJlbmRlcmVyIGlzIGF2YWlsYWJsZSBieSBub3cuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuU3RhdGVNYW5hZ2VyI2Jvb3RcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBib290OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5nYW1lLm9uUGF1c2UuYWRkKHRoaXMucGF1c2UsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLmdhbWUub25SZXN1bWUuYWRkKHRoaXMucmVzdW1lLCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX3BlbmRpbmdbaV07XG5cbiAgICAgICAgICAgIHRoaXMuYWRkKGVudHJ5LmtleSwgZW50cnkuc3RhdGUsIGVudHJ5LmF1dG9TdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQ2xlYXIgdGhlIHBlbmRpbmcgbGlzdFxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gW107XG4gICAgfSxcblxuICAgIGdldEtleTogZnVuY3Rpb24gKGtleSwgc3RhdGVDb25maWcpXG4gICAge1xuICAgICAgICBpZiAoIWtleSkgeyBrZXkgPSAnZGVmYXVsdCc7IH1cblxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAga2V5ID0gc3RhdGVDb25maWcuc2V0dGluZ3Mua2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ29iamVjdCcgJiYgc3RhdGVDb25maWcuaGFzT3duUHJvcGVydHkoJ2tleScpKVxuICAgICAgICB7XG4gICAgICAgICAgICBrZXkgPSBzdGF0ZUNvbmZpZy5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQnkgdGhpcyBwb2ludCBpdCdzIGVpdGhlciAnZGVmYXVsdCcgb3IgZXh0cmFjdGVkIGZyb20gdGhlIFN0YXRlXG5cbiAgICAgICAgaWYgKHRoaXMua2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYSBTdGF0ZSB3aXRoIGR1cGxpY2F0ZSBrZXk6ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEFkZHMgYSBuZXcgU3RhdGUgaW50byB0aGUgU3RhdGVNYW5hZ2VyLiBZb3UgbXVzdCBnaXZlIGVhY2ggU3RhdGUgYSB1bmlxdWUga2V5IGJ5IHdoaWNoIHlvdSdsbCBpZGVudGlmeSBpdC5cbiAgICAqIFRoZSBTdGF0ZSBjYW4gYmUgZWl0aGVyIGEgUGhhc2VyLlN0YXRlIG9iamVjdCAob3IgYW4gb2JqZWN0IHRoYXQgZXh0ZW5kcyBpdCksIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3Qgb3IgYSBmdW5jdGlvbi5cbiAgICAqIElmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBuZXcgc3RhdGUgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZCBieSBjYWxsaW5nIGl0LlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlN0YXRlTWFuYWdlciNhZGRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIHVuaXF1ZSBrZXkgeW91IHVzZSB0byByZWZlcmVuY2UgdGhpcyBzdGF0ZSwgaS5lLiBcIk1haW5NZW51XCIsIFwiTGV2ZWwxXCIuXG4gICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZXxvYmplY3R8ZnVuY3Rpb259IHN0YXRlICAtIFRoZSBzdGF0ZSB5b3Ugd2FudCB0byBzd2l0Y2ggdG8uXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvU3RhcnQ9ZmFsc2VdICAtIElmIHRydWUgdGhlIFN0YXRlIHdpbGwgYmUgc3RhcnRlZCBpbW1lZGlhdGVseSBhZnRlciBhZGRpbmcgaXQuXG4gICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnLCBhdXRvU3RhcnQpXG4gICAge1xuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB1bmRlZmluZWQpIHsgYXV0b1N0YXJ0ID0gZmFsc2U7IH1cblxuICAgICAgICAvLyAgaWYgbm90IGJvb3RlZCwgdGhlbiBwdXQgc3RhdGUgaW50byBhIGhvbGRpbmcgcGF0dGVyblxuICAgICAgICBpZiAoIXRoaXMuZ2FtZS5pc0Jvb3RlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5fcGVuZGluZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlQ29uZmlnLFxuICAgICAgICAgICAgICAgIGF1dG9TdGFydDogYXV0b1N0YXJ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlTWFuYWdlciBub3QgeWV0IGJvb3RlZCwgYWRkaW5nIHRvIGxpc3QnLCB0aGlzLl9wZW5kaW5nLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSwgc3RhdGVDb25maWcpO1xuXG4gICAgICAgIHZhciBuZXdTdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlTWFuYWdlci5hZGQgZnJvbSBpbnN0YW5jZScsIGtleSk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuY3JlYXRlU3RhdGVGcm9tSW5zdGFuY2Uoa2V5LCBzdGF0ZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXRlQ29uZmlnID09PSAnb2JqZWN0JylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1N0YXRlTWFuYWdlci5hZGQgZnJvbSBvYmplY3QnLCBrZXkpO1xuXG4gICAgICAgICAgICBzdGF0ZUNvbmZpZy5rZXkgPSBrZXk7XG5cbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZUZyb21PYmplY3Qoa2V5LCBzdGF0ZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXRlQ29uZmlnID09PSAnZnVuY3Rpb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVNYW5hZ2VyLmFkZCBmcm9tIGZ1bmN0aW9uJywga2V5KTtcblxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUZ1bmN0aW9uKGtleSwgc3RhdGVDb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5rZXlzW2tleV0gPSBuZXdTdGF0ZTtcblxuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKG5ld1N0YXRlKTtcblxuICAgICAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1N0YXRlLnNldHRpbmdzLmFjdGl2ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZS5pc0Jvb3RlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGtleSwgbmV3U3RhdGUpXG4gICAge1xuICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xuXG4gICAgICAgIG5ld1N0YXRlLnNldHRpbmdzLmtleSA9IGtleTtcblxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmdhbWUuY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULldFQkdMKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRnJhbWVCdWZmZXIobmV3U3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnKVxuICAgIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IFN0YXRlKHN0YXRlQ29uZmlnKTtcblxuICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xuXG4gICAgICAgIG5ld1N0YXRlLnN5cy5pbml0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVGcmFtZUJ1ZmZlcihuZXdTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cENhbGxiYWNrcyhuZXdTdGF0ZSwgc3RhdGVDb25maWcpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24gKGtleSwgc3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgc3RhdGUoKTtcblxuICAgICAgICBpZiAobmV3U3RhdGUgaW5zdGFuY2VvZiBTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RhdGVGcm9tSW5zdGFuY2Uoa2V5LCBuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5nYW1lID0gdGhpcy5nYW1lO1xuXG4gICAgICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhuZXdTdGF0ZSwga2V5KTtcbiAgICAgICAgICAgIG5ld1N0YXRlLnN5cyA9IG5ldyBTeXN0ZW1zKG5ld1N0YXRlKTtcblxuICAgICAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGF0ZUZyYW1lQnVmZmVyKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIERlZmF1bHQgcmVxdWlyZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR1cENhbGxiYWNrcyhuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0dXBDYWxsYmFja3M6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgc3RhdGVDb25maWcpXG4gICAge1xuICAgICAgICBpZiAoc3RhdGVDb25maWcgPT09IHVuZGVmaW5lZCkgeyBzdGF0ZUNvbmZpZyA9IG5ld1N0YXRlOyB9XG5cbiAgICAgICAgLy8gIEV4dHJhY3QgY2FsbGJhY2tzIG9yIHNldCBOT09QXG5cbiAgICAgICAgbmV3U3RhdGUuaW5pdCA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnaW5pdCcsIE5PT1ApO1xuICAgICAgICBuZXdTdGF0ZS5wcmVsb2FkID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdwcmVsb2FkJywgTk9PUCk7XG4gICAgICAgIG5ld1N0YXRlLmNyZWF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnY3JlYXRlJywgTk9PUCk7XG4gICAgICAgIG5ld1N0YXRlLnNodXRkb3duID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdzaHV0ZG93bicsIE5PT1ApO1xuXG4gICAgICAgIG5ld1N0YXRlLnByZVVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncHJlVXBkYXRlJywgTk9PUCk7XG4gICAgICAgIG5ld1N0YXRlLnVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAndXBkYXRlJywgTk9PUCk7XG4gICAgICAgIG5ld1N0YXRlLnBvc3RVcGRhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ3Bvc3RVcGRhdGUnLCBOT09QKTtcbiAgICAgICAgbmV3U3RhdGUucmVuZGVyID0gR2V0T2JqZWN0VmFsdWUoc3RhdGVDb25maWcsICdyZW5kZXInLCBOT09QKTtcblxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfSxcblxuICAgIGNyZWF0ZVN0YXRlRnJhbWVCdWZmZXI6IGZ1bmN0aW9uIChuZXdTdGF0ZSlcbiAgICB7XG4gICAgICAgIHZhciB4ID0gbmV3U3RhdGUuc2V0dGluZ3MueDtcbiAgICAgICAgdmFyIHkgPSBuZXdTdGF0ZS5zZXR0aW5ncy55O1xuXG4gICAgICAgIGlmIChuZXdTdGF0ZS5zZXR0aW5ncy53aWR0aCA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNldHRpbmdzLndpZHRoID0gdGhpcy5nYW1lLmNvbmZpZy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdTdGF0ZS5zZXR0aW5ncy5oZWlnaHQgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncy5oZWlnaHQgPSB0aGlzLmdhbWUuY29uZmlnLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aCA9IG5ld1N0YXRlLnNldHRpbmdzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbmV3U3RhdGUuc2V0dGluZ3MuaGVpZ2h0O1xuXG4gICAgICAgIG5ld1N0YXRlLnN5cy5mYm8gPSB0aGlzLmdhbWUucmVuZGVyZXIuY3JlYXRlRkJPKG5ld1N0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2tleV07XG4gICAgfSxcblxuICAgIGdldFN0YXRlSW5kZXg6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKTtcbiAgICB9LFxuXG4gICAgZ2V0QWN0aXZlU3RhdGVJbmRleDogZnVuY3Rpb24gKHN0YXRlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLnN0YXRlID09PSBzdGF0ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xuXG4gICAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuc2V0dGluZ3MuYWN0aXZlICYmIHRoaXMuYWN0aXZlLmluZGV4T2Yoc3RhdGUpICE9PSAtMSk7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgLy8gIGlmIG5vdCBib290ZWQsIHRoZW4gcHV0IHN0YXRlIGludG8gYSBob2xkaW5nIHBhdHRlcm5cbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZU1hbmFnZXIgbm90IHlldCBib290ZWQsIHNldHRpbmcgYXV0b1N0YXJ0IG9uIHBlbmRpbmcgbGlzdCcpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmF1dG9TdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XG5cbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgQWxyZWFkeSBzdGFydGVkPyBOb3RoaW5nIG1vcmUgdG8gZG8gaGVyZSAuLi5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKGtleSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zZXR0aW5ncy5hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyAgKyBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbml0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRlLmluaXQuY2FsbChzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5wcmVsb2FkICYmIHN0YXRlLnN5cy5sb2FkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5sb2FkLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmVsb2FkLmNhbGwoc3RhdGUsIHRoaXMuZ2FtZSk7XG5cbiAgICAgICAgICAgICAgICAvLyAgSXMgdGhlIGxvYWRlciBlbXB0eT9cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3lzLmxvYWQubGlzdC5zaXplID09PSAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBTdGFydCB0aGUgbG9hZGVyIGdvaW5nIGFzIHdlIGhhdmUgc29tZXRoaW5nIGluIHRoZSBxdWV1ZVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5sb2FkLmV2ZW50cy5vbmNlKCdMT0FERVJfQ09NUExFVEVfRVZFTlQnLCB0aGlzLmxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubG9hZC5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZENvbXBsZXRlOiBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5sb2FkZXIuc3RhdGU7XG5cbiAgICAgICAgLy8gIE1ha2Ugc3VyZSB0byBkbyBsb2FkLXVwZGF0ZSBvbmUgbGFzdCB0aW1lIGJlZm9yZSBzdGF0ZSBpcyBzZXQgdG8gX2NyZWF0ZWRcblxuICAgICAgICAvLyAgU3RvcCBkb2luZyB0aGlzIC4uLlxuICAgICAgICBpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoJ2xvYWRVcGRhdGUnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUubG9hZFVwZGF0ZS5jYWxsKHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnRDcmVhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBzdGFydENyZWF0ZTogZnVuY3Rpb24gKHN0YXRlKVxuICAgIHtcbiAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuY3JlYXRlLmNhbGwoc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIEluc2VydCBhdCB0aGUgY29ycmVjdCBpbmRleCwgb3IgaXQganVzdCBhbGwgZ29lcyB3cm9uZyA6KVxuXG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRTdGF0ZUluZGV4KHN0YXRlKTtcblxuICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKHsgaW5kZXg6IGksIHN0YXRlOiBzdGF0ZSB9KTtcblxuICAgICAgICAvLyAgU29ydCB0aGUgJ2FjdGl2ZScgYXJyYXkgYmFzZWQgb24gdGhlIGluZGV4IHByb3BlcnR5XG4gICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0U3RhdGVzLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHN0YXRlLnN5cy51cGRhdGVzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHN0YXRlLnN5cy5tYWlubG9vcC5zdGFydCgpO1xuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlU3RhdGVJbmRleChrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XG5cbiAgICAgICAgICAgIHN0YXRlLnNldHRpbmdzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydFN0YXRlcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzb3J0U3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVBLCBzdGF0ZUIpXG4gICAge1xuICAgICAgICAvLyAgU29ydCBkZXNjZW5kaW5nXG4gICAgICAgIGlmIChzdGF0ZUEuaW5kZXggPCBzdGF0ZUIuaW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZUEuaW5kZXggPiBzdGF0ZUIuaW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFNlZSBpZiB3ZSBjYW4gcmVkdWNlIHRoaXMgZG93biB0byBqdXN0IHVwZGF0ZSBhbmQgcmVuZGVyXG5cbiAgICBzdGVwOiBmdW5jdGlvbiAodGltZXN0YW1wKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zeXMubWFpbmxvb3AucnVubmluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubWFpbmxvb3Auc3RlcCh0aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qXG4gICAgcHJlVXBkYXRlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5hY3RpdmVbaV0uc3RhdGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3RbY10ucHJlVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLnByZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuYWN0aXZlW2ldLnN0YXRlO1xuXG4gICAgICAgICAgICAvLyAgSW52b2tlIFN0YXRlIE1haW4gTG9vcCBoZXJlIC0gdXBkYXRpbmcgYWxsIG9mIGl0cyBzeXN0ZW1zICh0d2VlbnMsIHBoeXNpY3MsIGV0YylcblxuICAgICAgICAgICAgLy8gIFRoaXMgc2hvdWxkbid0IGJlIGNhbGxlZCBpZiB0aGUgU3RhdGUgaXMgc3RpbGwgbG9hZGluZ1xuICAgICAgICAgICAgLy8gIEhhdmUgYSBTdGF0ZS5TVEFUVVMgY29uc3QgaW4gdGhlIFNldHRpbmdzLCBkaWN0YXRpbmcgd2hhdCBpcyBnb2luZyBvblxuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zdFVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuYWN0aXZlW2ldLnN0YXRlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0Lmxlbmd0aDsgYysrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdLnBvc3RVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUucG9zdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuYWN0aXZlW2ldLnN0YXRlO1xuXG4gICAgICAgICAgICAvLyAgQ2FuIHB1dCBhbGwga2luZHMgb2Ygb3RoZXIgY2hlY2tzIGluIGhlcmUsIGxpa2UgTWFpbkxvb3AsIEZQUywgZXRjLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5zZXR0aW5ncy52aXNpYmxlIHx8IHN0YXRlLnN5cy5jb2xvci5hbHBoYSA9PT0gMCB8fCBzdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ2FtZS5yZW5kZXJlci5yZW5kZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAqL1xuXG4gICAgcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlciwgc3RhdGUsIGludGVycG9sYXRpb25QZXJjZW50YWdlKVxuICAgIHtcbiAgICAgICAgLy8gIFBvcHVsYXRlcyB0aGUgZGlzcGxheSBsaXN0XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIocmVuZGVyZXIsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvU3RhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvU3RhdGVNYW5hZ2VyLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XG5cbi8qKlxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cbipcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiovXG5cbnZhciBHYW1lT2JqZWN0RmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRoYXQgb3ducyB0aGlzIEZhY3RvcnlcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICAgIHN0YXRlOiBudWxsXG5cbn07XG5cbmZ1bmN0aW9uIGluaXQgKHN0YXRlKVxue1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBHYW1lT2JqZWN0RmFjdG9yeSBpbnN0YW5jZSBmb3IgU3RhdGUnKTtcblxuICAgIEdhbWVPYmplY3RGYWN0b3J5LnN0YXRlID0gc3RhdGU7XG5cbiAgICAvLyAgIExvYWQgdGhlIGZhY3RvcmllcyBpbnRvIHRoaXMgT2JqZWN0XG5cbiAgICByZXR1cm4gRmFjdG9yeUNvbnRhaW5lci5sb2FkKEdhbWVPYmplY3RGYWN0b3J5LCB0cnVlKTtcblxuICAgIC8vIHJldHVybiBHYW1lT2JqZWN0RmFjdG9yeTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnkuanMiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvY29uc3QnKTtcbnZhciBCYXNlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL0Jhc2VMb2FkZXInKTtcbnZhciBOdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5L051bWJlckFycmF5Jyk7XG5cbnZhciBJbWFnZUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpO1xudmFyIEpTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZScpO1xudmFyIFhNTEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1hNTEZpbGUnKTtcbnZhciBCaW5hcnlGaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlJyk7XG52YXIgR0xTTEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlJyk7XG52YXIgVGV4dEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlJyk7XG52YXIgQXRsYXNKU09ORmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZScpO1xuXG52YXIgTG9hZGVyID0gZnVuY3Rpb24gKHN0YXRlKVxue1xuICAgIEJhc2VMb2FkZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRoYXQgb3ducyB0aGlzIEZhY3RvcnlcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIHRoaXMuX211bHRpbGlzdCA9IHt9O1xufTtcblxuTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUxvYWRlci5wcm90b3R5cGUpO1xuTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvYWRlcjtcblxuTG9hZGVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxue1xuICAgIHZhciBmaWxlID0gbmV3IEpTT05GaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLnhtbCA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgWE1MRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xufTtcblxuTG9hZGVyLnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHhoclNldHRpbmdzKVxue1xuICAgIHZhciBmaWxlID0gbmV3IEJpbmFyeUZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgVGV4dEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUuZ2xzbCA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgR0xTTEZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUuYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKVxue1xuICAgIC8vICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiAndGV4dHVyZScgYW5kICdkYXRhJ1xuICAgIHZhciBmaWxlcyA9IG5ldyBBdGxhc0pTT05GaWxlKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzLCBhdGxhc1hoclNldHRpbmdzKTtcblxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy50ZXh0dXJlKTtcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMuZGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkxvYWRlci5wcm90b3R5cGUubXVsdGlhdGxhcyA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkxzLCBhdGxhc1VSTHMsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcbntcbiAgICBpZiAodHlwZW9mIHRleHR1cmVVUkxzID09PSAnbnVtYmVyJylcbiAgICB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRleHR1cmVVUkxzO1xuXG4gICAgICAgIHRleHR1cmVVUkxzID0gTnVtYmVyQXJyYXkoMCwgdG90YWwsIGtleSArICctJywgJy5wbmcnKTtcbiAgICAgICAgYXRsYXNVUkxzID0gTnVtYmVyQXJyYXkoMCwgdG90YWwsIGtleSArICctJywgJy5qc29uJyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0dXJlVVJMcykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHR1cmVVUkxzID0gWyB0ZXh0dXJlVVJMcyBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF0bGFzVVJMcykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF0bGFzVVJMcyA9IFsgYXRsYXNVUkxzIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmlsZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG11bHRpS2V5O1xuXG4gICAgdGhpcy5fbXVsdGlsaXN0W2tleV0gPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0dXJlVVJMcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIG11bHRpS2V5ID0gJ19NQV9JTUdfJyArIGtleSArICdfJyArIGkudG9TdHJpbmcoKTtcblxuICAgICAgICBmaWxlID0gbmV3IEltYWdlRmlsZShtdWx0aUtleSwgdGV4dHVyZVVSTHNbaV0sIHRoaXMucGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XG5cbiAgICAgICAgdGhpcy5fbXVsdGlsaXN0W2tleV0ucHVzaChtdWx0aUtleSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF0bGFzVVJMcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIG11bHRpS2V5ID0gJ19NQV9KU09OXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgZmlsZSA9IG5ldyBKU09ORmlsZShtdWx0aUtleSwgYXRsYXNVUkxzW2ldLCB0aGlzLnBhdGgsIGF0bGFzWGhyU2V0dGluZ3MpO1xuXG4gICAgICAgIHRoaXMuYWRkRmlsZShmaWxlKTtcblxuICAgICAgICB0aGlzLl9tdWx0aWxpc3Rba2V5XS5wdXNoKG11bHRpS2V5KTtcbiAgICB9XG59O1xuXG4vLyAgVGhlIExvYWRlciBoYXMgZmluaXNoZWRcbkxvYWRlci5wcm90b3R5cGUucHJvY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5zdG9yYWdlLnNpemUgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gIFRoZSBnbG9iYWwgVGV4dHVyZSBNYW5hZ2VyXG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5zdGF0ZS5zeXMudGV4dHVyZXM7XG5cbiAgICAvLyAgUHJvY2VzcyBtdWx0aWF0bGFzIGdyb3VwcyBmaXJzdFxuXG4gICAgdmFyIGZpbGU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fbXVsdGlsaXN0KVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMuX211bHRpbGlzdFtrZXldO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuc3RvcmFnZS5nZXQoJ2tleScsIGtleXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS50eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIERvIHdlIGhhdmUgZXZlcnl0aGluZyBuZWVkZWQ/XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoICsgZGF0YS5sZW5ndGggPT09IGtleXMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgWXVwLCBhZGQgdGhlbSB0byB0aGUgVGV4dHVyZSBNYW5hZ2VyXG5cbiAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0uZnJhbWVzKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXNKU09OSGFzaChrZXksIGltYWdlcywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbiAoZmlsZSlcbiAgICB7XG4gICAgICAgIGlmIChmaWxlLnR5cGUgPT09ICdpbWFnZScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbGUudHlwZSA9PT0gJ2F0bGFzanNvbicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaWxlQSA9IGZpbGUuZmlsZUE7XG4gICAgICAgICAgICB2YXIgZmlsZUIgPSBmaWxlLmZpbGVCO1xuXG4gICAgICAgICAgICBpZiAoZmlsZUEudHlwZSA9PT0gJ2ltYWdlJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhcyhmaWxlQS5rZXksIGZpbGVBLmRhdGEsIGZpbGVCLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEF0bGFzKGZpbGVCLmtleSwgZmlsZUIuZGF0YSwgZmlsZUEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsZS50eXBlID09PSAnanNvbicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGlyKGZpbGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3N0YXRlL3N5c3RlbXMvTG9hZGVyLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLy8gTXkgdGhhbmtzIHRvIElzYWFjIFN1a2luIGZvciBjcmVhdGluZyBNYWluTG9vcC5qcywgb24gd2hpY2ggbG90cyBvZiB0aGlzIGlzIGJhc2VkLlxuXG52YXIgTWFpbkxvb3AgPSBmdW5jdGlvbiAoc3RhdGUsIGZyYW1lcmF0ZSlcbntcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZVxuICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIEdhbWUuXG4gICAgKi9cbiAgICB0aGlzLmdhbWUgPSBzdGF0ZS5nYW1lO1xuXG4gICAgLy8gVGhlIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRvIHNpbXVsYXRlIGVhY2ggdGltZSB1cGRhdGUoKSBydW5zLlxuICAgIHRoaXMudGltZXN0ZXAgPSAxMDAwIC8gZnJhbWVyYXRlO1xuXG4gICAgdGhpcy5waHlzaWNzU3RlcCA9IDEgLyBmcmFtZXJhdGU7XG5cbiAgICAvLyBUaGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgaW4tYXBwIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LlxuICAgIC8vIFNlZSB0aGUgY29tbWVudHMgaW5zaWRlIGFuaW1hdGUoKSBmb3IgZGV0YWlscy5cbiAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xuXG4gICAgLy8gVGhlIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgb2YgdGhlIGxhc3QgdGltZSB0aGUgbWFpbiBsb29wIHdhcyBydW4uXG4gICAgLy8gVXNlZCB0byBjb21wdXRlIHRoZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBmcmFtZXMuXG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSAwO1xuXG4gICAgLy8gQW4gZXhwb25lbnRpYWwgbW92aW5nIGF2ZXJhZ2Ugb2YgdGhlIGZyYW1lcyBwZXIgc2Vjb25kLlxuICAgIHRoaXMuZnBzID0gNjA7XG5cbiAgICAvLyBUaGUgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMpIG9mIHRoZSBsYXN0IHRpbWUgdGhlIGBmcHNgIG1vdmluZ1xuICAgIC8vIGF2ZXJhZ2Ugd2FzIHVwZGF0ZWQuXG4gICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gMDtcblxuICAgIC8vIFRoZSBudW1iZXIgb2YgZnJhbWVzIGRlbGl2ZXJlZCBpbiB0aGUgY3VycmVudCBzZWNvbmQuXG4gICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcblxuICAgIC8vIFRoZSBudW1iZXIgb2YgdGltZXMgdXBkYXRlKCkgaXMgY2FsbGVkIGluIGEgZ2l2ZW4gZnJhbWUuIFRoaXMgaXMgb25seVxuICAgIC8vIHJlbGV2YW50IGluc2lkZSBvZiBhbmltYXRlKCksIGJ1dCBhIHJlZmVyZW5jZSBpcyBoZWxkIGV4dGVybmFsbHkgc28gdGhhdFxuICAgIC8vIHRoaXMgdmFyaWFibGUgaXMgbm90IG1hcmtlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIGV2ZXJ5IHRpbWUgdGhlIG1haW5cbiAgICAvLyBsb29wIHJ1bnMuXG4gICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XG5cbiAgICAvLyBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBtdXN0IHBhc3Mgc2luY2UgdGhlIGxhc3RcbiAgICAvLyBmcmFtZSB3YXMgZXhlY3V0ZWQgYmVmb3JlIGFub3RoZXIgZnJhbWUgY2FuIGJlIGV4ZWN1dGVkLiBUaGVcbiAgICAvLyBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIGNhcHMgdGhlIEZQUyAodGhlIGRlZmF1bHQgb2YgemVybyBtZWFucyB0aGVyZSBpc1xuICAgIC8vIG5vIGNhcCkuXG4gICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMDtcblxuICAgIC8vIFdoZXRoZXIgdGhlIG1haW4gbG9vcCBpcyBydW5uaW5nLlxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgLy8gYHRydWVgIGlmIGBNYWluTG9vcC5zdGFydCgpYCBoYXMgYmVlbiBjYWxsZWQgYW5kIHRoZSBtb3N0IHJlY2VudCB0aW1lIGl0XG4gICAgLy8gd2FzIGNhbGxlZCBoYXMgbm90IGJlZW4gZm9sbG93ZWQgYnkgYSBjYWxsIHRvIGBNYWluTG9vcC5zdG9wKClgLiBUaGlzIGlzXG4gICAgLy8gZGlmZmVyZW50IHRoYW4gYHJ1bm5pbmdgIGJlY2F1c2UgdGhlcmUgaXMgYSBkZWxheSBvZiBhIGZldyBtaWxsaXNlY29uZHNcbiAgICAvLyBhZnRlciBgTWFpbkxvb3Auc3RhcnQoKWAgaXMgY2FsbGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gaXMgY29uc2lkZXJlZFxuICAgIC8vIFwicnVubmluZy5cIiBUaGlzIGRlbGF5IGlzIGR1ZSB0byB3YWl0aW5nIGZvciB0aGUgbmV4dCBmcmFtZS5cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFdoZXRoZXIgdGhlIHNpbXVsYXRpb24gaGFzIGZhbGxlbiB0b28gZmFyIGJlaGluZCByZWFsIHRpbWUuXG4gICAgLy8gU3BlY2lmaWNhbGx5LCBgcGFuaWNgIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCBpZiB0b28gbWFueSB1cGRhdGVzIG9jY3VyIGluXG4gICAgLy8gb25lIGZyYW1lLiBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgaW5zaWRlIG9mIGFuaW1hdGUoKSwgYnV0IGEgcmVmZXJlbmNlIGlzXG4gICAgLy8gaGVsZCBleHRlcm5hbGx5IHNvIHRoYXQgdGhpcyB2YXJpYWJsZSBpcyBub3QgbWFya2VkIGZvciBnYXJiYWdlXG4gICAgLy8gY29sbGVjdGlvbiBldmVyeSB0aW1lIHRoZSBtYWluIGxvb3AgcnVucy5cbiAgICB0aGlzLnBhbmljID0gZmFsc2U7XG59O1xuXG5NYWluTG9vcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYWluTG9vcDtcblxuTWFpbkxvb3AucHJvdG90eXBlID0ge1xuXG4gICAgc2V0TWF4RlBTOiBmdW5jdGlvbiAoZnBzKVxuICAgIHtcbiAgICAgICAgaWYgKGZwcyA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwIC8gZnBzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1heEZQUzogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5taW5GcmFtZURlbGF5O1xuICAgIH0sXG5cbiAgICByZXNldEZyYW1lRGVsdGE6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgb2xkRnJhbWVEZWx0YSA9IHRoaXMuZnJhbWVEZWx0YTtcblxuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xuXG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xuICAgIH0sXG5cbiAgICBzdGFydDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWVNcyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xuICAgIH0sXG5cbiAgICAvLyAgdGltZXN0YW1wID0gRE9NSGlnaFJlc1RpbWVTdGFtcFxuICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lc3RhbXApXG4gICAge1xuICAgICAgICAvLyBUaHJvdHRsZSB0aGUgZnJhbWUgcmF0ZSAoaWYgbWluRnJhbWVEZWxheSBpcyBzZXQgdG8gYSBub24temVybyB2YWx1ZSBieVxuICAgICAgICAvLyBgTWFpbkxvb3Auc2V0TWF4QWxsb3dlZEZQUygpYCkuXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWVNcyArIHRoaXMubWluRnJhbWVEZWxheSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnJhbWVEZWx0YSBpcyB0aGUgY3VtdWxhdGl2ZSBhbW91bnQgb2YgaW4tYXBwIHRpbWUgdGhhdCBoYXNuJ3QgYmVlblxuICAgICAgICAvLyBzaW11bGF0ZWQgeWV0LiBBZGQgdGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUuIFdlIG5lZWQgdG8gdHJhY2sgdG90YWxcbiAgICAgICAgLy8gbm90LXlldC1zaW11bGF0ZWQgdGltZSAoYXMgb3Bwb3NlZCB0byBqdXN0IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlXG4gICAgICAgIC8vIGxhc3QgZnJhbWUpIGJlY2F1c2Ugbm90IGFsbCBhY3R1YWxseSBlbGFwc2VkIHRpbWUgaXMgZ3VhcmFudGVlZCB0byBiZVxuICAgICAgICAvLyBzaW11bGF0ZWQgZWFjaCBmcmFtZS4gU2VlIHRoZSBjb21tZW50cyBiZWxvdyBmb3IgZGV0YWlscy5cbiAgICAgICAgdGhpcy5mcmFtZURlbHRhICs9IHRpbWVzdGFtcCAtIHRoaXMubGFzdEZyYW1lVGltZU1zO1xuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWVNcyA9IHRpbWVzdGFtcDtcblxuICAgICAgICAvLyBSdW4gYW55IHVwZGF0ZXMgdGhhdCBhcmUgbm90IGRlcGVuZGVudCBvbiB0aW1lIGluIHRoZSBzaW11bGF0aW9uLlxuXG4gICAgICAgIC8vICBIZXJlIHdlJ2xsIG5lZWQgdG8gcnVuIHRoaW5ncyBsaWtlIHR3ZWVuLnVwZGF0ZSwgaW5wdXQudXBkYXRlLCBldGMuXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLmJlZ2luKHRpbWVzdGFtcCwgdGhpcy5mcmFtZURlbHRhKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZSByYXRlLCBgZnBzYC4gRXZlcnkgc2Vjb25kLCB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGZyYW1lcyB0aGF0IG9jY3VycmVkIGluIHRoYXQgc2Vjb25kIGFyZSBpbmNsdWRlZCBpbiBhbiBleHBvbmVudGlhbFxuICAgICAgICAvLyBtb3ZpbmcgYXZlcmFnZSBvZiBhbGwgZnJhbWVzIHBlciBzZWNvbmQsIHdpdGggYW4gYWxwaGEgb2YgMC4yNS4gVGhpc1xuICAgICAgICAvLyBtZWFucyB0aGF0IG1vcmUgcmVjZW50IHNlY29uZHMgYWZmZWN0IHRoZSBlc3RpbWF0ZWQgZnJhbWUgcmF0ZSBtb3JlIHRoYW5cbiAgICAgICAgLy8gb2xkZXIgc2Vjb25kcy5cbiAgICAgICAgaWYgKHRpbWVzdGFtcCA+IHRoaXMubGFzdEZwc1VwZGF0ZSArIDEwMDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyBleHBvbmVudGlhbCBtb3ZpbmcgYXZlcmFnZSB3aXRoIGFuIGFscGhhIG9mIDAuMjUuXG4gICAgICAgICAgICAvLyBVc2luZyBjb25zdGFudHMgaW5saW5lIGlzIG9rYXkgaGVyZS5cbiAgICAgICAgICAgIHRoaXMuZnBzID0gMC4yNSAqIHRoaXMuZnJhbWVzVGhpc1NlY29uZCArIDAuNzUgKiB0aGlzLmZwcztcblxuICAgICAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCsrO1xuXG4gICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xuXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy50aW1lc3RlcDtcblxuICAgICAgICB3aGlsZSAodGhpcy5mcmFtZURlbHRhID49IHN0ZXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMudXBkYXRlKHRoaXMudGltZXN0ZXApO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGUoc3RlcCwgdGhpcy5waHlzaWNzU3RlcCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLnN5cy5jaGlsZHJlbi5saXN0W2NdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZShzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICBEZXYgbGV2ZWwgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKHN0ZXApO1xuXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy50aW1lc3RlcDtcblxuICAgICAgICAgICAgaWYgKCsrdGhpcy5udW1VcGRhdGVTdGVwcyA+PSAyNDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlLnN5cy5wcmVSZW5kZXIoKTtcblxuICAgICAgICB0aGlzLnN0YXRlLnN5cy51cGRhdGVzLnN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2V0dGluZ3MudmlzaWJsZSAmJiB0aGlzLnN0YXRlLnN5cy5jb2xvci5hbHBoYSAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nYW1lLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YXRlLCB0aGlzLmZyYW1lRGVsdGEgLyB0aGlzLnRpbWVzdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLnVwZGF0ZXMuc3RvcCgpO1xuXG4gICAgICAgIC8vIFJ1biBhbnkgdXBkYXRlcyB0aGF0IGFyZSBub3QgZGVwZW5kZW50IG9uIHRpbWUgaW4gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgIHRoaXMuc3RhdGUuc3lzLmVuZCh0aGlzLmZwcywgdGhpcy5wYW5pYyk7XG5cbiAgICAgICAgdGhpcy5wYW5pYyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKlxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlKHRpbWVzdGVwKTtcblxuICAgICAgICB2YXIgYztcbiAgICAgICAgdmFyIGNoaWxkO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGMrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5zeXMuY2hpbGRyZW4ubGlzdFtjXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXN0cylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGUodGltZXN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIERldiBsZXZlbCBjYWxsYmFja1xuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZSh0aW1lc3RlcCk7XG5cbiAgICAgICAgZm9yIChjID0gMDsgYyA8IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBjKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuc3RhdGUuc3lzLmNoaWxkcmVuLmxpc3RbY107XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5leGlzdHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlKHRpbWVzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgKi9cblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Mb29wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9NYWluTG9vcC5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBEaXJ0eSEgTWFuYWdlclxuKlxuKiBAY2xhc3NcbiovXG52YXIgVXBkYXRlTWFuYWdlciA9IGZ1bmN0aW9uIChzdGF0ZSlcbntcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICB0aGlzLmdhbWUgPSBzdGF0ZS5nYW1lO1xuXG4gICAgdGhpcy5saXN0ID0gW107XG5cbiAgICAvLyB0aGlzLmkgPSAxO1xuXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgXG4gICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xufTtcblxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcGRhdGVNYW5hZ2VyO1xuXG5VcGRhdGVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdG9wJywgdGhpcy5wcm9jZXNzZWQpO1xuXG4gICAgICAgIHRoaXMubGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIHRoaXMuaSsrO1xuICAgIH0sXG5cbiAgICBzdGFydDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gdGhpcy5saXN0Lmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmksICdVcGRhdGVNYW5hZ2VyLnN0YXJ0JywgbGVuKTtcblxuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEJlY2F1c2UgaXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCAoYXMgYSBjaGlsZCBvZiBhbm90aGVyIFRyYW5zZm9ybSB0aGF0IHdhcyB1cGRhdGVkKVxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtpXSAmJiB0aGlzLmxpc3RbaV0uX2RpcnR5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0W2ldLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24gKHRyYW5zZm9ybSlcbiAgICB7XG4gICAgICAgIHRoaXMubGlzdC5wdXNoKHRyYW5zZm9ybSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVwZGF0ZU1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL1VwZGF0ZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBBIFNldCBpcyBhIGNvbGxlY3Rpb24gb2YgdW5pcXVlIGVsZW1lbnRzLlxuXG52YXIgU2V0ID0gZnVuY3Rpb24gKGVsZW1lbnRzKVxue1xuICAgIHRoaXMuZW50cmllcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldDtcblxuU2V0LnByb3RvdHlwZSA9IHtcblxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZW50cnlbcHJvcGVydHldID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGR1bXA6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjb25zb2xlLmdyb3VwKCdTZXQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZW50cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0sXG5cblxuICAgIC8vICBGb3Igd2hlbiB5b3Uga25vdyB0aGlzIFNldCB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmVudHJpZXMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh0ZW1wW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIEZvciB3aGVuIHlvdSBhYnNvbHV0ZWx5IGtub3cgdGhpcyBTZXQgd29uJ3QgYmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBpdGVyYXRpb25cbiAgICBpdGVyYXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHRoaXMuZW50cmllc1tpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuZW50cmllcy5pbmRleE9mKHZhbHVlKSA+IC0xKTtcbiAgICB9LFxuXG4gICAgdW5pb246IGZ1bmN0aW9uIChzZXQpXG4gICAge1xuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHNldC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChzZXQpXG4gICAge1xuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyh2YWx1ZSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgfSxcblxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChzZXQpXG4gICAge1xuICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZXQuY29udGFpbnModmFsdWUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2V0LnByb3RvdHlwZSwge1xuXG4gICAgc2l6ZToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdHJ1Y3RzL1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBFeHRlbmQgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XG5cbi8qKlxuKiBBIEZyYW1lIGlzIGEgc2VjdGlvbiBvZiBhIFRleHR1cmUuXG4qXG4qIEBjbGFzcyBQaGFzZXIuRnJhbWVcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0aGlzIEZyYW1lIGJlbG9uZ3MgdG8uXG4qIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHVuaXF1ZSAod2l0aGluIHRoZSBUZXh0dXJlKSBuYW1lIG9mIHRoaXMgRnJhbWUuXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxuKiBAcGFyYW0ge251bWJlcn0geSAtIFkgcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cbiogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZS5cbiogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxuKi9cbnZhciBGcmFtZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0aGlzIGZyYW1lIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxuICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIHRoaXMuc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IHNvdXJjZUluZGV4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WCAtIFggcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXG4gICAgKi9cbiAgICB0aGlzLmN1dFggPSB4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0WSAtIFkgcG9zaXRpb24gd2l0aGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0IGZyb20uXG4gICAgKi9cbiAgICB0aGlzLmN1dFkgPSB5O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gY3V0V2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGFyZWEgaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQuXG4gICAgKi9cbiAgICB0aGlzLmN1dFdpZHRoID0gd2lkdGg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBhcmVhIGluIHRoZSBzb3VyY2UgaW1hZ2UgdG8gY3V0LlxuICAgICovXG4gICAgdGhpcy5jdXRIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIFggcmVuZGVyaW5nIG9mZnNldCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICB0aGlzLnggPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSBZIHJlbmRlcmluZyBvZmZzZXQgb2YgdGhpcyBGcmFtZSwgdGFraW5nIHRyaW0gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgdGhpcy55ID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlbmRlcmluZyB3aWR0aCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVuZGVyaW5nIGhlaWdodCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIC8qKlxuICAgICogSXMgdGhpcyBmcmFtZSBpcyByb3RhdGVkIG9yIG5vdCBpbiB0aGUgVGV4dHVyZT9cbiAgICAqIFJvdGF0aW9uIGFsbG93cyB5b3UgdG8gdXNlIHJvdGF0ZWQgZnJhbWVzIGluIHRleHR1cmUgYXRsYXMgcGFja2luZy5cbiAgICAqIEl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggU3ByaXRlIHJvdGF0aW9uLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm90YXRlZFxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMucm90YXRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBJcyB0aGlzIGEgdGlsaW5nIHRleHR1cmU/IEFzIHVzZWQgYnkgdGhlIGxpa2VzIG9mIGEgVGlsaW5nU3ByaXRlLlxuICAgICogVE9ETzogVHJ5IGFuZCByZW1vdmUgdGhpcywgaXQgc2hvdWxkbid0IGJlIGhlcmVcbiAgICAqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVGlsaW5nXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy5pc1RpbGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBUaGlzIHdpbGwgbGV0IGEgcmVuZGVyZXIga25vdyB0aGF0IGEgdGludGVkIHBhcmVudCBoYXMgdXBkYXRlZCBpdHMgdGV4dHVyZS5cbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSByZXF1aXJlc1JlVGludFxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMucmVxdWlyZXNSZVRpbnQgPSBmYWxzZTtcblxuICAgIC8vICBPdmVyLXJpZGVzIHRoZSBSZW5kZXJlciBzZXR0aW5nPyAtMSA9IHVzZSBSZW5kZXJlciBTZXR0aW5nLCAwID0gTm8gcm91bmRpbmcsIDEgPSBSb3VuZFxuICAgIHRoaXMuYXV0b1JvdW5kID0gLTE7XG5cbiAgICAvKipcbiAgICAqIFRoZSB1bi1tb2RpZmllZCBzb3VyY2UgZnJhbWUsIHRyaW0gYW5kIFVWIGRhdGEuXG4gICAgKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhXG4gICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgIGN1dDoge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGg6IGhlaWdodCxcbiAgICAgICAgICAgIHI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIGI6IHkgKyBoZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgIHNvdXJjZVNpemU6IHtcbiAgICAgICAgICAgIHc6IHdpZHRoLFxuICAgICAgICAgICAgaDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZVNvdXJjZVNpemU6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgICBoOiBoZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgdXZzOiB7XG4gICAgICAgICAgICB4MDogMCxcbiAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG4gICAgICAgICAgICB4MzogMCxcbiAgICAgICAgICAgIHkzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdJbWFnZToge1xuICAgICAgICAgICAgc3g6IHgsXG4gICAgICAgICAgICBzeTogeSxcbiAgICAgICAgICAgIHNXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBzSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBkV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgZEhlaWdodDogaGVpZ2h0XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVVVnMoKTtcbn07XG5cbkZyYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyYW1lO1xuXG5GcmFtZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAqIElmIHRoZSBmcmFtZSB3YXMgdHJpbW1lZCB3aGVuIGFkZGVkIHRvIHRoZSBUZXh0dXJlIEF0bGFzLCB0aGlzIHJlY29yZHMgdGhlIHRyaW0gYW5kIHNvdXJjZSBkYXRhLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlRleHR1cmVGcmFtZSNzZXRUcmltXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZyYW1lIGJlZm9yZSBiZWluZyB0cmltbWVkLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbEhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGZyYW1lIGJlZm9yZSBiZWluZyB0cmltbWVkLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RYIC0gVGhlIGRlc3RpbmF0aW9uIFggcG9zaXRpb24gb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFkgLSBUaGUgZGVzdGluYXRpb24gWSBwb3NpdGlvbiBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0V2lkdGggLSBUaGUgZGVzdGluYXRpb24gd2lkdGggb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdEhlaWdodCAtIFRoZSBkZXN0aW5hdGlvbiBoZWlnaHQgb2YgdGhlIHRyaW1tZWQgZnJhbWUgZm9yIGRpc3BsYXkuXG4gICAgKi9cbiAgICBzZXRUcmltOiBmdW5jdGlvbiAoYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCwgZGVzdFgsIGRlc3RZLCBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpXG4gICAge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIHNzID0gZGF0YS5zcHJpdGVTb3VyY2VTaXplO1xuICAgICAgICB2YXIgZGkgPSBkYXRhLmRyYXdJbWFnZTtcblxuICAgICAgICAvLyAgU3RvcmUgYWN0dWFsIHZhbHVlc1xuXG4gICAgICAgIGRhdGEudHJpbSA9IHRydWU7XG5cbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLncgPSBhY3R1YWxXaWR0aDtcbiAgICAgICAgZGF0YS5zb3VyY2VTaXplLmggPSBhY3R1YWxIZWlnaHQ7XG5cbiAgICAgICAgc3MueCA9IGRlc3RYO1xuICAgICAgICBzcy55ID0gZGVzdFk7XG4gICAgICAgIHNzLncgPSBkZXN0V2lkdGg7XG4gICAgICAgIHNzLmggPSBkZXN0SGVpZ2h0O1xuXG4gICAgICAgIC8vICBBZGp1c3QgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnggPSBkZXN0WDtcbiAgICAgICAgdGhpcy55ID0gZGVzdFk7XG4gICAgICAgIHRoaXMud2lkdGggPSBkZXN0V2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGVzdEhlaWdodDtcblxuICAgICAgICAvLyAgZHJhd0ltYWdlIGRhdGFcbiAgICAgICAgZGkuc3ggPSBkZXN0WDtcbiAgICAgICAgZGkuc3kgPSBkZXN0WTtcbiAgICAgICAgZGkuc1dpZHRoID0gZGVzdFdpZHRoO1xuICAgICAgICBkaS5zSGVpZ2h0ID0gZGVzdEhlaWdodDtcbiAgICAgICAgZGkuZFdpZHRoID0gZGVzdFdpZHRoO1xuICAgICAgICBkaS5kSGVpZ2h0ID0gZGVzdEhlaWdodDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVVWcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICAgICpcbiAgICAqIEBtZXRob2QgdXBkYXRlVVZzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHR3ID0gdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZGF0YS51dnM7XG4gICAgICAgIFxuICAgICAgICB1dnMueDAgPSB0aGlzLmN1dFggLyB0dztcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XG5cbiAgICAgICAgdXZzLngxID0gKHRoaXMuY3V0WCArIHRoaXMuY3V0V2lkdGgpIC8gdHc7XG4gICAgICAgIHV2cy55MSA9IHRoaXMuY3V0WSAvIHRoO1xuXG4gICAgICAgIHV2cy54MiA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dFdpZHRoKSAvIHR3O1xuICAgICAgICB1dnMueTIgPSAodGhpcy5jdXRZICsgdGhpcy5jdXRIZWlnaHQpIC8gdGg7XG5cbiAgICAgICAgdXZzLngzID0gdGhpcy5jdXRYIC8gdHc7XG4gICAgICAgIHV2cy55MyA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc0ludmVydGVkXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdXBkYXRlVVZzSW52ZXJ0ZWQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgdHcgPSB0aGlzLnNvdXJjZS53aWR0aDtcbiAgICAgICAgdmFyIHRoID0gdGhpcy5zb3VyY2UuaGVpZ2h0O1xuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcbiAgICAgICAgXG4gICAgICAgIHV2cy54MCA9IHRoaXMuY3V0WCAvIHR3O1xuICAgICAgICB1dnMueTAgPSB0aGlzLmN1dFkgLyB0aDtcblxuICAgICAgICB1dnMueDEgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XG4gICAgICAgIHV2cy55MSA9IHRoaXMuY3V0WSAvIHRoO1xuXG4gICAgICAgIHV2cy54MiA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dEhlaWdodCkgLyB0dztcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XG5cbiAgICAgICAgdXZzLngzID0gdGhpcy5jdXRYIC8gdHc7XG4gICAgICAgIHV2cy55MyA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dFdpZHRoKSAvIHRoO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBGcmFtZSh0aGlzLnRleHR1cmUsIHRoaXMubmFtZSwgdGhpcy5zb3VyY2VJbmRleCk7XG5cbiAgICAgICAgY2xvbmUuY3V0WCA9IHRoaXMuY3V0WDtcbiAgICAgICAgY2xvbmUuY3V0WSA9IHRoaXMuY3V0WTtcbiAgICAgICAgY2xvbmUuY3V0V2lkdGggPSB0aGlzLmN1dFdpZHRoO1xuICAgICAgICBjbG9uZS5jdXRIZWlnaHQgPSB0aGlzLmN1dEhlaWdodDtcblxuICAgICAgICBjbG9uZS54ID0gdGhpcy54O1xuICAgICAgICBjbG9uZS55ID0gdGhpcy55O1xuICAgICAgICBjbG9uZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGNsb25lLnJvdGF0ZWQgPSB0aGlzLnJvdGF0ZWQ7XG5cbiAgICAgICAgY2xvbmUuZGF0YSA9IEV4dGVuZCh0cnVlLCBjbG9uZS5kYXRhLCB0aGlzLmRhdGEpO1xuXG4gICAgICAgIGNsb25lLnVwZGF0ZVVWcygpO1xuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGcmFtZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogVGhlIHdpZHRoIG9mIHRoZSBGcmFtZSBpbiBpdHMgdW4tdHJpbW1lZCwgdW4tcGFkZGVkIHN0YXRlLCBhcyBwcmVwYXJlZCBpbiB0aGUgYXJ0IHBhY2thZ2UsXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjcmVhbFdpZHRoXG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbFdpZHRoXG4gICAgKi9cbiAgICByZWFsV2lkdGg6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VTaXplLnc7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIEZyYW1lIGluIGl0cyB1bi10cmltbWVkLCB1bi1wYWRkZWQgc3RhdGUsIGFzIHByZXBhcmVkIGluIHRoZSBhcnQgcGFja2FnZSxcbiAgICAqIGJlZm9yZSBiZWluZyBwYWNrZWQuXG4gICAgKlxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNyZWFsSGVpZ2h0XG4gICAgKiBAcHJvcGVydHkge2FueX0gcmVhbEhlaWdodFxuICAgICovXG4gICAgcmVhbEhlaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZVNpemUuaDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogVVZzXG4gICAgKlxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSN1dnNcbiAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB1dnNcbiAgICAqL1xuICAgIHV2czoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnV2cztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQ2FudmFzIERyYXcgSW1hZ2UgZGF0YVxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjY2FudmFzRGF0YVxuICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNhbnZhc0RhdGFcbiAgICAqL1xuICAgIGNhbnZhc0RhdGE6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5kcmF3SW1hZ2U7XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL0ZyYW1lLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIEZyYW1lID0gcmVxdWlyZSgnLi9GcmFtZScpO1xudmFyIFRleHR1cmVTb3VyY2UgPSByZXF1aXJlKCcuL1RleHR1cmVTb3VyY2UnKTtcblxuLyoqXG4qIEEgVGV4dHVyZSBjb25zaXN0cyBvZiBhIHNvdXJjZSwgdXN1YWxseSBhbiBJbWFnZSBmcm9tIHRoZSBDYWNoZSwgb3IgYSBDYW52YXMsIGFuZCBhIGNvbGxlY3Rpb25cbiogb2YgRnJhbWVzLiBUaGUgRnJhbWVzIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGFyZWFzIG9mIHRoZSBUZXh0dXJlLiBGb3IgZXhhbXBsZSBhIHRleHR1cmUgYXRsYXNcbiogbWF5IGhhdmUgbWFueSBGcmFtZXMsIG9uZSBmb3IgZWFjaCBlbGVtZW50IHdpdGhpbiB0aGUgYXRsYXMuIFdoZXJlLWFzIGEgc2luZ2xlIGltYWdlIHdvdWxkIGhhdmVcbioganVzdCBvbmUgZnJhbWUsIHRoYXQgZW5jb21wYXNzZXMgdGhlIHdob2xlIGltYWdlLlxuKlxuKiBUZXh0dXJlcyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIFRleHR1cmVNYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcbiogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBkZWxpdmVyaW5nIFRleHR1cmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIEZyYW1lcyB0byBHYW1lIE9iamVjdHMuXG4qXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIHRleHR1cmUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuKiBAcGFyYW0ge251bWJlcn0gc2NhbGVNb2RlXG4qL1xudmFyIFRleHR1cmUgPSBmdW5jdGlvbiAobWFuYWdlciwga2V5LCBzb3VyY2UpXG57XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgIHtcbiAgICAgICAgc291cmNlID0gWyBzb3VyY2UgXTtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcblxuICAgIC8qKlxuICAgICogVGhlIHNvdXJjZSB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxuICAgICogVXN1YWxseSBhbiBJbWFnZSwgYnV0IGNhbiBhbHNvIGJlIGEgQ2FudmFzLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSBzb3VyY2VcbiAgICAqIEB0eXBlIGFycmF5XG4gICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IFtdO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZnJhbWVzIC0gRnJhbWVzXG4gICAgKi9cbiAgICB0aGlzLmZyYW1lcyA9IHt9O1xuXG4gICAgdGhpcy5mcmFtZVRvdGFsID0gMDtcblxuICAgIC8vICBMb2FkIHRoZSBTb3VyY2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKG5ldyBUZXh0dXJlU291cmNlKHRoaXMsIHNvdXJjZVtpXSkpO1xuICAgIH1cbn07XG5cblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcblxuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cbiAgICBhZGQ6IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHZhciBmcmFtZSA9IG5ldyBGcmFtZSh0aGlzLCBuYW1lLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5mcmFtZXNbbmFtZV0gPSBmcmFtZTtcblxuICAgICAgICB0aGlzLmZyYW1lVG90YWwrKztcblxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwgfHwgdGhpcy5mcmFtZVRvdGFsID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lID0gJ19fQkFTRSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWZyYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIFRleHR1cmUuZnJhbWUgZm91bmQgd2l0aCBuYW1lICcgKyBuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzWydfX0JBU0UnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlSW5kZXg6IGZ1bmN0aW9uIChpbmRleClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlW2ldLmdsVGV4dHVyZUluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc291cmNlW2ldLmltYWdlLmN1cnJlbnRTcmMsICdpbmRleCA9ICcsIGluZGV4KTtcblxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxuICAgICpcbiAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBOZWVkIHRvIGl0ZXJhdGUgdGhvdWdoIHRoZSBUZXh0dXJlU291cmNlcywgYW5kIHVubG9hZCBlYWNoIG9uZVxuICAgICAgICAvLyAgdGhlbiBjbGVhciBvdXQgdGhlIGZyYW1lc1xuXG4gICAgICAgIC8qXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSlcbiAgICAgICAge1xuICAgICAgICAgICAgUGhhc2VyLkNhbnZhc1Bvb2wucmVtb3ZlQnlDYW52YXModGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICAqL1xuICAgIH1cblxufTtcblxuLyoqXG4qIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBiYXNlIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG4qXG4qIEBzdGF0aWNcbiogQG1ldGhvZCBmcm9tQ2FudmFzXG4qIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHNvdXJjZSBvZiB0aGUgdGV4dHVyZVxuKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNlZSB7eyNjcm9zc0xpbmsgXCJQSVhJL3NjYWxlTW9kZXM6cHJvcGVydHlcIn19UGhhc2VyLnNjYWxlTW9kZXN7ey9jcm9zc0xpbmt9fSBmb3IgcG9zc2libGUgdmFsdWVzXG4qIEByZXR1cm4ge0Jhc2VUZXh0dXJlfVxuUGhhc2VyLlRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICBpZiAoY2FudmFzLndpZHRoID09PSAwKVxuICAgIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLmhlaWdodCA9PT0gMClcbiAgICB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGhhc2VyLlRleHR1cmUoY2FudmFzLCBzY2FsZU1vZGUpO1xufTtcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL1RleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VycycpO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcblxuLyoqXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgVGV4dHVyZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgRnJhbWVzIHRvIEdhbWUgT2JqZWN0cy5cbipcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cbipcbiogQWNjZXNzIGl0IHZpYSBgc3RhdGUudGV4dHVyZXNgLlxuKlxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVNYW5hZ2VyXG4qIEBjb25zdHJ1Y3RvclxuKi9cbnZhciBUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5saXN0ID0ge307XG59O1xuXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlTWFuYWdlcjtcblxuVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgYWRkSW1hZ2U6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xuICAgICAgICBcbiAgICAgICAgUGFyc2VyLkltYWdlKHRleHR1cmUsIDApO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBhZGRDYW52YXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xuICAgICAgICBcbiAgICAgICAgUGFyc2VyLkNhbnZhcyh0ZXh0dXJlLCAwKTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgYWRkQXRsYXM6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcbiAgICB7XG4gICAgICAgIC8vICBJcyBpdCBhIEhhc2ggb3IgYW4gQXJyYXk/XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5mcmFtZXMpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBdGxhc0pTT05BcnJheShrZXksIHNvdXJjZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBdGxhc0pTT05IYXNoKGtleSwgc291cmNlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRBdGxhc0pTT05BcnJheTogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQYXJzZXIuSlNPTkFycmF5KHRleHR1cmUsIGksIGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgUGFyc2VyLkpTT05BcnJheSh0ZXh0dXJlLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBhZGRBdGxhc0pTT05IYXNoOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OSGFzaCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIFBhcnNlci5KU09OSGFzaCh0ZXh0dXJlLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBhZGRTcHJpdGVTaGVldDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZylcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IHRleHR1cmUuc291cmNlWzBdLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dHVyZS5zb3VyY2VbMF0uaGVpZ2h0O1xuXG4gICAgICAgIFBhcnNlci5TcHJpdGVTaGVldCh0ZXh0dXJlLCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIG1hcmdpbiwgc3BhY2luZyk7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIGFkZFNwcml0ZVNoZWV0RnJvbUF0bGFzOiBmdW5jdGlvbiAoa2V5LCBhdGxhc0tleSwgYXRsYXNGcmFtZSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmcpXG4gICAge1xuICAgICAgICB2YXIgYXRsYXMgPSB0aGlzLmdldChhdGxhc0tleSk7XG4gICAgICAgIHZhciBzaGVldCA9IGF0bGFzLmdldChhdGxhc0ZyYW1lKTtcblxuICAgICAgICBpZiAoc2hlZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzaGVldC5zb3VyY2UuaW1hZ2UpO1xuXG4gICAgICAgICAgICBQYXJzZXIuU3ByaXRlU2hlZXQodGV4dHVyZSwgMCwgc2hlZXQuY3V0WCwgc2hlZXQuY3V0WSwgc2hlZXQuY3V0V2lkdGgsIHNoZWV0LmN1dEhlaWdodCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRBdGxhc1N0YXJsaW5nWE1MOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIFBhcnNlci5TdGFybGluZ1hNTCh0ZXh0dXJlLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBhZGRBdGxhc1B5eGVsOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCBpLCBkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIFBhcnNlci5QeXhlbCh0ZXh0dXJlLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcywga2V5LCBzb3VyY2UpO1xuXG4gICAgICAgIHRoaXMubGlzdFtrZXldID0gdGV4dHVyZTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICBleGlzdHM6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMubGlzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9ICdfX0RFRkFVTFQnOyB9XG5cbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0WydfX01JU1NJTkcnXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZUZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldLmdldChmcmFtZSkuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRGcmFtZTogZnVuY3Rpb24gKGtleSwgZnJhbWUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XS5nZXQoZnJhbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFRleHR1cmU6IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBrZXksIGZyYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxuICAgICAgICB7XG4gICAgICAgICAgICBnYW1lT2JqZWN0LnRleHR1cmUgPSB0aGlzLmxpc3Rba2V5XTtcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZnJhbWUgPSBnYW1lT2JqZWN0LnRleHR1cmUuZ2V0KGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFBhc3NlcyBhbGwgVGV4dHVyZXMgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBtZXRob2QgZWFjaFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICogQHBhcmFtIHsuLi4qfSBbYXJndW1lbnRzXSAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBhZnRlciB0aGUgY2hpbGQuXG4gICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpXG4gICAge1xuICAgICAgICB2YXIgYXJncyA9IFsgbnVsbCBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHRleHR1cmUgaW4gdGhpcy5saXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBhcmdzWzBdID0gdGhpcy5saXN0W3RleHR1cmVdO1xuXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL1RleHR1cmVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIElzU2l6ZVBvd2VyT2ZUd28gPSByZXF1aXJlKCcuLi9tYXRoL3BvdzIvSXNTaXplUG93ZXJPZlR3bycpO1xuXG4vKipcbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlU291cmNlXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGVcbiovXG52YXIgVGV4dHVyZVNvdXJjZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2UpXG57XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgIHRoaXMuaW1hZ2UgPSBzb3VyY2U7XG5cbiAgICB0aGlzLmNvbXByZXNzaW9uQWxnb3JpdGhtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogVGhlIFJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUuXG4gICAgKlxuICAgICogQHByb3BlcnR5IHJlc29sdXRpb25cbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICBcbiAgICAvKipcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZS5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLndpZHRoID0gc291cmNlLm5hdHVyYWxXaWR0aCB8fCBzb3VyY2Uud2lkdGggfHwgMDtcblxuICAgIC8qKlxuICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZS5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgKiBAdHlwZSBOdW1iZXJcbiAgICAqIEByZWFkT25seVxuICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBzb3VyY2UubmF0dXJhbEhlaWdodCB8fCBzb3VyY2UuaGVpZ2h0IHx8IDA7XG5cbiAgICAvKipcbiAgICAqIFRoZSBzY2FsZSBtb2RlIHRvIGFwcGx5IHdoZW4gc2NhbGluZyB0aGlzIHRleHR1cmUuXG4gICAgKiBORUFSRVNUIG9yIERFRkFVTFRcbiAgICAqXG4gICAgKiBAcHJvcGVydHkgc2NhbGVNb2RlXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQGRlZmF1bHQgUGhhc2VyLnNjYWxlTW9kZXMuREVGQVVMVDtcbiAgICAqL1xuICAgIHRoaXMuc2NhbGVNb2RlID0gQ09OU1Quc2NhbGVNb2Rlcy5ERUZBVUxUO1xuICAgIC8vIHRoaXMuc2NhbGVNb2RlID0gQ09OU1Quc2NhbGVNb2Rlcy5ORUFSRVNUO1xuXG4gICAgLyoqXG4gICAgKiBDb250cm9scyBpZiBSR0IgY2hhbm5lbHMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIGJ5IEFscGhhICAoV2ViR0wgb25seSlcbiAgICAqXG4gICAgKiBAcHJvcGVydHkgcHJlbXVsdGlwbGllZEFscGhhXG4gICAgKiBAdHlwZSBCb29sZWFuXG4gICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgKi9cbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcbiAgICAqIEFsc28gdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBzaXplIHRvIHdvcmtcbiAgICAqXG4gICAgKiBAcHJvcGVydHkgbWlwbWFwXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqL1xuICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEEgQmFzZVRleHR1cmUgY2FuIGJlIHNldCB0byBza2lwIHRoZSByZW5kZXJpbmcgcGhhc2UgaW4gdGhlIFdlYkdMIFNwcml0ZSBCYXRjaC5cbiAgICAqXG4gICAgKiBZb3UgbWF5IHdhbnQgdG8gZG8gdGhpcyBpZiB5b3UgaGF2ZSBhIHBhcmVudCBTcHJpdGUgd2l0aCBubyB2aXNpYmxlIHRleHR1cmUgKGkuZS4gdXNlcyB0aGUgaW50ZXJuYWwgYF9fZGVmYXVsdGAgdGV4dHVyZSlcbiAgICAqIHRoYXQgaGFzIGNoaWxkcmVuIHRoYXQgeW91IGRvIHdhbnQgdG8gcmVuZGVyLCB3aXRob3V0IGNhdXNpbmcgYSBiYXRjaCBmbHVzaCBpbiB0aGUgcHJvY2Vzcy5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkgcmVuZGVyYWJsZVxuICAgICogQHR5cGUgQm9vbGVhblxuICAgICovXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IGlzUG93ZXJPZjJcbiAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAqL1xuICAgIHRoaXMuaXNQb3dlck9mMiA9IElzU2l6ZVBvd2VyT2ZUd28odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgZ2xUZXh0dXJlXG4gICAgKi9cbiAgICB0aGlzLmdsVGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIFRoZSBtdWx0aSB0ZXh0dXJlIGJhdGNoaW5nIGluZGV4IG51bWJlci5cbiAgICAqIEBwcm9wZXJ0eSBnbFRleHR1cmVJbmRleFxuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKi9cbiAgICB0aGlzLmdsVGV4dHVyZUluZGV4ID0gMDtcblxuICAgIC8qKlxuICAgICogVGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgdGV4dHVyZSB3YXMgbGFzdCB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICAqIENhbiBiZSB1c2VkIHRvIHB1cmdlIG91dCAnZGVhZCcgdGV4dHVyZXMgZnJvbSBHUFUgbWVtb3J5LlxuICAgICogQHByb3BlcnR5IGdsTGFzdFVzZWRcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICAgdGhpcy5nbExhc3RVc2VkID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IGdsRGlydHlcbiAgICAqL1xuICAgIHRoaXMuZ2xEaXJ0eSA9IHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVTb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXG4qIEBzdGF0aWNcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgQ2FudmFzVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcbntcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1RleHR1cmVQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0NhbnZhc1RleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogUGFyc2UgYSBTcHJpdGUgU2hlZXQgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5JbWFnZVxuKiBAc3RhdGljXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXG4qL1xudmFyIEltYWdlVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleClcbntcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlVGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvSW1hZ2VUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlcyBhIEpTT04gQXJyYXkgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBBcnJheSBmb3JtYXQuXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxuKi9cbnZhciBKU09OQXJyYXlUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCBqc29uKVxue1xuICAgIC8vICBNYWxmb3JtZWQ/XG4gICAgaWYgKCFqc29uWydmcmFtZXMnXSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gQXJyYXkgZ2l2ZW4sIG1pc3NpbmcgXFwnZnJhbWVzXFwnIGFycmF5Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcblxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBhcnJheVxuICAgIHZhciBmcmFtZXMgPSBqc29uWydmcmFtZXMnXTtcbiAgICB2YXIgbmV3RnJhbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNbaV07XG5cbiAgICAgICAgLy8gIFRoZSBmcmFtZSB2YWx1ZXMgYXJlIHRoZSBleGFjdCBjb29yZGluYXRlcyB0byBjdXQgdGhlIGZyYW1lIG91dCBvZiB0aGUgYXRsYXMgZnJvbVxuICAgICAgICBuZXdGcmFtZSA9IHRleHR1cmUuYWRkKHNyYy5maWxlbmFtZSwgc291cmNlSW5kZXgsIHNyYy5mcmFtZS54LCBzcmMuZnJhbWUueSwgc3JjLmZyYW1lLncsIHNyYy5mcmFtZS5oKTtcblxuICAgICAgICAvLyAgVGhlc2UgYXJlIHRoZSBvcmlnaW5hbCAobm9uLXRyaW1tZWQpIHNwcml0ZSB2YWx1ZXNcbiAgICAgICAgaWYgKHNyYy50cmltbWVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdGcmFtZS5zZXRUcmltKFxuICAgICAgICAgICAgICAgIHNyYy5zb3VyY2VTaXplLncsXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUuaCxcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS54LFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLnksXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUudyxcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS5oXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYy5yb3RhdGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdGcmFtZS5yb3RhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OQXJyYXlUZXh0dXJlUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXlUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlcyBhIEpTT04gQXJyYXkgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBKU09OIEhhc2ggZm9ybWF0LlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgSlNPTkhhc2hUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCBqc29uKVxue1xuICAgIC8vICBNYWxmb3JtZWQ/XG4gICAgaWYgKCFqc29uWydmcmFtZXMnXSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcblxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBPYmplY3RcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XG4gICAgdmFyIG5ld0ZyYW1lO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcbiAgICB7XG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNba2V5XTtcblxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXG4gICAgICAgIG5ld0ZyYW1lID0gdGV4dHVyZS5hZGQoa2V5LCBzb3VyY2VJbmRleCwgc3JjLmZyYW1lLngsIHNyYy5mcmFtZS55LCBzcmMuZnJhbWUudywgc3JjLmZyYW1lLmgpO1xuXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xuICAgICAgICBpZiAoc3JjLnRyaW1tZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUudyxcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueSxcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjLnJvdGF0ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05IYXNoVGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkhhc2hUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlcyBhIFB5eGVsIEpTT04gRmlsZSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxuKiBAc3RhdGljXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIFB5eGVsIEpTT04gZm9ybWF0LlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgUHl4ZWxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIGpzb24pXG57XG4gICAgLy8gIE1hbGZvcm1lZD8gVGhlcmUgYXJlIGEgZmV3IGtleXMgdG8gY2hlY2sgaGVyZS5cbiAgICB2YXIgc2lnbmF0dXJlID0gWyAnbGF5ZXJzJywgJ3RpbGV3aWR0aCcsICd0aWxlaGVpZ2h0JywgJ3RpbGVzd2lkZScsICd0aWxlc2hpZ2gnIF07XG5cbiAgICBzaWduYXR1cmUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgaWYgKCFqc29uW2tleV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBJbnZhbGlkIFB5eGVsIFRpbGVtYXAgSlNPTiBnaXZlbiwgbWlzc2luZyBcIicgKyBrZXkgKyAnXCIga2V5LicpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coanNvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIEkgb25seSBjYXJlIGFib3V0IHBhcnNpbmcgdGlsZW1hcHMgd2l0aCBhIHNpbmdsZSBsYXllci5cbiAgICBpZiAoanNvblsnbGF5ZXJzJ10ubGVuZ3RoICE9PSAxKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLkpTT05EYXRhUHl4ZWw6IFRvbyBtYW55IGxheWVycywgdGhpcyBwYXJzZXIgb25seSBzdXBwb3J0cyBmbGF0IFRpbGVtYXBzLicpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gbmV3IFBoYXNlci5GcmFtZURhdGEoKTtcblxuICAgIHZhciB0aWxlaGVpZ2h0ID0ganNvblsndGlsZWhlaWdodCddO1xuICAgIHZhciB0aWxld2lkdGggPSBqc29uWyd0aWxld2lkdGgnXTtcblxuICAgIHZhciBmcmFtZXMgPSBqc29uWydsYXllcnMnXVswXVsndGlsZXMnXTtcbiAgICB2YXIgbmV3RnJhbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGZyYW1lc1tpXS54LFxuICAgICAgICAgICAgZnJhbWVzW2ldLnksXG4gICAgICAgICAgICB0aWxld2lkdGgsXG4gICAgICAgICAgICB0aWxlaGVpZ2h0LFxuICAgICAgICAgICAgXCJmcmFtZV9cIiArIGkgIC8vIE5vIG5hbWVzIGFyZSBpbmNsdWRlZCBpbiBweXhlbCB0aWxlbWFwIGRhdGEuXG4gICAgICAgICkpO1xuXG4gICAgICAgIC8vIE5vIHRyaW0gZGF0YSBpcyBpbmNsdWRlZC5cbiAgICAgICAgbmV3RnJhbWUuc2V0VHJpbShmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFB5eGVsVGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvUHl4ZWxUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxuKlxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuU3ByaXRlU2hlZXRcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgRnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlIHRoYXQgdGhlIFNwcml0ZSBTaGVldCBpcyBzdG9yZWQgaW4uXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVdpZHRoIC0gVGhlIGZpeGVkIHdpZHRoIG9mIGVhY2ggZnJhbWUuXG4qIEBwYXJhbSB7bnVtYmVyfSBmcmFtZUhlaWdodCAtIFRoZSBmaXhlZCBoZWlnaHQgb2YgZWFjaCBmcmFtZS5cbiogQHBhcmFtIHtudW1iZXJ9IFtzdGFydEZyYW1lPTBdIC0gU2tpcCBhIG51bWJlciBvZiBmcmFtZXMuIFVzZWZ1bCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBzcHJpdGUgc2hlZXRzIGluIG9uZSBUZXh0dXJlLlxuKiBAcGFyYW0ge251bWJlcn0gW2VuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxuKiBAcGFyYW0ge251bWJlcn0gW21hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxuKiBAcGFyYW0ge251bWJlcn0gW3NwYWNpbmc9MF0gLSBJZiB0aGUgZnJhbWVzIGhhdmUgYmVlbiBkcmF3biB3aXRoIHNwYWNpbmcgYmV0d2VlbiB0aGVtLCBzcGVjaWZ5IHRoZSBhbW91bnQgaGVyZS5cbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXG4qL1xudmFyIFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzb3VyY2VJbmRleCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmcpXG57XG4gICAgaWYgKHN0YXJ0RnJhbWUgPT09IHVuZGVmaW5lZCkgeyBzdGFydEZyYW1lID0gMDsgfVxuICAgIGlmIChlbmRGcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGVuZEZyYW1lID0gLTE7IH1cbiAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHsgbWFyZ2luID0gMDsgfVxuICAgIGlmIChzcGFjaW5nID09PSB1bmRlZmluZWQpIHsgc3BhY2luZyA9IDA7IH1cblxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh3aWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcbiAgICB2YXIgY29sdW1uID0gTWF0aC5mbG9vcigoaGVpZ2h0IC0gbWFyZ2luKSAvIChmcmFtZUhlaWdodCArIHNwYWNpbmcpKTtcbiAgICB2YXIgdG90YWwgPSByb3cgKiBjb2x1bW47XG5cbiAgICBpZiAoc3RhcnRGcmFtZSA+IHRvdGFsIHx8IHN0YXJ0RnJhbWUgPCAtdG90YWwpXG4gICAge1xuICAgICAgICBzdGFydEZyYW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXG4gICAge1xuICAgICAgICAvLyAgQWxsb3cgbmVnYXRpdmUgc2tpcGZyYW1lcy5cbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxuICAgIHtcbiAgICAgICAgdG90YWwgPSBzdGFydEZyYW1lICsgKGVuZEZyYW1lICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIGZ4ID0gbWFyZ2luO1xuICAgIHZhciBmeSA9IG1hcmdpbjtcbiAgICB2YXIgYXggPSAwO1xuICAgIHZhciBheSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICBheCA9IDA7XG4gICAgICAgIGF5ID0gMDtcblxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcbiAgICAgICAgdmFyIGggPSBmeSArIGZyYW1lSGVpZ2h0O1xuXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gdyAtIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggPiBoZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF5ID0gaCAtIGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHR1cmUuYWRkKGksIHNvdXJjZUluZGV4LCB4ICsgZngsIHkgKyBmeSwgZnJhbWVXaWR0aCAtIGF4LCBmcmFtZUhlaWdodCAtIGF5KTtcblxuICAgICAgICBmeCArPSBmcmFtZVdpZHRoICsgc3BhY2luZztcblxuICAgICAgICBpZiAoZnggKyBmcmFtZVdpZHRoID4gd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZ4ID0gbWFyZ2luO1xuICAgICAgICAgICAgZnkgKz0gZnJhbWVIZWlnaHQgKyBzcGFjaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlcyB0aGUgWE1MIGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxuKlxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuU3RhcmxpbmdYTUxcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge29iamVjdH0geG1sIC0gVGhlIFhNTCBkYXRhIGZyb20gdGhlIFRleHR1cmUgQXRsYXMuIE11c3QgYmUgaW4gU3RhcmxpbmcgWE1MIGZvcm1hdC5cbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXG4qL1xudmFyIFN0YXJsaW5nWE1MVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB4bWwpXG57XG4gICAgLy8gIE1hbGZvcm1lZD9cbiAgICBpZiAoIXhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnVGV4dHVyZUF0bGFzJykpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJQaGFzZXIuQW5pbWF0aW9uUGFyc2VyLlhNTERhdGE6IEludmFsaWQgVGV4dHVyZSBBdGxhcyBYTUwgZ2l2ZW4sIG1pc3NpbmcgPFRleHR1cmVBdGxhcz4gdGFnXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gIExldCdzIGNyZWF0ZSBzb21lIGZyYW1lcyB0aGVuXG4gICAgdmFyIGRhdGEgPSBuZXcgUGhhc2VyLkZyYW1lRGF0YSgpO1xuICAgIHZhciBmcmFtZXMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1N1YlRleHR1cmUnKTtcbiAgICB2YXIgbmV3RnJhbWU7XG5cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZnJhbWU7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIHdpZHRoO1xuICAgIHZhciBoZWlnaHQ7XG4gICAgdmFyIGZyYW1lWDtcbiAgICB2YXIgZnJhbWVZO1xuICAgIHZhciBmcmFtZVdpZHRoO1xuICAgIHZhciBmcmFtZUhlaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV0uYXR0cmlidXRlcztcblxuICAgICAgICBuYW1lID0gZnJhbWUubmFtZS52YWx1ZTtcbiAgICAgICAgeCA9IHBhcnNlSW50KGZyYW1lLngudmFsdWUsIDEwKTtcbiAgICAgICAgeSA9IHBhcnNlSW50KGZyYW1lLnkudmFsdWUsIDEwKTtcbiAgICAgICAgd2lkdGggPSBwYXJzZUludChmcmFtZS53aWR0aC52YWx1ZSwgMTApO1xuICAgICAgICBoZWlnaHQgPSBwYXJzZUludChmcmFtZS5oZWlnaHQudmFsdWUsIDEwKTtcblxuICAgICAgICBmcmFtZVggPSBudWxsO1xuICAgICAgICBmcmFtZVkgPSBudWxsO1xuXG4gICAgICAgIGlmIChmcmFtZS5mcmFtZVgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZyYW1lWCA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWC52YWx1ZSwgMTApKTtcbiAgICAgICAgICAgIGZyYW1lWSA9IE1hdGguYWJzKHBhcnNlSW50KGZyYW1lLmZyYW1lWS52YWx1ZSwgMTApKTtcbiAgICAgICAgICAgIGZyYW1lV2lkdGggPSBwYXJzZUludChmcmFtZS5mcmFtZVdpZHRoLnZhbHVlLCAxMCk7XG4gICAgICAgICAgICBmcmFtZUhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lSGVpZ2h0LnZhbHVlLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdGcmFtZSA9IGRhdGEuYWRkRnJhbWUobmV3IFBoYXNlci5GcmFtZShpLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBuYW1lKSk7XG5cbiAgICAgICAgLy8gIFRyaW1tZWQ/XG4gICAgICAgIGlmIChmcmFtZVggIT09IG51bGwgfHwgZnJhbWVZICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdGcmFtZS5zZXRUcmltKHRydWUsIHdpZHRoLCBoZWlnaHQsIGZyYW1lWCwgZnJhbWVZLCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFybGluZ1hNTFRleHR1cmVQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL1N0YXJsaW5nWE1MVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2FudmFzOiByZXF1aXJlKCcuL0NhbnZhc1RleHR1cmVQYXJzZXInKSxcbiAgICBJbWFnZTogcmVxdWlyZSgnLi9JbWFnZVRleHR1cmVQYXJzZXInKSxcbiAgICBTcHJpdGVTaGVldDogcmVxdWlyZSgnLi9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXInKSxcbiAgICBKU09OQXJyYXk6IHJlcXVpcmUoJy4vSlNPTkFycmF5VGV4dHVyZVBhcnNlcicpLFxuICAgIEpTT05IYXNoOiByZXF1aXJlKCcuL0pTT05IYXNoVGV4dHVyZVBhcnNlcicpLFxuICAgIFN0YXJsaW5nWE1MOiByZXF1aXJlKCcuL1N0YXJsaW5nWE1MVGV4dHVyZVBhcnNlcicpLFxuICAgIFB5eGVsOiByZXF1aXJlKCcuL1B5eGVsVGV4dHVyZVBhcnNlcicpXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCIvKipcbiogU25hcHMgYSB2YWx1ZSB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhbiBhcnJheS5cbiogVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBpbiB0aGUgcmFuZ2UgYFtmaXJzdF92YWx1ZSwgbGFzdF92YWx1ZV1gLlxuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBzZWFyY2ggdmFsdWVcbiogQHBhcmFtIHtudW1iZXJbXX0gYXJyIC0gVGhlIGlucHV0IGFycmF5IHdoaWNoIF9tdXN0XyBiZSBzb3J0ZWQuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgdmFsdWUgZm91bmQuXG4qL1xudmFyIEZpbmRDbG9zZXN0SW5Tb3J0ZWQgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5KVxue1xuICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJyYXkubGVuZ3RoID09PSAxIHx8IHZhbHVlIDwgYXJyYXlbMF0pXG4gICAge1xuICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgfVxuXG4gICAgdmFyIGkgPSAxO1xuXG4gICAgd2hpbGUgKGFycmF5W2ldIDwgdmFsdWUpXG4gICAge1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgdmFyIGxvdyA9IGFycmF5W2kgLSAxXTtcbiAgICB2YXIgaGlnaCA9IChpIDwgYXJyYXkubGVuZ3RoKSA/IGFycmF5W2ldIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgcmV0dXJuICgoaGlnaCAtIHZhbHVlKSA8PSAodmFsdWUgLSBsb3cpKSA/IGhpZ2ggOiBsb3c7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRDbG9zZXN0SW5Tb3J0ZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEZldGNoIGEgcmFuZG9tIGVudHJ5IGZyb20gdGhlIGdpdmVuIGFycmF5LlxuKlxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2Vcbiogb3IgaWYgdGhlcmUgaXMgbm8gaXRlbSBmb3IgdGhlIHJhbmRvbWx5IGNob3NlbiBpbmRleC5cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge2FueVtdfSBvYmplY3RzIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxuKiBAcmV0dXJuIHtvYmplY3R9IFRoZSByYW5kb20gb2JqZWN0IHRoYXQgd2FzIHNlbGVjdGVkLlxuKi9cblxudmFyIEdldFJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0LCBsZW5ndGgpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgfVxuXG4gICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnQgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xuXG4gICAgcmV0dXJuIChhcnJheVtyYW5kb21JbmRleF0gPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYXJyYXlbcmFuZG9tSW5kZXhdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRSYW5kb21FbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvR2V0UmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZEF3YXlGcm9tWmVybyA9IHJlcXVpcmUoJy4uLy4uL21hdGgvUm91bmRBd2F5RnJvbVplcm8nKTtcblxuLyoqXG4qIENyZWF0ZSBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb20gYHN0YXJ0YFxuKiB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYCBieSBhZHZhbmNpbmcgYnkgYHN0ZXBgLlxuKlxuKiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgZW5kYCBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbipcbiogQ2VydGFpbiB2YWx1ZXMgZm9yIGBzdGFydGAgYW5kIGBlbmRgIChlZy4gTmFOL3VuZGVmaW5lZC9udWxsKSBhcmUgY3VycmVudGx5IGNvZXJjZWQgdG8gMDtcbiogZm9yIGZvcndhcmQgY29tcGF0aWJpbGl0eSBtYWtlIHN1cmUgdG8gcGFzcyBpbiBhY3R1YWwgbnVtYmVycy5cbipcbiogQG1ldGhvZCBQaGFzZXIuQXJyYXlVdGlscyNudW1iZXJBcnJheVN0ZXBcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBudW1iZXJzLlxuKiBAZXhhbXBsZVxuKiBOdW1iZXJBcnJheVN0ZXAoNCk7XG4qIC8vID0+IFswLCAxLCAyLCAzXVxuKlxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNSk7XG4qIC8vID0+IFsxLCAyLCAzLCA0XVxuKlxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgMjAsIDUpO1xuKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuKlxuKiBOdW1iZXJBcnJheVN0ZXAoMCwgLTQsIC0xKTtcbiogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4qXG4qIE51bWJlckFycmF5U3RlcCgxLCA0LCAwKTtcbiogLy8gPT4gWzEsIDEsIDFdXG4qXG4qIE51bWJlckFycmF5U3RlcCgwKTtcbiogLy8gPT4gW11cbiovXG52YXIgTnVtYmVyQXJyYXlTdGVwID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7IGVuZCA9IG51bGw7IH1cbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAxOyB9XG5cbiAgICBpZiAoZW5kID09PSBudWxsKVxuICAgIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgdG90YWwgPSBNYXRoLm1heChSb3VuZEF3YXlGcm9tWmVybygoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBcnJheVN0ZXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ2YXIgU3BsaWNlT25lID0gcmVxdWlyZSgnLi9TcGxpY2VPbmUnKTtcblxuLyoqXG4qIFJlbW92ZXMgYSByYW5kb20gb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IGFuZCByZXR1cm5zIGl0LlxuKlxuKiBXaWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGFyZSBubyBhcnJheSBpdGVtcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2Vcbiogb3IgaWYgdGhlcmUgaXMgbm8gaXRlbSBmb3IgdGhlIHJhbmRvbWx5IGNob3NlbiBpbmRleC5cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge2FueVtdfSBvYmplY3RzIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydEluZGV4IC0gT3B0aW9uYWwgb2Zmc2V0IG9mZiB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LiBEZWZhdWx0IHZhbHVlIGlzIDAsIG9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgdmFsdWVzIHlvdSB3YW50IHRvIHJhbmRvbWx5IHNlbGVjdCBmcm9tLlxuKiBAcmV0dXJuIHtvYmplY3R9IFRoZSByYW5kb20gb2JqZWN0IHRoYXQgd2FzIHJlbW92ZWQuXG4qL1xuXG52YXIgUmVtb3ZlUmFuZG9tRWxlbWVudCA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnQsIGxlbmd0aClcbntcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgeyBzdGFydCA9IDA7IH1cbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyB9XG5cbiAgICB2YXIgcmFuZG9tSW5kZXggPSBzdGFydCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XG5cbiAgICByZXR1cm4gU3BsaWNlT25lKGFycmF5LCByYW5kb21JbmRleCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZVJhbmRvbUVsZW1lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qcyIsIi8qKlxuKiBNb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGFycmF5IHRvIHRoZSBlbmQsIHNoaWZ0aW5nIGFsbCBpdGVtcyBpbiB0aGUgcHJvY2Vzcy5cbiogVGhlIFwicm90YXRpb25cIiBoYXBwZW5zIHRvIHRoZSBsZWZ0LlxuKlxuKiBAbWV0aG9kIFBoYXNlci5BcnJheVV0aWxzLnJvdGF0ZVxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4qIEByZXR1cm4ge2FueX0gVGhlIHNoaWZ0ZWQgdmFsdWUuXG4qL1xudmFyIFJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxue1xuICAgIGlmICh0b3RhbCA9PT0gdW5kZWZpbmVkKSB7IHRvdGFsID0gMTsgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgZWxlbWVudCA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUxlZnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIHRoZSBzdGFydCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxuKiBUaGUgXCJyb3RhdGlvblwiIGhhcHBlbnMgdG8gdGhlIHJpZ2h0LlxuKlxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4qIEByZXR1cm4ge2FueX0gVGhlIHNoaWZ0ZWQgdmFsdWUuXG4qL1xudmFyIFJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKGFycmF5LCB0b3RhbClcbntcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5wb3AoKTtcbiAgICAgICAgYXJyYXkudW5zaGlmdChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlUmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9Sb3RhdGVSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBBIHN0YW5kYXJkIEZpc2hlci1ZYXRlcyBBcnJheSBzaHVmZmxlIGltcGxlbWVudGF0aW9uIHdoaWNoIG1vZGlmaWVzIHRoZSBhcnJheSBpbiBwbGFjZS5cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaHVmZmxlLlxuKiBAcmV0dXJuIHthbnlbXX0gVGhlIG9yaWdpbmFsIGFycmF5LCBub3cgc2h1ZmZsZWQuXG4qL1xudmFyIFNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpXG57XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXG4gICAge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaHVmZmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvU2h1ZmZsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvcmljaC9Eb2N1bWVudHMvcGhhc2VyL3YzL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGhhc2VyLmpzIiwicmVxdWlyZSgnLi9wb2x5ZmlsbHMnKTtcblxudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIEV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0L0V4dGVuZCcpO1xuXG4vLyAgVGhpcyBvYmplY3QgaXMgZXhwb3J0ZWQgZ2xvYmFsbHlcblxudmFyIFBoYXNlciA9IHtcblxuICAgIEdhbWU6IHJlcXVpcmUoJy4vYm9vdC9HYW1lJyksXG5cbiAgICBFdmVudDogcmVxdWlyZSgnLi9ldmVudHMvRXZlbnQnKSxcbiAgICBFdmVudERpc3BhdGNoZXI6IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpLFxuXG4gICAgTWF0aDogcmVxdWlyZSgnLi9tYXRoJyksXG5cbiAgICBHZW9tOiByZXF1aXJlKCcuL2dlb20nKSxcblxuICAgIEdhbWVPYmplY3RzOiB7XG5cbiAgICAgICAgRmFjdG9yeTogcmVxdWlyZSgnLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJylcblxuICAgIH0sXG5cbiAgICBMb2FkZXI6IHtcblxuICAgICAgICBJbWFnZUZpbGU6IHJlcXVpcmUoJy4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUnKVxuXG4gICAgfSxcblxuICAgIFNvdW5kOiByZXF1aXJlKCcuL3NvdW5kJyksXG5cbiAgICBVdGlsczoge1xuXG4gICAgICAgIEFycmF5OiByZXF1aXJlKCcuL3V0aWxzL2FycmF5LycpLFxuICAgICAgICBPYmplY3RzOiByZXF1aXJlKCcuL3V0aWxzL29iamVjdC8nKVxuXG4gICAgfVxuXG59O1xuXG4vLyAgUmVxdWlyZWQsIGJ1dCBkb24ndCBuZWVkIFBoYXNlciBsZXZlbCBleHBvcnRzXG5cbnJlcXVpcmUoJy4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VGYWN0b3J5Jyk7XG5yZXF1aXJlKCcuL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5Jyk7XG5cbi8vICAgTWVyZ2UgaW4gdGhlIGNvbnN0c1xuXG5QaGFzZXIgPSBFeHRlbmQoZmFsc2UsIFBoYXNlciwgQ09OU1QpO1xuXG4vLyAgRXhwb3J0IGl0XG5cbm1vZHVsZS5leHBvcnRzID0gUGhhc2VyO1xuXG5nbG9iYWwuUGhhc2VyID0gUGhhc2VyO1xuXG4vKlxuICog4oCcU29tZXRpbWVzLCB0aGUgZWxlZ2FudCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IGEgZnVuY3Rpb24uXG4gKiBOb3QgYSBtZXRob2QuIE5vdCBhIGNsYXNzLiBOb3QgYSBmcmFtZXdvcmsuIEp1c3QgYSBmdW5jdGlvbi7igJ1cbiAqIC0gSm9obiBDYXJtYWNrXG4gKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoYXNlci5qc1xuLy8gbW9kdWxlIGlkID0gMzMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=