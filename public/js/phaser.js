(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Phaser", [], factory);
	else if(typeof exports === 'object')
		exports["Phaser"] = factory();
	else
		root["Phaser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 653);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/

var Common = {};

module.exports = Common;

(function() {

    Common._nextId = 0;
    Common._seed = 0;

    /**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */
    Common.extend = function(obj, deep) {
        var argsStart,
            args,
            deepClone;

        if (typeof deep === 'boolean') {
            argsStart = 2;
            deepClone = deep;
        } else {
            argsStart = 1;
            deepClone = true;
        }

        for (var i = argsStart; i < arguments.length; i++) {
            var source = arguments[i];

            if (source) {
                for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                            obj[prop] = obj[prop] || {};
                            Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                            obj[prop] = source[prop];
                        }
                    } else {
                        obj[prop] = source[prop];
                    }
                }
            }
        }
        
        return obj;
    };

    /**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */
    Common.clone = function(obj, deep) {
        return Common.extend({}, deep, obj);
    };

    /**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */
    Common.keys = function(obj) {
        if (Object.keys)
            return Object.keys(obj);

        // avoid hasOwnProperty for performance
        var keys = [];
        for (var key in obj)
            keys.push(key);
        return keys;
    };

    /**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */
    Common.values = function(obj) {
        var values = [];
        
        if (Object.keys) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
            }
            return values;
        }
        
        // avoid hasOwnProperty for performance
        for (var key in obj)
            values.push(obj[key]);
        return values;
    };

    /**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */
    Common.get = function(obj, path, begin, end) {
        path = path.split('.').slice(begin, end);

        for (var i = 0; i < path.length; i += 1) {
            obj = obj[path[i]];
        }

        return obj;
    };

    /**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */
    Common.set = function(obj, path, val, begin, end) {
        var parts = path.split('.').slice(begin, end);
        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
        return val;
    };

    /**
     * Returns a hex colour string made by lightening or darkening color by percent.
     * @method shadeColor
     * @param {string} color
     * @param {number} percent
     * @return {string} A hex colour
     */
    Common.shadeColor = function(color, percent) {   
        // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color
        var colorInteger = parseInt(color.slice(1),16), 
            amount = Math.round(2.55 * percent), 
            R = (colorInteger >> 16) + amount, 
            B = (colorInteger >> 8 & 0x00FF) + amount, 
            G = (colorInteger & 0x0000FF) + amount;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R :255) * 0x10000 
                + (B < 255 ? B < 1 ? 0 : B : 255) * 0x100 
                + (G < 255 ? G < 1 ? 0 : G : 255)).toString(16).slice(1);
    };

    /**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */
    Common.shuffle = function(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Common.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    };

    /**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */
    Common.choose = function(choices) {
        return choices[Math.floor(Common.random() * choices.length)];
    };

    /**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */
    Common.isElement = function(obj) {
        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
        try {
            return obj instanceof HTMLElement;
        }
        catch(e){
            return (typeof obj==="object") &&
              (obj.nodeType===1) && (typeof obj.style === "object") &&
              (typeof obj.ownerDocument ==="object");
        }
    };

    /**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */
    Common.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    /**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */
    Common.isFunction = function(obj) {
        return typeof obj === "function";
    };

    /**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */
    Common.isPlainObject = function(obj) {
        return typeof obj === 'object' && obj.constructor === Object;
    };

    /**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */
    Common.isString = function(obj) {
        return toString.call(obj) === '[object String]';
    };
    
    /**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */
    Common.clamp = function(value, min, max) {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    };
    
    /**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */
    Common.sign = function(value) {
        return value < 0 ? -1 : 1;
    };
    
    /**
     * Returns the current timestamp (high-res if available).
     * @method now
     * @return {number} the current timestamp (high-res if available)
     */
    Common.now = function() {
        // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
        // https://gist.github.com/davidwaterston/2982531

        var performance = window.performance || {};

        performance.now = (function() {
            return performance.now    ||
            performance.webkitNow     ||
            performance.msNow         ||
            performance.oNow          ||
            performance.mozNow        ||
            function() { return +(new Date()); };
        })();
              
        return performance.now();
    };
    
    /**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */
    Common.random = function(min, max) {
        min = (typeof min !== "undefined") ? min : 0;
        max = (typeof max !== "undefined") ? max : 1;
        return min + _seededRandom() * (max - min);
    };

    var _seededRandom = function() {
        // https://gist.github.com/ngryman/3830489
        Common._seed = (Common._seed * 9301 + 49297) % 233280;
        return Common._seed / 233280;
    };

    /**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */
    Common.colorToNumber = function(colorString) {
        colorString = colorString.replace('#','');

        if (colorString.length == 3) {
            colorString = colorString.charAt(0) + colorString.charAt(0)
                        + colorString.charAt(1) + colorString.charAt(1)
                        + colorString.charAt(2) + colorString.charAt(2);
        }

        return parseInt(colorString, 16);
    };

    /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */
    Common.logLevel = 1;

    /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */
    Common.log = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */
    Common.info = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */
    Common.warn = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */
    Common.nextId = function() {
        return Common._nextId++;
    };

    /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */
    Common.indexOf = function(haystack, needle) {
        if (haystack.indexOf)
            return haystack.indexOf(needle);

        for (var i = 0; i < haystack.length; i++) {
            if (haystack[i] === needle)
                return i;
        }

        return -1;
    };

    /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */
    Common.map = function(list, func) {
        if (list.map) {
            return list.map(func);
        }

        var mapped = [];

        for (var i = 0; i < list.length; i += 1) {
            mapped.push(func(list[i]));
        }

        return mapped;
    };

    /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */
    Common.topologicalSort = function(graph) {
        // https://mgechev.github.io/javascript-algorithms/graphs_others_topological-sort.js.html
        var result = [],
            visited = [],
            temp = [];

        for (var node in graph) {
            if (!visited[node] && !temp[node]) {
                _topologicalSort(node, visited, temp, graph, result);
            }
        }

        return result;
    };

    var _topologicalSort = function(node, visited, temp, graph, result) {
        var neighbors = graph[node] || [];
        temp[node] = true;

        for (var i = 0; i < neighbors.length; i += 1) {
            var neighbor = neighbors[i];

            if (temp[neighbor]) {
                // skip circular dependencies
                continue;
            }

            if (!visited[neighbor]) {
                _topologicalSort(neighbor, visited, temp, graph, result);
            }
        }

        temp[node] = false;
        visited[node] = true;

        result.push(node);
    };

    /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */
    Common.chain = function() {
        var funcs = [];

        for (var i = 0; i < arguments.length; i += 1) {
            var func = arguments[i];

            if (func._chained) {
                // flatten already chained functions
                funcs.push.apply(funcs, func._chained);
            } else {
                funcs.push(func);
            }
        }

        var chain = function() {
            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
            var lastResult,
                args = new Array(arguments.length);

            for (var i = 0, l = arguments.length; i < l; i++) {
                args[i] = arguments[i];
            }

            for (i = 0; i < funcs.length; i += 1) {
                var result = funcs[i].apply(lastResult, args);

                if (typeof result !== 'undefined') {
                    lastResult = result;
                }
            }

            return lastResult;
        };

        chain._chained = funcs;

        return chain;
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathBefore = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            func,
            Common.get(base, path)
        ));
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathAfter = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            Common.get(base, path),
            func
        ));
    };

})();


/***/ },
/* 1 */
/***/ function(module, exports) {

var Point = function (x, y)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = x; }

    this.x = x;

    this.y = y;
};

Point.prototype.constructor = Point;

Point.prototype = {

    setTo: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    }

};

module.exports = Point;


/***/ },
/* 2 */
/***/ function(module, exports) {

var CONST = {

    VERSION: '3.0.0',

    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,
    HEADLESS: 3

};

module.exports = CONST;


/***/ },
/* 3 */
/***/ function(module, exports) {

//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse

function hasGetterOrSetter (def)
{
    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');
}

function getProperty (definition, k, isClassDescriptor)
{
    //  This may be a lightweight object, OR it might be a property that was defined previously.
    
    //  For simple class descriptors we can just assume its NOT previously defined.
    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);

    if (!isClassDescriptor && def.value && typeof def.value === 'object')
    {
        def = def.value;
    }

    //  This might be a regular property, or it may be a getter/setter the user defined in a class.
    if (def && hasGetterOrSetter(def))
    {
        if (typeof def.enumerable === 'undefined')
        {
            def.enumerable = true;
        }

        if (typeof def.configurable === 'undefined')
        {
            def.configurable = true;
        }

        return def;
    }
    else
    {
        return false;
    }
}

function hasNonConfigurable (obj, k)
{
    var prop = Object.getOwnPropertyDescriptor(obj, k);

    if (!prop)
    {
        return false;
    }

    if (prop.value && typeof prop.value === 'object')
    {
        prop = prop.value;
    }

    if (prop.configurable === false)
    {
        return true;
    }

    return false;
}

function extend (ctor, definition, isClassDescriptor, extend)
{
    for (var k in definition)
    {
        if (!definition.hasOwnProperty(k))
        {
            continue;
        }

        var def = getProperty(definition, k, isClassDescriptor);

        if (def !== false)
        {
            //  If Extends is used, we will check its prototype to see if the final variable exists.
            
            var parent = extend || ctor;

            if (hasNonConfigurable(parent.prototype, k))
            {
                //  Just skip the final property
                if (Class.ignoreFinals)
                {
                    continue;
                }

                //  We cannot re-define a property that is configurable=false.
                //  So we will consider them final and throw an error. This is by
                //  default so it is clear to the developer what is happening.
                //  You can set ignoreFinals to true if you need to extend a class
                //  which has configurable=false; it will simply not re-define final properties.
                throw new Error('cannot override final property \'' + k + '\', set Class.ignoreFinals = true to skip');
            }

            Object.defineProperty(ctor.prototype, k, def);
        }
        else
        {
            ctor.prototype[k] = definition[k];
        }
    }
}

function mixin (myClass, mixins)
{
    if (!mixins)
    {
        return;
    }

    if (!Array.isArray(mixins))
    {
        mixins = [ mixins ];
    }

    for (var i = 0; i < mixins.length; i++)
    {
        extend(myClass, mixins[i].prototype || mixins[i]);
    }
}

/**
 * Creates a new class with the given descriptor.
 * The constructor, defined by the name `initialize`,
 * is an optional function. If unspecified, an anonymous
 * function will be used which calls the parent class (if
 * one exists).
 *
 * You can also use `Extends` and `Mixins` to provide subclassing
 * and inheritance.
 *
 * @class  Class
 * @constructor
 * @param {Object} definition a dictionary of functions for the class
 * @example
 *
 *      var MyClass = new Phaser.Class({
 *      
 *          initialize: function() {
 *              this.foo = 2.0;
 *          },
 *
 *          bar: function() {
 *              return this.foo + 5;
 *          }
 *      });
 */
function Class (definition)
{
    if (!definition)
    {
        definition = {};
    }

    //  The variable name here dictates what we see in Chrome debugger
    var initialize;
    var Extends;

    if (definition.initialize)
    {
        if (typeof definition.initialize !== 'function')
        {
            throw new Error('initialize must be a function');
        }

        initialize = definition.initialize;

        //  Usually we should avoid 'delete' in V8 at all costs.
        //  However, its unlikely to make any performance difference
        //  here since we only call this on class creation (i.e. not object creation).
        delete definition.initialize;
    }
    else
    {
        if (definition.Extends)
        {
            var base = definition.Extends;

            initialize = function ()
            {
                base.apply(this, arguments);
            };
        }
        else
        {
            initialize = function () {};
        }
    }

    if (definition.Extends)
    {
        initialize.prototype = Object.create(definition.Extends.prototype);
        initialize.prototype.constructor = initialize;

        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)

        Extends = definition.Extends;

        delete definition.Extends;
    }
    else
    {
        initialize.prototype.constructor = initialize;
    }

    //  Grab the mixins, if they are specified...
    var mixins = null;

    if (definition.Mixins)
    {
        mixins = definition.Mixins;
        delete definition.Mixins;
    }

    //  First, mixin if we can.
    mixin(initialize, mixins);

    //  Now we grab the actual definition which defines the overrides.
    extend(initialize, definition, true, Extends);

    return initialize;
}

Class.extend = extend;
Class.mixin = mixin;
Class.ignoreFinals = false;

module.exports = Class;


/***/ },
/* 4 */
/***/ function(module, exports) {


/**
* The GameObject Factory is a global level container of Factory instances.
* Factories register themselves with this container (when required)
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/

var factories = {};

var FactoryContainer = function ()
{
    // console.log('FactoryContainer is alive');

    this.register = function (factory)
    {
        if (factories.hasOwnProperty(factory.KEY))
        {
            // console.log('Already registered', factory.KEY);

            return this.getType(factory.KEY);
        }
        else
        {
            // console.log('registering', factory.KEY);

            factories[factory.KEY] = {
                add: factory.add,
                make: factory.make
            };

            return factory;
        }
    };

    this.getType = function (key)
    {
        return factories[key];
    };

    this.load = function (dest, isFactory)
    {
        for (var factory in factories)
        {
            if (factories.hasOwnProperty(factory))
            {
                // console.log('Loading', factory);

                dest[factory] = (isFactory) ? factories[factory].add : factories[factory].make;
            }
        }

        return dest;
    };

    return this;
};

module.exports = FactoryContainer();


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Alpha: __webpack_require__(268),
    BlendMode: __webpack_require__(269),
    Children: __webpack_require__(270),
    Color: __webpack_require__(271),
    Data: __webpack_require__(92),
    Flip: __webpack_require__(272),
    GetBounds: __webpack_require__(273),
    Origin: __webpack_require__(274),
    RenderPass: __webpack_require__(275),
    ScaleMode: __webpack_require__(276),
    Size: __webpack_require__(277),
    Texture: __webpack_require__(278),
    Transform: __webpack_require__(279),
    TransformMatrix: __webpack_require__(29),
    Visible: __webpack_require__(280)

};


/***/ },
/* 6 */
/***/ function(module, exports) {

var MATH_CONST = {

    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI

};

module.exports = MATH_CONST;


/***/ },
/* 7 */
/***/ function(module, exports) {

/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/

var Bounds = {};

module.exports = Bounds;

(function() {

    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */
    Bounds.create = function(vertices) {
        var bounds = { 
            min: { x: 0, y: 0 }, 
            max: { x: 0, y: 0 }
        };

        if (vertices)
            Bounds.update(bounds, vertices);
        
        return bounds;
    };

    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */
    Bounds.update = function(bounds, vertices, velocity) {
        bounds.min.x = Infinity;
        bounds.max.x = -Infinity;
        bounds.min.y = Infinity;
        bounds.max.y = -Infinity;

        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
        }
        
        if (velocity) {
            if (velocity.x > 0) {
                bounds.max.x += velocity.x;
            } else {
                bounds.min.x += velocity.x;
            }
            
            if (velocity.y > 0) {
                bounds.max.y += velocity.y;
            } else {
                bounds.min.y += velocity.y;
            }
        }
    };

    /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */
    Bounds.contains = function(bounds, point) {
        return point.x >= bounds.min.x && point.x <= bounds.max.x 
               && point.y >= bounds.min.y && point.y <= bounds.max.y;
    };

    /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */
    Bounds.overlaps = function(boundsA, boundsB) {
        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x
                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);
    };

    /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */
    Bounds.translate = function(bounds, vector) {
        bounds.min.x += vector.x;
        bounds.max.x += vector.x;
        bounds.min.y += vector.y;
        bounds.max.y += vector.y;
    };

    /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */
    Bounds.shift = function(bounds, position) {
        var deltaX = bounds.max.x - bounds.min.x,
            deltaY = bounds.max.y - bounds.min.y;
            
        bounds.min.x = position.x;
        bounds.max.x = position.x + deltaX;
        bounds.min.y = position.y;
        bounds.max.y = position.y + deltaY;
    };
    
})();


/***/ },
/* 8 */
/***/ function(module, exports) {

/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/

// TODO: consider params for reusing vector objects

var Vector = {};

module.exports = Vector;

(function() {

    /**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */
    Vector.create = function(x, y) {
        return { x: x || 0, y: y || 0 };
    };

    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */
    Vector.clone = function(vector) {
        return { x: vector.x, y: vector.y };
    };

    /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */
    Vector.magnitude = function(vector) {
        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
    };

    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */
    Vector.magnitudeSquared = function(vector) {
        return (vector.x * vector.x) + (vector.y * vector.y);
    };

    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @return {vector} A new vector rotated about (0, 0)
     */
    Vector.rotate = function(vector, angle) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        return {
            x: vector.x * cos - vector.y * sin,
            y: vector.x * sin + vector.y * cos
        };
    };

    /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */
    Vector.rotateAbout = function(vector, angle, point, output) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        if (!output) output = {};
        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
        output.x = x;
        return output;
    };

    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */
    Vector.normalise = function(vector) {
        var magnitude = Vector.magnitude(vector);
        if (magnitude === 0)
            return { x: 0, y: 0 };
        return { x: vector.x / magnitude, y: vector.y / magnitude };
    };

    /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */
    Vector.dot = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
    };

    /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */
    Vector.cross = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
    };

    /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */
    Vector.cross3 = function(vectorA, vectorB, vectorC) {
        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    };

    /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */
    Vector.add = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x + vectorB.x;
        output.y = vectorA.y + vectorB.y;
        return output;
    };

    /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */
    Vector.sub = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x - vectorB.x;
        output.y = vectorA.y - vectorB.y;
        return output;
    };

    /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */
    Vector.mult = function(vector, scalar) {
        return { x: vector.x * scalar, y: vector.y * scalar };
    };

    /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */
    Vector.div = function(vector, scalar) {
        return { x: vector.x / scalar, y: vector.y / scalar };
    };

    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */
    Vector.perp = function(vector, negate) {
        negate = negate === true ? -1 : 1;
        return { x: negate * -vector.y, y: negate * vector.x };
    };

    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */
    Vector.neg = function(vector) {
        return { x: -vector.x, y: -vector.y };
    };

    /**
     * Returns the angle in radians between the two vectors relative to the x-axis.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */
    Vector.angle = function(vectorA, vectorB) {
        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    };

    /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */
    Vector._temp = [
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create()
    ];

})();

/***/ },
/* 9 */
/***/ function(module, exports) {

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

var GetObjectValue = function (source, key, defaultValue)
{
    if (!source)
    {
        return defaultValue;
    }
    else if (key.indexOf('.'))
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    }
    else
    {
        return (source.hasOwnProperty(key)) ? source[key] : defaultValue;
    }
};

module.exports = GetObjectValue;


/***/ },
/* 10 */
/***/ function(module, exports) {

var Event = function (type)
{
    this.type = type;

    //  The element that initiated the event.
    this.target;

    this._propagate = true;
};

Event.prototype.constructor = Event;

Event.prototype = {

    reset: function (target)
    {
        this.target = target;

        this._propagate = true;
    },

    stopPropagation: function ()
    {
        this._propagate = false;
    }

};

module.exports = Event;


/***/ },
/* 11 */
/***/ function(module, exports) {

var FILE_CONST = {

    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_DESTROYED: 4,

    FILE_PENDING: 5,      // file is in the load queue but not yet started
    FILE_LOADING: 6,      // file has been started to load by the loader (onLoad called)
    FILE_LOADED: 7,       // file has loaded successfully, awaiting processing
    FILE_FAILED: 8,       // file failed to load
    FILE_PROCESSING: 9,   // file is being processed (onProcess callback)
    FILE_WAITING_LINKFILE: 10,   // file is being processed (onProcess callback)
    FILE_ERRORED: 11,   // file is being processed (onProcess callback)
    FILE_COMPLETE: 12,     // file has finished processing
    FILE_DESTROYED: 13,     // file has been destroyed

    TEXTURE_ATLAS_JSON_ARRAY: 20,
    TEXTURE_ATLAS_JSON_HASH: 21

};

module.exports = FILE_CONST;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Class = __webpack_require__(3);

/**
* This is the base Game Object class that you can use when creating your own extended Game Objects.
*
* @class
*/

var GameObject = new Class({

    initialize:

    function GameObject (state)
    {
        this.state = state;

        this.id = 0;
        this.name = '';

        this.parent;

        //  0001 | 0010 | 0100 | 1000
        //  Will Render bitmask flags for the components Visible, Alpha, Transform and Texture respectively
        this.renderMask = 15;
        this.renderFlags = 15;
    },

    destroy: function ()
    {
        this.parent.remove(this);

        this.state = undefined;
    }

});

module.exports = GameObject;


/***/ },
/* 13 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetBottom = function (gameObject)
{
    return (gameObject.y + gameObject.height) - (gameObject.height * gameObject.originY);
};

module.exports = GetBottom;


/***/ },
/* 14 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetLeft = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX);
};

module.exports = GetLeft;


/***/ },
/* 15 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var GetRight = function (gameObject)
{
    return (gameObject.x + gameObject.width) - (gameObject.width * gameObject.originX);
};

module.exports = GetRight;


/***/ },
/* 16 */
/***/ function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var GetTop = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY);
};

module.exports = GetTop;


/***/ },
/* 17 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetBottom = function (gameObject, value)
{
    gameObject.y = (value - gameObject.height) + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetBottom;


/***/ },
/* 18 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetLeft = function (gameObject, value)
{
    gameObject.x = value + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetLeft;


/***/ },
/* 19 */
/***/ function(module, exports) {

/**
* The left coordinate of the Game Object.
* This is the same as `x - offsetX`.
*
* @property {number} left
*/

var SetRight = function (gameObject, value)
{
    gameObject.x = (value - gameObject.width) + (gameObject.width * gameObject.originX);

    return gameObject;
};

module.exports = SetRight;


/***/ },
/* 20 */
/***/ function(module, exports) {

/**
* The y coordinate of the Game Object.
* This is the same as `y - offsetY`.
*
* @property {number} top
*/

var SetTop = function (gameObject, value)
{
    gameObject.y = value + (gameObject.height * gameObject.originY);

    return gameObject;
};

module.exports = SetTop;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var OS = {

    /**
    * @property {boolean} desktop - Is running on a desktop?
    * @default
    */
    desktop: false,

    /**
    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
    * @default
    */
    webApp: false,

    /**
    * @property {boolean} iOS - Is running on iOS?
    * @default
    */
    iOS: false,

    /**
    * @property {number} iOSVersion - If running in iOS this will contain the major version number.
    * @default
    */
    iOSVersion: 0,

    /**
    * @property {boolean} iPhone - Is running on iPhone?
    * @default
    */
    iPhone: false,

    /**
    * @property {boolean} iPad - Is running on iPad?
    * @default
    */
    iPad: false,

    /**
    * @property {boolean} cocoonJS - Is the game running under CocoonJS?
    * @default
    */
    cocoonJS: false,
    
    /**
    * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
    * @default
    */
    cocoonJSApp: false,
    
    /**
    * @property {boolean} cordova - Is the game running under Apache Cordova?
    * @default
    */
    cordova: false,
    
    /**
    * @property {boolean} node - Is the game running under Node.js?
    * @default
    */
    node: false,
    
    /**
    * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
    * @default
    */
    nodeWebkit: false,
    
    /**
    * @property {boolean} electron - Is the game running under GitHub Electron?
    * @default
    */
    electron: false,
    
    /**
    * @property {boolean} ejecta - Is the game running under Ejecta?
    * @default
    */
    ejecta: false,

    /**
    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
    * @default
    */
    crosswalk: false,

    /**
    * @property {boolean} android - Is running on android?
    * @default
    */
    android: false,

    /**
    * @property {boolean} chromeOS - Is running on chromeOS?
    * @default
    */
    chromeOS: false,

    /**
    * @property {boolean} linux - Is running on linux?
    * @default
    */
    linux: false,

    /**
    * @property {boolean} macOS - Is running on macOS?
    * @default
    */
    macOS: false,

    /**
    * @property {boolean} windows - Is running on windows?
    * @default
    */
    windows: false,

    /**
    * @property {boolean} windowsPhone - Is running on a Windows Phone?
    * @default
    */
    windowsPhone: false,

    /**
    * @property {boolean} vita - Is running on a PlayStation Vita?
    * @default
    */
    vita: false,

    /**
    * @property {boolean} kindle - Is running on an Amazon Kindle?
    * @default
    */
    kindle: false,

    /**
    * @property {number} pixelRatio - PixelRatio of the host device?
    * @default
    */
    pixelRatio: 1

};

function init ()
{
    var ua = navigator.userAgent;

    if (/Windows/.test(ua))
    {
        OS.windows = true;
    }
    else if (/Mac OS/.test(ua))
    {
        OS.macOS = true;
    }
    else if (/Linux/.test(ua))
    {
        OS.linux = true;
    }
    else if (/Android/.test(ua))
    {
        OS.android = true;
    }
    else if (/iP[ao]d|iPhone/i.test(ua))
    {
        OS.iOS = true;
        (navigator.appVersion).match(/OS (\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
    }
    else if (/Kindle/.test(ua) || (/\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua))
    {
        OS.kindle = true;

        // This will NOT detect early generations of Kindle Fire, I think there is no reliable way...
        // E.g. "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true"
    }
    else if (/CrOS/.test(ua))
    {
        OS.chromeOS = true;
    }
    else if ((/Playstation Vita/).test(ua))
    {
        OS.vita = true;
    }

    if (/Windows Phone/i.test(ua) || (/IEMobile/i).test(ua))
    {
        OS.android = false;
        OS.iOS = false;
        OS.macOS = false;
        OS.windows = true;
        OS.windowsPhone = true;
    }

    var silk = (/Silk/).test(ua);

    if (OS.windows || OS.macOS || (OS.linux && !silk) || OS.chromeOS)
    {
        OS.desktop = true;
    }

    //  Windows Phone / Table reset
    if (OS.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
    {
        OS.desktop = false;
    }

    //  WebApp mode in iOS
    if (navigator.standalone)
    {
        OS.webApp = true;
    }
    
    if (window.cordova !== undefined)
    {
        OS.cordova = true;
    }
    
    if ((typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined'))
    {
        OS.node = true;
    }
    
    if (OS.node && typeof process.versions === 'object')
    {
        OS.nodeWebkit = !!process.versions['node-webkit'];
        
        OS.electron = !!process.versions.electron;
    }
    
    if (navigator.isCocoonJS)
    {
        OS.cocoonJS = true;

        try
        {
            OS.cocoonJSApp = (typeof CocoonJS !== 'undefined');
        }
        catch (error)
        {
            OS.cocoonJSApp = false;
        }
    }

    if (window.ejecta !== undefined)
    {
        OS.ejecta = true;
    }

    if ((/Crosswalk/).test(ua))
    {
        OS.crosswalk = true;
    }

    OS.iPhone = ua.toLowerCase().indexOf('iphone') !== -1;
    OS.iPad = ua.toLowerCase().indexOf('ipad') !== -1;

    OS.pixelRatio = window['devicePixelRatio'] || 1;

    return OS;
}

module.exports = init();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(652)))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);

/**
 * The pool into which the canvas elements are placed.
 *
 * @property pool
 * @type Array
 */
var pool = [];

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games on the same page
//  can share the one single pool

/**
* The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
*
* @class Phaser.CanvasPool
* @static
*/
var CanvasPool = function ()
{
    /**
    * Creates a new Canvas DOM element, or pulls one from the pool if free.
    *
    * @method Phaser.CanvasPool.create
    * @static
    * @param {any} parent - The parent of the canvas element.
    * @param {number} width - The width of the canvas element.
    * @param {number} height - The height of the canvas element.
    * @return {HTMLCanvasElement} The canvas element.
    */
    var create = function (parent, width, height, type)
    {
        if (width === undefined) { width = 1; }
        if (height === undefined) { height = 1; }
        if (type === undefined) { type = CONST.CANVAS; }

        var canvas;
        var container = first(type);

        if (container === null)
        {
            // console.log('CanvasPool.create new');

            container = {
                parent: parent,
                canvas: document.createElement('canvas'),
                type: type
            };

            pool.push(container);

            canvas = container.canvas;
        }
        else
        {
            // console.log('CanvasPool.create existing');

            container.parent = parent;

            canvas = container.canvas;
        }

        canvas.width = width;
        canvas.height = height;
        
        return canvas;
    };

    var create2D = function (parent, width, height)
    {
        return create(parent, width, height, CONST.CANVAS);
    };

    var createWebGL = function (parent, width, height)
    {
        return create(parent, width, height, CONST.WEBGL);
    };

    /**
    * Gets the first free canvas index from the pool.
    *
    * @static
    * @method Phaser.CanvasPool.getFirst
    * @return {number}
    */
    var first = function (type)
    {
        if (type === undefined) { type = CONST.CANVAS; }

        pool.forEach(function (container)
        {
            if (!container.parent && container.type === type)
            {
                return container;
            }
        });

        return null;
    };

    /**
    * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
    * The canvas has its width and height set to 1, and its parent attribute nulled.
    * 
    * @static
    * @method Phaser.CanvasPool.remove
    * @param {any|HTMLCanvasElement} parent - The parent of the canvas element.
    */
    var remove = function (parent)
    {
        //  Check to see if the parent is a canvas object
        var isCanvas = parent instanceof HTMLCanvasElement;

        pool.forEach(function (container)
        {
            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))
            {
                // console.log('CanvasPool.remove found and removed');
                container.parent = null;
                container.canvas.width = 1;
                container.canvas.height = 1;
            }
        });
    };

    /**
    * Gets the total number of used canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getTotal
    * @return {number} The number of in-use (parented) canvas elements in the pool.
    */
    var total = function ()
    {
        var c = 0;

        pool.forEach(function (container)
        {
            if (container.parent)
            {
                c++;
            }
        });

        return c;
    };

    /**
    * Gets the total number of free canvas elements in the pool.
    * 
    * @static
    * @method Phaser.CanvasPool.getFree
    * @return {number} The number of free (un-parented) canvas elements in the pool.
    */
    var free = function ()
    {
        return pool.length - total();
    };

    return {
        create: create,
        create2D: create2D,
        createWebGL: createWebGL,
        first: first,
        remove: remove,
        total: total,
        free: free,
        pool: pool
    };
};

//  If we export the called function here, it'll only be invoked once (not every time it's required).
module.exports = CanvasPool();


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/

var Composite = {};

module.exports = Composite;

var Events = __webpack_require__(24);
var Common = __webpack_require__(0);
var Body = __webpack_require__(39);

(function() {

    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */
    Composite.create = function(options) {
        return Common.extend({ 
            id: Common.nextId(),
            type: 'composite',
            parent: null,
            isModified: false,
            bodies: [], 
            constraints: [], 
            composites: [],
            label: 'Composite',
            plugin: {}
        }, options);
    };

    /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */
    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
        composite.isModified = isModified;

        if (updateParents && composite.parent) {
            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
        }

        if (updateChildren) {
            for(var i = 0; i < composite.composites.length; i++) {
                var childComposite = composite.composites[i];
                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
            }
        }
    };

    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */
    Composite.add = function(composite, object) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeAdd', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                // skip adding compound parts
                if (obj.parent !== obj) {
                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');
                    break;
                }

                Composite.addBody(composite, obj);
                break;
            case 'constraint':
                Composite.addConstraint(composite, obj);
                break;
            case 'composite':
                Composite.addComposite(composite, obj);
                break;
            case 'mouseConstraint':
                Composite.addConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterAdd', { object: object });

        return composite;
    };

    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */
    Composite.remove = function(composite, object, deep) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeRemove', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                Composite.removeBody(composite, obj, deep);
                break;
            case 'constraint':
                Composite.removeConstraint(composite, obj, deep);
                break;
            case 'composite':
                Composite.removeComposite(composite, obj, deep);
                break;
            case 'mouseConstraint':
                Composite.removeConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterRemove', { object: object });

        return composite;
    };

    /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */
    Composite.addComposite = function(compositeA, compositeB) {
        compositeA.composites.push(compositeB);
        compositeB.parent = compositeA;
        Composite.setModified(compositeA, true, true, false);
        return compositeA;
    };

    /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */
    Composite.removeComposite = function(compositeA, compositeB, deep) {
        var position = Common.indexOf(compositeA.composites, compositeB);
        if (position !== -1) {
            Composite.removeCompositeAt(compositeA, position);
            Composite.setModified(compositeA, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < compositeA.composites.length; i++){
                Composite.removeComposite(compositeA.composites[i], compositeB, true);
            }
        }

        return compositeA;
    };

    /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */
    Composite.removeCompositeAt = function(composite, position) {
        composite.composites.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */
    Composite.addBody = function(composite, body) {
        composite.bodies.push(body);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBody = function(composite, body, deep) {
        var position = Common.indexOf(composite.bodies, body);
        if (position !== -1) {
            Composite.removeBodyAt(composite, position);
            Composite.setModified(composite, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeBody(composite.composites[i], body, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBodyAt = function(composite, position) {
        composite.bodies.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */
    Composite.addConstraint = function(composite, constraint) {
        composite.constraints.push(constraint);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraint = function(composite, constraint, deep) {
        var position = Common.indexOf(composite.constraints, constraint);
        if (position !== -1) {
            Composite.removeConstraintAt(composite, position);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeConstraint(composite.composites[i], constraint, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraintAt = function(composite, position) {
        composite.constraints.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */
    Composite.clear = function(composite, keepStatic, deep) {
        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.clear(composite.composites[i], keepStatic, true);
            }
        }
        
        if (keepStatic) {
            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });
        } else {
            composite.bodies.length = 0;
        }

        composite.constraints.length = 0;
        composite.composites.length = 0;
        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */
    Composite.allBodies = function(composite) {
        var bodies = [].concat(composite.bodies);

        for (var i = 0; i < composite.composites.length; i++)
            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));

        return bodies;
    };

    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */
    Composite.allConstraints = function(composite) {
        var constraints = [].concat(composite.constraints);

        for (var i = 0; i < composite.composites.length; i++)
            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));

        return constraints;
    };

    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */
    Composite.allComposites = function(composite) {
        var composites = [].concat(composite.composites);

        for (var i = 0; i < composite.composites.length; i++)
            composites = composites.concat(Composite.allComposites(composite.composites[i]));

        return composites;
    };

    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */
    Composite.get = function(composite, id, type) {
        var objects,
            object;

        switch (type) {
        case 'body':
            objects = Composite.allBodies(composite);
            break;
        case 'constraint':
            objects = Composite.allConstraints(composite);
            break;
        case 'composite':
            objects = Composite.allComposites(composite).concat(composite);
            break;
        }

        if (!objects)
            return null;

        object = objects.filter(function(object) { 
            return object.id.toString() === id.toString(); 
        });

        return object.length === 0 ? null : object[0];
    };

    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */
    Composite.move = function(compositeA, objects, compositeB) {
        Composite.remove(compositeA, objects);
        Composite.add(compositeB, objects);
        return compositeA;
    };

    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */
    Composite.rebase = function(composite) {
        var objects = Composite.allBodies(composite)
                        .concat(Composite.allConstraints(composite))
                        .concat(Composite.allComposites(composite));

        for (var i = 0; i < objects.length; i++) {
            objects[i].id = Common.nextId();
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */
    Composite.translate = function(composite, translation, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            Body.translate(bodies[i], translation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.rotate = function(composite, rotation, point, recursive) {
        var cos = Math.cos(rotation),
            sin = Math.sin(rotation),
            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
            });

            Body.rotate(body, rotation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + dx * scaleX,
                y: point.y + dy * scaleY
            });

            Body.scale(body, scaleX, scaleY);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a call to `Composite.add` is made, before objects have been added.
    *
    * @event beforeAdd
    * @param {} event An event object
    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.add` is made, after objects have been added.
    *
    * @event afterAdd
    * @param {} event An event object
    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, before objects have been removed.
    *
    * @event beforeRemove
    * @param {} event An event object
    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, after objects have been removed.
    *
    * @event afterRemove
    * @param {} event An event object
    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "composite"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage composites.
     *
     * @property label
     * @type string
     * @default "Composite"
     */

    /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
     * If you need to change it manually, you should use the `Composite.setModified` method.
     *
     * @property isModified
     * @type boolean
     * @default false
     */

    /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     *
     * @property parent
     * @type composite
     * @default null
     */

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     *
     * @property bodies
     * @type body[]
     * @default []
     */

    /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     *
     * @property constraints
     * @type constraint[]
     * @default []
     */

    /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     *
     * @property composites
     * @type composite[]
     * @default []
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/

var Events = {};

module.exports = Events;

var Common = __webpack_require__(0);

(function() {

    /**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.on = function(object, eventNames, callback) {
        var names = eventNames.split(' '),
            name;

        for (var i = 0; i < names.length; i++) {
            name = names[i];
            object.events = object.events || {};
            object.events[name] = object.events[name] || [];
            object.events[name].push(callback);
        }

        return callback;
    };

    /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.off = function(object, eventNames, callback) {
        if (!eventNames) {
            object.events = {};
            return;
        }

        // handle Events.off(object, callback)
        if (typeof eventNames === 'function') {
            callback = eventNames;
            eventNames = Common.keys(object.events).join(' ');
        }

        var names = eventNames.split(' ');

        for (var i = 0; i < names.length; i++) {
            var callbacks = object.events[names[i]],
                newCallbacks = [];

            if (callback && callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                }
            }

            object.events[names[i]] = newCallbacks;
        }
    };

    /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */
    Events.trigger = function(object, eventNames, event) {
        var names,
            name,
            callbacks,
            eventClone;

        if (object.events) {
            if (!event)
                event = {};

            names = eventNames.split(' ');

            for (var i = 0; i < names.length; i++) {
                name = names[i];
                callbacks = object.events[name];

                if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;

                    for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                    }
                }
            }
        }
    };

})();


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/

var Vertices = {};

module.exports = Vertices;

var Vector = __webpack_require__(8);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */
    Vertices.create = function(points, body) {
        var vertices = [];

        for (var i = 0; i < points.length; i++) {
            var point = points[i],
                vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body: body,
                    isInternal: false
                };

            vertices.push(vertex);
        }

        return vertices;
    };

    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */
    Vertices.fromPath = function(path, body) {
        var pathPattern = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,
            points = [];

        path.replace(pathPattern, function(match, x, y) {
            points.push({ x: parseFloat(x), y: parseFloat(y) });
        });

        return Vertices.create(points, body);
    };

    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */
    Vertices.centre = function(vertices) {
        var area = Vertices.area(vertices, true),
            centre = { x: 0, y: 0 },
            cross,
            temp,
            j;

        for (var i = 0; i < vertices.length; i++) {
            j = (i + 1) % vertices.length;
            cross = Vector.cross(vertices[i], vertices[j]);
            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
            centre = Vector.add(centre, temp);
        }

        return Vector.div(centre, 6 * area);
    };

    /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */
    Vertices.mean = function(vertices) {
        var average = { x: 0, y: 0 };

        for (var i = 0; i < vertices.length; i++) {
            average.x += vertices[i].x;
            average.y += vertices[i].y;
        }

        return Vector.div(average, vertices.length);
    };

    /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */
    Vertices.area = function(vertices, signed) {
        var area = 0,
            j = vertices.length - 1;

        for (var i = 0; i < vertices.length; i++) {
            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
            j = i;
        }

        if (signed)
            return area / 2;

        return Math.abs(area) / 2;
    };

    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */
    Vertices.inertia = function(vertices, mass) {
        var numerator = 0,
            denominator = 0,
            v = vertices,
            cross,
            j;

        // find the polygon's moment of inertia, using second moment of area
        // http://www.physicsforums.com/showthread.php?t=25293
        for (var n = 0; n < v.length; n++) {
            j = (n + 1) % v.length;
            cross = Math.abs(Vector.cross(v[j], v[n]));
            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
            denominator += cross;
        }

        return (mass / 6) * (numerator / denominator);
    };

    /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */
    Vertices.translate = function(vertices, vector, scalar) {
        var i;
        if (scalar) {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x * scalar;
                vertices[i].y += vector.y * scalar;
            }
        } else {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x;
                vertices[i].y += vector.y;
            }
        }

        return vertices;
    };

    /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */
    Vertices.rotate = function(vertices, angle, point) {
        if (angle === 0)
            return;

        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                dx = vertice.x - point.x,
                dy = vertice.y - point.y;
                
            vertice.x = point.x + (dx * cos - dy * sin);
            vertice.y = point.y + (dx * sin + dy * cos);
        }

        return vertices;
    };

    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */
    Vertices.contains = function(vertices, point) {
        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                nextVertice = vertices[(i + 1) % vertices.length];
            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                return false;
            }
        }

        return true;
    };

    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */
    Vertices.scale = function(vertices, scaleX, scaleY, point) {
        if (scaleX === 1 && scaleY === 1)
            return vertices;

        point = point || Vertices.centre(vertices);

        var vertex,
            delta;

        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            delta = Vector.sub(vertex, point);
            vertices[i].x = point.x + delta.x * scaleX;
            vertices[i].y = point.y + delta.y * scaleY;
        }

        return vertices;
    };

    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */
    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
        radius = radius || [8];

        if (!radius.length)
            radius = [radius];

        // quality defaults to -1, which is auto
        quality = (typeof quality !== 'undefined') ? quality : -1;
        qualityMin = qualityMin || 2;
        qualityMax = qualityMax || 14;

        var newVertices = [];

        for (var i = 0; i < vertices.length; i++) {
            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],
                vertex = vertices[i],
                nextVertex = vertices[(i + 1) % vertices.length],
                currentRadius = radius[i < radius.length ? i : radius.length - 1];

            if (currentRadius === 0) {
                newVertices.push(vertex);
                continue;
            }

            var prevNormal = Vector.normalise({ 
                x: vertex.y - prevVertex.y, 
                y: prevVertex.x - vertex.x
            });

            var nextNormal = Vector.normalise({ 
                x: nextVertex.y - vertex.y, 
                y: vertex.x - nextVertex.x
            });

            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),
                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),
                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),
                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));

            var precision = quality;

            if (quality === -1) {
                // automatically decide precision
                precision = Math.pow(currentRadius, 0.32) * 1.75;
            }

            precision = Common.clamp(precision, qualityMin, qualityMax);

            // use an even value for precision, more likely to reduce axes by using symmetry
            if (precision % 2 === 1)
                precision += 1;

            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),
                theta = alpha / precision;

            for (var j = 0; j < precision; j++) {
                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
            }
        }

        return newVertices;
    };

    /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */
    Vertices.clockwiseSort = function(vertices) {
        var centre = Vertices.mean(vertices);

        vertices.sort(function(vertexA, vertexB) {
            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
        });

        return vertices;
    };

    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */
    Vertices.isConvex = function(vertices) {
        // http://paulbourke.net/geometry/polygonmesh/

        var flag = 0,
            n = vertices.length,
            i,
            j,
            k,
            z;

        if (n < 3)
            return null;

        for (i = 0; i < n; i++) {
            j = (i + 1) % n;
            k = (i + 2) % n;
            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);

            if (z < 0) {
                flag |= 1;
            } else if (z > 0) {
                flag |= 2;
            }

            if (flag === 3) {
                return false;
            }
        }

        if (flag !== 0){
            return true;
        } else {
            return null;
        }
    };

    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */
    Vertices.hull = function(vertices) {
        // http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain

        var upper = [],
            lower = [], 
            vertex,
            i;

        // sort vertices on x-axis (y-axis for ties)
        vertices = vertices.slice(0);
        vertices.sort(function(vertexA, vertexB) {
            var dx = vertexA.x - vertexB.x;
            return dx !== 0 ? dx : vertexA.y - vertexB.y;
        });

        // build lower hull
        for (i = 0; i < vertices.length; i++) {
            vertex = vertices[i];

            while (lower.length >= 2 
                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                lower.pop();
            }

            lower.push(vertex);
        }

        // build upper hull
        for (i = vertices.length - 1; i >= 0; i--) {
            vertex = vertices[i];

            while (upper.length >= 2 
                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                upper.pop();
            }

            upper.push(vertex);
        }

        // concatenation of the lower and upper hulls gives the convex hull
        // omit last points because they are repeated at the beginning of the other list
        upper.pop();
        lower.pop();

        return upper.concat(lower);
    };

})();


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

var EventBinding = __webpack_require__(291);

var EventDispatcher = function ()
{
    this.bindings = {};
    this.filters = [];
    this.hasFilters = false;
};

EventDispatcher.prototype.constructor = EventDispatcher;

EventDispatcher.prototype = {

    getBinding: function (type)
    {
        if (this.bindings.hasOwnProperty(type))
        {
            return this.bindings[type];
        }
    },

    createBinding: function (type)
    {
        if (!this.getBinding(type))
        {
            this.bindings[type] = new EventBinding(this, type);
        }

        return this.bindings[type];
    },

    on: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, false);
        }

        return this;
    },

    once: function (type, listener, priority)
    {
        if (priority === undefined) { priority = 0; }

        var binding = this.createBinding(type);

        if (binding)
        {
            binding.add(listener, priority, true);
        }

        return this;
    },

    //  Add a callback that is notified every time this EventDispatcher dispatches an event
    //  no matter what the event type is. Filters are invoked first, before any bindings,
    //  and can stop events if they wish (in which case they'll never reach the bindings)
    filter: function (callback)
    {
        var i = this.filters.indexOf(callback);

        if (i === -1)
        {
            //  Add the filter
            this.filters.push(callback);
        }
        else
        {
            //  Remove the filter
            this.filters.splice(i, 1);
        }
        
        this.hasFilters = (this.filters.length > 0);

        return this;
    },

    has: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.has(listener);
        }
        else
        {
            return false;
        }
    },

    total: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            return binding.total();
        }
    },

    //  Removes an event listener.
    //  If there is no matching listener registered with the EventDispatcher, a call to this method has no effect.
    off: function (type, listener)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.remove(listener);
        }

        return this;
    },

    _dispatchHandler: function (event)
    {
        event.reset(this);

        //  Pass the event through the filters first

        if (this.hasFilters)
        {
            for (var i = 0; i < this.filters.length; i++)
            {
                this.filters[i].call(this, event);

                //  Did the filter kill the event? If so, we can abort now
                if (!event._propagate)
                {
                    return;
                }
            }
        }

        var binding = this.getBinding(event.type);

        if (binding)
        {
            binding.dispatch(event);
        }
    },

    dispatch: function (event)
    {
        if (Array.isArray(event))
        {
            for (var i = 0; i < event.length; i++)
            {
                this._dispatchHandler(event[i]);
            }
        }
        else
        {
            this._dispatchHandler(event);
        }
    },

    //  Removes all listeners, but retains the event type entries
    removeAll: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.removeAll();
        }

        return this;
    },

    removeAllFilters: function ()
    {
        this.filters.length = 0;

        this.hasFilters = false;

        return this;
    },

    delete: function (type)
    {
        var binding = this.getBinding(type);

        if (binding)
        {
            binding.destroy();

            delete this.bindings[type];
        }

        return this;
    },

    deleteAll: function ()
    {
        for (var binding in this.bindings)
        {
            binding.destroy();
        }

        this.bindings = {};
    },

    destroy: function ()
    {
        this.deleteAll();
        this.removeAllFilters();
    }

};

module.exports = EventDispatcher;


/***/ },
/* 27 */
/***/ function(module, exports) {


//  Encapsulates a 2D rectangle defined by its corner point in the top-left
//  and its extends in x (width) and y (height)

var Rectangle = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Rectangle.prototype.constructor = Rectangle;

Rectangle.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  TOP
    getLineA: function ()
    {
        return { x1: this.x, y1: this.y, x2: this.right, y2: this.y };
    },

    //  RIGHT
    getLineB: function ()
    {
        return { x1: this.right, y1: this.y, x2: this.right, y2: this.bottom };
    },

    //  BOTTOM
    getLineC: function ()
    {
        return { x1: this.right, y1: this.bottom, x2: this.x, y2: this.bottom };
    },

    //  LEFT
    getLineD: function ()
    {
        return { x1: this.x, y1: this.bottom, x2: this.x, y2: this.y };
    }

};

Object.defineProperties(Rectangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    },

    centerX: {

        enumerable: true,

        get: function ()
        {
            return this.x + (this.width / 2);
        },

        set: function (value)
        {
            this.x = value - (this.width / 2);
        }

    },

    centerY: {

        enumerable: true,

        get: function ()
        {
            return this.y + (this.height / 2);
        },

        set: function (value)
        {
            this.y = value - (this.height / 2);
        }

    }

});

module.exports = Rectangle;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

var GetURL = __webpack_require__(496);
var CONST = __webpack_require__(11);
var XHRLoader = __webpack_require__(497);
var XHRSettings = __webpack_require__(72);
var MergeXHRSettings = __webpack_require__(159);

var File = function (type, key, url, responseType, xhrSettings, config)
{
    //  file type (image, json, etc) for sorting within the Loader
    this.type = type;

    //  unique cache key (unique within its file type)
    this.key = key;

    //  The URL of the file, not including baseURL
    this.url = url;

    //  Set when the Loader calls 'load' on this file
    this.src = '';

    this.xhrSettings = XHRSettings(responseType);

    if (xhrSettings)
    {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, xhrSettings);
    }

    this.xhrLoader = null;

    this.state = CONST.FILE_PENDING;

    //  Set by onProgress (only if loading via XHR)
    this.bytesTotal = 0;
    this.bytesLoaded = -1;
    this.percentComplete = -1;

    //  For CORs based loading.
    //  If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
    this.crossOrigin = undefined;

    //  The actual processed file data
    this.data = undefined;

    //  A config object that can be used by file types to store transitional data
    this.config = config || {};

    //  Multipart file? (i.e. an atlas and its json together)
    this.linkFile = undefined;
    this.linkType = '';

    this.callback = null;
};

File.prototype.constructor = File;

File.prototype = {

    resetXHR: function ()
    {
        this.xhrLoader.onload = undefined;
        this.xhrLoader.onerror = undefined;
        this.xhrLoader.onprogress = undefined;
    },

    //  Called when the Image loads
    //  ProgressEvent
    onLoad: function (event)
    {
        this.resetXHR();

        this.callback(this, true);
    },

    onError: function (event)
    {
        this.resetXHR();

        this.callback(this, false);
    },

    onProgress: function (event)
    {
        if (event.lengthComputable)
        {
            this.bytesLoaded = event.loaded;
            this.bytesTotal = event.total;

            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);
        }

        // console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');
    },

    onProcess: function (callback)
    {
        this.state = CONST.FILE_PROCESSING;

        this.onComplete();

        callback(this);
    },

    onComplete: function ()
    {
        if (this.linkFile)
        {
            if (this.linkFile.state === CONST.FILE_WAITING_LINKFILE)
            {
                //  The linkfile has finished processing, and is waiting for this file, so let's do them both
                this.state = CONST.FILE_COMPLETE;
                this.linkFile.state = CONST.FILE_COMPLETE;
            }
            else
            {
                //  The linkfile still hasn't finished loading and/or processing yet
                this.state = CONST.FILE_WAITING_LINKFILE;
            }
        }
        else
        {
            this.state = CONST.FILE_COMPLETE;
        }
    },

    //  Called by the Loader, starts the actual file downloading
    load: function (callback, baseURL, globalXHR)
    {
        if (baseURL === undefined) { baseURL = ''; }

        this.callback = callback;

        this.src = GetURL(this, baseURL);

        if (this.src.indexOf('data:') === 0)
        {
            console.log('Local data URI');
        }
        else
        {
            this.xhrLoader = XHRLoader(this, globalXHR);
        }
    }
};

module.exports = File;


/***/ },
/* 29 */
/***/ function(module, exports) {

var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAcos = Math.acos;
var mathAtan = Math.atan;

var TransformMatrix = function (a, b, c, d, tx, ty) 
{
    a = typeof a === 'number' ? a : 1;
    b = typeof b === 'number' ? b : 0;
    c = typeof c === 'number' ? c : 0;
    d = typeof d === 'number' ? d : 1;
    tx = typeof tx === 'number' ? tx : 0;
    ty = typeof ty === 'number' ? ty : 0;

    this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
    this.decomposedMatrix = {
        translateX: 0,
        translateY: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0
    };
};

TransformMatrix.prototype.loadIdentity = function ()
{
    var matrix = this.matrix;
    
    matrix[0] = 1;
    matrix[1] = 0;
    matrix[2] = 0;
    matrix[3] = 1;
    matrix[4] = 0;
    matrix[5] = 0;

    return this;
};

TransformMatrix.prototype.translate = function (x, y)
{
    var matrix = this.matrix;

    matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
    matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];

    return this;
};

TransformMatrix.prototype.scale = function (x, y)
{
    var matrix = this.matrix;

    matrix[0] = matrix[0] * x;
    matrix[1] = matrix[1] * x;
    matrix[2] = matrix[2] * y;
    matrix[3] = matrix[3] * y;

    return this;
};

TransformMatrix.prototype.rotate = function (radian)
{
    var radianSin = mathSin(radian);
    var radianCos = mathCos(radian);

    return this.transform(radianCos, -radianSin, radianSin, radianCos, 0, 0);
};

TransformMatrix.prototype.multiply = function (otherMatrix)
{
    var matrix = this.matrix;
    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];
    var a1 = otherMatrix[0];
    var b1 = otherMatrix[1];
    var c1 = otherMatrix[2];
    var d1 = otherMatrix[3];
    var tx1 = otherMatrix[4];
    var ty1 = otherMatrix[5];

    matrix[0] = a1 * a0 + b1 * c0;
    matrix[1] = a1 * b0 + b1 * d0;
    matrix[2] = c1 * a0 + d1 * c0;
    matrix[3] = c1 * b0 + d1 * d0;
    matrix[4] = tx1 * a0 + ty1 * c0 + tx0;
    matrix[5] = tx1 * b0 + ty1 * d0 + ty0;

    return this;
};

TransformMatrix.prototype.transform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;
    var a0 = matrix[0];
    var b0 = matrix[1];
    var c0 = matrix[2];
    var d0 = matrix[3];
    var tx0 = matrix[4];
    var ty0 = matrix[5];

    matrix[0] = a * a0 + b * c0;
    matrix[1] = a * b0 + b * d0;
    matrix[2] = c * a0 + d * c0;
    matrix[3] = c * b0 + d * d0;
    matrix[4] = tx * a0 + ty * c0 + tx0;
    matrix[5] = tx * b0 + ty * d0 + ty0;

    return this;
};

TransformMatrix.prototype.setTransform = function (a, b, c, d, tx, ty)
{
    var matrix = this.matrix;

    matrix[0] = a;
    matrix[1] = b;
    matrix[2] = c;
    matrix[3] = d;
    matrix[4] = tx;
    matrix[5] = ty;

    return this;
};

TransformMatrix.prototype.decomposeMatrix = function ()
{
    var decomposedMatrix = this.decomposedMatrix;
    var matrix = this.matrix;
    var a = matrix[0];
    var b = matrix[1];
    var c = matrix[2];
    var d = matrix[3];
    var a2 = a * a;
    var b2 = b * b;
    var c2 = c * c;
    var d2 = d * d;
    var sx = mathSqrt(a2 + c2);
    var sy = mathSqrt(b2 + d2);

    decomposedMatrix.translateX = matrix[4];
    decomposedMatrix.translateY = matrix[5];
    decomposedMatrix.scaleX = sx;
    decomposedMatrix.scaleY = sy;
    decomposedMatrix.rotation = mathAcos(a / sx) * (mathAtan(-c / a) < 0 ? -1 : 1);

    return decomposedMatrix;
};

/* identity + translate + rotate + scale */
TransformMatrix.prototype.applyITRS = function (x, y, rotation, scaleX, scaleY) 
{
    var matrix = this.matrix;
    var a = 1;
    var b = 0;
    var c = 0;
    var d = 1;
    var e = 0;
    var f = 0;
    var sr = mathSin(rotation);
    var cr = mathCos(rotation);

    // Translate
    matrix[4] = a * x + c * y + e;
    matrix[5] = b * x + d * y + f;

    // Rotate
    matrix[0] = cr * a + -sr * c;
    matrix[1] = cr * b + -sr * d;
    matrix[2] = sr * a + cr * c;
    matrix[3] = sr * b + cr * d;

    // Scale
    matrix[0] = matrix[0] * scaleX;
    matrix[1] = matrix[1] * scaleX;
    matrix[2] = matrix[2] * scaleY;
    matrix[3] = matrix[3] * scaleY;

    return this;
};

module.exports = TransformMatrix;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);

var Browser = {

    /**
    * @property {boolean} arora - Set to true if running in Arora.
    * @default
    */
    arora: false,

    /**
    * @property {boolean} chrome - Set to true if running in Chrome.
    * @default
    */
    chrome: false,

    /**
    * @property {number} chromeVersion - If running in Chrome this will contain the major version number.
    * @default
    */
    chromeVersion: 0,

    /**
    * @property {boolean} epiphany - Set to true if running in Epiphany.
    * @default
    */
    epiphany: false,

    /**
    * @property {boolean} firefox - Set to true if running in Firefox.
    * @default
    */
    firefox: false,

    /**
    * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.
    * @default
    */
    firefoxVersion: 0,

    /**
    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
    * @default
    */
    mobileSafari: false,

    /**
    * @property {boolean} ie - Set to true if running in Internet Explorer.
    * @default
    */
    ie: false,

    /**
    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
    * @default
    */
    ieVersion: 0,

    /**
    * @property {boolean} midori - Set to true if running in Midori.
    * @default
    */
    midori: false,

    /**
    * @property {boolean} opera - Set to true if running in Opera.
    * @default
    */
    opera: false,

    /**
    * @property {boolean} safari - Set to true if running in Safari.
    * @default
    */
    safari: false,

    /**
    * @property {number} safariVersion - If running in Safari this will contain the major version number.
    * @default
    */
    safariVersion: 0,

    /**
    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
    * @default
    */
    trident: false,

    /**
    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
    * @default
    */
    tridentVersion: 0,

    /**
    * @property {boolean} edge - Set to true if running in Microsoft Edge browser.
    * @default
    */
    edge: false,

    /**
    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
    * @default
    */
    silk: false

};

function init ()
{
    var ua = navigator.userAgent;

    if ((/Arora/).test(ua))
    {
        Browser.arora = true;
    }
    else if (/Edge\/\d+/.test(ua))
    {
        Browser.edge = true;
    }
    else if ((/Chrome\/(\d+)/).test(ua) && !OS.windowsPhone)
    {
        Browser.chrome = true;
        Browser.chromeVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Epiphany/).test(ua))
    {
        Browser.epiphany = true;
    }
    else if ((/Firefox\D+(\d+)/).test(ua))
    {
        Browser.firefox = true;
        Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/AppleWebKit/).test(ua) && OS.iOS)
    {
        Browser.mobileSafari = true;
    }
    else if ((/MSIE (\d+\.\d+);/).test(ua))
    {
        Browser.ie = true;
        Browser.ieVersion = parseInt(RegExp.$1, 10);
    }
    else if ((/Midori/).test(ua))
    {
        Browser.midori = true;
    }
    else if ((/Opera/).test(ua))
    {
        Browser.opera = true;
    }
    else if ((/Safari/).test(ua) && !OS.windowsPhone)
    {
        Browser.safari = true;
    }
    else if ((/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/).test(ua))
    {
        Browser.ie = true;
        Browser.trident = true;
        Browser.tridentVersion = parseInt(RegExp.$1, 10);
        Browser.ieVersion = parseInt(RegExp.$3, 10);
    }

    //  Silk gets its own if clause because its ua also contains 'Safari'
    if ((/Silk/).test(ua))
    {
        Browser.silk = true;
    }

    return Browser;
}

module.exports = init();


/***/ },
/* 31 */
/***/ function(module, exports) {

var Angle = function (line)
{
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
};

module.exports = Angle;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(70);
var GetColor32 = __webpack_require__(147);

var Color = function (red, green, blue, alpha)
{
    if (red === undefined) { red = 0; }
    if (green === undefined) { green = 0; }
    if (blue === undefined) { blue = 0; }
    if (alpha === undefined) { alpha = 255; }

    //  All private
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 255;

    this.gl = [ 0.0, 0.0, 0.0, 1.0 ];

    this._color = 0;
    this._color32 = 0;
    this._rgba = '';

    this.dirty = true;

    this.setTo(red, green, blue, alpha);
};

Color.prototype.contrusctor = Color;

Color.prototype = {

    transparent: function ()
    {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 255
    setTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 255; }

        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;

        this.dirty = true;

        return this.update();
    },

    //  Values are in the range 0 to 1
    setGLTo: function (red, green, blue, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.redGL = red;
        this.greenGL = green;
        this.blueGL = blue;
        this.alphaGL = alpha;

        this.dirty = true;

        return this.update();
    },

    setFromRGB: function (color)
    {
        this.red = color.r;
        this.green = color.g;
        this.blue = color.b;

        if (color.hasOwnProperty('a'))
        {
            this.alpha = color.a;
        }

        this.dirty = true;

        return this.update();
    },

    update: function ()
    {
        if (!this.dirty)
        {
            return this;
        }

        this._color = GetColor(this.r, this.g, this.b);
        this._color32 = GetColor32(this.r, this.g, this.b, this.a);
        this._rgba = 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + (255 / this.a) + ')';

        this.dirty = false;

        return this;
    },

    //  Same as setRGB but performs safety checks on all the values given
    clone: function ()
    {
        return new Color(this.r, this.g, this.b, this.a);
    }

};

Object.defineProperties(Color.prototype, {

    color: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color;
        }

    },

    color32: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._color32;
        }

    },

    rgba: {

        enumerable: true,

        get: function ()
        {
            if (this.dirty)
            {
                this.update();
            }

            return this._rgba;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 1 range
    redGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[0];
        },

        set: function (value)
        {
            this.gl[0] = Math.min(Math.abs(value), 1);

            this.r = Math.floor(this.gl[0] * 255);

            this.dirty = true;
        }

    },

    greenGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[1];
        },

        set: function (value)
        {
            this.gl[1] = Math.min(Math.abs(value), 1);

            this.g = Math.floor(this.gl[1] * 255);

            this.dirty = true;
        }

    },

    blueGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[2];
        },

        set: function (value)
        {
            this.gl[2] = Math.min(Math.abs(value), 1);

            this.b = Math.floor(this.gl[2] * 255);

            this.dirty = true;
        }

    },

    alphaGL: {

        enumerable: true,

        get: function ()
        {
            return this.gl[3];
        },

        set: function (value)
        {
            this.gl[3] = Math.min(Math.abs(value), 1);

            this.a = Math.floor(this.gl[3] * 255);

            this.dirty = true;
        }

    },

    //  Gets and sets the red value, normalized to the 0 to 255 range
    red: {

        enumerable: true,

        get: function ()
        {
            return this.r;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.r = Math.min(value, 255);

            this.gl[0] = value / 255;

            this.dirty = true;
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this.g;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.g = Math.min(value, 255);

            this.gl[1] = value / 255;

            this.dirty = true;
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this.b;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.b = Math.min(value, 255);

            this.gl[2] = value / 255;

            this.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this.a;
        },

        set: function (value)
        {
            value = Math.floor(Math.abs(value));

            this.a = Math.min(value, 255);

            this.gl[3] = value / 255;

            this.dirty = true;
        }

    },

});


module.exports = Color;


/***/ },
/* 33 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterX = function (gameObject)
{
    return gameObject.x - (gameObject.width * gameObject.originX) + (gameObject.width * 0.5);
};

module.exports = GetCenterX;


/***/ },
/* 34 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var GetCenterY = function (gameObject)
{
    return gameObject.y - (gameObject.height * gameObject.originY) + (gameObject.height * 0.5);
};

module.exports = GetCenterY;


/***/ },
/* 35 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterX = function (gameObject, x)
{
    var offsetX = gameObject.width * gameObject.originX;

    gameObject.x = (x + offsetX) - (gameObject.width * 0.5);

    return gameObject;
};

module.exports = SetCenterX;


/***/ },
/* 36 */
/***/ function(module, exports) {

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

//  Phaser.Utils.Bounds.GetCenterX(bob)
//  Phaser.Utils.Bounds.CenterOn(bob, x, y)
//  Phaser.Utils.Bounds.CenterX(bob, x)
//  Phaser.Utils.Bounds.CenterY(bob, x)

var SetCenterY = function (gameObject, y)
{
    var offsetY = gameObject.height * gameObject.originY;

    gameObject.y = (y + offsetY) - (gameObject.height * 0.5);

    return gameObject;
};

module.exports = SetCenterY;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var ImageFile = function (key, url, path, xhrSettings, config)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.image\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.png';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'image', key, url, 'blob', xhrSettings, config);
};

ImageFile.prototype = Object.create(File.prototype);
ImageFile.prototype.constructor = ImageFile;

ImageFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.state = CONST.FILE_ERRORED;

        callback(_this);
    };

    this.data.src = URL.createObjectURL(this.xhrLoader.response);
};

module.exports = ImageFile;


/***/ },
/* 38 */
/***/ function(module, exports) {

// A triangle is a plane created by connecting three points.
// The first two arguments specify the first point, the middle two arguments
// specify the second point, and the last two arguments specify the third point.

var Triangle = function (x1, y1, x2, y2, x3, y3)
{
    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;

    this.setTo(x1, y1, x2, y2, x3, y3);
};

Triangle.prototype.constructor = Triangle;

Triangle.prototype = {

    setTo: function (x1, y1, x2, y2, x3, y3)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }
        if (x3 === undefined) { x3 = 0; }
        if (y3 === undefined) { y3 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        this.x3 = x3;
        this.y3 = y3;

        return this;
    },

    getLineA: function ()
    {
        return { x1: this.x1, y1: this.y1, x2: this.x2, y2: this.y2 };
    },

    getLineB: function ()
    {
        return { x1: this.x2, y1: this.y2, x2: this.x3, y2: this.y3 };
    },

    getLineC: function ()
    {
        return { x1: this.x3, y1: this.y3, x2: this.x1, y2: this.y1 };
    }

};

Object.defineProperties(Triangle.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 <= this.x2 && this.x1 <= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 <= this.x1 && this.x2 <= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2, this.x3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.x1 >= this.x2 && this.x1 >= this.x3)
            {
                diff = this.x1 - value;
            }
            else if (this.x2 >= this.x1 && this.x2 >= this.x3)
            {
                diff = this.x2 - value;
            }
            else
            {
                diff = this.x3 - value;
            }

            this.x1 -= diff;
            this.x2 -= diff;
            this.x3 -= diff;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 <= this.y2 && this.y1 <= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 <= this.y1 && this.y2 <= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2, this.y3);
        },

        set: function (value)
        {
            var diff = 0;

            if (this.y1 >= this.y2 && this.y1 >= this.y3)
            {
                diff = this.y1 - value;
            }
            else if (this.y2 >= this.y1 && this.y2 >= this.y3)
            {
                diff = this.y2 - value;
            }
            else
            {
                diff = this.y3 - value;
            }

            this.y1 -= diff;
            this.y2 -= diff;
            this.y3 -= diff;
        }

    }

});

module.exports = Triangle;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/

var Body = {};

module.exports = Body;

var Vertices = __webpack_require__(25);
var Vector = __webpack_require__(8);
var Sleeping = __webpack_require__(41);
var Render = __webpack_require__(82);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(7);
var Axes = __webpack_require__(81);

(function() {

    Body._inertiaScale = 4;
    Body._nextCollidingGroupId = 1;
    Body._nextNonCollidingGroupId = -1;
    Body._nextCategory = 0x0001;

    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */
    Body.create = function(options) {
        var defaults = {
            id: Common.nextId(),
            type: 'body',
            label: 'Body',
            parts: [],
            plugin: {},
            angle: 0,
            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
            position: { x: 0, y: 0 },
            force: { x: 0, y: 0 },
            torque: 0,
            positionImpulse: { x: 0, y: 0 },
            constraintImpulse: { x: 0, y: 0, angle: 0 },
            totalContacts: 0,
            speed: 0,
            angularSpeed: 0,
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            isSensor: false,
            isStatic: false,
            isSleeping: false,
            motion: 0,
            sleepThreshold: 60,
            density: 0.001,
            restitution: 0,
            friction: 0.1,
            frictionStatic: 0.5,
            frictionAir: 0.01,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            },
            slop: 0.05,
            timeScale: 1,
            render: {
                visible: true,
                opacity: 1,
                sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                },
                lineWidth: 0
            }
        };

        var body = Common.extend(defaults, options);

        _initProperties(body, options);

        return body;
    };

    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */
    Body.nextGroup = function(isNonColliding) {
        if (isNonColliding)
            return Body._nextNonCollidingGroupId--;

        return Body._nextCollidingGroupId++;
    };

    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */
    Body.nextCategory = function() {
        Body._nextCategory = Body._nextCategory << 1;
        return Body._nextCategory;
    };

    /**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */
    var _initProperties = function(body, options) {
        options = options || {};

        // init required properties (order is important)
        Body.set(body, {
            bounds: body.bounds || Bounds.create(body.vertices),
            positionPrev: body.positionPrev || Vector.clone(body.position),
            anglePrev: body.anglePrev || body.angle,
            vertices: body.vertices,
            parts: body.parts || [body],
            isStatic: body.isStatic,
            isSleeping: body.isSleeping,
            parent: body.parent || body
        });

        Vertices.rotate(body.vertices, body.angle, body.position);
        Axes.rotate(body.axes, body.angle);
        Bounds.update(body.bounds, body.vertices, body.velocity);

        // allow options to override the automatically calculated properties
        Body.set(body, {
            axes: options.axes || body.axes,
            area: options.area || body.area,
            mass: options.mass || body.mass,
            inertia: options.inertia || body.inertia
        });

        // render properties
        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),
            defaultStrokeStyle = Common.shadeColor(defaultFillStyle, -20);
        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
    };

    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */
    Body.set = function(body, settings, value) {
        var property;

        if (typeof settings === 'string') {
            property = settings;
            settings = {};
            settings[property] = value;
        }

        for (property in settings) {
            value = settings[property];

            if (!settings.hasOwnProperty(property))
                continue;

            switch (property) {

            case 'isStatic':
                Body.setStatic(body, value);
                break;
            case 'isSleeping':
                Sleeping.set(body, value);
                break;
            case 'mass':
                Body.setMass(body, value);
                break;
            case 'density':
                Body.setDensity(body, value);
                break;
            case 'inertia':
                Body.setInertia(body, value);
                break;
            case 'vertices':
                Body.setVertices(body, value);
                break;
            case 'position':
                Body.setPosition(body, value);
                break;
            case 'angle':
                Body.setAngle(body, value);
                break;
            case 'velocity':
                Body.setVelocity(body, value);
                break;
            case 'angularVelocity':
                Body.setAngularVelocity(body, value);
                break;
            case 'parts':
                Body.setParts(body, value);
                break;
            default:
                body[property] = value;

            }
        }
    };

    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */
    Body.setStatic = function(body, isStatic) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.isStatic = isStatic;

            if (isStatic) {
                part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                };

                part.restitution = 0;
                part.friction = 1;
                part.mass = part.inertia = part.density = Infinity;
                part.inverseMass = part.inverseInertia = 0;

                part.positionPrev.x = part.position.x;
                part.positionPrev.y = part.position.y;
                part.anglePrev = part.angle;
                part.angularVelocity = 0;
                part.speed = 0;
                part.angularSpeed = 0;
                part.motion = 0;
            } else if (part._original) {
                part.restitution = part._original.restitution;
                part.friction = part._original.friction;
                part.mass = part._original.mass;
                part.inertia = part._original.inertia;
                part.density = part._original.density;
                part.inverseMass = part._original.inverseMass;
                part.inverseInertia = part._original.inverseInertia;

                delete part._original;
            }
        }
    };

    /**
     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */
    Body.setMass = function(body, mass) {
        body.mass = mass;
        body.inverseMass = 1 / body.mass;
        body.density = body.mass / body.area;
    };

    /**
     * Sets the density of the body. Mass is automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */
    Body.setDensity = function(body, density) {
        Body.setMass(body, density * body.area);
        body.density = density;
    };

    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */
    Body.setInertia = function(body, inertia) {
        body.inertia = inertia;
        body.inverseInertia = 1 / body.inertia;
    };

    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */
    Body.setVertices = function(body, vertices) {
        // change vertices
        if (vertices[0].body === body) {
            body.vertices = vertices;
        } else {
            body.vertices = Vertices.create(vertices, body);
        }

        // update properties
        body.axes = Axes.fromVertices(body.vertices);
        body.area = Vertices.area(body.vertices);
        Body.setMass(body, body.density * body.area);

        // orient vertices around the centre of mass at origin (0, 0)
        var centre = Vertices.centre(body.vertices);
        Vertices.translate(body.vertices, centre, -1);

        // update inertia while vertices are at origin (0, 0)
        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));

        // update geometry
        Vertices.translate(body.vertices, body.position);
        Bounds.update(body.bounds, body.vertices, body.velocity);
    };

    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */
    Body.setParts = function(body, parts, autoHull) {
        var i;

        // add all the parts, ensuring that the first part is always the parent body
        parts = parts.slice(0);
        body.parts.length = 0;
        body.parts.push(body);
        body.parent = body;

        for (i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== body) {
                part.parent = body;
                body.parts.push(part);
            }
        }

        if (body.parts.length === 1)
            return;

        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;

        // find the convex hull of all parts to set on the parent body
        if (autoHull) {
            var vertices = [];
            for (i = 0; i < parts.length; i++) {
                vertices = vertices.concat(parts[i].vertices);
            }

            Vertices.clockwiseSort(vertices);

            var hull = Vertices.hull(vertices),
                hullCentre = Vertices.centre(hull);

            Body.setVertices(body, hull);
            Vertices.translate(body.vertices, hullCentre);
        }

        // sum the properties of all compound parts of the parent body
        var total = _totalProperties(body);

        body.area = total.area;
        body.parent = body;
        body.position.x = total.centre.x;
        body.position.y = total.centre.y;
        body.positionPrev.x = total.centre.x;
        body.positionPrev.y = total.centre.y;

        Body.setMass(body, total.mass);
        Body.setInertia(body, total.inertia);
        Body.setPosition(body, total.centre);
    };

    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */
    Body.setPosition = function(body, position) {
        var delta = Vector.sub(position, body.position);
        body.positionPrev.x += delta.x;
        body.positionPrev.y += delta.y;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.position.x += delta.x;
            part.position.y += delta.y;
            Vertices.translate(part.vertices, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */
    Body.setAngle = function(body, angle) {
        var delta = angle - body.angle;
        body.anglePrev += delta;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.angle += delta;
            Vertices.rotate(part.vertices, delta, body.position);
            Axes.rotate(part.axes, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
            if (i > 0) {
                Vector.rotateAbout(part.position, delta, body.position, part.position);
            }
        }
    };

    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */
    Body.setVelocity = function(body, velocity) {
        body.positionPrev.x = body.position.x - velocity.x;
        body.positionPrev.y = body.position.y - velocity.y;
        body.velocity.x = velocity.x;
        body.velocity.y = velocity.y;
        body.speed = Vector.magnitude(body.velocity);
    };

    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */
    Body.setAngularVelocity = function(body, velocity) {
        body.anglePrev = body.angle - velocity;
        body.angularVelocity = velocity;
        body.angularSpeed = Math.abs(body.angularVelocity);
    };

    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */
    Body.translate = function(body, translation) {
        Body.setPosition(body, Vector.add(body.position, translation));
    };

    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     */
    Body.rotate = function(body, rotation) {
        Body.setAngle(body, body.angle + rotation);
    };

    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */
    Body.scale = function(body, scaleX, scaleY, point) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            // scale vertices
            Vertices.scale(part.vertices, scaleX, scaleY, body.position);

            // update properties
            part.axes = Axes.fromVertices(part.vertices);

            if (!body.isStatic) {
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);

                // update inertia (requires vertices to be at origin)
                Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
                Body.setInertia(part, Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });
            }

            // update bounds
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }

        // handle circles
        if (body.circleRadius) { 
            if (scaleX === scaleY) {
                body.circleRadius *= scaleX;
            } else {
                // body is no longer a circle
                body.circleRadius = null;
            }
        }

        if (!body.isStatic) {
            var total = _totalProperties(body);
            body.area = total.area;
            Body.setMass(body, total.mass);
            Body.setInertia(body, total.inertia);
        }
    };

    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */
    Body.update = function(body, deltaTime, timeScale, correction) {
        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);

        // from the previous step
        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,
            velocityPrevX = body.position.x - body.positionPrev.x,
            velocityPrevY = body.position.y - body.positionPrev.y;

        // update velocity with Verlet integration
        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;
        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;

        body.positionPrev.x = body.position.x;
        body.positionPrev.y = body.position.y;
        body.position.x += body.velocity.x;
        body.position.y += body.velocity.y;

        // update angular velocity with Verlet integration
        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;
        body.anglePrev = body.angle;
        body.angle += body.angularVelocity;

        // track speed and acceleration
        body.speed = Vector.magnitude(body.velocity);
        body.angularSpeed = Math.abs(body.angularVelocity);

        // transform the body geometry
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            Vertices.translate(part.vertices, body.velocity);
            
            if (i > 0) {
                part.position.x += body.velocity.x;
                part.position.y += body.velocity.y;
            }

            if (body.angularVelocity !== 0) {
                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                Axes.rotate(part.axes, body.angularVelocity);
                if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                }
            }

            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */
    Body.applyForce = function(body, position, force) {
        body.force.x += force.x;
        body.force.y += force.y;
        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
        body.torque += offset.x * force.y - offset.y * force.x;
    };

    /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */
    var _totalProperties = function(body) {
        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
        // http://output.to/sideway/default.asp?qno=121100087

        var properties = {
            mass: 0,
            area: 0,
            inertia: 0,
            centre: { x: 0, y: 0 }
        };

        // sum the properties of all compound parts of the parent body
        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
            var part = body.parts[i];
            properties.mass += part.mass;
            properties.area += part.area;
            properties.inertia += part.inertia;
            properties.centre = Vector.add(properties.centre, 
                                           Vector.mult(part.position, part.mass !== Infinity ? part.mass : 1));
        }

        properties.centre = Vector.div(properties.centre, 
                                       properties.mass !== Infinity ? properties.mass : body.parts.length);

        return properties;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a body starts sleeping (where `this` is the body).
    *
    * @event sleepStart
    * @this {body} The body that has started sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a body ends sleeping (where `this` is the body).
    *
    * @event sleepEnd
    * @this {body} The body that has ended sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "body"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Body"
     */

    /**
     * An array of bodies that make up this body. 
     * The first body in the array must always be a self reference to the current body instance.
     * All bodies in the `parts` array together form a single rigid compound body.
     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
     * Parts themselves should never be added to a `World`, only the parent body should be.
     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     *
     * @property parts
     * @type body[]
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

    /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
     * See `body.parts`.
     *
     * @property parent
     * @type body
     */

    /**
     * A `Number` specifying the angle of the body, in radians.
     *
     * @property angle
     * @type number
     * @default 0
     */

    /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
     *
     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     *
     * @property vertices
     * @type vector[]
     */

    /**
     * A `Vector` that specifies the current world-space position of the body.
     *
     * @property position
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     *
     * @property force
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     *
     * @property torque
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     *
     * @readOnly
     * @property speed
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     *
     * @readOnly
     * @property angularSpeed
     * @type number
     * @default 0
     */

    /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property velocity
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property angularVelocity
     * @type number
     * @default 0
     */

    /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     *
     * @property isStatic
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
     *
     * @property isSensor
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     *
     * @property isSleeping
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     *
     * @readOnly
     * @property motion
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     *
     * @property sleepThreshold
     * @type number
     * @default 60
     */

    /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     *
     * @property density
     * @type number
     * @default 0.001
     */

    /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     *
     * @property mass
     * @type number
     */

    /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     *
     * @property inverseMass
     * @type number
     */

    /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     *
     * @property inertia
     * @type number
     */

    /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     *
     * @property inverseInertia
     * @type number
     */

    /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. 
     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
     *
     *     Math.max(bodyA.restitution, bodyB.restitution)
     *
     * @property restitution
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
     *
     * The effects of the value may be non-linear. 
     * High values may be unstable depending on the body.
     * The engine uses a Coulomb friction model including static and kinetic friction.
     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
     *
     *     Math.min(bodyA.friction, bodyB.friction)
     *
     * @property friction
     * @type number
     * @default 0.1
     */

    /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model). 
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     *
     * @property frictionStatic
     * @type number
     * @default 0.5
     */

    /**
     * A `Number` that defines the air friction of the body (air resistance). 
     * A value of `0` means the body will never slow as it moves through space.
     * The higher the value, the faster a body slows when moving through space.
     * The effects of the value are non-linear. 
     *
     * @property frictionAir
     * @type number
     * @default 0.01
     */

    /**
     * An `Object` that specifies the collision filtering properties of this body.
     *
     * Collisions between two bodies will obey the following rules:
     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
     *   they will always collide if the value is positive, and they will never collide
     *   if the value is negative.
     * - If the two bodies have different values of `collisionFilter.group` or if one
     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
     *
     * Each body belongs to a collision category, given by `collisionFilter.category`. This
     * value is used as a bit field and the category should have only one bit set, meaning that
     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
     * different collision categories available.
     *
     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
     * the categories it collides with (the value is the bitwise AND value of all these categories).
     *
     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
     * are both true.
     *
     * @property collisionFilter
     * @type object
     */

    /**
     * An Integer `Number`, that specifies the collision group this body belongs to.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.group
     * @type object
     * @default 0
     */

    /**
     * A bit field that specifies the collision category this body belongs to.
     * The category value should have only one bit set, for example `0x0001`.
     * This means there are up to 32 unique collision categories available.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.category
     * @type object
     * @default 1
     */

    /**
     * A bit mask that specifies the collision categories this body may collide with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.mask
     * @type object
     * @default -1
     */

    /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
     *
     * @property slop
     * @type number
     * @default 0.05
     */

    /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     *
     * @property timeScale
     * @type number
     * @default 1
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the body should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * Sets the opacity to use when rendering.
     *
     * @property render.opacity
     * @type number
     * @default 1
    */

    /**
     * An `Object` that defines the sprite properties to use when rendering, if any.
     *
     * @property render.sprite
     * @type object
     */

    /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     *
     * @property render.sprite.texture
     * @type string
     */
     
    /**
     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
     *
     * @property render.sprite.xScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
     *
     * @property render.sprite.yScale
     * @type number
     * @default 1
     */

     /**
      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
      *
      * @property render.sprite.xOffset
      * @type number
      * @default 0
      */

     /**
      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
      *
      * @property render.sprite.yOffset
      * @type number
      * @default 0
      */

    /**
     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 1.5
     */

    /**
     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.fillStyle
     * @type string
     * @default a random colour
     */

    /**
     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
     * They are constantly updated by `Body.update` during the simulation.
     *
     * @property axes
     * @type vector[]
     */
     
    /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     *
     * @property area
     * @type string
     * @default 
     */

    /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     *
     * @property bounds
     * @type bounds
     */

})();


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/

// TODO: fix instability issues with torque
// TODO: linked constraints
// TODO: breakable constraints
// TODO: collision constraints
// TODO: allow constrained bodies to sleep
// TODO: handle 0 length constraints properly
// TODO: impulse caching and warming

var Constraint = {};

module.exports = Constraint;

var Vertices = __webpack_require__(25);
var Vector = __webpack_require__(8);
var Sleeping = __webpack_require__(41);
var Bounds = __webpack_require__(7);
var Axes = __webpack_require__(81);
var Common = __webpack_require__(0);

(function() {

    var _minLength = 0.000001,
        _minDifference = 0.001;

    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */
    Constraint.create = function(options) {
        var constraint = options;

        // if bodies defined but no points, use body centre
        if (constraint.bodyA && !constraint.pointA)
            constraint.pointA = { x: 0, y: 0 };
        if (constraint.bodyB && !constraint.pointB)
            constraint.pointB = { x: 0, y: 0 };

        // calculate static length using initial world space points
        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,
            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,
            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
    
        constraint.length = constraint.length || length || _minLength;

        // render
        var render = {
            visible: true,
            lineWidth: 2,
            strokeStyle: '#ffffff'
        };
        
        constraint.render = Common.extend(render, constraint.render);

        // option defaults
        constraint.id = constraint.id || Common.nextId();
        constraint.label = constraint.label || 'Constraint';
        constraint.type = 'constraint';
        constraint.stiffness = constraint.stiffness || 1;
        constraint.angularStiffness = constraint.angularStiffness || 0;
        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
        constraint.plugin = {};

        return constraint;
    };

    /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */
    Constraint.solveAll = function(constraints, timeScale) {
        for (var i = 0; i < constraints.length; i++) {
            Constraint.solve(constraints[i], timeScale);
        }
    };

    /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */
    Constraint.solve = function(constraint, timeScale) {
        var bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB;

        // update reference angle
        if (bodyA && !bodyA.isStatic) {
            constraint.pointA = Vector.rotate(pointA, bodyA.angle - constraint.angleA);
            constraint.angleA = bodyA.angle;
        }
        
        // update reference angle
        if (bodyB && !bodyB.isStatic) {
            constraint.pointB = Vector.rotate(pointB, bodyB.angle - constraint.angleB);
            constraint.angleB = bodyB.angle;
        }

        var pointAWorld = pointA,
            pointBWorld = pointB;

        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);

        if (!pointAWorld || !pointBWorld)
            return;

        var delta = Vector.sub(pointAWorld, pointBWorld),
            currentLength = Vector.magnitude(delta);

        // prevent singularity
        if (currentLength === 0)
            currentLength = _minLength;

        // solve distance constraint with Gauss-Siedel method
        var difference = (currentLength - constraint.length) / currentLength,
            normal = Vector.div(delta, currentLength),
            force = Vector.mult(delta, difference * 0.5 * constraint.stiffness * timeScale * timeScale);
        
        // if difference is very small, we can skip
        if (Math.abs(1 - (currentLength / constraint.length)) < _minDifference * timeScale)
            return;

        var velocityPointA,
            velocityPointB,
            offsetA,
            offsetB,
            oAn,
            oBn,
            bodyADenom,
            bodyBDenom;
    
        if (bodyA && !bodyA.isStatic) {
            // point body offset
            offsetA = { 
                x: pointAWorld.x - bodyA.position.x + force.x, 
                y: pointAWorld.y - bodyA.position.y + force.y
            };
            
            // update velocity
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            
            // find point velocity and body mass
            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity));
            oAn = Vector.dot(offsetA, normal);
            bodyADenom = bodyA.inverseMass + bodyA.inverseInertia * oAn * oAn;
        } else {
            velocityPointA = { x: 0, y: 0 };
            bodyADenom = bodyA ? bodyA.inverseMass : 0;
        }
            
        if (bodyB && !bodyB.isStatic) {
            // point body offset
            offsetB = { 
                x: pointBWorld.x - bodyB.position.x - force.x, 
                y: pointBWorld.y - bodyB.position.y - force.y 
            };
            
            // update velocity
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // find point velocity and body mass
            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity));
            oBn = Vector.dot(offsetB, normal);
            bodyBDenom = bodyB.inverseMass + bodyB.inverseInertia * oBn * oBn;
        } else {
            velocityPointB = { x: 0, y: 0 };
            bodyBDenom = bodyB ? bodyB.inverseMass : 0;
        }
        
        var relativeVelocity = Vector.sub(velocityPointB, velocityPointA),
            normalImpulse = Vector.dot(normal, relativeVelocity) / (bodyADenom + bodyBDenom);
    
        if (normalImpulse > 0) normalImpulse = 0;
    
        var normalVelocity = {
            x: normal.x * normalImpulse, 
            y: normal.y * normalImpulse
        };

        var torque;
 
        if (bodyA && !bodyA.isStatic) {
            torque = Vector.cross(offsetA, normalVelocity) * bodyA.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyA.constraintImpulse.x -= force.x;
            bodyA.constraintImpulse.y -= force.y;
            bodyA.constraintImpulse.angle += torque;

            // apply forces
            bodyA.position.x -= force.x;
            bodyA.position.y -= force.y;
            bodyA.angle += torque;
        }

        if (bodyB && !bodyB.isStatic) {
            torque = Vector.cross(offsetB, normalVelocity) * bodyB.inverseInertia * (1 - constraint.angularStiffness);

            // keep track of applied impulses for post solving
            bodyB.constraintImpulse.x += force.x;
            bodyB.constraintImpulse.y += force.y;
            bodyB.constraintImpulse.angle -= torque;
            
            // apply forces
            bodyB.position.x += force.x;
            bodyB.position.y += force.y;
            bodyB.angle -= torque;
        }

    };

    /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */
    Constraint.postSolveAll = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                impulse = body.constraintImpulse;

            if (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                continue;
            }

            Sleeping.set(body, false);

            // update geometry and reset
            for (var j = 0; j < body.parts.length; j++) {
                var part = body.parts[j];
                
                Vertices.translate(part.vertices, impulse);

                if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                }

                if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                }

                Bounds.update(part.bounds, part.vertices, body.velocity);
            }

            impulse.angle = 0;
            impulse.x = 0;
            impulse.y = 0;
        }
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Constraint"
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the constraint should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 2
     */

    /**
     * A `String` that defines the stroke style to use when rendering the constraint outline.
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * The first possible `Body` that this constraint is attached to.
     *
     * @property bodyA
     * @type body
     * @default null
     */

    /**
     * The second possible `Body` that this constraint is attached to.
     *
     * @property bodyB
     * @type body
     * @default null
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointA
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointB
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
     * A value of `0.2` means the constraint acts like a soft spring.
     *
     * @property stiffness
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the target resting length of the constraint. 
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     *
     * @property length
     * @type number
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/

var Sleeping = {};

module.exports = Sleeping;

var Events = __webpack_require__(24);

(function() {

    Sleeping._motionWakeThreshold = 0.18;
    Sleeping._motionSleepThreshold = 0.08;
    Sleeping._minBias = 0.9;

    /**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */
    Sleeping.update = function(bodies, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // update bodies sleeping status
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;

            // wake up bodies if they have a force applied
            if (body.force.x !== 0 || body.force.y !== 0) {
                Sleeping.set(body, false);
                continue;
            }

            var minMotion = Math.min(body.motion, motion),
                maxMotion = Math.max(body.motion, motion);
        
            // biased average motion estimation between frames
            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
            
            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                body.sleepCounter += 1;
                
                if (body.sleepCounter >= body.sleepThreshold)
                    Sleeping.set(body, true);
            } else if (body.sleepCounter > 0) {
                body.sleepCounter -= 1;
            }
        }
    };

    /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Sleeping.afterCollisions = function(pairs, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // wake up bodies involved in collisions
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            // don't wake inactive pairs
            if (!pair.isActive)
                continue;

            var collision = pair.collision,
                bodyA = collision.bodyA.parent, 
                bodyB = collision.bodyB.parent;
        
            // don't wake if at least one body is static
            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)
                continue;
        
            if (bodyA.isSleeping || bodyB.isSleeping) {
                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,
                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;

                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                }
            }
        }
    };
  
    /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */
    Sleeping.set = function(body, isSleeping) {
        var wasSleeping = body.isSleeping;

        if (isSleeping) {
            body.isSleeping = true;
            body.sleepCounter = body.sleepThreshold;

            body.positionImpulse.x = 0;
            body.positionImpulse.y = 0;

            body.positionPrev.x = body.position.x;
            body.positionPrev.y = body.position.y;

            body.anglePrev = body.angle;
            body.speed = 0;
            body.angularSpeed = 0;
            body.motion = 0;

            if (!wasSleeping) {
                Events.trigger(body, 'sleepStart');
            }
        } else {
            body.isSleeping = false;
            body.sleepCounter = 0;

            if (wasSleeping) {
                Events.trigger(body, 'sleepEnd');
            }
        }
    };

})();


/***/ },
/* 42 */
/***/ function(module, exports) {

module.exports = {

    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1

};


/***/ },
/* 43 */
/***/ function(module, exports) {

var Contains = function (circle, x, y)
{
    //  Check if x/y are within the bounds first
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)
    {
        var dx = (circle.x - x) * (circle.x - x);
        var dy = (circle.y - y) * (circle.y - y);

        return (dx + dy) <= (circle.radius * circle.radius);
    }
    else
    {
        return false;
    }
};

module.exports = Contains;


/***/ },
/* 44 */
/***/ function(module, exports) {

//  This is based off an explanation and expanded math presented by Paul Bourke:
//  See http:'local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/

var LineToLine = function (line1, line2, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = line1.x1;
    var y1 = line1.y1;
    var x2 = line1.x2;
    var y2 = line1.y2;

    var x3 = line2.x1;
    var y3 = line2.y1;
    var x4 = line2.x2;
    var y4 = line2.y2;

    var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    //  Make sure there is not a division by zero - this also indicates that the lines are parallel.
    //  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).
    //  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).

    if (deNom === 0)
    {
        return false;
    }

    //  Calculate the intermediate fractional point that the lines potentially intersect.

    var uA = numA / deNom;
    var uB = numB / deNom;

    //  The fractional point will be between 0 and 1 inclusive if the lines intersect.
    //  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1)
    {
        out.x = x1 + (uA * (x2 - x1));
        out.y = y1 + (uA * (y2 - y1));

        return true;
    }

    return false;
};

module.exports = LineToLine;


/***/ },
/* 45 */
/***/ function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

var Contains = function (triangle, x, y)
{
    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var v2x = x - triangle.x1;
    var v2y = y - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot02 = (v0x * v2x) + (v0y * v2y);
    var dot11 = (v1x * v1x) + (v1y * v1y);
    var dot12 = (v1x * v2x) + (v1y * v2y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);
    var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
    var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;

    return (u >= 0 && v >= 0 && (u + v < 1));
};

module.exports = Contains;


/***/ },
/* 46 */
/***/ function(module, exports) {

var Wrap = function (value, min, max)
{
    var range = max - min;

    if (range <= 0)
    {
        return 0;
    }

    if (value >= min && value <= max)
    {
        return value;
    }

    var result = (value - min) % range;

    if (result < 0)
    {
        result += range;
    }

    return result + min;
};

module.exports = Wrap;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/

var Pair = {};

module.exports = Pair;

var Contact = __webpack_require__(176);

(function() {
    
    /**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */
    Pair.create = function(collision, timestamp) {
        var bodyA = collision.bodyA,
            bodyB = collision.bodyB,
            parentA = collision.parentA,
            parentB = collision.parentB;

        var pair = {
            id: Pair.id(bodyA, bodyB),
            bodyA: bodyA,
            bodyB: bodyB,
            contacts: {},
            activeContacts: [],
            separation: 0,
            isActive: true,
            isSensor: bodyA.isSensor || bodyB.isSensor,
            timeCreated: timestamp,
            timeUpdated: timestamp,
            inverseMass: parentA.inverseMass + parentB.inverseMass,
            friction: Math.min(parentA.friction, parentB.friction),
            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
            restitution: Math.max(parentA.restitution, parentB.restitution),
            slop: Math.max(parentA.slop, parentB.slop)
        };

        Pair.update(pair, collision, timestamp);

        return pair;
    };

    /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */
    Pair.update = function(pair, collision, timestamp) {
        var contacts = pair.contacts,
            supports = collision.supports,
            activeContacts = pair.activeContacts,
            parentA = collision.parentA,
            parentB = collision.parentB;
        
        pair.collision = collision;
        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
        pair.friction = Math.min(parentA.friction, parentB.friction);
        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
        pair.slop = Math.max(parentA.slop, parentB.slop);
        activeContacts.length = 0;
        
        if (collision.collided) {
            for (var i = 0; i < supports.length; i++) {
                var support = supports[i],
                    contactId = Contact.id(support),
                    contact = contacts[contactId];

                if (contact) {
                    activeContacts.push(contact);
                } else {
                    activeContacts.push(contacts[contactId] = Contact.create(support));
                }
            }

            pair.separation = collision.depth;
            Pair.setActive(pair, true, timestamp);
        } else {
            if (pair.isActive === true)
                Pair.setActive(pair, false, timestamp);
        }
    };
    
    /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */
    Pair.setActive = function(pair, isActive, timestamp) {
        if (isActive) {
            pair.isActive = true;
            pair.timeUpdated = timestamp;
        } else {
            pair.isActive = false;
            pair.activeContacts.length = 0;
        }
    };

    /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */
    Pair.id = function(bodyA, bodyB) {
        if (bodyA.id < bodyB.id) {
            return 'A' + bodyA.id + 'B' + bodyB.id;
        } else {
            return 'A' + bodyB.id + 'B' + bodyA.id;
        }
    };

})();


/***/ },
/* 48 */
/***/ function(module, exports) {

var Buffer32 = function (byteSize)
{
    this.dwordLength = 0;
    this.dwordCapacity = byteSize / 4;
    this.buffer = new ArrayBuffer(byteSize);
    this.floatView = new Float32Array(this.buffer);
    this.intView = new Int32Array(this.buffer);
    this.uintView = new Uint32Array(this.buffer);
};

Buffer32.prototype.clear = function ()
{
    this.dwordLength = 0;
};

Buffer32.prototype.getByteLength = function ()
{
    return this.dwordLength * 4;
};

Buffer32.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

Buffer32.prototype.allocate = function (dwordSize)
{
    var currentLength = this.dwordLength;
    this.dwordLength += dwordSize;
    return currentLength;
};

Buffer32.prototype.getUsedBufferAsFloat = function ()
{
    return this.floatView.subarray(0, this.dwordLength);
};

Buffer32.prototype.getUsedBufferAsInt = function ()
{
    return this.intView.subarray(0, this.dwordLength);
};

Buffer32.prototype.getUsedBufferAsUint = function ()
{
    return this.uintView.subarray(0, this.dwordLength);
};

module.exports = Buffer32;


/***/ },
/* 49 */
/***/ function(module, exports) {

var CreateBuffer = function (gl, bufferType, usage, bufferData, bufferSize)
{
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    if (bufferData && ArrayBuffer.isView(bufferData))
    {
        gl.bufferData(bufferType, bufferData, usage);
    }
    else
    {
        gl.bufferData(bufferType, bufferSize, usage);
    }
    return buffer;
};

module.exports = CreateBuffer;


/***/ },
/* 50 */
/***/ function(module, exports) {

var CreateProgram = function (gl, vertexShader, fragmentShader)
{
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Failed to link program. Error: \n' + gl.getProgramInfoLog(program));
        return null;
    }
    return program;
};

module.exports = CreateProgram;


/***/ },
/* 51 */
/***/ function(module, exports) {

var CreateShader = function (gl, shaderSource, shaderType)
{
    var shader = null;
    shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.error('Failed ' + (shaderType === gl.VERTEX_SHADER ? 'vertex' : shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'invalid') + ' shader compilation. Error: \n' + gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
};

module.exports = CreateShader;


/***/ },
/* 52 */
/***/ function(module, exports) {

var BindVertexArray = function (gl, vao)
{
    var attributes = vao.attributes;
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.buffer);
    for (var index = 0, length = attributes.length; index < length; ++index)
    {
        var attrib = attributes[index];
        var location = attrib.location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(
            location,
            attrib.size,
            attrib.type,
            attrib.normalized,
            attrib.stride,
            attrib.offset
        );
    }
};

module.exports = BindVertexArray;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

var Attribute = __webpack_require__(604);

var CreateAttribDesc = function (gl, program, name, size, type, normalized, stride, offset)
{
    return new Attribute(
        gl.getAttribLocation(program, name),
        size,
        type,
        normalized,
        stride,
        offset
    );
};

module.exports = CreateAttribDesc;


/***/ },
/* 54 */
/***/ function(module, exports) {

var VertexArray = function (vbo, attributes)
{
    this.buffer = vbo;
    this.attributes = attributes;
};

module.exports = VertexArray;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

var IsPlainObject = __webpack_require__(204);

/**
* This is a slightly modified version of http://api.jquery.com/jQuery.extend/
* 
* @method Phaser.Utils.extend
* @param {boolean} deep - Perform a deep copy?
* @param {object} target - The target object to copy to.
* @return {object} The extended object.
*/
var Extend = function ()
{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean")
    {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // extend Phaser if only one argument is passed
    if (length === i)
    {
        target = this;
        --i;
    }

    for (; i < length; i++)
    {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null)
        {
            // Extend the base object
            for (name in options)
            {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy)
                {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))
                {
                    if (copyIsArray)
                    {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else
                    {
                        clone = src && IsPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = Extend(deep, clone, copy);

                // Don't bring in undefined values
                }
                else if (copy !== undefined)
                {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

module.exports = Extend;


/***/ },
/* 56 */
/***/ function(module, exports) {

var CanvasInterpolation = {

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
    * Note that if this doesn't given the desired result then see the setSmoothingEnabled.
    *
    * @method Phaser.Canvas.setImageRenderingCrisp
    * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setCrisp: function (canvas)
    {
        var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ];

        types.forEach(function(type)
        {
            canvas.style['image-rendering'] = type;
        });

        canvas.style.msInterpolationMode = 'nearest-neighbor';

        return canvas;
    },

    /**
    * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
    * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
    *
    * @method Phaser.Canvas.setImageRenderingBicubic
    * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.
    * @return {HTMLCanvasElement} Returns the source canvas.
    */
    setBicubic: function (canvas)
    {
        canvas.style['image-rendering'] = 'auto';
        canvas.style.msInterpolationMode = 'bicubic';

        return canvas;
    }

};

module.exports = CanvasInterpolation;


/***/ },
/* 57 */
/***/ function(module, exports) {

module.exports = {
    ARC: 0,
    BEGIN_PATH: 1,
    CLOSE_PATH: 2,
    FILL_RECT: 3,
    LINE_TO: 4,
    MOVE_TO: 5,
    LINE_STYLE: 6,
    FILL_STYLE: 7,
    FILL_PATH: 8,
    STROKE_PATH: 9,
    FILL_TRIANGLE: 10,
    STROKE_TRIANGLE: 11,
    LINE_FX_TO: 12,
    MOVE_FX_TO: 13
};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var SpriteRender = __webpack_require__(322);

var Sprite = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        Components.Flip,
        SpriteRender
    ],

    initialize:

    function Sprite (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
    }

});

module.exports = Sprite;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);

var Zone = new Class({

    Mixins: [
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Size,
        Components.Transform,
        Components.Visible
    ],

    initialize:

    function Zone (state, x, y, width, height)
    {
        GameObject.call(this, state);

        this.setPosition(x, y);
        this.setSize(width, height);
        this.setOrigin(0);
    }

});

module.exports = Zone;


/***/ },
/* 60 */
/***/ function(module, exports) {

var Contains = function (ellipse, x, y)
{
    if (ellipse.width <= 0 || ellipse.height <= 0)
    {
        return false;
    }
 
    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5
    var normx = ((x - ellipse.x) / ellipse.width) - 0.5;
    var normy = ((y - ellipse.y) / ellipse.height) - 0.5;
 
    normx *= normx;
    normy *= normy;
 
    return (normx + normy < 0.25);
};

module.exports = Contains;


/***/ },
/* 61 */
/***/ function(module, exports) {

/**
* Convert a distance along this curve into a `time` value which will be between 0 and 1.
* 
* For example if this curve has a length of 100 pixels then `findT(50)` would return `0.5`.
*
* @method Phaser.Hermite#findT
* @param {integer} distance - The distance into the curve in pixels. Should be a positive integer.
* @return {number} The time (`t`) value, a float between 0 and 1.
*/
var FindT = function (curve, distance)
{
    if (distance <= 0)
    {
        return 0;
    }

    //  Find the _points which bracket the distance value
    var ti = Math.floor(distance / curve.length * curve._accuracy);

    while (ti > 0 && curve._points[ti] > distance)
    {
        ti--;
    }

    while (ti < curve._accuracy && curve._points[ti] < distance)
    {
        ti++;
    }

    //  Linear interpolation to get a more accurate fix
    var dt = curve._points[ti] - curve._points[ti - 1];
    var d = distance - curve._points[ti - 1];

    return ((ti - 1) / curve._accuracy) + d / (dt * curve._accuracy);
};

module.exports = FindT;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* Get a point on the curve using the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getPoint
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} An Object with the x, y coordinate of the curve at the specified `t` value set in its `x` and `y` properties.
*/
var GetPoint = function (curve, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    if (t < 0)
    {
        t = 0;
    }

    if (t > 1)
    {
        t = 1;
    }

    var t2 = t * t;
    var t3 = t * t2;

    out.x = t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x;
    out.y = t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y;

    return out;
};

module.exports = GetPoint;


/***/ },
/* 63 */
/***/ function(module, exports) {

/**
* Using Bresenham's line algorithm this will return an array of all coordinates on this line.
* The start and end points are rounded before this runs as the algorithm works on integers.
*
* @method Phaser.Line#coordinatesOnLine
* @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
* @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
* @return {array} An array of coordinates.
*/
var GetPointsOnLine = function (line, stepRate, results)
{
    if (stepRate === undefined) { stepRate = 1; }
    if (results === undefined) { results = []; }

    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = (x1 < x2) ? 1 : -1;
    var sy = (y1 < y2) ? 1 : -1;
    var err = dx - dy;

    results.push([ x1, y1 ]);

    var i = 1;

    while (!((x1 === x2) && (y1 === y2)))
    {
        var e2 = err << 1;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }

        if (i % stepRate === 0)
        {
            results.push([ x1, y1 ]);
        }

        i++;
    }

    return results;
};

module.exports = GetPointsOnLine;


/***/ },
/* 64 */
/***/ function(module, exports) {


var RotateAroundXY = function (line, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = line.x1 - x;
    var ty = line.y1 - y;

    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;

    tx = line.x2 - x;
    ty = line.y2 - y;

    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;

    return line;
};

module.exports = RotateAroundXY;


/***/ },
/* 65 */
/***/ function(module, exports) {

var Dot = function (pointA, pointB)
{
    return ((pointA.x * pointB.x) + (pointA.y * pointB.y));
};

module.exports = Dot;


/***/ },
/* 66 */
/***/ function(module, exports) {

var Contains = function (rect, x, y)
{
    if (rect.width <= 0 || rect.height <= 0)
    {
        return false;
    }

    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);
};

module.exports = Contains;


/***/ },
/* 67 */
/***/ function(module, exports) {

var GetAspectRatio = function (rect)
{
    return (rect.height === 0) ? NaN : rect.width / rect.height;
};

module.exports = GetAspectRatio;


/***/ },
/* 68 */
/***/ function(module, exports) {

//  http://www.blackpawn.com/texts/pointinpoly/

//  points is an array of Point-like objects with public x/y properties
//  returns an array containing all points that are within the triangle, or an empty array if none
//  if 'returnFirst' is true it will return after the first point within the triangle is found

var ContainsArray = function (triangle, points, returnFirst, out)
{
    if (returnFirst === undefined) { returnFirst = false; }
    if (out === undefined) { out = []; }

    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;

    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;

    var dot00 = (v0x * v0x) + (v0y * v0y);
    var dot01 = (v0x * v1x) + (v0y * v1y);
    var dot11 = (v1x * v1x) + (v1y * v1y);

    // Compute barycentric coordinates
    var b = ((dot00 * dot11) - (dot01 * dot01));
    var inv = (b === 0) ? 0 : (1 / b);

    var u;
    var v;
    var v2x;
    var v2y;
    var dot02;
    var dot12;

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    for (var i = 0; i < points.length; i++)
    {
        v2x = points[i].x - x1;
        v2y = points[i].y - y1;

        dot02 = (v0x * v2x) + (v0y * v2y);
        dot12 = (v1x * v2x) + (v1y * v2y);

        u = ((dot11 * dot02) - (dot01 * dot12)) * inv;
        v = ((dot00 * dot12) - (dot01 * dot02)) * inv;
    
        if (u >= 0 && v >= 0 && (u + v < 1))
        {
            out.push({ x: points[i].x, y: points[i].y });

            if (returnFirst)
            {
                break;
            }
        }
    }

    return out;
};

module.exports = ContainsArray;


/***/ },
/* 69 */
/***/ function(module, exports) {


var RotateAroundXY = function (triangle, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = triangle.x1 - x;
    var ty = triangle.y1 - y;

    triangle.x1 = tx * c - ty * s + x;
    triangle.y1 = tx * s + ty * c + y;

    tx = triangle.x2 - x;
    ty = triangle.y2 - y;

    triangle.x2 = tx * c - ty * s + x;
    triangle.y2 = tx * s + ty * c + y;

    tx = triangle.x3 - x;
    ty = triangle.y3 - y;

    triangle.x3 = tx * c - ty * s + x;
    triangle.y3 = tx * s + ty * c + y;

    return triangle;
};

module.exports = RotateAroundXY;


/***/ },
/* 70 */
/***/ function(module, exports) {

/**
 * Given 3 color values this will return an integer representation of it.
 *
 * @method getColor
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor = function (red, green, blue)
{
    return red << 16 | green << 8 | blue;
};

module.exports = GetColor;


/***/ },
/* 71 */
/***/ function(module, exports) {

module.exports = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,

    SHIFT: 16,
    CTRL: 17,
    ALT: 18,

    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,

    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,

    PRINT_SCREEN: 42,
    INSERT: 45,
    DELETE: 46,

    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,

    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,

    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,

    SEMICOLON: 186,
    PLUS: 187,
    COMMA: 188,
    MINUS: 189,
    PERIOD: 190,
    FORWAD_SLASH: 191,
    BACK_SLASH: 220,
    QUOTES: 222
};


/***/ },
/* 72 */
/***/ function(module, exports) {

//  Creates an XHRSettings Object with default values

var XHRSettings = function (responseType, async, user, password, timeout)
{
    if (responseType === undefined) { responseType = ''; }
    if (async === undefined) { async = true; }
    if (user === undefined) { user = ''; }
    if (password === undefined) { password = ''; }
    if (timeout === undefined) { timeout = 0; }

    // Before sending a request, set the xhr.responseType to "text", 
    // "arraybuffer", "blob", or "document", depending on your data needs. 
    // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".

    return {

        //  Ignored by the Loader, only used by File.
        responseType: responseType,

        async: async,

        //  credentials
        user: user,
        password: password,

        //  timeout in ms (0 = no timeout)
        timeout: timeout,

        //  setRequestHeader
        header: undefined,
        headerValue: undefined,

        //  overrideMimeType
        overrideMimeType: undefined

    };
    
};

module.exports = XHRSettings;


/***/ },
/* 73 */
/***/ function(module, exports) {

var Between = function (min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

module.exports = Between;


/***/ },
/* 74 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties, the item to be rotated
//  x/y = the coordinate to rotate around
//  angle = radians
//  distance = in px

var RotateAroundDistance = function (point, x, y, angle, distance)
{
    var t = angle + Math.atan2(point.y - y, point.x - x);

    point.x = x + (distance * Math.cos(t));
    point.y = y + (distance * Math.sin(t));

    return point;
};

module.exports = RotateAroundDistance;


/***/ },
/* 75 */
/***/ function(module, exports) {

var DistanceBetween = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return Math.sqrt(dx * dx + dy * dy);
};

module.exports = DistanceBetween;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/

// TODO: speculative contacts

var Detector = {};

module.exports = Detector;

var SAT = __webpack_require__(78);
var Pair = __webpack_require__(47);
var Bounds = __webpack_require__(7);

(function() {

    /**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */
    Detector.collisions = function(broadphasePairs, engine) {
        var collisions = [],
            pairsTable = engine.pairs.table;

        // @if DEBUG
        var metrics = engine.metrics;
        // @endif
        
        for (var i = 0; i < broadphasePairs.length; i++) {
            var bodyA = broadphasePairs[i][0], 
                bodyB = broadphasePairs[i][1];

            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                continue;
            
            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                continue;

            // @if DEBUG
            metrics.midphaseTests += 1;
            // @endif

            // mid phase
            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];

                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                        var partB = bodyB.parts[k];

                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {
                            // find a previous collision we could reuse
                            var pairId = Pair.id(partA, partB),
                                pair = pairsTable[pairId],
                                previousCollision;

                            if (pair && pair.isActive) {
                                previousCollision = pair.collision;
                            } else {
                                previousCollision = null;
                            }

                            // narrow phase
                            var collision = SAT.collides(partA, partB, previousCollision);

                            // @if DEBUG
                            metrics.narrowphaseTests += 1;
                            if (collision.reused)
                                metrics.narrowReuseCount += 1;
                            // @endif

                            if (collision.collided) {
                                collisions.push(collision);
                                // @if DEBUG
                                metrics.narrowDetections += 1;
                                // @endif
                            }
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */
    Detector.canCollide = function(filterA, filterB) {
        if (filterA.group === filterB.group && filterA.group !== 0)
            return filterA.group > 0;

        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
    };

})();


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/

var Grid = {};

module.exports = Grid;

var Pair = __webpack_require__(47);
var Detector = __webpack_require__(76);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */
    Grid.create = function(options) {
        var defaults = {
            controller: Grid,
            detector: Detector.collisions,
            buckets: {},
            pairs: {},
            pairsList: [],
            bucketWidth: 48,
            bucketHeight: 48
        };

        return Common.extend(defaults, options);
    };

    /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */

    /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */

    /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */
    Grid.update = function(grid, bodies, engine, forceUpdate) {
        var i, col, row,
            world = engine.world,
            buckets = grid.buckets,
            bucket,
            bucketId,
            gridChanged = false;

        // @if DEBUG
        var metrics = engine.metrics;
        metrics.broadphaseTests = 0;
        // @endif

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isSleeping && !forceUpdate)
                continue;

            // don't update out of world bodies
            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x
                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                continue;

            var newRegion = _getRegion(grid, body);

            // if the body has changed grid region
            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {

                // @if DEBUG
                metrics.broadphaseTests += 1;
                // @endif

                if (!body.region || forceUpdate)
                    body.region = newRegion;

                var union = _regionUnion(newRegion, body.region);

                // update grid buckets affected by region change
                // iterate over the union of both regions
                for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                        bucketId = _getBucketId(col, row);
                        bucket = buckets[bucketId];

                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol
                                                && row >= newRegion.startRow && row <= newRegion.endRow);

                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol
                                                && row >= body.region.startRow && row <= body.region.endRow);

                        // remove from old region buckets
                        if (!isInsideNewRegion && isInsideOldRegion) {
                            if (isInsideOldRegion) {
                                if (bucket)
                                    _bucketRemoveBody(grid, bucket, body);
                            }
                        }

                        // add to new region buckets
                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {
                            if (!bucket)
                                bucket = _createBucket(buckets, bucketId);
                            _bucketAddBody(grid, bucket, body);
                        }
                    }
                }

                // set the new region
                body.region = newRegion;

                // flag changes so we can update pairs
                gridChanged = true;
            }
        }

        // update pairs list only if pairs changed (i.e. a body changed region)
        if (gridChanged)
            grid.pairsList = _createActivePairsList(grid);
    };

    /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */
    Grid.clear = function(grid) {
        grid.buckets = {};
        grid.pairs = {};
        grid.pairsList = [];
    };

    /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */
    var _regionUnion = function(regionA, regionB) {
        var startCol = Math.min(regionA.startCol, regionB.startCol),
            endCol = Math.max(regionA.endCol, regionB.endCol),
            startRow = Math.min(regionA.startRow, regionB.startRow),
            endRow = Math.max(regionA.endRow, regionB.endRow);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */
    var _getRegion = function(grid, body) {
        var bounds = body.bounds,
            startCol = Math.floor(bounds.min.x / grid.bucketWidth),
            endCol = Math.floor(bounds.max.x / grid.bucketWidth),
            startRow = Math.floor(bounds.min.y / grid.bucketHeight),
            endRow = Math.floor(bounds.max.y / grid.bucketHeight);

        return _createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */
    var _createRegion = function(startCol, endCol, startRow, endRow) {
        return { 
            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,
            startCol: startCol, 
            endCol: endCol, 
            startRow: startRow, 
            endRow: endRow 
        };
    };

    /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */
    var _getBucketId = function(column, row) {
        return 'C' + column + 'R' + row;
    };

    /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */
    var _createBucket = function(buckets, bucketId) {
        var bucket = buckets[bucketId] = [];
        return bucket;
    };

    /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketAddBody = function(grid, bucket, body) {
        // add new pairs
        for (var i = 0; i < bucket.length; i++) {
            var bodyB = bucket[i];

            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))
                continue;

            // keep track of the number of buckets the pair exists in
            // important for Grid.update to work
            var pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair) {
                pair[2] += 1;
            } else {
                grid.pairs[pairId] = [body, bodyB, 1];
            }
        }

        // add to bodies (after pairs, otherwise pairs with self)
        bucket.push(body);
    };

    /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    var _bucketRemoveBody = function(grid, bucket, body) {
        // remove from bucket
        bucket.splice(Common.indexOf(bucket, body), 1);

        // update pair counts
        for (var i = 0; i < bucket.length; i++) {
            // keep track of the number of buckets the pair exists in
            // important for _createActivePairsList to work
            var bodyB = bucket[i],
                pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair)
                pair[2] -= 1;
        }
    };

    /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */
    var _createActivePairsList = function(grid) {
        var pairKeys,
            pair,
            pairs = [];

        // grid.pairs is used as a hashmap
        pairKeys = Common.keys(grid.pairs);

        // iterate over grid.pairs
        for (var k = 0; k < pairKeys.length; k++) {
            pair = grid.pairs[pairKeys[k]];

            // if pair exists in at least one bucket
            // it is a pair that needs further collision testing so push it
            if (pair[2] > 0) {
                pairs.push(pair);
            } else {
                delete grid.pairs[pairKeys[k]];
            }
        }

        return pairs;
    };
    
})();


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/

// TODO: true circles and curves

var SAT = {};

module.exports = SAT;

var Vertices = __webpack_require__(25);
var Vector = __webpack_require__(8);

(function() {

    /**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */
    SAT.collides = function(bodyA, bodyB, previousCollision) {
        var overlapAB,
            overlapBA, 
            minOverlap,
            collision,
            canReusePrevCol = false;

        if (previousCollision) {
            // estimate total motion
            var parentA = bodyA.parent,
                parentB = bodyB.parent,
                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed
                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;

            // we may be able to (partially) reuse collision result 
            // but only safe if collision was resting
            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;

            // reuse collision object
            collision = previousCollision;
        } else {
            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };
        }

        if (previousCollision && canReusePrevCol) {
            // if we can reuse the collision result
            // we only need to test the previously found axis
            var axisBodyA = collision.axisBody,
                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,
                axes = [axisBodyA.axes[previousCollision.axisNumber]];

            minOverlap = _overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
            collision.reused = true;

            if (minOverlap.overlap <= 0) {
                collision.collided = false;
                return collision;
            }
        } else {
            // if we can't reuse a result, perform a full SAT test

            overlapAB = _overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);

            if (overlapAB.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            overlapBA = _overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);

            if (overlapBA.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            if (overlapAB.overlap < overlapBA.overlap) {
                minOverlap = overlapAB;
                collision.axisBody = bodyA;
            } else {
                minOverlap = overlapBA;
                collision.axisBody = bodyB;
            }

            // important for reuse later
            collision.axisNumber = minOverlap.axisNumber;
        }

        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
        collision.collided = true;
        collision.depth = minOverlap.overlap;
        collision.parentA = collision.bodyA.parent;
        collision.parentB = collision.bodyB.parent;
        
        bodyA = collision.bodyA;
        bodyB = collision.bodyB;

        // ensure normal is facing away from bodyA
        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
            collision.normal = {
                x: minOverlap.axis.x,
                y: minOverlap.axis.y
            };
        } else {
            collision.normal = {
                x: -minOverlap.axis.x,
                y: -minOverlap.axis.y
            };
        }

        collision.tangent = Vector.perp(collision.normal);

        collision.penetration = collision.penetration || {};
        collision.penetration.x = collision.normal.x * collision.depth;
        collision.penetration.y = collision.normal.y * collision.depth; 

        // find support points, there is always either exactly one or two
        var verticesB = _findSupports(bodyA, bodyB, collision.normal),
            supports = [];

        // find the supports from bodyB that are inside bodyA
        if (Vertices.contains(bodyA.vertices, verticesB[0]))
            supports.push(verticesB[0]);

        if (Vertices.contains(bodyA.vertices, verticesB[1]))
            supports.push(verticesB[1]);

        // find the supports from bodyA that are inside bodyB
        if (supports.length < 2) {
            var verticesA = _findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                
            if (Vertices.contains(bodyB.vertices, verticesA[0]))
                supports.push(verticesA[0]);

            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                supports.push(verticesA[1]);
        }

        // account for the edge case of overlapping but no vertex containment
        if (supports.length < 1)
            supports = [verticesB[0]];
        
        collision.supports = supports;

        return collision;
    };

    /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */
    var _overlapAxes = function(verticesA, verticesB, axes) {
        var projectionA = Vector._temp[0], 
            projectionB = Vector._temp[1],
            result = { overlap: Number.MAX_VALUE },
            overlap,
            axis;

        for (var i = 0; i < axes.length; i++) {
            axis = axes[i];

            _projectToAxis(projectionA, verticesA, axis);
            _projectToAxis(projectionB, verticesB, axis);

            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);

            if (overlap <= 0) {
                result.overlap = overlap;
                return result;
            }

            if (overlap < result.overlap) {
                result.overlap = overlap;
                result.axis = axis;
                result.axisNumber = i;
            }
        }

        return result;
    };

    /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */
    var _projectToAxis = function(projection, vertices, axis) {
        var min = Vector.dot(vertices[0], axis),
            max = min;

        for (var i = 1; i < vertices.length; i += 1) {
            var dot = Vector.dot(vertices[i], axis);

            if (dot > max) { 
                max = dot; 
            } else if (dot < min) { 
                min = dot; 
            }
        }

        projection.min = min;
        projection.max = max;
    };
    
    /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */
    var _findSupports = function(bodyA, bodyB, normal) {
        var nearestDistance = Number.MAX_VALUE,
            vertexToBody = Vector._temp[0],
            vertices = bodyB.vertices,
            bodyAPosition = bodyA.position,
            distance,
            vertex,
            vertexA,
            vertexB;

        // find closest vertex on bodyB
        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            distance = -Vector.dot(normal, vertexToBody);

            if (distance < nearestDistance) {
                nearestDistance = distance;
                vertexA = vertex;
            }
        }

        // find next closest vertex using the two connected to it
        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
        vertex = vertices[prevIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        nearestDistance = -Vector.dot(normal, vertexToBody);
        vertexB = vertex;

        var nextIndex = (vertexA.index + 1) % vertices.length;
        vertex = vertices[nextIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        distance = -Vector.dot(normal, vertexToBody);
        if (distance < nearestDistance) {
            vertexB = vertex;
        }

        return [vertexA, vertexB];
    };

})();


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/

var Mouse = {};

module.exports = Mouse;

var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */
    Mouse.create = function(element) {
        var mouse = {};

        if (!element) {
            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');
        }
        
        mouse.element = element || document.body;
        mouse.absolute = { x: 0, y: 0 };
        mouse.position = { x: 0, y: 0 };
        mouse.mousedownPosition = { x: 0, y: 0 };
        mouse.mouseupPosition = { x: 0, y: 0 };
        mouse.offset = { x: 0, y: 0 };
        mouse.scale = { x: 1, y: 1 };
        mouse.wheelDelta = 0;
        mouse.button = -1;
        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;

        mouse.sourceEvents = {
            mousemove: null,
            mousedown: null,
            mouseup: null,
            mousewheel: null
        };
        
        mouse.mousemove = function(event) { 
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.sourceEvents.mousemove = event;
        };
        
        mouse.mousedown = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            } else {
                mouse.button = event.button;
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mousedownPosition.x = mouse.position.x;
            mouse.mousedownPosition.y = mouse.position.y;
            mouse.sourceEvents.mousedown = event;
        };
        
        mouse.mouseup = function(event) {
            var position = _getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                event.preventDefault();
            }
            
            mouse.button = -1;
            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mouseupPosition.x = mouse.position.x;
            mouse.mouseupPosition.y = mouse.position.y;
            mouse.sourceEvents.mouseup = event;
        };

        mouse.mousewheel = function(event) {
            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            event.preventDefault();
        };

        Mouse.setElement(mouse, mouse.element);

        return mouse;
    };

    /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */
    Mouse.setElement = function(mouse, element) {
        mouse.element = element;

        element.addEventListener('mousemove', mouse.mousemove);
        element.addEventListener('mousedown', mouse.mousedown);
        element.addEventListener('mouseup', mouse.mouseup);
        
        element.addEventListener('mousewheel', mouse.mousewheel);
        element.addEventListener('DOMMouseScroll', mouse.mousewheel);

        element.addEventListener('touchmove', mouse.mousemove);
        element.addEventListener('touchstart', mouse.mousedown);
        element.addEventListener('touchend', mouse.mouseup);
    };

    /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */
    Mouse.clearSourceEvents = function(mouse) {
        mouse.sourceEvents.mousemove = null;
        mouse.sourceEvents.mousedown = null;
        mouse.sourceEvents.mouseup = null;
        mouse.sourceEvents.mousewheel = null;
        mouse.wheelDelta = 0;
    };

    /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */
    Mouse.setOffset = function(mouse, offset) {
        mouse.offset.x = offset.x;
        mouse.offset.y = offset.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };

    /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */
    Mouse.setScale = function(mouse, scale) {
        mouse.scale.x = scale.x;
        mouse.scale.y = scale.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };
    
    /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */
    var _getRelativeMousePosition = function(event, element, pixelRatio) {
        var elementBounds = element.getBoundingClientRect(),
            rootNode = (document.documentElement || document.body.parentNode || document.body),
            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,
            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,
            touches = event.changedTouches,
            x, y;
        
        if (touches) {
            x = touches[0].pageX - elementBounds.left - scrollX;
            y = touches[0].pageY - elementBounds.top - scrollY;
        } else {
            x = event.pageX - elementBounds.left - scrollX;
            y = event.pageY - elementBounds.top - scrollY;
        }

        return { 
            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
        };
    };

})();


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/

// TODO: true circle bodies

var Bodies = {};

module.exports = Bodies;

var Vertices = __webpack_require__(25);
var Common = __webpack_require__(0);
var Body = __webpack_require__(39);
var Bounds = __webpack_require__(7);
var Vector = __webpack_require__(8);
var decomp = __webpack_require__(182);

(function() {

    /**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */
    Bodies.rectangle = function(x, y, width, height, options) {
        options = options || {};

        var rectangle = { 
            label: 'Rectangle Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, rectangle, options));
    };
    
    /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */
    Bodies.trapezoid = function(x, y, width, height, slope, options) {
        options = options || {};

        slope *= 0.5;
        var roof = (1 - (slope * 2)) * width;
        
        var x1 = width * slope,
            x2 = x1 + roof,
            x3 = x2 + x1,
            verticesPath;

        if (slope < 0.5) {
            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        } else {
            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        }

        var trapezoid = { 
            label: 'Trapezoid Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(verticesPath)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, trapezoid, options));
    };

    /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */
    Bodies.circle = function(x, y, radius, options, maxSides) {
        options = options || {};

        var circle = {
            label: 'Circle Body',
            circleRadius: radius
        };
        
        // approximate circles with polygons until true circles implemented in SAT
        maxSides = maxSides || 25;
        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));

        // optimisation: always use even number of sides (half the number of unique axes)
        if (sides % 2 === 1)
            sides += 1;

        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    };

    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */
    Bodies.polygon = function(x, y, sides, radius, options) {
        options = options || {};

        if (sides < 3)
            return Bodies.circle(x, y, radius, options);

        var theta = 2 * Math.PI / sides,
            path = '',
            offset = theta * 0.5;

        for (var i = 0; i < sides; i += 1) {
            var angle = offset + (i * theta),
                xx = Math.cos(angle) * radius,
                yy = Math.sin(angle) * radius;

            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
        }

        var polygon = { 
            label: 'Polygon Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(path)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, polygon, options));
    };

    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */
    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
        var body,
            parts,
            isConvex,
            vertices,
            i,
            j,
            k,
            v,
            z;

        options = options || {};
        parts = [];

        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;
        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;
        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;

        if (!decomp) {
            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');
        }

        // ensure vertexSets is an array of arrays
        if (!Common.isArray(vertexSets[0])) {
            vertexSets = [vertexSets];
        }

        for (v = 0; v < vertexSets.length; v += 1) {
            vertices = vertexSets[v];
            isConvex = Vertices.isConvex(vertices);

            if (isConvex || !decomp) {
                if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                } else {
                    // fallback to convex hull when decomposition is not possible
                    vertices = Vertices.hull(vertices);
                }

                parts.push({
                    position: { x: x, y: y },
                    vertices: vertices
                });
            } else {
                // initialise a decomposition
                var concave = vertices.map(function(vertex) {
                    return [vertex.x, vertex.y];
                });

                // vertices are concave and simple, we can decompose into parts
                decomp.makeCCW(concave);
                if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);

                // use the quick decomposition algorithm (Bayazit)
                var decomposed = decomp.quickDecomp(concave);

                // for each decomposed chunk
                for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];

                    // convert vertices into the correct structure
                    var chunkVertices = chunk.map(function(vertices) {
                        return {
                            x: vertices[0],
                            y: vertices[1]
                        };
                    });

                    // skip small chunks
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                        continue;

                    // create a compound part
                    parts.push({
                        position: Vertices.centre(chunkVertices),
                        vertices: chunkVertices
                    });
                }
            }
        }

        // create body parts
        for (i = 0; i < parts.length; i++) {
            parts[i] = Body.create(Common.extend(parts[i], options));
        }

        // flag internal edges (coincident part edges)
        if (flagInternal) {
            var coincident_max_dist = 5;

            for (i = 0; i < parts.length; i++) {
                var partA = parts[i];

                for (j = i + 1; j < parts.length; j++) {
                    var partB = parts[j];

                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices,
                            pbv = partB.vertices;

                        // iterate vertices of both parts
                        for (k = 0; k < partA.vertices.length; k++) {
                            for (z = 0; z < partB.vertices.length; z++) {
                                // find distances between the vertices
                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),
                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));

                                // if both vertices are very close, consider the edge concident (internal)
                                if (da < coincident_max_dist && db < coincident_max_dist) {
                                    pav[k].isInternal = true;
                                    pbv[z].isInternal = true;
                                }
                            }
                        }

                    }
                }
            }
        }

        if (parts.length > 1) {
            // create the parent body to be returned, that contains generated compound parts
            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));
            Body.setPosition(body, { x: x, y: y });

            return body;
        } else {
            return parts[0];
        }
    };

})();


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/

var Axes = {};

module.exports = Axes;

var Vector = __webpack_require__(8);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */
    Axes.fromVertices = function(vertices) {
        var axes = {};

        // find the unique axes, using edge normal gradients
        for (var i = 0; i < vertices.length; i++) {
            var j = (i + 1) % vertices.length, 
                normal = Vector.normalise({ 
                    x: vertices[j].y - vertices[i].y, 
                    y: vertices[i].x - vertices[j].x
                }),
                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);
            
            // limit precision
            gradient = gradient.toFixed(3).toString();
            axes[gradient] = normal;
        }

        return Common.values(axes);
    };

    /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */
    Axes.rotate = function(axes, angle) {
        if (angle === 0)
            return;
        
        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i],
                xx;
            xx = axis.x * cos - axis.y * sin;
            axis.y = axis.x * sin + axis.y * cos;
            axis.x = xx;
        }
    };

})();


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/

var Render = {};

module.exports = Render;

var Common = __webpack_require__(0);
var Composite = __webpack_require__(23);
var Bounds = __webpack_require__(7);
var Events = __webpack_require__(24);
var Grid = __webpack_require__(77);
var Vector = __webpack_require__(8);
var Mouse = __webpack_require__(79);

(function() {
    
    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */
    Render.create = function(options) {
        var defaults = {
            controller: Render,
            engine: null,
            element: null,
            canvas: null,
            mouse: null,
            frameRequestId: null,
            options: {
                width: 800,
                height: 600,
                pixelRatio: 1,
                background: '#18181d',
                wireframeBackground: '#0f0f13',
                hasBounds: !!options.bounds,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showSeparations: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false,
                showVertexNumbers: false,
                showConvexHulls: false,
                showInternalEdges: false,
                showMousePosition: false
            }
        };

        var render = Common.extend(defaults, options);

        if (render.canvas) {
            render.canvas.width = render.options.width || render.canvas.width;
            render.canvas.height = render.options.height || render.canvas.height;
        }

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
        render.context = render.canvas.getContext('2d');
        render.textures = {};

        render.bounds = render.bounds || { 
            min: { 
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.canvas.width,
                y: render.canvas.height
            }
        };

        if (render.options.pixelRatio !== 1) {
            Render.setPixelRatio(render, render.options.pixelRatio);
        }

        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');
        }

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */
    Render.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            Render.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */
    Render.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */
    Render.setPixelRatio = function(render, pixelRatio) {
        var options = render.options,
            canvas = render.canvas;

        if (pixelRatio === 'auto') {
            pixelRatio = _getPixelRatio(canvas);
        }

        options.pixelRatio = pixelRatio;
        canvas.setAttribute('data-pixel-ratio', pixelRatio);
        canvas.width = options.width * pixelRatio;
        canvas.height = options.height * pixelRatio;
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
        render.context.scale(pixelRatio, pixelRatio);
    };

    /**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */
    Render.lookAt = function(render, objects, padding, center) {
        center = typeof center !== 'undefined' ? center : true;
        objects = Common.isArray(objects) ? objects : [objects];
        padding = padding || {
            x: 0,
            y: 0
        };

        // find bounds of all objects
        var bounds = {
            min: { x: Infinity, y: Infinity },
            max: { x: -Infinity, y: -Infinity }
        };

        for (var i = 0; i < objects.length; i += 1) {
            var object = objects[i],
                min = object.bounds ? object.bounds.min : (object.min || object.position || object),
                max = object.bounds ? object.bounds.max : (object.max || object.position || object); 

            if (min && max) { 
                if (min.x < bounds.min.x) 
                    bounds.min.x = min.x;
                    
                if (max.x > bounds.max.x) 
                    bounds.max.x = max.x;

                if (min.y < bounds.min.y) 
                    bounds.min.y = min.y;

                if (max.y > bounds.max.y) 
                    bounds.max.y = max.y;
            }
        }

        // find ratios
        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,
            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,
            viewHeight = render.canvas.height,
            viewWidth = render.canvas.width,
            outerRatio = viewWidth / viewHeight,
            innerRatio = width / height,
            scaleX = 1,
            scaleY = 1;

        // find scale factor
        if (innerRatio > outerRatio) {
            scaleY = innerRatio / outerRatio;
        } else {
            scaleX = outerRatio / innerRatio;
        }

        // enable bounds
        render.options.hasBounds = true;

        // position and size
        render.bounds.min.x = bounds.min.x;
        render.bounds.max.x = bounds.min.x + width * scaleX;
        render.bounds.min.y = bounds.min.y;
        render.bounds.max.y = bounds.min.y + height * scaleY;

        // center
        if (center) {
            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;
            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;
        }

        // padding
        render.bounds.min.x -= padding.x;
        render.bounds.max.x -= padding.x;
        render.bounds.min.y -= padding.y;
        render.bounds.max.y -= padding.y;

        // update mouse
        if (render.mouse) {
            Mouse.setScale(render.mouse, {
                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
            });

            Mouse.setOffset(render.mouse, render.bounds.min);
        }
    };

    /**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */
    Render.startViewTransform = function(render) {
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        render.context.scale(1 / boundsScaleX, 1 / boundsScaleY);
        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
    };

    /**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */
    Render.endViewTransform = function(render) {
        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
    };

    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */
    Render.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            canvas = render.canvas,
            context = render.context,
            options = render.options,
            allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            background = options.wireframes ? options.wireframeBackground : options.background,
            bodies = [],
            constraints = [],
            i;

        var event = {
            timestamp: engine.timing.timestamp
        };

        Events.trigger(render, 'beforeRender', event);

        // apply background if it has changed
        if (render.currentBackground !== background)
            _applyBackground(render, background);

        // clear the canvas with a transparent fill, to allow the canvas background to show
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = "transparent";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.globalCompositeOperation = 'source-over';

        // handle bounds
        if (options.hasBounds) {
            // filter out bodies that are not in view
            for (i = 0; i < allBodies.length; i++) {
                var body = allBodies[i];
                if (Bounds.overlaps(body.bounds, render.bounds))
                    bodies.push(body);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            Render.startViewTransform(render);

            // update mouse
            if (render.mouse) {
                Mouse.setScale(render.mouse, {
                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                });

                Mouse.setOffset(render.mouse, render.bounds.min);
            }
        } else {
            constraints = allConstraints;
            bodies = allBodies;
        }

        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {
            // fully featured rendering of bodies
            Render.bodies(render, bodies, context);
        } else {
            if (options.showConvexHulls)
                Render.bodyConvexHulls(render, bodies, context);

            // optimised method for wireframes only
            Render.bodyWireframes(render, bodies, context);
        }

        if (options.showBounds)
            Render.bodyBounds(render, bodies, context);

        if (options.showAxes || options.showAngleIndicator)
            Render.bodyAxes(render, bodies, context);
        
        if (options.showPositions)
            Render.bodyPositions(render, bodies, context);

        if (options.showVelocity)
            Render.bodyVelocity(render, bodies, context);

        if (options.showIds)
            Render.bodyIds(render, bodies, context);

        if (options.showSeparations)
            Render.separations(render, engine.pairs.list, context);

        if (options.showCollisions)
            Render.collisions(render, engine.pairs.list, context);

        if (options.showVertexNumbers)
            Render.vertexNumbers(render, bodies, context);

        if (options.showMousePosition)
            Render.mousePosition(render, render.mouse, context);

        Render.constraints(constraints, context);

        if (options.showBroadphase && engine.broadphase.controller === Grid)
            Render.grid(render, engine.broadphase, context);

        if (options.showDebug)
            Render.debug(render, context);

        if (options.hasBounds) {
            // revert view transforms
            Render.endViewTransform(render);
        }

        Events.trigger(render, 'afterRender', event);
    };

    /**
     * Description
     * @private
     * @method debug
     * @param {render} render
     * @param {RenderingContext} context
     */
    Render.debug = function(render, context) {
        var c = context,
            engine = render.engine,
            world = engine.world,
            metrics = engine.metrics,
            options = render.options,
            bodies = Composite.allBodies(world),
            space = "    ";

        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
            var text = "";

            if (metrics.timing) {
                text += "fps: " + Math.round(metrics.timing.fps) + space;
            }

            // @if DEBUG
            if (metrics.extended) {
                if (metrics.timing) {
                    text += "delta: " + metrics.timing.delta.toFixed(3) + space;
                    text += "correction: " + metrics.timing.correction.toFixed(3) + space;
                }

                text += "bodies: " + bodies.length + space;

                if (engine.broadphase.controller === Grid)
                    text += "buckets: " + metrics.buckets + space;

                text += "\n";

                text += "collisions: " + metrics.collisions + space;
                text += "pairs: " + engine.pairs.list.length + space;
                text += "broad: " + metrics.broadEff + space;
                text += "mid: " + metrics.midEff + space;
                text += "narrow: " + metrics.narrowEff + space;
            }
            // @endif            

            render.debugString = text;
            render.debugTimestamp = engine.timing.timestamp;
        }

        if (render.debugString) {
            c.font = "12px Arial";

            if (options.wireframes) {
                c.fillStyle = 'rgba(255,255,255,0.5)';
            } else {
                c.fillStyle = 'rgba(0,0,0,0.5)';
            }

            var split = render.debugString.split('\n');

            for (var i = 0; i < split.length; i++) {
                c.fillText(split[i], 50, 50 + i * 18);
            }
        }
    };

    /**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */
    Render.constraints = function(constraints, context) {
        var c = context;

        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];

            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                continue;

            var bodyA = constraint.bodyA,
                bodyB = constraint.bodyB;

            if (bodyA) {
                c.beginPath();
                c.moveTo(bodyA.position.x + constraint.pointA.x, bodyA.position.y + constraint.pointA.y);
            } else {
                c.beginPath();
                c.moveTo(constraint.pointA.x, constraint.pointA.y);
            }

            if (bodyB) {
                c.lineTo(bodyB.position.x + constraint.pointB.x, bodyB.position.y + constraint.pointB.y);
            } else {
                c.lineTo(constraint.pointB.x, constraint.pointB.y);
            }

            if (constraint.render.lineWidth) {
                c.lineWidth = constraint.render.lineWidth;
                c.strokeStyle = constraint.render.strokeStyle;
                c.stroke();
            }
        }
    };
    
    /**
     * Description
     * @private
     * @method bodyShadows
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyShadows = function(render, bodies, context) {
        var c = context,
            engine = render.engine;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            if (body.circleRadius) {
                c.beginPath();
                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                c.closePath();
            } else {
                c.beginPath();
                c.moveTo(body.vertices[0].x, body.vertices[0].y);
                for (var j = 1; j < body.vertices.length; j++) {
                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                }
                c.closePath();
            }

            var distanceX = body.position.x - render.options.width * 0.5,
                distanceY = body.position.y - render.options.height * 0.2,
                distance = Math.abs(distanceX) + Math.abs(distanceY);

            c.shadowColor = 'rgba(0,0,0,0.15)';
            c.shadowOffsetX = 0.05 * distanceX;
            c.shadowOffsetY = 0.05 * distanceY;
            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);

            c.fill();

            c.shadowColor = null;
            c.shadowOffsetX = null;
            c.shadowOffsetY = null;
            c.shadowBlur = null;
        }
    };

    /**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodies = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            showInternalEdges = options.showInternalEdges || !options.wireframes,
            body,
            part,
            i,
            k;

        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                if (!part.render.visible)
                    continue;

                if (options.showSleeping && body.isSleeping) {
                    c.globalAlpha = 0.5 * part.render.opacity;
                } else if (part.render.opacity !== 1) {
                    c.globalAlpha = part.render.opacity;
                }

                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    // part sprite
                    var sprite = part.render.sprite,
                        texture = _getTexture(render, sprite.texture);

                    c.translate(part.position.x, part.position.y); 
                    c.rotate(part.angle);

                    c.drawImage(
                        texture,
                        texture.width * -sprite.xOffset * sprite.xScale, 
                        texture.height * -sprite.yOffset * sprite.yScale, 
                        texture.width * sprite.xScale, 
                        texture.height * sprite.yScale
                    );

                    // revert translation, hopefully faster than save / restore
                    c.rotate(-part.angle);
                    c.translate(-part.position.x, -part.position.y); 
                } else {
                    // part polygon
                    if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);

                        for (var j = 1; j < part.vertices.length; j++) {
                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                            } else {
                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                            }

                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                            }
                        }
                        
                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                    }

                    if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;

                        if (part.render.lineWidth) {
                            c.lineWidth = part.render.lineWidth;
                            c.strokeStyle = part.render.strokeStyle;
                            c.stroke();
                        }

                        c.fill();
                    } else {
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    }
                }

                c.globalAlpha = 1;
            }
        }
    };

    /**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyWireframes = function(render, bodies, context) {
        var c = context,
            showInternalEdges = render.options.showInternalEdges,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render all bodies
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                c.moveTo(part.vertices[0].x, part.vertices[0].y);

                for (j = 1; j < part.vertices.length; j++) {
                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                    } else {
                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                    }

                    if (part.vertices[j].isInternal && !showInternalEdges) {
                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                    }
                }
                
                c.lineTo(part.vertices[0].x, part.vertices[0].y);
            }
        }

        c.lineWidth = 1;
        c.strokeStyle = '#bbb';
        c.stroke();
    };

    /**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyConvexHulls = function(render, bodies, context) {
        var c = context,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render convex hulls
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible || body.parts.length === 1)
                continue;

            c.moveTo(body.vertices[0].x, body.vertices[0].y);

            for (j = 1; j < body.vertices.length; j++) {
                c.lineTo(body.vertices[j].x, body.vertices[j].y);
            }
            
            c.lineTo(body.vertices[0].x, body.vertices[0].y);
        }

        c.lineWidth = 1;
        c.strokeStyle = 'rgba(255,255,255,0.2)';
        c.stroke();
    };

    /**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.vertexNumbers = function(render, bodies, context) {
        var c = context,
            i,
            j,
            k;

        for (i = 0; i < bodies.length; i++) {
            var parts = bodies[i].parts;
            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {
                var part = parts[k];
                for (j = 0; j < part.vertices.length; j++) {
                    c.fillStyle = 'rgba(255,255,255,0.2)';
                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                }
            }
        }
    };

    /**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */
    Render.mousePosition = function(render, mouse, context) {
        var c = context;
        c.fillStyle = 'rgba(255,255,255,0.8)';
        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
    };

    /**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyBounds = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.render.visible) {
                var parts = bodies[i].parts;
                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,255,255,0.08)';
        } else {
            c.strokeStyle = 'rgba(0,0,0,0.1)';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyAxes = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            part,
            i,
            j,
            k;

        c.beginPath();

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                parts = body.parts;

            if (!body.render.visible)
                continue;

            if (options.showAxes) {
                // render all axes
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                }
            } else {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        // render a single axis indicator
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2, 
                                 (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);
                    }
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'indianred';
            c.lineWidth = 1;
        } else {
            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            c.globalCompositeOperation = 'overlay';
            c.lineWidth = 2;
        }

        c.stroke();
        c.globalCompositeOperation = 'source-over';
    };

    /**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyPositions = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            body,
            part,
            i,
            k;

        c.beginPath();

        // render current positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = 0; k < body.parts.length; k++) {
                part = body.parts[k];
                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'indianred';
        } else {
            c.fillStyle = 'rgba(0,0,0,0.5)';
        }
        c.fill();

        c.beginPath();

        // render previous positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];
            if (body.render.visible) {
                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        c.fillStyle = 'rgba(255,165,0,0.8)';
        c.fill();
    };

    /**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyVelocity = function(render, bodies, context) {
        var c = context;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            c.moveTo(body.position.x, body.position.y);
            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
        }

        c.lineWidth = 3;
        c.strokeStyle = 'cornflowerblue';
        c.stroke();
    };

    /**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyIds = function(render, bodies, context) {
        var c = context,
            i,
            j;

        for (i = 0; i < bodies.length; i++) {
            if (!bodies[i].render.visible)
                continue;

            var parts = bodies[i].parts;
            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                var part = parts[j];
                c.font = "12px Arial";
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.fillText(part.id, part.position.x + 10, part.position.y - 10);
            }
        }
    };

    /**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.collisions = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render collision positions
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            for (j = 0; j < pair.activeContacts.length; j++) {
                var contact = pair.activeContacts[j],
                    vertex = contact.vertex;
                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'rgba(255,255,255,0.7)';
        } else {
            c.fillStyle = 'orange';
        }
        c.fill();

        c.beginPath();
            
        // render collision normals
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;

            if (pair.activeContacts.length > 0) {
                var normalPosX = pair.activeContacts[0].vertex.x,
                    normalPosY = pair.activeContacts[0].vertex.y;

                if (pair.activeContacts.length === 2) {
                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                }
                
                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                } else {
                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                }

                c.lineTo(normalPosX, normalPosY);
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.7)';
        } else {
            c.strokeStyle = 'orange';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.separations = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render separations
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            bodyA = collision.bodyA;
            bodyB = collision.bodyB;

            var k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyB.isStatic) k = 0;

            c.moveTo(bodyB.position.x, bodyB.position.y);
            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);

            k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyA.isStatic) k = 0;

            c.moveTo(bodyA.position.x, bodyA.position.y);
            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.5)';
        } else {
            c.strokeStyle = 'orange';
        }
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */
    Render.grid = function(render, grid, context) {
        var c = context,
            options = render.options;

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,180,0,0.1)';
        } else {
            c.strokeStyle = 'rgba(255,180,0,0.5)';
        }

        c.beginPath();

        var bucketKeys = Common.keys(grid.buckets);

        for (var i = 0; i < bucketKeys.length; i++) {
            var bucketId = bucketKeys[i];

            if (grid.buckets[bucketId].length < 2)
                continue;

            var region = bucketId.split(/C|R/);
            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth, 
                    0.5 + parseInt(region[2], 10) * grid.bucketHeight, 
                    grid.bucketWidth, 
                    grid.bucketHeight);
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */
    Render.inspector = function(inspector, context) {
        var engine = inspector.engine,
            selected = inspector.selected,
            render = inspector.render,
            options = render.options,
            bounds;

        if (options.hasBounds) {
            var boundsWidth = render.bounds.max.x - render.bounds.min.x,
                boundsHeight = render.bounds.max.y - render.bounds.min.y,
                boundsScaleX = boundsWidth / render.options.width,
                boundsScaleY = boundsHeight / render.options.height;
            
            context.scale(1 / boundsScaleX, 1 / boundsScaleY);
            context.translate(-render.bounds.min.x, -render.bounds.min.y);
        }

        for (var i = 0; i < selected.length; i++) {
            var item = selected[i].data;

            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.9)';
            context.setLineDash([1,2]);

            switch (item.type) {

            case 'body':

                // render body selections
                bounds = item.bounds;
                context.beginPath();
                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), 
                             Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                context.closePath();
                context.stroke();

                break;

            case 'constraint':

                // render constraint selections
                var point = item.pointA;
                if (item.bodyA)
                    point = item.pointB;
                context.beginPath();
                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                context.closePath();
                context.stroke();

                break;

            }

            context.setLineDash([]);
            context.translate(-0.5, -0.5);
        }

        // render selection region
        if (inspector.selectStart !== null) {
            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.6)';
            context.fillStyle = 'rgba(255,165,0,0.1)';
            bounds = inspector.selectBounds;
            context.beginPath();
            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), 
                         Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
            context.closePath();
            context.stroke();
            context.fill();
            context.translate(-0.5, -0.5);
        }

        if (options.hasBounds)
            context.setTransform(1, 0, 0, 1, 0, 0);
    };

    /**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */
    var _createCanvas = function(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.oncontextmenu = function() { return false; };
        canvas.onselectstart = function() { return false; };
        return canvas;
    };

    /**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */
    var _getPixelRatio = function(canvas) {
        var context = canvas.getContext('2d'),
            devicePixelRatio = window.devicePixelRatio || 1,
            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio
                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio
                                      || context.backingStorePixelRatio || 1;

        return devicePixelRatio / backingStorePixelRatio;
    };

    /**
     * Gets the requested texture (an Image) via its path
     * @method _getTexture
     * @private
     * @param {render} render
     * @param {string} imagePath
     * @return {Image} texture
     */
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };

    /**
     * Applies the background to the canvas using CSS.
     * @method applyBackground
     * @private
     * @param {render} render
     * @param {string} background
     */
    var _applyBackground = function(render, background) {
        var cssBackground = background;

        if (/(jpg|gif|png)$/.test(background))
            cssBackground = 'url(' + background + ')';

        render.canvas.style.background = cssBackground;
        render.canvas.style.backgroundSize = "contain";
        render.currentBackground = background;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */

    /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */

    /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */

    /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */

    /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */

    /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */

    /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */

    /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */

    /**
     * A `Bounds` object that specifies the drawing view region. 
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */

    /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */

    /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */

})();


/***/ },
/* 83 */
/***/ function(module, exports) {

module.exports = {

    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16

};


/***/ },
/* 84 */
/***/ function(module, exports) {

var Buffer16 = function (byteSize)
{
    this.wordLength = 0;
    this.wordCapacity = byteSize / 2;
    this.buffer = new ArrayBuffer(byteSize);
    this.intView = new Int16Array(this.buffer);
    this.uintView = new Uint16Array(this.buffer);
};

Buffer16.prototype.clear = function ()
{
    this.wordLength = 0;
};

Buffer16.prototype.getByteLength = function ()
{
    return this.wordLength * 2;
};

Buffer16.prototype.getByteCapacity = function () 
{
    return this.buffer.byteLength;
};

Buffer16.prototype.allocate = function (wordSize)
{
    var currentLength = this.wordLength;
    this.wordLength += wordSize;
    return currentLength;
};

Buffer16.prototype.getUsedBufferAsShort = function ()
{
    return this.intView.subarray(0, this.wordLength);
};

Buffer16.prototype.getUsedBufferAsWord = function ()
{
    return this.uintView.subarray(0, this.wordLength);
};

module.exports = Buffer16;


/***/ },
/* 85 */
/***/ function(module, exports) {


var NOOP = function ()
{
    //  NOOP (No Operation) Callback
};

module.exports = NOOP;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Actions

module.exports = {

    Angle: __webpack_require__(219),
    Call: __webpack_require__(220),
    GridAlign: __webpack_require__(221),
    IncAlpha: __webpack_require__(222),
    IncX: __webpack_require__(223),
    IncXY: __webpack_require__(224),
    IncY: __webpack_require__(225),
    PlaceOnCircle: __webpack_require__(226),
    PlaceOnLine: __webpack_require__(227),
    PlaceOnRectangle: __webpack_require__(228),
    PlaceOnTriangle: __webpack_require__(229),
    RandomCircle: __webpack_require__(230),
    RandomEllipse: __webpack_require__(231),
    RandomLine: __webpack_require__(232),
    RandomRectangle: __webpack_require__(233),
    RandomTriangle: __webpack_require__(234),
    Rotate: __webpack_require__(235),
    RotateAround: __webpack_require__(236),
    RotateAroundDistance: __webpack_require__(237),
    ScaleX: __webpack_require__(238),
    ScaleXY: __webpack_require__(239),
    ScaleY: __webpack_require__(240),
    SetAlpha: __webpack_require__(241),
    SetOrigin: __webpack_require__(242),
    SetRotation: __webpack_require__(243),
    SetScale: __webpack_require__(244),
    SetScaleX: __webpack_require__(245),
    SetScaleY: __webpack_require__(246),
    SetVisible: __webpack_require__(247),
    SetX: __webpack_require__(248),
    SetXY: __webpack_require__(249),
    SetY: __webpack_require__(250),
    SmootherStep: __webpack_require__(252),
    SmoothStep: __webpack_require__(251),
    Spread: __webpack_require__(253),
    ToggleVisible: __webpack_require__(254)

};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

var RND = __webpack_require__(558);

module.exports = {

    //  CONSTs (makes them visible under Phaser.Math)
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1.0e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,

    //  Collections of functions
    Angle: __webpack_require__(530),
    Distance: __webpack_require__(533),
    Easing: __webpack_require__(545),
    Fuzzy: __webpack_require__(551),
    Interpolation: __webpack_require__(554),
    Pow2: __webpack_require__(557),
    Snap: __webpack_require__(562),

    //  Random Data Generator
    RND: new RND(),

    //  Single functions
    Average: __webpack_require__(508),
    Bernstein: __webpack_require__(162),
    Between: __webpack_require__(73),
    CatmullRom: __webpack_require__(163),
    CeilTo: __webpack_require__(509),
    Clamp: __webpack_require__(164),
    DegToRad: __webpack_require__(510),
    Difference: __webpack_require__(511),
    Factorial: __webpack_require__(165),
    FloatBetween: __webpack_require__(512),
    FloorTo: __webpack_require__(513),
    Linear: __webpack_require__(166),
    MaxAdd: __webpack_require__(514),
    MinSub: __webpack_require__(515),
    Percent: __webpack_require__(516),
    RadToDeg: __webpack_require__(517),
    Rotate: __webpack_require__(518),
    RotateAround: __webpack_require__(519),
    RotateAroundDistance: __webpack_require__(74),
    RoundAwayFromZero: __webpack_require__(167),
    RoundTo: __webpack_require__(520),
    SinCosTableGenerator: __webpack_require__(521),
    SmootherStep: __webpack_require__(169),
    SmoothStep: __webpack_require__(168),
    Within: __webpack_require__(522),
    Wrap: __webpack_require__(46)

};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Systems = __webpack_require__(184);

/**
* A Base State Class.
*
* @class Phaser.State
* @constructor
*/
var State = function (config)
{
    //  The State Systems. You must never overwrite this property, or all hell will break lose.
    this.sys = new Systems(this, config);

    this.settings = this.sys.settings;
};

State.prototype.constructor = State;

State.prototype = {

    //  Should be overridden by your own States
    update: function ()
    {
    },

    //  Should be overridden by your own States
    render: function ()
    {
    }

};

module.exports = State;


/***/ },
/* 89 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 90 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 91 */
/***/ function(module, exports) {

var GetContext = function (canvas, options)
{
    return (
        canvas.getContext('2d', options) || 
        null
    );
};

module.exports = GetContext;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Event = __webpack_require__(10);
var EventDispatcher = __webpack_require__(26);

/**
* The Data Component features a means to store pieces of data specific to a Game Object,
* search it, query it, and retrieve it.
*
* @class
*/
var Data = function (parent)
{
    this.parent = parent;

    this.events = new EventDispatcher();

    this.list = {};

    this._beforeCallbacks = {};
    this._afterCallbacks = {};

    this._frozen = false;
};

Data.prototype.constructor = Data;

Data.prototype = {

    //  Retrieves the value for the given key, or undefined if it doesn't exist.
    get: function (key)
    {
        return this.list[key];
    },

    getAll: function ()
    {
        var results = {};

        for (var key in this.list)
        {
            results[key] = this.list[key];
        }

        return results;
    },

    query: function (search)
    {
        var results = {};

        for (var key in this.list)
        {
            if (key.match(search))
            {
                results[key] = this.list[key];
            }
        }

        return results;
    },

    set: function (key, data)
    {
        if (this._frozen)
        {
            return this;
        }

        var listener;
        var result;

        //  If there is a 'before' callback, then check it for a result
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            listener = this._beforeCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                data = result;
            }
        }

        // this.events.dispatch(new Event.LOADER_START_EVENT(this));

        this.list[key] = data;

        //  If there is a 'after' callback, then check it for a result
        if (this._afterCallbacks.hasOwnProperty(key))
        {
            listener = this._afterCallbacks[key];

            result = listener.callback.call(listener.scope, this.parent, key, data);

            if (result !== undefined)
            {
                this.list[key] = result;
            }
        }

        return this;
    },

    before: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._beforeCallbacks[key];
        }
        else
        {
            this._beforeCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    after: function (key, callback, scope)
    {
        if (callback === undefined)
        {
            //  Remove entry
            delete this._afterCallbacks[key];
        }
        else
        {
            this._afterCallbacks[key] = { callback: callback, scope: scope };
        }
    },

    /**
    * Passes all data entries to the given callback. Stores the result of the callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [scope] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the game object, key, and data.
    */
    each: function (callback, scope)
    {
        var args = [ this.parent, null, undefined ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var key in this.list)
        {
            args[1] = key;
            args[2] = this.list[key];

            callback.apply(scope, args);
        }
    },

    merge: function (data, overwrite)
    {
        if (overwrite === undefined) { overwrite = true; }

        //  Merge data from another component into this one
        for (var key in data)
        {
            if (overwrite || (!overwrite && !this.has(key)))
            {
                this.list[key] = data;
            }
        }
    },

    remove: function (key)
    {
        if (!this._frozen && this.has(key))
        {
            delete this.list[key];

            this.removeListeners(key);
        }
    },

    removeListeners: function (key)
    {
        if (this._beforeCallbacks.hasOwnProperty(key))
        {
            delete this._beforeCallbacks[key];
        }

        if (this._afterCallbacks.hasOwnProperty(key))
        {
            delete this._afterCallbacks[key];
        }
    },

    //  Gets the data associated with the given 'key', deletes it from this Data store, then returns it.
    pop: function (key)
    {
        var data = undefined;

        if (!this._frozen && this.has(key))
        {
            data = this.list[key];

            delete this.list[key];

            this.removeListeners(key);
        }

        return data;
    },

    has: function (key)
    {
        return this.list.hasOwnProperty(key);
    },

    reset: function ()
    {
        for (var key in this.list)
        {
            delete this.list[key];
        }

        for (key in this._beforeCallbacks)
        {
            delete this._beforeCallbacks[key];
        }

        for (key in this._afterCallbacks)
        {
            delete this._afterCallbacks[key];
        }

        this._frozen = false;
    }

};

Object.defineProperties(Data.prototype, {

    /**
    * Freeze this Data component, so no changes can be written to it.
    *
    * @name freeze
    * @property {boolean} freeze
    */
    freeze: {

        enumerable: true,

        get: function ()
        {
            return this._frozen;
        },

        set: function (value)
        {
            this._frozen = (value) ? true : false;
        }

    },

    count: {

        enumerable: true,

        get: function ()
        {
            var i = 0;

            for (var key in this.list)
            {
                if (this.list[key] !== undefined)
                {
                    i++;
                }
            }

            return i;
        }

    }

});

module.exports = Data;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(22);

var CanvasFeatures = {

    supportNewBlendModes: false,

    supportInverseAlpha: false

};

function checkBlendMode ()
{
    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

    var magenta = new Image();
    magenta.src = pngHead + 'AP804Oa6' + pngEnd;

    var yellow = new Image();
    yellow.src = pngHead + '/wCKxvRF' + pngEnd;

    var canvas = CanvasPool.create(this, 6, 1);
    var context = canvas.getContext('2d');

    context.globalCompositeOperation = 'multiply';
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);

    if (!context.getImageData(2, 0, 1, 1))
    {
        return false;
    }

    var data = context.getImageData(2, 0, 1, 1).data;

    CanvasPool.remove(this);

    return (data[0] === 255 && data[1] === 0 && data[2] === 0);
}

function checkInverseAlpha ()
{
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext('2d');

    context.fillStyle = 'rgba(10, 20, 30, 0.5)';

    //  Draw a single pixel
    context.fillRect(0, 0, 1, 1);

    //  Get the color values
    var s1 = context.getImageData(0, 0, 1, 1);

    if (s1 === null)
    {
        return false;
    }

    //  Plot them to x2
    context.putImageData(s1, 1, 0);

    //  Get those values
    var s2 = context.getImageData(1, 0, 1, 1);

    //  Compare and return
    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);
}

function init ()
{
    if (document !== undefined)
    {
        CanvasFeatures.supportNewBlendModes = checkBlendMode();
        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }

    return CanvasFeatures;
}

module.exports = init();


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);
var CanvasPool = __webpack_require__(22);

var Features = {

    /**
    * @property {boolean} canvas - Is canvas available?
    * @default
    */
    canvas: false,

    /**
    * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
    * @default
    */
    canvasBitBltShift: null,

    /**
    * @property {boolean} webGL - Is webGL available?
    * @default
    */
    webGL: false,

    /**
    * @property {boolean} file - Is file available?
    * @default
    */
    file: false,

    /**
    * @property {boolean} fileSystem - Is fileSystem available?
    * @default
    */
    fileSystem: false,

    /**
    * @property {boolean} localStorage - Is localStorage available?
    * @default
    */
    localStorage: false,

    /**
    * @property {boolean} worker - Is worker available?
    * @default
    */
    worker: false,

    /**
    * @property {boolean} pointerLock - Is Pointer Lock available?
    * @default
    */
    pointerLock: false,

    /**
    * @property {boolean} vibration - Does the device support the Vibration API?
    * @default
    */
    vibration: false,

    /**
    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
    * @default
    */
    getUserMedia: true,

    /**
    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
    * @default
    */
    littleEndian: false,

    /**
    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
    * @default
    */
    support32bit: false

};

/**
* Check Little or Big Endian system.
*
* @author Matt DesLauriers (@mattdesl)
*/
function checkIsLittleEndian ()
{
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);

    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;

    if (c[0] === 0xd4c3b2a1)
    {
        return true;
    }

    if (c[0] === 0xa1b2c3d4)
    {
        return false;
    }
    else
    {
        //  Could not determine endianness
        return null;
    }
}

function init ()
{
    Features.canvas = !!window['CanvasRenderingContext2D'] || OS.cocoonJS;

    try
    {
        Features.localStorage = !!localStorage.getItem;
    }
    catch (error)
    {
        Features.localStorage = false;
    }

    Features.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
    Features.fileSystem = !!window['requestFileSystem'];

    var isUint8 = false;

    var testWebGL = function ()
    {
        if (window['WebGLRenderingContext'])
        {
            try
            {
                var canvas = CanvasPool.createWebGL(this);

                if (OS.cocoonJS)
                {
                    canvas.screencanvas = false;
                }

                var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                var canvas2D = CanvasPool.create2D(this);

                var ctx2D = canvas2D.getContext('2d');

                //  Can't be done on a webgl context
                var image = ctx2D.createImageData(1, 1);
    
                /**
                * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.
                *
                * @author Matt DesLauriers (@mattdesl)
                */
                isUint8 = image.data instanceof Uint8ClampedArray;

                CanvasPool.remove(canvas);
                CanvasPool.remove(canvas2D);

                return (ctx !== null);
            }
            catch (e)
            {
                return false;
            }
        }
        
        return false;
    };

    Features.webGL = true;//testWebGL();

    Features.worker = !!window['Worker'];

    Features.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;

    // Older versions of firefox (< 21) apparently claim support but user media does not actually work
    if (Browser.firefox && Browser.firefoxVersion < 21)
    {
        Features.getUserMedia = false;
    }

    // Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it
    // is safer to not try and use the fast copy-over method.
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome))
    {
        Features.canvasBitBltShift = true;
    }

    // Known not to work
    if (Browser.safari || Browser.mobileSafari)
    {
        Features.canvasBitBltShift = false;
    }

    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

    if (navigator.vibrate)
    {
        Features.vibration = true;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')
    {
        Features.littleEndian = checkIsLittleEndian();
    }

    Features.support32bit = (
        typeof ArrayBuffer !== 'undefined' &&
        typeof Uint8ClampedArray !== 'undefined' &&
        typeof Int32Array !== 'undefined' &&
        Features.littleEndian !== null &&
        isUint8
    );

    return Features;
}

module.exports = init();


/***/ },
/* 95 */
/***/ function(module, exports) {

var AddToDOM = function (element, parent, overflowHidden)
{
    if (overflowHidden === undefined) { overflowHidden = true; }

    var target;

    if (parent)
    {
        if (typeof parent === 'string')
        {
            //  Hopefully an element ID
            target = document.getElementById(parent);
        }
        else if (typeof parent === 'object' && parent.nodeType === 1)
        {
            //  Quick test for a HTMLelement
            target = parent;
        }
    }

    //  Fallback, covers an invalid ID and a non HTMLelement object
    if (!target)
    {
        target = document.body;
    }

    if (overflowHidden && target.style)
    {
        target.style.overflow = 'hidden';
    }

    target.appendChild(element);

    return element;
};

module.exports = AddToDOM;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var OS = __webpack_require__(21);

var isBooted = false;

var DOMContentLoaded = function (callback)
{
    if (isBooted)
    {
        return;
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive')
    {
        isBooted = true;
        
        callback();

        return;
    }

    var check = function ()
    {
        isBooted = true;

        document.removeEventListener('deviceready', check, true);
        document.removeEventListener('DOMContentLoaded', check, true);
        window.removeEventListener('load', check, true);

        callback();
    };

    if (!document.body)
    {
        window.setTimeout(check, 20);
    }
    else if (OS.cordova && !OS.cocoonJS)
    {
        //  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready
        document.addEventListener('deviceready', check, false);
    }
    else
    {
        document.addEventListener('DOMContentLoaded', check, true);
        window.addEventListener('load', check, true);
    }
};

module.exports = DOMContentLoaded;


/***/ },
/* 97 */
/***/ function(module, exports) {

var ParseXML = function (data)
{
    var xml = '';

    try
    {
        if (window['DOMParser'])
        {
            var domparser = new DOMParser();
            xml = domparser.parseFromString(data, 'text/xml');
        }
        else
        {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.loadXML(data);
        }
    }
    catch (e)
    {
        xml = null;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)
    {
        return null;
    }
    else
    {
        return xml;
    }
};

module.exports = ParseXML;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var NOOP = __webpack_require__(85);

/**
* Abstracts away the use of RAF or setTimeOut for the core game update loop.
*
* @class Phaser.RequestAnimationFrame
* @constructor
* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
*/
var RequestAnimationFrame = function ()
{
    /**
    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.
    * @default
    */
    this.isRunning = false;

    this.callback = NOOP;

    this.tick = 0;

    /**
    * @property {boolean} isSetTimeOut  - True if the browser is using setTimeout instead of rAf.
    */
    this.isSetTimeOut = false;

    /**
    * @property {number} timeOutID - The callback setTimeout or rAf callback ID used when calling cancel.
    */
    this.timeOutID = null;

    var _this = this;

    //  timestamp = DOMHighResTimeStamp
    var step = function (timestamp)
    {
        _this.tick = timestamp;

        _this.timeOutID = window.requestAnimationFrame(step);

        _this.callback(timestamp);
    };

    var stepTimeout = function ()
    {
        var d = Date.now();

        _this.tick = d;

        _this.timeOutID = window.setTimeout(stepTimeout, _this.timeToCall);

        _this.callback(d);
    };

    this.step = step;
    this.stepTimeout = stepTimeout;
};

RequestAnimationFrame.prototype.constructor = RequestAnimationFrame;

RequestAnimationFrame.prototype = {

    /**
    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
    * @method Phaser.RequestAnimationFrame#start
    */
    start: function (callback, forceSetTimeOut)
    {
        this.callback = callback;

        this.isSetTimeOut = forceSetTimeOut;

        this.isRunning = true;

        var _this = this;

        this.timeOutID = (forceSetTimeOut) ? window.setTimeout(_this.stepTimeout, 0) : window.requestAnimationFrame(_this.step);
    },

    /**
    * Stops the requestAnimationFrame from running.
    * @method Phaser.RequestAnimationFrame#stop
    */
    stop: function ()
    {
        this.isRunning = false;

        if (this.isSetTimeOut)
        {
            clearTimeout(this.timeOutID);
        }
        else
        {
            window.cancelAnimationFrame(this.timeOutID);
        }
    },

    destroy: function ()
    {
        this.stop();

        this.callback = NOOP;
    }

};

module.exports = RequestAnimationFrame;


/***/ },
/* 99 */
/***/ function(module, exports) {

var EVENT_CONST = {

    DISPATCHER_IDLE: 0,
    DISPATCHER_DISPATCHING: 1,
    DISPATCHER_REMOVING: 2,
    DISPATCHER_DESTROYED: 3,

    LISTENER_PENDING: 4,
    LISTENER_ACTIVE: 5,
    LISTENER_REMOVING: 6

};

module.exports = EVENT_CONST;


/***/ },
/* 100 */
/***/ function(module, exports) {


var GetBitmapTextSize = function (src)
{
    var text = src.text;
    var textLength = text.length;

    var bx = Number.MAX_VALUE;
    var by = Number.MAX_VALUE;
    var bw = 0;
    var bh = 0;
    
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (bx > x)
        {
            bx = x;
        }

        if (by > y)
        {
            by = y;
        }

        var gw = x + glyphW - bx;
        var gh = y + glyphH - by;

        if (bw < gw)
        {
            bw = gw;
        }
        
        if (bh < gh)
        {
            bh = gh;
        }

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    var scale = (src.fontSize / src.fontData.size);
    var sx = scale * src.scaleX;
    var sy = scale * src.scaleY;

    return {
        local: {
            x: bx * scale,
            y: by * scale,
            width: bw * scale,
            height: bh * scale
        },
        global: {
            x: src.x + (bx * sx),
            y: src.y + (by * sy),
            width: bw * sx,
            height: bh * sy
        }
    };
};

module.exports = GetBitmapTextSize;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var Render = __webpack_require__(296);
var GetBitmapTextSize = __webpack_require__(100);

var DynamicBitmapText = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.RenderPass,
        Components.Visible,
        Render
    ],

    initialize:

    function DynamicBitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (size === undefined) { size = 32; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state);

        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = text;

        this.fontSize = size;

        this.displayCallback;

        this.setTexture(font);
        this.setPosition(x, y);
        this.initRenderPassComponent();
    },

    setDisplayCallback: function (callback)
    {
        this.displayCallback = callback;

        return this;
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    }

});

module.exports = DynamicBitmapText;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var Render = __webpack_require__(300);
var GetBitmapTextSize = __webpack_require__(100);

var BitmapText = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Origin,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.RenderPass,
        Components.Visible,
        Render
    ],

    initialize:

    function BitmapText (state, x, y, font, text, size, align)
    {
        if (text === undefined) { text = ''; }
        if (size === undefined) { size = 32; }
        if (align === undefined) { align = 'left'; }

        GameObject.call(this, state);

        this.fontData = this.state.sys.cache.bitmapFont.get(font);

        this.text = text;

        this.fontSize = size;

        this.setTexture(font);
        this.setPosition(x, y);
        this.setOrigin(0, 0);
        this.initRenderPassComponent();
    },

    setFontSize: function (size)
    {
        this.fontSize = size;

        return this;
    },

    setText: function (text)
    {
        this.text = text;

        return this;
    },

    // {
    //     local: {
    //         x,
    //         y,
    //         width,
    //         height
    //     },
    //     global: {
    //         x,
    //         y,
    //         width,
    //         height
    //     }
    // }

    getTextBounds: function ()
    {
        //  local = the BitmapText based on fontSize and 0x0 coords
        //  global = the BitmapText, taking into account scale and world position

        return GetBitmapTextSize(this);
    }

});

module.exports = BitmapText;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var BlitterRender = __webpack_require__(304);
var Bob = __webpack_require__(306);

/**
* A Blitter Game Object.
*
* The Blitter Game Object is a special type of Container, that contains Blitter.Bob objects.
* These objects can be thought of as just texture frames with a position and nothing more.
* Bobs don't have any update methods, or the ability to have children, or any kind of special effects.
* They are essentially just super-fast texture frame renderers, and the Blitter object creates and manages them.
*
* @class Blitter
* @extends Phaser.GameObject
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
* @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
* @param {string} [key] - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
* @param {string|number} [frame] - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
*/

var Blitter = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.RenderPass,
        Components.Visible,
        BlitterRender
    ],

    initialize:

    function Blitter (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);

        this.children = new Components.Children(this);

        this.renderList = [];

        this.dirty = false;
        this.initRenderPassComponent();
    },

    //  frame MUST be part of the Blitter texture
    create: function (x, y, frame, visible, index)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }
        if (index === undefined) { index = this.children.length; }

        if (typeof frame === 'string')
        {
            frame = this.texture.get(frame);
        }

        var bob = new Bob(this, x, y, frame, visible);

        this.children.addAt(bob, index, false);

        this.dirty = true;

        return bob;
    },

    //  frame MUST be part of the Blitter texture
    createFromCallback: function (callback, quantity, frame, visible)
    {
        var bobs = this.createMultiple(quantity, frame, visible);

        for (var i = 0; i < bobs.length; i++)
        {
            var bob = bobs[i];

            callback.call(this, bob, i);
        }

        return bobs;
    },

    //  frame MUST be part of the Blitter texture
    createMultiple: function (quantity, frame, visible)
    {
        if (frame === undefined) { frame = this.frame; }
        if (visible === undefined) { visible = true; }

        if (!Array.isArray(frame))
        {
            frame = [ frame ];
        }

        var bobs = [];
        var _this = this;

        frame.forEach(function (singleFrame)
        {
            for (var i = 0; i < quantity; i++)
            {
                bobs.push(_this.create(0, 0, singleFrame, visible));
            }
        });

        return bobs;
    },

    childCanRender: function (child)
    {
        return (child.visible && child.alpha > 0);
    },

    getRenderList: function ()
    {
        if (this.dirty)
        {
            this.renderList = this.children.list.filter(this.childCanRender, this);
            this.dirty = false;
        }

        return this.renderList;
    },

    clear: function ()
    {
        this.children.removeAll();
        this.dirty = true;
    }

});

module.exports = Blitter;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var ContainerRender = __webpack_require__(309);

var Container = new Class({

    Mixins: [
        Components.Visible,
        ContainerRender
    ],

    initialize:

    function Container (state)
    {
        GameObject.call(this, state);

        this.children = new Components.Children(this);
    }

});

module.exports = Container;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var Render = __webpack_require__(313);
var Commands = __webpack_require__(57);
var MATH_CONST = __webpack_require__(6);
var GetObjectValue = __webpack_require__(9);

var Graphics = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Transform,
        Components.RenderPass,
        Components.Visible,
        Render
    ],

    initialize:

    function Graphics (state, options)
    {
        var x = GetObjectValue(options, 'x', 0);
        var y = GetObjectValue(options, 'y', 0);

        GameObject.call(this, state);

        this.setPosition(x, y);

        this.commandBuffer = [];
        this.initRenderPassComponent();

        this.defaultFillColor = -1;
        this.defaultFillAlpha = 1;

        this.defaultStrokeWidth = 1;
        this.defaultStrokeColor = -1;
        this.defaultStrokeAlpha = 1;

        this.setDefaultStyles(options);
    },

    //  STYLES

    setDefaultStyles: function (options)
    {
        if (GetObjectValue(options, 'lineStyle', null))
        {
            this.defaultStrokeWidth = GetObjectValue(options, 'lineStyle.width', 1);
            this.defaultStrokeColor = GetObjectValue(options, 'lineStyle.color', 0xffffff);
            this.defaultStrokeAlpha = GetObjectValue(options, 'lineStyle.alpha', 1);

            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        if (GetObjectValue(options, 'fillStyle', null))
        {
            this.defaultFillColor = GetObjectValue(options, 'fillStyle.color', 0xffffff);
            this.defaultFillAlpha = GetObjectValue(options, 'fillStyle.alpha', 1);

            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        return this;
    },

    lineStyle: function (lineWidth, color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.LINE_STYLE,
            lineWidth, color, alpha
        );

        return this;
    },

    fillStyle: function (color, alpha)
    {
        if (alpha === undefined) { alpha = 1; }

        this.commandBuffer.push(
            Commands.FILL_STYLE,
            color, alpha
        );

        return this;
    },

    //  PATH

    beginPath: function ()
    {
        this.commandBuffer.push(
            Commands.BEGIN_PATH
        );

        return this;
    },

    closePath: function ()
    {
        this.commandBuffer.push(
            Commands.CLOSE_PATH
        );

        return this;
    },

    fillPath: function ()
    {
        this.commandBuffer.push(
            Commands.FILL_PATH
        );

        return this;
    },

    strokePath: function ()
    {
        this.commandBuffer.push(
            Commands.STROKE_PATH
        );

        return this;
    },

    //  CIRCLE

    fillCircleShape: function (circle)
    {
        return this.fillCircle(circle.x, circle.y, circle.radius);
    },

    strokeCircleShape: function (circle)
    {
        return this.strokeCircle(circle.x, circle.y, circle.radius);
    },

    fillCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.fillPath();
        this.closePath();

        return this;
    },

    strokeCircle: function (x, y, radius)
    {
        this.beginPath();
        this.arc(x, y, radius, 0, MATH_CONST.PI2);
        this.closePath();
        this.strokePath();

        return this;
    },

    //  RECTANGLE

    fillRectShape: function (rect)
    {
        return this.fillRect(rect.x, rect.y, rect.width, rect.height);
    },

    strokeRectShape: function (rect)
    {
        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
    },

    fillRect: function (x, y, width, height)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, width, height
        );

        return this;
    },

    strokeRect: function (x, y, width, height)
    {
        this.beginPath();
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.strokePath();
        this.closePath();

        return this;
    },

    //  POINT

    fillPointShape: function (point, size)
    {
        return this.fillPoint(point.x, point.y, size);
    },

    fillPoint: function (x, y, size)
    {
        this.commandBuffer.push(
            Commands.FILL_RECT,
            x, y, size, size
        );

        return this;
    },

    //  TRIANGLE

    fillTriangleShape: function (triangle)
    {
        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    strokeTriangleShape: function (triangle)
    {
        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },

    fillTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.FILL_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    strokeTriangle: function (x0, y0, x1, y1, x2, y2)
    {
        this.commandBuffer.push(
            Commands.STROKE_TRIANGLE,
            x0, y0, x1, y1, x2, y2
        );

        return this;
    },

    //  LINE

    strokeLineShape: function (line)
    {
        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
    },

    lineBetween: function (x1, y1, x2, y2)
    {
        this.beginPath();
        this.moveTo(x1, y1);
        this.lineTo(x2, y2);
        this.strokePath();
        this.closePath();

        return this;
    },

    lineTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.LINE_TO,
            x, y
        );

        return this;
    },

    moveTo: function (x, y)
    {
        this.commandBuffer.push(
            Commands.MOVE_TO,
            x, y
        );

        return this;
    },

    lineFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.LINE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    moveFxTo: function (x, y, width, rgb)
    {
        this.commandBuffer.push(
            Commands.MOVE_FX_TO,
            x, y, width, rgb, 1
        );

        return this;
    },

    //  ARC

    arc: function (x, y, radius, startAngle, endAngle, anticlockwise)
    {
        this.commandBuffer.push(
            Commands.ARC,
            x, y, radius, startAngle, endAngle, anticlockwise
        );

        return this;
    },

    clear: function ()
    {
        this.commandBuffer.length = 0;

        if (this.defaultFillColor > -1)
        {
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
        }

        if (this.defaultStrokeColor > -1)
        {
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
        }

        return this;
    }

});

module.exports = Graphics;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var ImageRender = __webpack_require__(317);

var Image = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.Flip,
        Components.GetBounds,
        Components.Origin,
        Components.RenderPass,
        Components.ScaleMode,
        Components.Size,
        Components.Texture,
        Components.Transform,
        Components.Visible,
        ImageRender
    ],

    initialize:

    function Image (state, x, y, texture, frame)
    {
        GameObject.call(this, state);

        this.setTexture(texture, frame);
        this.setPosition(x, y);
        this.setSizeToFrame();
        this.setOrigin();
        this.initRenderPassComponent();
    }

});

module.exports = Image;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var Set = __webpack_require__(185);
var GetObjectValue = __webpack_require__(9);
var Range = __webpack_require__(198);
var Actions = __webpack_require__(86);
var Sprite = __webpack_require__(58);

var Layer = new Class({

    initialize:

    function Layer (state, children)
    {
        this.state = state;

        this.children = new Set(children);

        this.classType = Sprite;
    },

    //  Layer management methods:

    add: function (child)
    {
        this.children.set(child);

        return this;
    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.children.set(children[i]);
            }
        }

        return this;
    },

    create: function (x, y, key, frame, visible)
    {
        if (visible === undefined) { visible = true; }

        var child = this.state.children.add(new this.classType(this.state, x, y, key, frame));

        child.visible = visible;

        this.add(child);

        return child;
    },

    createFromConfig: function (options)
    {
        var key = GetObjectValue(options, 'key', undefined);
        var frame = GetObjectValue(options, 'frame', null);
        var visible = GetObjectValue(options, 'visible', true);

        var entries = [];

        //  Can't do anything without at least a key
        if (key === undefined)
        {
            return entries;
        }
        else
        {
            if (!Array.isArray(key))
            {
                key = [ key ];
            }

            if (!Array.isArray(frame))
            {
                frame = [ frame ];
            }
        }

        //  Build an array of key frame pairs to loop through

        var repeat = GetObjectValue(options, 'repeat', 0);
        var randomKey = GetObjectValue(options, 'randomKey', false);
        var randomFrame = GetObjectValue(options, 'randomFrame', false);
        var yoyo = GetObjectValue(options, 'yoyo', false);
        var quantity = GetObjectValue(options, 'frameQuantity', 1);
        var max = GetObjectValue(options, 'max', 0);

        var range = Range(key, frame, {
            max: max,
            qty: quantity,
            random: randomKey,
            randomB: randomFrame,
            repeat: repeat,
            yoyo: yoyo
        });

        for (var c = 0; c < range.length; c++)
        {
            entries.push(this.create(0, 0, range[c].a, range[c].b, visible));
        }

        //  Post-creation options (applied only to those items created in this call):

        var x = GetObjectValue(options, 'setXY.x', 0);
        var y = GetObjectValue(options, 'setXY.y', 0);
        var stepX = GetObjectValue(options, 'setXY.stepX', 0);
        var stepY = GetObjectValue(options, 'setXY.stepY', 0);

        Actions.SetXY(entries, x, y, stepX, stepY);

        var rotation = GetObjectValue(options, 'setRotation.value', 0);
        var stepRotation = GetObjectValue(options, 'setRotation.step', 0);

        Actions.SetRotation(entries, rotation, stepRotation);

        var scaleX = GetObjectValue(options, 'setScale.x', 1);
        var scaleY = GetObjectValue(options, 'setScale.y', scaleX);
        var stepScaleX = GetObjectValue(options, 'setScale.stepX', 0);
        var stepScaleY = GetObjectValue(options, 'setScale.stepY', 0);

        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);

        var alpha = GetObjectValue(options, 'setAlpha.value', 1);
        var stepAlpha = GetObjectValue(options, 'setAlpha.step', 0);

        Actions.SetAlpha(entries, alpha, stepAlpha);

        return entries;
    },

    createMultiple: function (config)
    {
        if (!Array.isArray(config))
        {
            config = [ config ];
        }

        var output = [];

        for (var i = 0; i < config.length; i++)
        {
            var entries = this.createFromConfig(config[i]);

            output = output.concat(entries);
        }

        return output;
    },

    remove: function (child)
    {
        this.children.delete(child);

        return this;
    },

    clear: function ()
    {
        this.children.clear();

        return this;
    },

    destroy: function ()
    {
        this.children.clear();

        this.state = undefined;
        this.children = undefined;
    },

    //  Child related methods

    angle: function (value)
    {
        Actions.Angle(this.children.entries, value);

        return this;
    },

    gridAlign: function (options)
    {
        Actions.GridAlign(this.children.entries, options);

        return this;
    },

    incAlpha: function (value, step)
    {
        Actions.IncAlpha(this.children.entries, value, step);

        return this;
    },

    incX: function (value)
    {
        Actions.IncX(this.children.entries, value);

        return this;
    },

    incXY: function (x, y)
    {
        Actions.IncXY(this.children.entries, x, y);

        return this;
    },

    incY: function (value)
    {
        Actions.IncY(this.children.entries, value);

        return this;
    },

    placeOnCircle: function (circle, startAngle, endAngle)
    {
        Actions.PlaceOnCircle(this.children.entries, circle, startAngle, endAngle);

        return this;
    },

    placeOnLine: function (line)
    {
        Actions.PlaceOnLine(this.children.entries, line);

        return this;
    },

    placeOnRectangle: function (rect, shift)
    {
        Actions.PlaceOnRectangle(this.children.entries, rect, shift);

        return this;
    },

    placeOnTriangle: function (triangle, stepRate)
    {
        Actions.PlaceOnTriangle(this.children.entries, triangle, stepRate);

        return this;
    },

    randomCircle: function (circle)
    {
        Actions.RandomCircle(this.children.entries, circle);

        return this;
    },

    randomEllipse: function (ellipse)
    {
        Actions.RandomEllipse(this.children.entries, ellipse);

        return this;
    },

    randomLine: function (line)
    {
        Actions.RandomLine(this.children.entries, line);

        return this;
    },

    randomRectangle: function (rect)
    {
        Actions.RandomRectangle(this.children.entries, rect);

        return this;
    },

    randomTriangle: function (triangle)
    {
        Actions.RandomTriangle(this.children.entries, triangle);

        return this;
    },

    rotate: function (value, step)
    {
        Actions.Rotate(this.children.entries, value, step);

        return this;
    },

    rotateAround: function (point, angle)
    {
        Actions.RotateAround(this.children.entries, point, angle);

        return this;
    },

    rotateAroundDistance: function (point, angle, distance)
    {
        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);

        return this;
    },

    setAlpha: function (value, step)
    {
        Actions.SetAlpha(this.children.entries, value, step);

        return this;
    },

    setOrigin: function (x, y)
    {
        Actions.SetOrigin(this.children.entries, x, y);

        return this;
    },

    scaleX: function (value)
    {
        Actions.ScaleX(this.children.entries, value);

        return this;
    },

    scaleXY: function (x, y)
    {
        Actions.ScaleXY(this.children.entries, x, y);

        return this;
    },

    scaleY: function (value)
    {
        Actions.ScaleY(this.children.entries, value);

        return this;
    },

    setRotation: function (value, step)
    {
        Actions.SetRotation(this.children.entries, value, step);

        return this;
    },

    setScale: function (x, y, stepX, stepY)
    {
        Actions.SetScale(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setScaleX: function (value, step)
    {
        Actions.SetScaleX(this.children.entries, value, step);

        return this;
    },

    setScaleY: function (value, step)
    {
        Actions.SetScaleY(this.children.entries, value, step);

        return this;
    },

    setVisible: function (value)
    {
        Actions.SetVisible(this.children.entries, value);

        return this;
    },

    setX: function (value, step)
    {
        Actions.SetX(this.children.entries, value, step);

        return this;
    },

    setXY: function (x, y, stepX, stepY)
    {
        Actions.SetXY(this.children.entries, x, y, stepX, stepY);

        return this;
    },

    setY: function (value, step)
    {
        Actions.SetY(this.children.entries, value, step);

        return this;
    },

    smootherStep: function (property, min, max, inc)
    {
        Actions.SmootherStep(this.children.entries, property, min, max, inc);

        return this;
    },

    smoothStep: function (property, min, max, inc)
    {
        Actions.SmoothStep(this.children.entries, property, min, max, inc);

        return this;
    },

    spread: function (property, min, max, inc)
    {
        Actions.Spread(this.children.entries, property, min, max, inc);

        return this;
    },

    toggleVisible: function ()
    {
        Actions.ToggleVisible(this.children.entries);

        return this;
    }

});

module.exports = Layer;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {


var Class = __webpack_require__(3);
var GameObject = __webpack_require__(12);
var Components = __webpack_require__(5);
var CanvasPool = __webpack_require__(22);
var TextRender = __webpack_require__(329);
var TextStyle = __webpack_require__(326);
var GetTextSize = __webpack_require__(324);

var Text = new Class({

    Mixins: [
        Components.Alpha,
        Components.BlendMode,
        Components.GetBounds,
        Components.Origin,
        Components.ScaleMode,
        Components.Transform,
        Components.Visible,
        Components.Flip,
        Components.RenderPass,
        TextRender
    ],

    initialize:

    function Text (state, x, y, text, style)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (text === undefined) { text = ''; }

        GameObject.call(this, state);

        this.setPosition(x, y);
        this.setOrigin(0, 0);

        /**
         * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
         */
        this.canvas = CanvasPool.create(this);

        /**
         * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
         */
        this.context = this.canvas.getContext('2d');

        this.style = new TextStyle(this, style);

        this.autoRound = true;

        /**
         * The Regular Expression that is used to split the text up into lines, in
         * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
         * You can change this RegExp to be anything else that you may need.
         * @property {Object} splitRegExp
         */
        this.splitRegExp = /(?:\r\n|\r|\n)/;

        this.text = (Array.isArray(text)) ? text.join('\n') : text;

        this.resolution = 1;

        this.padding = { x: 0, y: 0 };

        this.width = 1;
        this.height = 1;

        this.canvasTexture = null;
        this.prevWidth = 0;
        this.prevHeight = 0;
        this.dirty = false;

        if (text !== '')
        {
            this.updateText();
        }
        this.initRenderPassComponent();
    },

    setText: function (value)
    {
        if (Array.isArray(value))
        {
            value = value.join('\n');
        }

        if (value !== this.text)
        {
            this.text = value;

            this.updateText();
        }

        return this;
    },

    setStyle: function (style)
    {
        return this.style.setStyle(style);
    },

    setFont: function (font)
    {
        return this.style.setFont(font);
    },

    setFixedSize: function (width, height)
    {
        return this.style.setFixedSize(width, height);
    },

    setBackgroundColor: function (color)
    {
        return this.style.setBackgroundColor(color);
    },

    setFill: function (color)
    {
        return this.style.setFill(color);
    },

    setStroke: function (color, thickness)
    {
        return this.style.setStroke(color, thickness);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    },

    setShadowOffset: function (x, y)
    {
        return this.style.setShadowOffset(x, y);
    },

    setShadowColor: function (color)
    {
        return this.style.setShadowColor(color);
    },

    setShadowBlur: function (blur)
    {
        return this.style.setShadowBlur(blur);
    },

    setShadowStroke: function (enabled)
    {
        return this.style.setShadowStroke(enabled);
    },

    setShadowFill: function (enabled)
    {
        return this.style.setShadowFill(enabled);
    },

    setAlign: function (align)
    {
        return this.style.setAlign(align);
    },

    setMaxLines: function (max)
    {
        return this.style.setMaxLines(max);
    },

    updateText: function ()
    {
        var canvas = this.canvas;
        var context = this.context;
        var style = this.style;
        var size = style.metrics;

        var outputText = this.text;

        // if (style.wordWrap)
        // {
        //     outputText = this.runWordWrap(this.text);
        // }

        //  Split text into lines
        var lines = outputText.split(this.splitRegExp);

        var textSize = GetTextSize(this, size, lines);

        if (!style.fixedWidth)
        {
            this.width = textSize.width;
        }

        if (!style.fixedHeight)
        {
            this.height = textSize.height;
        }

        this.updateOrigin();

        var w = textSize.width * this.resolution;
        var h = textSize.height * this.resolution;

        if (canvas.width !== w || canvas.height !== h)
        {
            canvas.width = w;
            canvas.height = h;
        }
        else
        {
            context.clearRect(0, 0, w, h);
        }

        if (style.backgroundColor)
        {
            context.fillStyle = style.backgroundColor;
            context.fillRect(0, 0, w, h);
        }

        style.syncFont(canvas, context);

        var linePositionX;
        var linePositionY;

        //  Draw text line by line
        for (var i = 0; i < textSize.lines; i++)
        {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;

            if (i > 0)
            {
                linePositionY += (textSize.lineSpacing * i);
            }

            if (style.align === 'right')
            {
                linePositionX += textSize.width - textSize.lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (textSize.width - textSize.lineWidths[i]) / 2;
            }

            if (this.autoRound)
            {
                linePositionX = Math.round(linePositionX);
                linePositionY = Math.round(linePositionY);
            }

            if (style.strokeThickness)
            {
                this.style.syncShadow(context, style.shadowStroke);

                context.strokeText(lines[i], linePositionX, linePositionY);
            }

            if (style.fill)
            {
                this.style.syncShadow(context, style.shadowFill);

                context.fillText(lines[i], linePositionX, linePositionY);
            }
        }

        this.dirty = true;

        return this;
    }
});

module.exports = Text;


/***/ },
/* 109 */
/***/ function(module, exports) {

var Circle = function (x, y, radius)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (radius === undefined) { radius = 0; }

    this.x = x;

    this.y = y;

    this._radius = radius;
    this._diameter = radius * 2;
};

Circle.prototype.constructor = Circle;

Circle.prototype = {

    setTo: function (x, y, radius)
    {
        this.x = x;
        this.y = y;
        this._radius = radius;
        this._diameter = radius * 2;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    isEmpty: function ()
    {
        return (this._radius <= 0);
    }

};

Object.defineProperties(Circle.prototype, {

    radius: {

        enumerable: true,

        get: function ()
        {
            return this._radius;
        },

        set: function (value)
        {
            this._radius = value;
            this._diameter = value * 2;
        }

    },

    diameter: {

        enumerable: true,

        get: function ()
        {
            return this._diameter;
        },

        set: function (value)
        {
            this._diameter = value;
            this._radius = value * 0.5;
        }

    },

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x - this._radius;
        },

        set: function (value)
        {
            this.x = value + this._radius;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this._radius;
        },

        set: function (value)
        {
            this.x = value - this._radius;
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y - this._radius;
        },

        set: function (value)
        {
            this.y = value + this._radius;
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this._radius;
        },

        set: function (value)
        {
            this.y = value - this._radius;
        }

    }

});

module.exports = Circle;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* Returns a uniformly distributed random point from anywhere within this Circle.
* 
* @method Phaser.Circle#random
* @param {Phaser.Point|object} [out] - A Phaser.Point, or any object with public x/y properties, that the values will be set in.
*     If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
* @return {Phaser.Point} An object containing the random point in its `x` and `y` properties.
*/
var Random = function (circle, out)
{
    if (out === undefined) { out = new Point(); }

    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = (u > 1) ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    out.x = circle.x + (x * circle.radius);
    out.y = circle.y + (y * circle.radius);

    return out;
};

module.exports = Random;


/***/ },
/* 111 */
/***/ function(module, exports) {

var Ellipse = function (x, y, width, height)
{
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (width === undefined) { width = 0; }
    if (height === undefined) { height = 0; }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
};

Ellipse.prototype.constructor = Ellipse;

Ellipse.prototype = {

    setTo: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    },

    setEmpty: function ()
    {
        return this.setTo(0, 0, 0, 0);
    },

    setPosition: function (x, y)
    {
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setSize: function (width, height)
    {
        if (height === undefined) { height = width; }

        this.width = width;
        this.height = height;

        return this;
    },

    isEmpty: function ()
    {
        return (this.width <= 0 || this.height <= 0);
    },

    //  AKA Semi Minor Axis
    getMinorRadius: function ()
    {
        return Math.min(this.width, this.height) / 2;
    },

    //  AKA Semi Major Axis
    getMajorRadius: function ()
    {
        return Math.max(this.width, this.height) / 2;
    }

};

Object.defineProperties(Ellipse.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return this.x;
        },

        set: function (value)
        {
            if (value >= this.right)
            {
                this.width = 0;
            }
            else
            {
                this.width = this.right - value;
            }

            this.x = value;
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return this.x + this.width;
        },

        set: function (value)
        {
            if (value <= this.x)
            {
                this.width = 0;
            }
            else
            {
                this.width = value - this.x;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return this.y;
        },

        set: function (value)
        {
            if (value >= this.bottom)
            {
                this.height = 0;
                this.y = value;
            }
            else
            {
                this.height = (this.bottom - value);
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return this.y + this.height;
        },

        set: function (value)
        {
            if (value <= this.y)
            {
                this.height = 0;
            }
            else
            {
                this.height = value - this.y;
            }
        }

    }

});

module.exports = Ellipse;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (ellipse, out)
{
    if (out === undefined) { out = new Point(); }

    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());

    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);
    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);

    return out;
};

module.exports = Random;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

var GetPoint = __webpack_require__(62);

/**
* Calculate and return the angle, in radians, of the curves tangent based on time.
*
* @method Phaser.Hermite#getAngle
* @param {number} [t=0] - The `t` (time) value at which to find the angle. Must be between 0 and 1.
* @return {number} The angle of the line at the specified `t` time value along the curve. The value is in radians.
*/
var GetAngle = function (curve, t)
{
    if (t === undefined) { t = 0; }

    GetPoint(curve, t - 0.01, curve._temp1);
    GetPoint(curve, t + 0.01, curve._temp2);

    return Math.atan2(curve._temp2.y - curve._temp1.y, curve._temp2.x - curve._temp1.x);
};

module.exports = GetAngle;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

//  Based on code by Matt DesLauriers
//  https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md

var Contains = __webpack_require__(43);

var tmp = { x: 0, y: 0 };

var LineToCircle = function (line, circle, nearest)
{
    if (nearest === undefined) { nearest = tmp; }

    if (Contains(circle, line.x1, line.y1))
    {
        nearest.x = line.x1;
        nearest.y = line.y1;

        return true;
    }

    if (Contains(circle, line.x2, line.y2))
    {
        nearest.x = line.x2;
        nearest.y = line.y2;

        return true;
    }

    var dx = line.x2 - line.x1;
    var dy = line.y2 - line.y1;

    var lcx = circle.x - line.x1;
    var lcy = circle.y - line.y1;

    //  project lc onto d, resulting in vector p
    var dLen2 = (dx * dx) + (dy * dy);
    var px = dx;
    var py = dy;

    if (dLen2 > 0)
    {
        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;

        px *= dp;
        py *= dp;
    }

    nearest.x = line.x1 + px;
    nearest.y = line.y1 + py;
    
    //  len2 of p
    var pLen2 = (px * px) + (py * py);
    
    return (
        pLen2 <= dLen2 &&
        ((px * dx) + (py * dy)) >= 0 &&
        Contains(circle, nearest.x, nearest.y)
    );
};

module.exports = LineToCircle;


/***/ },
/* 115 */
/***/ function(module, exports) {

var PointToLine = function (point, line)
{
    return ((point.x - line.x1) * (line.y2 - line.y1) === (line.x2 - line.x1) * (point.y - line.y1));
};

module.exports = PointToLine;


/***/ },
/* 116 */
/***/ function(module, exports) {

var RectangleToRectangle = function (rectA, rectB)
{
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)
    {
        return false;
    }

    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
};

module.exports = RectangleToRectangle;


/***/ },
/* 117 */
/***/ function(module, exports) {

//  Defines a Line segment, a part of a line between two endpoints

var Line = function (x1, y1, x2, y2)
{
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;

    this.setTo(x1, y1, x2, y2);
};

Line.prototype.constructor = Line;

Line.prototype = {

    setTo: function (x1, y1, x2, y2)
    {
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        this.x1 = x1;
        this.y1 = y1;

        this.x2 = x2;
        this.y2 = y2;

        return this;
    },

    getPointA: function ()
    {
        return { x1: this.x1, y1: this.y1 };
    },

    getPointB: function ()
    {
        return { x1: this.x2, y1: this.y2 };
    }

};

Object.defineProperties(Line.prototype, {

    left: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 <= this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    right: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.x1, this.x2);
        },

        set: function (value)
        {
            if (this.x1 > this.x2)
            {
                this.x1 = value;
            }
            else
            {
                this.x2 = value;
            }
        }

    },

    top: {

        enumerable: true,

        get: function ()
        {
            return Math.min(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 <= this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    },

    bottom: {

        enumerable: true,

        get: function ()
        {
            return Math.max(this.y1, this.y2);
        },

        set: function (value)
        {
            if (this.y1 > this.y2)
            {
                this.y1 = value;
            }
            else
            {
                this.y2 = value;
            }
        }

    }

});

module.exports = Line;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);
var Wrap = __webpack_require__(46);
var Angle = __webpack_require__(31);

var NormalAngle = function (line)
{
    var angle = Angle(line) - MATH_CONST.TAU;

    return Wrap(angle, -Math.PI, Math.PI);
};

module.exports = NormalAngle;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var t = Math.random();

    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);

    return out;
};

module.exports = Random;


/***/ },
/* 120 */
/***/ function(module, exports) {

var GetMagnitude = function (point)
{
    return Math.sqrt((point.x * point.x) + (point.y * point.y));
};

module.exports = GetMagnitude;


/***/ },
/* 121 */
/***/ function(module, exports) {

var GetMagnitudeSq = function (point)
{
    return (point.x * point.x) + (point.y * point.y);
};

module.exports = GetMagnitudeSq;


/***/ },
/* 122 */
/***/ function(module, exports) {

var Multiply = function (point, x, y)
{
    point.x *= x;
    point.y *= y;

    return point;
};

module.exports = Multiply;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

var GetMagnitude = __webpack_require__(120);

var Normalize = function (point)
{
    if (point.x !== 0 && point.y !== 0)
    {
        var m = GetMagnitude(point);

        point.x /= m;
        point.y /= m;
    }

    return point;
};

module.exports = Normalize;


/***/ },
/* 124 */
/***/ function(module, exports) {

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var Contains = function (polygon, x, y)
{
    //  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva

    var inside = false;

    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)
    {
        var ix = polygon.points[i].x;
        var iy = polygon.points[i].y;

        var jx = polygon.points[j].x;
        var jy = polygon.points[j].y;

        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))
        {
            inside = !inside;
        }
    }

    return inside;
};

module.exports = Contains;


/***/ },
/* 125 */
/***/ function(module, exports) {

var Polygon = function (points)
{
    /**
    * @property {number} area - The area of this Polygon.
    */
    this.area = 0;

    /**
    * @property {array} points - An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
    */
    this.points = [];

    if (points)
    {
        this.setTo(points);
    }
};

Polygon.prototype.constructor = Polygon;

Polygon.prototype = {

    /**
     * Sets this Polygon to the given points.
     *
     * The points can be set from a variety of formats:
     *
     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
     *
     * `setTo` may also be called without any arguments to remove all points.
     *
     * @method Phaser.Polygon#setTo
     * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
     * @return {Phaser.Polygon} This Polygon object
     */
    setTo: function (points)
    {
        this.area = 0;
        this.points = [];

        if (!Array.isArray(points))
        {
            return this;
        }

        var entry;
        var y0 = Number.MAX_VALUE;
        var p;

        //  The points argument is an array, so iterate through it
        for (var i = 0; i < points.length; i++)
        {
            p = { x: 0, y: 0 };

            if (typeof points[i] === 'number')
            {
                p.x = points[i];
                p.y = points[i + 1];
                i++;
            }
            else if (Array.isArray(entry))
            {
                //  An array of arrays?
                p.x = points[i][0];
                p.y = points[i][1];
            }
            else
            {
                p.x = points[i].x;
                p.y = points[i].y;
            }

            this.points.push(p);

            //  Lowest boundary
            if (p.y < y0)
            {
                y0 = p.y;
            }
        }

        this.calculateArea(y0);

        return this;
    },

    /**
     * Calculates the area of the Polygon. This is available in the property Polygon.area
     *
     * @method Phaser.Polygon#calculateArea
     * @private
     * @param {number} y0 - The lowest boundary
     * @return {number} The area of the Polygon.
     */
    calculateArea: function (y0)
    {
        if (this.points.length < 3)
        {
            this.area = 0;

            return this.area;
        }

        var sum = 0;
        var p1;
        var p2;

        for (var i = 0; i < this.points.length - 1; i++)
        {
            p1 = this.points[i];
            p2 = this.points[i + 1];

            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }

        p1 = this.points[0];
        p2 = this.points[this.points.length - 1];

        sum += (p1.x - p2.x) * (p2.y + p1.y);

        this.area = -sum * 0.5;

        // var p1;
        // var p2;
        // var avgHeight;
        // var width;

        // for (var i = 0, len = this.points.length; i < len; i++)
        // {
        //     p1 = this.points[i];

        //     if (i === len - 1)
        //     {
        //         p2 = this.points[0];
        //     }
        //     else
        //     {
        //         p2 = this.points[i + 1];
        //     }

        //     avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2;
        //     width = p1.x - p2.x;
        //     this.area += avgHeight * width;
        // }

        return this.area;
    }

};

module.exports = Polygon;


/***/ },
/* 126 */
/***/ function(module, exports) {

var Decompose = function (rect, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: rect.x, y: rect.y });
    out.push({ x: rect.right, y: rect.y });
    out.push({ x: rect.right, y: rect.bottom });
    out.push({ x: rect.x, y: rect.bottom });

    return out;
};

module.exports = Decompose;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

var Perimeter = __webpack_require__(128);

//  Return an array of points from the perimeter of the rectangle
//  each spaced out based on the quantity or step required

var MarchingAnts = function (rect, step, quantity, out)
{
    if (out === undefined) { out = []; }

    if (!step && !quantity)
    {
        //  Bail out
        return out;
    }

    //  If step is a falsey value (false, null, 0, undefined, etc) then we calculate
    //  it based on the quantity instead, otherwise we always use the step value
    if (!step)
    {
        step = Perimeter(rect) / quantity;
    }
    else
    {
        quantity = Math.round(Perimeter(rect) / step);
    }

    var x = rect.x;
    var y = rect.y;
    var face = 0;

    //  Loop across each face of the rectangle

    for (var i = 0; i < quantity; i++)
    {
        out.push({ x: x, y: y });

        switch (face)
        {
            //  Top face
            case 0:
                x += step;

                if (x >= rect.right)
                {
                    face = 1;
                    y += (x - rect.right);
                    x = rect.right;
                }
                break;

            //  Right face
            case 1:
                y += step;

                if (y >= rect.bottom)
                {
                    face = 2;
                    x -= (y - rect.bottom);
                    y = rect.bottom;
                }
                break;

            //  Bottom face
            case 2:
                x -= step;

                if (x <= rect.left)
                {
                    face = 3;
                    y -= (rect.left - x);
                    x = rect.left;
                }
                break;

            //  Left face
            case 3:
                y -= step;

                if (y <= rect.top)
                {
                    face = 0;
                    y = rect.top;
                }
                break;
        }
    }

    return out;
};

module.exports = MarchingAnts;


/***/ },
/* 128 */
/***/ function(module, exports) {

var Perimeter = function (rect)
{
    return 2 * (rect.width + rect.height);
};

module.exports = Perimeter;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Random = function (rect, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = rect.x + (Math.random() * rect.width);
    out.y = rect.y + (Math.random() * rect.height);

    return out;
};

module.exports = Random;


/***/ },
/* 130 */
/***/ function(module, exports) {

//  The three medians (the lines drawn from the vertices to the bisectors of the opposite sides)
//  meet in the centroid or center of mass (center of gravity).
//  The centroid divides each median in a ratio of 2:1

var Centroid = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;

    return out;
};

module.exports = Centroid;


/***/ },
/* 131 */
/***/ function(module, exports) {

var Decompose = function (triangle, out)
{
    if (out === undefined) { out = []; }

    out.push({ x: triangle.x1, y: triangle.y1 });
    out.push({ x: triangle.x2, y: triangle.y2 });
    out.push({ x: triangle.x3, y: triangle.y3 });

    return out;
};

module.exports = Decompose;


/***/ },
/* 132 */
/***/ function(module, exports) {

// The three angle bisectors of a triangle meet in one point called the incenter.
// It is the center of the incircle, the circle inscribed in the triangle.

function getLength (x1, y1, x2, y2)
{
    var x = x1 - x2;
    var y = y1 - y2;
    var magnitude = (x * x) + (y * y);

    return Math.sqrt(magnitude);
}

var InCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var d1 = getLength(x3, y3, x2, y2);
    var d2 = getLength(x1, y1, x3, y3);
    var d3 = getLength(x2, y2, x1, y1);

    var p = d1 + d2 + d3;

    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;

    return out;
};

module.exports = InCenter;


/***/ },
/* 133 */
/***/ function(module, exports) {

var Offset = function (triangle, x, y)
{
    triangle.x1 += x;
    triangle.y1 += y;

    triangle.x2 += x;
    triangle.y2 += y;

    triangle.x3 += x;
    triangle.y3 += y;

    return triangle;
};

module.exports = Offset;


/***/ },
/* 134 */
/***/ function(module, exports) {


var Random = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    //  Basis vectors
    var ux = triangle.x2 - triangle.x1;
    var uy = triangle.y2 - triangle.y1;

    var vx = triangle.x3 - triangle.x1;
    var vy = triangle.y3 - triangle.y1;

    //  Random point within the unit square
    var r = Math.random();
    var s = Math.random();

    //  Point outside the triangle? Remap it.
    if (r + s >= 1)
    {
        r = 1 - r;
        s = 1 - s;
    }

    out.x = triangle.x1 + ((ux * r) + (vx * s));
    out.y = triangle.y1 + ((uy * r) + (vy * s));

    return out;
};

module.exports = Random;


/***/ },
/* 135 */
/***/ function(module, exports) {

/**
* Adds the source and backdrop colors together and returns the value, up to a maximum of 255.
*
* @method Lazer.Color.blendAdd
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Add = function (a, b)
{
    return Math.min(255, a + b);
};

module.exports = Add;


/***/ },
/* 136 */
/***/ function(module, exports) {

/**
* Darkens the backdrop color to reflect the source color.
* Painting with white produces no change. 
*
* @method Lazer.Color.blendColorBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorBurn = function (a, b)
{
    return (b === 0) ? b : Math.max(0, (255 - ((255 - a) << 8) / b));
};

module.exports = ColorBurn;


/***/ },
/* 137 */
/***/ function(module, exports) {

/**
* Brightens the backdrop color to reflect the source color. 
* Painting with black produces no change.
*
* @method Lazer.Color.blendColorDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var ColorDodge = function (a, b)
{
    return (b === 255) ? b : Math.min(255, ((a << 8) / (255 - b)));
};

module.exports = ColorDodge;


/***/ },
/* 138 */
/***/ function(module, exports) {

/**
* Selects the darker of the backdrop and source colors.
*
* @method Lazer.Color.blendDarken
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Darken = function (a, b)
{
    return (b > a) ? a : b;
};

module.exports = Darken;


/***/ },
/* 139 */
/***/ function(module, exports) {

/**
* Selects the lighter of the backdrop and source colors.
*
* @method Lazer.Color.blendLighten
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Lighten = function (a, b)
{
    return (b > a) ? b : a;
};

module.exports = Lighten;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

var Subtract = __webpack_require__(144);

/**
* An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.
*
* @method Lazer.Color.blendLinearBurn
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearBurn = function (a, b)
{
    return Subtract(a, b);
};

module.exports = LinearBurn;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

var Add = __webpack_require__(135);

/**
* An alias for blendAdd, it simply sums the values of the two colors.
*
* @method Lazer.Color.blendLinearDodge
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearDodge = function (a, b)
{
    return Add(a, b);
};

module.exports = LinearDodge;


/***/ },
/* 142 */
/***/ function(module, exports) {

/**
* Multiplies or screens the colors, depending on the backdrop color.
* Source colors overlay the backdrop while preserving its highlights and shadows. 
* The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.
*
* @method Lazer.Color.blendOverlay
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Overlay = function (a, b)
{
    return (b < 128) ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255);
};

module.exports = Overlay;


/***/ },
/* 143 */
/***/ function(module, exports) {

/**
* Reflect blend mode. This mode is useful when adding shining objects or light zones to images. 
*
* @method Lazer.Color.blendReflect
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Reflect = function (a, b)
{
    return (b === 255) ? b : Math.min(255, (a * a / (255 - b)));
};

module.exports = Reflect;


/***/ },
/* 144 */
/***/ function(module, exports) {

/**
* Combines the source and backdrop colors and returns their value minus 255.
*
* @method Lazer.Color.blendSubtract
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Subtract = function (a, b)
{
    return Math.max(0, a + b - 255);
};

module.exports = Subtract;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

var ColorBurn = __webpack_require__(136);
var ColorDodge = __webpack_require__(137);

/**
* This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).
* Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.
* The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom 
* layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.
*
* @method Lazer.Color.blendVividLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var VividLight = function (a, b)
{
    return (b < 128) ? ColorBurn(a, 2 * b) : ColorDodge(a, (2 * (b - 128)));
};

module.exports = VividLight;


/***/ },
/* 146 */
/***/ function(module, exports) {

/**
* Return a string containing a hex representation of the given color component.
*
* @param {integer} color - The color channel to get the hex value for, must be a value between 0 and 255.
* @return {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.
*/
var ComponentToHex = function (color)
{
    var hex = color.toString(16);

    return (hex.length === 1) ? '0' + hex : hex;
};

module.exports = ComponentToHex;


/***/ },
/* 147 */
/***/ function(module, exports) {

/**
 * Given an alpha and 3 color values this will return an integer representation of it.
 *
 * @method getColor32
 * @param {integer} r - The red color component in the range 0 - 255.
 * @param {integer} g - The green color component in the range 0 - 255.
 * @param {integer} b - The blue color component in the range 0 - 255.
 * @return {integer} A native color value integer (format: 0xRRGGBB).
 */
var GetColor32 = function (red, green, blue, alpha)
{
    return alpha << 24 | red << 16 | green << 8 | blue;
};

module.exports = GetColor32;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

var GetColor = __webpack_require__(70);

/**
 * Converts an HSV (hue, saturation and value) color value to RGB.
 * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
 * Based on code by Michael Jackson (https://github.com/mjijackson)
 *
 * @method fromHSV
 * @param {number} h - The hue, in the range 0 - 1.
 * @param {number} s - The saturation, in the range 0 - 1.
 * @param {number} v - The value, in the range 0 - 1.
 * @return {BaseColor} This
 */
var HSVToRGB = function (h, s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var i = Math.floor(h * 6);
    var f = h * 6 - i;

    var p = Math.floor((v * (1 - s)) * 255);
    var q = Math.floor((v * (1 - f * s)) * 255);
    var t = Math.floor((v * (1 - (1 - f) * s)) * 255);

    v = Math.floor(v *= 255);

    var output = { r: v, g: v, b: v, color: 0 };

    var r = i % 6;

    if (r === 0)
    {
        output.g = t;
        output.b = p;
    }
    else if (r === 1)
    {
        output.r = q;
        output.b = p;
    }
    else if (r === 2)
    {
        output.r = p;
        output.b = t;
    }
    else if (r === 3)
    {
        output.r = p;
        output.g = q;
    }
    else if (r === 4)
    {
        output.r = t;
        output.g = p;
    }
    else if (r === 5)
    {
        output.g = p;
        output.b = q;
    }

    output.color = GetColor(output.r, output.g, output.b);

    return output;
};

module.exports = HSVToRGB;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(32);

/**
* Converts a hex string into a Phaser Color object.
*
* The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.    
*
* An alpha channel is _not_ supported.
*
* @method Phaser.Color.hexToColor
* @static
* @param {string} hex - The color string in a hex format.
* @param {object} [out] - An object into which 3 properties will be created or set: r, g and b. If not provided a new object will be created.
* @return {object} An object with the red, green and blue values set in the r, g and b properties.
*/
var HexStringToColor = function (hex)
{
    var color = new Color();

    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    if (result)
    {
        var r = parseInt(result[1], 16);
        var g = parseInt(result[2], 16);
        var b = parseInt(result[3], 16);

        color.setTo(r, g, b);
    }

    return color;
};

module.exports = HexStringToColor;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
* Converts a hue to an RGB color.
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.hueToColor
* @param {number} p
* @param {number} q
* @param {number} t
* @return {number} The color component value.
*/
var HueToComponent = function (p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }

    if (t > 1)
    {
        t -= 1;
    }

    if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2)
    {
        return q;
    }

    if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

module.export = HueToComponent;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)(module)))

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(32);
var IntegerToRGB = __webpack_require__(152);

var IntegerToColor = function (input)
{
    var rgb = IntegerToRGB(input);

    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
};

module.exports = IntegerToColor;


/***/ },
/* 152 */
/***/ function(module, exports) {

/**
* Return the component parts of a color as an Object with the properties alpha, red, green, blue.
*
* Alpha will only be set if it exist in the given color (0xAARRGGBB)
*
* @method Phaser.Color.getRGB
* @static
* @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).
* @return {object} An Object with properties: alpha, red, green, blue (also r, g, b and a). Alpha will only be present if a color value > 16777215 was given.
*/
var IntegerToRGB = function (color)
{
    if (color > 16777215)
    {
        //  The color value has an alpha component
        return {
            a: color >>> 24,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
    else
    {
        return {
            a: 255,
            r: color >> 16 & 0xFF,
            g: color >> 8 & 0xFF,
            b: color & 0xFF
        };
    }
};

module.exports = IntegerToRGB;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(32);

/**
* Converts a CSS 'web' string into a Phaser Color object.
*
* The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
*
* @method Phaser.Color.webToColor
* @static
* @param {string} web - The color string in CSS 'web' format.
* @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.
* @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
*/
var RGBStringToColor = function (rgb)
{
    var color = new Color();

    var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());

    if (result)
    {
        var r = parseInt(result[1], 10);
        var g = parseInt(result[2], 10);
        var b = parseInt(result[3], 10);
        var a = (result[4] !== undefined) ? parseFloat(result[4]) : 1;

        color.setTo(r, g, b, a * 255);
    }

    return color;
};

module.exports = RGBStringToColor;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

var RGBStringToColor = __webpack_require__(153);
var HexStringToColor = __webpack_require__(149);
var IntegerToColor = __webpack_require__(151);

var ValueToColor = function (input)
{
    if (typeof input === 'string')
    {
        if (input.substr(0, 3).toLowerCase() === 'rgb')
        {
            return RGBStringToColor(input);
        }
        else
        {
            return HexStringToColor(input);
        }
    }
    else if (typeof input === 'number')
    {
        return IntegerToColor(input);
    }
};

module.exports = ValueToColor;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

var EventDispatcher = __webpack_require__(26);
var Event = __webpack_require__(487);
var KeyCodes = __webpack_require__(71);
var Key = __webpack_require__(158);
var KeyCombo = __webpack_require__(156);
var ProcessKeyCombo = __webpack_require__(157);
var ProcessKeyDown = __webpack_require__(492);
var ProcessKeyUp = __webpack_require__(493);

/**
* The Keyboard class monitors keyboard input and dispatches keyboard events.
*
* _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
* See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
*
* Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
* For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
* So please check your extensions before opening Phaser issues.
*
* @class Phaser.Keyboard
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var KeyboardManager = function (inputManager)
{
    this.manager = inputManager;

    this.enabled = false;

    this.target;

    this.events = new EventDispatcher();

    this.keys = [];

    this.combos = [];

    this.captures = [];

    //   Standard FIFO queue
    this.queue = [];

    this.keyHandler;
};

KeyboardManager.prototype.constructor = KeyboardManager;

KeyboardManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        var config = this.manager.gameConfig;

        this.enabled = config.inputKeyboard;
        this.target = config.inputKeyboardEventTarget;

        if (this.enabled)
        {
            this.startListeners();
        }
    },

    startListeners: function ()
    {
        var queue = this.queue;
        var captures = this.captures;

        var keyHandler = function (event)
        {
            if (event.preventDefaulted)
            {
                // Do nothing if event already handled
                return;
            }

            queue.push(event);

            if (captures[event.keyCode])
            {
                event.preventDefault();
            }
        };

        this.keyHandler = keyHandler;

        this.target.addEventListener('keydown', keyHandler, false);
        this.target.addEventListener('keyup', keyHandler, false);
    },

    stopListeners: function ()
    {
        this.target.removeEventListener('keydown', this.keyHandler);
        this.target.removeEventListener('keyup', this.keyHandler);
    },

    /**
    * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.
    *
    * @method Phaser.Keyboard#createCursorKeys
    * @return {object} An object containing properties: `up`, `down`, `left` and `right` of {@link Phaser.Key} objects.
    */
    createCursorKeys: function ()
    {
        return this.addKeys({
            up: KeyCodes.UP,
            down: KeyCodes.DOWN,
            left: KeyCodes.LEFT,
            right: KeyCodes.RIGHT
        });
    },

    /**
    * A practical way to create an object containing user selected hotkeys.
    *
    * For example,
    *
    *     addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );
    *
    * would return an object containing properties (`up`, `down`, `left` and `right`) referring to {@link Phaser.Key} object.
    *
    * @method Phaser.Keyboard#addKeys
    * @param {object} keys - A key mapping object, i.e. `{ 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S }` or `{ 'up': 52, 'down': 53 }`.
    * @return {object} An object containing the properties mapped to {@link Phaser.Key} values.
    */
    addKeys: function (keys)
    {
        var output = {};

        for (var key in keys)
        {
            output[key] = this.addKey(keys[key]);
        }

        return output;
    },

    /**
    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
    * The Key object can then be polled, have events attached to it, etc.
    *
    * @method Phaser.Keyboard#addKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key.
    * @return {Phaser.Key} The Key object which you can store locally and reference directly.
    */
    addKey: function (keyCode)
    {
        var keys = this.keys;

        if (!keys[keyCode])
        {
            keys[keyCode] = new Key(keyCode);
            this.captures[keyCode] = true;
        }

        return keys[keyCode];
    },

    /**
    * Removes a Key object from the Keyboard manager.
    *
    * @method Phaser.Keyboard#removeKey
    * @param {integer} keycode - The {@link Phaser.KeyCode keycode} of the key to remove.
    */
    removeKey: function (keyCode)
    {
        if (this.keys[keyCode])
        {
            this.keys[keyCode] = undefined;
            this.captures[keyCode] = false;
        }
    },

    addKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = true;
        }
    },

    removeKeyCapture: function (keyCodes)
    {
        if (!Array.isArray(keyCodes))
        {
            keyCodes = [ keyCodes ];
        }

        for (var i = 0; i < keyCodes.length; i++)
        {
            this.captures[keyCodes[i]] = false;
        }
    },

    createCombo: function (keys, config)
    {
        return new KeyCombo(this, keys, config);
    },

    //  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
    //  type = 'keydown', 'keyup'
    //  keyCode = integer

    update: function ()
    {
        if (!this.enabled)
        {
            return;
        }

        //  Clears the queue array, and also means we don't work on array data that could potentially
        //  be modified during the processing phase
        var queue = this.queue.splice(0, this.queue.length);

        var keys = this.keys;
        var singleKey;

        //  Process the event queue, dispatching all of the events that have stored up
        for (var i = 0; i < queue.length; i++)
        {
            var event = queue[i];

            if (event.type === 'keydown')
            {
                this.events.dispatch(new Event.KEY_DOWN_EVENT(event));

                singleKey = Event._DOWN[event.keyCode];

                if (singleKey)
                {
                    this.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyDown(keys[event.keyCode], event);
                }
            }
            else
            {
                this.events.dispatch(new Event.KEY_UP_EVENT(event));

                singleKey = Event._UP[event.keyCode];

                if (singleKey)
                {
                    this.events.dispatch(new singleKey(event));
                }

                if (keys[event.keyCode])
                {
                    ProcessKeyUp(keys[event.keyCode], event);
                }
            }
        }
    }

};

module.exports = KeyboardManager;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

var GetObjectValue = __webpack_require__(9);
var ResetKeyCombo = __webpack_require__(484);
var ProcessKeyCombo = __webpack_require__(157);
var KeyComboMatchEvent = __webpack_require__(483);

//  Keys can be either:
//
//  A string (ATARI)
//  An array of either integers (key codes) or strings, or a mixture of both
//  An array of objects (such as Key objects) with a public 'keyCode' property

var KeyCombo = function (keyboardManager, keys, config)
{
    if (config === undefined) { config = {}; }

    //  Can't have a zero or single length combo (string or array based)
    if (keys.length < 2)
    {
        return false;
    }

    this.manager = keyboardManager;

    this.enabled = true;

    this.keyCodes = [];

    //  if 'keys' is a string we need to get the keycode of each character in it

    for (var i = 0; i < keys.length; i++)
    {
        var char = keys[i];

        if (typeof char === 'string')
        {
            this.keyCodes.push(char.toUpperCase().charCodeAt(0));
        }
        else if (typeof char === 'number')
        {
            this.keyCodes.push(char);
        }
        else if (char.hasOwnProperty('keyCode'))
        {
            this.keyCodes.push(char.keyCode);
        }
    }

    //  The current keyCode the combo is waiting for
    this.current = this.keyCodes[0];

    //  The current index of the key being waited for in the 'keys' string
    this.index = 0;

    //  The length of this combo (in keycodes)
    this.size = this.keyCodes.length;

    //  The time the previous key in the combo was matched
    this.timeLastMatched = 0;

    //  Has this Key Combo been matched yet?
    this.matched = false;

    //  The time the entire combo was matched
    this.timeMatched = 0;

    //  Custom options ...

    //  If they press the wrong key do we reset the combo?
    this.resetOnWrongKey = GetObjectValue(config, 'resetOnWrongKey', true);

    //  The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
    this.maxKeyDelay = GetObjectValue(config, 'maxKeyDelay', 0);

    //  If previously matched and they press Key 1 again, will it reset?
    this.resetOnMatch = GetObjectValue(config, 'resetOnMatch', false);

    //  If the combo matches, will it delete itself?
    this.deleteOnMatch = GetObjectValue(config, 'deleteOnMatch', false);

    var _this = this;

    var onKeyDownHandler = function (event)
    {
        if (_this.matched || !_this.enabled)
        {
            return;
        }

        var matched = ProcessKeyCombo(event.data, _this);

        if (matched)
        {
            _this.manager.events.dispatch(new KeyComboMatchEvent(_this, event));

            if (_this.resetOnMatch)
            {
                ResetKeyCombo(_this);
            }
            else if (_this.deleteOnMatch)
            {
                _this.destroy();
            }
        }
    };

    this.onKeyDown = onKeyDownHandler;

    this.manager.events.on('KEY_DOWN_EVENT', onKeyDownHandler);
};

KeyCombo.prototype.constructor = KeyCombo;

KeyCombo.prototype = {

    destroy: function ()
    {
        this.enabled = false;
        this.keyCodes = [];

        this.manager.events.off('KEY_DOWN', this.onKeyDown);
        this.manager = undefined;
    }

};

Object.defineProperties(KeyCombo.prototype, {

    progress: {

        enumerable: true,

        //  How far complete is this combo? A value between 0 and 1.
        get: function ()
        {
            return this.index / this.size;
        }

    }

});

module.exports = KeyCombo;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

var AdvanceKeyCombo = __webpack_require__(482);

var ProcessKeyCombo = function (event, combo)
{
    if (combo.matched)
    {
        return true;
    }

    var comboMatched = false;
    var keyMatched = false;

    if (event.keyCode === combo.current)
    {
        //  Key was correct

        if (combo.index > 0 && combo.maxKeyDelay > 0)
        {
            //  We have to check to see if the delay between
            //  the new key and the old one was too long (if enabled)

            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;

            //  Check if they pressed it in time or not
            if (event.timeStamp <= timeLimit)
            {
                keyMatched = true;
                comboMatched = AdvanceKeyCombo(event, combo);
            }
        }
        else
        {
            keyMatched = true;

            //  We don't check the time for the first key pressed, so just advance it
            comboMatched = AdvanceKeyCombo(event, combo);
        }
    }

    if (!keyMatched && combo.resetOnWrongKey)
    {
        //  Wrong key was pressed
        combo.index = 0;
        combo.current = combo.keyCodes[0];
    }

    if (comboMatched)
    {
        combo.timeLastMatched = event.timeStamp;
        combo.matched = true;
        combo.timeMatched = event.timeStamp;
    }

    return comboMatched;
};

module.exports = ProcessKeyCombo;


/***/ },
/* 158 */
/***/ function(module, exports) {

//  A generic Key object which can be passed to the Process functions (and so on)

//  keycode must be an integer

var Key = function (keyCode)
{
    /**
    * @property {integer} keyCode - The keycode of this key.
    */
    this.keyCode = keyCode;

    /**
    * @property {KeyboardEvent} originalEvent - The original DOM event.
    */
    this.originalEvent = undefined;

    /**
    * @property {boolean} preventDefault - Should this Key prevent event propagation?
    * @default
    */
    this.preventDefault = true;

    /**
    * @property {boolean} enabled - Can this Key be processed?
    * @default
    */
    this.enabled = true;

    /**
    * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
    * @default
    */
    this.isDown = false;

    /**
    * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
    * @default
    */
    this.isUp = true;

    /**
    * @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.
    * @default
    */
    this.altKey = false;

    /**
    * @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.
    * @default
    */
    this.ctrlKey = false;

    /**
    * @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.
    * @default
    */
    this.shiftKey = false;

    /**
    * @property {integer} location - The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
    * @default
    */
    this.location = 0;

    /**
    * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
    */
    this.timeDown = 0;

    /**
    * If the key is down this value holds the duration of that key press and is constantly updated.
    * If the key is up it holds the duration of the previous down session.
    * @property {number} duration - The number of milliseconds this key has been held down for.
    * @default
    */
    this.duration = 0;

    /**
    * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
    * @default
    */
    this.timeUp = 0;

    /**
    * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
    * @default
    */
    this.repeats = 0;

    /**
     * @property {boolean} _justDown - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justDown = false;

    /**
     * @property {boolean} _justUp - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
     * @private
     */
    this._justUp = false;
};

Key.prototype.constructor = Key;

module.exports = Key;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

var XHRSettings = __webpack_require__(72);

//  Takes two XHR Objects and creates a new object

//  The new object is based on global initially, but any setting in
//  local overrides the global value.

var MergeXHRSettings = function (global, local)
{
    var output = (global === undefined) ? XHRSettings() : Object.assign(global);

    if (local)
    {
        for (var setting in local)
        {
            if (local[setting] !== undefined)
            {
                output[setting] = local[setting];
            }
        }
    }

    return output;

};

module.exports = MergeXHRSettings;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var JSONFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.json\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.json';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'json', key, url, 'text', xhrSettings);
};

JSONFile.prototype = Object.create(File.prototype);
JSONFile.prototype.constructor = JSONFile;

JSONFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = JSON.parse(this.xhrLoader.responseText);

    this.onComplete();

    callback(this);
};

module.exports = JSONFile;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);
var ParseXML = __webpack_require__(97);

var XMLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.xml\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.xml';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'xml', key, url, 'text', xhrSettings);
};

XMLFile.prototype = Object.create(File.prototype);
XMLFile.prototype.constructor = XMLFile;

XMLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = ParseXML(this.xhrLoader.responseText);

    if (this.data === null)
    {
        throw new Error('XMLFile: Invalid XML');
    }

    this.onComplete();

    callback(this);
};

module.exports = XMLFile;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

var Factorial = __webpack_require__(165);

var Bernstein = function (n, i)
{
    return Factorial(n) / Factorial(i) / Factorial(n - i);
};

module.exports = Bernstein;


/***/ },
/* 163 */
/***/ function(module, exports) {

var CatmullRom = function (p0, p1, p2, p3, t)
{
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;

    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = CatmullRom;


/***/ },
/* 164 */
/***/ function(module, exports) {

/**
* Force a value within the boundaries by clamping it to the range `min`, `max`.
*
* @method Phaser.Math#clamp
* @param {float} v - The value to be clamped.
* @param {float} min - The minimum bounds.
* @param {float} max - The maximum bounds.
* @return {number} The clamped value.
*/
var Clamp = function (v, min, max)
{
    if (v < min)
    {
        return min;
    }
    else if (max < v)
    {
        return max;
    }
    else
    {
        return v;
    }
};

module.exports = Clamp;


/***/ },
/* 165 */
/***/ function(module, exports) {

var Factorial = function (value)
{
    if (value === 0)
    {
        return 1;
    }

    var res = value;

    while (--value)
    {
        res *= value;
    }

    return res;
};

module.exports = Factorial;


/***/ },
/* 166 */
/***/ function(module, exports) {

var Linear = function (p0, p1, t)
{
    return (p1 - p0) * t + p0;
};

module.exports = Linear;


/***/ },
/* 167 */
/***/ function(module, exports) {

var RoundAwayFromZero = function (value)
{
    // "Opposite" of truncate.
    return (value > 0) ? Math.ceil(value) : Math.floor(value);
};

module.exports = RoundAwayFromZero;


/***/ },
/* 168 */
/***/ function(module, exports) {

var SmoothStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * (3 - 2 * x);
};

module.exports = SmoothStep;


/***/ },
/* 169 */
/***/ function(module, exports) {

var SmootherStep = function (x, min, max)
{
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));

    return x * x * x * (x * (x * 6 - 15) + 10);
};

module.exports = SmootherStep;


/***/ },
/* 170 */
/***/ function(module, exports) {

var Normalize = function (angle)
{
    angle = angle % (2 * Math.PI);

    if (angle >= 0)
    {
        return angle;
    }
    else
    {
        return angle + 2 * Math.PI;
    }
};

module.exports = Normalize;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

var MathWrap = __webpack_require__(46);

var Wrap = function (angle)
{
    return MathWrap(angle, -Math.PI, Math.PI);
};

module.exports = Wrap;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

var Wrap = __webpack_require__(46);

var WrapDegrees = function (angle)
{
    return Wrap(angle, -180, 180);
};

module.exports = WrapDegrees;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(166);

var LinearInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (k < 0)
    {
        return Linear(v[0], v[1], f);
    }

    if (k > 1)
    {
        return Linear(v[m], v[m - 1], m - f);
    }

    return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);
};

module.exports = LinearInterpolation;


/***/ },
/* 174 */
/***/ function(module, exports) {

/**
* Checks if the given dimensions make a power of two texture.
* 
* @method Phaser.Math#isPowerOfTwo
* @param {number} width - The width to check.
* @param {number} height - The height to check.
* @return {boolean} True if the width and height are a power of two.
*/
var IsSizePowerOfTwo = function (width, height)
{
    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
};

module.exports = IsSizePowerOfTwo;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/

var World = {};

module.exports = World;

var Composite = __webpack_require__(23);
var Constraint = __webpack_require__(40);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */
    World.create = function(options) {
        var composite = Composite.create();

        var defaults = {
            label: 'World',
            gravity: {
                x: 0,
                y: 1,
                scale: 0.001
            },
            bounds: { 
                min: { x: -Infinity, y: -Infinity }, 
                max: { x: Infinity, y: Infinity } 
            }
        };
        
        return Common.extend(composite, defaults, options);
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * The gravity to apply on the world.
     *
     * @property gravity
     * @type object
     */

    /**
     * The gravity x component.
     *
     * @property gravity.x
     * @type object
     * @default 0
     */

    /**
     * The gravity y component.
     *
     * @property gravity.y
     * @type object
     * @default 1
     */

    /**
     * The gravity scale factor.
     *
     * @property gravity.scale
     * @type object
     * @default 0.001
     */

    /**
     * A `Bounds` object that defines the world bounds for collision detection.
     *
     * @property bounds
     * @type bounds
     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }
     */

    // World is a Composite body
    // see src/module/Outro.js for these aliases:
    
    /**
     * An alias for Composite.clear
     * @method clear
     * @param {world} world
     * @param {boolean} keepStatic
     */

    /**
     * An alias for Composite.add
     * @method addComposite
     * @param {world} world
     * @param {composite} composite
     * @return {world} The original world with the objects from composite added
     */
    
     /**
      * An alias for Composite.addBody
      * @method addBody
      * @param {world} world
      * @param {body} body
      * @return {world} The original world with the body added
      */

     /**
      * An alias for Composite.addConstraint
      * @method addConstraint
      * @param {world} world
      * @param {constraint} constraint
      * @return {world} The original world with the constraint added
      */

})();


/***/ },
/* 176 */
/***/ function(module, exports) {

/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/

var Contact = {};

module.exports = Contact;

(function() {

    /**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */
    Contact.create = function(vertex) {
        return {
            id: Contact.id(vertex),
            vertex: vertex,
            normalImpulse: 0,
            tangentImpulse: 0
        };
    };
    
    /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */
    Contact.id = function(vertex) {
        return vertex.body.id + '_' + vertex.index;
    };

})();


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/

var Pairs = {};

module.exports = Pairs;

var Pair = __webpack_require__(47);
var Common = __webpack_require__(0);

(function() {
    
    var _pairMaxIdleLife = 1000;

    /**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */
    Pairs.create = function(options) {
        return Common.extend({ 
            table: {},
            list: [],
            collisionStart: [],
            collisionActive: [],
            collisionEnd: []
        }, options);
    };

    /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */
    Pairs.update = function(pairs, collisions, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            collisionStart = pairs.collisionStart,
            collisionEnd = pairs.collisionEnd,
            collisionActive = pairs.collisionActive,
            activePairIds = [],
            collision,
            pairId,
            pair,
            i;

        // clear collision state arrays, but maintain old reference
        collisionStart.length = 0;
        collisionEnd.length = 0;
        collisionActive.length = 0;

        for (i = 0; i < collisions.length; i++) {
            collision = collisions[i];

            if (collision.collided) {
                pairId = Pair.id(collision.bodyA, collision.bodyB);
                activePairIds.push(pairId);

                pair = pairsTable[pairId];
                
                if (pair) {
                    // pair already exists (but may or may not be active)
                    if (pair.isActive) {
                        // pair exists and is active
                        collisionActive.push(pair);
                    } else {
                        // pair exists but was inactive, so a collision has just started again
                        collisionStart.push(pair);
                    }

                    // update the pair
                    Pair.update(pair, collision, timestamp);
                } else {
                    // pair did not exist, create a new pair
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;

                    // push the new pair
                    collisionStart.push(pair);
                    pairsList.push(pair);
                }
            }
        }

        // deactivate previously active pairs that are now inactive
        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {
                Pair.setActive(pair, false, timestamp);
                collisionEnd.push(pair);
            }
        }
    };
    
    /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */
    Pairs.removeOld = function(pairs, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            indexesToRemove = [],
            pair,
            collision,
            pairIndex,
            i;

        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            collision = pair.collision;
            
            // never remove sleeping pairs
            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                pair.timeUpdated = timestamp;
                continue;
            }

            // if pair is inactive for too long, mark it to be removed
            if (timestamp - pair.timeUpdated > _pairMaxIdleLife) {
                indexesToRemove.push(i);
            }
        }

        // remove marked pairs
        for (i = 0; i < indexesToRemove.length; i++) {
            pairIndex = indexesToRemove[i] - i;
            pair = pairsList[pairIndex];
            delete pairsTable[pair.id];
            pairsList.splice(pairIndex, 1);
        }
    };

    /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */
    Pairs.clear = function(pairs) {
        pairs.table = {};
        pairs.list.length = 0;
        pairs.collisionStart.length = 0;
        pairs.collisionActive.length = 0;
        pairs.collisionEnd.length = 0;
        return pairs;
    };

})();


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/

var Resolver = {};

module.exports = Resolver;

var Vertices = __webpack_require__(25);
var Vector = __webpack_require__(8);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(7);

(function() {

    Resolver._restingThresh = 4;
    Resolver._restingThreshTangent = 6;
    Resolver._positionDampen = 0.9;
    Resolver._positionWarming = 0.8;
    Resolver._frictionNormalMultiplier = 5;

    /**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */
    Resolver.preSolvePosition = function(pairs) {
        var i,
            pair,
            activeCount;

        // find total contacts on each body
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive)
                continue;
            
            activeCount = pair.activeContacts.length;
            pair.collision.parentA.totalContacts += activeCount;
            pair.collision.parentB.totalContacts += activeCount;
        }
    };

    /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solvePosition = function(pairs, timeScale) {
        var i,
            pair,
            collision,
            bodyA,
            bodyB,
            normal,
            bodyBtoA,
            contactShare,
            positionImpulse,
            contactCount = {},
            tempA = Vector._temp[0],
            tempB = Vector._temp[1],
            tempC = Vector._temp[2],
            tempD = Vector._temp[3];

        // find impulses required to resolve penetration
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;

            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;

            // get current separation between body edges involved in collision
            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), 
                                    Vector.add(bodyA.positionImpulse, 
                                        Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);

            pair.separation = Vector.dot(normal, bodyBtoA);
        }
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive || pair.isSensor || pair.separation < 0)
                continue;
            
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            positionImpulse = (pair.separation - pair.slop) * timeScale;

            if (bodyA.isStatic || bodyB.isStatic)
                positionImpulse *= 2;
            
            if (!(bodyA.isStatic || bodyA.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyA.totalContacts;
                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
            }

            if (!(bodyB.isStatic || bodyB.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyB.totalContacts;
                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
            }
        }
    };

    /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */
    Resolver.postSolvePosition = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset contact count
            body.totalContacts = 0;

            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                // update body geometry
                for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                }

                // move the body without changing velocity
                body.positionPrev.x += body.positionImpulse.x;
                body.positionPrev.y += body.positionImpulse.y;

                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    // reset cached impulse if the body has velocity along it
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                } else {
                    // warm the next iteration
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                }
            }
        }
    };

    /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */
    Resolver.preSolveVelocity = function(pairs) {
        var i,
            j,
            pair,
            contacts,
            collision,
            bodyA,
            bodyB,
            normal,
            tangent,
            contact,
            contactVertex,
            normalImpulse,
            tangentImpulse,
            offset,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1];
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            contacts = pair.activeContacts;
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            tangent = collision.tangent;

            // resolve each contact
            for (j = 0; j < contacts.length; j++) {
                contact = contacts[j];
                contactVertex = contact.vertex;
                normalImpulse = contact.normalImpulse;
                tangentImpulse = contact.tangentImpulse;

                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    // total impulse from contact
                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                    
                    // apply impulse from contact
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyA.position, tempA);
                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }

                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyB.position, tempA);
                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                }
            }
        }
    };

    /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solveVelocity = function(pairs, timeScale) {
        var timeScaleSquared = timeScale * timeScale,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1],
            tempB = Vector._temp[2],
            tempC = Vector._temp[3],
            tempD = Vector._temp[4],
            tempE = Vector._temp[5];
        
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            var collision = pair.collision,
                bodyA = collision.parentA,
                bodyB = collision.parentB,
                normal = collision.normal,
                tangent = collision.tangent,
                contacts = pair.activeContacts,
                contactShare = 1 / contacts.length;

            // update body velocities
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // resolve each contact
            for (var j = 0; j < contacts.length; j++) {
                var contact = contacts[j],
                    contactVertex = contact.vertex,
                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),
                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),
                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),
                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), 
                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),
                    normalVelocity = Vector.dot(normal, relativeVelocity);

                var tangentVelocity = Vector.dot(tangent, relativeVelocity),
                    tangentSpeed = Math.abs(tangentVelocity),
                    tangentVelocityDirection = Common.sign(tangentVelocity);

                // raw impulses
                var normalImpulse = (1 + pair.restitution) * normalVelocity,
                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;

                // coulomb friction
                var tangentImpulse = tangentVelocity,
                    maxFriction = Infinity;

                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(
                        pair.friction * tangentVelocityDirection * timeScaleSquared,
                        -maxFriction, maxFriction
                    );
                }

                // modify impulses accounting for mass, inertia and offset
                var oAcN = Vector.cross(offsetA, normal),
                    oBcN = Vector.cross(offsetB, normal),
                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);

                normalImpulse *= share;
                tangentImpulse *= share;

                // handle high velocity and resting collisions separately
                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    // high normal velocity so clear cached contact normal impulse
                    contact.normalImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // impulse constraint tends to 0
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                }

                // handle high velocity and resting collisions separately
                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    // high tangent velocity so clear cached contact tangent impulse
                    contact.tangentImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                }

                // total impulse from contact
                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                
                // apply impulse from contact
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                }

                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                }
            }
        }
    };

})();


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/

var Engine = {};

module.exports = Engine;

var World = __webpack_require__(175);
var Sleeping = __webpack_require__(41);
var Resolver = __webpack_require__(178);
var Render = __webpack_require__(82);
var Pairs = __webpack_require__(177);
var Metrics = __webpack_require__(180);
var Grid = __webpack_require__(77);
var Events = __webpack_require__(24);
var Composite = __webpack_require__(23);
var Constraint = __webpack_require__(40);
var Common = __webpack_require__(0);
var Body = __webpack_require__(39);

(function() {

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */
    Engine.create = function(element, options) {
        // options may be passed as the first (and only) argument
        options = Common.isElement(element) ? options : element;
        element = Common.isElement(element) ? element : null;
        options = options || {};

        if (element || options.render) {
            Common.warn('Engine.create: engine.render is deprecated (see docs)');
        }

        var defaults = {
            positionIterations: 6,
            velocityIterations: 4,
            constraintIterations: 2,
            enableSleeping: false,
            events: [],
            plugin: {},
            timing: {
                timestamp: 0,
                timeScale: 1
            },
            broadphase: {
                controller: Grid
            }
        };

        var engine = Common.extend(defaults, options);

        // @deprecated
        if (element || engine.render) {
            var renderDefaults = {
                element: element,
                controller: Render
            };
            
            engine.render = Common.extend(renderDefaults, engine.render);
        }

        // @deprecated
        if (engine.render && engine.render.controller) {
            engine.render = engine.render.controller.create(engine.render);
        }

        // @deprecated
        if (engine.render) {
            engine.render.engine = engine;
        }

        engine.world = options.world || World.create(engine.world);
        engine.pairs = Pairs.create();
        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
        engine.metrics = engine.metrics || { extended: false };

        // @if DEBUG
        engine.metrics = Metrics.create(engine.metrics);
        // @endif

        return engine;
    };

    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */
    Engine.update = function(engine, delta, correction) {
        delta = delta || 1000 / 60;
        correction = correction || 1;

        var world = engine.world,
            timing = engine.timing,
            broadphase = engine.broadphase,
            broadphasePairs = [],
            i;

        // increment timestamp
        timing.timestamp += delta * timing.timeScale;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(engine, 'beforeUpdate', event);

        // get lists of all bodies and constraints, no matter what composites they are in
        var allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world);

        // @if DEBUG
        // reset metrics logging
        Metrics.reset(engine.metrics);
        // @endif

        // if sleeping enabled, call the sleeping controller
        if (engine.enableSleeping)
            Sleeping.update(allBodies, timing.timeScale);

        // applies gravity to all bodies
        _bodiesApplyGravity(allBodies, world.gravity);

        // update all body position and rotation by integration
        _bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);

        // update all constraints
        for (i = 0; i < engine.constraintIterations; i++) {
            Constraint.solveAll(allConstraints, timing.timeScale);
        }
        Constraint.postSolveAll(allBodies);

        // broadphase pass: find potential collision pairs
        if (broadphase.controller) {

            // if world is dirty, we must flush the whole grid
            if (world.isModified)
                broadphase.controller.clear(broadphase);

            // update the grid buckets based on current bodies
            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
            broadphasePairs = broadphase.pairsList;
        } else {

            // if no broadphase set, we just pass all bodies
            broadphasePairs = allBodies;
        }

        // clear all composite modified flags
        if (world.isModified) {
            Composite.setModified(world, false, false, true);
        }

        // narrowphase pass: find actual collisions, then create or update collision pairs
        var collisions = broadphase.detector(broadphasePairs, engine);

        // update collision pairs
        var pairs = engine.pairs,
            timestamp = timing.timestamp;
        Pairs.update(pairs, collisions, timestamp);
        Pairs.removeOld(pairs, timestamp);

        // wake up bodies involved in collisions
        if (engine.enableSleeping)
            Sleeping.afterCollisions(pairs.list, timing.timeScale);

        // trigger collision events
        if (pairs.collisionStart.length > 0)
            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });

        // iteratively resolve position between collisions
        Resolver.preSolvePosition(pairs.list);
        for (i = 0; i < engine.positionIterations; i++) {
            Resolver.solvePosition(pairs.list, timing.timeScale);
        }
        Resolver.postSolvePosition(allBodies);

        // iteratively resolve velocity between collisions
        Resolver.preSolveVelocity(pairs.list);
        for (i = 0; i < engine.velocityIterations; i++) {
            Resolver.solveVelocity(pairs.list, timing.timeScale);
        }

        // trigger collision events
        if (pairs.collisionActive.length > 0)
            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });

        if (pairs.collisionEnd.length > 0)
            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });

        // @if DEBUG
        // update metrics log
        Metrics.update(engine.metrics, engine);
        // @endif

        // clear force buffers
        _bodiesClearForces(allBodies);

        Events.trigger(engine, 'afterUpdate', event);

        return engine;
    };
    
    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */
    Engine.merge = function(engineA, engineB) {
        Common.extend(engineA, engineB);
        
        if (engineB.world) {
            engineA.world = engineB.world;

            Engine.clear(engineA);

            var bodies = Composite.allBodies(engineA.world);

            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                Sleeping.set(body, false);
                body.id = Common.nextId();
            }
        }
    };

    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */
    Engine.clear = function(engine) {
        var world = engine.world;
        
        Pairs.clear(engine.pairs);

        var broadphase = engine.broadphase;
        if (broadphase.controller) {
            var bodies = Composite.allBodies(world);
            broadphase.controller.clear(broadphase);
            broadphase.controller.update(broadphase, bodies, engine, true);
        }
    };

    /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method bodiesClearForces
     * @private
     * @param {body[]} bodies
     */
    var _bodiesClearForces = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset force buffers
            body.force.x = 0;
            body.force.y = 0;
            body.torque = 0;
        }
    };

    /**
     * Applys a mass dependant force to all given bodies.
     * @method bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */
    var _bodiesApplyGravity = function(bodies, gravity) {
        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;

        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {
            return;
        }
        
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            // apply gravity
            body.force.y += body.mass * gravity.y * gravityScale;
            body.force.x += body.mass * gravity.x * gravityScale;
        }
    };

    /**
     * Applys `Body.update` to all given `bodies`.
     * @method updateAll
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */
    var _bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            Body.update(body, deltaTime, timeScale, correction);
        }
    };

    /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method run
     * @param {engine} engine
     */

    /**
    * Fired just before an update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update and all collision events
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
    *
    * @event collisionStart
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
    *
    * @event collisionActive
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
    *
    * @event collisionEnd
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property positionIterations
     * @type number
     * @default 6
     */

    /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property velocityIterations
     * @type number
     * @default 4
     */

    /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * The default value of `2` is usually very adequate.
     *
     * @property constraintIterations
     * @type number
     * @default 2
     */

    /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     *
     * @property enableSleeping
     * @type boolean
     * @default false
     */

    /**
     * An `Object` containing properties regarding the timing systems of the engine. 
     *
     * @property timing
     * @type object
     */

    /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
     * A value of `0.1` gives a slow-motion effect.
     * A value of `1.2` gives a speed-up effect.
     *
     * @property timing.timeScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. 
     * It is incremented on every `Engine.update` by the given `delta` argument. 
     *
     * @property timing.timestamp
     * @type number
     * @default 0
     */

    /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
     *
     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     *
     * @property render
     * @type render
     * @deprecated see Demo.js for an example of creating a renderer
     * @default a Matter.Render instance
     */

    /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     *
     * @property broadphase
     * @type grid
     * @default a Matter.Grid instance
     */

    /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     *
     * @property world
     * @type world
     * @default a Matter.World instance
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

// @if DEBUG
/**
* _Internal Class_, not generally used outside of the engine's internals.
*
*/

var Metrics = {};

module.exports = Metrics;

var Composite = __webpack_require__(23);
var Common = __webpack_require__(0);

(function() {

    /**
     * Creates a new metrics.
     * @method create
     * @private
     * @return {metrics} A new metrics
     */
    Metrics.create = function(options) {
        var defaults = {
            extended: false,
            narrowDetections: 0,
            narrowphaseTests: 0,
            narrowReuse: 0,
            narrowReuseCount: 0,
            midphaseTests: 0,
            broadphaseTests: 0,
            narrowEff: 0.0001,
            midEff: 0.0001,
            broadEff: 0.0001,
            collisions: 0,
            buckets: 0,
            bodies: 0,
            pairs: 0
        };

        return Common.extend(defaults, false, options);
    };

    /**
     * Resets metrics.
     * @method reset
     * @private
     * @param {metrics} metrics
     */
    Metrics.reset = function(metrics) {
        if (metrics.extended) {
            metrics.narrowDetections = 0;
            metrics.narrowphaseTests = 0;
            metrics.narrowReuse = 0;
            metrics.narrowReuseCount = 0;
            metrics.midphaseTests = 0;
            metrics.broadphaseTests = 0;
            metrics.narrowEff = 0;
            metrics.midEff = 0;
            metrics.broadEff = 0;
            metrics.collisions = 0;
            metrics.buckets = 0;
            metrics.pairs = 0;
            metrics.bodies = 0;
        }
    };

    /**
     * Updates metrics.
     * @method update
     * @private
     * @param {metrics} metrics
     * @param {engine} engine
     */
    Metrics.update = function(metrics, engine) {
        if (metrics.extended) {
            var world = engine.world,
                bodies = Composite.allBodies(world);

            metrics.collisions = metrics.narrowDetections;
            metrics.pairs = engine.pairs.list.length;
            metrics.bodies = bodies.length;
            metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
            metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
            metrics.broadEff = (1 - (metrics.broadphaseTests / (bodies.length || 1))).toFixed(2);
            metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
            //var broadphase = engine.broadphase[engine.broadphase.current];
            //if (broadphase.instance)
            //    metrics.buckets = Common.keys(broadphase.instance.buckets).length;
        }
    };

})();
// @endif


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/

var Plugin = {};

module.exports = Plugin;

var Common = __webpack_require__(0);

(function() {

    Plugin._registry = {};

    /**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */
    Plugin.register = function(plugin) {
        if (!Plugin.isPlugin(plugin)) {
            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');
        }

        if (plugin.name in Plugin._registry) {
            var registered = Plugin._registry[plugin.name],
                pluginVersion = Plugin.versionParse(plugin.version).number,
                registeredVersion = Plugin.versionParse(registered.version).number;

            if (pluginVersion > registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));
                Plugin._registry[plugin.name] = plugin;
            } else if (pluginVersion < registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));
            } else if (plugin !== registered) {
                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');
            }
        } else {
            Plugin._registry[plugin.name] = plugin;
        }

        return plugin;
    };

    /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */
    Plugin.resolve = function(dependency) {
        return Plugin._registry[Plugin.dependencyParse(dependency).name];
    };

    /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */
    Plugin.toString = function(plugin) {
        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');
    };

    /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */
    Plugin.isPlugin = function(obj) {
        return obj && obj.name && obj.version && obj.install;
    };

    /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */
    Plugin.isUsed = function(module, name) {
        return module.used.indexOf(name) > -1;
    };

    /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */
    Plugin.isFor = function(plugin, module) {
        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));
    };

    /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick ✅ indicates a dependency was resolved and installed.
     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross ❌ indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */
    Plugin.use = function(module, plugins) {
        module.uses = (module.uses || []).concat(plugins || []);

        if (module.uses.length === 0) {
            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');
            return;
        }

        var dependencies = Plugin.dependencies(module),
            sortedDependencies = Common.topologicalSort(dependencies),
            status = [];

        for (var i = 0; i < sortedDependencies.length; i += 1) {
            if (sortedDependencies[i] === module.name) {
                continue;
            }

            var plugin = Plugin.resolve(sortedDependencies[i]);

            if (!plugin) {
                status.push('❌ ' + sortedDependencies[i]);
                continue;
            }

            if (Plugin.isUsed(module, plugin.name)) {
                continue;
            }

            if (!Plugin.isFor(plugin, module)) {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');
                plugin._warned = true;
            }

            if (plugin.install) {
                plugin.install(module);
            } else {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');
                plugin._warned = true;
            }

            if (plugin._warned) {
                status.push('🔶 ' + Plugin.toString(plugin));
                delete plugin._warned;
            } else {
                status.push('✅ ' + Plugin.toString(plugin));
            }

            module.used.push(plugin.name);
        }

        if (status.length > 0) {
            Common.info(status.join('  '));
        }
    };

    /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */
    Plugin.dependencies = function(module, tracked) {
        var parsedBase = Plugin.dependencyParse(module),
            name = parsedBase.name;

        tracked = tracked || {};

        if (name in tracked) {
            return;
        }

        module = Plugin.resolve(module) || module;

        tracked[name] = Common.map(module.uses || [], function(dependency) {
            if (Plugin.isPlugin(dependency)) {
                Plugin.register(dependency);
            }

            var parsed = Plugin.dependencyParse(dependency),
                resolved = Plugin.resolve(dependency);

            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',
                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'
                );

                resolved._warned = true;
                module._warned = true;
            } else if (!resolved) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',
                    Plugin.toString(parsedBase), 'could not be resolved.'
                );

                module._warned = true;
            }

            return parsed.name;
        });

        for (var i = 0; i < tracked[name].length; i += 1) {
            Plugin.dependencies(tracked[name][i], tracked);
        }

        return tracked;
    };

    /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */
    Plugin.dependencyParse = function(dependency) {
        if (Common.isString(dependency)) {
            var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;

            if (!pattern.test(dependency)) {
                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');
            }

            return {
                name: dependency.split('@')[0],
                range: dependency.split('@')[1] || '*'
            };
        }

        return {
            name: dependency.name,
            range: dependency.range || dependency.version
        };
    };

    /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */
    Plugin.versionParse = function(range) {
        var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;

        if (!pattern.test(range)) {
            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');
        }

        var identifiers = range.split('-');
        range = identifiers[0];

        var isRange = isNaN(Number(range[0])),
            version = isRange ? range.substr(1) : range,
            parts = Common.map(version.split('.'), function(part) {
                return Number(part);
            });

        return {
            isRange: isRange,
            version: version,
            range: range,
            operator: isRange ? range[0] : '',
            parts: parts,
            prerelease: identifiers[1],
            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
        };
    };

    /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */
    Plugin.versionSatisfies = function(version, range) {
        range = range || '*';

        var rangeParsed = Plugin.versionParse(range),
            rangeParts = rangeParsed.parts,
            versionParsed = Plugin.versionParse(version),
            versionParts = versionParsed.parts;

        if (rangeParsed.isRange) {
            if (rangeParsed.operator === '*' || version === '*') {
                return true;
            }

            if (rangeParsed.operator === '~') {
                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
            }

            if (rangeParsed.operator === '^') {
                if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                }

                if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }

                return versionParts[2] === rangeParts[2];
            }
        }

        return version === range || version === '*';
    };

})();


/***/ },
/* 182 */
/***/ function(module, exports) {

module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    makeCCW: polygonMakeCCW
};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2){
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	var da = q2[0] - q1[0];
	var db = q2[1] - q1[1];

	// segments are parallel
	if((da*dy - db*dx) === 0){
		return false;
	}

	var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
	var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);

	return (s>=0 && s<=1 && t>=0 && t<=1);
}

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
}

function isLeft(a,b,c){
    return triangleArea(a,b,c) > 0;
}

function isLeftOn(a,b,c) {
    return triangleArea(a, b, c) >= 0;
}

function isRight(a,b,c) {
    return triangleArea(a, b, c) < 0;
}

function isRightOn(a,b,c) {
    return triangleArea(a, b, c) <= 0;
}

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a,b,c,thresholdAngle) {
    if(!thresholdAngle){
        return triangleArea(a, b, c) === 0;
    } else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
}

function sqdist(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i){
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon){
    polygon.length = 0;
}

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to){
    for(var i=from; i<to; i++){
        polygon.push(poly[i]);
    }
}

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon){
    var br = 0,
        v = polygon;

    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
    }
}

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon){
    var tmp = [];
    var N = polygon.length;
    for(var i=0; i!==N; i++){
        tmp.push(polygon.pop());
    }
    for(var i=0; i!==N; i++){
		polygon[i] = tmp[i];
    }
}

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i){
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1,l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
}

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i,j,targetPoly){
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++){
            p.push(polygon[k]);
        }

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++){
            p.push(polygon[k]);
        }

        // Insert vertices i to end
        for(var k=i; k<polygon.length; k++){
            p.push(polygon[k]);
        }
    }

    return p;
}

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min=[], tmp1=[], tmp2=[], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                    for(var k=0; k<tmp2.length; k++){
                        tmp1.push(tmp2[k]);
                    }

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                }
            }
        }
    }

    return min;
}

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon){
    var edges = polygonGetCutEdges(polygon);
    if(edges.length > 0){
        return polygonSlice(polygon, edges);
    } else {
        return [polygon];
    }
}

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges){
    if(cutEdges.length === 0){
		return [polygon];
    }
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){

        var polys = [polygon];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);

        if(i !== -1 && j !== -1){
            return [polygonCopy(polygon, i,j),
                    polygonCopy(polygon, j,i)];
        } else {
            return false;
        }
    }
}

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon){
    var path = polygon, i;
    // Check
    for(i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(i=1; i<path.length-2; i++){
        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
}

function getIntersectionPoint(p1, p2, q1, q2, delta){
	delta = delta || 0;
	var a1 = p2[1] - p1[1];
	var b1 = p1[0] - p2[0];
	var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	var a2 = q2[1] - q1[1];
	var b2 = q1[0] - q2[0];
	var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	var det = (a1 * b2) - (a2 * b1);

	if(!scalar_eq(det,0,delta)){
		return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];
	} else {
		return [0,0];
    }
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!=="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=[], upperPoly=[]; // polygons
    var poly = polygon,
        v = polygon;

    if(v.length < 3){
		return result;
    }

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly,i,poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly,0,upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly,i,closestIndex+1);
                    if (closestIndex !== 0){
                        polygonAppend(upperPoly, poly,closestIndex,v.length);
                    }
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        polygonAppend(lowerPoly, poly,i,v.length);
                    }
                    polygonAppend(lowerPoly, poly,0,closestIndex+1);
                    polygonAppend(upperPoly, poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(polygon);

    return result;
}

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision){
    var num = 0;
    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){
        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){
            // Remove the middle point
            polygon.splice(i%polygon.length,1);
            num++;
        }
    }
    return num;
}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
}


/***/ },
/* 183 */
/***/ function(module, exports) {

var CreateTexture2DImage = function (gl, pixels, filter, mipLevels)
{
    var texture = gl.createTexture();
    mipLevels = mipLevels || 0;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texImage2D(
        gl.TEXTURE_2D,
        mipLevels,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        pixels
    );
    return texture;
};

module.exports = CreateTexture2DImage;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var EventDispatcher = __webpack_require__(26);
var GameObjectFactory = __webpack_require__(612);
var GameObjectCreator = __webpack_require__(611);
var StateManager = __webpack_require__(614);
var Loader = __webpack_require__(613);
var UpdateManager = __webpack_require__(615);
var Component = __webpack_require__(5);
var Settings = __webpack_require__(608);
var RTree = __webpack_require__(617);
var CameraManager = __webpack_require__(610);
var StableSort = __webpack_require__(647);

var Systems = function (state, config)
{
    this.state = state;

    this.game = null;

    this.config = config;

    this.settings = Settings.create(config);

    this.x = this.settings.x;
    this.y = this.settings.y;
    this.width = this.settings.width;
    this.height = this.settings.height;

    this.mask = null;
    this.canvas;
    this.context;

    //  CORE SYSTEMS / PROPERTIES

    this.cache;
    this.textures;

    //  Reference to State specific managers (Factory, Tweens, Loader, Physics, etc)
    this.add;
    this.make;
    this.load;
    this.events;
    this.updates;
    this.tree;
    this.stateManager;

    //  State properties
    this.cameras;
    this.children;
    this.color;
    this.data;
    // this.fbo;
    this.time;
    this.transform;
};

Systems.prototype.constructor = Systems;

Systems.prototype = {

    init: function (game)
    {
        // console.log('State.Systems.init');

        this.game = game;

        Settings.init(this.settings, this.game.config);

        this.width = this.settings.width;
        this.height = this.settings.height;

        this.cache = this.game.cache;
        this.textures = this.game.textures;

        //  State specific managers (Factory, Tweens, Loader, Physics, etc)

        this.tree = RTree(16);
        this.events = new EventDispatcher();
        this.add = new GameObjectFactory(this.state);
        this.make = new GameObjectCreator(this.state);
        this.updates = new UpdateManager(this.state);
        this.load = new Loader(this.state);
        this.stateManager = new StateManager(this.state, game);
        this.cameras = new CameraManager(this.state);

        //  State specific properties (transform, data, children, etc)

        this.children = new Component.Children(this.state);
        this.color = new Component.Color(this.state);
        this.data = new Component.Data(this.state);

        this.inject();
    },

    inject: function ()
    {
        //  Defaults properties injected into the State

        this.state.game = this.game;

        this.state.events = this.events;
        this.state.add = this.add;
        this.state.load = this.load;
        this.state.children = this.children;
        this.state.color = this.color;
        this.state.data = this.data;
        this.state.settings = this.settings;
        this.state.state = this.stateManager;
        this.state.cameras = this.cameras;

        this.state.cache = this.game.cache;
        this.state.input = this.game.input;
        this.state.textures = this.game.textures;
        this.state.sortChildrenFlag = false;
    },

    //  Called just once per frame, regardless of speed
    begin: function (timestamp, frameDelta)
    {
        var state = this.state;
        if (state.sortChildrenFlag)
        {
            /* Sort the current state children */
            StableSort.inplace(state.children.list, function (childA, childB) {
                return childA._z - childB._z;
            });
            state.sortChildrenFlag = false;
        }
    },

    //  Potentially called multiple times per frame (on super-fast systems)
    update: function (timestep, physicsStep)
    {
        this.cameras.update(timestep);

        this.state.update.call(this.state, timestep, physicsStep);
    },

    render: function (interpolation, renderer)
    {
        if (!this.settings.visible)
        {
            return;
        }

        this.cameras.render(renderer, this.children, interpolation);
    }
};

module.exports = Systems;


/***/ },
/* 185 */
/***/ function(module, exports) {

// A Set is a collection of unique elements.

var Set = function (elements)
{
    this.entries = [];

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.set(elements[i]);
        }
    }
};

Set.prototype.constructor = Set;

Set.prototype = {

    set: function (value)
    {
        if (this.entries.indexOf(value) === -1)
        {
            this.entries.push(value);
        }

        return this;
    },

    get: function (property, value)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];

            if (entry[property] === value)
            {
                return entry;
            }
        }
    },

    delete: function (value)
    {
        var index = this.entries.indexOf(value);

        if (index > -1)
        {
            this.entries.splice(index, 1);
        }

        return this;
    },

    dump: function ()
    {
        console.group('Set');

        for (var i = 0; i < this.entries.length; i++)
        {
            var entry = this.entries[i];
            console.log(entry);
        }

        console.groupEnd();
    },


    //  For when you know this Set will be modified during the iteration
    each: function (callback)
    {
        var temp = this.entries.slice();

        for (var i = 0; i < temp.length; i++)
        {
            if (callback(temp[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    //  For when you absolutely know this Set won't be modified during the iteration
    iterate: function (callback)
    {
        for (var i = 0; i < this.entries.length; i++)
        {
            if (callback(this.entries[i]) === false)
            {
                break;
            }
        }

        return this;
    },

    clear: function ()
    {
        this.entries.length = 0;

        return this;
    },

    contains: function (value)
    {
        return (this.entries.indexOf(value) > -1);
    },

    union: function (set)
    {
        var newSet = new Set();

        set.values.forEach(function (value)
        {
            newSet.add(value);
        });

        this.entries.forEach(function (value)
        {
            newSet.add(value);
        });

        return newSet;
    },

    intersect: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    },

    difference: function (set)
    {
        var newSet = new Set();

        this.entries.forEach(function (value)
        {
            if (!set.contains(value))
            {
                newSet.add(value);
            }
        });

        return newSet;
    }

};

Object.defineProperties(Set.prototype, {

    size: {

        enumerable: true,

        get: function ()
        {
            return this.entries.length;
        },

        set: function (value)
        {
            return this.entries.length = value;
        }

    }

});

module.exports = Set;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(33);
var GetBottom = __webpack_require__(13);
var SetCenterX = __webpack_require__(35);
var SetBottom = __webpack_require__(17);

var InBottomCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomCenter;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetBottom = __webpack_require__(13);
var SetLeft = __webpack_require__(18);
var SetBottom = __webpack_require__(17);

var InBottomLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomLeft;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetBottom = __webpack_require__(13);
var SetRight = __webpack_require__(19);
var SetBottom = __webpack_require__(17);

var InBottomRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetBottom(gameObject, GetBottom(container) + offsetY);

    return gameObject;
};

module.exports = InBottomRight;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(33);
var GetCenterY = __webpack_require__(34);
var CenterOn = __webpack_require__(203);

var InCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    CenterOn(gameObject, GetCenterX(container) + offsetX, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InCenter;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetCenterY = __webpack_require__(34);
var SetLeft = __webpack_require__(18);
var SetCenterY = __webpack_require__(36);

var InLeftCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InLeftCenter;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetCenterY = __webpack_require__(34);
var SetRight = __webpack_require__(19);
var SetCenterY = __webpack_require__(36);

var InRightCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetCenterY(gameObject, GetCenterY(container) + offsetY);

    return gameObject;
};

module.exports = InRightCenter;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(33);
var GetTop = __webpack_require__(16);
var SetCenterX = __webpack_require__(35);
var SetTop = __webpack_require__(20);

var InTopCenter = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopCenter;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetTop = __webpack_require__(16);
var SetLeft = __webpack_require__(18);
var SetTop = __webpack_require__(20);

var InTopLeft = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(container) - offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopLeft;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetTop = __webpack_require__(16);
var SetRight = __webpack_require__(19);
var SetTop = __webpack_require__(20);

var InTopRight = function (gameObject, container, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(container) + offsetX);
    SetTop(gameObject, GetTop(container) - offsetY);

    return gameObject;
};

module.exports = InTopRight;


/***/ },
/* 195 */
/***/ function(module, exports) {

var CONST = {

    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @type {integer}
    */
    BOTTOM_RIGHT: 12

};

module.exports = CONST;


/***/ },
/* 196 */
/***/ function(module, exports) {

/**
* Create an array representing the range of numbers (usually integers), between, and inclusive of,
* the given `start` and `end` arguments. For example:
*
* `var array = numberArray(2, 4); // array = [2, 3, 4]`
* `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
* 
* This is equivalent to `numberArrayStep(start, end, 1)`.
* 
* You can optionally provide a prefix and / or suffix string. If given the array will contain
* strings, not integers. For example:
* 
* `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
* `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
*
* @method Phaser.ArrayUtils#numberArray
* @param {number} start - The minimum value the array starts with.
* @param {number} end - The maximum value the array contains.
* @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.
* @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.
* @return {number[]|string[]} The array of number values, or strings if a prefix or suffix was provided.
*/
var NumberArray = function (start, end, prefix, suffix)
{
    var result = [];

    for (var i = start; i <= end; i++)
    {
        if (prefix || suffix)
        {
            var key = (prefix) ? prefix + i.toString() : i.toString();

            if (suffix)
            {
                key = key.concat(suffix);
            }

            result.push(key);
        }
        else
        {
            result.push(i);
        }
    }

    return result;
};

module.exports = NumberArray;


/***/ },
/* 197 */
/***/ function(module, exports) {

//  This is from the quickselect npm package: https://www.npmjs.com/package/quickselect
//  Coded by https://www.npmjs.com/~mourner (Vladimir Agafonkin)

// https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

var QuickSelect = function (arr, k, left, right, compare)
{
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left)
    {
        if (right - left > 600)
        {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));

            QuickSelect(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);

        if (compare(arr[right], t) > 0)
        {
            swap(arr, left, right);
        }

        while (i < j)
        {
            swap(arr, i, j);

            i++;
            j--;

            while (compare(arr[i], t) < 0)
            {
                i++;
            }

            while (compare(arr[j], t) > 0)
            {
                j--;
            }
        }

        if (compare(arr[left], t) === 0)
        {
            swap(arr, left, j);
        }
        else
        {
            j++;
            swap(arr, j, right);
        }

        if (j <= k)
        {
            left = j + 1;
        }

        if (k <= j)
        {
            right = j - 1;
        }
    }
};

function swap (arr, i, j)
{
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare (a, b)
{
    return a < b ? -1 : a > b ? 1 : 0;
}

module.exports = QuickSelect;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

var Shuffle = __webpack_require__(201);
var GetObjectValue = __webpack_require__(9);

var BuildChunk = function (a, b, qty)
{
    var out = [];

    for (var aIndex = 0; aIndex < a.length; aIndex++)
    {
        for (var bIndex = 0; bIndex < b.length; bIndex++)
        {
            for (var i = 0; i < qty; i++)
            {
                out.push({ a: a[aIndex], b: b[bIndex] });
            }
        }
    }

    return out;
};

//  options = repeat, random, randomB, yoyo, max, qty

//  Range ([a,b,c], [1,2,3]) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2,3], qty = 3) =
//  a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3

//  Range ([a,b,c], [1,2,3], repeat x1) =
//  a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3

//  Range ([a,b], [1,2], repeat -1 = endless, max = 14) =
//  Maybe if max is set then repeat goes to -1 automatically?
//  a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)

//  Range ([a], [1,2,3,4,5], random = true) =
//  a4, a1, a5, a2, a3

//  Range ([a, b], [1,2,3], random = true) =
//  b3, a2, a1, b1, a3, b2

//  Range ([a, b, c], [1,2,3], randomB = true) =
//  a3, a1, a2, b2, b3, b1, c1, c3, c2

//  Range ([a], [1,2,3,4,5], yoyo = true) =
//  a1, a2, a3, a4, a5, a5, a4, a3, a2, a1

//  Range ([a, b], [1,2,3], yoyo = true) =
//  a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1

var Range = function (a, b, options)
{
    var max = GetObjectValue(options, 'max', 0);
    var qty = GetObjectValue(options, 'qty', 1);
    var random = GetObjectValue(options, 'random', false);
    var randomB = GetObjectValue(options, 'randomB', false);
    var repeat = GetObjectValue(options, 'repeat', 0);
    var yoyo = GetObjectValue(options, 'yoyo', false);

    var out = [];

    if (randomB)
    {
        Shuffle(b);
    }

    //  Endless repeat, so limit by max
    if (repeat === -1)
    {
        if (max === 0)
        {
            repeat = 0;
        }
        else
        {
            //  Work out how many repeats we need
            var total = (a.length * b.length) * qty;

            if (yoyo)
            {
                total *= 2;
            }

            repeat = Math.ceil(max / total);
        }
    }

    for (var i = 0; i <= repeat; i++)
    {
        var chunk = BuildChunk(a, b, qty);

        if (random)
        {
            Shuffle(chunk);
        }

        out = out.concat(chunk);

        if (yoyo)
        {
            chunk.reverse();

            out = out.concat(chunk);
        }
    }

    if (max)
    {
        out.splice(max);
    }

    return out;
};

module.exports = Range;


/***/ },
/* 199 */
/***/ function(module, exports) {

/**
* Moves the element at the start of the array to the end, shifting all items in the process.
* The "rotation" happens to the left.
*
* @method Phaser.ArrayUtils.rotate
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateLeft = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.shift();
        array.push(element);
    }

    return element;
};

module.exports = RotateLeft;


/***/ },
/* 200 */
/***/ function(module, exports) {

/**
* Moves the element at the end of the array to the start, shifting all items in the process.
* The "rotation" happens to the right.
*
* @param {any[]} array - The array to shift/rotate. The array is modified.
* @param {integer} [total=1] - The number of times to shift the array. Only the most recently shifted element is returned.
* @return {any} The shifted value.
*/
var RotateRight = function (array, total)
{
    if (total === undefined) { total = 1; }

    var element = null;

    for (var i = 0; i < total; i++)
    {
        element = array.pop();
        array.unshift(element);
    }

    return element;
};

module.exports = RotateRight;


/***/ },
/* 201 */
/***/ function(module, exports) {

/**
* A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
*
* @method
* @param {any[]} array - The array to shuffle.
* @return {any[]} The original array, now shuffled.
*/
var Shuffle = function (array)
{
    for (var i = array.length - 1; i > 0; i--)
    {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    return array;
};

module.exports = Shuffle;


/***/ },
/* 202 */
/***/ function(module, exports) {

//  Removes a single item from an array and returns it
//  without creating gc (like the native splice does)
//  Based on code by Mike Reinstein

var SpliceOne = function (array, index)
{
    if (index >= array.length)
    {
        return;
    }

    var len = array.length - 1;

    var item = array[index];

    for (var i = index; i < len; i++)
    {
        array[i] = array[i + 1];
    }

    array.length = len;

    return item;
};

module.exports = SpliceOne;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

var SetCenterX = __webpack_require__(35);
var SetCenterY = __webpack_require__(36);

/**
* The center x coordinate of the Game Object.
* This is the same as `(x - offsetX) + (width / 2)`.
*
* @property {number} centerX
*/

var CenterOn = function (gameObject, x, y)
{
    SetCenterX(gameObject, x);

    return SetCenterY(gameObject, y);
};

module.exports = CenterOn;


/***/ },
/* 204 */
/***/ function(module, exports) {

/**
* This is a slightly modified version of jQuery.isPlainObject.
* A plain object is an object whose internal class property is [object Object].
* @method Phaser.Utils.isPlainObject
* @param {object} obj - The object to inspect.
* @return {boolean} - true if the object is plain, otherwise false.
*/
var IsPlainObject = function (obj)
{
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window)
    {
        return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf"))
        {
            return false;
        }
    } catch (e) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
};

module.exports = IsPlainObject;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Config = __webpack_require__(256);
var DebugHeader = __webpack_require__(258);
var Device = __webpack_require__(285);

var AddToDOM = __webpack_require__(95);
var DOMContentLoaded = __webpack_require__(96);

var MainLoop = __webpack_require__(259);
var CreateRenderer = __webpack_require__(257);
var GlobalInputManager = __webpack_require__(481);
var GlobalStateManager = __webpack_require__(607);
var AnimationManager = __webpack_require__(255);
var TextureManager = __webpack_require__(620);
var Data = __webpack_require__(92);
var Cache = __webpack_require__(261);

var Game = function (config)
{
    this.config = new Config(config);

    this.renderer = null;
    this.canvas = null;
    this.context = null;

    this.isBooted = false;
    this.isRunning = false;

    /**
    * @property {Phaser.AnimationManager} anims - Reference to the Phaser Animation Manager.
    */
    this.anims = new AnimationManager(this);

    /**
    * @property {Phaser.TextureManager} textures - Reference to the Phaser Texture Manager.
    */
    this.textures = new TextureManager(this);

    /**
    * @property {Phaser.Cache} cache - Reference to the assets cache.
    */
    this.cache = new Cache();

    /**
    * @property {Phaser.Data} registry - Game wide data store.
    */
    this.registry = new Data(this);

    /**
    * @property {Phaser.Input} input - Reference to the input manager
    */
    this.input = new GlobalInputManager(this, this.config);

    /**
    * @property {Phaser.GlobalStateManager} state - The StateManager. Phaser instance specific.
    */
    this.state = new GlobalStateManager(this, this.config.stateConfig);

    /**
    * @property {Phaser.Device} device - Contains device information and capabilities (singleton)
    */
    this.device = Device;

    /**
    * @property {Phaser.MainLoop} mainloop - Main Loop handler.
    * @protected
    */
    this.mainloop = new MainLoop(this, this.config.fps);

    //  Wait for the DOM Ready event, then call boot.
    DOMContentLoaded(this.boot.bind(this));

    //  For debugging only
    window.game = this;
};

Game.prototype.constructor = Game;

Game.prototype = {

    boot: function ()
    {
        this.isBooted = true;

        this.config.preBoot();

        DebugHeader(this);

        CreateRenderer(this);

        AddToDOM(this.canvas, this.config.parent);

        this.state.boot();

        this.input.boot();

        this.isRunning = true;

        this.config.postBoot();

        this.mainloop.start();
    }

};

module.exports = Game;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    AddEventListener: __webpack_require__(286),
    AddToDOM: __webpack_require__(95),
    CanvasInterpolation: __webpack_require__(56),
    CanvasPool: __webpack_require__(22),
    DOMContentLoaded: __webpack_require__(96),
    ParseXML: __webpack_require__(97),
    RemoveEventListener: __webpack_require__(287),
    RemoveFromDOM: __webpack_require__(288),
    RequestAnimationFrame: __webpack_require__(98),
    TouchAction: __webpack_require__(289),
    UserSelect: __webpack_require__(290)

};


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

//  Required, but don't need Phaser level exports
//  (maybe these should be Phaser export level?)

__webpack_require__(303);
__webpack_require__(308);
__webpack_require__(316);
__webpack_require__(321);
__webpack_require__(299);
__webpack_require__(295);
__webpack_require__(312);
__webpack_require__(328);
__webpack_require__(319);
__webpack_require__(331);

//  Phaser.GameObjects

module.exports = {

    Factory: __webpack_require__(4),

    BitmapText: __webpack_require__(102),
    Blitter: __webpack_require__(103),
    Container: __webpack_require__(104),
    DynamicBitmapText: __webpack_require__(101),
    Graphics: __webpack_require__(105),
    Image: __webpack_require__(106),
    Layer: __webpack_require__(107),
    Sprite: __webpack_require__(58),
    Text: __webpack_require__(108),
    Zone: __webpack_require__(59)

};


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom

module.exports = {
    
    Circle: __webpack_require__(343),
    Ellipse: __webpack_require__(353),
    Hermite: __webpack_require__(360),
    Intersects: __webpack_require__(371),
    Line: __webpack_require__(390),
    Point: __webpack_require__(410),
    Polygon: __webpack_require__(416),
    Rectangle: __webpack_require__(442),
    Triangle: __webpack_require__(456)

};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics

module.exports = {

    BlendModes: __webpack_require__(471),
    Color: __webpack_require__(480)
  
};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Input

module.exports = {

    Keyboard: __webpack_require__(488)

};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Physics

module.exports = {
    PolyDecomp: __webpack_require__(182),
    MatterJS: __webpack_require__(569)
};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(571);
__webpack_require__(572);
__webpack_require__(573);
__webpack_require__(577);
__webpack_require__(574);
__webpack_require__(575);
__webpack_require__(578);
__webpack_require__(579);
__webpack_require__(576);


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound

module.exports = {

    Dynamic: __webpack_require__(606)

};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Utils.Align

module.exports = {

    InBottomCenter: __webpack_require__(186),
    InBottomLeft: __webpack_require__(187),
    InBottomRight: __webpack_require__(188),
    InCenter: __webpack_require__(189),
    InLeftCenter: __webpack_require__(190),
    InRightCenter: __webpack_require__(191),
    InTopCenter: __webpack_require__(192),
    InTopLeft: __webpack_require__(193),
    InTopRight: __webpack_require__(194),
    ToBottomCenter: __webpack_require__(631),
    ToBottomLeft: __webpack_require__(632),
    ToBottomRight: __webpack_require__(633),
    ToLeftBottom: __webpack_require__(634),
    ToLeftCenter: __webpack_require__(635),
    ToLeftTop: __webpack_require__(636),
    ToRightBottom: __webpack_require__(637),
    ToRightCenter: __webpack_require__(638),
    ToRightTop: __webpack_require__(639),
    ToTopCenter: __webpack_require__(640),
    ToTopLeft: __webpack_require__(641),
    ToTopRight: __webpack_require__(642)

};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    FindClosestInSorted: __webpack_require__(643),
    GetRandomElement: __webpack_require__(644),
    NumberArray: __webpack_require__(196),
    NumberArrayStep: __webpack_require__(645),
    QuickSelect: __webpack_require__(197),
    Range: __webpack_require__(198),
    RemoveRandomElement: __webpack_require__(646),
    RotateLeft: __webpack_require__(199),
    RotateRight: __webpack_require__(200),
    Shuffle: __webpack_require__(201),
    SpliceOne: __webpack_require__(202)

};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Utils.Bounds

module.exports = {

    CenterOn: __webpack_require__(203),
    GetBottom: __webpack_require__(13),
    GetCenterX: __webpack_require__(33),
    GetCenterY: __webpack_require__(34),
    GetLeft: __webpack_require__(14),
    GetOffsetX: __webpack_require__(648),
    GetOffsetY: __webpack_require__(649),
    GetRight: __webpack_require__(15),
    GetTop: __webpack_require__(16),
    SetBottom: __webpack_require__(17),
    SetCenterX: __webpack_require__(35),
    SetCenterY: __webpack_require__(36),
    SetLeft: __webpack_require__(18),
    SetRight: __webpack_require__(19),
    SetTop: __webpack_require__(20)
    
};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Extend: __webpack_require__(55),
    IsPlainObject: __webpack_require__(204)

};


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Pad: __webpack_require__(650),
    Reverse: __webpack_require__(651)

};


/***/ },
/* 219 */
/***/ function(module, exports) {

var Angle = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].angle += value;
    }

    return items;
};

module.exports = Angle;


/***/ },
/* 220 */
/***/ function(module, exports) {

var Call = function (items, callback, thisArg)
{
    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        callback.call(thisArg, item);
    }

    return items;
};

module.exports = Call;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(195);
var AlignIn = __webpack_require__(630);
var Zone = __webpack_require__(59);
var GetObjectValue = __webpack_require__(9);

var tempZone = new Zone({}, 0, 0, 1, 1);

/**
* This method iterates through all children in the Group (regardless if they are visible or exist)
* and then changes their position so they are arranged in a Grid formation. Children must have
* the `alignTo` method in order to be positioned by this call. All default Phaser Game Objects have
* this.
*
* The grid dimensions are determined by the first four arguments. The `width` and `height` arguments
* relate to the width and height of the grid respectively.
*
* For example if the Group had 100 children in it:
*
* `Group.align(10, 10, 32, 32)`
*
* This will align all of the children into a grid formation of 10x10, using 32 pixels per
* grid cell. If you want a wider grid, you could do:
* 
* `Group.align(25, 4, 32, 32)`
*
* This will align the children into a grid of 25x4, again using 32 pixels per grid cell.
*
* You can choose to set _either_ the `width` or `height` value to -1. Doing so tells the method
* to keep on aligning children until there are no children left. For example if this Group had
* 48 children in it, the following:
*
* `Group.align(-1, 8, 32, 32)`
*
* ... will align the children so that there are 8 children vertically (the second argument), 
* and each row will contain 6 sprites, except the last one, which will contain 5 (totaling 48)
*
* You can also do:
* 
* `Group.align(10, -1, 32, 32)`
*
* In this case it will create a grid 10 wide, and as tall as it needs to be in order to fit
* all of the children in.
*
* The `position` property allows you to control where in each grid cell the child is positioned.
* This is a constant and can be one of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, 
* `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, 
* `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.
*
* The final argument; `offset` lets you start the alignment from a specific child index.
*
* @method Phaser.Group#align
* @param {integer} width - The width of the grid in items (not pixels). Set to -1 for a dynamic width. If -1 then you must set an explicit height value.
* @param {integer} height - The height of the grid in items (not pixels). Set to -1 for a dynamic height. If -1 then you must set an explicit width value.
* @param {integer} cellWidth - The width of each grid cell, in pixels.
* @param {integer} cellHeight - The height of each grid cell, in pixels.
* @param {integer} [position] - The position constant. One of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.
* @return {boolean} True if the Group children were aligned, otherwise false.
*/
var GridAlign = function (items, options)
{
    var width = GetObjectValue(options, 'width', -1);
    var height = GetObjectValue(options, 'height', -1);
    var cellWidth = GetObjectValue(options, 'cellWidth', 1);
    var cellHeight = GetObjectValue(options, 'cellHeight', cellWidth);
    var position = GetObjectValue(options, 'position', CONST.TOP_LEFT);
    var x = GetObjectValue(options, 'x', 0);
    var y = GetObjectValue(options, 'y', 0);
    // var centerX = GetObjectValue(options, 'centerX', null);
    // var centerY = GetObjectValue(options, 'centerY', null);

    var cx = 0;
    var cy = 0;
    var w = (width * cellWidth);
    var h = (height * cellHeight);

    //  If the Grid is centered on a position then we need to calculate it now
    // if (centerX !== null && centerY !== null)
    // {
        // 
    // }

    tempZone.setPosition(x, y);
    tempZone.setSize(cellWidth, cellHeight);

    for (var i = 0; i < items.length; i++)
    {
        AlignIn(items[i], tempZone, position);

        if (width === -1)
        {
            //  We keep laying them out horizontally until we've done them all
            cy += cellHeight;
            tempZone.y += cellHeight;

            if (cy === h)
            {
                cy = 0;
                tempZone.x += cellWidth;
                tempZone.y = y;
            }
        }
        else if (height === -1)
        {
            //  We keep laying them out vertically until we've done them all
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                tempZone.x = x;
                tempZone.y += cellHeight;
            }
        }
        else
        {
            //  We keep laying them out until we hit the column limit
            cx += cellWidth;
            tempZone.x += cellWidth;

            if (cx === w)
            {
                cx = 0;
                cy += cellHeight;
                tempZone.x = x;
                tempZone.y += cellHeight;

                if (cy === h)
                {
                    //  We've hit the column limit, so return, even if there are items left
                    break;
                }
            }
        }
    }

    return items;
};

module.exports = GridAlign;


/***/ },
/* 222 */
/***/ function(module, exports) {

var IncAlpha = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha += value;
    }

    return items;
};

module.exports = IncAlpha;


/***/ },
/* 223 */
/***/ function(module, exports) {

var IncX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += value;
    }

    return items;
};

module.exports = IncX;


/***/ },
/* 224 */
/***/ function(module, exports) {

var IncXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].x += x;
        items[i].y += y;
    }

    return items;
};

module.exports = IncXY;


/***/ },
/* 225 */
/***/ function(module, exports) {

var IncY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].y += value;
    }

    return items;
};

module.exports = IncY;


/***/ },
/* 226 */
/***/ function(module, exports) {

var PlaceOnCircle = function (items, circle, startAngle, endAngle)
{
    if (startAngle === undefined) { startAngle = 0; }
    if (endAngle === undefined) { endAngle = 6.28; }

    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = circle.x + (circle.radius * Math.cos(angle));
        items[i].y = circle.y + (circle.radius * Math.sin(angle));

        angle += angleStep;
    }

    return items;
};

module.exports = PlaceOnCircle;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(63);

var PlaceOnLine = function (items, line)
{
    var points = GetPointsOnLine(line);
    var step = points.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = points[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnLine;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

var MarchingAnts = __webpack_require__(127);
var RotateLeft = __webpack_require__(199);
var RotateRight = __webpack_require__(200);

//  Place the items in the array around the perimeter of the given rectangle.

//  Placement starts from the top-left of the rectangle, and proceeds in a
//  clockwise direction. If the shift parameter is given you can offset where
//  placement begins.

var PlaceOnRectangle = function (items, rect, shift)
{
    if (shift === undefined) { shift = 0; }

    var points = MarchingAnts(rect, false, items.length);

    if (shift > 0)
    {
        RotateLeft(points, shift);
    }
    else if (shift < 0)
    {
        RotateRight(points, Math.abs(shift));
    }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = points[i].x;
        items[i].y = points[i].y;
    }

    return items;
};

module.exports = PlaceOnRectangle;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

var GetPointsOnLine = __webpack_require__(63);

var PlaceOnTriangle = function (items, triangle, stepRate)
{
    var p1 = GetPointsOnLine({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);
    var p2 = GetPointsOnLine({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);
    var p3 = GetPointsOnLine({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);

    //  Remove overlaps
    p1.pop();
    p2.pop();
    p3.pop();

    p1 = p1.concat(p2, p3);

    var step = p1.length / items.length;
    var p = 0;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];
        var point = p1[Math.floor(p)];

        item.x = point[0];
        item.y = point[1];

        p += step;
    }

    return items;
};

module.exports = PlaceOnTriangle;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

var Random = __webpack_require__(110);

var RandomCircle = function (items, circle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(circle, items[i]);
    }

    return items;
};

module.exports = RandomCircle;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

var Random = __webpack_require__(112);

var RandomEllipse = function (items, ellipse)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(ellipse, items[i]);
    }

    return items;
};

module.exports = RandomEllipse;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

var Random = __webpack_require__(119);

var RandomLine = function (items, line)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(line, items[i]);
    }

    return items;
};

module.exports = RandomLine;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

var Random = __webpack_require__(129);

var RandomRectangle = function (items, rect)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(rect, items[i]);
    }

    return items;
};

module.exports = RandomRectangle;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

var Random = __webpack_require__(134);

var RandomTriangle = function (items, triangle)
{
    for (var i = 0; i < items.length; i++)
    {
        Random(triangle, items[i]);
    }

    return items;
};

module.exports = RandomTriangle;


/***/ },
/* 235 */
/***/ function(module, exports) {

var Rotate = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation += value + (i * step);
    }

    return items;
};

module.exports = Rotate;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundDistance = __webpack_require__(74);
var DistanceBetween = __webpack_require__(75);

//  point = any object with public x/y properties

var RotateAround = function (items, point, angle)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        var item = items[i];

        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
    }

    return items;
};

module.exports = RotateAround;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

var MathRotateAroundDistance = __webpack_require__(74);

//  point = any object with public x/y properties
//  angle = radians
//  distance = px

var RotateAroundDistance = function (items, point, angle, distance)
{
    var x = point.x;
    var y = point.y;

    for (var i = 0; i < items.length; i++)
    {
        MathRotateAroundDistance(items[i], x, y, angle, distance);
    }

    return items;
};

module.exports = RotateAroundDistance;


/***/ },
/* 238 */
/***/ function(module, exports) {

var ScaleX = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += value;
    }

    return items;
};

module.exports = ScaleX;


/***/ },
/* 239 */
/***/ function(module, exports) {

var ScaleXY = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX += x;
        items[i].scaleY += y;
    }

    return items;
};

module.exports = ScaleXY;


/***/ },
/* 240 */
/***/ function(module, exports) {

var ScaleY = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY += value;
    }

    return items;
};

module.exports = ScaleY;


/***/ },
/* 241 */
/***/ function(module, exports) {

var SetAlpha = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].alpha = value + (i * step);
    }

    return items;
};

module.exports = SetAlpha;


/***/ },
/* 242 */
/***/ function(module, exports) {

var SetOrigin = function (items, x, y)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].setOrigin(x, y);
    }

    return items;
};

module.exports = SetOrigin;


/***/ },
/* 243 */
/***/ function(module, exports) {

var SetRotation = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].rotation = value + (i * step);
    }

    return items;
};

module.exports = SetRotation;


/***/ },
/* 244 */
/***/ function(module, exports) {

var SetScale = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].setScale(
            x + (i * stepX),
            y + (i * stepY)
        );
    }

    return items;
};

module.exports = SetScale;


/***/ },
/* 245 */
/***/ function(module, exports) {

var SetScaleX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleX = value + (i * step);
    }

    return items;
};

module.exports = SetScaleX;


/***/ },
/* 246 */
/***/ function(module, exports) {

var SetScaleY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].scaleY = value + (i * step);
    }

    return items;
};

module.exports = SetScaleY;


/***/ },
/* 247 */
/***/ function(module, exports) {

var SetVisible = function (items, value)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = value;
    }

    return items;
};

module.exports = SetVisible;


/***/ },
/* 248 */
/***/ function(module, exports) {

var SetX = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = value + (i * step);
    }

    return items;
};

module.exports = SetX;


/***/ },
/* 249 */
/***/ function(module, exports) {

var SetXY = function (items, x, y, stepX, stepY)
{
    if (stepX === undefined) { stepX = 0; }
    if (stepY === undefined) { stepY = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].x = x + (i * stepX);
        items[i].y = y + (i * stepY);
    }

    return items;
};

module.exports = SetXY;


/***/ },
/* 250 */
/***/ function(module, exports) {

var SetY = function (items, value, step)
{
    if (step === undefined) { step = 0; }

    for (var i = 0; i < items.length; i++)
    {
        items[i].y = value + (i * step);
    }

    return items;
};

module.exports = SetY;


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

var MathSmoothStep = __webpack_require__(168);

var SmoothStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmoothStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmoothStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmoothStep;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

var MathSmootherStep = __webpack_require__(169);

var SmootherStep = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += MathSmootherStep(i * step, min, max);
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = MathSmootherStep(i * step, min, max);
        }
    }

    return items;
};

module.exports = SmootherStep;


/***/ },
/* 253 */
/***/ function(module, exports) {

var Spread = function (items, property, min, max, inc)
{
    if (inc === undefined) { inc = false; }

    var step = Math.abs(max - min) / items.length;
    var i;

    if (inc)
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] += i * step;
        }
    }
    else
    {
        for (i = 0; i < items.length; i++)
        {
            items[i][property] = i * step;
        }
    }

    return items;
};

module.exports = Spread;


/***/ },
/* 254 */
/***/ function(module, exports) {

var ToggleVisible = function (items)
{
    for (var i = 0; i < items.length; i++)
    {
        items[i].visible = !items[i].visible;
    }

    return items;
};

module.exports = ToggleVisible;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Map = __webpack_require__(616);

/**
* Animations are managed by the global AnimationManager. This is a singleton class that is
* responsible for creating and delivering animations and their corresponding data to Game Objects.
*
* Sprites and other Game Objects get the data they need from the AnimationManager.
*
* Access it via `state.anims`.
*
* @class Phaser.AnimationManager
* @constructor
*/
var AnimationManager = function (game)
{
    this.game = game;

    this.anims = new Map();
};

AnimationManager.prototype.constructor = AnimationManager;

AnimationManager.prototype = {

    //  add frame name based animation
    //  add frame index based animation
    //  add bone based animation
    //  add animation from json data

    add: function (key, frames, loop)
    {
        if (this.anims.has(key))
        {
            console.error('Animation with key', key, 'already exists');
            return;
        }


    },

    get: function (key)
    {
        return this.anims.get(key);
    }

};

module.exports = AnimationManager;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var MATH = __webpack_require__(87);
var CONST = __webpack_require__(2);
var NOOP = __webpack_require__(85);
var GetObjectValue = __webpack_require__(9);
var ValueToColor = __webpack_require__(154);

var defaultBannerColor = [
    '#ff0000',
    '#ffff00',
    '#00ff00',
    '#00ffff',
    '#000000'
];

var defaultBannerTextColor = '#ffffff';

var Config = function (config)
{
    if (config === undefined) { config = {}; }

    this.width = GetObjectValue(config, 'width', 1024);
    this.height = GetObjectValue(config, 'height', 768);
    this.zoom = GetObjectValue(config, 'zoom', 1);

    this.resolution = GetObjectValue(config, 'resolution', 1);

    this.renderType = GetObjectValue(config, 'type', CONST.AUTO);

    this.parent = GetObjectValue(config, 'parent', null);
    this.canvas = GetObjectValue(config, 'canvas', null);
    this.canvasStyle = GetObjectValue(config, 'canvasStyle', null);

    this.stateConfig = GetObjectValue(config, 'state', null);

    this.seed = GetObjectValue(config, 'seed', [ (Date.now() * Math.random()).toString() ]);

    MATH.RND.init(this.seed);

    this.gameTitle = GetObjectValue(config, 'title', '');
    this.gameURL = GetObjectValue(config, 'url', 'http://phaser.io');
    this.gameVersion = GetObjectValue(config, 'version', '');

    //  Input
    this.inputKeyboard = GetObjectValue(config, 'input.keyboard', true);
    this.inputKeyboardEventTarget = GetObjectValue(config, 'input.keyboard.target', window);

    //  If you do: { banner: false } it won't display any banner at all
    this.hideBanner = (GetObjectValue(config, 'banner', null) === false);

    this.hidePhaser = GetObjectValue(config, 'banner.hidePhaser', false);
    this.bannerTextColor = GetObjectValue(config, 'banner.text', defaultBannerTextColor);
    this.bannerBackgroundColor = GetObjectValue(config, 'banner.background', defaultBannerColor);
   
    this.fps = GetObjectValue(config, 'fps', 60);
    this.forceSetTimeOut = GetObjectValue(config, 'forceSetTimeOut', false);

    this.pixelArt = GetObjectValue(config, 'pixelArt', false);
    this.transparent = GetObjectValue(config, 'transparent', false);
    this.clearBeforeRender = GetObjectValue(config, 'clearBeforeRender', true);
    this.backgroundColor = ValueToColor(GetObjectValue(config, 'backgroundColor', 0));
    this.preserveDrawingBuffer = ValueToColor(GetObjectValue(config, 'preserveDrawingBuffer', false));

    //  Callbacks
    this.preBoot = GetObjectValue(config, 'callbacks.preBoot', NOOP);
    this.postBoot = GetObjectValue(config, 'callbacks.postBoot', NOOP);

    //  Default / Missing Images
    var pngPrefix = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg';

    this.defaultImage = GetObjectValue(config, 'images.default', pngPrefix + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');
    this.missingImage = GetObjectValue(config, 'images.missing', pngPrefix + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');
};

Config.prototype.constructor = Config;

module.exports = Config;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CanvasPool = __webpack_require__(22);
var Features = __webpack_require__(94);
var CanvasRenderer = __webpack_require__(580);
var WebGLRenderer = __webpack_require__(584);
var CanvasInterpolation = __webpack_require__(56);

/**
* Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
*
* @method Phaser.Game#setUpRenderer
* @protected
*/
var CreateRenderer = function (game)
{
    var config = game.config;

    //  Game either requested Canvas,
    //  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas
    if (config.renderType === CONST.CANVAS || (config.renderType !== CONST.CANVAS && !Features.webGL))
    {
        if (Features.canvas)
        {
            //  They requested Canvas and their browser supports it
            config.renderType = CONST.CANVAS;
        }
        else
        {
            throw new Error('Cannot create Canvas or WebGL context, aborting.');
        }
    }
    else
    {
        //  Game requested WebGL and browser says it supports it
        config.renderType = CONST.WEBGL;
    }

    //  Does the game config provide its own canvas element to use?
    if (config.canvas)
    {
        game.canvas = config.canvas;
    }
    else
    {
        game.canvas = CanvasPool.create(game, config.width, config.height, config.renderType);
    }

    //  Does the game config provide some canvas css styles to use?
    if (config.canvasStyle)
    {
        game.canvas.style = config.canvasStyle;
    }

    //  Pixel Art mode?
    if (config.pixelArt)
    {
        CanvasInterpolation.setCrisp(game.canvas);
    }

    //  Zoomed?
    if (config.zoom !== 1)
    {
        game.canvas.style.width = (config.width * config.zoom).toString() + 'px';
        game.canvas.style.height = (config.height * config.zoom).toString() + 'px';
    }

    //  Create the renderer
    if (config.renderType === CONST.WEBGL)
    {
        game.renderer = new WebGLRenderer(game);
        game.context = null;
    }
    else
    {
        game.renderer = new CanvasRenderer(game);
        game.context = game.renderer.gameContext;

        //  debug
        game.canvas.id = 'game';
    }
};

module.exports = CreateRenderer;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CHECKSUM = __webpack_require__(267);

var DebugHeader = function (game)
{
    var config = game.config;

    if (config.hideBanner)
    {
        return;
    }

    var renderType = (config.renderType === CONST.CANVAS) ? 'Canvas' : 'WebGL';

    var ie = false;

    if (!ie)
    {
        var c = '';
        var args = [c];

        if (Array.isArray(config.bannerBackgroundColor))
        {
            var lastColor;

            config.bannerBackgroundColor.forEach(function(color) {

                c = c.concat('%c ');

                args.push('background: ' + color);

                lastColor = color;

            });

            //  inject the text color
            args[args.length - 1] = 'color: ' + config.bannerTextColor + '; background: ' + lastColor;
        }
        else
        {
            c = c.concat('%c ');

            args.push('color: ' + config.bannerTextColor + '; background: ' + config.bannerBackgroundColor);
        }

        //  URL link background color (always white)
        args.push('background: #fff');

        if (config.gameTitle)
        {
            c = c.concat(config.gameTitle);

            if (config.gameVersion)
            {
                c = c.concat(' v' + config.gameVersion);
            }

            if (!config.hidePhaser)
            {
                c = c.concat(' / ');
            }
        }

        if (!config.hidePhaser)
        {
            c = c.concat('Phaser v' + CONST.VERSION + ' (' + renderType + ')');
        }

        c = c.concat(' %c ' + config.gameURL);

        //  Inject the new string back into the args array
        args[0] = c;

        console.log.apply(console, args);
    }
    else if (window['console'])
    {
        console.log('Phaser v' + CONST.VERSION + ' / http://phaser.io');
    }

    // Keep this during dev build only
    console.log(CHECKSUM.build);

};

module.exports = DebugHeader;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

var RequestAnimationFrame = __webpack_require__(98);

// My thanks to Isaac Sukin for creating MainLoop.js, on which lots of this is based.

var MainLoop = function (game, framerate)
{
    this.game = game;

    /**
    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
    * @protected
    */
    this.raf = new RequestAnimationFrame();

    /**
    * @property {number} timestep - The amount of time (in milliseconds) to simulate each time update() runs.
    */
    this.timestep = 1000 / framerate;

    /**
    * @property {number} physicsStep - 1 / framerate.
    */
    this.physicsStep = 1 / framerate;

    /**
    * @property {number} frameDelta - The cumulative amount of in-app time that hasn't been simulated yet.
    */
    this.frameDelta = 0;

    this.discardedTime = 0;

    /**
    * The timestamp in milliseconds of the last time the main loop was run.
    * Used to compute the time elapsed between frames.
    * @property {number} lastFrameTimeMs
    */
    this.lastFrameTimeMs = 0;

    /**
    * @property {number} fps - An exponential moving average of the frames per second.
    */
    this.fps = 60;

    /**
    * @property {number} lastFpsUpdate - The timestamp (in milliseconds) of the last time the `fps` moving average was updated.
    */
    this.lastFpsUpdate = 0;

    /**
    * @property {number} framesThisSecond - The number of frames delivered in the current second.
    */
    this.framesThisSecond = 0;

    /**
    * @property {number} numUpdateSteps - The number of times update() is called in a given frame.
    */
    this.numUpdateSteps = 0;

    /**
    * The minimum amount of time in milliseconds that must pass since the last frame was executed
    * before another frame can be executed.
    * The multiplicative inverse caps the FPS (the default of zero means there is no cap)
    * @property {number} minFrameDelay
    */
    this.minFrameDelay = 0;

    /**
    * @property {boolean} running - Whether the main loop is running.
    */
    this.running = false;

    /**
     * `true` if `MainLoop.start()` has been called and the most recent time it
     * was called has not been followed by a call to `MainLoop.stop()`. This is
     * different than `running` because there is a delay of a few milliseconds
     * after `MainLoop.start()` is called before the application is considered
     * "running." This delay is due to waiting for the next frame.
    * @property {boolean} started
    */
    this.started = false;

    /**
     * Whether the simulation has fallen too far behind real time.
     * Specifically, `panic` will be set to `true` if too many updates occur in
     * one frame. This is only relevant inside of animate(), but a reference is
     * held externally so that this variable is not marked for garbage
     * collection every time the main loop runs.
    * @property {boolean} panic - Whether the simulation has fallen too far behind real time.
    */
    this.panic = false;
};

MainLoop.prototype.constructor = MainLoop;

MainLoop.prototype = {

    setMaxFPS: function (fps)
    {
        if (fps === 0)
        {
            this.stop();
        }
        else
        {
            this.minFrameDelay = 1000 / fps;
        }
    },

    getMaxFPS: function ()
    {
        return 1000 / this.minFrameDelay;
    },

    resetFrameDelta: function ()
    {
        var oldFrameDelta = this.frameDelta;

        this.frameDelta = 0;

        return oldFrameDelta;
    },

    start: function ()
    {
        if (this.started)
        {
            return this;
        }

        this.started = true;
        this.running = true;

        this.lastFrameTimeMs = window.performance.now();
        this.lastFpsUpdate = window.performance.now();
        this.framesThisSecond = 0;

        this.raf.start(this.step.bind(this), this.game.config.forceSetTimeOut);
    },

    //  timestamp = DOMHighResTimeStamp
    // active = array containing: ({ index: i, state: state })

    step: function (timestamp)
    {
        var active = this.game.state.active;
        var renderer = this.game.renderer;

        var len = active.length;

        // Throttle the frame rate (if minFrameDelay is set to a non-zero value by
        // `MainLoop.setMaxAllowedFPS()`).
        if (len === 0 || timestamp < this.lastFrameTimeMs + this.minFrameDelay)
        {
            return;
        }

        // frameDelta is the cumulative amount of in-app time that hasn't been
        // simulated yet. Add the time since the last frame. We need to track total
        // not-yet-simulated time (as opposed to just the time elapsed since the
        // last frame) because not all actually elapsed time is guaranteed to be
        // simulated each frame. See the comments below for details.
        this.frameDelta += timestamp - this.lastFrameTimeMs;
        this.lastFrameTimeMs = timestamp;

        //  Global Managers (Time, Input, etc)

        this.game.input.update(timestamp, this.frameDelta);

        //  Run any updates that are not dependent on time in the simulation.
        //  Here we'll need to run things like tween.update, input.update, etc.

        for (var i = 0; i < len; i++)
        {
            active[i].state.sys.begin(timestamp, this.frameDelta);
        }

        // Update the estimate of the frame rate, `fps`. Every second, the number
        // of frames that occurred in that second are included in an exponential
        // moving average of all frames per second, with an alpha of 0.25. This
        // means that more recent seconds affect the estimated frame rate more than
        // older seconds.
        if (timestamp > this.lastFpsUpdate + 1000)
        {
            // Compute the new exponential moving average with an alpha of 0.25.
            // Using constants inline is okay here.
            this.fps = 0.25 * this.framesThisSecond + 0.75 * this.fps;

            this.lastFpsUpdate = timestamp;
            this.framesThisSecond = 0;
        }

        this.framesThisSecond++;

        this.numUpdateSteps = 0;

        while (this.frameDelta >= this.timestep)
        {
            for (i = 0; i < len; i++)
            {
                active[i].state.sys.update(this.timestep, this.physicsStep);
            }

            this.frameDelta -= this.timestep;

            if (++this.numUpdateSteps >= 240)
            {
                this.panic = true;
                break;
            }
        }

        //  Render

        var interpolation = this.frameDelta / this.timestep;

        renderer.preRender();

        //  This uses active.length, in case state.update removed the state from the active list
        for (i = 0; i < active.length; i++)
        {
            active[i].state.sys.render(interpolation, renderer);
        }

        renderer.postRender();

        if (this.panic)
        {
            // This pattern introduces non-deterministic behavior, but in this case
            // it's better than the alternative (the application would look like it
            // was running very quickly until the simulation caught up to real
            // time).
            this.discardedTime = Math.round(this.resetFrameDelta());

            // console.warn('Main loop panicked, tab probably put in the background. Discarding ' + discardedTime + 'ms');
        }

        this.panic = false;
    },

    stop: function ()
    {
        this.running = false;
        this.started = false;

        return this;
    }

};

module.exports = MainLoop;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

var CacheEntry = __webpack_require__(262);
var Events = __webpack_require__(265);
var EventDispatcher = __webpack_require__(26);

var BaseCache = function ()
{
    this.entries = new Map();

    this.events = new EventDispatcher();
};

BaseCache.prototype.constructor = BaseCache;

BaseCache.prototype = {

    add: function (key, data)
    {
        this.entries.set(key, data);

        this.events.dispatch(new Events.CACHE_ADD_EVENT(this, key, data));
    },

    has: function (key)
    {
        return this.entries.has(key);
    },

    get: function (key)
    {
        return this.entries.get(key);
    },

    remove: function (key)
    {
        var entry = this.get(key);

        if (entry)
        {
            this.entries.delete(key);

            this.events.dispatch(new Events.CACHE_REMOVE_EVENT(this, key, entry.data));
        }
    },

    destroy: function ()
    {
        this.entries.clear();
    }

};

module.exports = BaseCache;


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

var BaseCache = __webpack_require__(260);

var Cache = function ()
{
    this.sound = new BaseCache();
    this.video = new BaseCache();
    this.text = new BaseCache();
    this.json = new BaseCache();
    this.xml = new BaseCache();
    this.physics = new BaseCache();
    this.tilemap = new BaseCache();
    this.binary = new BaseCache();
    this.bitmapFont = new BaseCache();
    this.shader = new BaseCache();

    this.custom = {};
};

Cache.prototype.constructor = Cache;

Cache.prototype = {

    //  Add your own custom Cache entry, available under Cache.custom.key
    addCustom: function (key)
    {
        if (!this.custom.hasOwnProperty(key))
        {
            this.custom[key] = new BaseCache();

            return this.custom[key];
        }
    }

};

module.exports = Cache;


/***/ },
/* 262 */
/***/ function(module, exports) {

var CacheEntry = function (key, url, data)
{
    this.key = key;

    this.url = url;

    this.data = data;
};

CacheEntry.prototype.constructor = CacheEntry;

module.exports = CacheEntry;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var CacheAddEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheAddEvent.prototype = Object.create(Event.prototype);
CacheAddEvent.prototype.constructor = CacheAddEvent;

module.exports = CacheAddEvent;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var CacheRemoveEvent = function (cache, key, data)
{
    Event.call(this, 'CACHE_ADD_EVENT');

    this.cache = cache;
    this.key = key;
    this.data = data;
};

CacheRemoveEvent.prototype = Object.create(Event.prototype);
CacheRemoveEvent.prototype.constructor = CacheRemoveEvent;

module.exports = CacheRemoveEvent;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    CACHE_ADD_EVENT: __webpack_require__(263),
    CACHE_REMOVE_EVENT: __webpack_require__(264)

};


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(29);

var Camera = function (x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.scrollX = 0.0;
    this.scrollY = 0.0;
    this.zoom = 1.0;
    this.rotation = 0.0;
    this.matrix = new TransformMatrix(1, 0, 0, 1, 0, 0);

    // shake
    this._shakeDuration = 0.0;
    this._shakeIntensity = 0.0;
    this._shakeOffsetX = 0.0;
    this._shakeOffsetY = 0.0;

    // fade
    this._fadeDuration = 0.0;
    this._fadeRed = 0.0;
    this._fadeGreen = 0.0;
    this._fadeBlue = 0.0;
    this._fadeAlpha = 0.0;

    // flash
    this._flashDuration = 0.0;
    this._flashRed = 1.0;
    this._flashGreen = 1.0;
    this._flashBlue = 1.0;
    this._flashAlpha = 0.0;

    // origin
    this._follow = null;
};

Camera.prototype.constructor = Camera;

Camera.prototype = {

    setViewport: function (x, y, width, height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;
    },

    setState: function (state)
    {
        this.state = state;
    },

    update: function (delta)
    {
        if (this._flashAlpha > 0.0)
        {
            this._flashAlpha -= delta / this._flashDuration;

            if (this._flashAlpha < 0.0)
            {
                this._flashAlpha = 0.0;
            }
        }

        if (this._fadeAlpha > 0.0 && this._fadeAlpha < 1.0)
        {
            this._fadeAlpha += delta / this._fadeDuration;

            if (this._fadeAlpha >= 1.0)
            {
                this._fadeAlpha = 1.0;
            }
        }

        if (this._shakeDuration > 0.0)
        {
            var intensity = this._shakeIntensity;

            this._shakeDuration -= delta;

            if (this._shakeDuration <= 0.0)
            {
                this._shakeOffsetX = 0.0;
                this._shakeOffsetY = 0.0;
            }
            else
            {
                this._shakeOffsetX = (Math.random() * intensity * this.width * 2 - intensity * this.width) * this.zoom;
                this._shakeOffsetY = (Math.random() * intensity * this.height * 2 - intensity * this.height) * this.zoom;
            }
        }
    },

    startFollow: function (gameObjectOrPoint)
    {
        if (this._follow !== null)
        {
            this.stopFollow();
        }

        this._follow = gameObjectOrPoint;
    },

    stopFollow: function () 
    {
        /* do unfollow work here */
        this._follow = null;
    },

    flash: function (duration, red, green, blue, force)
    {
        if (!force && this._flashAlpha > 0.0)
        {
            return;
        }

        if (red === undefined) { red = 1.0; }
        if (green === undefined) { green = 1.0; }
        if (blue === undefined) { blue = 1.0; }

        this._flashRed = red;
        this._flashGreen = green;
        this._flashBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._flashDuration = duration;
        this._flashAlpha = 1.0;
    },

    fade: function (duration, red, green, blue, force)
    {
        if (red === undefined) { red = 0.0; }
        if (green === undefined) { green = 0.0; }
        if (blue === undefined) { blue = 0.0; }

        if (!force && this._fadeAlpha > 0.0)
        {
            return;
        }

        this._fadeRed = red;
        this._fadeGreen = green;
        this._fadeBlue = blue;

        if (duration <= 0)
        {
            duration = Number.MIN_VALUE;
        }

        this._fadeDuration = duration;
        this._fadeAlpha = Number.MIN_VALUE;
    },

    shake: function (duration, intensity, force)
    {
        if (intensity === undefined) { intensity = 0.05; }

        if (!force && (this._shakeOffsetX !== 0.0 || this._shakeOffsetY !== 0.0))
        {
            return;
        }

        this._shakeDuration = duration;
        this._shakeIntensity = intensity;
        this._shakeOffsetX = 0;
        this._shakeOffsetY = 0;
    },

    preRender: function ()
    {
        var width = this.width;
        var height = this.height;
        var zoom = this.zoom;
        var matrix = this.matrix;
        var originX = width / 2;
        var originY = height / 2;
        var follow = this._follow;

        if (follow != null)
        {
            originX = follow.x;
            originY = follow.y;
            
            this.scrollX = originX - width * 0.5;
            this.scrollY = originY - height * 0.5;
        }

        matrix.loadIdentity();
        matrix.translate(this.x + originX, this.y + originY);
        matrix.rotate(this.rotation);
        matrix.scale(zoom, zoom);
        matrix.translate(-originX, -originY);
        matrix.translate(this._shakeOffsetX, this._shakeOffsetY);
    },

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = Camera;


/***/ },
/* 267 */
/***/ function(module, exports) {

var CHECKSUM = {
build: '7ca218d0-18d8-11e7-adaa-6d4ae57a90ac'
};
module.exports = CHECKSUM;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

var Clamp = __webpack_require__(164);

//  Alpha Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 2; // 0010

var Alpha = {

    _alpha: 1,

    alpha: {

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = Clamp(value, 0, 1);

            if (this._alpha === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    }

};

module.exports = Alpha;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

var BlendModes = __webpack_require__(83);

//  BlendMode Component

var BlendMode = {

    _blendMode: BlendModes.NORMAL,

    blendMode: {

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            value | 0;

            if (value >= 0 && value <= 16)
            {
                this._blendMode = value;
            }
        }

    }

};

module.exports = BlendMode;


/***/ },
/* 270 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Children Component features quick access to Group sorting related methods.
*
* @class
*/
var Children = function (gameObject)
{
    this.gameObject = gameObject;

    //  The objects that belong to this collection.
    //  The equivalent of the old `Sprite.children` array.
    this.list = [];

    this.position = 0;
};

Children.prototype.constructor = Children;

Children.prototype = {

    add: function (child)
    {
        if (child.parent === this)
        {
            return child;
        }
        else if (child.parent)
        {
            child.parent.children.remove(child);
        }

        child.parent = this.gameObject;

        this.list.push(child);

        return child;
    },

    addAt: function (child, index)
    {
        if (index === undefined) { index = 0; }

        if (this.list.length === 0)
        {
            return this.add(child);
        }

        if (index >= 0 && index <= this.list.length)
        {
            if (child.parent)
            {
                child.parent.children.remove(child);
            }

            child.parent = this;

            this.list.splice(index, 0, child);
        }

        return child;

    },

    addMultiple: function (children)
    {
        if (Array.isArray(children))
        {
            for (var i = 0; i < children.length; i++)
            {
                this.add(children[i]);
            }
        }

        return children;
    },

    getAt: function (index)
    {
        return this.list[index];
    },

    getIndex: function (child)
    {
        //  Return -1 if given child isn't a child of this parent
        return this.list.indexOf(child);
    },

    /**
    * Gets the first item from the set based on the property strictly equaling the value given.
    * Returns null if not found.
    *
    * @method Phaser.ArraySet#getByKey
    * @param {string} property - The property to check against the value.
    * @param {any} value - The value to check if the property strictly equals.
    * @return {any} The item that was found, or null if nothing matched.
    */
    getByKey: function (property, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i][property] === value)
            {
                return this.list[i];
            }
        }

        return null;
    },

    /**
    * Searches the Group for the first instance of a child with the `name`
    * property matching the given argument. Should more than one child have
    * the same name only the first instance is returned.
    *
    * @method Phaser.Group#getByName
    * @param {string} name - The name to search for.
    * @return {any} The first child with a matching name, or null if none were found.
    */
    getByName: function (name)
    {
        return this.getByKey('name', name);
    },

    /**
    * Returns a random child from the group.
    *
    * @method Phaser.Group#getRandom
    * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).
    * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
    * @return {any} A random child of this Group.
    */
    getRandom: function (startIndex, length)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (length === undefined) { length = this.list.length; }

        if (length === 0 || length > this.list.length)
        {
            return null;
        }

        var randomIndex = startIndex + Math.floor(Math.random() * length);

        return this.list[randomIndex];
    },

    getFirst: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (child[property] === value)
            {
                return child;
            }
        }

        return null;
    },

    /**
    * Returns all children in this Group.
    *
    * You can optionally specify a matching criteria using the `property` and `value` arguments.
    *
    * For example: `getAll('exists', true)` would return only children that have their exists property set.
    *
    * Optionally you can specify a start and end index. For example if this Group had 100 children,
    * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
    * the first 50 children in the Group.
    *
    * @method Phaser.Group#getAll
    * @param {string} [property] - An optional property to test against the value argument.
    * @param {any} [value] - If property is set then Child.property must strictly equal this value to be included in the results.
    * @param {integer} [startIndex=0] - The first child index to start the search from.
    * @param {integer} [endIndex] - The last child index to search up until.
    * @return {any} A random existing child of this Group.
    */
    getAll: function (property, value, startIndex, endIndex)
    {
        if (startIndex === undefined) { startIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var output = [];

        for (var i = startIndex; i < endIndex; i++)
        {
            var child = this.list[i];

            if (property)
            {
                if (child[property] === value)
                {
                    output.push(child);
                }
            }
            else
            {
                output.push(child);
            }
        }

        return output;
    },

    swap: function (child1, child2)
    {
        if (child1 === child2)
        {
            return;
        }

        var index1 = this.getIndex(child1);
        var index2 = this.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of the same parent');
        }

        this.list[index1] = child2;
        this.list[index2] = child1;
    },

    //   was setIndex
    moveTo: function (child, index)
    {
        var currentIndex = this.getIndex(child);

        if (currentIndex === -1 || index < 0 || index >= this.list.length)
        {
            throw new Error('Children.moveTo: The supplied index is out of bounds');
        }

        //  Remove
        this.list.splice(currentIndex, 1);

        //  Add in new location
        this.list.splice(index, 0, child);

        return child;
    },

    remove: function (child)
    {
        var index = this.list.indexOf(child);

        if (index !== -1)
        {
            child.parent = undefined;

            this.list.splice(index, 1);
        }
        
        return child;
    },

    removeAt: function (index)
    {
        var child = this.list[index];

        if (child)
        {
            child.parent = undefined;

            this.children.splice(index, 1);
        }

        return child;
    },

    removeBetween: function (beginIndex, endIndex)
    {
        if (beginIndex === undefined) { beginIndex = 0; }
        if (endIndex === undefined) { endIndex = this.list.length; }

        var range = endIndex - beginIndex;

        if (range > 0 && range <= endIndex)
        {
            var removed = this.list.splice(beginIndex, range);

            for (var i = 0; i < removed.length; i++)
            {
                removed[i].parent = undefined;
            }

            return removed;
        }
        else if (range === 0 && this.list.length === 0)
        {
            return [];
        }
        else
        {
            throw new Error('Children.removeBetween: Range Error, numeric values are outside the acceptable range');
        }
    },

    /**
    * Removes all the items.
    *
    * @method Phaser.ArraySet#removeAll
    */
    removeAll: function ()
    {
        var i = this.list.length;

        while (i--)
        {
            this.remove(this.list[i]);
        }

        return this;
    },

    //  Check to see if the given child is a child of this object, at any depth (recursively scans up the tree)
    contains: function (child)
    {
        if (!child)
        {
            return false;
        }
        else if (child.parent === this)
        {
            return true;
        }
        else
        {
            return this.contains(child.parent);
        }
    },

    /**
    * Brings the given child to the top of this group so it renders above all other children.
    *
    * @method Phaser.Group#bringToTop
    * @param {any} child - The child to bring to the top of this group.
    * @return {any} The child that was moved.
    */
    bringToTop: function (child)
    {
        if (child.parent === this && this.getIndex(child) < this.list.length)
        {
            this.remove(child);
            this.add(child);
        }

        return child;
    },

    /**
    * Sends the given child to the bottom of this group so it renders below all other children.
    *
    * @method Phaser.Group#sendToBack
    * @param {any} child - The child to send to the bottom of this group.
    * @return {any} The child that was moved.
    */
    sendToBack: function (child)
    {
        if (child.parent === this && this.getIndex(child) > 0)
        {
            this.remove(child);
            this.addAt(child, 0);
        }

        return child;
    },

    /**
    * Moves the given child up one place in this group unless it's already at the top.
    *
    * @method Phaser.Group#moveUp
    * @param {any} child - The child to move up in the group.
    * @return {any} The child that was moved.
    */
    moveUp: function (child)
    {
        var a = this.getIndex(child);

        if (a !== -1 && a < this.list.length - 1)
        {
            var b = this.getAt(a + 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Moves the given child down one place in this group unless it's already at the bottom.
    *
    * @method Phaser.Group#moveDown
    * @param {any} child - The child to move down in the group.
    * @return {any} The child that was moved.
    */
    moveDown: function (child)
    {
        var a = this.getIndex(child);

        if (a > 0)
        {
            var b = this.getAt(a - 1);

            if (b)
            {
                this.swap(child, b);
            }
        }

        return child;
    },

    /**
    * Reverses all children in this group.
    *
    * This operation applies only to immediate children and does not propagate to subgroups.
    *
    * @method Phaser.Group#reverse
    */
    reverse: function ()
    {
        this.list.reverse();

        return this;
    },

    shuffle: function ()
    {
        for (var i = this.list.length - 1; i > 0; i--)
        {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = this.list[i];
            this.list[i] = this.list[j];
            this.list[j] = temp;
        }

        return this;
    },

    /**
    * Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
    *
    * If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
    *
    * If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
    *
    * @method Phaser.Group#replace
    * @param {any} oldChild - The child in this group that will be replaced.
    * @param {any} newChild - The child to be inserted into this group.
    * @return {any} Returns the oldChild that was replaced within this group.
    */
    replace: function (oldChild, newChild)
    {
        var index = this.getIndex(oldChild);

        if (index !== -1)
        {
            if (newChild.parent)
            {
                newChild.parent.remove(newChild);
            }

            this.remove(oldChild);

            this.addAt(newChild, index);

            return oldChild;
        }
    },

    //  Swaps a child from another parent, with one from this parent.
    //  child1 = the child of THIS parent
    //  child2 = the child of the OTHER parent
    exchange: function (child1, child2)
    {
        if (child1 === child2 || child1.parent === child2.parent)
        {
            return;
        }

        var parentChildren = child2.parent.children;

        var index1 = this.getIndex(child1);
        var index2 = parentChildren.getIndex(child2);

        if (index1 < 0 || index2 < 0)
        {
            throw new Error('Children.swap: Supplied objects must be children of parents');
        }

        this.remove(child1);

        parentChildren.remove(child2);

        this.addAt(child2, index1);

        parentChildren.addAt(child1, index2);
    },

    /**
    * Checks for the item within this list.
    *
    * @method Phaser.ArraySet#exists
    * @param {any} item - The element to get the list index for.
    * @return {boolean} True if the item is found in the list, otherwise false.
    */
    exists: function (child)
    {
        return (this.list.indexOf(child) > -1);
    },

    /**
    * Sets the property `key` to the given value on all members of this list.
    *
    * @method Phaser.ArraySet#setAll
    * @param {any} key - The property of the item to set.
    * @param {any} value - The value to set the property to.
    */
    setAll: function (key, value)
    {
        for (var i = 0; i < this.list.length; i++)
        {
            if (this.list[i])
            {
                this.list[i][key] = value;
            }
        }
    },

    /**
    * Passes all children to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (i = 0; i < this.list.length; i++)
        {
            args[0] = this.list[i];
            callback.apply(thisArg, args);
        }
    },

    /**
    * Moves all children from this Group to the Group given.
    *
    * @method Phaser.Group#moveAll
    * @param {Phaser.Group} group - The new Group to which the children will be moved to.
    * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event for the new Group.
    * @return {Phaser.Group} The Group to which all the children were moved.
    */
    reparent: function (newParent)
    {
        if (newParent !== this)
        {
            for (var i = 0; i < this.list.length; i++)
            {
                var child = this.remove(this.list[i]);

                newParent.add(child);
            }
        }

        return newParent;
    }

};

Object.defineProperties(Children.prototype, {

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    length: {

        enumerable: true,

        get: function ()
        {
            return this.list.length;
        }

    },

    /**
    * Returns the first item and resets the cursor to the start.
    *
    * @name Phaser.ArraySet#first
    * @property {any} first
    */
    first: {

        enumerable: true,

        get: function ()
        {
            this.position = 0;

            if (this.list.length > 0)
            {
                return this.list[0];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the last item and resets the cursor to the end.
    *
    * @name Phaser.ArraySet#last
    * @property {any} last
    */
    last: {

        enumerable: true,

        get: function ()
        {
            if (this.list.length > 0)
            {
                this.position = this.list.length - 1;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the next item (based on the cursor) and advances the cursor.
    *
    * @name Phaser.ArraySet#next
    * @property {any} next
    */
    next: {

        enumerable: true,

        get: function ()
        {
            if (this.position < this.list.length)
            {
                this.position++;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    },

    /**
    * Returns the previous item (based on the cursor) and retreats the cursor.
    *
    * @name Phaser.ArraySet#previous
    * @property {any} previous
    */
    previous: {

        enumerable: true,

        get: function ()
        {
            if (this.position > 0)
            {
                this.position--;

                return this.list[this.position];
            }
            else
            {
                return null;
            }
        }

    }

});

module.exports = Children;


/***/ },
/* 271 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The Color Component allows you to control the alpha, blend mode, tint and background color
* of a Game Object.
*
* @class
*/
var Color = function (gameObject)
{
    this.gameObject = gameObject;

    this.state = gameObject.state;

    this._dirty = false;

    this._alpha = 1;
    this._worldAlpha = 1;

    this._blendMode = 0;

    this._tint = { topLeft: 0xffffff, topRight: 0xffffff, bottomLeft: 0xffffff, bottomRight: 0xffffff };
    this._glTint = { topLeft: 16777215, topRight: 16777215, bottomLeft: 16777215, bottomRight: 16777215 };
    this._hasTint = false;

    //  Between 0 and 255
    this._r = 0;
    this._g = 0;
    this._b = 0;

    //  Between 0 and 1
    this._a = 1;

    //  String version of RGBA
    this._rgba = '';

    //  32-bit version of ARGB
    this._glBg = 0;

    this._hasBackground = false;
};

Color.prototype.constructor = Color;

Color.prototype = {

    setBackground: function (red, green, blue, alpha)
    {
        if (red === undefined)
        {
            this._hasBackground = false;
            this._glBg = 0;
        }
        else
        {
            this._hasBackground = true;
            this._r = red;
            this._g = (green) ? green : 0;
            this._b = (blue) ? blue : 0;
            this._a = (alpha) ? alpha : 1;
        }

        this.dirty = true;
    },

    clearTint: function ()
    {
        this.setTint(0xffffff);

        this._hasTint = false;
    },

    setTint: function (topLeft, topRight, bottomLeft, bottomRight)
    {
        if (topRight === undefined)
        {
            topRight = topLeft;
            bottomLeft = topLeft;
            bottomRight = topLeft;
        }

        this.tintTopLeft = topLeft;
        this.tintTopRight = topRight;
        this.tintBottomLeft = bottomLeft;
        this.tintBottomRight = bottomRight;

        this._hasTint = true;

        this.dirty = true;
    },

    //  Called by the Dirty Manager
    update: function ()
    {
        this._dirty = false;

        if (this._hasBackground)
        {
            this._rgba = 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + this._a + ')';
            this._glBg = this.getColor32(this._r, this._g, this._b, this._a);
        }

        //  Tint mults?

    },

    getColor: function (value)
    {
        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    },

    getColor32: function (r, g, b, a)
    {
        a *= 255;

        return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0;
    },

    destroy: function ()
    {
        this.gameObject = null;
        this.state = null;
        this._tint = [];
    }

};

Object.defineProperties(Color.prototype, {

    dirty: {

        enumerable: true,

        get: function ()
        {
            return this._dirty;
        },

        set: function (value)
        {
            if (value)
            {
                if (!this._dirty)
                {
                    this._dirty = true;

                    this.state.sys.updates.add(this);
                }
            }
            else
            {
                this._dirty = false;
            }
        }

    },

    tintTopLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topLeft;
        },

        set: function (value)
        {
            this._tint.topLeft = value;
            this._glTint.topLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintTopRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.topRight;
        },

        set: function (value)
        {
            this._tint.topRight = value;
            this._glTint.topRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomLeft: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomLeft;
        },

        set: function (value)
        {
            this._tint.bottomLeft = value;
            this._glTint.bottomLeft = this.getColor(value);
            this.dirty = true;
        }

    },

    tintBottomRight: {

        enumerable: true,

        get: function ()
        {
            return this._tint.bottomRight;
        },

        set: function (value)
        {
            this._tint.bottomRight = value;
            this._glTint.bottomRight = this.getColor(value);
            this.dirty = true;
        }

    },

    tint: {

        enumerable: true,

        get: function ()
        {
            return this._tint;
        },

        set: function (value)
        {
            this.setTint(value, value, value, value);
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            if (value !== this._alpha)
            {
                this._alpha = value;
                this.dirty = true;
            }
        }

    },

    blendMode: {

        enumerable: true,

        get: function ()
        {
            return this._blendMode;
        },

        set: function (value)
        {
            if (value !== this._blendMode && value >= 0 && value <= 16)
            {
                this._blendMode = value;
                this.dirty = true;
            }
        }

    },

    worldAlpha: {

        enumerable: true,

        get: function ()
        {
            if (this.gameObject.parent)
            {
                this._worldAlpha = this._alpha * this.gameObject.parent.color.worldAlpha;
            }

            return this._worldAlpha;
        },

        set: function (value)
        {
            this._worldAlpha = this._alpha * value;
        }

    },

    backgroundAlpha: {

        enumerable: true,

        get: function ()
        {
            return this._a;
        },

        set: function (value)
        {
            if (value !== this._a)
            {
                this._a = value;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    red: {

        enumerable: true,

        get: function ()
        {
            return this._r;
        },

        set: function (value)
        {
            if (value !== this._r)
            {
                this._r = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    green: {

        enumerable: true,

        get: function ()
        {
            return this._g;
        },

        set: function (value)
        {
            if (value !== this._g)
            {
                this._g = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    },

    blue: {

        enumerable: true,

        get: function ()
        {
            return this._b;
        },

        set: function (value)
        {
            if (value !== this._b)
            {
                this._b = value | 0;
                this._hasBackground = true;
                this.dirty = true;
            }
        }

    }

});

module.exports = Color;


/***/ },
/* 272 */
/***/ function(module, exports) {

var Flip = {

    flipX: false,
    flipY: false,

    setFlipX: function (value)
    {
        this.flipX = value;

        return this;
    },

    setFlipY: function (value)
    {
        this.flipX = value;

        return this;
    },

    setFlip: function (x, y)
    {
        this.flipX = x;
        this.flipY = y;

        return this;
    },

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    }

};

module.exports = Flip;


/***/ },
/* 273 */
/***/ function(module, exports) {

var GetBounds = {

    getBounds: function (output)
    {
        if (output === undefined) { output = { x: 0, y: 0, width: 0, height: 0 }; }

        var x = this.x;
        var y = this.y;

        var w = this.displayWidth;
        var h = this.displayHeight;

        var r = this.rotation;

        var wct = w * Math.cos(r);
        var hct = h * Math.cos(r);

        var wst = w * Math.sin(r);
        var hst = h * Math.sin(r);

        var xMin = x;
        var xMax = x;
        var yMin = y;
        var yMax = y;

        if (r > 0)
        {
            if (r < 1.5707963267948966)
            {
                // 0 < theta < 90
                yMax = y + hct + wst;
                xMin = x - hst;
                xMax = x + wct;
            }
            else
            {
                // 90 <= theta <= 180
                yMin = y + hct;
                yMax = y + wst;
                xMin = x - hst + wct;
            }
        }
        else if (r > -1.5707963267948966)
        {
            // -90 < theta <= 0
            yMin = y + wst;
            yMax = y + hct;
            xMax = x + wct - hst;
        }
        else
        {
            // -180 <= theta <= -90
            yMin = y + wst + hct;
            xMin = x + wct;
            xMax = x - hst;
        }

        output.x = xMin;
        output.y = yMin;
        output.width = xMax - xMin;
        output.height = yMax - yMin;

        return output;
    }
};

module.exports = GetBounds;


/***/ },
/* 274 */
/***/ function(module, exports) {

//  Origin Component
//  Values are normalized, given in the range 0 to 1.
//  Display values contain the calculated pixel values.

var Origin = {

    originX: 0.5,
    originY: 0.5,

    //  READ ONLY
    displayOriginX: 0,
    displayOriginY: 0,

    setOrigin: function (x, y)
    {
        if (x === undefined) { x = 0.5; }
        if (y === undefined) { y = x; }

        this.originX = x;
        this.originY = y;

        return this.updateOrigin();
    },

    setDisplayOrigin: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.displayOriginX = x;
        this.displayOriginY = y;

        this.originX = this.width / x;
        this.originY = this.height / y;

        return this;
    },

    updateOrigin: function ()
    {
        this.displayOriginX = Math.round(this.originX * this.width);
        this.displayOriginY = Math.round(this.originY * this.height);

        return this;
    }

};

module.exports = Origin;


/***/ },
/* 275 */
/***/ function(module, exports) {

/* This is a WebGL ONLY component */
var RenderPass = {
    outputStage: {
        renderTarget: null,
        enableDepthTest: false,
        enableStencilTest: false,
        enableBlending: false,

        /* Blend State */
        blendLogicOp: 0,
        blendSrcRgb: 0,
        blendDstRgb: 0,
        blendSrcAlpha: 0,
        blendDstAlpha: 0,
        blendEqRgb: 0,
        blendEqAlpha: 0,
        blendRed: 0,
        blendGreen: 0,
        blendBlue: 0,
        blendAlpha: 0,

        /* Depth-Stencil State */
        depthFunc: 0,
        depthMask: 0,
        stencilFunc: 0,
        stencilFail: 0,
        stencilZFail: 0,
        stencilZPass: 0
    },

    renderPass: {
        shaderPipeline: null,
        textures: [],
        topology: 0
    },

    /* Needed for getting constant values
     * Form the WebGL context.
     */
    renderingContext: null,
    
    /* Utility functions */
    initRenderPassComponent: function () 
    {
        var renderingContext = this.state.game.renderer.gl;

        if (renderingContext !== undefined &&
            ((renderingContext instanceof WebGLRenderingContext) || (renderingContext !== null && renderingContext.rawgl !== undefined)))
        {
            this.renderingContext = renderingContext;
            this.setDefaultDepthStencilState();
            this.setNoBlending();
        }
    },

    setRenderTarget: function (renderTarget) 
    {
        this.outputStage.renderTarget = renderTarget;
        return this;
    },

    setDefaultDepthStencilState: function () 
    {
        var gl = this.renderingContext;
        var outputStage = this.outputStage;

        outputStage.depthEnabled = false;
        outputStage.stencilEnabled = false;
        outputStage.depthMask = true;
        outputStage.depthFunc = gl.LESS;
        outputStage.stencilFunc = gl.NEVER;
        outputStage.stencilZFail = gl.KEEP;
        outputStage.stencilZPass = gl.KEEP;
        
        return this;
    },

    setBlendColor: function (r, g, b, a) 
    {
        var outputStage = this.outputStage;

        outputStage.blendRed = r;
        outputStage.blendGreen = g;
        outputStage.blendBlue = b;
        outputStage.blendAlpha = a;

        return this;
    },

    setBlendFunc: function (src, dst, eq) 
    {
        var outputStage = this.outputStage;
        
        outputStage.blendSrcRgb = outputStage.blendSrcAlpha = src;
        outputStage.blendDstRgb = outputStage.blendDstAlpha = dst;
        outputStage.blendEqRgb = outputStage.blendEqAlpha = eq;
        
        return this;
    },

    setBlendFuncSeparate: function (srcRgb, srcAlpha, dstRgb, dstAlpha, eqRgb, eqAlpha) 
    {
        var outputStage = this.outputStage;
        
        outputStage.blendSrcRgb = srcRgb;
        outputStage.blendSrcAlpha = srcAlpha;
        outputStage.blendDstRgb = dstRgb;
        outputStage.blendDstAlpha = dstAlpha;
        outputStage.blendEqRgb = eqRgb;
        outputStage.blendEqAlpha = eqAlpha;
        
        return this;
    },

    setDefaultBlending: function () {
        var gl = this.renderingContext;

        this.setBlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ADD);
        
        return this;
    },

    setNoBlending: function () {
        var gl = this.renderingContext;

        this.setBlendFunc(gl.ONE, gl.ZERO, gl.ADD);
        
        return this;
    },

    setTexture: function (texture, textureUnit) {
        this.renderPass.textures[textureUnit] = texture;
        return this;
    },

    setTopology: function (topology) {
        this.renderPass.topology = topology;
        return this;
    },

    setShaderPipeline: function (shaderPipeline) {
        this.renderPass.shaderPipeline = shaderPipeline;
        return this;
    },

    /* Call this on render pass */
    dispatchRenderPassState: function () {
        var gl = this.renderingContext;
        var textures = this.textures;
        var length = textures.length;
        var outputStage = this.outputStage;

        for (var index = 0; index < length; ++index) {
            if (textures[index] !== null) {
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, textures[index].texture);
            } else {
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
        }

        if (outputStage.enableBlending) {
            gl.enable(gl.BLEND);
            gl.blendFuncSeparate(outputStage.blendSrcRGB, outputStage.blendDstRGB, outputStage.blendSrcAlpha, outputStage.blendDstAlpha);
            gl.blendEquationSeparate(outputStage.blendEqRgb, outputStage.blendEqAlpha);
            gl.blendColor(outputStage.blendRed, outputStage.blendGreen, outputStage.blendBlue, outputStage.blendAlpha)
        } else {
            gl.disable(gl.BLEND);
        }

        if (outputStage.enableDepthTest) {
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(outputStage.depthFunc);
            gl.depthMask(outputStage.depthMask);
        } else {
            gl.disable(gl.DEPTH_TEST);
        }

        if (outputStage.enableStencilTest) {
            gl.enable(gl.STENCIL_TEST);
            gl.stencilFunc(this.stencilFunc, 0, 1);
            gl.stencilOp(this.stencilFail, this.stencilZFail, this.stencilZPass);
        } else {
            gl.disable(gl.STENCIL_TEST);
        }
    }
};

module.exports = RenderPass;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(42);

//  ScaleMode Component

var ScaleMode = {

    _scaleMode: ScaleModes.DEFAULT,

    scaleMode: {

        get: function ()
        {
            return this._scaleMode;
        },

        set: function (value)
        {
            if (value === ScaleModes.LINEAR || value === ScaleModes.NEAREST)
            {
                this._scaleMode = value;
            }
        }

    }

};

module.exports = ScaleMode;


/***/ },
/* 277 */
/***/ function(module, exports) {

var Size = {

    width: 0,
    height: 0,

    displayWidth: {

        get: function ()
        {
            return this.scaleX * this.frame.realWidth;
        },

        set: function (value)
        {
            this.scaleX = value / this.frame.realWidth;
        }

    },

    displayHeight: {

        get: function ()
        {
            return this.scaleY * this.frame.realHeight;
        },

        set: function (value)
        {
            this.scaleY = value / this.frame.realHeight;
        }

    },

    setSizeToFrame: function (frame)
    {
        if (frame === undefined) { frame = this.frame; }

        this.width = frame.realWidth;
        this.height = frame.realHeight;

        return this;
    },

    setSize: function (width, height)
    {
        this.width = width;
        this.height = height;

        return this;
    }

};

module.exports = Size;


/***/ },
/* 278 */
/***/ function(module, exports) {

//  Texture Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 8; // 1000

var Texture = {

    texture: null,
    frame: null,

    setTexture: function (key, frame)
    {
        this.texture = this.state.sys.textures.get(key);

        this.frame = this.texture.get(frame);

        if (!this.frame.cutWidth || !this.frame.cutHeight)
        {
            this.renderFlags &= ~_FLAG;
        }
        else
        {
            this.renderFlags |= _FLAG;

            // if (this.hasOwnProperty('originX'))
            // {
            //     //  Default origin to the center
            //     var w = Math.floor(this.frame.realWidth / 2);
            //     var h = Math.floor(this.frame.realHeight / 2);

            //     this.setOrigin(w, h);
            // }
        }

        return this;
    }

};

module.exports = Texture;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);
var WrapAngle = __webpack_require__(171);
var WrapAngleDegrees = __webpack_require__(172);

//  global bitmask flag for GameObject.renderMask (used by Scale)
var _FLAG = 4; // 0100

//  Transform Component

var Transform = {

    //  "private" properties
    _scaleX: 1,
    _scaleY: 1,
    _rotation: 0,
    _z: 0,

    x: 0,
    y: 0,
    z: {
        get: function () {
            return this._z;
        },
        set: function (value) {
            this.state.sortChildrenFlag = true;
            this._z = value;
        }
    },

    scaleX: {

        get: function ()
        {
            return this._scaleX;
        },

        set: function (value)
        {
            this._scaleX = value;

            if (this._scaleX === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    scaleY: {

        get: function ()
        {
            return this._scaleY;
        },

        set: function (value)
        {
            this._scaleY = value;

            if (this._scaleY === 0)
            {
                this.renderFlags &= ~_FLAG;
            }
            else
            {
                this.renderFlags |= _FLAG;
            }
        }

    },

    angle: {

        get: function ()
        {
            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
        },

        set: function (value)
        {
            //  value is in degrees
            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
        }
    },

    rotation: {

        get: function ()
        {
            return this._rotation;
        },

        set: function (value)
        {
            //  value is in radians
            this._rotation = WrapAngle(value);
        }
    },

    setPosition: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.x = x;
        this.y = y;

        return this;
    },

    setRotation: function (radians)
    {
        if (radians === undefined) { radians = 0; }

        this.rotation = radians;

        return this;
    },

    setScale: function (x, y)
    {
        if (x === undefined) { x = 1; }
        if (y === undefined) { y = x; }

        this.scaleX = x;
        this.scaleY = y;

        return this;
    }

};

module.exports = Transform;


/***/ },
/* 280 */
/***/ function(module, exports) {


//  Visible Component

//  bitmask flag for GameObject.renderMask
var _FLAG = 1; // 0001

var Visible = {

    _visible: true,

    visible: {

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            if (value)
            {
                this._visible = true;
                this.renderFlags |= _FLAG;
            }
            else
            {
                this._visible = false;
                this.renderFlags &= ~_FLAG;
            }
        }

    }

};

module.exports = Visible;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);

var Audio = {

    /**
    * @property {boolean} audioData - Are Audio tags available?
    * @default
    */
    audioData: false,

    /**
    * @property {boolean} webAudio - Is the WebAudio API available?
    * @default
    */
    webAudio: false,

    /**
    * @property {boolean} ogg - Can this device play ogg files?
    * @default
    */
    ogg: false,

    /**
    * @property {boolean} opus - Can this device play opus files?
    * @default
    */
    opus: false,

    /**
    * @property {boolean} mp3 - Can this device play mp3 files?
    * @default
    */
    mp3: false,

    /**
    * @property {boolean} wav - Can this device play wav files?
    * @default
    */
    wav: false,

    /**
    * Can this device play m4a files?
    * @property {boolean} m4a - True if this device can play m4a files.
    * @default
    */
    m4a: false,

    /**
    * @property {boolean} webm - Can this device play webm files?
    * @default
    */
    webm: false,

    /**
    * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?
    * @default
    */
    dolby: false

};

function init ()
{
    Audio.audioData = !!(window['Audio']);
    Audio.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']);

    var audioElement = document.createElement('audio');

    var result = !!audioElement.canPlayType;

    try
    {
        if (result)
        {
            if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.ogg = true;
            }

            if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
            {
                Audio.opus = true;
            }

            if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
            {
                Audio.mp3 = true;
            }

            //  Mimetypes accepted:
            //  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
            //  bit.ly/iphoneoscodecs
            if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
            {
                Audio.wav = true;
            }

            if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
            {
                Audio.m4a = true;
            }

            if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
            {
                Audio.webm = true;
            }

            if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '')
            {
                if (Browser.edge)
                {
                    Audio.dolby = true;
                }
                else if (Browser.safari && Browser.safariVersion >= 9)
                {
                    if ((/Mac OS X (\d+)_(\d+)/).test(navigator.userAgent))
                    {
                        var major = parseInt(RegExp.$1, 10);
                        var minor = parseInt(RegExp.$2, 10);

                        if ((major === 10 && minor >= 11) || major > 10)
                        {
                            Audio.dolby = true;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        //  Nothing to do here
    }

    return Audio;
}

module.exports = init();


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);

var Fullscreen = {

    /**
    * @property {boolean} available - Does the browser support the Full Screen API?
    * @default
    */
    available: false,

    /**
    * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.
    * @default
    */
    request: '',

    /**
    * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.
    * @default
    */
    cancel: '',

    /**
    * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?
    * @default
    */
    keyboard: false

};

/**
* Checks for support of the Full Screen API.
*/
function init ()
{
    var fs = [
        'requestFullscreen',
        'requestFullScreen',
        'webkitRequestFullscreen',
        'webkitRequestFullScreen',
        'msRequestFullscreen',
        'msRequestFullScreen',
        'mozRequestFullScreen',
        'mozRequestFullscreen'
    ];

    var element = document.createElement('div');

    for (var i = 0; i < fs.length; i++)
    {
        if (element[fs[i]])
        {
            Fullscreen.available = true;
            Fullscreen.request = fs[i];
            break;
        }
    }

    var cfs = [
        'cancelFullScreen',
        'exitFullscreen',
        'webkitCancelFullScreen',
        'webkitExitFullscreen',
        'msCancelFullScreen',
        'msExitFullscreen',
        'mozCancelFullScreen',
        'mozExitFullscreen'
    ];

    if (Fullscreen.available)
    {
        for (var i = 0; i < cfs.length; i++)
        {
            if (document[cfs[i]])
            {
                Fullscreen.cancel = cfs[i];
                break;
            }
        }
    }

    //  Keyboard Input?
    if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])
    {
        Fullscreen.keyboard = true;
    }

    return Fullscreen;
}

module.exports = init();


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);

var Input = {

    /**
    * @property {boolean} touch - Is touch available?
    * @default
    */
    touch: false,

    /**
    * @property {boolean} mspointer - Is mspointer available?
    * @default
    */
    mspointer: false,

    /**
    * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
    * @default
    * @protected
    */
    wheelEvent: null
    
};

function init ()
{
    if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1))
    {
        Input.touch = true;
    }

    if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)
    {
        Input.mspointer = true;
    }

    if (!OS.cocoonJS)
    {
        // See https://developer.mozilla.org/en-US/docs/Web/Events/wheel
        if ('onwheel' in window || (Browser.ie && 'WheelEvent' in window))
        {
            // DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+
            Input.wheelEvent = 'wheel';
        }
        else if ('onmousewheel' in window)
        {
            // Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.
            Input.wheelEvent = 'mousewheel';
        }
        else if (Browser.firefox && 'MouseScrollEvent' in window)
        {
            // FF prior to 17. This should probably be scrubbed.
            Input.wheelEvent = 'DOMMouseScroll';
        }
    }

    return Input;
}

module.exports = init();


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);

var Video = {

    /**
    * @property {boolean} oggVideo - Can this device play ogg video files?
    * @default
    */
    oggVideo: false,

    /**
    * @property {boolean} h264Video - Can this device play h264 mp4 video files?
    * @default
    */
    h264Video: false,

    /**
    * @property {boolean} mp4Video - Can this device play h264 mp4 video files?
    * @default
    */
    mp4Video: false,

    /**
    * @property {boolean} webmVideo - Can this device play webm video files?
    * @default
    */
    webmVideo: false,

    /**
    * @property {boolean} vp9Video - Can this device play vp9 video files?
    * @default
    */
    vp9Video: false,

    /**
    * @property {boolean} hlsVideo - Can this device play hls video files?
    * @default
    */
    hlsVideo: false

};

function init ()
{
    var videoElement = document.createElement('video');
    var result = !!videoElement.canPlayType;

    try
    {
        if (result)
        {
            if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''))
            {
                Video.oggVideo = true;
            }

            if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                Video.h264Video = true;
                Video.mp4Video = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ''))
            {
                Video.webmVideo = true;
            }

            if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ''))
            {
                Video.vp9Video = true;
            }

            if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ''))
            {
                Video.hlsVideo = true;
            }
        }
    }
    catch (e)
    {
        //  Nothing to do
    }

    return Video;
}

module.exports = init();


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

//  This singleton is instantiated as soon as Phaser loads,
//  before a Phaser.Game instance has even been created.
//  Which means all instances of Phaser Games can share it,
//  without having to re-poll the device all over again

var OS = __webpack_require__(21);
var Browser = __webpack_require__(30);
var Features = __webpack_require__(94);
var Input = __webpack_require__(283);
var Audio = __webpack_require__(281);
var Video = __webpack_require__(284);
var Fullscreen = __webpack_require__(282);
var CanvasFeatures = __webpack_require__(93);

module.exports = {

    OS: OS,
    Browser: Browser,
    Features: Features,
    Input: Input,
    Audio: Audio,
    Video: Video,
    Fullscreen: Fullscreen,
    CanvasFeatures: CanvasFeatures

};


/***/ },
/* 286 */
/***/ function(module, exports) {

var AddEventListener = function (target, event, listener, useCapture)
{
    if (useCapture === undefined) { useCapture = false; }

    target.addEventListener(event, listener, useCapture);
};

module.exports = AddEventListener;


/***/ },
/* 287 */
/***/ function(module, exports) {

var RemoveEventListener = function (target, event, listener)
{
    target.removeEventListener(event, listener);
};

module.exports = RemoveEventListener;


/***/ },
/* 288 */
/***/ function(module, exports) {

var RemoveFromDOM = function (element)
{
    if (element.parentNode)
    {
        element.parentNode.removeChild(element);
    }
};

module.exports = RemoveFromDOM;


/***/ },
/* 289 */
/***/ function(module, exports) {

/**
* Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
*
* @method Phaser.Canvas.TouchAction
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var TouchAction = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    canvas.style['msTouchAction'] = value;
    canvas.style['ms-touch-action'] = value;
    canvas.style['touch-action'] = value;

    return canvas;
};

module.exports = TouchAction;


/***/ },
/* 290 */
/***/ function(module, exports) {

/**
* Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
*
* @method Phaser.Canvas.setUserSelect
* @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
* @param {string} [value] - The touch action to set. Defaults to 'none'.
* @return {HTMLCanvasElement} The source canvas.
*/
var UserSelect = function (canvas, value)
{
    if (value === undefined) { value = 'none'; }

    var vendors = [
        '-webkit-',
        '-khtml-',
        '-moz-',
        '-ms-',
        ''
    ];

    vendors.forEach(function (vendor)
    {
        canvas.style[vendor + 'user-select'] = value;
    });

    canvas.style['-webkit-touch-callout'] = value;
    canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';

    return canvas;
};

module.exports = UserSelect;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(99);
var EventListener = __webpack_require__(292);

var EventBinding = function (dispatcher, type)
{
    this.dispatcher = dispatcher;
    this.type = type;
    this.state = CONST.DISPATCHER_IDLE;
    this.active = [];
};

EventBinding.prototype.constructor = EventBinding;

EventBinding.prototype = {

    total: function ()
    {
        var total = 0;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state !== CONST.LISTENER_REMOVING)
            {
                total++;
            }
        }

        return total;
    },

    get: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return this.active[i];
            }
        }
    },

    getIndex: function (callback)
    {
        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].callback === callback)
            {
                return i;
            }
        }

        return null;
    },

    has: function (callback)
    {
        return (this.get(callback));
    },

    add: function (callback, priority, once)
    {
        var listener = this.get(callback);

        if (!listener)
        {
            //  The listener doesn't exist, so create one
            listener = EventListener(this.type, callback, priority, once);
        }
        else
        {
            //  Listener already exists, abort
            return;
        }

        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we don't need a pending state
            listener.state = CONST.LISTENER_ACTIVE;

            this.active.push(listener);

            this.active.sort(this.sortHandler);
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  Add it to the list, but keep the state as pending.
            //  The call to 'tidy' will sort it out at the end of the dispatch.
            this.active.push(listener);
        }
    },

    sortHandler: function (listenerA, listenerB)
    {
        if (listenerB.priority < listenerA.priority)
        {
            return -1;
        }
        else if (listenerB.priority > listenerA.priority)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    },

    remove: function (callback)
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            //  The Dispatcher isn't doing anything, so we can remove right away
            var i = this.getIndex(callback);

            if (i !== null)
            {
                this.active.splice(i, 1);
            }
        }
        else if (this.state === CONST.DISPATCHER_DISPATCHING)
        {
            //  The Dispatcher is working, so we flag the listener for removal at the end
            var listener = this.get(callback);

            if (listener)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }
        }
    },

    dispatch: function (event)
    {
        if (this.state !== CONST.DISPATCHER_IDLE)
        {
            throw new Error('Error: Failed to execute \'EventDispatcher.dispatch\' on \'' + this.type + '\': The event is already being dispatched.');
        }
        else if (this.active.length === 0)
        {
            //  This was a valid dispatch call, we just had nothing to do ...
            return;
        }

        this.state = CONST.DISPATCHER_DISPATCHING;

        var listener;

        for (var i = 0; i < this.active.length; i++)
        {
            listener = this.active[i];

            if (listener.state !== CONST.LISTENER_ACTIVE)
            {
                continue;
            }

            listener.callback.call(this.dispatcher, event);

            //  Has the callback changed the state of this binding?
            if (this.state !== CONST.DISPATCHER_DISPATCHING)
            {
                //  Yup! Let's break out
                break;
            }

            //  Was it a 'once' listener?
            if (listener.once)
            {
                listener.state = CONST.LISTENER_REMOVING;
            }

            //  Has the event been halted by the callback?
            if (!event._propagate)
            {
                //  Break out, a listener has called Event.stopPropagation
                break;
            }
        }

        //  Dispatch over, or aborted
        if (this.state === CONST.DISPATCHER_REMOVING)
        {
            this.removeAll();

            //  All done, tidy the list in case there were any pending events added
            this.tidy();
        }
        else if (this.state === CONST.DISPATCHER_DESTROYED)
        {
            this.dispatcher.delete(this.type);
        }
        else
        {
            //  All done, just purge the list
            this.tidy();

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    //  Removes all listeners
    //  If this is currently being dispatched then don't remove 'pending' listeners
    //  (i.e. ones that were added during the dispatch), only active ones
    removeAll: function ()
    {
        if (this.state === CONST.DISPATCHER_IDLE)
        {
            this.active.length = 0;
        }
        else
        {
            for (var i = this.active.length - 1; i >= 0; i--)
            {
                if (this.active[i].state !== CONST.LISTENER_PENDING)
                {
                    this.active.pop();
                }
            }

            this.state = CONST.DISPATCHER_IDLE;
        }
    },

    tidy: function ()
    {
        //  Nothing to do ...
        if (this.active.length === 0)
        {
            return;
        }

        var added = 0;

        var i = this.active.length - 1;

        do
        {
            if (this.active[i].state === CONST.LISTENER_REMOVING)
            {
                this.active.splice(i, 1);
            }
            else if (this.active[i].state === CONST.LISTENER_PENDING)
            {
                this.active[i].state === CONST.LISTENER_ACTIVE;
                added++;
            }

            i--;
        }
        while (i >= 0);

        if (added > 0)
        {
            this.active.sort(this.sortHandler);
        }
    },

    destroy: function ()
    {
        this.active.length = 0;
        this.dispatcher = undefined;
        this.type = '';
        this.state = CONST.DISPATCHER_DESTROYED;
    }

};

module.exports = EventBinding;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(99);

var EventListener = function (type, callback, priority, once)
{
    return {
        type: type,
        callback: callback,
        priority: priority,
        once: once,
        state: CONST.LISTENER_PENDING
    };
};

module.exports = EventListener;


/***/ },
/* 293 */
/***/ function(module, exports) {

function getValue (node, attribute)
{
    return parseInt(node.getAttribute(attribute), 10);
}

var ParseXMLBitmapFont = function (xml, xSpacing, ySpacing, frame)
{
    if (xSpacing === undefined) { xSpacing = 0; }
    if (ySpacing === undefined) { ySpacing = 0; }

    var data = {};
    var info = xml.getElementsByTagName('info')[0];
    var common = xml.getElementsByTagName('common')[0];

    data.font = info.getAttribute('face');
    data.size = getValue(info, 'size');
    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;
    data.chars = {};

    var letters = xml.getElementsByTagName('char');

    var x = (frame) ? frame.x : 0;
    var y = (frame) ? frame.y : 0;

    for (var i = 0; i < letters.length; i++)
    {
        var node = letters[i];

        var charCode = getValue(node, 'id');
        var gw = getValue(node, 'width');
        var gh = getValue(node, 'height');

        data.chars[charCode] =
        {
            x: x + getValue(node, 'x'),
            y: y + getValue(node, 'y'),
            width: gw,
            height: gh,
            centerX: Math.floor(gw / 2),
            centerY: Math.floor(gh / 2),
            xOffset: getValue(node, 'xoffset'),
            yOffset: getValue(node, 'yoffset'),
            xAdvance: getValue(node, 'xadvance') + xSpacing,
            kerning: {}
        };
    }

    var kernings = xml.getElementsByTagName('kerning');

    for (i = 0; i < kernings.length; i++)
    {
        var kern = kernings[i];

        var first = getValue(kern, 'first');
        var second = getValue(kern, 'second');
        var amount = getValue(kern, 'amount');

        data.chars[second].kerning[first] = amount;
    }

    return data;
};

module.exports = ParseXMLBitmapFont;


/***/ },
/* 294 */
/***/ function(module, exports) {

var DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var displayCallback = src.displayCallback;

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x, src.y);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    for (var index = 0; index < textLength; ++index)
    {
        //  Reset the scale (in case the callback changed it)
        scale = (src.fontSize / src.fontData.size);
        rotation = 0;

        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0 });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        x *= scale;
        y *= scale;

        x -= cameraScrollX;
        y -= cameraScrollY;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(scale, scale);

        // ctx.fillStyle = 'rgba(0,255,0,0.2)';
        // ctx.fillRect(0, 0, glyphW, glyphH);

        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);

        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    ctx.restore();
};

module.exports = DynamicBitmapTextCanvasRenderer;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(101);
var FactoryContainer = __webpack_require__(4);

var DynamicBitmapTextFactory = {

    KEY: 'dynamicBitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.state.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(DynamicBitmapTextFactory);


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(294),
    renderWebGL: __webpack_require__(297)

};


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(29);
var tempMatrix = new TransformMatrix();
var tempMatrixChar = new TransformMatrix();

var DynamicBitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var displayCallback = src.displayCallback;
    var textureFrame = src.frame;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var text = src.text;
    var textLength = text.length;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = src.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var srcX = src.x; 
    var srcY = src.y;
    var textureData = src.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var tx = 0;
    var ty = 0;
    var txw = 0;
    var tyh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (src.fontSize / src.fontData.size);
    var uta, utb, utc, utd, ute, utf;
    var tempMatrixCharMatrix = tempMatrixChar.matrix;

    tempMatrix.applyITRS(
        src.x - cameraScrollX, src.y - cameraScrollY, 
        -src.rotation, 
        src.scaleX, src.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);
        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];
        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        if (displayCallback)
        {
            var output = displayCallback({ index: index, charCode: charCode, x: x, y: y, scale: scale, rotation: 0 });

            x = output.x;
            y = output.y;
            scale = output.scale;
            rotation = output.rotation;
        }

        tempMatrixChar.applyITRS(
            x, y,
            -rotation,
            scale, scale
        );

        uta = tempMatrixCharMatrix[0];
        utb = tempMatrixCharMatrix[1];
        utc = tempMatrixCharMatrix[2];
        utd = tempMatrixCharMatrix[3];
        ute = tempMatrixCharMatrix[4];
        utf = tempMatrixCharMatrix[5];

        sra = uta * mva + utb * mvc;
        srb = uta * mvb + utb * mvd;
        src = utc * mva + utd * mvc;
        srd = utc * mvb + utd * mvd;
        sre = ute * mva + utf * mvc + mve;
        srf = ute * mvb + utf * mvd + mvf;

        xw = glyphW;
        yh = glyphH;
        tx0 = sre;
        ty0 = srf;
        tx1 = yh * src + sre;
        ty1 = yh * srd + srf;
        tx2 = xw * sra + yh * src + sre;
        ty2 = xw * srb + yh * srd + srf;
        tx3 = xw * sra + sre;
        ty3 = xw * srb + srf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, texture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }
};

module.exports = DynamicBitmapTextWebGLRenderer;


/***/ },
/* 298 */
/***/ function(module, exports) {

var BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    var text = src.text;
    var textLength = text.length;

    if (this.renderMask !== this.renderFlags || textLength === 0)
    {
        return;
    }
    
    var textureFrame = src.frame;

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;

    var xAdvance = 0;
    var yAdvance = 0;

    var indexCount = 0;
    var charCode = 0;

    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;

    var x = 0;
    var y = 0;

    var lastGlyph = null;
    var lastCharCode = 0;

    var ctx = renderer.currentContext;
    var image = src.frame.source.image;

    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;

    var rotation = 0;
    var scale = (src.fontSize / src.fontData.size);

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(src.x - cameraScrollX, src.y - cameraScrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);

        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];

        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;

        glyphW = glyph.width;
        glyphH = glyph.height;

        x = indexCount + glyph.xOffset + xAdvance;
        y = glyph.yOffset + yAdvance;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        x *= scale;
        y *= scale;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
        ctx.restore();
        
        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }

    ctx.restore();
};

module.exports = BitmapTextCanvasRenderer;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

var BitmapText = __webpack_require__(102);
var FactoryContainer = __webpack_require__(4);

var BitmapTextFactory = {

    KEY: 'bitmapText',

    add: function (x, y, font, text, size, align)
    {
        return this.state.children.add(new BitmapText(this.state, x, y, font, text, size, align));
    },

    make: function (x, y, font, text, size, align)
    {
        return new BitmapText(this.state, x, y, font, text, size, align);
    }

};

module.exports = FactoryContainer.register(BitmapTextFactory);


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(298),
    renderWebGL: __webpack_require__(301)

};


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

var TransformMatrix = __webpack_require__(29);
var tempMatrix = new TransformMatrix();

var BitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var textureFrame = src.frame;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var text = src.text;
    var textLength = text.length;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var blitterBatch = renderer.blitterBatch;
    var alpha = src.alpha;
    var vertexDataBuffer = blitterBatch.vertexDataBuffer;
    var vertexBuffer = vertexDataBuffer.floatView;
    var vertexOffset = 0;
    var srcX = src.x; 
    var srcY = src.y;
    var textureData = src.texture.source[textureFrame.sourceIndex];
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var textureWidth = textureData.width;
    var textureHeight = textureData.height;
    var texture = textureData.glTexture;
    var xAdvance = 0;
    var yAdvance = 0;
    var indexCount = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var xw = 0;
    var yh = 0;
    var tx = 0;
    var ty = 0;
    var txw = 0;
    var tyh = 0;
    var umin = 0;
    var umax = 0;
    var vmin = 0;
    var vmax = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var tempMatrixMatrix = tempMatrix.matrix;
    var cameraMatrix = camera.matrix.matrix;
    var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var scale = (src.fontSize / src.fontData.size);

    tempMatrix.applyITRS(
        src.x - cameraScrollX, src.y - cameraScrollY, 
        -src.rotation, 
        src.scaleX, src.scaleY
    );

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    for (var index = 0; index < textLength; ++index)
    {
        charCode = text.charCodeAt(index);
        if (charCode === 10)
        {
            xAdvance = 0;
            indexCount = 0;
            yAdvance += lineHeight;
            lastGlyph = null;
            continue;
        }

        glyph = chars[charCode];
        if (!glyph)
        {
            continue;
        }

        glyphX = textureX + glyph.x;
        glyphY = textureY + glyph.y;
        glyphW = glyph.width;
        glyphH = glyph.height;
        x = (indexCount + glyph.xOffset + xAdvance) * scale;
        y = (glyph.yOffset + yAdvance) * scale;

        if (lastGlyph !== null)
        {
            var kerningOffset = glyph.kerning[lastCharCode];
            x += (kerningOffset !== undefined) ? kerningOffset : 0;
        }

        xw = x + glyphW * scale;
        yh = y + glyphH * scale;
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;
        umin = glyphX / textureWidth;
        umax = (glyphX + glyphW) / textureWidth;
        vmin = glyphY / textureHeight;
        vmax = (glyphY + glyphH) / textureHeight;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, texture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;

        vertexBuffer[vertexOffset++] = tx0;
        vertexBuffer[vertexOffset++] = ty0;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx1;
        vertexBuffer[vertexOffset++] = ty1;
        vertexBuffer[vertexOffset++] = umin;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx2;
        vertexBuffer[vertexOffset++] = ty2;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmax;
        vertexBuffer[vertexOffset++] = alpha;
        vertexBuffer[vertexOffset++] = tx3;
        vertexBuffer[vertexOffset++] = ty3;
        vertexBuffer[vertexOffset++] = umax;
        vertexBuffer[vertexOffset++] = vmin;
        vertexBuffer[vertexOffset++] = alpha;

        xAdvance += glyph.xAdvance;
        indexCount += 1;
        lastGlyph = glyph;
        lastCharCode = charCode;
    }
};

module.exports = BitmapTextWebGLRenderer;


/***/ },
/* 302 */
/***/ function(module, exports) {


var BlitterCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();

    renderer.setBlendMode(src.blendMode);

    var ca = renderer.currentAlpha;

    //  Render bobs
    for (var i = 0; i < list.length; i++)
    {
        var bob = list[i];

        if (ca !== bob.alpha)
        {
            ca = renderer.setAlpha(bob.alpha);
        }

        renderer.blitImage(bob.x, bob.y, bob.frame, camera);
    }
};

module.exports = BlitterCanvasRenderer;


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {


var Blitter = __webpack_require__(103);
var FactoryContainer = __webpack_require__(4);

var BlitterFactory = {

    KEY: 'blitter',

    add: function (x, y, key, frame, parent)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Blitter(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        return new Blitter(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(BlitterFactory);


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(302),
    renderWebGL: __webpack_require__(305)

};


/***/ },
/* 305 */
/***/ function(module, exports) {

var BlitterWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var list = src.getRenderList();
    var blitterBatch = renderer.blitterBatch;
    var cameraMatrix = camera.matrix.matrix;
    var a = cameraMatrix[0];
    var b = cameraMatrix[1];
    var c = cameraMatrix[2];
    var d = cameraMatrix[3];
    var e = cameraMatrix[4];
    var f = cameraMatrix[5];
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;

    //  Render bobs

    for (var i = 0, l = list.length; i < l; i++)
    {
        var bob = list[i];
        var frame = bob.frame;
        var alpha = bob.alpha;
        var vertexDataBuffer = blitterBatch.vertexDataBuffer;
        var vertexBuffer = vertexDataBuffer.floatView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (bob.flipX ? -1 : 1);
        var height = frame.height * (bob.flipY ? -1 : 1);
        var x = bob.x + frame.x - cameraScrollX + ((frame.width) * (bob.flipX ? 1 : 0.0));
        var y = bob.y + frame.y - cameraScrollY + ((frame.height) * (bob.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var tx = x * a + y * c + e;
        var ty = x * b + y * d + f;
        var txw = xw * a + yh * c + e;
        var tyh = xw * b + yh * d + f;

        if (blitterBatch.elementCount >= blitterBatch.maxParticles)
        {
            blitterBatch.flush();
        }

        renderer.setBatch(blitterBatch, frame.texture.source[frame.sourceIndex].glTexture);
        vertexOffset = vertexDataBuffer.allocate(20);
        blitterBatch.elementCount += 6;
        x += frame.x;
        y += frame.y;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x0;
        vertexBuffer[vertexOffset++] = uvs.y0;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = tx;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x1;
        vertexBuffer[vertexOffset++] = uvs.y1;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = tyh;
        vertexBuffer[vertexOffset++] = uvs.x2;
        vertexBuffer[vertexOffset++] = uvs.y2;
        vertexBuffer[vertexOffset++] = alpha;

        vertexBuffer[vertexOffset++] = txw;
        vertexBuffer[vertexOffset++] = ty;
        vertexBuffer[vertexOffset++] = uvs.x3;
        vertexBuffer[vertexOffset++] = uvs.y3;
        vertexBuffer[vertexOffset++] = alpha;
    }
};

module.exports = BlitterWebGLRenderer;


/***/ },
/* 306 */
/***/ function(module, exports) {

var Bob = function (blitter, x, y, frame, visible)
{
    this.parent = blitter;

    this.x = x;
    this.y = y;
    this.frame = frame;
    this.data = {};

    this._visible = visible;
    this._alpha = 1;

    this.flipX - false;
    this.flipY = false;

};

Bob.prototype.constructor = Bob;

Bob.prototype = {

    resetFlip: function ()
    {
        this.flipX = false;
        this.flipY = false;
    },


    reset: function (x, y, frame)
    {
        this.x = x;
        this.y = y;
        this.frame = frame;
    },

    destroy: function ()
    {
        this.parent = undefined;
        this.frame = undefined;
        this.data = undefined;
    }

};

Object.defineProperties(Bob.prototype, {

    visible: {

        enumerable: true,

        get: function ()
        {
            return this._visible;
        },

        set: function (value)
        {
            this._visible = value;
            this.parent.dirty = true;
        }

    },

    alpha: {

        enumerable: true,

        get: function ()
        {
            return this._alpha;
        },

        set: function (value)
        {
            this._alpha = value;
            this.parent.dirty = true;
        }

    }

});

module.exports = Bob;


/***/ },
/* 307 */
/***/ function(module, exports) {


var ContainerCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderCanvas(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerCanvasRenderer;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {


var Container = __webpack_require__(104);
var FactoryContainer = __webpack_require__(4);

var ContainerFactory = {

    KEY: 'container',

    add: function (parent, x, y)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Container(this.state, parent, x, y));
    },

    make: function (parent, x, y)
    {
        return new Container(this.state, parent, x, y);
    }

};

module.exports = FactoryContainer.register(ContainerFactory);


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(307),
    renderWebGL: __webpack_require__(310)

};


/***/ },
/* 310 */
/***/ function(module, exports) {


var ContainerWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    //  Render children
    for (var i = 0; i < src.children.list.length; i++)
    {
        var child = src.children.list[i];

        child.renderWebGL(renderer, child, interpolationPercentage, camera);
    }
};

module.exports = ContainerWebGLRenderer;


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(57);
var MATH_CONST = __webpack_require__(6);

var GraphicsCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    var srcX = src.x;
    var srcY = src.y;
    var srcScaleX = src.scaleX;
    var srcScaleY = src.scaleY;
    var srcRotation = src.rotation;
    var commandBuffer = src.commandBuffer;
    var ctx = renderer.currentContext;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var red = 0;
    var green = 0;
    var blue = 0;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    ctx.save();
    ctx.translate(srcX - cameraScrollX, srcY - cameraScrollY);
    ctx.rotate(srcRotation);
    ctx.scale(srcScaleX, srcScaleY);
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = src.alpha;

    for (var index = 0, length = commandBuffer.length; index < length; ++index)
    {
        var commandID = commandBuffer[index];

        switch (commandID)
        {
            case Commands.ARC:
                ctx.arc(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4],
                    commandBuffer[index + 5],
                    commandBuffer[index + 6]
                );
                index += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[index + 1];
                lineColor = commandBuffer[index + 2];
                lineAlpha = commandBuffer[index + 3];
                red = ((lineColor & 0xFF0000) >>> 16);
                green = ((lineColor & 0xFF00) >>> 8);
                blue = (lineColor & 0xFF);
                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';
                ctx.lineWidth = lineWidth;
                index += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[index + 1];
                fillAlpha = commandBuffer[index + 2];
                red = ((fillColor & 0xFF0000) >>> 16);
                green = ((fillColor & 0xFF00) >>> 8);
                blue = (fillColor & 0xFF);
                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
                index += 2;
                break;

            case Commands.BEGIN_PATH:
                ctx.beginPath();
                break;

            case Commands.CLOSE_PATH:
                ctx.closePath();
                break;

            case Commands.FILL_PATH:
                ctx.fill();
                break;

            case Commands.STROKE_PATH:
                ctx.stroke();
                break;

            case Commands.FILL_RECT:
                ctx.fillRect(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2],
                    commandBuffer[index + 3],
                    commandBuffer[index + 4]
                );
                index += 4;
                break;

            case Commands.FILL_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.fill();
                index += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                ctx.beginPath();
                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
                ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
                ctx.closePath();
                ctx.stroke();
                index += 6;
                break;

            case Commands.LINE_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.MOVE_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 2;
                break;

            case Commands.LINE_FX_TO:
                ctx.lineTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            case Commands.MOVE_FX_TO:
                ctx.moveTo(
                    commandBuffer[index + 1],
                    commandBuffer[index + 2]
                );
                index += 5;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + commandID);
                break;
        }
    }

    ctx.restore();
};

module.exports = GraphicsCanvasRenderer;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

var Graphics = __webpack_require__(105);
var FactoryContainer = __webpack_require__(4);

var GraphicsFactory = {

    KEY: 'graphics',

    add: function (options)
    {
        return this.state.children.add(new Graphics(this.state, options));
    },

    make: function (options)
    {
        return new Graphics(this.state, options);
    }

};

module.exports = FactoryContainer.register(GraphicsFactory);


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(311),
    renderWebGL: __webpack_require__(314)

};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

var Commands = __webpack_require__(57);
var TransformMatrix = __webpack_require__(29);
var pathArray = [];
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
var tempMatrix = new TransformMatrix();

var Point = function (x, y, width, rgb, alpha)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.rgb = rgb;
    this.alpha = alpha;
};

var Path = function (x, y, width, rgb, alpha)
{
    this.points = [];
    this.pointsLength = 1;
    this.points[0] = new Point(x, y, width, rgb, alpha);
};

var GraphicsWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }

    var shapeBatch = renderer.shapeBatch;
    var vertexDataBuffer = shapeBatch.vertexDataBuffer;
    var vertexBufferF32 = vertexDataBuffer.floatView;
    var vertexBufferU32 = vertexDataBuffer.uintView;
    var vertexOffset = 0;
    var cameraScrollX = camera.scrollX;
    var cameraScrollY = camera.scrollY;
    const srcX = src.x - cameraScrollX;
    const srcY = src.y - cameraScrollY;
    const srcScaleX = src.scaleX;
    const srcScaleY = src.scaleY;
    const srcRotation = -src.rotation;
    var commandBuffer = src.commandBuffer;
    var value;
    var lineAlpha = 1.0;
    var fillAlpha = 1.0;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1.0;
    var cameraMatrix = camera.matrix.matrix;
    var lastPath = null;
    var iteration = 0;
    var iterStep = 0.01;
    var tx = 0;
    var ty = 0;
    var ta = 0;
    var x, y, radius, startAngle, endAngle, anticlockwise;
    var width, height, txw, tyh;
    var vertexCount = shapeBatch.vertexCount;
    var polygon = [];
    var x0, y0, x1, y1, x2, y2;
    var tx0, ty0, tx1, ty1, tx2, ty2;
    var v0, v1, v2;
    var polygonIndex;
    var path;
    var pathLength;
    var point;
    var maxVertices = shapeBatch.maxVertices;
    var translateX, translateY;
    var tempMatrixMatrix = tempMatrix.matrix;
    var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
    var mva, mvb, mvc, mvd, mve, mvf;

    tempMatrix.applyITRS(srcX, srcY, srcRotation, srcScaleX, srcScaleY);

    sra = tempMatrixMatrix[0];
    srb = tempMatrixMatrix[1];
    src = tempMatrixMatrix[2];
    srd = tempMatrixMatrix[3];
    sre = tempMatrixMatrix[4];
    srf = tempMatrixMatrix[5];

    cma = cameraMatrix[0];
    cmb = cameraMatrix[1];
    cmc = cameraMatrix[2];
    cmd = cameraMatrix[3];
    cme = cameraMatrix[4];
    cmf = cameraMatrix[5];

    mva = sra * cma + srb * cmc;
    mvb = sra * cmb + srb * cmd;
    mvc = src * cma + srd * cmc;
    mvd = src * cmb + srd * cmd;
    mve = sre * cma + srf * cmc + cme;
    mvf = sre * cmb + srf * cmd + cmf;

    renderer.setBatch(shapeBatch, null);

    for (var cmdIndex = 0, cmdLength = commandBuffer.length; cmdIndex < cmdLength; ++cmdIndex)
    {
        var cmd = commandBuffer[cmdIndex];

        switch(cmd)
        {
            case Commands.ARC:
                iteration = 0;
                x = commandBuffer[cmdIndex + 1];
                y = commandBuffer[cmdIndex + 2];
                radius = commandBuffer[cmdIndex + 3];
                startAngle = commandBuffer[cmdIndex + 4];
                endAngle = commandBuffer[cmdIndex + 5];
                anticlockwise = commandBuffer[cmdIndex + 6];
                
                while (iteration < 1)
                {
                    ta = (endAngle - startAngle) * iteration + startAngle;
                    tx = x + cos(ta) * radius;
                    ty = y + sin(ta) * radius;

                    if (iteration === 0)
                    {
                        lastPath = new Path(tx, ty, lineWidth, lineColor, lineAlpha);
                        pathArray.push(lastPath);
                    }
                    else
                    {
                        lastPath.points.push(new Point(tx, ty, lineWidth, lineColor, lineAlpha));
                    }

                    iteration += iterStep;
                }
                cmdIndex += 6;
                break;

            case Commands.LINE_STYLE:
                lineWidth = commandBuffer[cmdIndex + 1];
                lineColor = commandBuffer[cmdIndex + 2];
                lineAlpha = commandBuffer[cmdIndex + 3];
                cmdIndex += 3;
                break;

            case Commands.FILL_STYLE:
                fillColor = commandBuffer[cmdIndex + 1];
                fillAlpha = commandBuffer[cmdIndex + 2];
                cmdIndex += 2;
                break;

            case Commands.BEGIN_PATH:
                pathArray.length = 0;
                break;

            case Commands.CLOSE_PATH:
                if (lastPath !== null && lastPath.points.length > 0)
                {
                    var firstPoint = lastPath.points[0];
                    var lastPoint = lastPath.points[lastPath.points.length - 1];
                    lastPath.points.push(firstPoint);
                    lastPath = new Path(lastPoint.x, lastPoint.y, lastPoint.width, lastPoint.rgb, lastPoint.alpha);
                    pathArray.push(lastPath);
                }
                break;

            case Commands.FILL_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    shapeBatch.addFillPath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        pathArray[pathArrayIndex].points,
                        fillColor,
                        fillAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf
                    );
                }
                break;

            case Commands.STROKE_PATH:
                for (var pathArrayIndex = 0, pathArrayLength = pathArray.length;
                    pathArrayIndex < pathArrayLength;
                    ++pathArrayIndex)
                {
                    var path = pathArray[pathArrayIndex];
                    shapeBatch.addStrokePath(
                        /* Graphics Game Object Properties */
                        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                        /* Rectangle properties */ 
                        path.points,
                        lineWidth,
                        lineColor,
                        lineAlpha,
                        /* Transform */
                        mva, mvb, mvc, mvd, mve, mvf,
                        path === this._lastPath
                    );
                }
                break;
                
            case Commands.FILL_RECT:
                shapeBatch.addFillRect(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Rectangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
             
                cmdIndex += 4;
                break;

            case Commands.FILL_TRIANGLE:
                shapeBatch.addFillTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    fillColor,
                    fillAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
                
                cmdIndex += 6;
                break;

            case Commands.STROKE_TRIANGLE:
                shapeBatch.addStrokeTriangle(
                    /* Graphics Game Object Properties */
                    srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                    /* Triangle properties */ 
                    commandBuffer[cmdIndex + 1] - cameraScrollX,
                    commandBuffer[cmdIndex + 2] - cameraScrollY,
                    commandBuffer[cmdIndex + 3] - cameraScrollX,
                    commandBuffer[cmdIndex + 4] - cameraScrollY,
                    commandBuffer[cmdIndex + 5] - cameraScrollX,
                    commandBuffer[cmdIndex + 6] - cameraScrollY,
                    lineWidth,
                    lineColor,
                    lineAlpha,
                    /* Transform */
                    mva, mvb, mvc, mvd, mve, mvf
                );
                
                cmdIndex += 6;
                break

            case Commands.LINE_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha));
                }
                else
                {
                    lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                    pathArray.push(lastPath);
                }
                cmdIndex += 2;
                break;

            case Commands.MOVE_TO:
                lastPath = new Path(commandBuffer[cmdIndex + 1], commandBuffer[cmdIndex + 2], lineWidth, lineColor, lineAlpha);
                pathArray.push(lastPath);
                cmdIndex += 2;
                break;

            case Commands.LINE_FX_TO:
                if (lastPath !== null)
                {
                    lastPath.points.push(new Point(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    ));
                }
                else
                {
                    lastPath = new Path(
                        commandBuffer[cmdIndex + 1], 
                        commandBuffer[cmdIndex + 2], 
                        commandBuffer[cmdIndex + 3],
                        commandBuffer[cmdIndex + 4],
                        commandBuffer[cmdIndex + 5]
                    );
                    pathArray.push(lastPath);
                }
                cmdIndex += 5;
                break;

            case Commands.MOVE_FX_TO:
                lastPath = new Path(
                    commandBuffer[cmdIndex + 1], 
                    commandBuffer[cmdIndex + 2], 
                    commandBuffer[cmdIndex + 3],
                    commandBuffer[cmdIndex + 4],
                    commandBuffer[cmdIndex + 5]
                );
                pathArray.push(lastPath);
                cmdIndex += 5;
                break;

            default:
                console.error('Phaser: Invalid Graphics Command ID ' + cmd);
                break;
        }
    }

    pathArray.length = 0;
};

module.exports = GraphicsWebGLRenderer;


/***/ },
/* 315 */
/***/ function(module, exports) {


var ImageCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = ImageCanvasRenderer;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {


var Image = __webpack_require__(106);
var FactoryContainer = __webpack_require__(4);

var ImageFactory = {

    KEY: 'image',

    /**
    * Create a new `Image` object.
    *
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    *
    * It can still rotate, scale, crop and receive input events.
    * This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @method Phaser.GameObject.Factory#image
    * @param {number} [x=0] - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} [y=0] - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Image} The newly created Image object.
    */
    add: function (x, y, key, frame, parent)
    {
        if (parent === undefined) { parent = this.state; }

        return parent.children.add(new Image(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        return new Image(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(ImageFactory);


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(315),
    renderWebGL: __webpack_require__(318)

};


/***/ },
/* 318 */
/***/ function(module, exports) {

var ImageWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = ImageWebGLRenderer;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

var Layer = __webpack_require__(107);
var FactoryContainer = __webpack_require__(4);

var LayerFactory = {

    KEY: 'layer',

    add: function (children)
    {
        return new Layer(this.state, children);
    },

    make: function (children)
    {
        return new Layer(this.state, children);
    }

};

module.exports = FactoryContainer.register(LayerFactory);


/***/ },
/* 320 */
/***/ function(module, exports) {


var SpriteCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask === this.renderFlags)
    {
        renderer.drawImage(src, camera);
    }
};

module.exports = SpriteCanvasRenderer;


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Sprite = __webpack_require__(58);
var FactoryContainer = __webpack_require__(4);

var SpriteFactory = {

    KEY: 'sprite',

    /**
    * Create a new Sprite with specific position and sprite sheet key.
    *
    * At its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.
    * They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
    * events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
    *
    * @method Phaser.GameObject.Factory#sprite
    * @param {number} [x=0] - The x coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {number} [y=0] - The y coordinate of the sprite. The coordinate is relative to any parent container this sprite may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|Phaser.Video|PIXI.Texture} [key] - The image used as a texture by this display object during rendering. If a string Phaser will get for an entry in the Image Cache. Or it can be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
    * @param {string|number} [frame] - If a Texture Atlas or Sprite Sheet is used this allows you to specify the frame to be used. Use either an integer for a Frame ID or a string for a frame name.
    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
    * @return {Phaser.Sprite} The newly created Sprite object.
    */
    add: function (x, y, key, frame, group)
    {
        if (group === undefined) { group = this.state; }

        // console.log('ImageFactory.add', key, x, y, frame, group);
        // console.log('into State', this.state);

        return group.children.add(new Sprite(this.state, x, y, key, frame));
    },

    make: function (x, y, key, frame)
    {
        // console.log('ImageFactory.make', key, x, y, frame);

        return new Sprite(this.state, x, y, key, frame);
    }

};

module.exports = FactoryContainer.register(SpriteFactory);


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(320),
    renderWebGL: __webpack_require__(323)

};


/***/ },
/* 323 */
/***/ function(module, exports) {

var SpriteWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    renderer.spriteBatch.addSprite(src, camera);
};

module.exports = SpriteWebGLRenderer;


/***/ },
/* 324 */
/***/ function(module, exports) {


var GetTextSize = function (text, size, lines)
{
    var canvas = text.canvas;
    var context = text.context;
    var style = text.style;

    var lineWidths = [];
    var maxLineWidth = 0;
    var drawnLines = lines.length;
    
    if (style.maxLines > 0 && style.maxLines < lines.length)
    {
        drawnLines = style.maxLines;
    }

    style.syncFont(canvas, context);

    //  Text Width

    for (var i = 0; i < drawnLines; i++)
    {
        var lineWidth = style.strokeThickness + text.padding.x;

        lineWidth += context.measureText(lines[i]).width;

        // Adjust for wrapped text
        if (style.wordWrap)
        {
            lineWidth -= context.measureText(' ').width;
        }

        lineWidths[i] = Math.ceil(lineWidth);
        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
    }

    //  Text Height

    var lineHeight = size.fontSize + style.strokeThickness + text.padding.y;
    var height = lineHeight * drawnLines;
    var lineSpacing = text._lineSpacing || 0;

    if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight)
    {
        lineSpacing = -lineHeight;
    }

    // //  Adjust for line spacing
    if (lineSpacing !== 0)
    {
        height += (lineSpacing > 0) ? lineSpacing * lines.length : lineSpacing * (lines.length - 1);
    }

    return { width: maxLineWidth, height: height, lines: drawnLines, lineWidths: lineWidths, lineSpacing: lineSpacing, lineHeight: lineHeight };
};

module.exports = GetTextSize;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

var CanvasPool = __webpack_require__(22);

/**
* Calculates the ascent, descent and fontSize of a given font style.
*
* @method Phaser.GameObject.Text#determineFontProperties
* @private
* @param {object} textStyle
*/
var MeasureText = function (textStyle, testString)
{
    if (testString === undefined) { testString = '|MÉq'; }

    /**
     * @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
     */
    var canvas = CanvasPool.create(this);

    /**
     * @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
     */
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var width = Math.ceil(context.measureText(testString).width);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * 1.4 | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle.font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(testString, 0, baseline);

    var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height))
    {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;

        CanvasPool.remove(canvas);

        return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx += line;
        }
        else
        {
            break;
        }
    }

    output.ascent = baseline - i;

    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--)
    {
        for (j = 0; j < line; j += 4)
        {
            if (imagedata[idx + j] !== 255)
            {
                stop = true;
                break;
            }
        }

        if (!stop)
        {
            idx -= line;
        }
        else
        {
            break;
        }
    }

    output.descent = (i - baseline) + 6;
    output.fontSize = output.ascent + output.descent;

    CanvasPool.remove(canvas);

    return output;
};

module.exports = MeasureText;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

var Class = __webpack_require__(3);
var GetObjectValue = __webpack_require__(9);
var MeasureText = __webpack_require__(325);

//  Key: [ Object Key, Default Value ]

var propertyMap = {
    font: [ 'font', '16px Courier' ],
    backgroundColor: [ 'backgroundColor', null ],
    fill: [ 'fill', '#fff' ],
    stroke: [ 'stroke', '#fff' ],
    strokeThickness: [ 'strokeThickness', 0 ],
    shadowOffsetX: [ 'shadow.offsetX', 0 ],
    shadowOffsetY: [ 'shadow.offsetY', 0 ],
    shadowColor: [ 'shadow.color', '#000' ],
    shadowBlur: [ 'shadow.blur', 0 ],
    shadowStroke: [ 'shadow.stroke', false ],
    shadowFill: [ 'shadow.fill', false ],
    align: [ 'align', 'left' ],
    maxLines: [ 'maxLines', 0 ],
    fixedWidth: [ 'fixedWidth', false ],
    fixedHeight: [ 'fixedHeight', false ],
    rtl: [ 'rtl', false ]
};

var TextStyle = new Class({

    initialize:

    function TextStyle (text, style)
    {
        this.parent = text;

        this.font;
        this.backgroundColor;
        this.fill;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;
        this.align;
        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.rtl;

        //  Set to defaults
        this.reset();

        if (style !== undefined)
        {
            for (var key in propertyMap)
            {
                this[key] = GetObjectValue(style, propertyMap[key][0], this[key]);
            }
        }

        this.metrics = MeasureText(this);
    },

    reset: function ()
    {
        for (var key in propertyMap)
        {
            this[key] = propertyMap[key][1];
        }

        return this;
    },

    syncFont: function (canvas, context)
    {
        if (this.rtl)
        {
            canvas.dir = 'rtl';
        }

        context.font = this.font;
        context.textBaseline = 'alphabetic';

        context.fillStyle = this.fill;
        context.strokeStyle = this.stroke;

        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
    },

    syncShadow: function (context, enabled)
    {
        if (enabled)
        {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
        }
        else
        {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
        }
    },

    update: function (recalculateMetrics)
    {
        if (recalculateMetrics)
        {
            this.metrics = MeasureText(this);
        }

        return this.parent.updateText();
    },

    setStyle: function (style)
    {
        for (var key in propertyMap)
        {
            this[key] = GetObjectValue(style, propertyMap[key][0], this[key]);
        }

        return this.update(true);
    },

    setFont: function (font)
    {
        this.font = font;

        return this.update(true);
    },

    setFixedSize: function (width, height)
    {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width)
        {
            this.text.width = width;
        }

        if (height)
        {
            this.text.height = height;
        }

        return this.update(false);
    },

    setBackgroundColor: function (color)
    {
        this.backgroundColor = color;

        return this.update(false);
    },

    setFill: function (color)
    {
        this.fill = color;

        return this.update(false);
    },

    setStroke: function (color, thickness)
    {
        if (color === undefined)
        {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
        }
        else
        {
            if (thickness === undefined) { thickness = this.strokeThickness; }

            this.stroke = color;
            this.strokeThickness = thickness;
        }

        return this.update(true);
    },

    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (color === undefined) { color = '#000'; }
        if (blur === undefined) { blur = 0; }
        if (shadowStroke === undefined) { shadowStroke = false; }
        if (shadowFill === undefined) { shadowFill = false; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = color;
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;

        return this.update(false);
    },

    setShadowOffset: function (x, y)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = x; }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;

        return this.update(false);
    },

    setShadowColor: function (color)
    {
        if (color === undefined) { color = '#000'; }

        this.shadowColor = color;

        return this.update(false);
    },

    setShadowBlur: function (blur)
    {
        if (blur === undefined) { blur = 0; }

        this.shadowBlur = blur;

        return this.update(false);
    },

    setShadowStroke: function (enabled)
    {
        this.shadowStroke = enabled;

        return this.update(false);
    },

    setShadowFill: function (enabled)
    {
        this.shadowFill = enabled;

        return this.update(false);
    },

    setAlign: function (align)
    {
        if (align === undefined) { align = 'left'; }

        this.align = align;

        return this.update(false);
    },

    setMaxLines: function (max)
    {
        if (max === undefined) { max = 0; }

        this.maxLines = max;

        return this.update(false);
    },

    destroy: function ()
    {
        this.parent = undefined;
    }

});

module.exports = TextStyle;


/***/ },
/* 327 */
/***/ function(module, exports) {

var TextCanvasRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    
    var ctx = renderer.currentContext;

    //  Blend Mode
    if (renderer.currentBlendMode !== src.blendMode)
    {
        renderer.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    }

    //  Alpha
    if (renderer.currentAlpha !== src.alpha)
    {
        renderer.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing
    if (renderer.currentScaleMode !== src.scaleMode)
    {
        renderer.currentScaleMode = src.scaleMode;
    }

    var canvas = src.canvas;

    ctx.save();
    ctx.translate(src.x - camera.scrollX, src.y - camera.scrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.translate(canvas.width * (src.flipX ? 1 : 0), canvas.height * (src.flipY ? 1 : 0));
    ctx.scale(src.flipX ? -1 : 1, src.flipY ? -1 : 1);
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, -src.displayOriginX, -src.displayOriginY, canvas.width, canvas.height);
    ctx.restore();
};

module.exports = TextCanvasRenderer;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

var Text = __webpack_require__(108);
var FactoryContainer = __webpack_require__(4);

var TextFactory = {

    KEY: 'text',

    add: function (x, y, text, style)
    {
        return this.state.children.add(new Text(this.state, x, y, text, style));
    },

    make: function (x, y, text, style)
    {
        return new Text(this.state, x, y, text, style);
    }

};

module.exports = FactoryContainer.register(TextFactory);


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    renderCanvas: __webpack_require__(327),
    renderWebGL: __webpack_require__(330)

};


/***/ },
/* 330 */
/***/ function(module, exports) {

var TextWebGLRenderer = function (renderer, src, interpolationPercentage, camera)
{
    if (this.renderMask !== this.renderFlags)
    {
        return;
    }
    
    if (src.dirty)
    {
        var w = src.canvas.width;
        var h = src.canvas.height;
        var resize = !(src.prevWidth < w || src.prevHeight < h);

        src.canvasTexture = renderer.uploadCanvasToGPU(src.canvas, src.canvasTexture, resize);
        src.prevWidth = w;
        src.prevHeight = h;
        src.dirty = false;
    }

    renderer.spriteBatch.addSpriteTexture(src, camera, src.canvasTexture, src.prevWidth, src.prevHeight);
};

module.exports = TextWebGLRenderer;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

var Zone = __webpack_require__(59);
var FactoryContainer = __webpack_require__(4);

var ZoneFactory = {

    KEY: 'zone',

    add: function (x, y, width, height)
    {
        return new Zone(this.state, x, y, width, height);
    },

    make: function (x, y, width, height)
    {
        return new Zone(this.state, x, y, width, height);
    }

};

module.exports = FactoryContainer.register(ZoneFactory);


/***/ },
/* 332 */
/***/ function(module, exports) {

var Area = function (circle)
{
    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;
};

module.exports = Area;


/***/ },
/* 333 */
/***/ function(module, exports) {

var Circumference = function (circle)
{
    return 2 * (Math.PI * circle.radius);
};

module.exports = Circumference;


/***/ },
/* 334 */
/***/ function(module, exports) {

/**
* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
* @method Phaser.Circle.circumferencePoint
* @param {Phaser.Circle} a - The first Circle object.
* @param {number} angle - The angle in radians to return the point from.
* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
* @return {Phaser.Point} The Point object holding the result.
*/
var CircumferencePoint = function (circle, angle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = circle.x + (circle.radius * Math.cos(angle));
    out.y = circle.y + (circle.radius * Math.sin(angle));

    return out;
};

module.exports = CircumferencePoint;


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

var Circle = __webpack_require__(109);

var Clone = function (source)
{
    return new Circle(source.x, source.y, source.radius);
};

module.exports = Clone;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(43);

var ContainsPoint = function (circle, point)
{
    return Contains(circle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(43);

var ContainsRect = function (circle, rect)
{
    return (
        Contains(circle, rect.x, rect.y) &&
        Contains(circle, rect.right, rect.y) &&
        Contains(circle, rect.x, rect.bottom) &&
        Contains(circle, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 338 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.radius);
};

module.exports = CopyFrom;


/***/ },
/* 339 */
/***/ function(module, exports) {

var Equals = function (circle, toCompare)
{
    return (
        circle.x === toCompare.x &&
        circle.y === toCompare.y &&
        circle.radius === toCompare.radius
    );
};

module.exports = Equals;


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var GetBounds = function (circle, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 341 */
/***/ function(module, exports) {

var Offset = function (circle, x, y)
{
    circle.x += x;
    circle.y += y;

    return circle;
};

module.exports = Offset;


/***/ },
/* 342 */
/***/ function(module, exports) {

var OffsetPoint = function (circle, point)
{
    circle.x += point.x;
    circle.y += point.y;

    return circle;
};

module.exports = OffsetPoint;


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Circle

var Circle = __webpack_require__(109);

Circle.Area = __webpack_require__(332);
Circle.Circumference = __webpack_require__(333);
Circle.CircumferencePoint = __webpack_require__(334);
Circle.Clone = __webpack_require__(335);
Circle.Contains = __webpack_require__(43);
Circle.ContainsPoint = __webpack_require__(336);
Circle.ContainsRect = __webpack_require__(337);
Circle.CopyFrom = __webpack_require__(338);
Circle.Equals = __webpack_require__(339);
Circle.GetBounds = __webpack_require__(340);
Circle.Offset = __webpack_require__(341);
Circle.OffsetPoint = __webpack_require__(342);
Circle.Random = __webpack_require__(110);

module.exports = Circle;


/***/ },
/* 344 */
/***/ function(module, exports) {

var Area = function (ellipse)
{
    if (ellipse.isEmpty())
    {
        return 0;
    }

    //  units squared
    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);
};

module.exports = Area;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

var Ellipse = __webpack_require__(111);

var Clone = function (source)
{
    return new Ellipse(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(60);

var ContainsPoint = function (ellipse, point)
{
    return Contains(ellipse, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(60);

var ContainsRect = function (ellipse, rect)
{
    return (
        Contains(ellipse, rect.x, rect.y) &&
        Contains(ellipse, rect.right, rect.y) &&
        Contains(ellipse, rect.x, rect.bottom) &&
        Contains(ellipse, rect.right, rect.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 348 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Ellipse} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 349 */
/***/ function(module, exports) {

var Equals = function (ellipse, toCompare)
{
    return (
        ellipse.x === toCompare.x &&
        ellipse.y === toCompare.y &&
        ellipse.width === toCompare.width &&
        ellipse.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var GetBounds = function (ellipse, out)
{
    if (out === undefined) { out = new Rectangle(); }

    out.x = ellipse.x - ellipse.width;
    out.y = ellipse.y - ellipse.height;
    out.width = ellipse.width;
    out.height = ellipse.height;

    return out;
};

module.exports = GetBounds;


/***/ },
/* 351 */
/***/ function(module, exports) {

var Offset = function (ellipse, x, y)
{
    ellipse.x += x;
    ellipse.y += y;

    return ellipse;
};

module.exports = Offset;


/***/ },
/* 352 */
/***/ function(module, exports) {

var OffsetPoint = function (ellipse, point)
{
    ellipse.x += point.x;
    ellipse.y += point.y;

    return ellipse;
};

module.exports = OffsetPoint;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Ellipse

var Ellipse = __webpack_require__(111);

Ellipse.Area = __webpack_require__(344);
Ellipse.Clone = __webpack_require__(345);
Ellipse.Contains = __webpack_require__(60);
Ellipse.ContainsPoint = __webpack_require__(346);
Ellipse.ContainsRect = __webpack_require__(347);
Ellipse.CopyFrom = __webpack_require__(348);
Ellipse.Equals = __webpack_require__(349);
Ellipse.GetBounds = __webpack_require__(350);
Ellipse.Offset = __webpack_require__(351);
Ellipse.OffsetPoint = __webpack_require__(352);
Ellipse.Random = __webpack_require__(112);

module.exports = Ellipse;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

var GetAngle = __webpack_require__(113);
var FindT = __webpack_require__(61);

/**
* Calculate and return the angle, in radians, of the curves tangent at the given pixel distance along the curves length.
*
* @method Phaser.Hermite#getAngleWithDistance
* @param {number} [distance=0] - The distance along the curve to get the angle from, in pixels.
* @return {number} The angle of the line at the specified distance along the curve. The value is in radians.
*/
var GetAngleWithDistance = function (curve, distance)
{
    if (distance === undefined) { distance = 0; }

    if (distance <= 0)
    {
        return Math.atan2(this._v1y, this._v1x);
    }
    else
    {
        return GetAngle(curve, FindT(curve, distance));
    }
};

module.exports = GetAngleWithDistance;


/***/ },
/* 355 */
/***/ function(module, exports) {

/**
* Get the angle of the curves entry point.
*
* @method Phaser.Hermite#getEntryTangent
* @param {Phaser.Point|Object} point - The Phaser.Point object, or an Object with public `x` and `y` properties, in which the tangent vector values will be stored.
* @return {Phaser.Point} A Point object containing the tangent vector of this Hermite curve.
*/
var GetEntryTangent = function (curve, point)
{
    point.x = curve._v1x;
    point.y = curve._v1y;

    return point;
};

module.exports = GetEntryTangent;


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);
var GetPoint = __webpack_require__(62);
var FindT = __webpack_require__(61);

/**
* Get a point on the curve using the distance, in pixels, along the curve.
*
* @method Phaser.Hermite#getPointWithDistance
* @param {integer} [distance=0] - The distance along the curve to get the point from, given in pixels.
* @param {Phaser.Point|Object} [point] - An optional Phaser.Point, or Object containing public `x` and `y` properties. If given the resulting values will be stored in the Objects `x` and `y` properties. If omitted a new Phaser.Point object is created.
* @return {Phaser.Point} The point on the line at the specified 'distance' along the curve.
*/
var GetPointWithDistance = function (curve, distance, out)
{
    if (distance === undefined) { distance = 0; }
    if (out === undefined) { out = new Point(); }

    if (distance <= 0)
    {
        out.x = this._p1x;
        out.y = this._p1y;
    }
    else
    {
        GetPoint(curve, FindT(curve, distance), out);
    }
    
    return out;
};

module.exports = GetPointWithDistance;


/***/ },
/* 357 */
/***/ function(module, exports) {

/**
* Get the X component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getX
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The X component of a point on the curve based on the `t` (time) value.
*/
var GetX = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ax + t2 * curve._bx + t * curve._v1x + curve._p1x);
};

module.exports = GetX;


/***/ },
/* 358 */
/***/ function(module, exports) {

/**
* Get the Y component of a point on the curve based on the `t` (time) value, which must be between 0 and 1.
*
* @method Phaser.Hermite#getY
* @param {number} [t=0] - The time value along the curve from which to extract a point. This is a value between 0 and 1, where 0 represents the start of the curve and 1 the end.
* @return {number} The Y component of a point on the curve based on the `t` (time) value.
*/
var GetY = function (curve, t)
{
    if (t === undefined)
    {
        t = 0;
    }
    else
    {
        if (t < 0)
        {
            t = 0;
        }

        if (t > 1)
        {
            t = 1;
        }
    }

    var t2 = t * t;
    var t3 = t * t2;

    return (t3 * curve._ay + t2 * curve._by + t * curve._v1y + curve._p1y);
};

module.exports = GetY;


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

/**
* @author       Richard Davey <rich@photonstorm.com>
* @author       Pete Baron <pete@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A data representation of a Hermite Curve (see http://en.wikipedia.org/wiki/Cubic_Hermite_spline)
* 
* A Hermite curve has a start and end point and tangent vectors for both of them.
* The curve will always pass through the two control points and the shape of it is controlled
* by the length and direction of the tangent vectors.  At the control points the curve will
* be facing exactly in the vector direction.
* 
* As these curves change speed (speed = distance between points separated by an equal change in
* 't' value - see Hermite.getPoint) this class attempts to reduce the variation by pre-calculating
* the `accuracy` number of points on the curve. The straight-line distances to these points are stored
* in the private 'points' array, and this information is used by Hermite.findT() to convert a pixel
* distance along the curve into a 'time' value.
* 
* Higher `accuracy` values will result in more even movement, but require more memory for the points
* list. 5 works, but 10 seems to be an ideal value for the length of curves found in most games on
* a desktop screen. If you use very long curves (more than 400 pixels) you may need to increase
* this value further.
*
* @class Phaser.Hermite
* @constructor
* @param {number} p1x - The x coordinate of the start of the curve.
* @param {number} p1y - The y coordinate of the start of the curve.
* @param {number} p2x - The x coordinate of the end of the curve.
* @param {number} p2y - The y coordinate of the end of the curve.
* @param {number} v1x - The x component of the tangent vector for the start of the curve.
* @param {number} v1y - The y component of the tangent vector for the start of the curve.
* @param {number} v2x - The x component of the tangent vector for the end of the curve.
* @param {number} v2y - The y component of the tangent vector for the end of the curve.
* @param {number} [accuracy=10] The amount of points to pre-calculate on the curve.
*/
var Hermite = function (p1x, p1y, p2x, p2y, v1x, v1y, v2x, v2y, accuracy)
{
    if (accuracy === undefined) { accuracy = 10; }

    /**
    * @property {number} _accuracy - The amount of points to pre-calculate on the curve.
    * @private
    */
    this._accuracy = accuracy;

    /**
    * @property {number} _p1x - The x coordinate of the start of the curve.
    * @private
    */
    this._p1x = p1x;

    /**
    * @property {number} _p1y - The y coordinate of the start of the curve.
    * @private
    */
    this._p1y = p1y;

    /**
    * @property {number} _p2x - The x coordinate of the end of the curve.
    * @private
    */
    this._p2x = p2x;

    /**
    * @property {number} _p2y - The y coordinate of the end of the curve.
    * @private
    */
    this._p2y = p2y;

    /**
    * @property {number} _v1x - The x component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1x = v1x;

    /**
    * @property {number} _v1y - The y component of the tangent vector for the start of the curve.
    * @private
    */
    this._v1y = v1y;

    /**
    * @property {number} _v2x - The x component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2x = v2x;

    /**
    * @property {number} _v2y - The y component of the tangent vector for the end of the curve.
    * @private
    */
    this._v2y = v2y;
    
    /**
    * @property {array} _points - A local array of cached points.
    * @private
    */
    this._points = [];

    /**
    * @property {Phaser.Point} _temp1 - A local cached Point object.
    * @private
    */
    this._temp1 = new Point();

    /**
    * @property {Phaser.Point} _temp2 - A local cached Point object.
    * @private
    */
    this._temp2 = new Point();

    this.recalculate();
};

Hermite.prototype.constructor = Hermite;

Hermite.prototype = {

    /**
    * Performs the curve calculations.
    *
    * This is called automatically if you change any of the curves public properties, such as `Hermite.p1x` or `Hermite.v2y`.
    *
    * If you adjust any of the internal private values, then call this to update the points.
    *
    * @method Phaser.Hermite#recalculate
    * @return {Phaser.Hermite} This object.
    */
    recalculate: function ()
    {
        this._ax = (2 * this._p1x - 2 * this._p2x + this._v1x + this._v2x);
        this._ay = (2 * this._p1y - 2 * this._p2y + this._v1y + this._v2y);
        this._bx = (-3 * this._p1x + 3 * this._p2x - 2 * this._v1x - this._v2x);
        this._by = (-3 * this._p1y + 3 * this._p2y - 2 * this._v1y - this._v2y);

        this.length = this.calculateEvenPoints();

        return this;
    },

    /**
    * Calculate a number of points along the curve, based on `Hermite.accuracy`, and stores them in the private `_points` array.
    *
    * @method Phaser.Hermite#calculateEvenPoints
    * @return {number} The total length of the curve approximated as straight line distances between the points.
    */
    calculateEvenPoints: function ()
    {
        var totalLength = 0;

        this._temp1.setTo(0, 0);                    //  pnt
        this._temp2.setTo(this._p1x, this._p1y);    //  lastPnt

        this._points[0] = 0;

        for (var i = 1; i <= this._accuracy; i++)
        {
            this.getPoint(i / this._accuracy, this._temp1);

            totalLength += this._temp1.distance(this._temp2);

            this._points[i] = totalLength;
            this._temp2.copyFrom(this._temp1);
        }

        return totalLength;
    }

};

Object.defineProperties(Hermite.prototype, {

    /**
    * @name Phaser.Hermite#accuracy
    * @property {number} accuracy - The amount of points to pre-calculate on the curve.
    */
    accuracy: {

        enumerable: true,

        get: function ()
        {
            return this._accuracy;
        },

        set: function (value)
        {
            if (value !== this._accuracy)
            {
                this._accuracy = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1x
    * @property {number} p1x - The x coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1x: {

        enumerable: true,

        get: function ()
        {
            return this._p1x;
        },

        set: function (value)
        {
            if (value !== this._p1x)
            {
                this._p1x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p1y
    * @property {number} p1y - The y coordinate of the start of the curve. Setting this value will recalculate the curve.
    */
    p1y: {

        enumerable: true,

        get: function ()
        {
            return this._p1y;
        },

        set: function (value)
        {
            if (value !== this._p1y)
            {
                this._p1y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p2x
    * @property {number} p2x - The x coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2x: {

        enumerable: true,

        get: function ()
        {
            return this._p2x;
        },

        set: function (value)
        {
            if (value !== this._p2x)
            {
                this._p2x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#p2y
    * @property {number} p2y - The y coordinate of the end of the curve. Setting this value will recalculate the curve.
    */
    p2y: {

        enumerable: true,

        get: function ()
        {
            return this._p2y;
        },

        set: function (value)
        {
            if (value !== this._p2y)
            {
                this._p2y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v1x
    * @property {number} v1x - The x component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1x: {

        enumerable: true,

        get: function ()
        {
            return this._v1x;
        },

        set: function (value)
        {
            if (value !== this._v1x)
            {
                this._v1x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v1y
    * @property {number} v1y - The y component of the tangent vector for the start of the curve. Setting this value will recalculate the curve.
    */
    v1y: {

        enumerable: true,

        get: function ()
        {
            return this._v1y;
        },

        set: function (value)
        {
            if (value !== this._v1y)
            {
                this._v1y = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v2x
    * @property {number} v2x - The x component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2x: {

        enumerable: true,

        get: function ()
        {
            return this._v2x;
        },

        set: function (value)
        {
            if (value !== this._v2x)
            {
                this._v2x = value;
                this.recalculate();
            }
        }

    },

    /**
    * @name Phaser.Hermite#v2y
    * @property {number} v2y - The y component of the tangent vector for the end of the curve. Setting this value will recalculate the curve.
    */
    v2y: {

        enumerable: true,

        get: function ()
        {
            return this._v2y;
        },

        set: function (value)
        {
            if (value !== this._v2y)
            {
                this._v2y = value;
                this.recalculate();
            }
        }

    }

});

module.exports = Hermite;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Hermite

var Hermite = __webpack_require__(359);

Hermite.FindT = __webpack_require__(61);
Hermite.GetAngle = __webpack_require__(113);
Hermite.GetAngleWithDistance = __webpack_require__(354);
Hermite.GetEntryTangent = __webpack_require__(355);
Hermite.GetPoint = __webpack_require__(62);
Hermite.GetPointWithDistance = __webpack_require__(356);
Hermite.GetX = __webpack_require__(357);
Hermite.GetY = __webpack_require__(358);

module.exports = Hermite;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

var DistanceBetween = __webpack_require__(75);

var CircleToCircle = function (circleA, circleB)
{
    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));
};

module.exports = CircleToCircle;


/***/ },
/* 362 */
/***/ function(module, exports) {

var CircleToRectangle = function (circle, rect)
{
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;

    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var xDist = halfWidth + circle.radius;

    if (cx <= halfWidth || cx > xDist)
    {
        return false;
    }

    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var yDist = halfHeight + circle.radius;

    if (cy <= halfHeight || cy > yDist)
    {
        return false;
    }

    var xCornerDist = cx - halfWidth;
    var yCornerDist = cy - halfHeight;
    var xCornerDistSq = xCornerDist * xCornerDist;
    var yCornerDistSq = yCornerDist * yCornerDist;
    var maxCornerDistSq = circle.radius * circle.radius;

    return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);
};

module.exports = CircleToRectangle;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);
var RectangleToRectangle = __webpack_require__(116);

var GetRectangleIntersection = function (rectA, rectB, output)
{
    if (output === undefined) { output = new Rectangle(); }

    if (RectangleToRectangle(rectA, rectB))
    {
        output.x = Math.max(rectA.x, rectB.x);
        output.y = Math.max(rectA.y, rectB.y);
        output.width = Math.min(rectA.right, rectB.right) - output.x;
        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }

    return output;
};

module.exports = GetRectangleIntersection;


/***/ },
/* 364 */
/***/ function(module, exports) {

/**
* Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
* object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
*
* An intersection is considered valid if:
*
* The line starts within, or ends within, the Rectangle.
* The line segment intersects one of the 4 rectangle edges.
*
* The for the purposes of this function rectangles are considered 'solid'.
*
* @method Phaser.Line.intersectsRectangle
* @param {Phaser.Line} line - The line to check for intersection with.
* @param {Phaser.Rectangle|object} rect - The rectangle, or rectangle-like object, to check for intersection with.
* @return {boolean} True if the line intersects with the rectangle edges, or starts or ends within the rectangle.
*/
var LineToRectangle = function (line, rect)
{
    var x1 = line.x1;
    var y1 = line.y2;

    var x2 = line.x2;
    var y2 = line.y2;

    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;

    var t = 0;

    //  If the start or end of the line is inside the rect then we assume
    //  collision, as rects are solid for our use-case.

    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||
        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))
    {
        return true;
    }

    if (x1 < bx1 && x2 >= bx1)
    {
        //  Left edge
        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);

        if (t > by1 && t <= by2)
        {
            return true;
        }
    }
    else if (x1 > bx2 && x2 <= bx2)
    {
        //  Right edge
        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);

        if (t >= by1 && t <= by2)
        {
            return true;
        }
    }

    if (y1 < by1 && y2 >= by1)
    {
        //  Top edge
        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }
    else if (y1 > by2 && y2 <= by2)
    {
        //  Bottom edge
        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);

        if (t >= bx1 && t <= bx2)
        {
            return true;
        }
    }

    return false;
};

module.exports = LineToRectangle;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

var PointToLine = __webpack_require__(115);

var PointToLineSegment = function (point, line)
{
    if (!PointToLine(point, line))
    {
        return false;
    }

    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);

    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));
};

module.exports = PointToLineSegment;


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(44);
var Contains = __webpack_require__(66);
var ContainsArray = __webpack_require__(68);
var Decompose = __webpack_require__(126);

var RectangleToTriangle = function (rect, triangle)
{
    //  First the cheapest ones:

    if (
        triangle.left > rect.right ||
        triangle.right < rect.left ||
        triangle.top > rect.bottom ||
        triangle.bottom < rect.top)
    {
        return false;
    }

    var triA = triangle.getLineA();
    var triB = triangle.getLineB();
    var triC = triangle.getLineC();

    //  Are any of the triangle points within the rectangle?

    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2))
    {
        return true;
    }

    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2))
    {
        return true;
    }

    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2))
    {
        return true;
    }

    //  Cheap tests over, now to see if any of the lines intersect ...

    var rectA = rect.getLineA();
    var rectB = rect.getLineB();
    var rectC = rect.getLineC();
    var rectD = rect.getLineD();

    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD))
    {
        return true;
    }

    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD))
    {
        return true;
    }

    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD))
    {
        return true;
    }

    //  None of the lines intersect, so are any rectangle points within the triangle?

    var points = Decompose(rect);
    var within = ContainsArray(triangle, points, true);

    return (within.length > 0);
};

module.exports = RectangleToTriangle;


/***/ },
/* 367 */
/***/ function(module, exports) {

var RectangleToValues = function (rect, left, right, top, bottom, tolerance)
{
    if (tolerance === undefined) { tolerance = 0; }

    return !(
        left > rect.right + tolerance ||
        right < rect.left - tolerance ||
        top > rect.bottom + tolerance ||
        bottom < rect.top - tolerance
    );
};

module.exports = RectangleToValues;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {


var LineToCircle = __webpack_require__(114);
var Contains = __webpack_require__(45);

var TriangleToCircle = function (triangle, circle)
{
     //  First the cheapest ones:

    if (
        triangle.left > circle.right ||
        triangle.right < circle.left ||
        triangle.top > circle.bottom ||
        triangle.bottom < circle.top)
    {
        return false;
    }

    if (Contains(triangle, circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineA(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineB(), circle))
    {
        return true;
    }

    if (LineToCircle(triangle.getLineC(), circle))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToCircle;


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(44);
var Contains = __webpack_require__(45);

var TriangleToLine = function (triangle, line)
{
    //  If the Triangle contains either the start or end point of the line, it intersects
    if (Contains(triangle, line.getPointA()) || Contains(triangle, line.getPointB()))
    {
        return true;
    }

    //  Now check the line against each line of the Triangle
    if (LineToLine(triangle.getLineA(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineB(), line))
    {
        return true;
    }

    if (LineToLine(triangle.getLineC(), line))
    {
        return true;
    }

    return false;
};

module.exports = TriangleToLine;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {


var LineToLine = __webpack_require__(44);
var ContainsArray = __webpack_require__(68);
var Decompose = __webpack_require__(131);

var TriangleToTriangle = function (triangleA, triangleB)
{
    //  First the cheapest ones:

    if (
        triangleA.left > triangleB.right ||
        triangleA.right < triangleB.left ||
        triangleA.top > triangleB.bottom ||
        triangleA.bottom < triangleB.top)
    {
        return false;
    }

    var lineAA = triangleA.getLineA();
    var lineAB = triangleA.getLineB();
    var lineAC = triangleA.getLineC();

    var lineBA = triangleB.getLineA();
    var lineBB = triangleB.getLineB();
    var lineBC = triangleB.getLineC();

    //  Now check the lines against each line of TriangleB
    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))
    {
        return true;
    }

    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))
    {
        return true;
    }

    //  Nope, so check to see if any of the points of triangleA are within triangleB

    var points = Decompose(triangleA);
    var within = ContainsArray(triangleB, points, true);

    if (within.length > 0)
    {
        return true;
    }

    //  Finally check to see if any of the points of triangleB are within triangleA

    points = Decompose(triangleB);
    within = ContainsArray(triangleA, points, true);

    if (within.length > 0)
    {
        return true;
    }

    return false;
};

module.exports = TriangleToTriangle;


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Intersects

module.exports = {

    CircleToCircle: __webpack_require__(361),
    CircleToRectangle: __webpack_require__(362),
    GetRectangleIntersection: __webpack_require__(363),
    LineToCircle: __webpack_require__(114),
    LineToLine: __webpack_require__(44),
    LineToRectangle: __webpack_require__(364),
    PointToLine: __webpack_require__(115),
    PointToLineSegment: __webpack_require__(365),
    RectangleToRectangle: __webpack_require__(116),
    RectangleToTriangle: __webpack_require__(366),
    RectangleToValues: __webpack_require__(367),
    TriangleToCircle: __webpack_require__(368),
    TriangleToLine: __webpack_require__(369),
    TriangleToTriangle: __webpack_require__(370)

};


/***/ },
/* 372 */
/***/ function(module, exports) {


var CenterOn = function (line, x, y)
{
    var tx = x - ((line.x1 + line.x2) / 2);
    var ty = y - ((line.y1 + line.y2) / 2);

    line.x1 += tx;
    line.y1 += ty;

    line.x2 += tx;
    line.y2 += ty;

    return line;
};

module.exports = CenterOn;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

var Line = __webpack_require__(117);

var Clone = function (source)
{
    return new Line(source.x1, source.y1, source.x2, source.y2);
};

module.exports = Clone;


/***/ },
/* 374 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Line.
* @method Phaser.Line#copyFrom
* @param {any} source - The object to copy from.
* @return {Line} This Line object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
};

module.exports = CopyFrom;


/***/ },
/* 375 */
/***/ function(module, exports) {

var Equals = function (line, toCompare)
{
    return (
        line.x1 === toCompare.x1 &&
        line.y1 === toCompare.y1 &&
        line.x2 === toCompare.x2 &&
        line.y2 === toCompare.y2
    );
};

module.exports = Equals;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var GetMidPoint = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;

    return out;
};

module.exports = GetMidPoint;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);
var Angle = __webpack_require__(31);
var Point = __webpack_require__(1);

var GetNormal = function (line, out)
{
    if (out === undefined) { out = new Point(); }

    var a = Angle(line) - MATH_CONST.TAU;

    out.x = Math.cos(a);
    out.y = Math.sin(a);

    return out;
};

module.exports = GetNormal;


/***/ },
/* 378 */
/***/ function(module, exports) {

var Height = function (line)
{
    return Math.abs(line.y1 - line.y2);
};

module.exports = Height;


/***/ },
/* 379 */
/***/ function(module, exports) {

var Length = function (line)
{
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
};

module.exports = Length;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);
var Angle = __webpack_require__(31);

var NormalX = function (line)
{
    return Math.cos(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalX;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);
var Angle = __webpack_require__(31);

var NormalY = function (line)
{
    return Math.sin(Angle(line) - MATH_CONST.TAU);
};

module.exports = NormalY;


/***/ },
/* 382 */
/***/ function(module, exports) {

var Offset = function (line, x, y)
{
    line.x1 += x;
    line.y1 += y;

    line.x2 += x;
    line.y2 += y;

    return line;
};

module.exports = Offset;


/***/ },
/* 383 */
/***/ function(module, exports) {

var PerpSlope = function (line)
{
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
};

module.exports = PerpSlope;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

var Angle = __webpack_require__(31);
var NormalAngle = __webpack_require__(118);

/**
* Returns the reflected angle between two lines.
* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.
*
* @method Phaser.Line.reflect
* @param {Phaser.Line} a - The base line.
* @param {Phaser.Line} b - The line to be reflected from the base line.
* @return {number} The reflected angle in radians.
*/
var ReflectAngle = function (lineA, lineB)
{
    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));
};

module.exports = ReflectAngle;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(64);

var Rotate = function (line, angle)
{
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;

    return RotateAroundXY(line, x, y, angle);
};

module.exports = Rotate;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(64);

var RotateAroundPoint = function (line, point, angle)
{
    return RotateAroundXY(line, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 387 */
/***/ function(module, exports) {

var SetToAngle = function (line, x, y, angle, length)
{
    line.x1 = x;
    line.y1 = y;

    line.x2 = x + (Math.cos(angle) * length);
    line.y2 = y + (Math.sin(angle) * length);

    return line;
};

module.exports = SetToAngle;


/***/ },
/* 388 */
/***/ function(module, exports) {

var Slope = function (line)
{
    return (line.y2 - line.y1) / (line.x2 - line.x1);
};

module.exports = Slope;


/***/ },
/* 389 */
/***/ function(module, exports) {

var Width = function (line)
{
    return Math.abs(line.x1 - line.x2);
};

module.exports = Width;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Line

var Line = __webpack_require__(117);

Line.Angle = __webpack_require__(31);
Line.CenterOn = __webpack_require__(372);
Line.Clone = __webpack_require__(373);
Line.CopyFrom = __webpack_require__(374);
Line.Equals = __webpack_require__(375);
Line.GetMidPoint = __webpack_require__(376);
Line.GetNormal = __webpack_require__(377);
Line.GetPointsOnLine = __webpack_require__(63);
Line.Height = __webpack_require__(378);
Line.Length = __webpack_require__(379);
Line.NormalAngle = __webpack_require__(118);
Line.NormalX = __webpack_require__(380);
Line.NormalY = __webpack_require__(381);
Line.Offset = __webpack_require__(382);
Line.PerpSlope = __webpack_require__(383);
Line.Random = __webpack_require__(119);
Line.ReflectAngle = __webpack_require__(384);
Line.Rotate = __webpack_require__(385);
Line.RotateAroundPoint = __webpack_require__(386);
Line.RotateAroundXY = __webpack_require__(64);
Line.SetToAngle = __webpack_require__(387);
Line.Slope = __webpack_require__(388);
Line.Width = __webpack_require__(389);

module.exports = Line;


/***/ },
/* 391 */
/***/ function(module, exports) {

var Add = function (point, x, y)
{
    point.x += x;
    point.y += y;

    return point;
};

module.exports = Add;


/***/ },
/* 392 */
/***/ function(module, exports) {

var Ceil = function (point)
{
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
};

module.exports = Ceil;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Clone = function (source)
{
    return new Point(source.x, source.y);
};

module.exports = Clone;


/***/ },
/* 394 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y);
};

module.exports = CopyFrom;


/***/ },
/* 395 */
/***/ function(module, exports) {

var Cross = function (pointA, pointB)
{
    return ((pointA.x * pointB.y) - (pointA.y * pointB.x));
};

module.exports = Cross;


/***/ },
/* 396 */
/***/ function(module, exports) {

var Divide = function (point, x, y)
{
    point.x /= x;
    point.y /= y;

    return point;
};

module.exports = Divide;


/***/ },
/* 397 */
/***/ function(module, exports) {

var Equals = function (point, toCompare)
{
    return (point.x === toCompare.x && point.y === toCompare.y);
};

module.exports = Equals;


/***/ },
/* 398 */
/***/ function(module, exports) {

var Floor = function (point)
{
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
};

module.exports = Floor;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var GetCentroid = function (points, out)
{
    if (out === undefined) { out = new Point(); }

    if (!Array.isArray(points))
    {
        throw new Error('GetCentroid points argument must be an array');
    }

    var len = points.length;

    if (len < 1)
    {
        throw new Error('GetCentroid points array must not be empty');
    }
    else if (len === 1)
    {
        out.x = points[0].x;
        out.y = points[0].y;
    }
    else
    {
        for (var i = 0; i < len; i++)
        {
            out.x += points[i].x;
            out.y += points[i].y;
        }

        out.x /= len;
        out.y /= len;
    }

    return out;
};

module.exports = GetCentroid;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Interpolate = function (pointA, pointB, t, out)
{
    if (t === undefined) { t = 0; }
    if (out === undefined) { out = new Point(); }

    out.x = pointA.x + ((pointB.x - pointA.x) * t);
    out.y = pointA.y + ((pointB.y - pointA.y) * t);

    return out;
};

module.exports = Interpolate;


/***/ },
/* 401 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var Invert = function (point)
{
    return point.setTo(point.y, point.x);
};

module.exports = Invert;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

var Point = __webpack_require__(1);

var Negative = function (point, out)
{
    if (out === undefined) { out = new Point(); }

    return out.setTo(-point.x, -point.y);
};

module.exports = Negative;


/***/ },
/* 403 */
/***/ function(module, exports) {

var NormalizeRightHand = function (point)
{
    return point.setTo(point.y * -1, point.x);
};

module.exports = NormalizeRightHand;


/***/ },
/* 404 */
/***/ function(module, exports) {

var Perp = function (point)
{
    return point.setTo(-point.y, point.x);
};

module.exports = Perp;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(65);
var Point = __webpack_require__(1);
var GetMagnitudeSq = __webpack_require__(121);

var Project = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB) / GetMagnitudeSq(pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = Project;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

var Dot = __webpack_require__(65);
var Point = __webpack_require__(1);

var ProjectUnit = function (pointA, pointB, out)
{
    if (out === undefined) { out = new Point(); }

    var amt = Dot(pointA, pointB);

    if (amt !== 0)
    {
        out.x = amt * pointB.x;
        out.y = amt * pointB.y;
    }

    return out;
};

module.exports = ProjectUnit;


/***/ },
/* 407 */
/***/ function(module, exports) {

var RPerp = function (point)
{
    return point.setTo(point.y, -point.x);
};

module.exports = RPerp;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(123);
var Multiply = __webpack_require__(122);

var SetMagnitude = function (point, magnitude)
{
    Normalize(point);

    return Multiply(point, magnitude, magnitude);
};

module.exports = SetMagnitude;


/***/ },
/* 409 */
/***/ function(module, exports) {

var Subtract = function (point, x, y)
{
    point.x -= x;
    point.y -= y;

    return point;
};

module.exports = Subtract;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Point

var Point = __webpack_require__(1);

Point.Add = __webpack_require__(391);
Point.Ceil = __webpack_require__(392);
Point.Clone = __webpack_require__(393);
Point.CopyFrom = __webpack_require__(394);
Point.Cross = __webpack_require__(395);
Point.Divide = __webpack_require__(396);
Point.Dot = __webpack_require__(65);
Point.Equals = __webpack_require__(397);
Point.Floor = __webpack_require__(398);
Point.GetCentroid = __webpack_require__(399);
Point.GetMagnitude = __webpack_require__(120);
Point.GetMagnitudeSq = __webpack_require__(121);
Point.Interpolate = __webpack_require__(400);
Point.Invert = __webpack_require__(401);
Point.Multiply = __webpack_require__(122);
Point.Negative = __webpack_require__(402);
Point.Normalize = __webpack_require__(123);
Point.NormalizeRightHand = __webpack_require__(403);
Point.Perp = __webpack_require__(404);
Point.Project = __webpack_require__(405);
Point.ProjectUnit = __webpack_require__(406);
Point.RPerp = __webpack_require__(407);
Point.SetMagnitude = __webpack_require__(408);
Point.Subtract = __webpack_require__(409);

module.exports = Point;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

var Polygon = __webpack_require__(125);

var Clone = function (polygon)
{
    return new Polygon(polygon.points);
};

module.exports = Clone;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(124);

/**
* Checks whether the x and y coordinates are contained within this polygon.
*
* @method Phaser.Polygon#contains
* @param {number} x - The X value of the coordinate to test.
* @param {number} y - The Y value of the coordinate to test.
* @return {boolean} True if the coordinates are within this polygon, otherwise false.
*/
var ContainsPoint = function (polygon, point)
{
    return Contains(polygon, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 413 */
/***/ function(module, exports) {

"use strict";
//  2.1.1 (Mar 17, 2016)

/*
ISC License

Copyright (c) 2016, Mapbox

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
 */

'use strict';

module.exports = earcut;

/*
vertices is a flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...].
holes is an array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11).
dimensions is the number of coordinates per vertice in the input array (2 by default).
Each group of three vertice indices in the resulting array forms a triangle.
 */

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

/***/ },
/* 414 */
/***/ function(module, exports) {


var GetAABB = function (polygon)
{
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;

    for (var i = 0; i < polygon.points.length; i++)
    {
        p = polygon.points[i];

        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    }

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
};

module.exports = GetAABB;


/***/ },
/* 415 */
/***/ function(module, exports) {

/**
 * Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
 *
 * @method Phaser.Polygon#toNumberArray
 * @param {array} [output] - The array to append the points to. If not specified a new array will be created.
 * @return {array} The flattened array.
 */
var GetNumberArray = function (polygon, output)
{
    if (output === undefined) { output = []; }

    for (var i = 0; i < polygon.points.length; i++)
    {
        output.push(polygon.points[i].x);
        output.push(polygon.points[i].y);
    }

    return output;
};

module.exports = GetNumberArray;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Polygon

var Polygon = __webpack_require__(125);

Polygon.Clone = __webpack_require__(411);
Polygon.Contains = __webpack_require__(124);
Polygon.ContainsPoint = __webpack_require__(412);
Polygon.GetAABB = __webpack_require__(414);
Polygon.GetNumberArray = __webpack_require__(415);

module.exports = Polygon;


/***/ },
/* 417 */
/***/ function(module, exports) {

var Area = function (rect)
{
    return rect.width * rect.height;
};

module.exports = Area;


/***/ },
/* 418 */
/***/ function(module, exports) {

var Ceil = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);

    return rect;
};

module.exports = Ceil;


/***/ },
/* 419 */
/***/ function(module, exports) {

var CeilAll = function (rect)
{
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);

    return rect;
};

module.exports = CeilAll;


/***/ },
/* 420 */
/***/ function(module, exports) {

/**
* Centers this Rectangle so that the center coordinates match the given x and y values.
*
* @method Phaser.Rectangle#centerOn
* @param {number} x - The x coordinate to place the center of the Rectangle at.
* @param {number} y - The y coordinate to place the center of the Rectangle at.
* @return {Phaser.Rectangle} This Rectangle object
*/
var CenterOn = function (rect, x, y)
{
    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = CenterOn;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var Clone = function (source)
{
    return new Rectangle(source.x, source.y, source.width, source.height);
};

module.exports = Clone;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(66);

var ContainsPoint = function (rect, point)
{
    return Contains(rect, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 423 */
/***/ function(module, exports) {

//  Checks if rectB is fully contained within rectA

var ContainsRect = function (rectA, rectB)
{
    //  Volume check (if rectB volume > rectA then rectA cannot contain it)
    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))
    {
        return false;
    }

    return (
        (rectB.x > rectA.x && rectB.x < rectA.right) &&
        (rectB.right > rectA.x && rectB.right < rectA.right) &&
        (rectB.y > rectA.y && rectB.y < rectA.bottom) && 
        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)
    );
};

module.exports = ContainsRect;


/***/ },
/* 424 */
/***/ function(module, exports) {

/**
* Copies the x, y and diameter properties from any given object to this Circle.
* @method Phaser.Circle#copyFrom
* @param {any} source - The object to copy from.
* @return {Circle} This Circle object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x, source.y, source.width, source.height);
};

module.exports = CopyFrom;


/***/ },
/* 425 */
/***/ function(module, exports) {

var Equals = function (rect, toCompare)
{
    return (
        rect.x === toCompare.x &&
        rect.y === toCompare.y &&
        rect.width === toCompare.width &&
        rect.height === toCompare.height
    );
};

module.exports = Equals;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(67);

//  Fits the target rectangle into the source rectangle.
//  Preserves aspect ratio.
//  Scales and centers the target rectangle to the source rectangle

var FitInside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio < GetAspectRatio(source))
    {
        //  Taller than Wide
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Wider than Tall
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - (target.width / 2),
        (source.bottom / 2) - (target.height / 2)
    );
};

module.exports = FitInside;


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

var GetAspectRatio = __webpack_require__(67);

//  Fits the target rectangle around the source rectangle.
//  Preserves aspect ration.
//  Scales and centers the target rectangle to the source rectangle

var FitOutside = function (target, source)
{
    var ratio = GetAspectRatio(target);

    if (ratio > GetAspectRatio(source))
    {
        //  Wider than Tall
        target.setSize(source.height * ratio, source.height);
    }
    else
    {
        //  Taller than Wide
        target.setSize(source.width, source.width * ratio);
    }

    return target.setPosition(
        (source.right / 2) - target.width / 2,
        (source.bottom / 2) - target.height / 2
    );
};

module.exports = FitOutside;


/***/ },
/* 428 */
/***/ function(module, exports) {

var Floor = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);

    return rect;
};

module.exports = Floor;


/***/ },
/* 429 */
/***/ function(module, exports) {

var FloorAll = function (rect)
{
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);

    return rect;
};

module.exports = FloorAll;


/***/ },
/* 430 */
/***/ function(module, exports) {

//  The center of the Rectangle object, expressed as a Point object 

var GetCenter = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.right / 2;
    out.y = rect.bottom / 2;

    return out;
};

module.exports = GetCenter;


/***/ },
/* 431 */
/***/ function(module, exports) {

//  The size of the Rectangle object, expressed as a Point object 
//  with the values of the width and height properties.

var GetSize = function (rect, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    out.x = rect.width;
    out.y = rect.height;

    return out;
};

module.exports = GetSize;


/***/ },
/* 432 */
/***/ function(module, exports) {

//  Increases the size of the Rectangle object by the specified amounts.
//  The center point of the Rectangle object stays the same, and its size increases 
//  to the left and right by the x value, and to the top and the bottom by the y value.

var Inflate = function (rect, x, y)
{
    //  Get the current center
    var cx = rect.x + (rect.width / 2);
    var cy = rect.y + (rect.height / 2);

    //  Inflate
    rect.width = 2 * x;
    rect.height = 2 * y;

    rect.x = x - (rect.width / 2);
    rect.y = y - (rect.height / 2);

    return rect;
};

module.exports = Inflate;


/***/ },
/* 433 */
/***/ function(module, exports) {

//  Merges the target Rectangle with a list of points.
//  The points is an array of objects with public x/y properties.

var MergePoints = function (target, points)
{
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;

    for (var i = 0; i < points.length; i++)
    {
        minX = Math.min(minX, points[i].x);
        maxX = Math.max(maxX, points[i].x);
        minY = Math.min(minY, points[i].y);
        maxY = Math.max(maxY, points[i].y);
    }

    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;

    return target;
};

module.exports = MergePoints;


/***/ },
/* 434 */
/***/ function(module, exports) {

//  Merges source rectangle into target rectangle and returns target
//  Neither rect should have negative widths or heights

var MergeRect = function (target, source)
{
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeRect;


/***/ },
/* 435 */
/***/ function(module, exports) {


var MergeXY = function (target, x, y)
{
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);

    target.x = minX;
    target.width = maxX - minX;

    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);

    target.y = minY;
    target.height = maxY - minY;

    return target;
};

module.exports = MergeXY;


/***/ },
/* 436 */
/***/ function(module, exports) {

var Offset = function (rect, x, y)
{
    rect.x += x;
    rect.y += y;

    return rect;
};

module.exports = Offset;


/***/ },
/* 437 */
/***/ function(module, exports) {

var OffsetPoint = function (rect, point)
{
    rect.x += point.x;
    rect.y += point.y;

    return rect;
};

module.exports = OffsetPoint;


/***/ },
/* 438 */
/***/ function(module, exports) {

var Overlaps = function (rectA, rectB)
{
    return (
        rectA.x < rectB.right && 
        rectA.right > rectB.x && 
        rectA.y < rectB.bottom && 
        rectA.bottom > rectB.y
    );
};

module.exports = Overlaps;


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);

//  deg = degrees (0-360)

var PerimeterPoint = function (rect, deg, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var theta = deg * MATH_CONST.DEG_TO_RAD;

    while (theta < -Math.PI)
    {
        theta += MATH_CONST.PI2;
    }

    while (theta > Math.PI)
    {
        theta -= MATH_CONST.PI2;
    }

    var rectAtan = Math.atan2(rect.height, rect.width);
    var tanTheta = Math.tan(theta);
    var thetaBounds = Math.PI - rectAtan;
    var region;
    var xFactor = 1;
    var yFactor = 1;

    if (theta > -rectAtan && theta <= rectAtan)
    {
        region = 1;
        yFactor = -1;
    }
    else if (theta > rectAtan && theta <= thetaBounds)
    {
        region = 2;
        yFactor = -1;
    }
    else if (theta > thetaBounds || theta <= -thetaBounds)
    {
        region = 3;
        xFactor = -1;
    }
    else
    {
        region = 4;
        xFactor = -1;
    }

    out.x = rect.x + (rect.width / 2);
    out.y = rect.y + (rect.height / 2);

    if (region === 1 || region === 3)
    {
        out.x += xFactor * (rect.width / 2);                                     // "Z0"
        out.y += yFactor * (rect.width / 2) * tanTheta;
    }
    else
    {
        out.x += xFactor * (rect.height / (2 * tanTheta));                        // "Z1"
        out.y += yFactor * (rect.height / 2);
    }

    return out;
};

module.exports = PerimeterPoint;


/***/ },
/* 440 */
/***/ function(module, exports) {

/**
* Scales the width and height of this Rectangle by the given amounts.
* 
* @method Phaser.Rectangle#scale
* @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
* @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
* @return {Phaser.Rectangle} This Rectangle object
*/
var Scale = function (rect, x, y)
{
    if (y === undefined) { y = x; }

    rect.width *= x;
    rect.height *= y;

    return rect;
};

module.exports = Scale;


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(27);

var Union = function (rectA, rectB, output)
{
    if (output === undefined) { output = Rectangle(); }

    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);

    return output.set(
        x,
        y,
        Math.max(rectA.right, rectB.right) - x,
        Math.max(rectA.bottom, rectB.bottom) - y
    );
    
};

module.exports = Union;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Rectangle

var Rectangle = __webpack_require__(27);

Rectangle.Area = __webpack_require__(417);
Rectangle.Ceil = __webpack_require__(418);
Rectangle.CeilAll = __webpack_require__(419);
Rectangle.CenterOn = __webpack_require__(420);
Rectangle.Clone = __webpack_require__(421);
Rectangle.Contains = __webpack_require__(66);
Rectangle.ContainsPoint = __webpack_require__(422);
Rectangle.ContainsRect = __webpack_require__(423);
Rectangle.CopyFrom = __webpack_require__(424);
Rectangle.Decompose = __webpack_require__(126);
Rectangle.Equals = __webpack_require__(425);
Rectangle.FitInside = __webpack_require__(426);
Rectangle.FitOutside = __webpack_require__(427);
Rectangle.Floor = __webpack_require__(428);
Rectangle.FloorAll = __webpack_require__(429);
Rectangle.GetAspectRatio = __webpack_require__(67);
Rectangle.GetCenter = __webpack_require__(430);
Rectangle.GetSize = __webpack_require__(431);
Rectangle.Inflate = __webpack_require__(432);
Rectangle.MarchingAnts = __webpack_require__(127);
Rectangle.MergePoints = __webpack_require__(433);
Rectangle.MergeRect = __webpack_require__(434);
Rectangle.MergeXY = __webpack_require__(435);
Rectangle.Offset = __webpack_require__(436);
Rectangle.OffsetPoint = __webpack_require__(437);
Rectangle.Overlaps = __webpack_require__(438);
Rectangle.Perimeter = __webpack_require__(128);
Rectangle.PerimeterPoint = __webpack_require__(439);
Rectangle.Random = __webpack_require__(129);
Rectangle.Scale = __webpack_require__(440);
Rectangle.Union = __webpack_require__(441);

module.exports = Rectangle;


/***/ },
/* 443 */
/***/ function(module, exports) {

// The 2D area of a triangle. The area value is always non-negative.

var Area = function (triangle)
{
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    var x2 = triangle.x2;
    var y2 = triangle.y2;

    var x3 = triangle.x3;
    var y3 = triangle.y3;

    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
};

module.exports = Area;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(38);

// Builds an equilateral triangle.
// In the equilateral triangle, all the sides are the same length (congruent)
// and all the angles are the same size (congruent).

//  The x/y specifies the top-middle of the triangle (x1/y1) and length
//  is the length of each side

var BuildEquilateral = function (x, y, length)
{
    var height = length * (Math.sqrt(3) / 2);

    var x1 = x;
    var y1 = y;

    var x2 = x + (length / 2);
    var y2 = y + height;

    var x3 = x - (length / 2);
    var y3 = y + height;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildEquilateral;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

var EarCut = __webpack_require__(413);
var Triangle = __webpack_require__(38);

var BuildFromPolygon = function (data, holes, scaleX, scaleY, out)
{
    if (holes === undefined) { holes = null; }
    if (scaleX === undefined) { scaleX = 1; }
    if (scaleY === undefined) { scaleY = 1; }
    if (out === undefined) { out = []; }

    var tris = EarCut(data, holes);

    var a;
    var b;
    var c;

    var x1;
    var y1;

    var x2;
    var y2;

    var x3;
    var y3;

    for (var i = 0; i < tris.length; i += 3)
    {
        a = tris[i];
        b = tris[i + 1];
        c = tris[i + 2];

        x1 = data[a * 2] * scaleX;
        y1 = data[(a * 2) + 1] * scaleY;

        x2 = data[b * 2] * scaleX;
        y2 = data[(b * 2) + 1] * scaleY;

        x3 = data[c * 2] * scaleX;
        y3 = data[(c * 2) + 1] * scaleY;

        out.push(new Triangle(x1, y1, x2, y2, x3, y3));
    }

    return out;
};

module.exports = BuildFromPolygon;


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(38);

//  Builds a right triangle, with one 90 degree angle and two acute angles
//  The x/y is the coordinate of the 90 degree angle (and will map to x1/y1 in the resulting Triangle)
//  w/h can be positive or negative and represent the length of each side

var BuildRight = function (x, y, width, height)
{
    if (height === undefined) {  height = width; }

    //  90 degree angle
    var x1 = x;
    var y1 = y;

    var x2 = x;
    var y2 = y - height;

    var x3 = x + width;
    var y3 = y;

    return new Triangle(x1, y1, x2, y2, x3, y3);
};

module.exports = BuildRight;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

var Centroid = __webpack_require__(130);
var Offset = __webpack_require__(133);

var CenterOn = function (triangle, x, y, centerFunc)
{
    if (centerFunc === undefined) { centerFunc = Centroid; }

    //  Get the center of the triangle
    var center = centerFunc(triangle);

    //  Difference
    var diffX = x - center.x;
    var diffY = y - center.y;

    return Offset(triangle, diffX, diffY);
};

module.exports = CenterOn;


/***/ },
/* 448 */
/***/ function(module, exports) {

//  Adapted from http://bjornharrtell.github.io/jsts/doc/api/jsts_geom_Triangle.js.html

/**
 * Computes the determinant of a 2x2 matrix. Uses standard double-precision
 * arithmetic, so is susceptible to round-off error.
 *
 * @param {Number}
 *          m00 the [0,0] entry of the matrix.
 * @param {Number}
 *          m01 the [0,1] entry of the matrix.
 * @param {Number}
 *          m10 the [1,0] entry of the matrix.
 * @param {Number}
 *          m11 the [1,1] entry of the matrix.
 * @return {Number} the determinant.
 */
function det (m00, m01, m10, m11)
{
    return (m00 * m11) - (m01 * m10);
}

/**
 * Computes the circumcentre of a triangle. The circumcentre is the centre of
 * the circumcircle, the smallest circle which encloses the triangle. It is also
 * the common intersection point of the perpendicular bisectors of the sides of
 * the triangle, and is the only point which has equal distance to all three
 * vertices of the triangle.
 * <p>
 * This method uses an algorithm due to J.R.Shewchuk which uses normalization to
 * the origin to improve the accuracy of computation. (See <i>Lecture Notes on
 * Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
 */
var CircumCenter = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0 }; }

    var cx = triangle.x3;
    var cy = triangle.y3;

    var ax = triangle.x1 - cx;
    var ay = triangle.y1 - cy;

    var bx = triangle.x2 - cx;
    var by = triangle.y2 - cy;

    var denom = 2 * det(ax, ay, bx, by);
    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);

    out.x = cx - numx / denom;
    out.y = cy + numy / denom;

    return out;
};

module.exports = CircumCenter;


/***/ },
/* 449 */
/***/ function(module, exports) {

//  Adapted from https://gist.github.com/mutoo/5617691

var CircumCircle = function (triangle, out)
{
    if (out === undefined) { out = { x: 0, y: 0, radius: 0 }; }

    //  A
    var x1 = triangle.x1;
    var y1 = triangle.y1;

    //  B
    var x2 = triangle.x2;
    var y2 = triangle.y2;

    //  C
    var x3 = triangle.x3;
    var y3 = triangle.y3;

    var A = x2 - x1;
    var B = y2 - y1;
    var C = x3 - x1;
    var D = y3 - y1;
    var E = A * (x1 + x2) + B * (y1 + y2);
    var F = C * (x1 + x3) + D * (y1 + y3);
    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));

    var dx;
    var dy;

    //  If the points of the triangle are collinear, then just find the
    //  extremes and use the midpoint as the center of the circumcircle.

    if (Math.abs(G) < 0.000001)
    {
        var minX = Math.min(x1, x2, x3);
        var minY = Math.min(y1, y2, y3);
        dx = (Math.max(x1, x2, x3) - minX) * 0.5;
        dy = (Math.max(y1, y2, y3) - minY) * 0.5;

        out.x = minX + dx;
        out.y = minY + dy;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }
    else
    {
        out.x = (D * E - B * F) / G;
        out.y = (A * F - C * E) / G;
        dx = out.x - x1;
        dy = out.y - y1;
        out.radius = Math.sqrt(dx * dx + dy * dy);
    }

    return out;
};

module.exports = CircumCircle;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

var Triangle = __webpack_require__(38);

var Clone = function (source)
{
    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = Clone;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

var Contains = __webpack_require__(45);

var ContainsPoint = function (triangle, point)
{
    return Contains(triangle, point.x, point.y);
};

module.exports = ContainsPoint;


/***/ },
/* 452 */
/***/ function(module, exports) {

/**
* Copies the x1, y1 - x3, y3 properties from any given object to this Triangle.
* @method Phaser.Line#copyFrom
* @param {any} source - The object to copy from.
* @return {Line} This Line object.
*/
var CopyFrom = function (source, dest)
{
    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
};

module.exports = CopyFrom;


/***/ },
/* 453 */
/***/ function(module, exports) {

var Equals = function (triangle, toCompare)
{
    return (
        triangle.x1 === toCompare.x1 &&
        triangle.y1 === toCompare.y1 &&
        triangle.x2 === toCompare.x2 &&
        triangle.y2 === toCompare.y2 &&
        triangle.x3 === toCompare.x3 &&
        triangle.y3 === toCompare.y3
    );
};

module.exports = Equals;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(69);
var InCenter = __webpack_require__(132);

var Rotate = function (triangle, angle)
{
    var point = InCenter(triangle);

    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = Rotate;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

var RotateAroundXY = __webpack_require__(69);

var RotateAroundPoint = function (triangle, point, angle)
{
    return RotateAroundXY(triangle, point.x, point.y, angle);
};

module.exports = RotateAroundPoint;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Geom.Triangle

var Triangle = __webpack_require__(38);

Triangle.Area = __webpack_require__(443);
Triangle.BuildEquilateral = __webpack_require__(444);
Triangle.BuildFromPolygon = __webpack_require__(445);
Triangle.BuildRight = __webpack_require__(446);
Triangle.CenterOn = __webpack_require__(447);
Triangle.Centroid = __webpack_require__(130);
Triangle.CircumCenter = __webpack_require__(448);
Triangle.CircumCircle = __webpack_require__(449);
Triangle.Clone = __webpack_require__(450);
Triangle.Contains = __webpack_require__(45);
Triangle.ContainsArray = __webpack_require__(68);
Triangle.ContainsPoint = __webpack_require__(451);
Triangle.CopyFrom = __webpack_require__(452);
Triangle.Decompose = __webpack_require__(131);
Triangle.Equals = __webpack_require__(453);
Triangle.InCenter = __webpack_require__(132);
Triangle.Offset = __webpack_require__(133);
Triangle.Random = __webpack_require__(134);
Triangle.Rotate = __webpack_require__(454);
Triangle.RotateAroundPoint = __webpack_require__(455);
Triangle.RotateAroundXY = __webpack_require__(69);

module.exports = Triangle;


/***/ },
/* 457 */
/***/ function(module, exports) {

/**
* Takes the average of the source and backdrop colors.
*
* @method Lazer.Color.blendAverage
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Average = function (a, b)
{
    return (a + b) / 2;
};

module.exports = Average;


/***/ },
/* 458 */
/***/ function(module, exports) {

/**
* Subtracts the darker of the two constituent colors from the lighter.
* 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendDifference
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 459 */
/***/ function(module, exports) {

/**
* Produces an effect similar to that of the Difference mode, but lower in contrast. 
* Painting with white inverts the backdrop color; painting with black produces no change. 
*
* @method Lazer.Color.blendExclusion
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Exclusion =  function (a, b)
{
    return a + b - 2 * a * b / 255;
};

module.exports = Exclusion;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

var Reflect = __webpack_require__(143);

/**
* Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.
*
* @method Lazer.Color.blendGlow
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Glow = function (a, b)
{
    return Reflect(b, a);
};

module.exports = Glow;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

var Overlay = __webpack_require__(142);

/**
* Multiplies or screens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; 
* this is useful for adding shadows to a scene. 
* 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop. 
*
* @method Lazer.Color.blendHardLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardLight = function (a, b)
{
    return Overlay(b, a);
};

module.exports = HardLight;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

var VividLight = __webpack_require__(145);

/**
* Runs blendVividLight on the source and backdrop colors.
* If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.
* Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.
* This changes all pixels to primary additive colors (red, green, or blue), white, or black.
*
* @method Lazer.Color.blendHardMix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var HardMix = function (a, b)
{
    return (VividLight(a, b) < 128) ? 0 : 255;
};

module.exports = HardMix;


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

var LinearBurn = __webpack_require__(140);
var LinearDodge = __webpack_require__(141);

/**
* This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).
* Dodge applies to values of top layer lighter than middle gray, and burn to darker values.
* The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.
*
* @method Lazer.Color.blendLinearLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var LinearLight = function (a, b)
{
    return (b < 128) ? LinearBurn(a, 2 * b) : LinearDodge(a, (2 * (b - 128)));
};

module.exports = LinearLight;


/***/ },
/* 464 */
/***/ function(module, exports) {

/**
* Multiplies the backdrop and source color values.
* The result color is always at least as dark as either of the two constituent
* colors. Multiplying any color with black produces black;
* multiplying with white leaves the original color unchanged.
*
* @method Lazer.Color.blendMultiply
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Multiply = function (a, b)
{
    return (a * b) / 255;
};

module.exports = Multiply;


/***/ },
/* 465 */
/***/ function(module, exports) {

/**
* Negation blend mode.
*
* @method Lazer.Color.blendNegation
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Negation = function (a, b)
{
    return 255 - Math.abs(255 - a - b);
};

module.exports = Negation;


/***/ },
/* 466 */
/***/ function(module, exports) {

/**
* Blends the source color, ignoring the backdrop.
*
* @method Lazer.Color.blendNormal
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Normal = function (a)
{
    return a;
};

module.exports = Normal;


/***/ },
/* 467 */
/***/ function(module, exports) {

/**
* Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.
*
* @method Lazer.Color.blendPhoenix
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Phoenix = function (a, b)
{
    return Math.min(a, b) - Math.max(a, b) + 255;
};

module.exports = Phoenix;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

var Darken = __webpack_require__(138);
var Lighten = __webpack_require__(139);

/**
* If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.
* If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.
*
* @method Lazer.Color.blendPinLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var PinLight = function (a, b)
{
    return (b < 128) ? Darken(a, 2 * b) : Lighten(a, (2 * (b - 128)));
};

module.exports = PinLight;


/***/ },
/* 469 */
/***/ function(module, exports) {

/**
* Multiplies the complements of the backdrop and source color values, then complements the result.
* The result color is always at least as light as either of the two constituent colors. 
* Screening any color with white produces white; screening with black leaves the original color unchanged. 
*
* @method Lazer.Color.blendScreen
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var Screen = function (a, b)
{
    return 255 - (((255 - a) * (255 - b)) >> 8);
};

module.exports = Screen;


/***/ },
/* 470 */
/***/ function(module, exports) {

/**
* Darkens or lightens the colors, depending on the source color value. 
* 
* If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; 
* this is useful for adding highlights to a scene. 
* 
* If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. 
* The degree of lightening or darkening is proportional to the difference between the source color and 0.5; 
* if it is equal to 0.5, the backdrop is unchanged.
* 
* Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. 
* The effect is similar to shining a diffused spotlight on the backdrop. 
*
* @method Lazer.Color.blendSoftLight
* @static
* @param {integer} a - The source color to blend, in the range 1 to 255.
* @param {integer} b - The backdrop color to blend, in the range 1 to 255.
* @returns {integer} The blended color value, in the range 1 to 255.
*/
var SoftLight = function (a, b)
{
    return (b < 128) ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255);
};

module.exports = SoftLight;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics.BlendModes

module.exports = {

    Add: __webpack_require__(135),
    Average: __webpack_require__(457),
    ColorBurn: __webpack_require__(136),
    ColorDodge: __webpack_require__(137),
    Darken: __webpack_require__(138),
    Difference: __webpack_require__(458),
    Exclusion: __webpack_require__(459),
    Glow: __webpack_require__(460),
    HardLight: __webpack_require__(461),
    HardMix: __webpack_require__(462),
    Lighten: __webpack_require__(139),
    LinearBurn: __webpack_require__(140),
    LinearDodge: __webpack_require__(141),
    LinearLight: __webpack_require__(463),
    Multiply: __webpack_require__(464),
    Negation: __webpack_require__(465),
    Normal: __webpack_require__(466),
    Overlay: __webpack_require__(142),
    Phoenix: __webpack_require__(467),
    PinLight: __webpack_require__(468),
    Reflect: __webpack_require__(143),
    Screen: __webpack_require__(469),
    SoftLight: __webpack_require__(470),
    Subtract: __webpack_require__(144),
    VividLight: __webpack_require__(145)
    
};


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(32);

var CSSMap = {
    aliceblue: [ 240, 248, 245 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [ 0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [ 0, 0, 0 ],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [ 0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 35 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0 ],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    darkblue: [ 0, 0, 139 ],
    darkcyan: [ 0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [ 0, 100, 0 ],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0 ],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0 ],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [ 0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [ 0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0 ],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    green: [ 0, 128, 0 ],
    greenyellow: [ 173, 255, 47 ],
    grey: [ 128, 128, 128 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0 ],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [ 0, 255, 0 ],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    maroon: [ 128, 0, 0 ],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [ 0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [ 0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [ 0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0 ],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0 ],
    orangered: [ 255, 69, 0 ],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    rebeccapurple: [ 102, 51, 153 ],
    red: [ 255, 0, 0 ],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 129 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [ 0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [ 0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0 ],
    yellowgreen: [ 154, 205, 50 ]
};

var CSSToColor = function (name)
{
    name = name.toLowerCase();

    var color = new Color();
    var entry = CSSMap[name];

    if (entry)
    {
        color.setTo(entry[0], entry[1], entry[2], 255);
    }

    return color;
};

module.exports = CSSToColor;


/***/ },
/* 473 */
/***/ function(module, exports) {

var ColorToRGBA = function (color)
{
    var output = {
        r: color >> 16 & 0xFF,
        g: color >> 8 & 0xFF,
        b: color & 0xFF,
        a: 255
    };

    if (color > 16777215)
    {
        output.a = color >>> 24;
    }

    return output;
};

module.exports = ColorToRGBA;


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

var Color = __webpack_require__(32);
var HueToComponent = __webpack_require__(150);

var HSLToColor = function (h, s, l)
{
    // achromatic by default
    var r = l;
    var g = l;
    var b = l;

    if (s !== 0)
    {
        var q = (l < 0.5) ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = HueToComponent(p, q, h + 1 / 3);
        g = HueToComponent(p, q, h);
        b = HueToComponent(p, q, h - 1 / 3);
    }

    var color = new Color();

    return color.setGLTo(r, g, b, 1);
};

module.exports = HSLToColor;


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

var HSVToRGB = __webpack_require__(148);

/**
* Get HSV color wheel values in an array which will be 360 elements in size.
*
* @method Phaser.Color.HSVColorWheel
* @static
* @param {number} [s=1] - The saturation, in the range 0 - 1.
* @param {number} [v=1] - The value, in the range 0 - 1.
* @return {array} An array containing 360 elements corresponding to the HSV color wheel.
*/
var HSVColorWheel = function (s, v)
{
    if (s === undefined) { s = 1; }
    if (v === undefined) { v = 1; }

    var colors = [];

    for (var c = 0; c <= 359; c++)
    {
        colors.push(HSVToRGB(c / 359, s, v));
    }

    return colors;
};

module.exports = HSVColorWheel;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

var Linear = __webpack_require__(173);

var RGBWithRGB = function (r1, g1, b1, r2, g2, b2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    var t = index / length;

    return {
        r: Linear(r1, r2, t),
        g: Linear(g1, g2, t),
        b: Linear(b1, b2, t)
    };
};

var ColorWithColor = function (color1, color2, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
};

var ColorWithRGB = function  (color, r, g, b, length, index)
{
    if (length === undefined) { length = 100; }
    if (index === undefined) { index = 0; }

    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
};


module.exports = {

    RGBWithRGB: RGBWithRGB,
    ColorWithRGB: ColorWithRGB,
    ColorWithColor: ColorWithColor

};


/***/ },
/* 477 */
/***/ function(module, exports) {

/**
* Converts an RGB color value to HSV (hue, saturation and value).
* Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
* Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
* Based on code by Michael Jackson (https://github.com/mjijackson)
*
* @method Lazer.Color.RGBtoHSV
* @static
* @param {number} r - The red color component, in the range 0 - 255.
* @param {number} g - The green color component, in the range 0 - 255.
* @param {number} b - The blue color component, in the range 0 - 255.
* @return {object} An object with the hue, saturation and value set in the h, s and v properties.
*/
var RGBToHSV = function (r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var d = max - min;

    // achromatic by default
    var h = 0;
    var s = (max === 0) ? 0 : d / max;
    var v = max;

    if (max !== min)
    {
        if (max === r)
        {
            h = (g - b) / d + ((g < b) ? 6 : 0);
        }
        else if (max === g)
        {
            h = (b - r) / d + 2;
        }
        else if (max === b)
        {
            h = (r - g) / d + 4;
        }

        h /= 6;
    }

    return { h: h, s: s, v: v };
};

module.exports = RGBToHSV;


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

var ComponentToHex = __webpack_require__(146);

var RGBToString = function (r, g, b, a, prefix)
{
    if (a === undefined) { a = 255; }
    if (prefix === undefined) { prefix = '#'; }

    if (prefix === '#')
    {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    else
    {
        return '0x' + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    }
};

module.exports = RGBToString;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

var Between = __webpack_require__(73);

var RandomRGB = function (min, max)
{
    if (min === undefined) { min = 0; }
    if (max === undefined) { max = 255; }

    return {
        r: Between(min, max),
        g: Between(min, max),
        b: Between(min, max)
    };
};

module.exports = RandomRGB;


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Graphics.Color

var Color = __webpack_require__(32);

Color.ColorToRGBA = __webpack_require__(473);
Color.ComponentToHex = __webpack_require__(146);
Color.CSSToColor = __webpack_require__(472);
Color.GetColor = __webpack_require__(70);
Color.GetColor32 = __webpack_require__(147);
Color.HexStringToColor = __webpack_require__(149);
Color.HSLToColor = __webpack_require__(474);
Color.HSVColorWheel = __webpack_require__(475);
Color.HSVToRGB = __webpack_require__(148);
Color.HueToComponent = __webpack_require__(150);
Color.IntegerToColor = __webpack_require__(151);
Color.IntegerToRGB = __webpack_require__(152);
Color.Interpolate = __webpack_require__(476);
Color.RandomRGB = __webpack_require__(479);
Color.RGBStringToColor = __webpack_require__(153);
Color.RGBToHSV = __webpack_require__(477);
Color.RGBToString = __webpack_require__(478);
Color.ValueToColor = __webpack_require__(154);

module.exports = Color;


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

//  GlobalInputManager

var Keyboard = __webpack_require__(155);

var GlobalInputManager = function (game, gameConfig)
{
    this.game = game;

    this.gameConfig = gameConfig;

    this.keyboard = new Keyboard(this);
};

GlobalInputManager.prototype.constructor = GlobalInputManager;

GlobalInputManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.Input.KeyboardManager#boot
    * @private
    */
    boot: function ()
    {
        this.keyboard.boot();
    },

    update: function ()
    {
        this.keyboard.update();
    }

};

module.exports = GlobalInputManager;


/***/ },
/* 482 */
/***/ function(module, exports) {

//  Return boolean (true if it reached the end of the combo, false if not)

var AdvanceKeyCombo = function (event, combo)
{
    combo.timeLastMatched = event.timeStamp;
    combo.index++;

    if (combo.index === combo.size)
    {
        return true;
    }
    else
    {
        combo.current = combo.keyCodes[combo.index];
        return false;
    }
};

module.exports = AdvanceKeyCombo;


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var KeyComboMatchEvent = function (keyCombo, keyboardEvent)
{
    Event.call(this, 'KEY_COMBO_MATCH_EVENT');

    this.target = keyCombo;

    this.data = keyboardEvent;
};

KeyComboMatchEvent.prototype = Object.create(Event.prototype);
KeyComboMatchEvent.prototype.constructor = KeyComboMatchEvent;

module.exports = KeyComboMatchEvent;


/***/ },
/* 484 */
/***/ function(module, exports) {

var ResetKeyCombo = function (combo)
{
    combo.current = combo.keyCodes[0];
    combo.index = 0;
    combo.timeLastMatched = 0;
    combo.matched = false;
    combo.timeMatched = 0;

    return combo;
};

module.exports = ResetKeyCombo;


/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var KeyDownEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_DOWN_EVENT');

    this.data = keyboardEvent;
};

KeyDownEvent.prototype = Object.create(Event.prototype);
KeyDownEvent.prototype.constructor = KeyDownEvent;

module.exports = KeyDownEvent;


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var KeyUpEvent = function (keyboardEvent)
{
    Event.call(this, 'KEY_UP_EVENT');

    this.data = keyboardEvent;
};

KeyUpEvent.prototype = Object.create(Event.prototype);
KeyUpEvent.prototype.constructor = KeyUpEvent;

module.exports = KeyUpEvent;


/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);
var KeyCodes = __webpack_require__(71);

var events = {
    KEY_DOWN_EVENT: __webpack_require__(485),
    KEY_UP_EVENT: __webpack_require__(486),
    _UP: [],
    _DOWN: []
};

function createKeyEvent (type)
{
    var KeyEvent = function (keyboardEvent)
    {
        Event.call(this, type);

        this.data = keyboardEvent;
    };

    KeyEvent.prototype = Object.create(Event.prototype);
    KeyEvent.prototype.constructor = KeyEvent;

    return KeyEvent;
}

//  Inject the KeyCode events

for (var code in KeyCodes)
{
    //  The Key Down Event Types

    var downType = 'KEY_DOWN_' + code;
    var upType = 'KEY_UP_' + code;

    events._DOWN[KeyCodes[code]] = createKeyEvent(downType);
    events._UP[KeyCodes[code]] = createKeyEvent(upType);

    //  More friendly aliases to the main events
    events[downType] = events._DOWN[KeyCodes[code]];
    events[upType] = events._UP[KeyCodes[code]];
}

module.exports = events;


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Input.Keyboard

module.exports = {

    KeyboardManager: __webpack_require__(155),

    Key: __webpack_require__(158),
    KeyCodes: __webpack_require__(71),

    KeyCombo: __webpack_require__(156),

    JustDown: __webpack_require__(490),
    JustUp: __webpack_require__(491),
    DownDuration: __webpack_require__(489),
    UpDuration: __webpack_require__(494)
    
};


/***/ },
/* 489 */
/***/ function(module, exports) {

/**
* Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
* or was pressed down longer ago than then given duration.
* 
* @method Phaser.Key#downDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just pressed. Given in ms.
* @return {boolean} True if the key was pressed down within the given duration.
*/
var DownDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isDown && key.duration < duration);
};

module.exports = DownDuration;


/***/ },
/* 490 */
/***/ function(module, exports) {

/**
* The justDown value allows you to test if this Key has just been pressed down or not.
* When you check this value it will return `true` if the Key is down, otherwise `false`.
* You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
* This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
* 
* @property {boolean} justDown
* @memberof Phaser.Key
* @default false
*/

var JustDown = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justDown;
        key._justDown = false;
    }

    return current;
};

module.exports = JustDown;


/***/ },
/* 491 */
/***/ function(module, exports) {

/**
* The justUp value allows you to test if this Key has just been released or not.
* When you check this value it will return `true` if the Key is up, otherwise `false`.
* You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
* This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
* 
* @property {boolean} justUp
* @memberof Phaser.Key
* @default false
*/

var JustUp = function (key)
{
    var current = false;

    if (key.isDown)
    {
        current = key._justUp;
        key._justUp = false;
    }

    return current;
};

module.exports = JustUp;


/***/ },
/* 492 */
/***/ function(module, exports) {


var ProcessKeyDown = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.altKey = event.altKey;
    key.ctrlKey = event.ctrlKey;
    key.shiftKey = event.shiftKey;
    key.location = event.location;

    key.isDown = true;
    key.isUp = false;
    key.timeDown = event.timeStamp;
    key.duration = 0;
    key.repeats++;

    key._justDown = true;
    key._justUp = false;

    return key;
};

module.exports = ProcessKeyDown;


/***/ },
/* 493 */
/***/ function(module, exports) {


var ProcessKeyUp = function (key, event)
{
    key.originalEvent = event;

    if (key.preventDefault)
    {
        event.preventDefault();
    }

    if (!key.enabled)
    {
        return;
    }

    key.isDown = false;
    key.isUp = true;
    key.timeUp = event.timeStamp;
    key.duration = key.timeUp - key.timeDown;
    key.repeats = 0;

    key._justDown = false;
    key._justUp = true;

    return key;
};

module.exports = ProcessKeyUp;


/***/ },
/* 494 */
/***/ function(module, exports) {

/**
* Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
* or was released longer ago than then given duration.
* 
* @method Phaser.Key#upDuration
* @param {number} [duration=50] - The duration within which the key is considered as being just released. Given in ms.
* @return {boolean} True if the key was released within the given duration.
*/
var UpDuration = function (key, duration)
{
    if (duration === undefined) { duration = 50; }

    return (key.isUp && key.duration < duration);
};

module.exports = UpDuration;


/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var Set = __webpack_require__(185);
var XHRSettings = __webpack_require__(72);
var Event = __webpack_require__(500);
var EventDispatcher = __webpack_require__(26);

var BaseLoader = function ()
{
    //  To finish the loader ...
    //  
    //  3) Progress update

    this.events = new EventDispatcher();

    //  Move to a 'setURL' method?
    this.baseURL = '';
    this.path = '';

    //  Read from Game / State Config
    this.enableParallel = true;
    this.maxParallelDownloads = 4;

    //  xhr specific global settings (can be overridden on a per-file basis)
    this.xhr = XHRSettings();

    this.crossOrigin = undefined;

    this.list = new Set();
    this.inflight = new Set();
    this.failed = new Set();
    this.queue = new Set();
    this.storage = new Set();

    this._state = CONST.LOADER_IDLE;
};

BaseLoader.prototype.contructor = BaseLoader;

BaseLoader.prototype = {

    addFile: function (file)
    {
        if (!this.isReady())
        {
            return -1;
        }

        file.path = this.path;

        this.list.set(file);

        return this;
    },

    //  Is the Loader actively loading (or processing loaded files)
    isLoading: function ()
    {
        return (this._state === CONST.LOADER_LOADING || this._state === CONST.LOADER_PROCESSING);
    },

    //  Is the Loader ready to start a new load?
    isReady: function ()
    {
        return (this._state === CONST.LOADER_IDLE || this._state === CONST.LOADER_COMPLETE || this._state === CONST.LOADER_FAILED);
    },

    start: function ()
    {
        console.log(this.state.settings.key, '- BaseLoader start. Files to load:', this.list.size);

        if (!this.isReady())
        {
            return;
        }

        this.events.dispatch(new Event.LOADER_START_EVENT(this));

        if (this.list.size === 0)
        {
            this.finishedLoading();
        }
        else
        {
            this._state = CONST.LOADER_LOADING;

            this.failed.clear();
            this.inflight.clear();
            this.queue.clear();

            this.queue.debug = true;

            this.updateProgress();

            this.processLoadQueue();
        }
    },

    updateProgress: function ()
    {

    },

    processLoadQueue: function ()
    {
        // console.log('======== BaseLoader processLoadQueue');
        // console.log('List size', this.list.size);
        // console.log(this.inflight.size, 'items still in flight. Can load another', (this.maxParallelDownloads - this.inflight.size));

        var _this = this;

        this.list.each(function (file)
        {
            if (file.state === CONST.FILE_PENDING && _this.inflight.size < _this.maxParallelDownloads)
            {
                _this.inflight.set(file);

                _this.list.delete(file);

                _this.loadFile(file);
            }

            if (_this.inflight.size === _this.maxParallelDownloads)
            {
                //  Tells the Set iterator to abort
                return false;
            }

        });
    },

    //  private
    loadFile: function (file)
    {
        // console.log('LOADING', file.key);

        //  If the file doesn't have its own crossOrigin set,
        //  we'll use the Loaders (which is undefined by default)
        if (!file.crossOrigin)
        {
            file.crossOrigin = this.crossOrigin;
        }

        file.load(this.nextFile.bind(this), this.baseURL);
    },

    nextFile: function (previousFile, success)
    {
        // console.log('LOADED:', previousFile.src, success);

        //  Move the file that just loaded from the inflight list to the queue or failed Set

        if (success)
        {
            this.queue.set(previousFile);
        }
        else
        {
            this.failed.set(previousFile);
        }

        this.inflight.delete(previousFile);

        if (this.list.size > 0)
        {
            // console.log('nextFile - still something in the list');
            this.processLoadQueue();
        }
        else if (this.inflight.size === 0)
        {
            // console.log('nextFile calling finishedLoading');
            this.finishedLoading();
        }
    },

    finishedLoading: function ()
    {
        // console.log('---> BaseLoader.finishedLoading PROCESSING', this.queue.size, 'files');

        this._state = CONST.LOADER_PROCESSING;

        this.storage.clear();

        var _this = this;

        this.queue.each(function (file)
        {
            // console.log('%c Calling process on ' + file.key, 'color: #000000; background: #ffff00;');

            file.onProcess(_this.processUpdate.bind(_this));
        });
    },

    //  Called automatically by the File when it has finished processing
    processUpdate: function (file)
    {
        // console.log('-> processUpdate', file.key, file.state);

        //  This file has failed to load, so move it to the failed Set
        if (file.state === CONST.FILE_ERRORED)
        {
            this.failed.set(file);

            if (file.linkFile)
            {
                this.queue.delete(file.linkFile);
            }

            return this.removeFromQueue(file);
        }

        //  If we got here, then the file loaded

        //  Special handling for multi-part files

        if (file.linkFile)
        {
            if (file.state === CONST.FILE_COMPLETE && file.linkFile.state === CONST.FILE_COMPLETE)
            {
                //  Partner has loaded, so add them both to Storage

                this.storage.set({ type: file.linkType, fileA: file, fileB: file.linkFile });

                this.queue.delete(file.linkFile);

                this.removeFromQueue(file);
            }
        }
        else
        {
            this.storage.set(file);

            this.removeFromQueue(file);
        }
    },

    removeFromQueue: function (file)
    {
        this.queue.delete(file);

        if (this.queue.size === 0 && this._state === CONST.LOADER_PROCESSING)
        {
            //  We've processed all the files we loaded
            this.processComplete();
        }
    },

    processComplete: function ()
    {
        console.log(this.state.settings.key, '- Loader Complete. Loaded:', this.storage.size, 'Failed:', this.failed.size);

        this.list.clear();
        this.inflight.clear();
        this.queue.clear();

        if (this.processCallback)
        {
            this.processCallback();
        }

        this._state = CONST.LOADER_COMPLETE;

        this.events.dispatch(new Event.LOADER_COMPLETE_EVENT(this));
    },

    reset: function ()
    {
        this.list.clear();
        this.inflight.clear();
        this.failed.clear();
        this.queue.clear();
        this.storage.clear();

        this.events.removeAll('LOADER_START_EVENT');
        this.events.removeAll('LOADER_COMPLETE_EVENT');

        this.tag = '';
        this.path = '';
        this.baseURL = '';

        this._state = CONST.LOADER_IDLE;
    },

    destroy: function ()
    {
        this.reset();
        this._state = CONST.LOADER_DESTROYED;
    }

};

module.exports = BaseLoader;


/***/ },
/* 496 */
/***/ function(module, exports) {

var GetURL = function (file, baseURL)
{
    if (!file.url)
    {
        return false;
    }

    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/))
    {
        return file.url;
    }
    else
    {
        return baseURL + file.url;
    }
};

module.exports = GetURL;


/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

var MergeXHRSettings = __webpack_require__(159);

var XHRLoader = function (file, globalXHRSettings)
{
    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);

    var xhr = new XMLHttpRequest();

    xhr.open('GET', file.src, config.async, config.user, config.password);

    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config.timeout;

    if (config.header && config.headerValue)
    {
        xhr.setRequestHeader(config.header, config.headerValue);
    }

    if (config.overrideMimeType)
    {
        xhr.overrideMimeType(config.overrideMimeType);
    }

    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)

    xhr.onload = file.onLoad.bind(file);
    xhr.onerror = file.onError.bind(file);
    xhr.onprogress = file.onProgress.bind(file);

    //  This is the only standard method, the ones above are browser additions (maybe not universal?)
    // xhr.onreadystatechange

    xhr.send();

    return xhr;
};

module.exports = XHRLoader;


/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var LoaderCompleteEvent = function (loader)
{
    Event.call(this, 'LOADER_COMPLETE_EVENT');

    this.loader = loader;
};

LoaderCompleteEvent.prototype = Object.create(Event.prototype);
LoaderCompleteEvent.prototype.constructor = LoaderCompleteEvent;

module.exports = LoaderCompleteEvent;


/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

var Event = __webpack_require__(10);

var LoaderStartEvent = function (loader)
{
    Event.call(this, 'LOADER_START_EVENT');

    this.loader = loader;
};

LoaderStartEvent.prototype = Object.create(Event.prototype);
LoaderStartEvent.prototype.constructor = LoaderStartEvent;

module.exports = LoaderStartEvent;


/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    LOADER_START_EVENT: __webpack_require__(499),
    LOADER_COMPLETE_EVENT: __webpack_require__(498)

};


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(160);

var AtlasJSONFile = function (key, textureURL, atlasURL, path, textureXhrSettings, atlasXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new JSONFile(key, atlasURL, path, atlasXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'atlasjson';
    data.linkType = 'atlasjson';

    return { texture: image, data: data };
};

module.exports = AtlasJSONFile;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var BinaryFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.binary\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.bin';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'binary', key, url, 'arraybuffer', xhrSettings);
};

BinaryFile.prototype = Object.create(File.prototype);
BinaryFile.prototype.constructor = BinaryFile;

BinaryFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.response;

    this.onComplete();

    callback(this);
};

module.exports = BinaryFile;


/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);
var XMLFile = __webpack_require__(161);

var BitmapFontFile = function (key, textureURL, xmlURL, path, textureXhrSettings, xmlXhrSettings)
{
    var image = new ImageFile(key, textureURL, path, textureXhrSettings);
    var data = new XMLFile(key, xmlURL, path, xmlXhrSettings);

    //  Link them together
    image.linkFile = data;
    data.linkFile = image;

    //  Set the type
    image.linkType = 'bitmapfont';
    data.linkType = 'bitmapfont';

    return { texture: image, data: data };
};

module.exports = BitmapFontFile;


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var GLSLFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.glsl';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'glsl', key, url, 'text', xhrSettings);
};

GLSLFile.prototype = Object.create(File.prototype);
GLSLFile.prototype.constructor = GLSLFile;

GLSLFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = GLSLFile;


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var SVGFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.svg\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.svg';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'svg', key, url, 'text', xhrSettings);
};

SVGFile.prototype = Object.create(File.prototype);
SVGFile.prototype.constructor = SVGFile;

SVGFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    var svg = [ this.xhrLoader.responseText ];

    try
    {
        var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });
    }
    catch (e)
    {
        _this.state = CONST.FILE_ERRORED;

        callback(_this);

        return;
    }

    this.data = new Image();

    this.data.crossOrigin = this.crossOrigin;

    var _this = this;
    var retry = false;

    this.data.onload = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        _this.onComplete();

        callback(_this);
    };

    this.data.onerror = function ()
    {
        URL.revokeObjectURL(_this.data.src);

        //  Safari 8 re-try
        if (!retry)
        {
            retry = true;

            var url = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));

            _this.data.src = URL.createObjectURL(url);
        }
        else
        {
            _this.state = CONST.FILE_ERRORED;

            callback(_this);
        }
    };

    this.data.src = URL.createObjectURL(blob);
};

module.exports = SVGFile;


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

var ImageFile = __webpack_require__(37);

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing

var SpriteSheet = function (key, url, config, path, xhrSettings)
{
    var image = new ImageFile(key, url, path, xhrSettings, config);

    //  Override the File type
    image.type = 'spritesheet';

    return image;
};

module.exports = SpriteSheet;


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {


var CONST = __webpack_require__(11);
var File = __webpack_require__(28);

var TextFile = function (key, url, path, xhrSettings)
{
    if (path === undefined) { path = ''; }

    if (!key)
    {
        throw new Error('Error calling \'Loader.text\' invalid key provided.');
    }

    if (!url)
    {
        url = path + key + '.text';
    }
    else
    {
        url = path.concat(url);
    }

    File.call(this, 'text', key, url, 'text', xhrSettings);
};

TextFile.prototype = Object.create(File.prototype);
TextFile.prototype.constructor = TextFile;

TextFile.prototype.onProcess = function (callback)
{
    this.state = CONST.FILE_PROCESSING;

    this.data = this.xhrLoader.responseText;

    this.onComplete();

    callback(this);
};

module.exports = TextFile;


/***/ },
/* 508 */
/***/ function(module, exports) {

var Average = function (values)
{
    var sum = 0;

    for (var i = 0; i < values.length; i++)
    {
        sum += (+values[i]);
    }

    return sum / values.length;
};

module.exports = Average;


/***/ },
/* 509 */
/***/ function(module, exports) {

var CeilTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.ceil(value * p) / p;
};

module.exports = CeilTo;


/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(6);

var DegToRad = function (degrees)
{
    return degrees * CONST.DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ },
/* 511 */
/***/ function(module, exports) {

var Difference = function (a, b)
{
    return Math.abs(a - b);
};

module.exports = Difference;


/***/ },
/* 512 */
/***/ function(module, exports) {

var FloatBetween = function (min, max)
{
    return Math.random() * (max - min + 1) + min;
};

module.exports = FloatBetween;


/***/ },
/* 513 */
/***/ function(module, exports) {

var FloorTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.floor(value * p) / p;
};

module.exports = FloorTo;


/***/ },
/* 514 */
/***/ function(module, exports) {


var MaxAdd = function (value, amount, max)
{
    return Math.min(value + amount, max);
};

module.exports = MaxAdd;


/***/ },
/* 515 */
/***/ function(module, exports) {

var MinSub = function (value, amount, min)
{
    return Math.max(value - amount, min);
};

module.exports = MinSub;


/***/ },
/* 516 */
/***/ function(module, exports) {

var Percent = function (a, b, base)
{
    if (base === undefined) { base = 0; }

    if (a > b || base > b)
    {
        return 1;
    }
    else if (a < base || base > a)
    {
        return 0;
    }
    else
    {
        return (a - base) / b;
    }
};

module.exports = Percent;


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(6);

var RadToDeg = function (radians)
{
    return radians * CONST.RAD_TO_DEG;
};

module.exports = RadToDeg;


/***/ },
/* 518 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var Rotate = function (point, angle)
{
    var x = point.x;
    var y = point.y;

    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));
    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));

    return point;
};

module.exports = Rotate;


/***/ },
/* 519 */
/***/ function(module, exports) {

//  p = Point or any object with public x/y properties

var RotateAround = function (point, x, y, angle)
{
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    var tx = point.x - x;
    var ty = point.y - y;

    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;

    return point;
};

module.exports = RotateAround;


/***/ },
/* 520 */
/***/ function(module, exports) {

var RoundTo = function (value, place, base)
{
    if (place === undefined) { place = 0; }
    if (base === undefined) { base = 10; }

    var p = Math.pow(base, -place);

    return Math.round(value * p) / p;
};

module.exports = RoundTo;


/***/ },
/* 521 */
/***/ function(module, exports) {


var SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)
{
    if (sinAmp === undefined) { sinAmp = 1; }
    if (cosAmp === undefined) { cosAmp = 1; }
    if (frequency === undefined) { frequency = 1; }

    frequency *= Math.PI / length;

    var cos = [];
    var sin = [];

    for (var c = 0; c < length; c++)
    {
        cosAmp -= sinAmp * frequency;
        sinAmp += cosAmp * frequency;

        cos[c] = cosAmp;
        sin[c] = sinAmp;
    }

    return {
        sin: sin,
        cos: cos,
        length: length
    };
};

module.exports = SinCosTableGenerator;


/***/ },
/* 522 */
/***/ function(module, exports) {

/**
* Checks if two values are within the given tolerance of each other.
*
* @method Phaser.Math#within
* @param {number} a - The first number to check
* @param {number} b - The second number to check
* @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.
* @return {boolean} True if a is <= tolerance of b.
* @see {@link Phaser.Math.fuzzyEqual}
*/
var Within = function (a, b, tolerance)
{
    return (Math.abs(a - b) <= tolerance);
};

module.exports = Within;


/***/ },
/* 523 */
/***/ function(module, exports) {

var Between = function (x1, y1, x2, y2)
{
    return Math.atan2(y2 - y1, x2 - x1);
};

module.exports = Between;


/***/ },
/* 524 */
/***/ function(module, exports) {

var BetweenPoints = function (point1, point2)
{
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

module.exports = BetweenPoints;


/***/ },
/* 525 */
/***/ function(module, exports) {

var BetweenPointsY = function (point1, point2)
{
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
};

module.exports = BetweenPointsY;


/***/ },
/* 526 */
/***/ function(module, exports) {

var BetweenY = function (x1, y1, x2, y2)
{
    return Math.atan2(x2 - x1, y2 - y1);
};

module.exports = BetweenY;


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

var Normalize = __webpack_require__(170);

var Reverse = function (angle)
{
    return Normalize(angle + Math.PI);
};

module.exports = Reverse;


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

var MATH_CONST = __webpack_require__(6);

/**
* Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
* The lerp argument is the amount to rotate by in this call.
* 
* @method Phaser.Math#rotateToAngle
* @param {number} currentAngle - The current angle, in radians.
* @param {number} targetAngle - The target angle to rotate to, in radians.
* @param {number} [lerp=0.05] - The lerp value to add to the current angle.
* @return {number} The adjusted angle.
*/
var RotateTo = function (currentAngle, targetAngle, lerp)
{
    if (lerp === undefined) { lerp = 0.05; }

    if (currentAngle === targetAngle)
    {
        return currentAngle;
    }

    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))
    {
        currentAngle = targetAngle;
    }
    else
    {
        if (Math.abs(targetAngle - currentAngle) > Math.PI)
        {
            if (targetAngle < currentAngle)
            {
                targetAngle += MATH_CONST.PI2;
            }
            else
            {
                targetAngle -= MATH_CONST.PI2;
            }
        }

        if (targetAngle > currentAngle)
        {
            currentAngle += lerp;
        }
        else if (targetAngle < currentAngle)
        {
            currentAngle -= lerp;
        }
    }

    return currentAngle;
};

module.exports = RotateTo;


/***/ },
/* 529 */
/***/ function(module, exports) {

/**
* Gets the shortest angle between `angle1` and `angle2`.
* Both angles must be in the range -180 to 180, which is the same clamped
* range that `sprite.angle` uses, so you can pass in two sprite angles to
* this method, and get the shortest angle back between the two of them.
*
* The angle returned will be in the same range. If the returned angle is
* greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
* a clockwise rotation.
* 
* @method Phaser.Math#getShortestAngle
* @param {number} angle1 - The first angle. In the range -180 to 180.
* @param {number} angle2 - The second angle. In the range -180 to 180.
* @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.
*/
var ShortestBetween = function (angle1, angle2)
{
    var difference = angle2 - angle1;

    if (difference === 0)
    {
        return 0;
    }

    var times = Math.floor((difference - (-180)) / 360);

    return difference - (times * 360);

};

module.exports = ShortestBetween;


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(523),
    BetweenY: __webpack_require__(526),
    BetweenPoints: __webpack_require__(524),
    BetweenPointsY: __webpack_require__(525),
    Reverse: __webpack_require__(527),
    RotateTo: __webpack_require__(528),
    ShortestBetween: __webpack_require__(529),
    Normalize: __webpack_require__(170),
    Wrap: __webpack_require__(171),
    WrapDegrees: __webpack_require__(172)

};


/***/ },
/* 531 */
/***/ function(module, exports) {

var DistancePower = function (x1, y1, x2, y2, pow)
{
    if (pow === undefined) { pow = 2; }

    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
};

module.exports = DistancePower;


/***/ },
/* 532 */
/***/ function(module, exports) {

var DistanceSquared = function (x1, y1, x2, y2)
{
    var dx = x1 - x2;
    var dy = y1 - y2;

    return dx * dx + dy * dy;
};

module.exports = DistanceSquared;


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Between: __webpack_require__(75),
    Power: __webpack_require__(531),
    Squared: __webpack_require__(532)

};


/***/ },
/* 534 */
/***/ function(module, exports) {

function In (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return v * v * ((overshoot + 1) * v - overshoot);
}

function Out (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
}

function InOut (v, overshoot)
{
    if (overshoot === undefined) { overshoot = 1.70158; }

    var s = overshoot * 1.525;

    if ((v *= 2) < 1)
    {
        return 0.5 * (v * v * ((s + 1) * v - s));
    }
    else
    {
        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 535 */
/***/ function(module, exports) {

function In (v)
{
    v = 1 - v;

    if (v < 1 / 2.75)
    {
        return 1 - (7.5625 * v * v);
    }
    else if (v < 2 / 2.75)
    {
        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    }
    else if (v < 2.5 / 2.75)
    {
        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    }
    else
    {
        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
}

function Out (v)
{
    if (v < 1 / 2.75)
    {
        return 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
}

function InOut (v)
{
    var reverse = false;

    if (v < 0.5)
    {
        v = 1 - (v * 2);
        reverse = true;
    }
    else
    {
        v = (v * 2) - 1;
    }

    if (v < 1 / 2.75)
    {
        v = 7.5625 * v * v;
    }
    else if (v < 2 / 2.75)
    {
        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    }
    else if (v < 2.5 / 2.75)
    {
        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    }
    else
    {
        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }

    if (reverse)
    {
        return (1 - v) * 0.5;
    }
    else
    {
        return v * 0.5 + 0.5;
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 536 */
/***/ function(module, exports) {

function In (v)
{
    return 1 - Math.sqrt(1 - v * v);
}

function Out (v)
{
    return Math.sqrt(1 - (--v * v));
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return -0.5 * (Math.sqrt(1 - v * v) - 1);
    }
    else
    {
        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 537 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v;
}

function Out (v)
{
    return --v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 538 */
/***/ function(module, exports) {

function In (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
}

function Out (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);
    }
}

function InOut (v, amplitude, period)
{
    if (amplitude === undefined) { amplitude = 0.1; }
    if (period === undefined) { period = 0.1; }

    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        var s = period / 4;

        if (amplitude < 1)
        {
            amplitude = 1;
        }
        else
        {
            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
        }

        if ((v *= 2) < 1)
        {
            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
        }
        else
        {
            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
        }
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 539 */
/***/ function(module, exports) {

function In (v)
{
    return Math.pow(2, 10 * (v - 1)) - 0.001;
}

function Out (v)
{
    return 1 - Math.pow(2, -10 * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * Math.pow(2, 10 * (v - 1));
    }
    else
    {
        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 540 */
/***/ function(module, exports) {

/**
* Linear Easing (no variation).
*
* @method Lazer.Easing.Linear#None
* @param {number} v - The value to be tweened.
* @returns {number} v.
*/
var Linear = function (v)
{
    return v;
};

module.exports = Linear;


/***/ },
/* 541 */
/***/ function(module, exports) {

function In (v)
{
    return v * v;
}

function Out (v)
{
    return v * (2 - v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v;
    }
    else
    {
        return -0.5 * (--v * (v - 2) - 1);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 542 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v;
}

function Out (v)
{
    return 1 - (--v * v * v * v);
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v;
    }
    else
    {
        return -0.5 * ((v -= 2) * v * v * v - 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 543 */
/***/ function(module, exports) {

function In (v)
{
    return v * v * v * v * v;
}

function Out (v)
{
    return --v * v * v * v * v + 1;
}

function InOut (v)
{
    if ((v *= 2) < 1)
    {
        return 0.5 * v * v * v * v * v;
    }
    else
    {
        return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 544 */
/***/ function(module, exports) {

function In (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 1 - Math.cos(v * Math.PI / 2);
    }
}

function Out (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return Math.sin(v * Math.PI / 2);
    }
}

function InOut (v)
{
    if (v === 0)
    {
        return 0;
    }
    else if (v === 1)
    {
        return 1;
    }
    else
    {
        return 0.5 * (1 - Math.cos(Math.PI * v));
    }
}

module.exports = {

    In: In,
    Out: Out,
    InOut: InOut

};


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Back: __webpack_require__(534),
    Bounce: __webpack_require__(535),
    Circular: __webpack_require__(536),
    Cubic: __webpack_require__(537),
    Elastic: __webpack_require__(538),
    Expo: __webpack_require__(539),
    Linear: __webpack_require__(540),
    Quadratic: __webpack_require__(541),
    Quartic: __webpack_require__(542),
    Quintic: __webpack_require__(543),
    Sine: __webpack_require__(544)

};


/***/ },
/* 546 */
/***/ function(module, exports) {

var Ceil = function (value, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.ceil(value - epsilon);
};

module.exports = Ceil;


/***/ },
/* 547 */
/***/ function(module, exports) {

var Equal = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.abs(a - b) < epsilon;
};

module.exports = Equal;


/***/ },
/* 548 */
/***/ function(module, exports) {

var Floor = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return Math.floor(value + epsilon);
};

module.exports = Floor;


/***/ },
/* 549 */
/***/ function(module, exports) {

var GreaterThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a > b - epsilon;
};

module.exports = GreaterThan;


/***/ },
/* 550 */
/***/ function(module, exports) {

var LessThan = function (a, b, epsilon)
{
    if (epsilon === undefined) { epsilon = 0.0001; }

    return a < b + epsilon;
};

module.exports = LessThan;


/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(546),
    Equal: __webpack_require__(547),
    Floor: __webpack_require__(548),
    GreaterThan: __webpack_require__(549),
    LessThan: __webpack_require__(550)

};


/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

var Bernstein = __webpack_require__(162);

var BezierInterpolation = function (v, k)
{
    var b = 0;
    var n = v.length - 1;

    for (var i = 0; i <= n; i++)
    {
        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }

    return b;
};

module.exports = BezierInterpolation;


/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

var CatmullRom = __webpack_require__(163);

var CatmullRomInterpolation = function (v, k)
{
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);

    if (v[0] === v[m])
    {
        if (k < 0)
        {
            i = Math.floor(f = m * (1 + k));
        }

        return CatmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    }
    else
    {
        if (k < 0)
        {
            return v[0] - (CatmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
        }

        if (k > 1)
        {
            return v[m] - (CatmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }

        return CatmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
};

module.exports = CatmullRomInterpolation;


/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Bezier: __webpack_require__(552),
    CatmullRom: __webpack_require__(553),
    Linear: __webpack_require__(173)

};


/***/ },
/* 555 */
/***/ function(module, exports) {

//  Takes value and returns the nearest power of 2

var GetPowerOfTwo = function (value)
{
    //  Math.log(2)
    var index = Math.log(value) / 0.6931471805599453;

    return (1 << Math.ceil(index));
};

module.exports = GetPowerOfTwo;


/***/ },
/* 556 */
/***/ function(module, exports) {

//  Is value a power of 2?

var IsValuePowerOfTwo = function (value)
{
    return (value > 0 && (value & (value - 1)) === 0);
};

module.exports = IsValuePowerOfTwo;


/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {module.export = {

    GetNext: __webpack_require__(555),
    IsSize: __webpack_require__(174),
    IsValue: __webpack_require__(556)

};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)(module)))

/***/ },
/* 558 */
/***/ function(module, exports) {

/**
* @property {number} c - Internal var.
* @private
*/
var c = 1;

/**
* @property {number} s0 - Internal var.
* @private
*/
var s0 = 0;

/**
* @property {number} s1 - Internal var.
* @private
*/
var s1 = 0;

/**
* @property {number} s2 - Internal var.
* @private
*/
var s2 = 0;

/**
* @property {Array} sign - Internal var.
* @private
*/
var sign = [ -1, 1 ];

/**
* Private random helper.
*
* @method Phaser.RandomDataGenerator#rnd
* @private
* @return {number}
*/
var rnd = function ()
{
    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32

    c = t | 0;
    s0 = s1;
    s1 = s2;
    s2 = t - c;

    return s2;
};

/**
* Internal method that creates a seed hash.
*
* @method Phaser.RandomDataGenerator#hash
* @private
* @param {any} data
* @return {number} hashed value.
*/
var hash = function (data)
{
    var h, i, n;
    n = 0xefc8249d;
    data = data.toString();

    for (i = 0; i < data.length; i++)
    {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000;// 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10;// 2^-32
};


var RandomDataGenerator = function (seeds)
{
    if (seeds)
    {
        this.init(seeds);
    }
};

RandomDataGenerator.prototype.constructor = RandomDataGenerator;

RandomDataGenerator.prototype = {

    init: function (seeds)
    {
        if (typeof seeds === 'string')
        {
            this.state(seeds);
        }
        else
        {
            this.sow(seeds);
        }
    },

    /**
    * Reset the seed of the random data generator.
    *
    * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
    *
    * @method Phaser.RandomDataGenerator#sow
    * @param {any[]} seeds - The array of seeds: the `toString()` of each value is used.
    */
    sow: function (seeds)
    {
        // Always reset to default seed
        s0 = hash(' ');
        s1 = hash(s0);
        s2 = hash(s1);
        c = 1;

        if (!seeds)
        {
            return;
        }

        // Apply any seeds
        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)
        {
            var seed = seeds[i];

            s0 -= hash(seed);
            s0 += ~~(s0 < 0);
            s1 -= hash(seed);
            s1 += ~~(s1 < 0);
            s2 -= hash(seed);
            s2 += ~~(s2 < 0);
        }

    },

    /**
    * Returns a random integer between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#integer
    * @return {number} A random integer between 0 and 2^32.
    */
    integer: function ()
    {
        // 2^32
        return rnd() * 0x100000000;
    },

    /**
    * Returns a random real number between 0 and 1.
    *
    * @method Phaser.RandomDataGenerator#frac
    * @return {number} A random real number between 0 and 1.
    */
    frac: function ()
    {
        // 2^-53
        return rnd() + (rnd() * 0x200000 | 0) * 1.1102230246251565e-16;
    },

    /**
    * Returns a random real number between 0 and 2^32.
    *
    * @method Phaser.RandomDataGenerator#real
    * @return {number} A random real number between 0 and 2^32.
    */
    real: function ()
    {
        return this.integer() + this.frac();
    },

    /**
    * Returns a random integer between and including min and max.
    *
    * @method Phaser.RandomDataGenerator#integerInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    integerInRange: function (min, max)
    {
        return Math.floor(this.realInRange(0, max - min + 1) + min);
    },

    /**
    * Returns a random integer between and including min and max.
    * This method is an alias for RandomDataGenerator.integerInRange.
    *
    * @method Phaser.RandomDataGenerator#between
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    between: function (min, max)
    {
        return this.integerInRange(min, max);
    },

    /**
    * Returns a random real number between min and max.
    *
    * @method Phaser.RandomDataGenerator#realInRange
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random number between min and max.
    */
    realInRange: function (min, max)
    {
        return this.frac() * (max - min) + min;
    },

    /**
    * Returns a random real number between -1 and 1.
    *
    * @method Phaser.RandomDataGenerator#normal
    * @return {number} A random real number between -1 and 1.
    */
    normal: function ()
    {
        return 1 - (2 * this.frac());
    },

    /**
    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
    *
    * @method Phaser.RandomDataGenerator#uuid
    * @return {string} A valid RFC4122 version4 ID hex string
    */
    uuid: function ()
    {
        var a = '';
        var b = '';

        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')
        {
        }

        return b;
    },

    /**
    * Returns a random member of `array`.
    *
    * @method Phaser.RandomDataGenerator#pick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    pick: function (array)
    {
        return array[this.integerInRange(0, array.length - 1)];
    },

    /**
    * Returns a sign to be used with multiplication operator.
    *
    * @method Phaser.RandomDataGenerator#sign
    * @return {number} -1 or +1.
    */
    sign: function ()
    {
        return this.pick(sign);
    },

    /**
    * Returns a random member of `array`, favoring the earlier entries.
    *
    * @method Phaser.RandomDataGenerator#weightedPick
    * @param {Array} array - An Array to pick a random member of.
    * @return {any} A random member of the array.
    */
    weightedPick: function (array)
    {
        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },

    /**
    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
    *
    * @method Phaser.RandomDataGenerator#timestamp
    * @param {number} min - The minimum value in the range.
    * @param {number} max - The maximum value in the range.
    * @return {number} A random timestamp between min and max.
    */
    timestamp: function (min, max)
    {
        return this.realInRange(min || 946684800000, max || 1577862000000);
    },

    /**
    * Returns a random angle between -180 and 180.
    *
    * @method Phaser.RandomDataGenerator#angle
    * @return {number} A random number between -180 and 180.
    */
    angle: function ()
    {
        return this.integerInRange(-180, 180);
    },

    /**
    * Returns a random rotation in radians, between -3.141 and 3.141
    *
    * @method Phaser.RandomDataGenerator#rotation
    * @return {number} A random number between -3.141 and 3.141
    */
    rotation: function ()
    {
        return this.realInRange(-3.141592653589793, 3.141592653589793);
    },

    /**
    * Gets or Sets the state of the generator. This allows you to retain the values
    * that the generator is using between games, i.e. in a game save file.
    *
    * To seed this generator with a previously saved state you can pass it as the
    * `seed` value in your game config, or call this method directly after Phaser has booted.
    *
    * Call this method with no parameters to return the current state.
    *
    * If providing a state it should match the same format that this method
    * returns, which is a string with a header `!rnd` followed by the `c`,
    * `s0`, `s1` and `s2` values respectively, each comma-delimited.
    *
    * @method Phaser.RandomDataGenerator#state
    * @param {string} [state] - Generator state to be set.
    * @return {string} The current state of the generator.
    */
    state: function (state)
    {
        if (typeof state === 'string' && state.match(/^!rnd/))
        {
            state = state.split(',');

            c = parseFloat(state[1]);
            s0 = parseFloat(state[2]);
            s1 = parseFloat(state[3]);
            s2 = parseFloat(state[4]);
        }

        return [ '!rnd', c, s0, s1, s2 ].join(',');
    }

};

module.exports = RandomDataGenerator;


/***/ },
/* 559 */
/***/ function(module, exports) {

var SnapCeil = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.ceil(value / gap);

    return start + value;
};

module.exports = SnapCeil;


/***/ },
/* 560 */
/***/ function(module, exports) {

var SnapFloor = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.floor(value / gap);

    return start + value;
};

module.exports = SnapFloor;


/***/ },
/* 561 */
/***/ function(module, exports) {

var SnapTo = function (value, gap, start)
{
    if (start === undefined) { start = 0; }

    if (gap === 0)
    {
        return value;
    }

    value -= start;
    value = gap * Math.round(value / gap);

    return start + value;
};

module.exports = SnapTo;


/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

module.exports = {

    Ceil: __webpack_require__(559),
    Floor: __webpack_require__(560),
    To: __webpack_require__(561)

};


/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/

var Query = {};

module.exports = Query;

var Vector = __webpack_require__(8);
var SAT = __webpack_require__(78);
var Bounds = __webpack_require__(7);
var Bodies = __webpack_require__(80);
var Vertices = __webpack_require__(25);

(function() {

    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */
    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
        rayWidth = rayWidth || 1e-100;

        var rayAngle = Vector.angle(startPoint, endPoint),
            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),
            rayX = (endPoint.x + startPoint.x) * 0.5,
            rayY = (endPoint.y + startPoint.y) * 0.5,
            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),
            collisions = [];

        for (var i = 0; i < bodies.length; i++) {
            var bodyA = bodies[i];
            
            if (Bounds.overlaps(bodyA.bounds, ray.bounds)) {
                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];

                    if (Bounds.overlaps(part.bounds, ray.bounds)) {
                        var collision = SAT.collides(part, ray);
                        if (collision.collided) {
                            collision.body = collision.bodyA = collision.bodyB = bodyA;
                            collisions.push(collision);
                            break;
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */
    Query.region = function(bodies, bounds, outside) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                overlaps = Bounds.overlaps(body.bounds, bounds);
            if ((overlaps && !outside) || (!overlaps && outside))
                result.push(body);
        }

        return result;
    };

    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */
    Query.point = function(bodies, point) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            
            if (Bounds.contains(body.bounds, point)) {
                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];

                    if (Bounds.contains(part.bounds, point)
                        && Vertices.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                    }
                }
            }
        }

        return result;
    };

})();


/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/

var MouseConstraint = {};

module.exports = MouseConstraint;

var Vertices = __webpack_require__(25);
var Sleeping = __webpack_require__(41);
var Mouse = __webpack_require__(79);
var Events = __webpack_require__(24);
var Detector = __webpack_require__(76);
var Constraint = __webpack_require__(40);
var Composite = __webpack_require__(23);
var Common = __webpack_require__(0);
var Bounds = __webpack_require__(7);

(function() {

    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */
    MouseConstraint.create = function(engine, options) {
        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);

        if (!mouse) {
            if (engine && engine.render && engine.render.canvas) {
                mouse = Mouse.create(engine.render.canvas);
            } else if (options && options.element) {
                mouse = Mouse.create(options.element);
            } else {
                mouse = Mouse.create();
                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');
            }
        }

        var constraint = Constraint.create({ 
            label: 'Mouse Constraint',
            pointA: mouse.position,
            pointB: { x: 0, y: 0 },
            length: 0.01, 
            stiffness: 0.1,
            angularStiffness: 1,
            render: {
                strokeStyle: '#90EE90',
                lineWidth: 3
            }
        });

        var defaults = {
            type: 'mouseConstraint',
            mouse: mouse,
            element: null,
            body: null,
            constraint: constraint,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            }
        };

        var mouseConstraint = Common.extend(defaults, options);

        Events.on(engine, 'beforeUpdate', function() {
            var allBodies = Composite.allBodies(engine.world);
            MouseConstraint.update(mouseConstraint, allBodies);
            _triggerEvents(mouseConstraint);
        });

        return mouseConstraint;
    };

    /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */
    MouseConstraint.update = function(mouseConstraint, bodies) {
        var mouse = mouseConstraint.mouse,
            constraint = mouseConstraint.constraint,
            body = mouseConstraint.body;

        if (mouse.button === 0) {
            if (!constraint.bodyB) {
                for (var i = 0; i < bodies.length; i++) {
                    body = bodies[i];
                    if (Bounds.contains(body.bounds, mouse.position) 
                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {
                            var part = body.parts[j];
                            if (Vertices.contains(part.vertices, mouse.position)) {
                                constraint.pointA = mouse.position;
                                constraint.bodyB = mouseConstraint.body = body;
                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };
                                constraint.angleB = body.angle;

                                Sleeping.set(body, false);
                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });

                                break;
                            }
                        }
                    }
                }
            } else {
                Sleeping.set(constraint.bodyB, false);
                constraint.pointA = mouse.position;
            }
        } else {
            constraint.bodyB = mouseConstraint.body = null;
            constraint.pointB = null;

            if (body)
                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });
        }
    };

    /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */
    var _triggerEvents = function(mouseConstraint) {
        var mouse = mouseConstraint.mouse,
            mouseEvents = mouse.sourceEvents;

        if (mouseEvents.mousemove)
            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });

        if (mouseEvents.mousedown)
            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });

        if (mouseEvents.mouseup)
            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });

        // reset the mouse state ready for the next step
        Mouse.clearSourceEvents(mouse);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when the mouse has moved (or a touch moves) during the last step
    *
    * @event mousemove
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is down (or a touch has started) during the last step
    *
    * @event mousedown
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is up (or a touch has ended) during the last step
    *
    * @event mouseup
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user starts dragging a body
    *
    * @event startdrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user ends dragging a body
    *
    * @event enddrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body that has stopped being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     *
     * @property mouse
     * @type mouse
     * @default mouse
     */

    /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     *
     * @property body
     * @type body
     * @default null
     */

    /**
     * The `Constraint` object that is used to move the body during interaction.
     *
     * @property constraint
     * @type constraint
     */

    /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter
     * @type object
     */

})();


/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/

var Matter = {};

module.exports = Matter;

var Plugin = __webpack_require__(181);
var Common = __webpack_require__(0);

(function() {

    /**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */
    Matter.name = 'matter-js';

    /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */
    Matter.version = '@@VERSION@@';

    /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */
    Matter.uses = [];

    /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */
    Matter.used = [];

    /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */
    Matter.use = function() {
        Plugin.use(Matter, Array.prototype.slice.call(arguments));
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Matter.before = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathBefore(Matter, path, func);
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Matter.after = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathAfter(Matter, path, func);
    };

})();


/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/

var Runner = {};

module.exports = Runner;

var Events = __webpack_require__(24);
var Engine = __webpack_require__(179);
var Common = __webpack_require__(0);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    if (!_requestAnimationFrame) {
        var _frameTimeout;

        _requestAnimationFrame = function(callback){ 
            _frameTimeout = setTimeout(function() { 
                callback(Common.now()); 
            }, 1000 / 60);
        };

        _cancelAnimationFrame = function() {
            clearTimeout(_frameTimeout);
        };
    }

    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */
    Runner.create = function(options) {
        var defaults = {
            fps: 60,
            correction: 1,
            deltaSampleSize: 60,
            counterTimestamp: 0,
            frameCounter: 0,
            deltaHistory: [],
            timePrev: null,
            timeScalePrev: 1,
            frameRequestId: null,
            isFixed: false,
            enabled: true
        };

        var runner = Common.extend(defaults, options);

        runner.delta = runner.delta || 1000 / runner.fps;
        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
        runner.fps = 1000 / runner.delta;

        return runner;
    };

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */
    Runner.run = function(runner, engine) {
        // create runner if engine is first argument
        if (typeof runner.positionIterations !== 'undefined') {
            engine = runner;
            runner = Runner.create();
        }

        (function render(time){
            runner.frameRequestId = _requestAnimationFrame(render);

            if (time && runner.enabled) {
                Runner.tick(runner, engine, time);
            }
        })();

        return runner;
    };

    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */
    Runner.tick = function(runner, engine, time) {
        var timing = engine.timing,
            correction = 1,
            delta;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(runner, 'beforeTick', event);
        Events.trigger(engine, 'beforeTick', event); // @deprecated

        if (runner.isFixed) {
            // fixed timestep
            delta = runner.delta;
        } else {
            // dynamic timestep based on wall clock between calls
            delta = (time - runner.timePrev) || runner.delta;
            runner.timePrev = time;

            // optimistically filter delta over a few frames, to improve stability
            runner.deltaHistory.push(delta);
            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
            delta = Math.min.apply(null, runner.deltaHistory);
            
            // limit delta
            delta = delta < runner.deltaMin ? runner.deltaMin : delta;
            delta = delta > runner.deltaMax ? runner.deltaMax : delta;

            // correction for delta
            correction = delta / runner.delta;

            // update engine timing object
            runner.delta = delta;
        }

        // time correction for time scaling
        if (runner.timeScalePrev !== 0)
            correction *= timing.timeScale / runner.timeScalePrev;

        if (timing.timeScale === 0)
            correction = 0;

        runner.timeScalePrev = timing.timeScale;
        runner.correction = correction;

        // fps counter
        runner.frameCounter += 1;
        if (time - runner.counterTimestamp >= 1000) {
            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
            runner.counterTimestamp = time;
            runner.frameCounter = 0;
        }

        Events.trigger(runner, 'tick', event);
        Events.trigger(engine, 'tick', event); // @deprecated

        // if world has been modified, clear the render scene graph
        if (engine.world.isModified 
            && engine.render
            && engine.render.controller
            && engine.render.controller.clear) {
            engine.render.controller.clear(engine.render); // @deprecated
        }

        // update
        Events.trigger(runner, 'beforeUpdate', event);
        Engine.update(engine, delta, correction);
        Events.trigger(runner, 'afterUpdate', event);

        // render
        // @deprecated
        if (engine.render && engine.render.controller) {
            Events.trigger(runner, 'beforeRender', event);
            Events.trigger(engine, 'beforeRender', event); // @deprecated

            engine.render.controller.world(engine.render);

            Events.trigger(runner, 'afterRender', event);
            Events.trigger(engine, 'afterRender', event); // @deprecated
        }

        Events.trigger(runner, 'afterTick', event);
        Events.trigger(engine, 'afterTick', event); // @deprecated
    };

    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */
    Runner.stop = function(runner) {
        _cancelAnimationFrame(runner.frameRequestId);
    };

    /**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */
    Runner.start = function(runner, engine) {
        Runner.run(runner, engine);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired at the start of a tick, before any updates to the engine or timing
    *
    * @event beforeTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine timing updated, but just before update
    *
    * @event tick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired at the end of a tick, after engine update and after rendering
    *
    * @event afterTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after update
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A flag that specifies whether the runner is running or not.
     *
     * @property enabled
     * @type boolean
     * @default true
     */

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     *
     * @property isFixed
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     *
     * @property delta
     * @type number
     * @default 1000 / 60
     */

})();


/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/

var Composites = {};

module.exports = Composites;

var Composite = __webpack_require__(23);
var Constraint = __webpack_require__(40);
var Common = __webpack_require__(0);
var Body = __webpack_require__(39);
var Bodies = __webpack_require__(80);

(function() {

    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        var stack = Composite.create({ label: 'Stack' }),
            x = xx,
            y = yy,
            lastBody,
            i = 0;

        for (var row = 0; row < rows; row++) {
            var maxHeight = 0;
            
            for (var column = 0; column < columns; column++) {
                var body = callback(x, y, column, row, lastBody, i);
                    
                if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,
                        bodyWidth = body.bounds.max.x - body.bounds.min.x; 

                    if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                    
                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });

                    x = body.bounds.max.x + columnGap;

                    Composite.addBody(stack, body);
                    
                    lastBody = body;
                    i += 1;
                } else {
                    x += columnGap;
                }
            }
            
            y += maxHeight + rowGap;
            x = xx;
        }

        return stack;
    };
    
    /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */
    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
        var bodies = composite.bodies;
        
        for (var i = 1; i < bodies.length; i++) {
            var bodyA = bodies[i - 1],
                bodyB = bodies[i],
                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,
                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, 
                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,
                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
        
            var defaults = {
                bodyA: bodyA,
                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                bodyB: bodyB,
                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
            };
            
            var constraint = Common.extend(defaults, options);
        
            Composite.addConstraint(composite, Constraint.create(constraint));
        }

        composite.label += ' Chain';
        
        return composite;
    };

    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */
    Composites.mesh = function(composite, columns, rows, crossBrace, options) {
        var bodies = composite.bodies,
            row,
            col,
            bodyA,
            bodyB,
            bodyC;
        
        for (row = 0; row < rows; row++) {
            for (col = 1; col < columns; col++) {
                bodyA = bodies[(col - 1) + (row * columns)];
                bodyB = bodies[col + (row * columns)];
                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));
            }

            if (row > 0) {
                for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + ((row - 1) * columns)];
                    bodyB = bodies[col + (row * columns)];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));

                    if (crossBrace && col > 0) {
                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }

                    if (crossBrace && col < columns - 1) {
                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }
                }
            }
        }

        composite.label += ' Mesh';
        
        return composite;
    };
    
    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
            var actualRows = Math.min(rows, Math.ceil(columns / 2)),
                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
            
            if (row > actualRows)
                return;
            
            // reverse row order
            row = actualRows - row;
            
            var start = row,
                end = columns - 1 - row;

            if (column < start || column > end)
                return;
            
            // retroactively fix the first body's position, since width was unknown
            if (i === 1) {
                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
            }

            var xOffset = lastBody ? column * lastBodyWidth : 0;
            
            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
        });
    };

    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */
    Composites.newtonsCradle = function(xx, yy, number, size, length) {
        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });

        for (var i = 0; i < number; i++) {
            var separation = 1.9,
                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, 
                            { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),
                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });

            Composite.addBody(newtonsCradle, circle);
            Composite.addConstraint(newtonsCradle, constraint);
        }

        return newtonsCradle;
    };
    
    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */
    Composites.car = function(xx, yy, width, height, wheelSize) {
        var group = Body.nextGroup(true),
            wheelBase = -20,
            wheelAOffset = -width * 0.5 + wheelBase,
            wheelBOffset = width * 0.5 - wheelBase,
            wheelYOffset = 0;
    
        var car = Composite.create({ label: 'Car' }),
            body = Bodies.trapezoid(xx, yy, width, height, 0.3, { 
                collisionFilter: {
                    group: group
                },
                friction: 0.01,
                chamfer: {
                    radius: 10
                }
            });
    
        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8,
            density: 0.01
        });
                    
        var axelA = Constraint.create({
            bodyA: body,
            pointA: { x: wheelAOffset, y: wheelYOffset },
            bodyB: wheelA,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
                        
        var axelB = Constraint.create({
            bodyA: body,
            pointA: { x: wheelBOffset, y: wheelYOffset },
            bodyB: wheelB,
            stiffness: 0.2,
            render: {
                lineWidth: 0
            }
        });
        
        Composite.addBody(car, body);
        Composite.addBody(car, wheelA);
        Composite.addBody(car, wheelB);
        Composite.addConstraint(car, axelA);
        Composite.addConstraint(car, axelB);

        return car;
    };

    /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */
    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
        constraintOptions = Common.extend({ stiffness: 0.4 }, constraintOptions);

        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
            return Bodies.circle(x, y, particleRadius, particleOptions);
        });

        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);

        softBody.label = 'Soft Body';

        return softBody;
    };

})();


/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/

var Svg = {};

module.exports = Svg;

var Bounds = __webpack_require__(7);

(function() {

    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */
    Svg.pathToVertices = function(path, sampleLength) {
        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
        var i, il, total, point, segment, segments, 
            segmentsQueue, lastSegment, 
            lastPoint, segmentIndex, points = [],
            lx, ly, length = 0, x = 0, y = 0;

        sampleLength = sampleLength || 15;

        var addPoint = function(px, py, pathSegType) {
            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;

            // when the last point doesn't equal the current point add the current point
            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                } else {
                    lx = 0;
                    ly = 0;
                }

                var point = {
                    x: lx + px,
                    y: ly + py
                };

                // set last point
                if (isRelative || !lastPoint) {
                    lastPoint = point;
                }

                points.push(point);

                x = lx + px;
                y = ly + py;
            }
        };

        var addSegmentPoint = function(segment) {
            var segType = segment.pathSegTypeAsLetter.toUpperCase();

            // skip path ends
            if (segType === 'Z') 
                return;

            // map segment to x and y
            switch (segType) {

            case 'M':
            case 'L':
            case 'T':
            case 'C':
            case 'S':
            case 'Q':
                x = segment.x;
                y = segment.y;
                break;
            case 'H':
                x = segment.x;
                break;
            case 'V':
                y = segment.y;
                break;
            }

            addPoint(x, y, segment.pathSegType);
        };

        // ensure path is absolute
        _svgPathToAbsolute(path);

        // get total length
        total = path.getTotalLength();

        // queue segments
        segments = [];
        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
            segments.push(path.pathSegList.getItem(i));

        segmentsQueue = segments.concat();

        // sample through path
        while (length < total) {
            // get segment at position
            segmentIndex = path.getPathSegAtLength(length);
            segment = segments[segmentIndex];

            // new segment
            if (segment != lastSegment) {
                while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());

                lastSegment = segment;
            }

            // add points in between when curving
            // TODO: adaptive sampling
            switch (segment.pathSegTypeAsLetter.toUpperCase()) {

            case 'C':
            case 'T':
            case 'S':
            case 'Q':
            case 'A':
                point = path.getPointAtLength(length);
                addPoint(point.x, point.y, 0);
                break;

            }

            // increment by sample value
            length += sampleLength;
        }

        // add remaining segments not passed by sampling
        for (i = 0, il = segmentsQueue.length; i < il; ++i)
            addSegmentPoint(segmentsQueue[i]);

        return points;
    };

    var _svgPathToAbsolute = function(path) {
        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,
            x = 0, y = 0, len = segs.numberOfItems;

        for (var i = 0; i < len; ++i) {
            var seg = segs.getItem(i),
                segType = seg.pathSegTypeAsLetter;

            if (/[MLHVCSQTA]/.test(segType)) {
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
            } else {
                if ('x1' in seg) x1 = x + seg.x1;
                if ('x2' in seg) x2 = x + seg.x2;
                if ('y1' in seg) y1 = y + seg.y1;
                if ('y2' in seg) y2 = y + seg.y2;
                if ('x' in seg) x += seg.x;
                if ('y' in seg) y += seg.y;

                switch (segType) {

                case 'm':
                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                    break;
                case 'l':
                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                    break;
                case 'h':
                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                    break;
                case 'v':
                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                    break;
                case 'c':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                    break;
                case 's':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                    break;
                case 'q':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                    break;
                case 't':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                    break;
                case 'a':
                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                    break;
                case 'z':
                case 'Z':
                    x = x0;
                    y = y0;
                    break;

                }
            }

            if (segType == 'M' || segType == 'm') {
                x0 = x;
                y0 = y;
            }
        }
    };

})();

/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

var Matter = module.exports = __webpack_require__(565);

Matter.Body = __webpack_require__(39);
Matter.Composite = __webpack_require__(23);
Matter.World = __webpack_require__(175);

Matter.Contact = __webpack_require__(176);
Matter.Detector = __webpack_require__(76);
Matter.Grid = __webpack_require__(77);
Matter.Pairs = __webpack_require__(177);
Matter.Pair = __webpack_require__(47);
Matter.Query = __webpack_require__(563);
Matter.Resolver = __webpack_require__(178);
Matter.SAT = __webpack_require__(78);

Matter.Constraint = __webpack_require__(40);
Matter.MouseConstraint = __webpack_require__(564);

Matter.Common = __webpack_require__(0);
Matter.Engine = __webpack_require__(179);
Matter.Events = __webpack_require__(24);
Matter.Mouse = __webpack_require__(79);
Matter.Runner = __webpack_require__(566);
Matter.Sleeping = __webpack_require__(41);
Matter.Plugin = __webpack_require__(181);

// @if DEBUG
Matter.Metrics = __webpack_require__(180);
// @endif

Matter.Bodies = __webpack_require__(80);
Matter.Composites = __webpack_require__(567);

Matter.Axes = __webpack_require__(81);
Matter.Bounds = __webpack_require__(7);
Matter.Svg = __webpack_require__(568);
Matter.Vector = __webpack_require__(8);
Matter.Vertices = __webpack_require__(25);

Matter.Render = __webpack_require__(82);
Matter.RenderPixi = __webpack_require__(570);

// aliases

Matter.World.add = Matter.Composite.add;
Matter.World.remove = Matter.Composite.remove;
Matter.World.addComposite = Matter.Composite.addComposite;
Matter.World.addBody = Matter.Composite.addBody;
Matter.World.addConstraint = Matter.Composite.addConstraint;
Matter.World.clear = Matter.Composite.clear;
Matter.Engine.run = Matter.Runner.run;


/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

/**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/

var RenderPixi = {};

module.exports = RenderPixi;

var Bounds = __webpack_require__(7);
var Composite = __webpack_require__(23);
var Common = __webpack_require__(0);
var Events = __webpack_require__(24);
var Vector = __webpack_require__(8);

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }
    
    /**
     * Creates a new Pixi.js WebGL renderer
     * @method create
     * @param {object} options
     * @return {RenderPixi} A new renderer
     * @deprecated
     */
    RenderPixi.create = function(options) {
        Common.warn('RenderPixi.create: Matter.RenderPixi is deprecated (see docs)');

        var defaults = {
            controller: RenderPixi,
            engine: null,
            element: null,
            frameRequestId: null,
            canvas: null,
            renderer: null,
            container: null,
            spriteContainer: null,
            pixiOptions: null,
            options: {
                width: 800,
                height: 600,
                background: '#fafafa',
                wireframeBackground: '#222',
                hasBounds: false,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false
            }
        };

        var render = Common.extend(defaults, options),
            transparent = !render.options.wireframes && render.options.background === 'transparent';

        // init pixi
        render.pixiOptions = render.pixiOptions || {
            view: render.canvas,
            transparent: transparent,
            antialias: true,
            backgroundColor: options.background
        };

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
        render.container = render.container || new PIXI.Container();
        render.spriteContainer = render.spriteContainer || new PIXI.Container();
        render.canvas = render.canvas || render.renderer.view;
        render.bounds = render.bounds || { 
            min: {
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.options.width,
                y: render.options.height
            }
        };

        // event listeners
        Events.on(render.engine, 'beforeUpdate', function() {
            RenderPixi.clear(render);
        });

        // caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // use a sprite batch for performance
        render.container.addChild(render.spriteContainer);

        // insert canvas
        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
        }

        // prevent menus on canvas
        render.canvas.oncontextmenu = function() { return false; };
        render.canvas.onselectstart = function() { return false; };

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     * @deprecated
     */
    RenderPixi.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            RenderPixi.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     * @deprecated
     */
    RenderPixi.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Clears the scene graph
     * @method clear
     * @param {RenderPixi} render
     * @deprecated
     */
    RenderPixi.clear = function(render) {
        var container = render.container,
            spriteContainer = render.spriteContainer;

        // clear stage container
        while (container.children[0]) { 
            container.removeChild(container.children[0]); 
        }

        // clear sprite batch
        while (spriteContainer.children[0]) { 
            spriteContainer.removeChild(spriteContainer.children[0]); 
        }

        var bgSprite = render.sprites['bg-0'];

        // clear caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // set background sprite
        render.sprites['bg-0'] = bgSprite;
        if (bgSprite)
            container.addChildAt(bgSprite, 0);

        // add sprite batch back into container
        render.container.addChild(render.spriteContainer);

        // reset background state
        render.currentBackground = null;

        // reset bounds transforms
        container.scale.set(1, 1);
        container.position.set(0, 0);
    };

    /**
     * Sets the background of the canvas 
     * @method setBackground
     * @param {RenderPixi} render
     * @param {string} background
     * @deprecated
     */
    RenderPixi.setBackground = function(render, background) {
        if (render.currentBackground !== background) {
            var isColor = background.indexOf && background.indexOf('#') !== -1,
                bgSprite = render.sprites['bg-0'];

            if (isColor) {
                // if solid background color
                var color = Common.colorToNumber(background);
                render.renderer.backgroundColor = color;

                // remove background sprite if existing
                if (bgSprite)
                    render.container.removeChild(bgSprite); 
            } else {
                // initialise background sprite if needed
                if (!bgSprite) {
                    var texture = _getTexture(render, background);

                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);
                    bgSprite.position.x = 0;
                    bgSprite.position.y = 0;
                    render.container.addChildAt(bgSprite, 0);
                }
            }

            render.currentBackground = background;
        }
    };

    /**
     * Description
     * @method world
     * @param {engine} engine
     * @deprecated
     */
    RenderPixi.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            renderer = render.renderer,
            container = render.container,
            options = render.options,
            bodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            constraints = [],
            i;

        if (options.wireframes) {
            RenderPixi.setBackground(render, options.wireframeBackground);
        } else {
            RenderPixi.setBackground(render, options.background);
        }

        // handle bounds
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        if (options.hasBounds) {
            // Hide bodies that are not in view
            for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
        } else {
            constraints = allConstraints;
        }

        for (i = 0; i < bodies.length; i++)
            RenderPixi.body(render, bodies[i]);

        for (i = 0; i < constraints.length; i++)
            RenderPixi.constraint(render, constraints[i]);

        renderer.render(container);
    };


    /**
     * Description
     * @method constraint
     * @param {engine} engine
     * @param {constraint} constraint
     * @deprecated
     */
    RenderPixi.constraint = function(render, constraint) {
        var engine = render.engine,
            bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB,
            container = render.container,
            constraintRender = constraint.render,
            primitiveId = 'c-' + constraint.id,
            primitive = render.primitives[primitiveId];

        // initialise constraint primitive if not existing
        if (!primitive)
            primitive = render.primitives[primitiveId] = new PIXI.Graphics();

        // don't render if constraint does not have two end points
        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
            primitive.clear();
            return;
        }

        // add to scene graph if not already there
        if (Common.indexOf(container.children, primitive) === -1)
            container.addChild(primitive);

        // render the constraint on every update, since they can change dynamically
        primitive.clear();
        primitive.beginFill(0, 0);
        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
        
        if (bodyA) {
            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
        } else {
            primitive.moveTo(pointA.x, pointA.y);
        }

        if (bodyB) {
            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
        } else {
            primitive.lineTo(pointB.x, pointB.y);
        }

        primitive.endFill();
    };
    
    /**
     * Description
     * @method body
     * @param {engine} engine
     * @param {body} body
     * @deprecated
     */
    RenderPixi.body = function(render, body) {
        var engine = render.engine,
            bodyRender = body.render;

        if (!bodyRender.visible)
            return;

        if (bodyRender.sprite && bodyRender.sprite.texture) {
            var spriteId = 'b-' + body.id,
                sprite = render.sprites[spriteId],
                spriteContainer = render.spriteContainer;

            // initialise body sprite if not existing
            if (!sprite)
                sprite = render.sprites[spriteId] = _createBodySprite(render, body);

            // add to scene graph if not already there
            if (Common.indexOf(spriteContainer.children, sprite) === -1)
                spriteContainer.addChild(sprite);

            // update body sprite
            sprite.position.x = body.position.x;
            sprite.position.y = body.position.y;
            sprite.rotation = body.angle;
            sprite.scale.x = bodyRender.sprite.xScale || 1;
            sprite.scale.y = bodyRender.sprite.yScale || 1;
        } else {
            var primitiveId = 'b-' + body.id,
                primitive = render.primitives[primitiveId],
                container = render.container;

            // initialise body primitive if not existing
            if (!primitive) {
                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                primitive.initialAngle = body.angle;
            }

            // add to scene graph if not already there
            if (Common.indexOf(container.children, primitive) === -1)
                container.addChild(primitive);

            // update body primitive
            primitive.position.x = body.position.x;
            primitive.position.y = body.position.y;
            primitive.rotation = body.angle - primitive.initialAngle;
        }
    };

    /**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */
    var _createBodySprite = function(render, body) {
        var bodyRender = body.render,
            texturePath = bodyRender.sprite.texture,
            texture = _getTexture(render, texturePath),
            sprite = new PIXI.Sprite(texture);

        sprite.anchor.x = body.render.sprite.xOffset;
        sprite.anchor.y = body.render.sprite.yOffset;

        return sprite;
    };

    /**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */
    var _createBodyPrimitive = function(render, body) {
        var bodyRender = body.render,
            options = render.options,
            primitive = new PIXI.Graphics(),
            fillStyle = Common.colorToNumber(bodyRender.fillStyle),
            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleWireframe = Common.colorToNumber('#bbb'),
            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),
            part;

        primitive.clear();

        // handle compound parts
        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
            part = body.parts[k];

            if (!options.wireframes) {
                primitive.beginFill(fillStyle, 1);
                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
            } else {
                primitive.beginFill(0, 0);
                primitive.lineStyle(1, strokeStyleWireframe, 1);
            }

            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            for (var j = 1; j < part.vertices.length; j++) {
                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
            }

            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            primitive.endFill();

            // angle indicator
            if (options.showAngleIndicator || options.showAxes) {
                primitive.beginFill(0, 0);

                if (options.wireframes) {
                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                } else {
                    primitive.lineStyle(1, strokeStyleIndicator);
                }

                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), 
                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));

                primitive.endFill();
            }
        }

        return primitive;
    };

    /**
     * Gets the requested texture (a PIXI.Texture) via its path
     * @method _getTexture
     * @private
     * @param {RenderPixi} render
     * @param {string} imagePath
     * @return {PIXI.Texture} texture
     * @deprecated
     */
    var _getTexture = function(render, imagePath) {
        var texture = render.textures[imagePath];

        if (!texture)
            texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);

        return texture;
    };

})();


/***/ },
/* 571 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function (fun /*, thisArg */)
    {
        'use strict';

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== 'function')
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}


/***/ },
/* 572 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}


/***/ },
/* 573 */
/***/ function(module, exports) {

/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*

This monkeypatch library is intended to be included in projects that are
written to the proper AudioContext spec (instead of webkitAudioContext),
and that use the new naming and proper bits of the Web Audio API (e.g.
using BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may
have to run on systems that only support the deprecated bits.

This library should be harmless to include if the browser supports
unprefixed "AudioContext", and/or if it supports the new names.

The patches this library handles:
if window.AudioContext is unsupported, it will be aliased to webkitAudioContext().
if AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or
noteGrainOn(), depending on parameters.

The following aliases only take effect if the new names are not already in place:

AudioBufferSourceNode.stop() is aliased to noteOff()
AudioContext.createGain() is aliased to createGainNode()
AudioContext.createDelay() is aliased to createDelayNode()
AudioContext.createScriptProcessor() is aliased to createJavaScriptNode()
AudioContext.createPeriodicWave() is aliased to createWaveTable()
OscillatorNode.start() is aliased to noteOn()
OscillatorNode.stop() is aliased to noteOff()
OscillatorNode.setPeriodicWave() is aliased to setWaveTable()
AudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()

This library does NOT patch the enumerated type changes, as it is
recommended in the specification that implementations support both integer
and string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel
BiquadFilterNode.type and OscillatorNode.type.

*/
(function (global, exports, perf) {
  'use strict';

  function fixSetTarget(param) {
    if (!param)	// if NYI, just return
      return;
    if (!param.setTargetAtTime)
      param.setTargetAtTime = param.setTargetValueAtTime;
  }

  if (window.hasOwnProperty('webkitAudioContext') &&
      !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;

    if (!AudioContext.prototype.hasOwnProperty('createGain'))
      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
    if (!AudioContext.prototype.hasOwnProperty('createDelay'))
      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))
      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;
    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))
      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;


    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;
    AudioContext.prototype.createGain = function() {
      var node = this.internal_createGain();
      fixSetTarget(node.gain);
      return node;
    };

    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;
    AudioContext.prototype.createDelay = function(maxDelayTime) {
      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();
      fixSetTarget(node.delayTime);
      return node;
    };

    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;
    AudioContext.prototype.createBufferSource = function() {
      var node = this.internal_createBufferSource();
      if (!node.start) {
        node.start = function ( when, offset, duration ) {
          if ( offset || duration )
            this.noteGrainOn( when || 0, offset, duration );
          else
            this.noteOn( when || 0 );
        };
      } else {
        node.internal_start = node.start;
        node.start = function( when, offset, duration ) {
          if( typeof duration !== 'undefined' )
            node.internal_start( when || 0, offset, duration );
          else
            node.internal_start( when || 0, offset || 0 );
        };
      }
      if (!node.stop) {
        node.stop = function ( when ) {
          this.noteOff( when || 0 );
        };
      } else {
        node.internal_stop = node.stop;
        node.stop = function( when ) {
          node.internal_stop( when || 0 );
        };
      }
      fixSetTarget(node.playbackRate);
      return node;
    };

    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;
    AudioContext.prototype.createDynamicsCompressor = function() {
      var node = this.internal_createDynamicsCompressor();
      fixSetTarget(node.threshold);
      fixSetTarget(node.knee);
      fixSetTarget(node.ratio);
      fixSetTarget(node.reduction);
      fixSetTarget(node.attack);
      fixSetTarget(node.release);
      return node;
    };

    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;
    AudioContext.prototype.createBiquadFilter = function() {
      var node = this.internal_createBiquadFilter();
      fixSetTarget(node.frequency);
      fixSetTarget(node.detune);
      fixSetTarget(node.Q);
      fixSetTarget(node.gain);
      return node;
    };

    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {
      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;
      AudioContext.prototype.createOscillator = function() {
        var node = this.internal_createOscillator();
        if (!node.start) {
          node.start = function ( when ) {
            this.noteOn( when || 0 );
          };
        } else {
          node.internal_start = node.start;
          node.start = function ( when ) {
            node.internal_start( when || 0);
          };
        }
        if (!node.stop) {
          node.stop = function ( when ) {
            this.noteOff( when || 0 );
          };
        } else {
          node.internal_stop = node.stop;
          node.stop = function( when ) {
            node.internal_stop( when || 0 );
          };
        }
        if (!node.setPeriodicWave)
          node.setPeriodicWave = node.setWaveTable;
        fixSetTarget(node.frequency);
        fixSetTarget(node.detune);
        return node;
      };
    }
  }

  if (window.hasOwnProperty('webkitOfflineAudioContext') &&
      !window.hasOwnProperty('OfflineAudioContext')) {
    window.OfflineAudioContext = webkitOfflineAudioContext;
  }

}(window));



/***/ },
/* 574 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}

/**
* A polyfill for Function.prototype.bind
*/
if (!Function.prototype.bind) {

    /* jshint freeze: false */
    Function.prototype.bind = (function () {

        var slice = Array.prototype.slice;

        return function (thisArg) {

            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function')
            {
                throw new TypeError();
            }

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto)
                {
                    F.prototype = proto;
                }

                if (!(this instanceof F))
                {
                    /* jshint supernew: true */
                    return new F;
                }
            })(target.prototype);

            return bound;
        };
    })();
}

/**
* A polyfill for Array.isArray
*/
if (!Array.isArray)
{
    Array.isArray = function (arg)
    {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/**
* A polyfill for Array.forEach
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
*/
if (!Array.prototype.forEach)
{
    Array.prototype.forEach = function(fun /*, thisArg */)
    {
        "use strict";

        if (this === void 0 || this === null)
        {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (typeof fun !== "function")
        {
            throw new TypeError();
        }

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

        for (var i = 0; i < len; i++)
        {
            if (i in t)
            {
                fun.call(thisArg, t[i], i, t);
            }
        }
    };
}

/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 575 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
if (!Math.trunc) {
    Math.trunc = function trunc(x) {
        return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
}


/***/ },
/* 576 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/


/**
* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9
* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/
* Cameron Foale (http://www.kibibu.com)
*/
if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object")
{
    var CheapArray = function(type)
    {
        var proto = new Array(); // jshint ignore:line

        window[type] = function(arg) {

            if (typeof(arg) === "number")
            {
                Array.call(this, arg);
                this.length = arg;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = 0;
                }
            }
            else
            {
                Array.call(this, arg.length);

                this.length = arg.length;

                for (var i = 0; i < this.length; i++)
                {
                    this[i] = arg[i];
                }
            }
        };

        window[type].prototype = proto;
        window[type].constructor = window[type];
    };

    CheapArray('Float32Array'); // jshint ignore:line
    CheapArray('Uint32Array'); // jshint ignore:line
    CheapArray('Uint16Array'); // jshint ignore:line
    CheapArray('Int16Array'); // jshint ignore:line
    CheapArray('ArrayBuffer'); // jshint ignore:line
}


/***/ },
/* 577 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * Also fix for the absent console in IE9
 */
if (!window.console)
{
    window.console = {};
    window.console.log = window.console.assert = function(){};
    window.console.warn = window.console.assert = function(){};
}


/***/ },
/* 578 */
/***/ function(module, exports) {

/**
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
 * performance.now
 */
(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }
  
  Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
  });

  if ("now" in window.performance == false)
  {
    var nowOffset = Date.now();
    
    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }
  }

})();


/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(89)))

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(2);
var DrawImage = __webpack_require__(582);
var BlitImage = __webpack_require__(581);
var GetBlendModes = __webpack_require__(583);
var GetContext = __webpack_require__(91);

var CanvasRenderer = function (game)
{
    /**
    * @property {Phaser.Game} game - A reference to the currently running Game.
    */
    this.game = game;

    //  Needed?
    this.type = CONST.CANVAS;

    this.drawCount = 0;

    //  Read all the following from game config (or State config?)
    // this.clearBeforeRender = true;
    // this.transparent = false;
    // this.autoResize = false;
    // this.smoothProperty = Phaser.Canvas.getSmoothingPrefix(this.context);
    // this.roundPixels = false;

    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;

    this.gameCanvas = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.gameContext = GetContext(this.gameCanvas);

    this.gameConfig = game.config;

    this.currentContext = this.gameContext;

    //  Map to the required function
    this.drawImage = DrawImage;
    this.blitImage = BlitImage;

    this.blendModes = GetBlendModes();

    this.currentAlpha = 1;
    this.currentBlendMode = 0;
    this.currentScaleMode = 0;

    // this.tintMethod = this.tintWithPerPixel;

    this.init();
};

CanvasRenderer.prototype.constructor = CanvasRenderer;

CanvasRenderer.prototype = {

    init: function ()
    {
        this.resize(this.width, this.height);
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.gameCanvas.width = this.width;
        this.gameCanvas.height = this.height;

        if (this.autoResize)
        {
            this.gameCanvas.style.width = (this.width / res) + 'px';
            this.gameCanvas.style.height = (this.height / res) + 'px';
        }

        // if (this.smoothProperty)
        // {
        //     this.gameContext[this.smoothProperty] = (this.scaleMode === ScaleModes.LINEAR);
        // }
    },

    resetTransform: function ()
    {
        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
    },

    setBlendMode: function (blendMode)
    {
        if (this.currentBlendMode !== blendMode)
        {
            this.currentContext.globalCompositeOperation = blendMode;
            this.currentBlendMode = blendMode;
        }

        return this.currentBlendMode;
    },

    setAlpha: function (alpha)
    {
        if (this.currentAlpha !== alpha)
        {
            this.currentContext.globalAlpha = alpha;
            this.currentAlpha = alpha;
        }

        return this.currentAlpha;
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        // console.log('%c render start ', 'color: #ffffff; background: #00ff00;');

        var ctx = this.gameContext;
        var config = this.gameConfig;

        var width = this.width;
        var height = this.height;

        if (config.clearBeforeRender)
        {
            ctx.clearRect(0, 0, width, height);
        }

        if (!config.transparent)
        {
            ctx.fillStyle = config.backgroundColor.rgba;
            ctx.fillRect(0, 0, width, height);
        }

        //  Add Pre-render hook

        this.drawCount = 0;
    },

    /**
     * Renders the State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        var w = state.sys.width;
        var h = state.sys.height;
        var ctx = state.sys.context;
        var settings = state.sys.settings;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== ctx.canvas.width || camera.height !== ctx.canvas.height);
        var list = children.list;

        this.currentContext = ctx;

        

        //  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)

        if (this.currentAlpha !== 1)
        {
            ctx.globalAlpha = 1;
            this.currentAlpha = 1;
        }

        if (this.currentBlendMode !== 0)
        {
            ctx.globalCompositeOperation = 'source-over';
            this.currentBlendMode = 0;
        }

        this.currentScaleMode = 0;

        if (settings.renderToTexture)
        {
            if (settings.clearBeforeRender)
            {
                ctx.clearRect(0, 0, w, h);
            }

            if (settings.backgroundColor)
            {
                ctx.fillStyle = settings.backgroundColor;
                ctx.fillRect(0, 0, w, h);
            }
        }

        this.drawCount += list.length;

        if (scissor)
        {
            ctx.save();
            ctx.beginPath();
            ctx.rect(camera.x, camera.y, camera.width, camera.height);
            ctx.clip();
            ctx.closePath();
        }

        var matrix = camera.matrix.matrix;
        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);

        for (var c = 0; c < list.length; c++)
        {
            var child = list[c];

            child.renderCanvas(this, child, interpolationPercentage, camera);
        }
        //  Call the State.render function
        state.render.call(state, ctx, interpolationPercentage);
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            // fade rendering
            ctx.fillStyle = 'rgb(' + (camera._fadeRed * 255) + ',' + (camera._fadeGreen * 255) + ',' + (camera._fadeBlue * 255) + ')';
            ctx.globalAlpha = camera._fadeAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            // flash rendering
            ctx.fillStyle = 'rgb(' + (camera._flashRed * 255) + ',' + (camera._flashGreen * 255) + ',' + (camera._flashBlue * 255) + ')';
            ctx.globalAlpha = camera._flashAlpha;
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            ctx.globalAlpha = 1.0;
        }

        //  Reset the camera scissor
        if (scissor)
        {
            ctx.restore();
        }
        
        //  Blast it to the Game Canvas (if needed)
        if (settings.renderToTexture)
        {
            this.gameContext.drawImage(state.sys.canvas, 0, 0, w, h, settings.x, settings.y, w, h);
        }
    },

    postRender: function ()
    {
        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');

        var ctx = this.gameContext;

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        this.currentAlpha = 1;
        this.currentBlendMode = 0;

        //  Add Post-render hook
    },

    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @method destroy
     * @param [removegameCanvas=true] {boolean} Removes the Canvas element from the DOM.
     */
    destroy: function ()
    {
        //  CanvasPool

        this.gameCanvas = null;
        this.gameContext = null;
    }

};

module.exports = CanvasRenderer;


/***/ },
/* 581 */
/***/ function(module, exports) {


//  No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas
var BlitImage = function (dx, dy, frame, camera)
{
    var ctx = this.currentContext;
    var cd = frame.canvasData;

    ctx.drawImage(
        frame.source.image,
        cd.sx,
        cd.sy,
        cd.sWidth,
        cd.sHeight,
        dx - camera.scrollX,
        dy - camera.scrollY,
        cd.dWidth,
        cd.dHeight
    );
};

module.exports = BlitImage;


/***/ },
/* 582 */
/***/ function(module, exports) {


var DrawImage = function (src, camera)
{
    var ctx = this.currentContext;
    var frame = src.frame;
    var cd = frame.canvasData;

    //  Blend Mode

    if (this.currentBlendMode !== src.blendMode)
    {
        this.currentBlendMode = src.blendMode;
        ctx.globalCompositeOperation = this.blendModes[src.blendMode];
    }

    //  Alpha

    if (this.currentAlpha !== src.alpha)
    {
        this.currentAlpha = src.alpha;
        ctx.globalAlpha = src.alpha;
    }

    //  Smoothing

    if (this.currentScaleMode !== src.scaleMode)
    {
        this.currentScaleMode = src.scaleMode;
        // ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);
    }

    var dx = frame.x - src.displayOriginX;
    var dy = frame.y - src.displayOriginY;

    ctx.save();
    ctx.translate(src.x - camera.scrollX, src.y - camera.scrollY);
    ctx.rotate(src.rotation);
    ctx.scale(src.scaleX, src.scaleY);
    ctx.scale(src.flipX ? -1 : 1, src.flipY ? -1 : 1);
    ctx.translate(src.dWidth * (src.flipX ? 1 : 0), src.dHeight * (src.flipY ? 1 : 0));
    ctx.drawImage(frame.source.image, cd.sx, cd.sy, cd.sWidth, cd.sHeight, dx, dy, cd.dWidth, cd.dHeight);
    ctx.restore();
};

module.exports = DrawImage;


/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

var modes = __webpack_require__(83);
var CanvasFeatures = __webpack_require__(93);

var GetBlendModes = function ()
{
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;

    output[modes.NORMAL] = 'source-over';
    output[modes.ADD] = 'lighter';
    output[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
    output[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
    output[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
    output[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
    output[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
    output[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
    output[modes.HUE] = (useNew) ? 'hue' : 'source-over';
    output[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
    output[modes.COLOR] = (useNew) ? 'color' : 'source-over';
    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

    return output;
};

module.exports = GetBlendModes;


/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey (@photonstorm)
* @author       Felipe Alfonso (@bitnenfer)
* @copyright    2017 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var CreateEmptyTexture = __webpack_require__(602);
var CreateTexture2DImage = __webpack_require__(183);
var BlitterBatch = __webpack_require__(589);
var AAQuadBatch = __webpack_require__(585);
var SpriteBatch = __webpack_require__(599);
var ShapeBatch = __webpack_require__(594);
var BlendModes = __webpack_require__(83);

var WebGLRenderer = function (game)
{
    this.game = game;
    this.type = CONST.WEBGL;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.resolution = game.config.resolution;
    this.view = game.canvas;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.contextLost = false;
    this.maxTextures = 1;
    this.multiTexture = false;
    this.blendModes = [];
    this.gl = null;
    this.extensions = null;
    this.batches = [];
    this.blitterBatch = null;
    this.aaQuadBatch = null;
    this.spriteBatch = null;
    this.shapeBatch = null;
    this.batch = null;
    this.currentTexture2D = null;

    this.init();
};

WebGLRenderer.prototype.constructor = WebGLRenderer;

WebGLRenderer.prototype = {

    init: function ()
    {
        console.log('WebGLRenderer.init');

        this.gl = this.view.getContext('webgl', this.config.WebGLContextOptions) || this.view.getContext('experimental-webgl', this.config.WebGLContextOptions);

        if (!this.gl)
        {
            this.contextLost = true;
            throw new Error('This browser does not support WebGL. Try using the Canvas renderer.');
        }

        var gl = this.gl;
        var color = this.game.config.backgroundColor;
    
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);

        this.resize(this.width, this.height);

        //  Map Blend Modes

        var add = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
        var normal = [ gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        var multiply = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
        var screen = [ gl.SRC_ALPHA, gl.ONE ];

        this.blendModes = [
            normal, add, multiply, screen, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal,
            normal, normal, normal, normal
        ];

        this.blendMode = -1;
        this.extensions = gl.getSupportedExtensions();
        this.blitterBatch = this.addBatch(new BlitterBatch(this.game, gl, this));
        this.aaQuadBatch = this.addBatch(new AAQuadBatch(this.game, gl, this));
        this.spriteBatch = this.addBatch(new SpriteBatch(this.game, gl, this));
        this.shapeBatch = this.addBatch(new ShapeBatch(this.game, gl, this));
    },

    createTexture2D: function (source)
    {
        var gl = this.gl;

        if (!source.glTexture)
        {
            source.glTexture = CreateTexture2DImage(gl, source.image, gl.NEAREST, 0);
        }

        this.currentTexture2D = source.glTexture;
    },

    setTexture2D: function (texture2D)
    {
        if (this.currentTexture2D !== texture2D)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            var gl = this.gl;

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture2D);

            this.currentTexture2D = texture2D;
        }
    },

    setBatch: function (batch, texture2D, camera)
    {
        var gl = this.gl;
        this.setTexture2D(texture2D);

        if (this.batch !== batch)
        {
            if (this.batch)
            {
                this.batch.flush();
            }

            batch.bind();

            this.batch = batch;
        }
    },

    resize: function (width, height)
    {
        var res = this.game.config.resolution;

        this.width = width * res;
        this.height = height * res;

        this.view.width = this.width;
        this.view.height = this.height;

        if (this.autoResize)
        {
            this.view.style.width = (this.width / res) + 'px';
            this.view.style.height = (this.height / res) + 'px';
        }

        this.gl.viewport(0, 0, this.width, this.height);
        for (var i = 0, l = this.batches.length; i < l; ++i)
        {
            this.batches[i].bind();
            this.batches[i].resize(width, height, resolution);
        }
        if (this.batch) 
        {
            this.batch.bind();
        }
    },

    //  Call at the start of the render loop
    preRender: function ()
    {
        //  No point rendering if our context has been blown up!
        if (this.contextLost)
        {
            return;
        }

        //  Add Pre-render hook

        var gl = this.gl;
        var color = this.game.config.backgroundColor;

        gl.clearColor(color.redGL, color.greenGL, color.blueGL, color.alphaGL);
        // Some drivers require to call glClear
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

        this.setBlendMode(BlendModes.NORMAL);
    },

    /**
     * Renders a single State.
     *
     * @method render
     * @param {Phaser.State} state - The State to be rendered.
     * @param {number} interpolationPercentage - The cumulative amount of time that hasn't been simulated yet, divided
     *   by the amount of time that will be simulated the next time update()
     *   runs. Useful for interpolating frames.
     */
    render: function (state, children, interpolationPercentage, camera)
    {
        //  Could move to the State Systems or MainLoop
        var gl = this.gl;
        var scissor = (camera.x !== 0 || camera.y !== 0 || camera.width !== gl.canvas.width || camera.height !== gl.canvas.height);

        if (scissor)
        {
            gl.enable(gl.SCISSOR_TEST);
            gl.scissor(camera.x, (gl.drawingBufferHeight - camera.y - camera.height), camera.width, camera.height);
        }
        // We could either clear color or render a quad
        gl.clear(gl.COLOR_BUFFER_BIT);

        var list = children.list;
        var length = list.length;
        for (var index = 0; index < length; ++index)
        {
            var child = list[index];
            // Setting blend mode if needed            
            var batch = this.batch;
            var newBlendMode = child.blendMode;
            if (this.blendMode !== newBlendMode)
            {
                if (batch) 
                {
                    batch.flush();
                }
                var blend = this.blendModes[newBlendMode];
                gl.enable(gl.BLEND);
                if (blend.length > 2)
                {
                    gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
                }
                else
                {
                    gl.blendFunc(blend[0], blend[1]);        
                }
                this.blendMode = newBlendMode;
            }
            // drawing child
            child.renderWebGL(this, child, interpolationPercentage, camera);
            batch = this.batch;
            if (batch && batch.isFull())
            {
                batch.flush();
            }
        }
        if (this.batch)
        {
            this.batch.flush();
        }
        if (camera._fadeAlpha > 0 || camera._flashAlpha > 0)
        {
            var aaQuadBatch = this.aaQuadBatch;
            aaQuadBatch.bind();
            // fade rendering
            aaQuadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._fadeRed, 
                camera._fadeGreen, 
                camera._fadeBlue, 
                camera._fadeAlpha
            );
            // flash rendering
            aaQuadBatch.add(
                camera.x, camera.y, camera.width, camera.height, 
                camera._flashRed, 
                camera._flashGreen, 
                camera._flashBlue, 
                camera._flashAlpha
            );
            aaQuadBatch.flush();
            this.batch.bind();
        }
        if (scissor)
        {
            gl.disable(gl.SCISSOR_TEST);
        }
    },

    //  Called at the end of the render loop (tidy things up, etc)
    postRender: function ()
    {
        if (this.batch)
        {
            this.batch.flush();
        }
        //  Add Post-render hook

        // console.log('%c render end ', 'color: #ffffff; background: #ff0000;');
    },

    destroy: function ()
    {
        this.gl = null;
    },

    createFBO: function () {},

    setBlendMode: function (newBlendMode)
    {
        var gl = this.gl;
        var batch = this.batch;
        var blend = null;

        if (this.blendMode !== newBlendMode)
        {
            if (batch)
                batch.flush();
            blend = this.blendModes[newBlendMode];
            gl.enable(gl.BLEND);
            if (blend.length > 2)
            {
                gl.blendFuncSeparate(blend[0], blend[1], blend[2], blend[3]);
            }
            else
            {
                gl.blendFunc(blend[0], blend[1]);        
            }
            this.blendMode = newBlendMode;
        }
    },

    addBatch: function (batchInstance)
    {
        var index = this.batches.indexOf(batchInstance);
        if (index < 0) 
        {
            this.batches.push(batchInstance);
            return batchInstance;
        }
        return null;
    },

    uploadCanvasToGPU: function (srcCanvas, dstTexture, shouldUpdateResource)
    {
        var gl = this.gl;

        if (!dstTexture)
        {
            /* only call this once */
            dstTexture = gl.createTexture();
        }
        
        if (shouldUpdateResource)
        {
            /* Update resource */
            gl.bindTexture(gl.TEXTURE_2D, dstTexture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
        }
        else
        {
            /* Allocate or Reallocate resource */
            gl.bindTexture(gl.TEXTURE_2D, dstTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        /* we must rebind old texture */
        gl.bindTexture(gl.TEXTURE_2D, this.currentTexture2D);

        return dstTexture;
    }
};

module.exports = WebGLRenderer;


/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(52);
var CreateProgram = __webpack_require__(50);
var CreateShader = __webpack_require__(51);
var CreateBuffer = __webpack_require__(49);
var CreateAttribDesc = __webpack_require__(53);
var Buffer32 = __webpack_require__(48);
var Buffer16 = __webpack_require__(84);
var VertexArray = __webpack_require__(54);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(588);

var AAQuadBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxQuads = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

AAQuadBatch.prototype.constructor = AAQuadBatch;

AAQuadBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.AAQUAD_VERTEX_COUNT * CONST.MAX_AAQUAD);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.AAQUAD_INDEX_COUNT * CONST.MAX_AAQUAD);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_color', 4, gl.FLOAT, false, CONST.VERTEX_SIZE, 8)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_AAQUAD * CONST.AAQUAD_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.AAQUAD_INDEX_COUNT, indexB += CONST.AAQUAD_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    add: function (x, y, width, height, red, green, blue, alpha)
    {
        // The user must check if the buffers are full before flushing
        // this is to give freedom of when should the renderer flush. var vertexDataBuffer = this.vertexDataBuffer;
        var vertexDataBuffer = this.vertexDataBuffer;
        var floatBuffer = vertexDataBuffer.floatView;
        var vertexOffset = vertexDataBuffer.allocate(CONST.AAQUAD_VERTEX_COMPONENT_COUNT * CONST.AAQUAD_VERTEX_COUNT);

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y + height;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        floatBuffer[vertexOffset++] = x + width;
        floatBuffer[vertexOffset++] = y;
        floatBuffer[vertexOffset++] = red;
        floatBuffer[vertexOffset++] = green;
        floatBuffer[vertexOffset++] = blue;
        floatBuffer[vertexOffset++] = alpha;

        this.elementCount += CONST.AAQUAD_INDEX_COUNT;
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }
};

module.exports = AAQuadBatch;


/***/ },
/* 586 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'varying vec4 v_color;',
    'void main() {',
    '   gl_FragColor = v_color;',
    '}'
].join('\n');


/***/ },
/* 587 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec4 a_color;',
    'varying vec4 v_color;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_color = a_color;',
    '}'
].join('\n');

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(586);
var VertexShader = __webpack_require__(587);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec4)
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    AAQUAD_VERTEX_COUNT: 4,
    AAQUAD_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    AAQUAD_VERTEX_COMPONENT_COUNT: 6,
    MAX_AAQUAD: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

//  Could you move these into sub-folders please, i.e. 'vao', 'shader' etc?

var BindVertexArray = __webpack_require__(52);
var CreateProgram = __webpack_require__(50);
var CreateShader = __webpack_require__(51);
var CreateBuffer = __webpack_require__(49);
var CreateAttribDesc = __webpack_require__(53);
var Buffer32 = __webpack_require__(48);
var Buffer16 = __webpack_require__(84);
var VertexArray = __webpack_require__(54);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(592);

var BlitterBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxParticles = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

BlitterBatch.prototype.constructor = BlitterBatch;

BlitterBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.PARTICLE_VERTEX_COUNT * CONST.MAX_PARTICLES);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.PARTICLE_INDEX_COUNT * CONST.MAX_PARTICLES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 16)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_PARTICLES * CONST.PARTICLE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxParticles = max;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.PARTICLE_INDEX_COUNT, indexB += CONST.PARTICLE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    }
};

module.exports = BlitterBatch;


/***/ },
/* 590 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(1.0, 1.0, 1.0, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 591 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute float a_alpha;',
    'varying vec2 v_tex_coord;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '	v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(590);
var VertexShader = __webpack_require__(591);

var CONST = {

    // VERTEX_SIZE = sizeof(vec2) + sizeof(vec2) + sizeof(float)
    VERTEX_SIZE: 20,
    INDEX_SIZE: 2,
    PARTICLE_VERTEX_COUNT: 4,
    PARTICLE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    PARTICLE_VERTEX_COMPONENT_COUNT: 5,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_PARTICLES: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 593 */
/***/ function(module, exports) {

module.exports = [
    'precision mediump float;',
    'varying vec4 v_color;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = vec4(v_color.bgr, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(52);
var CreateProgram = __webpack_require__(50);
var CreateShader = __webpack_require__(51);
var CreateBuffer = __webpack_require__(49);
var CreateAttribDesc = __webpack_require__(53);
var Buffer32 = __webpack_require__(48);
var VertexArray = __webpack_require__(54);
var Earcut = __webpack_require__(597);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(596);

var ShapeBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxVertices = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.vertexDataBuffer = null;
    this.vertexCount = 0;
    this.viewMatrixLocation = null;
    this.tempTriangle = [
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0},
        {x: 0, y: 0, width: 0, rgb: 0xFFFFFF, alpha: 1.0}
    ];

    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;
    this.context = null;
    this.init(this.glContext);

};

ShapeBatch.prototype.constructor = ShapeBatch;

ShapeBatch.prototype = {

    init: function (gl)
    {
        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.MAX_VERTICES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_color', 4, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 12)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var max = CONST.MAX_VERTICES;

        this.vertexDataBuffer = vertexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;
        this.maxVertices = max;
        this.polygonCache = [];

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        if (this.vertexCount > 0)
        {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
            gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
            vertexDataBuffer.clear();
            this.vertexCount = 0;
        }
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;
        
        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    },

    addLine: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* line properties */
        ax, ay, bx, by, aLineWidth, bLineWidth, aLineColor, bLineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }

        this.vertexCount += 6;

        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var dx = bx - ax;
        var dy = by - ay;
        var len = Math.sqrt(dx * dx + dy * dy);
        var al0 = aLineWidth * (by - ay) / len;
        var al1 = aLineWidth * (ax - bx) / len;
        var bl0 = bLineWidth * (by - ay) / len;
        var bl1 = bLineWidth * (ax - bx) / len;
        var lx0 = bx - bl0;
        var ly0 = by - bl1;
        var lx1 = ax - al0;
        var ly1 = ay - al1;
        var lx2 = bx + bl0;
        var ly2 = by + bl1;
        var lx3 = ax + al0;
        var ly3 = ay + al1;
        var x0 = lx0 * a + ly0 * c + e;
        var y0 = lx0 * b + ly0 * d + f;
        var x1 = lx1 * a + ly1 * c + e;
        var y1 = lx1 * b + ly1 * d + f;
        var x2 = lx2 * a + ly2 * c + e;
        var y2 = lx2 * b + ly2 * d + f;
        var x3 = lx3 * a + ly3 * c + e;
        var y3 = lx3 * b + ly3 * d + f;
        var vertexOffset = vertexDataBuffer.allocate(24);

        vertexBufferF32[vertexOffset++] = x0;
        vertexBufferF32[vertexOffset++] = y0;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x1;
        vertexBufferF32[vertexOffset++] = y1;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x3;
        vertexBufferF32[vertexOffset++] = y3;
        vertexBufferU32[vertexOffset++] = aLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;
        vertexBufferF32[vertexOffset++] = x2;
        vertexBufferF32[vertexOffset++] = y2;
        vertexBufferU32[vertexOffset++] = bLineColor;
        vertexBufferF32[vertexOffset++] = lineAlpha;

        return [
            x0, y0, bLineColor,
            x1, y1, aLineColor,
            x2, y2, bLineColor,
            x3, y3, aLineColor
        ];

    },

    addStrokePath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f,
        /* is last connection */
        isLastPath
    ) {
        var point0, point1;
        var pathLength = path.length;
        var polylines = this.polygonCache;
        var halfLineWidth = lineWidth * 0.5;
        var last, curr;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset;
        var x0, y0, x1, y1, x2, y2;
        var line;

        for (var pathIndex = 0; pathIndex + 1 < pathLength; pathIndex += 1)
        {
            point0 = path[pathIndex];
            point1 = path[pathIndex + 1];
            line = this.addLine(
                srcX, srcY, srcScaleX, srcScaleY, srcRotation,
                point0.x, point0.y, 
                point1.x, point1.y, 
                point0.width / 2, point1.width / 2, 
                point0.rgb, point1.rgb, lineAlpha,
                a, b, c, d, e, f
            );
            polylines.push(line);
        }

        /* Render joints */
        for (var index = 1, polylinesLength = polylines.length;
            index < polylinesLength; ++index)
        {

            if (this.vertexCount + 6 > this.maxVertices)
            {
                this.flush();
            }

            last = polylines[index - 1] || polylines[polylinesLength - 1];
            curr = polylines[index];
            vertexOffset = vertexDataBuffer.allocate(24)

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 3 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 3 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 0 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 0 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 0 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = last[3 * 2 + 0];
            vertexBufferF32[vertexOffset++] = last[3 * 2 + 1];
            vertexBufferU32[vertexOffset++] = last[3 * 2 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 0];
            vertexBufferF32[vertexOffset++] = curr[3 * 1 + 1];
            vertexBufferU32[vertexOffset++] = curr[3 * 1 + 2];
            vertexBufferF32[vertexOffset++] = lineAlpha;

            this.vertexCount += 6;
        }
        polylines.length = 0;
    },

    addFillPath: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Path properties */
        path, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        var length = path.length;
        var polygonCache = this.polygonCache;
        var polygonIndexArray;
        var point;
        var v0, v1, v2;
        var vertexOffset;
        var vertexCount = this.vertexCount;
        var maxVertices = this.maxVertices;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var x0, y0, x1, y1, x2, y2;
        var tx0, ty0, tx1, ty1, tx2, ty2;

        for (var pathIndex = 0; pathIndex < length; ++pathIndex)
        {
            point = path[pathIndex];
            polygonCache.push(point.x, point.y);
        }
        polygonIndexArray = Earcut(polygonCache);
        length = polygonIndexArray.length;

        for (var index = 0; index < length; index += 3)
        {
            v0 = polygonIndexArray[index + 0] * 2;
            v1 = polygonIndexArray[index + 1] * 2;
            v2 = polygonIndexArray[index + 2] * 2;

            if (vertexCount + 3 > maxVertices)
            {
                this.vertexCount = vertexCount;
                this.flush();
                vertexCount = 0;
            }
            vertexOffset = vertexDataBuffer.allocate(12);
            vertexCount += 3;

            x0 = polygonCache[v0 + 0];
            y0 = polygonCache[v0 + 1];
            x1 = polygonCache[v1 + 0];
            y1 = polygonCache[v1 + 1];
            x2 = polygonCache[v2 + 0];
            y2 = polygonCache[v2 + 1];

            tx0 = x0 * a + y0 * c + e;
            ty0 = x0 * b + y0 * d + f;
            tx1 = x1 * a + y1 * c + e;
            ty1 = x1 * b + y1 * d + f;
            tx2 = x2 * a + y2 * c + e;
            ty2 = x2 * b + y2 * d + f;

            vertexBufferF32[vertexOffset++] = tx0;
            vertexBufferF32[vertexOffset++] = ty0;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx1;
            vertexBufferF32[vertexOffset++] = ty1;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

            vertexBufferF32[vertexOffset++] = tx2;
            vertexBufferF32[vertexOffset++] = ty2;
            vertexBufferU32[vertexOffset++] = fillColor;
            vertexBufferF32[vertexOffset++] = fillAlpha;

        }
        this.vertexCount = vertexCount;
        polygonCache.length = 0;
    },

    addFillRect: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Rectangle properties */
        x, y, width, height, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 6 > this.maxVertices)
        {
            this.flush();
        }
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(24);
        var xw = x + width;
        var yh = y + height;
        var tx0 = x * a + y * c + e;
        var ty0 = x * b + y * d + f;
        var tx1 = x * a + yh * c + e;
        var ty1 = x * b + yh * d + f;
        var tx2 = xw * a + yh * c + e;
        var ty2 = xw * b + yh * d + f;
        var tx3 = xw * a + y * c + e;
        var ty3 = xw * b + y * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 6;
    },

    addFillTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, fillColor, fillAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        if (this.vertexCount + 3 > this.maxVertices)
        {
            this.flush();
        }
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = vertexDataBuffer.allocate(12);
        var tx0 = x0 * a + y0 * c + e;
        var ty0 = x0 * b + y0 * d + f;
        var tx1 = x1 * a + y1 * c + e;
        var ty1 = x1 * b + y1 * d + f;
        var tx2 = x2 * a + y2 * c + e;
        var ty2 = x2 * b + y2 * d + f;

        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferU32[vertexOffset++] = fillColor;
        vertexBufferF32[vertexOffset++] = fillAlpha;

        this.vertexCount += 3;
    },

    addStrokeTriangle: function (
        /* Graphics Game Object properties */
        srcX, srcY, srcScaleX, srcScaleY, srcRotation,
        /* Triangle properties */
        x0, y0, x1, y1, x2, y2, lineWidth, lineColor, lineAlpha,
        /* transform */
        a, b, c, d, e, f
    ) {
        var tempTriangle = this.tempTriangle;

        tempTriangle[0].x = x0;
        tempTriangle[0].y = y0;
        tempTriangle[0].width = lineWidth;
        tempTriangle[0].rgb = lineColor;
        tempTriangle[0].alpha = lineAlpha;
        tempTriangle[1].x = x1;
        tempTriangle[1].y = y1;
        tempTriangle[1].width = lineWidth;
        tempTriangle[1].rgb = lineColor;
        tempTriangle[1].alpha = lineAlpha;
        tempTriangle[2].x = x2;
        tempTriangle[2].y = y2;
        tempTriangle[2].width = lineWidth;
        tempTriangle[2].rgb = lineColor;
        tempTriangle[2].alpha = lineAlpha;
        tempTriangle[3].x = x0;
        tempTriangle[3].y = y0;
        tempTriangle[3].width = lineWidth;
        tempTriangle[3].rgb = lineColor;
        tempTriangle[3].alpha = lineAlpha;

        this.addStrokePath(
            srcX, srcY, srcScaleX, srcScaleY, srcRotation,
            tempTriangle, lineWidth, lineColor, lineAlpha,
            a, b, c, d, e, f
        );
    }
};

module.exports = ShapeBatch;


/***/ },
/* 595 */
/***/ function(module, exports) {

module.exports = [
    'precision mediump float;',
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec4 a_color;',
    'attribute float a_alpha;',
    'varying vec4 v_color;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_color = a_color;',
    '   v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 596 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(593);
var VertexShader = __webpack_require__(595);

var CONST = {

    VERTEX_SIZE: 16,

    // How many 32-bit components does the vertex have.
    SHAPE_VERTEX_COMPONENT_COUNT: 4,

    // Can't be bigger than 10,000 since index are 16-bit
    MAX_VERTICES: 16000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 597 */
/***/ function(module, exports, __webpack_require__) {

var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.earcut=e()}}(function(){return function e(n,t,r){function x(u,f){if(!t[u]){if(!n[u]){var o="function"==typeof require&&require;if(!f&&o)return require(u,!0);if(i)return i(u,!0);var v=new Error("Cannot find module '"+u+"'");throw v.code="MODULE_NOT_FOUND",v}var l=t[u]={exports:{}};n[u][0].call(l.exports,function(e){var t=n[u][1][e];return x(t?t:e)},l,l.exports,e,n,t,r)}return t[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)x(r[u]);return x}({1:[function(e,n,t){"use strict";function r(e,n,t){t=t||2;var r=n&&n.length,i=r?n[0]*t:e.length,f=x(e,0,i,t,!0),o=[];if(!f)return o;var v,l,p,a,h,s,c;if(r&&(f=y(e,n,f,t)),e.length>80*t){v=p=e[0],l=a=e[1];for(var d=t;i>d;d+=t)h=e[d],s=e[d+1],v>h&&(v=h),l>s&&(l=s),h>p&&(p=h),s>a&&(a=s);c=Math.max(p-v,a-l)}return u(f,o,t,v,l,c),o}function x(e,n,t,r,x){var i,u;if(x===_(e,n,t,r)>0)for(i=n;t>i;i+=r)u=E(i,e[i],e[i+1],u);else for(i=t-r;i>=n;i-=r)u=E(i,e[i],e[i+1],u);return u&&z(u,u.next)&&(N(u),u=u.next),u}function i(e,n){if(!e)return e;n||(n=e);var t,r=e;do if(t=!1,r.steiner||!z(r,r.next)&&0!==b(r.prev,r,r.next))r=r.next;else{if(N(r),r=n=r.prev,r===r.next)return null;t=!0}while(t||r!==n);return n}function u(e,n,t,r,x,y,p){if(e){!p&&y&&s(e,r,x,y);for(var a,h,c=e;e.prev!==e.next;)if(a=e.prev,h=e.next,y?o(e,r,x,y):f(e))n.push(a.i/t),n.push(e.i/t),n.push(h.i/t),N(e),e=h.next,c=h.next;else if(e=h,e===c){p?1===p?(e=v(e,n,t),u(e,n,t,r,x,y,2)):2===p&&l(e,n,t,r,x,y):u(i(e),n,t,r,x,y,1);break}}}function f(e){var n=e.prev,t=e,r=e.next;if(b(n,t,r)>=0)return!1;for(var x=e.next.next;x!==e.prev;){if(g(n.x,n.y,t.x,t.y,r.x,r.y,x.x,x.y)&&b(x.prev,x,x.next)>=0)return!1;x=x.next}return!0}function o(e,n,t,r){var x=e.prev,i=e,u=e.next;if(b(x,i,u)>=0)return!1;for(var f=x.x<i.x?x.x<u.x?x.x:u.x:i.x<u.x?i.x:u.x,o=x.y<i.y?x.y<u.y?x.y:u.y:i.y<u.y?i.y:u.y,v=x.x>i.x?x.x>u.x?x.x:u.x:i.x>u.x?i.x:u.x,l=x.y>i.y?x.y>u.y?x.y:u.y:i.y>u.y?i.y:u.y,y=d(f,o,n,t,r),p=d(v,l,n,t,r),a=e.nextZ;a&&a.z<=p;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.nextZ}for(a=e.prevZ;a&&a.z>=y;){if(a!==e.prev&&a!==e.next&&g(x.x,x.y,i.x,i.y,u.x,u.y,a.x,a.y)&&b(a.prev,a,a.next)>=0)return!1;a=a.prevZ}return!0}function v(e,n,t){var r=e;do{var x=r.prev,i=r.next.next;!z(x,i)&&M(x,r,r.next,i)&&q(x,i)&&q(i,x)&&(n.push(x.i/t),n.push(r.i/t),n.push(i.i/t),N(r),N(r.next),r=e=i),r=r.next}while(r!==e);return r}function l(e,n,t,r,x,f){var o=e;do{for(var v=o.next.next;v!==o.prev;){if(o.i!==v.i&&w(o,v)){var l=D(o,v);return o=i(o,o.next),l=i(l,l.next),u(o,n,t,r,x,f),void u(l,n,t,r,x,f)}v=v.next}o=o.next}while(o!==e)}function y(e,n,t,r){var u,f,o,v,l,y=[];for(u=0,f=n.length;f>u;u++)o=n[u]*r,v=f-1>u?n[u+1]*r:e.length,l=x(e,o,v,r,!1),l===l.next&&(l.steiner=!0),y.push(Z(l));for(y.sort(p),u=0;u<y.length;u++)a(y[u],t),t=i(t,t.next);return t}function p(e,n){return e.x-n.x}function a(e,n){if(n=h(e,n)){var t=D(n,e);i(t,t.next)}}function h(e,n){var t,r=n,x=e.x,i=e.y,u=-(1/0);do{if(i<=r.y&&i>=r.next.y){var f=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(x>=f&&f>u){if(u=f,f===x){if(i===r.y)return r;if(i===r.next.y)return r.next}t=r.x<r.next.x?r:r.next}}r=r.next}while(r!==n);if(!t)return null;if(x===u)return t.prev;var o,v=t,l=t.x,y=t.y,p=1/0;for(r=t.next;r!==v;)x>=r.x&&r.x>=l&&g(y>i?x:u,i,l,y,y>i?u:x,i,r.x,r.y)&&(o=Math.abs(i-r.y)/(x-r.x),(p>o||o===p&&r.x>t.x)&&q(r,e)&&(t=r,p=o)),r=r.next;return t}function s(e,n,t,r){var x=e;do null===x.z&&(x.z=d(x.x,x.y,n,t,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next;while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,c(x)}function c(e){var n,t,r,x,i,u,f,o,v=1;do{for(t=e,e=null,i=null,u=0;t;){for(u++,r=t,f=0,n=0;v>n&&(f++,r=r.nextZ,r);n++);for(o=v;f>0||o>0&&r;)0===f?(x=r,r=r.nextZ,o--):0!==o&&r?t.z<=r.z?(x=t,t=t.nextZ,f--):(x=r,r=r.nextZ,o--):(x=t,t=t.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;t=r}i.nextZ=null,v*=2}while(u>1);return e}function d(e,n,t,r,x){return e=32767*(e-t)/x,n=32767*(n-r)/x,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),e|n<<1}function Z(e){var n=e,t=e;do n.x<t.x&&(t=n),n=n.next;while(n!==e);return t}function g(e,n,t,r,x,i,u,f){return(x-u)*(n-f)-(e-u)*(i-f)>=0&&(e-u)*(r-f)-(t-u)*(n-f)>=0&&(t-u)*(i-f)-(x-u)*(r-f)>=0}function w(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!m(e,n)&&q(e,n)&&q(n,e)&&O(e,n)}function b(e,n,t){return(n.y-e.y)*(t.x-n.x)-(n.x-e.x)*(t.y-n.y)}function z(e,n){return e.x===n.x&&e.y===n.y}function M(e,n,t,r){return z(e,n)&&z(t,r)||z(e,r)&&z(t,n)?!0:b(e,n,t)>0!=b(e,n,r)>0&&b(t,r,e)>0!=b(t,r,n)>0}function m(e,n){var t=e;do{if(t.i!==e.i&&t.next.i!==e.i&&t.i!==n.i&&t.next.i!==n.i&&M(t,t.next,e,n))return!0;t=t.next}while(t!==e);return!1}function q(e,n){return b(e.prev,e,e.next)<0?b(e,n,e.next)>=0&&b(e,e.prev,n)>=0:b(e,n,e.prev)<0||b(e,e.next,n)<0}function O(e,n){var t=e,r=!1,x=(e.x+n.x)/2,i=(e.y+n.y)/2;do t.y>i!=t.next.y>i&&x<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==e);return r}function D(e,n){var t=new U(e.i,e.x,e.y),r=new U(n.i,n.x,n.y),x=e.next,i=n.prev;return e.next=n,n.prev=e,t.next=x,x.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function E(e,n,t,r){var x=new U(e,n,t);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function N(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function U(e,n,t){this.i=e,this.x=n,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function _(e,n,t,r){for(var x=0,i=n,u=t-r;t>i;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}n.exports=r,r.deviation=function(e,n,t,r){var x=n&&n.length,i=x?n[0]*t:e.length,u=Math.abs(_(e,0,i,t));if(x)for(var f=0,o=n.length;o>f;f++){var v=n[f]*t,l=o-1>f?n[f+1]*t:e.length;u-=Math.abs(_(e,v,l,t))}var y=0;for(f=0;f<r.length;f+=3){var p=r[f]*t,a=r[f+1]*t,h=r[f+2]*t;y+=Math.abs((e[p]-e[h])*(e[a+1]-e[p+1])-(e[p]-e[a])*(e[h+1]-e[p+1]))}return 0===u&&0===y?0:Math.abs((y-u)/u)},r.flatten=function(e){for(var n=e[0][0].length,t={vertices:[],holes:[],dimensions:n},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;n>u;u++)t.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,t.holes.push(r))}return t}},{}]},{},[1])(1)});

/***/ },
/* 598 */
/***/ function(module, exports) {

module.exports = [
    'precision lowp float;',
    'uniform sampler2D u_sampler2D;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'varying float v_alpha;',
    'void main() {',
    '   gl_FragColor = texture2D(u_sampler2D, v_tex_coord) * vec4(v_color, v_alpha);',
    '}'
].join('\n');


/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

var BindVertexArray = __webpack_require__(52);
var CreateProgram = __webpack_require__(50);
var CreateShader = __webpack_require__(51);
var CreateBuffer = __webpack_require__(49);
var CreateAttribDesc = __webpack_require__(53);
var Buffer32 = __webpack_require__(48);
var Buffer16 = __webpack_require__(84);
var VertexArray = __webpack_require__(54);
var TransformMatrix = __webpack_require__(29);

var PHASER_CONST = __webpack_require__(2);
var CONST = __webpack_require__(601);

var SpriteBatch = function (game, gl, manager)
{
    this.game = game;
    this.type = PHASER_CONST.WEBGL;
    this.view = game.canvas;
    this.resolution = game.config.resolution;
    this.width = game.config.width * game.config.resolution;
    this.height = game.config.height * game.config.resolution;
    this.glContext = gl;
    this.maxSprites = null;
    this.vertShader = null;
    this.fragShader = null;
    this.program = null;
    this.vertexArray = null;
    this.indexBufferObject = null;
    this.vertexDataBuffer = null;
    this.indexDataBuffer = null;
    this.elementCount = 0;
    this.currentTexture2D = null;
    this.viewMatrixLocation = null;
    this.tempMatrix = new TransformMatrix();
    //   All of these settings will be able to be controlled via the Game Config
    this.config = {
        clearBeforeRender: true,
        transparent: false,
        autoResize: false,
        preserveDrawingBuffer: false,

        WebGLContextOptions: {
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        }
    };

    this.manager = manager;
    this.dirty = false;

    this.init(this.glContext);
};

SpriteBatch.prototype.constructor = SpriteBatch;

SpriteBatch.prototype = {

    init: function (gl)
    {

        var vertexDataBuffer = new Buffer32(CONST.VERTEX_SIZE * CONST.SPRITE_VERTEX_COUNT * CONST.MAX_SPRITES);
        var indexDataBuffer = new Buffer16(CONST.INDEX_SIZE * CONST.SPRITE_INDEX_COUNT * CONST.MAX_SPRITES);
        var vertShader = CreateShader(gl, CONST.VERTEX_SHADER_SOURCE, gl.VERTEX_SHADER);
        var fragShader = CreateShader(gl, CONST.FRAGMENT_SHADER_SOURCE, gl.FRAGMENT_SHADER);
        var program = CreateProgram(gl, vertShader, fragShader);
        var indexBufferObject = CreateBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, null, indexDataBuffer.getByteCapacity());
        var attribArray = [
            CreateAttribDesc(gl, program, 'a_position', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 0),
            CreateAttribDesc(gl, program, 'a_tex_coord', 2, gl.FLOAT, false, CONST.VERTEX_SIZE, 8),
            CreateAttribDesc(gl, program, 'a_color', 3, gl.UNSIGNED_BYTE, true, CONST.VERTEX_SIZE, 16),
            CreateAttribDesc(gl, program, 'a_alpha', 1, gl.FLOAT, false, CONST.VERTEX_SIZE, 20)
        ];
        var vertexArray = new VertexArray(CreateBuffer(gl, gl.ARRAY_BUFFER, gl.STREAM_DRAW, null, vertexDataBuffer.getByteCapacity()), attribArray);
        var viewMatrixLocation = gl.getUniformLocation(program, 'u_view_matrix');
        var indexBuffer = indexDataBuffer.uintView;
        var max = CONST.MAX_SPRITES * CONST.SPRITE_INDEX_COUNT;

        this.vertexDataBuffer = vertexDataBuffer;
        this.indexDataBuffer = indexDataBuffer;
        this.vertShader = vertShader;
        this.fragShader = fragShader;
        this.program = program;
        this.indexBufferObject = indexBufferObject;
        this.vertexArray = vertexArray;
        this.viewMatrixLocation = viewMatrixLocation;

        // Populate the index buffer only once
        for (var indexA = 0, indexB = 0; indexA < max; indexA += CONST.SPRITE_INDEX_COUNT, indexB += CONST.SPRITE_VERTEX_COUNT)
        {
            indexBuffer[indexA + 0] = indexB + 0;
            indexBuffer[indexA + 1] = indexB + 1;
            indexBuffer[indexA + 2] = indexB + 2;
            indexBuffer[indexA + 3] = indexB + 0;
            indexBuffer[indexA + 4] = indexB + 2;
            indexBuffer[indexA + 5] = indexB + 3;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, indexBuffer);

        this.bind();
        this.resize(this.width, this.height, this.game.config.resolution);
        this.unbind();
    },

    isFull: function ()
    {
        return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());
    },

    bind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(this.program);
        gl.clearColor(0, 0, 0, 1);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBufferObject);
        BindVertexArray(gl, this.vertexArray);
    },

    unbind: function ()
    {
        var gl = this.glContext;

        gl.useProgram(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },

    flush: function ()
    {
        if (this.elementCount === 0)
        {
            return;
        }

        var gl = this.glContext;
        var vertexDataBuffer = this.vertexDataBuffer;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexDataBuffer.getUsedBufferAsFloat());
        gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);
        vertexDataBuffer.clear();

        this.elementCount = 0;
    },

    resize: function (width, height, resolution)
    {
        var gl = this.glContext;
        
        this.width = width * resolution;
        this.height = height * resolution;

        gl.uniformMatrix4fv(
            this.viewMatrixLocation,
            false,
            new Float32Array([
                2 / this.width, 0, 0, 0,
                0, -2 / this.height, 0, 0,
                0, 0, 1, 1,
                -1, 1, 0, 0
            ])
        );
    },

    destroy: function ()
    {
        var gl = this.glContext;

        if (gl)
        {
            gl.deleteShader(this.vertShader);
            gl.deleteShader(this.fragShader);
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.indexBufferObject);
            gl.deleteBuffer(this.vertexArray.buffer);
        }
    },

    addSpriteTexture: function (src, camera, texture, textureWidth, textureHeight)
    {
        var tempMatrix = this.tempMatrix;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var width = textureWidth * (src.flipX ? -1 : 1);
        var height = textureHeight * (src.flipY ? -1 : 1);
        var translateX = src.x - camera.scrollX;
        var translateY = src.y - camera.scrollY;
        var scaleX = src.scaleX;
        var scaleY = src.scaleY;
        var rotation = -src.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -src.displayOriginX + ((textureWidth) * (src.flipX ? 1 : 0.0));
        var y = -src.displayOriginY + ((textureHeight) * (src.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = src.alpha;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setBatch(this, texture, camera);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferF32[vertexOffset++] = 0;
        vertexBufferF32[vertexOffset++] = 0;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferF32[vertexOffset++] = 0;
        vertexBufferF32[vertexOffset++] = 1;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferF32[vertexOffset++] = 1;
        vertexBufferF32[vertexOffset++] = 1;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferF32[vertexOffset++] = 1;
        vertexBufferF32[vertexOffset++] = 0;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
        vertexBufferF32[vertexOffset++] = alpha;
    },

    addSprite: function (src, camera)
    {
        var tempMatrix = this.tempMatrix;
        var frame = src.frame;
        var alpha = 16777216;
        var vertexDataBuffer = this.vertexDataBuffer;
        var vertexBufferF32 = vertexDataBuffer.floatView;
        var vertexBufferU32 = vertexDataBuffer.uintView;
        var vertexOffset = 0;
        var uvs = frame.uvs;
        var width = frame.width * (src.flipX ? -1 : 1);
        var height = frame.height * (src.flipY ? -1 : 1);
        var translateX = src.x - camera.scrollX;
        var translateY = src.y - camera.scrollY;
        var scaleX = src.scaleX;
        var scaleY = src.scaleY;
        var rotation = -src.rotation;
        var tempMatrixMatrix = tempMatrix.matrix;
        var x = -src.displayOriginX + frame.x + ((frame.width) * (src.flipX ? 1 : 0.0));
        var y = -src.displayOriginY + frame.y + ((frame.height) * (src.flipY ? 1 : 0.0));
        var xw = x + width;
        var yh = y + height;
        var cameraMatrix = camera.matrix.matrix;
        var mva, mvb, mvc, mvd, mve, mvf, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3;
        var sra, srb, src, srd, sre, srf, cma, cmb, cmc, cmd, cme, cmf;
        var alpha = src.alpha;

        tempMatrix.applyITRS(translateX, translateY, rotation, scaleX, scaleY);

        sra = tempMatrixMatrix[0];
        srb = tempMatrixMatrix[1];
        src = tempMatrixMatrix[2];
        srd = tempMatrixMatrix[3];
        sre = tempMatrixMatrix[4];
        srf = tempMatrixMatrix[5];

        cma = cameraMatrix[0];
        cmb = cameraMatrix[1];
        cmc = cameraMatrix[2];
        cmd = cameraMatrix[3];
        cme = cameraMatrix[4];
        cmf = cameraMatrix[5];

        mva = sra * cma + srb * cmc;
        mvb = sra * cmb + srb * cmd;
        mvc = src * cma + srd * cmc;
        mvd = src * cmb + srd * cmd;
        mve = sre * cma + srf * cmc + cme;
        mvf = sre * cmb + srf * cmd + cmf; 
        
        tx0 = x * mva + y * mvc + mve;
        ty0 = x * mvb + y * mvd + mvf;
        tx1 = x * mva + yh * mvc + mve;
        ty1 = x * mvb + yh * mvd + mvf;
        tx2 = xw * mva + yh * mvc + mve;
        ty2 = xw * mvb + yh * mvd + mvf;
        tx3 = xw * mva + y * mvc + mve;
        ty3 = xw * mvb + y * mvd + mvf;

        this.manager.setBatch(this, frame.texture.source[frame.sourceIndex].glTexture, camera);
        vertexOffset = vertexDataBuffer.allocate(24);
        this.elementCount += 6;
        
        vertexBufferF32[vertexOffset++] = tx0;
        vertexBufferF32[vertexOffset++] = ty0;
        vertexBufferF32[vertexOffset++] = uvs.x0;
        vertexBufferF32[vertexOffset++] = uvs.y0;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topLeft;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx1;
        vertexBufferF32[vertexOffset++] = ty1;
        vertexBufferF32[vertexOffset++] = uvs.x1;
        vertexBufferF32[vertexOffset++] = uvs.y1;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomLeft;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx2;
        vertexBufferF32[vertexOffset++] = ty2;
        vertexBufferF32[vertexOffset++] = uvs.x2;
        vertexBufferF32[vertexOffset++] = uvs.y2;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.bottomRight;
        vertexBufferF32[vertexOffset++] = alpha;

        vertexBufferF32[vertexOffset++] = tx3;
        vertexBufferF32[vertexOffset++] = ty3;
        vertexBufferF32[vertexOffset++] = uvs.x3;
        vertexBufferF32[vertexOffset++] = uvs.y3;
        vertexBufferU32[vertexOffset++] = 0xFFFFFF; //vertexColor.topRight;
        vertexBufferF32[vertexOffset++] = alpha;
    }

};

module.exports = SpriteBatch;


/***/ },
/* 600 */
/***/ function(module, exports) {

module.exports = [
    'uniform mat4 u_view_matrix;',
    'attribute vec2 a_position;',
    'attribute vec2 a_tex_coord;',
    'attribute vec3 a_color;',
    'attribute float a_alpha;',
    'varying vec2 v_tex_coord;',
    'varying vec3 v_color;',
    'varying float v_alpha;',
    'void main () {',
    '   gl_Position = u_view_matrix * vec4(a_position, 1.0, 1.0);',
    '   v_tex_coord = a_tex_coord;',
    '   v_color = a_color;',
    '   v_alpha = a_alpha;',
    '}'
].join('\n');


/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

var FragmentShader = __webpack_require__(598);
var VertexShader = __webpack_require__(600);

var CONST = {

    // VERTEX_SIZE = (sizeof(vec2) * 4) + (sizeof(float) + sizeof(uint32))
    VERTEX_SIZE: 24,
    INDEX_SIZE: 2,
    SPRITE_VERTEX_COUNT: 4,
    SPRITE_INDEX_COUNT: 6,

    // How many 32-bit components does the vertex have.
    SPRITE_VERTEX_COMPONENT_COUNT: 6,

    // Can't be bigger since index are 16-bit
    MAX_SPRITES: 2000,

    VERTEX_SHADER_SOURCE: VertexShader,
    FRAGMENT_SHADER_SOURCE: FragmentShader

};

module.exports = CONST;


/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(42);

var CreateEmptyTexture = function (gl, width, height, scaleMode, textureIndex)
{
    var texture = gl.createTexture();
    var glScaleMode = (scaleMode === ScaleModes.LINEAR) ? gl.LINEAR : gl.NEAREST;

    gl.activeTexture(gl.TEXTURE0 + textureIndex);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    //  We'll read from this texture, but it won't have mipmaps, so turn them off:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glScaleMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glScaleMode);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    return texture;
};

module.exports = CreateEmptyTexture;


/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

var ScaleModes = __webpack_require__(42);
var CreateTexture2DImage = __webpack_require__(183);

var CreateTexture2DFromSource = function (gl, source)
{
    var filter;

    if (source.scaleMode === ScaleModes.LINEAR)
    {
        filter = gl.LINEAR;
    }
    else if (source.scaleMode === ScaleModes.NEAREST)
    {
        filter = gl.NEAREST;
    }

    source.glTexture = CreateTexture2DImage(gl, source.image, filter, source.mipmapLevel)
};

module.exports = CreateTexture2DFromSource;


/***/ },
/* 604 */
/***/ function(module, exports) {

var Attribute = function (location, size, type, normalized, stride, offset)
{
    this.location = location;
    this.size = size;
    this.type = type;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
};

module.exports = Attribute;


/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {


var Between = __webpack_require__(73);
var GetObjectValue = __webpack_require__(9);

//  Phaser.Sound.Dynamic.FX

//  Based on Sound.js by KittyKatAttack
//  https://github.com/kittykatattack/sound.js

// frequency,      //The sound's fequency pitch in Hertz
// attack,              //The time, in seconds, to fade the sound in
// decay,               //The time, in seconds, to fade the sound out
// type,                //waveform type: "sine", "triangle", "square", "sawtooth"
// volume,         //The sound's maximum volume
// panValue,            //The speaker pan. left: -1, middle: 0, right: 1
// wait,                //The time, in seconds, to wait before playing the sound
// pitchBend,     //The number of Hz in which to bend the sound's pitch down
// reverse,             //If `reverse` is true the pitch will bend up
// random,         //A range, in Hz, within which to randomize the pitch
// dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch
// echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]
// reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]
// timeout              //A number, in seconds, which is the maximum duration for sound effects

var FX = function (ctx, config)
{
    this.audioContext = ctx;

    this.frequencyValue = GetObjectValue(config, 'frequency', 200);
    this.attack = GetObjectValue(config, 'attack', 0);
    this.decay = GetObjectValue(config, 'decay', 1);
    this.type = GetObjectValue(config, 'type', 'sine');
    this.volumeValue = GetObjectValue(config, 'volume', 1);
    this.panValue = GetObjectValue(config, 'pan', 0);
    this.wait = GetObjectValue(config, 'wait', 0);
    this.pitchBendAmount = GetObjectValue(config, 'pitchBend', 0);
    this.reverse = GetObjectValue(config, 'reverse', false);
    this.randomValue = GetObjectValue(config, 'random', 0);
    this.dissonance = GetObjectValue(config, 'dissonance', 0);
    this.echo = GetObjectValue(config, 'echo', false);
    this.echoDelay = GetObjectValue(config, 'echo.delay', 0);
    this.echoFeedback = GetObjectValue(config, 'echo.feedback', 0);
    this.echoFilter = GetObjectValue(config, 'echo.filter', 0);
    this.reverb = GetObjectValue(config, 'reverb', false);
    this.reverbDuration = GetObjectValue(config, 'reverb.duration', 0);
    this.reverbDecay = GetObjectValue(config, 'reverb.decay', 0);
    this.reverbReverse = GetObjectValue(config, 'reverb.reverse', false);
    this.timeout = GetObjectValue(config, 'timeout', false);

    this.volume = ctx.createGain();
    this.pan = (!ctx.createStereoPanner) ? ctx.createPanner() : ctx.createStereoPanner();

    this.volume.connect(this.pan);
    this.pan.connect(ctx.destination);

    //  Set the values

    this.volume.gain.value = this.volumeValue;

    if (!ctx.createStereoPanner)
    {
        this.pan.setPosition(this.panValue, 0, 1 - Math.abs(this.panValue));
    }
    else
    {
        this.pan.pan.value = this.panValue;
    }

    //  Create an oscillator, gain and pan nodes, and connect them together to the destination

    var oscillator = ctx.createOscillator();

    oscillator.connect(this.volume);
    oscillator.type = this.type;

    //  Optionally randomize the pitch if `randomValue` > 0.
    //  A random pitch is selected that's within the range specified by `frequencyValue`.
    //  The random pitch will be either above or below the target frequency.

    if (this.randomValue > 0)
    {
        oscillator.frequency.value = Between(
            this.frequencyValue - this.randomValue / 2,
            this.frequencyValue + this.randomValue / 2
        );
    }
    else
    {
        oscillator.frequency.value = this.frequencyValue;
    }

    //  Apply effects

    if (this.attack > 0)
    {
        this.fadeIn(this.volume);
    }

    this.fadeOut(this.volume);

    if (this.pitchBendAmount > 0)
    {
        this.pitchBend(oscillator);
    }

    if (this.echo)
    {
        this.addEcho(this.volume);
    }

    if (this.reverb)
    {
        this.addReverb(this.volume);
    }

    if (this.dissonance > 0)
    {
        this.addDissonance();
    }

    this.play(oscillator);

    var _this = this;

    oscillator.onended = function ()
    {
        console.log('onended');
        _this.pan.disconnect();
        _this.volume.disconnect();
    };
};

FX.prototype.constructor = FX;

FX.prototype = {

    play: function (oscillator)
    {
        oscillator.start(this.audioContext.currentTime + this.wait);

        //Oscillators have to be stopped otherwise they accumulate in 
        //memory and tax the CPU. They'll be stopped after a default
        //timeout of 2 seconds, which should be enough for most sound 
        //effects. Override this in the `soundEffect` parameters if you
        //need a longer sound

        oscillator.stop(this.audioContext.currentTime + this.wait + 2);
    },

    fadeIn: function (volume)
    {
        volume.gain.value = 0;

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait);

        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);
    },

    fadeOut: function (volume)
    {
        volume.gain.linearRampToValueAtTime(this.volumeValue, this.audioContext.currentTime + this.wait + this.attack);

        volume.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.wait + this.attack + this.decay);
    },

    addReverb: function (volume)
    {
        var convolver = this.audioContext.createConvolver();

        convolver.buffer = this.impulseResponse(this.reverbDuration, this.reverbDecay, this.reverbReverse, this.audioContext);

        volume.connect(convolver);

        convolver.connect(this.pan);
    },

    addEcho: function (volume)
    {
        var feedback = this.audioContext.createGain();
        var delay = this.audioContext.createDelay();
        var filter = this.audioContext.createBiquadFilter();

        //  Set the node values

        feedback.gain.value = this.echoFeedback;
        delay.delayTime.value = this.echoDelay;

        if (this.echoFilter)
        {
            filter.frequency.value = this.echoFilter;
        }

        //  Create the delay feedback loop (with optional filtering)

        delay.connect(feedback);

        if (this.echoFilter)
        {
            feedback.connect(filter);
            filter.connect(delay);
        }
        else
        {
            feedback.connect(delay);
        }

        //  Connect the delay node to the oscillator volume node

        volume.connect(delay);

        //  Connect the delay node to the main sound chains pan node,
        //  so that the echo effect is directed to the correct speaker

        delay.connect(this.pan);
    },

    pitchBend: function (oscillator)
    {
        var frequency = oscillator.frequency.value;

        if (!this.reverse)
        {
            //  If reverse is false, make the sound drop in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency - this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }
        else
        {
            //  If reverse is true, make the sound rise in pitch
            oscillator.frequency.linearRampToValueAtTime(frequency, this.audioContext.currentTime + this.wait);
            oscillator.frequency.linearRampToValueAtTime(frequency + this.pitchBendAmount, this.audioContext.currentTime + this.wait + this.attack + this.decay);
        }

    },

    addDissonance: function ()
    {
        //  Create two more oscillators and gain nodes

        var ctx = this.audioContext;

        var d1 = ctx.createOscillator();
        var d2 = ctx.createOscillator();
        var d1Volume = ctx.createGain();
        var d2Volume = ctx.createGain();

        //  Set the volume to the `volumeValue`
        d1Volume.gain.value = this.volumeValue;
        d2Volume.gain.value = this.volumeValue;

        //  Connect the oscillators to the gain and destination nodes
        d1.connect(d1Volume);
        d2.connect(d2Volume);

        d1Volume.connect(ctx.destination);
        d2Volume.connect(ctx.destination);

        //  Set the waveform to "sawtooth" for a harsh effect
        d1.type = 'sawtooth';
        d2.type = 'sawtooth';

        //  Make the two oscillators play at frequencies above and below the main sound's frequency.
        //  Use whatever value was supplied by the `dissonance` argument
        d1.frequency.value = this.frequencyValue + this.dissonance;
        d2.frequency.value = this.frequencyValue - this.dissonance;

        //  Fade in / out, pitch bend and play the oscillators to match the main sound
        if (this.attack > 0)
        {
            this.fadeIn(d1Volume);
            this.fadeIn(d2Volume);
        }

        if (this.decay > 0)
        {
            this.fadeOut(d1Volume);
            this.fadeOut(d2Volume);
        }

        if (this.pitchBendAmount > 0)
        {
            this.pitchBend(d1);
            this.pitchBend(d2);
        }

        if (this.echo)
        {
            this.addEcho(d1Volume);
            this.addEcho(d2Volume);
        }

        if (this.reverb)
        {
            this.addReverb(d1Volume);
            this.addReverb(d2Volume);
        }

        this.play(d1);
        this.play(d2);
    },

    impulseResponse: function (duration, decay, reverse)
    {
        //  The length of the buffer.
        var length = this.audioContext.sampleRate * duration;

        //  Create an audio buffer (an empty sound container) to store the reverb effect.
        var impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);

        //  Use `getChannelData` to initialize empty arrays to store sound data for the left and right channels.
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);

        //  Loop through each sample-frame and fill the channel data with random noise.
        for (var i = 0; i < length; i++)
        {
            //  Apply the reverse effect, if `reverse` is `true`.
            var n = (reverse) ? length - i : i;

            //  Fill the left and right channels with random white noise which decays exponentially.
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
        }

        //  Return the `impulse`.
        return impulse;
    }

};

module.exports = FX;


/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

//  Phaser.Sound.Dynamic

module.exports = {

    FX: __webpack_require__(605)

};


/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var NOOP = __webpack_require__(85);
var State = __webpack_require__(88);
var Systems = __webpack_require__(184);
var GetObjectValue = __webpack_require__(9);
var EventDispatcher = __webpack_require__(26);
var Rectangle = __webpack_require__(27);
var CanvasPool = __webpack_require__(22);
var CanvasInterpolation = __webpack_require__(56);
var GetContext = __webpack_require__(91);

/**
* The State Manager is responsible for loading, setting up and switching game states.
*
* @class Phaser.GlobalStateManager
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GlobalStateManager = function (game, stateConfig)
{
    this.game = game;

    //  Everything kept in here
    this.keys = {};
    this.states = [];

    //  Only active states are kept in here
    this.active = [];

    this._pending = [];

    if (stateConfig)
    {
        if (Array.isArray(stateConfig))
        {
            for (var i = 0; i < stateConfig.length; i++)
            {
                //  The i === 0 part just starts the first State given
                this._pending.push({
                    index: i,
                    key: 'default',
                    state: stateConfig[i],
                    autoStart: (i === 0),
                    data: {}
                });
            }
        }
        else
        {
            this._pending.push({
                index: 0,
                key: 'default',
                state: stateConfig,
                autoStart: true,
                data: {}
            });
        }
    }
};

GlobalStateManager.prototype.constructor = GlobalStateManager;

GlobalStateManager.prototype = {

    /**
    * The Boot handler is called by Phaser.Game when it first starts up.
    * The renderer is available by now.
    *
    * @method Phaser.GlobalStateManager#boot
    * @private
    */
    boot: function ()
    {
        for (var i = 0; i < this._pending.length; i++)
        {
            var entry = this._pending[i];

            this.add(entry.key, entry.state, entry.autoStart);
        }

        //  Clear the pending list
        this._pending = [];
    },

    //  private
    getKey: function (key, stateConfig)
    {
        if (!key) { key = 'default'; }

        if (stateConfig instanceof State)
        {
            key = stateConfig.settings.key;
        }
        else if (typeof stateConfig === 'object' && stateConfig.hasOwnProperty('key'))
        {
            key = stateConfig.key;
        }

        //  By this point it's either 'default' or extracted from the State

        if (this.keys.hasOwnProperty(key))
        {
            throw new Error('Cannot add a State with duplicate key: ' + key);
        }
        else
        {
            return key;
        }
    },

    /**
    * Adds a new State into the GlobalStateManager. You must give each State a unique key by which you'll identify it.
    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
    * If a function is given a new state object will be created by calling it.
    *
    * @method Phaser.GlobalStateManager#add
    * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
    * @param {Phaser.State|object|function} state  - The state you want to switch to.
    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
    */
    add: function (key, stateConfig, autoStart)
    {
        if (autoStart === undefined) { autoStart = false; }

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            this._pending.push({
                index: this._pending.length,
                key: key,
                state: stateConfig,
                autoStart: autoStart
            });

            console.log('GlobalStateManager not yet booted, adding to list', this._pending.length);

            return;
        }

        key = this.getKey(key, stateConfig);

        // console.log('GlobalStateManager.add', key, stateConfig, autoStart);

        var newState;

        if (stateConfig instanceof State)
        {
            // console.log('GlobalStateManager.add from instance:', key);
            newState = this.createStateFromInstance(key, stateConfig);
        }
        else if (typeof stateConfig === 'object')
        {
            // console.log('GlobalStateManager.add from object:', key);

            stateConfig.key = key;

            newState = this.createStateFromObject(key, stateConfig);
        }
        else if (typeof stateConfig === 'function')
        {
            // console.log('GlobalStateManager.add from function:', key);

            newState = this.createStateFromFunction(key, stateConfig);
        }

        this.keys[key] = newState;

        this.states.push(newState);

        if (autoStart || newState.settings.active)
        {
            if (this.game.isBooted)
            {
                this.start(key);
            }
            else
            {
                this._start.push(key);
            }
        }

        return newState;
    },

    createStateFromInstance: function (key, newState)
    {
        newState.settings.key = key;

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return newState;
    },

    createStateFromObject: function (key, stateConfig)
    {
        var newState = new State(stateConfig);

        newState.sys.init(this.game);

        this.createStateDisplay(newState);

        return this.setupCallbacks(newState, stateConfig);
    },

    createStateFromFunction: function (key, state)
    {
        var newState = new state();

        if (newState instanceof State)
        {
            return this.createStateFromInstance(key, newState);
        }
        else
        {
            newState.sys = new Systems(newState);

            newState.sys.init(this.game);

            this.createStateDisplay(newState);

            //  Default required functions

            if (!newState.init)
            {
                newState.init = NOOP;
            }

            if (!newState.preload)
            {
                newState.preload = NOOP;
            }

            if (!newState.create)
            {
                newState.create = NOOP;
            }

            if (!newState.shutdown)
            {
                newState.shutdown = NOOP;
            }

            if (!newState.update)
            {
                newState.update = NOOP;
            }

            if (!newState.render)
            {
                newState.render = NOOP;
            }

            return newState;
        }
    },

    setupCallbacks: function (state, stateConfig)
    {
        if (stateConfig === undefined) { stateConfig = state; }

        //  Extract callbacks or set NOOP

        state.init = GetObjectValue(stateConfig, 'init', NOOP);
        state.preload = GetObjectValue(stateConfig, 'preload', NOOP);
        state.create = GetObjectValue(stateConfig, 'create', NOOP);
        state.shutdown = GetObjectValue(stateConfig, 'shutdown', NOOP);

        //  Game Loop level callbacks

        state.update = GetObjectValue(stateConfig, 'update', NOOP);
        state.render = GetObjectValue(stateConfig, 'render', NOOP);

        return state;
    },

    createStateDisplay: function (state)
    {
        // console.log('createStateDisplay', state.settings.key);

        var settings = state.sys.settings;

        // var x = settings.x;
        // var y = settings.y;
        var width = settings.width;
        var height = settings.height;

        var config = this.game.config;

        if (config.renderType === CONST.CANVAS)
        {
            if (settings.renderToTexture)
            {
                // console.log('renderToTexture', width, height);
                state.sys.canvas = CanvasPool.create(state, width, height);
                state.sys.context = GetContext(state.sys.canvas);

                //  Pixel Art mode?
                if (config.pixelArt)
                {
                    CanvasInterpolation.setCrisp(state.sys.canvas);
                }
            }
            else
            {
                // console.log('using game canvas');
                state.sys.mask = new Rectangle(0, 0, width, height);
                state.sys.canvas = this.game.canvas;
                state.sys.context = this.game.context;
            }
        }
        else if (config.renderType === CONST.WEBGL)
        {
            // state.sys.fbo = this.game.renderer.createFBO(state, x, y, width, height);
        }
    },

    getState: function (key)
    {
        return this.keys[key];
    },

    getStateIndex: function (state)
    {
        return this.states.indexOf(state);
    },

    getActiveStateIndex: function (state)
    {
        var index = -1;

        for (var i = 0; i < this.active.length; i++)
        {
            if (this.active[i].state === state)
            {
                index = this.active[i].index;
            }
        }

        return index;
    },

    isActive: function (key)
    {
        var state = this.getState(key);

        return (state && state.settings.active && this.active.indexOf(state) !== -1);
    },

    start: function (key, data)
    {
        if (data === undefined) { data = {}; }

        // console.log('start:', key);
        // console.dir(data);

        //  if not booted, then put state into a holding pattern
        if (!this.game.isBooted)
        {
            // console.log('GlobalStateManager not yet booted, setting autoStart on pending list');

            for (var i = 0; i < this._pending.length; i++)
            {
                var entry = this._pending[i];

                if (entry.key === key)
                {
                    entry.autoStart = true;
                    entry.data = data;
                }
            }

            return;
        }

        var state = this.getState(key);

        if (state)
        {
            //  Already started? Nothing more to do here ...
            if (this.isActive(key))
            {
                return;
            }

            state.settings.active = true;

            state.settings.data = data;

            var loader = state.sys.load;

            //  Files payload?
            if (loader && Array.isArray(state.sys.settings.files))
            {
                loader.reset();

                if (loader.loadArray(state.sys.settings.files))
                {
                    loader.events.once('LOADER_COMPLETE_EVENT', this.payloadComplete.bind(this));

                    loader.start();
                }
                else
                {
                    this.bootState(state);
                }
            }
            else
            {
                this.bootState(state);
            }
        }
    },

    payloadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('payloadComplete', state.sys.settings.key);

        this.bootState(state);
    },

    bootState: function (state)
    {
        // console.log('bootState', state.sys.settings.key);

        if (state.init)
        {
            state.init.call(state, state.sys.settings.data);
        }

        var loader = state.sys.load;
            
        loader.reset();

        if (state.preload)
        {
            state.preload(this.game);

            //  Is the loader empty?
            if (loader.list.size === 0)
            {
                this.create(state);
            }
            else
            {
                //  Start the loader going as we have something in the queue

                loader.events.once('LOADER_COMPLETE_EVENT', this.loadComplete.bind(this));

                loader.start();
            }
        }
        else
        {
            //  No preload? Then there was nothing to load either
            this.create(state);
        }
    },

    loadComplete: function (event)
    {
        var state = event.loader.state;

        // console.log('loadComplete', state.sys.settings.key);

        this.create(state);
    },

    create: function (state)
    {
        // console.log('create', state.sys.settings.key);
        // console.log(state);

        //  Insert at the correct index, or it just all goes wrong :)

        var i = this.getStateIndex(state);

        // console.log('create.index', state.sys.settings.key, i);

        this.active.push({ index: i, state: state });

        //  Sort the 'active' array based on the index property
        this.active.sort(this.sortStates);

        state.sys.updates.running = true;

        if (state.create)
        {
            state.create.call(state, state.sys.settings.data);
        }
    },

    pause: function (key)
    {
        var index = this.getActiveStateIndex(this.getState(key));

        if (index > -1)
        {
            var state = this.getState(key);

            state.settings.active = false;

            this.active.splice(index, 1);

            this.active.sort(this.sortStates);
        }
    },

    sortStates: function (stateA, stateB)
    {
        // console.log('sortStates', stateA.state.sys.settings.key, stateA.index, stateB.state.sys.settings.key, stateB.index);

        //  Sort descending
        if (stateA.index < stateB.index)
        {
            return -1;
        }
        else if (stateA.index > stateB.index)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

};

module.exports = GlobalStateManager;


/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(609);
var ScaleModes = __webpack_require__(42);
var GetObjectValue = __webpack_require__(9);

var Settings = {

    create: function (config)
    {
        if (typeof config === 'string')
        {
            config = { key: config };
        }
        else if (config === undefined)
        {
            //  Pass the 'hasOwnProperty' checks
            config = {};
        }

        return {

            status: CONST.PENDING,

            op: CONST.BOOT,

            key: GetObjectValue(config, 'key', ''),
            active: GetObjectValue(config, 'active', false),
            visible: GetObjectValue(config, 'visible', true),

            //  Loader payload array

            data: {},

            files: GetObjectValue(config, 'files', false),

            //  -1 means the State Manager will set it to be the Game dimensions

            x: GetObjectValue(config, 'x', 0),
            y: GetObjectValue(config, 'y', 0),
            rotation: GetObjectValue(config, 'rotation', 0),
            width: GetObjectValue(config, 'width', -1),
            height: GetObjectValue(config, 'height', -1),

            //  State Render Settings (applies only to this State)

            scaleMode: GetObjectValue(config, 'scaleMode', ScaleModes.DEFAULT),
            roundPixels: GetObjectValue(config, 'roundPixels', false),

            dirtyRender: GetObjectValue(config, 'dirtyRender', false),
            renderToTexture: GetObjectValue(config, 'renderToTexture', false),

            //  The following only apply if renderToTexture is true

            autoResize: GetObjectValue(config, 'autoResize', false),
            transparent: GetObjectValue(config, 'transparent', false),
            clearBeforeRender: GetObjectValue(config, 'clearBeforeRender', true),
            backgroundColor: GetObjectValue(config, 'backgroundColor', false)

        };
    },

    init: function (config, gameConfig)
    {
        if (config.width === -1)
        {
            config.width = gameConfig.width;
        }

        if (config.height === -1)
        {
            config.height = gameConfig.height;
        }
    }

};

module.exports = Settings;


/***/ },
/* 609 */
/***/ function(module, exports) {


module.exports = {

    PENDING: 0,
    INSTALLED: 1,

    BOOT: 0,
    INIT: 1,
    PRELOAD: 2,
    CREATE: 3,
    UPDATE: 4,
    RENDER: 5,
    SHUTDOWN: 6

};


/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

var Camera = __webpack_require__(266);

var CameraManager = function (state)
{
    this.state = state;

    this.cameras = [];
    this.cameraPool = [];

    this.main = this.add();
};

CameraManager.prototype.constructor = CameraManager;

CameraManager.prototype = {

    add: function (x, y, width, height)
    {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = this.state.sys.width; }
        if (height === undefined) { height = this.state.sys.height; }

        var camera = null;

        if (this.cameraPool.length > 0)
        {
            camera = this.cameraPool.pop();
            camera.setViewport(x, y, width, height);
        }
        else
        {
            camera = new Camera(x, y, width, height);
        }

        camera.setState(this.state);

        this.cameras.push(camera);

        return camera;
    },

    addReference: function (camera)
    {
        var index = this.cameras.indexOf(camera);
        var poolIndex = this.cameraPool.indexOf(camera);

        if (index < 0 && poolIndex >= 0)
        {
            this.cameras.push(camera);
            this.cameraPool.slice(poolIndex, 1);
            return camera;
        }
        
        return null;
    },

    remove: function (camera)
    {
        var cameraIndex = this.cameras.indexOf(camera);

        if (cameraIndex >= 0)
        {
            this.cameraPool.push(this.cameras[cameraIndex]);
            this.cameras.splice(cameraIndex, 1);
        }
    },

    resetAll: function ()
    {
        while (this.cameras.length > 0)
        {
            this.cameraPool.push(this.cameras.pop());
        }

        this.main = this.add();
    },

    update: function (timestep)
    {
        for (var i = 0, l = this.cameras.length; i < l; ++i)
        {
            this.cameras[i].update(timestep);
        }
    },

    render: function (renderer, children, interpolation)
    {
        var cameras = this.cameras;
        for (var i = 0, l = cameras.length; i < l; ++i)
        {
            var camera = cameras[i];

            camera.preRender();

            renderer.render(this.state, children, interpolation, camera);
        }

    },

    destroy: function ()
    {
        this.main = undefined;

        for (var i = 0; i < this.cameras.length; i++)
        {
            this.cameras[i].destroy();
        }

        for (i = 0; i < this.cameraPool.length; i++)
        {
            this.cameraPool[i].destroy();
        }

        this.cameras = [];
        this.cameraPool = [];
        this.state = undefined;
    }

};

module.exports = CameraManager;


/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(4);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectCreator = function (state)
{
    this.state = state;

    FactoryContainer.load(this, false);
};

GameObjectCreator.prototype.constructor = GameObjectCreator;

GameObjectCreator.prototype = {

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectCreator;


/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var FactoryContainer = __webpack_require__(4);

/**
* The GameObject Factory is a quick way to create many common game objects. The Factory is owned by the State.
*
* @class Phaser.GameObject.Factory
* @constructor
* @param {Phaser.Game} game - A reference to the currently running game.
*/
var GameObjectFactory = function (state)
{
    this.state = state;

    FactoryContainer.load(this, true);
};

GameObjectFactory.prototype.constructor = GameObjectFactory;

GameObjectFactory.prototype = {

    existing: function (child)
    {
        return this.state.children.add(child);
    },

    destroy: function ()
    {
        this.state = undefined;
    }

};

module.exports = GameObjectFactory;


/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(11);
var BaseLoader = __webpack_require__(495);
var NumberArray = __webpack_require__(196);

var ImageFile = __webpack_require__(37);
var JSONFile = __webpack_require__(160);
var XMLFile = __webpack_require__(161);
var BinaryFile = __webpack_require__(502);
var GLSLFile = __webpack_require__(504);
var TextFile = __webpack_require__(507);
var AtlasJSONFile = __webpack_require__(501);
var BitmapFontFile = __webpack_require__(503);
var SpriteSheet = __webpack_require__(506);
var SVGFile = __webpack_require__(505);

var ParseXMLBitmapFont = __webpack_require__(293);

var Loader = function (state)
{
    BaseLoader.call(this);

    /**
    * @property {Phaser.State} state - The State that owns this Factory
    * @protected
    */
    this.state = state;

    this._multilist = {};
};

Loader.prototype = Object.create(BaseLoader.prototype);
Loader.prototype.constructor = Loader;

Loader.prototype.loadArray = function (files)
{
    if (Array.isArray(files))
    {
        for (var i = 0; i < files.length; i++)
        {
            this.file(files[i]);
        }
    }

    return (this.list.size > 0);
};

Loader.prototype.file = function (file)
{
    var entry;

    switch (file.type)
    {
        case 'image':
        case 'json':
        case 'xml':
        case 'binary':
        case 'text':
        case 'glsl':
        case 'svg':
            entry = this[file.type](file.key, file.url, file.xhrSettings);
            break;

        case 'spritesheet':
            entry = this.spritesheet(file.key, file.url, file.config, file.xhrSettings);
            break;

        case 'atlas':
            entry = this.atlas(file.key, file.textureURL, file.atlasURL, file.textureXhrSettings, file.atlasXhrSettings);
            break;

        case 'bitmapFont':
            entry = this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.textureXhrSettings, file.xmlXhrSettings);
            break;

        case 'multiatlas':
            entry = this.multiatlas(file.key, file.textureURLs, file.atlasURLs, file.textureXhrSettings, file.atlasXhrSettings);
            break;
    }

    return entry;
};

Loader.prototype.image = function (key, url, xhrSettings)
{
    var file = new ImageFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.json = function (key, url, xhrSettings)
{
    var file = new JSONFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.xml = function (key, url, xhrSettings)
{
    var file = new XMLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.binary = function (key, url, xhrSettings)
{
    var file = new BinaryFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.text = function (key, url, xhrSettings)
{
    var file = new TextFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.glsl = function (key, url, xhrSettings)
{
    var file = new GLSLFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

//  config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing
Loader.prototype.spritesheet = function (key, url, config, xhrSettings)
{
    var file = new SpriteSheet(key, url, config, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.atlas = function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new AtlasJSONFile(key, textureURL, atlasURL, this.path, textureXhrSettings, atlasXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.bitmapFont = function (key, textureURL, xmlURL, textureXhrSettings, xmlXhrSettings)
{
    //  Returns an object with two properties: 'texture' and 'data'
    var files = new BitmapFontFile(key, textureURL, xmlURL, this.path, textureXhrSettings, xmlXhrSettings);

    this.addFile(files.texture);
    this.addFile(files.data);

    return this;
};

Loader.prototype.svg = function (key, url, xhrSettings)
{
    var file = new SVGFile(key, url, this.path, xhrSettings);

    return this.addFile(file);
};

Loader.prototype.multiatlas = function (key, textureURLs, atlasURLs, textureXhrSettings, atlasXhrSettings)
{
    if (typeof textureURLs === 'number')
    {
        var total = textureURLs;

        textureURLs = NumberArray(0, total, key + '-', '.png');
        atlasURLs = NumberArray(0, total, key + '-', '.json');
    }
    else
    {
        if (!Array.isArray(textureURLs))
        {
            textureURLs = [ textureURLs ];
        }

        if (!Array.isArray(atlasURLs))
        {
            atlasURLs = [ atlasURLs ];
        }
    }

    var file;
    var i = 0;
    var multiKey;

    this._multilist[key] = [];

    for (i = 0; i < textureURLs.length; i++)
    {
        multiKey = '_MA_IMG_' + key + '_' + i.toString();

        file = new ImageFile(multiKey, textureURLs[i], this.path, textureXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }

    for (i = 0; i < atlasURLs.length; i++)
    {
        multiKey = '_MA_JSON_' + key + '_' + i.toString();

        file = new JSONFile(multiKey, atlasURLs[i], this.path, atlasXhrSettings);

        this.addFile(file);

        this._multilist[key].push(multiKey);
    }
};

//  The Loader has finished
Loader.prototype.processCallback = function ()
{
    if (this.storage.size === 0)
    {
        return;
    }

    //  The global Texture Manager
    var cache = this.state.sys.cache;
    var textures = this.state.sys.textures;

    //  Process multiatlas groups first

    var file;
    var fileA;
    var fileB;

    for (var key in this._multilist)
    {
        var data = [];
        var images = [];
        var keys = this._multilist[key];

        for (var i = 0; i < keys.length; i++)
        {
            file = this.storage.get('key', keys[i]);

            if (file)
            {
                if (file.type === 'image')
                {
                    images.push(file.data);
                }
                else if (file.type === 'json')
                {
                    data.push(file.data);
                }

                this.storage.delete(file);
            }
        }

        //  Do we have everything needed?
        if (images.length + data.length === keys.length)
        {
            //  Yup, add them to the Texture Manager

            //  Is the data JSON Hash or JSON Array?
            if (Array.isArray(data[0].frames))
            {
                textures.addAtlasJSONArray(key, images, data);
            }
            else
            {
                textures.addAtlasJSONHash(key, images, data);
            }
        }
    }

    this.storage.each(function (file)
    {
        switch (file.type)
        {
            case 'image':
            case 'svg':
                textures.addImage(file.key, file.data);
                break;

            case 'atlasjson':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    textures.addAtlas(fileA.key, fileA.data, fileB.data);
                }
                else
                {
                    textures.addAtlas(fileB.key, fileB.data, fileA.data);
                }
                break;

            case 'bitmapfont':

                fileA = file.fileA;
                fileB = file.fileB;

                if (fileA.type === 'image')
                {
                    cache.bitmapFont.add(fileB.key, ParseXMLBitmapFont(fileB.data));
                    textures.addImage(fileA.key, fileA.data);
                }
                else
                {
                    cache.bitmapFont.add(fileA.key, ParseXMLBitmapFont(fileA.data));
                    textures.addImage(fileB.key, fileB.data);
                }
                break;

            case 'spritesheet':
                textures.addSpriteSheet(file.key, file.data, file.config);
                break;

            case 'json':
                cache.json.add(file.key, file.data);
                break;

            case 'xml':
                cache.xml.add(file.key, file.data);
                break;

            case 'text':
                cache.text.add(file.key, file.data);
                break;

            case 'binary':
                cache.binary.add(file.key, file.data);
                break;

            case 'sound':
                cache.sound.add(file.key, file.data);
                break;

            case 'glsl':
                cache.shader.add(file.key, file.data);
                break;
        }
    });

    this.storage.clear();
};

module.exports = Loader;


/***/ },
/* 614 */
/***/ function(module, exports) {

//  A proxy class to the Global State Manager

var StateManager = function (state, game)
{
    //  The State that owns this StateManager
    this.state = state;

    this.key = state.sys.settings.key;

    //  GlobalStateManager
    this.manager = game.state;
};

StateManager.prototype.constructor = StateManager;

StateManager.prototype = {

    //  Start this State (or the one given via key)
    start: function (key, data)
    {
        if (key === undefined) { key = this.key; }

        this.manager.start(key, data);
    },

    //  Pause this State (or the one given via key)
    pause: function (key)
    {
        if (key === undefined) { key = this.key; }

        this.manager.pause(key);
    },

    //  Stop this State and start the one given
    swap: function (key)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    moveUp: function ()
    {

    },

    moveDown: function ()
    {

    },

    bringToTop: function ()
    {

    },

    sendToBack: function ()
    {

    },

    //  TODO
    transitionTo: function (key, duration)
    {
        this.manager.pause(this.key);

        this.manager.start(key);
    },

    isActive: function (key)
    {
        if (key === undefined) { key = this.key; }

        return this.manager.isActive(key);
    }

};

module.exports = StateManager;


/***/ },
/* 615 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Dirty! Manager
*
* @class
*/
var UpdateManager = function (state)
{
    this.state = state;

    this.list = [];

    // this.i = 1;

    this.running = false;
    
    this.processed = 0;
};

UpdateManager.prototype.constructor = UpdateManager;

UpdateManager.prototype = {

    stop: function ()
    {
        if (!this.running)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.stop', this.processed);

        this.list.length = 0;

        // this.i++;
    },

    start: function ()
    {
        if (!this.running)
        {
            return;
        }

        var len = this.list.length;

        if (len === 0)
        {
            return;
        }

        // console.log(this.i, 'UpdateManager.start', len);

        this.processed = 0;

        for (var i = 0; i < len; i++)
        {
            //  Because it may have already been processed (as a child of another Transform that was updated)
            if (this.list[i] && this.list[i]._dirty)
            {
                this.processed++;
                this.list[i].update();
            }
        }
    },

    add: function (transform)
    {
        this.list.push(transform);
    }

};

module.exports = UpdateManager;


/***/ },
/* 616 */
/***/ function(module, exports) {

// The keys of a Map can be arbitrary values.

/*
var map = new Map([
    [ 1, 'one' ],
    [ 2, 'two' ],
    [ 3, 'three' ]
]);
*/

var Map = function (elements)
{
    this.entries = {};

    this.size = 0;

    if (Array.isArray(elements))
    {
        for (var i = 0; i < elements.length; i++)
        {
            this.set(elements[i][0], elements[i][1]);
        }
    }
};

Map.prototype.constructor = Map;

Map.prototype = {

    set: function (key, value)
    {
        if (!this.has(key))
        {
            this.entries[key] = value;
            this.size++;
        }

        return this;
    },

    get: function (key)
    {
        if (this.has(key))
        {
            return this.entries[key];
        }
    },

    has: function (key)
    {
        return (this.entries.hasOwnProperty(key));
    },

    delete: function (key)
    {
        if (this.has(key))
        {
            delete this.entries[key];
            this.size--;
        }

        return this;
    },

    clear: function ()
    {
        Object.keys(this.entries).forEach(function (prop)
        {
            delete this.entries[prop];
        });

        this.size = 0;

        return this;
    },

    keys: function ()
    {
        return Object.keys(this.entries);
    },

    values: function ()
    {
        var output = [];
        var entries = this.entries;

        for (var key in entries)
        {
            output.push(entries[key]);
        }

        return output;
    },

    dump: function ()
    {
        var entries = this.entries;

        console.group('Map');

        for (var key in entries)
        {
            console.log(key, entries[key]);
        }

        console.groupEnd();
    },


    each: function (callback)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (callback(key, entries[key]) === false)
            {
                break;
            }
        }

        return this;
    },

    contains: function (value)
    {
        var entries = this.entries;

        for (var key in entries)
        {
            if (entries[key] === value)
            {
                return true;
            }
        }

        return false;
    },

    //  Merges all new keys from the given Map into this one
    //  If it encounters a key that already exists it will be skipped
    //  unless override = true
    merge: function (map, override)
    {
        if (override === undefined) { override = false; }

        var local = this.entries;
        var source = map.entries;

        for (var key in source)
        {
            if (local.hasOwnProperty(key) && override)
            {
                local[key] = source[key];
            }
            else
            {
                this.set(key, source[key]);
            }
        }

        return this;
    }
};

module.exports = Map;


/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {


var quickselect = __webpack_require__(197);

/**
 * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
 * It's based on an optimized R-tree data structure with bulk insertion support.
 *
 * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
 * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
 */

function rbush (maxEntries, format)
{
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format)
    {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function ()
    {
        return this._all(this.data, []);
    },

    search: function (bbox)
    {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox)
    {
        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data)
    {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item)
    {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function ()
    {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn)
    {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data)
    {
        this.data = data;
        return this;
    },

    _all: function (node, result)
    {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height)
    {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path)
    {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode)
    {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level)
    {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode)
    {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M)
    {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M)
    {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare)
    {
        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level)
    {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path)
    {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format)
    {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem (item, items, equalsFn)
{
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox (node, toBBox)
{
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox (node, k, p, toBBox, destNode)
{
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend (a, b)
{
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX (a, b) { return a.minX - b.minX; }
function compareNodeMinY (a, b) { return a.minY - b.minY; }

function bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea (a, b)
{
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea (a, b)
{
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains (a, b)
{
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects (a, b)
{
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode (children)
{
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect (arr, left, right, n, compare)
{
    var stack = [left, right],
        mid;

    while (stack.length)
    {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

module.exports = rbush;


/***/ },
/* 618 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Extend = __webpack_require__(55);

/**
* A Frame is a section of a Texture.
*
* @class Phaser.Frame
* @constructor
* @param {Phaser.Texture} texture - The Texture this Frame belongs to.
* @param {string} name - The unique (within the Texture) name of this Frame.
* @param {number} x - X position of the frame within the Texture.
* @param {number} y - Y position of the frame within the Texture.
* @param {number} width - Width of the frame within the Texture.
* @param {number} height - Height of the frame within the Texture.
*/
var Frame = function (texture, name, sourceIndex, x, y, width, height)
{
    /**
    * @property {Phaser.Texture} texture - The Texture this frame belongs to.
    */
    this.texture = texture;

    /**
    * @property {string} name - The name of this frame within the Texture.
    */
    this.name = name;

    this.source = texture.source[sourceIndex];

    this.sourceIndex = sourceIndex;

    /**
    * @property {number} cutX - X position within the source image to cut from.
    */
    this.cutX = x;

    /**
    * @property {number} cutY - Y position within the source image to cut from.
    */
    this.cutY = y;

    /**
    * @property {number} cutWidth - The width of the area in the source image to cut.
    */
    this.cutWidth = width;

    /**
    * @property {number} cutHeight - The height of the area in the source image to cut.
    */
    this.cutHeight = height;

    /**
    * @property {number} x - The X rendering offset of this Frame, taking trim into account.
    */
    this.x = 0;

    /**
    * @property {number} y - The Y rendering offset of this Frame, taking trim into account.
    */
    this.y = 0;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.width = width;

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.height = height;

    /**
    * @property {number} width - The rendering width of this Frame, taking trim into account.
    */
    this.centerX = Math.floor(width / 2);

    /**
    * @property {number} height - The rendering height of this Frame, taking trim into account.
    */
    this.centerY = Math.floor(height / 2);

    /**
    * Is this frame is rotated or not in the Texture?
    * Rotation allows you to use rotated frames in texture atlas packing.
    * It has nothing to do with Sprite rotation.
    *
    * @property {boolean} rotated
    * @default
    */
    this.rotated = false;

    /**
    * Is this a tiling texture? As used by the likes of a TilingSprite.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} isTiling
    * @default
    */
    this.isTiling = false;

    /**
    * This will let a renderer know that a tinted parent has updated its texture.
    * TODO: Try and remove this, it shouldn't be here
    *
    * @property {boolean} requiresReTint
    * @default
    */
    this.requiresReTint = false;

    //  Over-rides the Renderer setting? -1 = use Renderer Setting, 0 = No rounding, 1 = Round
    this.autoRound = -1;

    /**
    * The un-modified source frame, trim and UV data.
    *
    * @private
    * @property {object} data
    */
    this.data = {
        cut: {
            x: x,
            y: y,
            w: width,
            h: height,
            r: x + width,
            b: y + height
        },
        trim: false,
        sourceSize: {
            w: width,
            h: height
        },
        spriteSourceSize: {
            x: 0,
            y: 0,
            w: width,
            h: height
        },
        uvs: {
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            x3: 0,
            y3: 0
        },
        radius: 0.5 * Math.sqrt(width * width + height * height),
        drawImage: {
            sx: x,
            sy: y,
            sWidth: width,
            sHeight: height,
            dWidth: width,
            dHeight: height
        }
    };

    this.updateUVs();
};

Frame.prototype.constructor = Frame;

Frame.prototype = {

    /**
    * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
    *
    * @method Phaser.TextureFrame#setTrim
    * @param {number} actualWidth - The width of the frame before being trimmed.
    * @param {number} actualHeight - The height of the frame before being trimmed.
    * @param {number} destX - The destination X position of the trimmed frame for display.
    * @param {number} destY - The destination Y position of the trimmed frame for display.
    * @param {number} destWidth - The destination width of the trimmed frame for display.
    * @param {number} destHeight - The destination height of the trimmed frame for display.
    */
    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)
    {
        var data = this.data;
        var ss = data.spriteSourceSize;

        //  Store actual values

        data.trim = true;

        data.sourceSize.w = actualWidth;
        data.sourceSize.h = actualHeight;

        ss.x = destX;
        ss.y = destY;
        ss.w = destWidth;
        ss.h = destHeight;

        //  Adjust properties
        this.x = destX;
        this.y = destY;

        this.width = destWidth;
        this.height = destHeight;

        this.centerX = Math.floor(destWidth / 2);
        this.centerY = Math.floor(destHeight / 2);

        this.updateUVs();

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVs
    * @private
    */
    updateUVs: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x0 = this.cutX / tw;
        uvs.y0 = this.cutY / th;

        uvs.x1 = this.cutX / tw;
        uvs.y1 = (this.cutY + this.cutHeight) / th;

        uvs.x2 = (this.cutX + this.cutWidth) / tw;
        uvs.y2 = (this.cutY + this.cutHeight) / th;

        uvs.x3 = (this.cutX + this.cutWidth) / tw;
        uvs.y3 = this.cutY / th;

        return this;
    },

    /**
    * Updates the internal WebGL UV cache.
    *
    * @method updateUVsInverted
    * @private
    */
    updateUVsInverted: function ()
    {
        var tw = this.source.width;
        var th = this.source.height;
        var uvs = this.data.uvs;
        
        uvs.x3 = (this.cutX + this.cutHeight) / tw;
        uvs.y3 = (this.cutY + this.cutWidth) / th;

        uvs.x2 = this.cutX / tw;        
        uvs.y2 = (this.cutY + this.cutWidth) / th;
        
        uvs.x1 = this.cutX / tw;
        uvs.y1 = this.cutY / th;
        
        uvs.x0 = (this.cutX + this.cutHeight) / tw;
        uvs.y0 = this.cutY / th;

        return this;
    },

    clone: function ()
    {
        var clone = new Frame(this.texture, this.name, this.sourceIndex);

        clone.cutX = this.cutX;
        clone.cutY = this.cutY;
        clone.cutWidth = this.cutWidth;
        clone.cutHeight = this.cutHeight;

        clone.x = this.x;
        clone.y = this.y;

        clone.width = this.width;
        clone.height = this.height;

        clone.centerX = this.centerX;
        clone.centerY = this.centerY;

        clone.rotated = this.rotated;

        clone.data = Extend(true, clone.data, this.data);

        clone.updateUVs();

        return clone;
    },

    destroy: function ()
    {
    }

};

Object.defineProperties(Frame.prototype, {

    /**
    * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realWidth
    * @property {any} realWidth
    */
    realWidth: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.w;
        }

    },

    /**
    * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
    * before being packed.
    *
    * @name Phaser.TextureFrame#realHeight
    * @property {any} realHeight
    */
    realHeight: {

        enumerable: true,

        get: function ()
        {
            return this.data.sourceSize.h;
        }

    },

    /**
    * UVs
    *
    * @name Phaser.TextureFrame#uvs
    * @property {Object} uvs
    */
    uvs: {

        enumerable: true,

        get: function ()
        {
            return this.data.uvs;
        }

    },

    /**
    * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
    * @name Phaser.TextureFrame#radius
    * @property {number} radius
    */
    radius: {

        enumerable: true,

        get: function ()
        {
            return this.data.radius;
        }

    },

    /**
    * Canvas Draw Image data
    *
    * @name Phaser.TextureFrame#canvasData
    * @property {Object} canvasData
    */
    canvasData: {

        enumerable: true,

        get: function ()
        {
            return this.data.drawImage;
        }

    }

});

module.exports = Frame;


/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Frame = __webpack_require__(618);
var TextureSource = __webpack_require__(621);

/**
* A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
* of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
* may have many Frames, one for each element within the atlas. Where-as a single image would have
* just one frame, that encompasses the whole image.
*
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* @class Phaser.Texture
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var Texture = function (manager, key, source)
{
    this.manager = manager;

    if (!Array.isArray(source))
    {
        source = [ source ];
    }

    this.key = key;

    /**
    * The source that is used to create the texture.
    * Usually an Image, but can also be a Canvas.
    *
    * @property source
    * @type array
    */
    this.source = [];

    /**
    * @property {object} frames - Frames
    */
    this.frames = {};

    this.firstFrame = '__BASE';

    this.frameTotal = 0;

    //  Load the Sources
    for (var i = 0; i < source.length; i++)
    {
        this.source.push(new TextureSource(this, source[i]));
    }
};

Texture.prototype.constructor = Texture;

Texture.prototype = {

    add: function (name, sourceIndex, x, y, width, height)
    {
        var frame = new Frame(this, name, sourceIndex, x, y, width, height);

        this.frames[name] = frame;

        //  Set the first frame of the Texture (other than __BASE)
        //  This is used to ensure we don't spam the display with entire
        //  atlases of sprite sheets, but instead just the first frame of them
        //  should the dev incorrectly specify the frame index
        if (this.frameTotal === 1)
        {
            this.firstFrame = name;
        }

        this.frameTotal++;

        return frame;
    },

    get: function (name)
    {
        if (name === undefined || name === null)
        {
            name = (this.frameTotal === 1) ? '__BASE' : this.firstFrame;
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'];
        }
        else
        {
            return frame;
        }
    },

    getSourceImage: function (name)
    {
        if (name === undefined || name === null || this.frameTotal === 1)
        {
            name = '__BASE';
        }

        var frame = this.frames[name];

        if (!frame)
        {
            console.warn('No Texture.frame found with name ' + name);

            return this.frames['__BASE'].source.image;
        }
        else
        {
            return frame.source.image;
        }
    },

    setTextureIndex: function (index)
    {
        for (var i = 0; i < this.source.length; i++)
        {
            this.source[i].glTextureIndex = index;

            console.log(this.source[i].image.currentSrc, 'index = ', index);

            index++;
        }

        return index;
    },

    /**
    * Destroys this base texture
    *
    * @method destroy
    */
    destroy: function ()
    {
        //  TODO
    }

};

module.exports = Texture;


/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var Parser = __webpack_require__(629);
var Texture = __webpack_require__(619);
var CanvasPool = __webpack_require__(22);

/**
* Textures are managed by the global TextureManager. This is a singleton class that is
* responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
*
* Sprites and other Game Objects get the texture data they need from the TextureManager.
*
* Access it via `state.textures`.
*
* @class Phaser.TextureManager
* @constructor
*/
var TextureManager = function (game)
{
    this.game = game;

    this.list = {};

    this.addBase64('__DEFAULT', game.config.defaultImage);
    this.addBase64('__MISSING', game.config.missingImage);
};

TextureManager.prototype.constructor = TextureManager;

TextureManager.prototype = {

    addBase64: function (key, data)
    {
        var _this = this;
        var image = new Image();

        image.onload = function ()
        {
            var texture = _this.create(key, image);
        
            Parser.Image(texture, 0);
        };

        image.src = data;
    },

    addImage: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Image(texture, 0);

        return texture;
    },

    createCanvas: function (key, width, height)
    {
        if (width === undefined) { width = 256; }
        if (height === undefined) { height = 256; }

        var canvas = CanvasPool.create(this, width, height);

        return this.addCanvas(key, canvas);
    },

    addCanvas: function (key, source)
    {
        var texture = this.create(key, source);
        
        Parser.Canvas(texture, 0);

        return texture;
    },

    addAtlas: function (key, source, data)
    {
        //  Is it a Hash or an Array?

        if (Array.isArray(data.frames))
        {
            return this.addAtlasJSONArray(key, source, data);
        }
        else
        {
            return this.addAtlasJSONHash(key, source, data);
        }
    },

    addAtlasJSONArray: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONArray(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONArray(texture, 0, data);
        }

        return texture;
    },

    addAtlasJSONHash: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.JSONHash(texture, i, data[i]);
            }
        }
        else
        {
            Parser.JSONHash(texture, 0, data);
        }

        return texture;
    },

    /**
     * [addSpriteSheet description]
     * @param {[type]} key    [description]
     * @param {[type]} source [description]
     * @param {[type]} config [description]
     * @param {number} config.frameWidth - The fixed width of each frame.
     * @param {number} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.
     * @param {number} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     * @param {number} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.
     * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
     */
    addSpriteSheet: function (key, source, config)
    {
        var texture = this.create(key, source);

        var width = texture.source[0].width;
        var height = texture.source[0].height;

        Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);

        return texture;
    },

    addSpriteSheetFromAtlas: function (key, atlasKey, atlasFrame, config)
    {
        var atlas = this.get(atlasKey);
        var sheet = atlas.get(atlasFrame);

        if (sheet)
        {
            var texture = this.create(key, sheet.source.image);

            Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);

            return texture;
        }
    },

    addAtlasStarlingXML: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.StarlingXML(texture, i, data[i]);
            }
        }
        else
        {
            Parser.StarlingXML(texture, 0, data);
        }

        return texture;
    },

    addAtlasPyxel: function (key, source, data)
    {
        var texture = this.create(key, source);

        if (Array.isArray(data))
        {
            for (var i = 0; i < data.length; i++)
            {
                Parser.Pyxel(texture, i, data[i]);
            }
        }
        else
        {
            Parser.Pyxel(texture, 0, data);
        }

        return texture;
    },

    create: function (key, source)
    {
        var texture = new Texture(this, key, source);

        this.list[key] = texture;

        return texture;
    },

    exists: function (key)
    {
        return (this.list.hasOwnProperty(key));
    },

    get: function (key)
    {
        if (key === undefined) { key = '__DEFAULT'; }

        if (this.list[key])
        {
            return this.list[key];
        }
        else
        {
            return this.list['__MISSING'];
        }
    },

    cloneFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame).clone();
        }
    },

    getFrame: function (key, frame)
    {
        if (this.list[key])
        {
            return this.list[key].get(frame);
        }
    },

    setTexture: function (gameObject, key, frame)
    {
        if (this.list[key])
        {
            gameObject.texture = this.list[key];
            gameObject.frame = gameObject.texture.get(frame);
        }

        return gameObject;
    },

    /**
    * Passes all Textures to the given callback.
    *
    * @method each
    * @param {function} callback - The function to call.
    * @param {object} [thisArg] - Value to use as `this` when executing callback.
    * @param {...*} [arguments] - Additional arguments that will be passed to the callback, after the child.
    */
    each: function (callback, thisArg)
    {
        var args = [ null ];

        for (var i = 1; i < arguments.length; i++)
        {
            args.push(arguments[i]);
        }

        for (var texture in this.list)
        {
            args[0] = this.list[texture];

            callback.apply(thisArg, args);
        }
    }

};

module.exports = TextureManager;


/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var CONST = __webpack_require__(2);
var ScaleModes = __webpack_require__(42);
var IsSizePowerOfTwo = __webpack_require__(174);
var CreateTexture2DFromSource = __webpack_require__(603);

/**
*
* @class Phaser.TextureSource
* @constructor
* @param {object} source
* @param {number} scaleMode
*/
var TextureSource = function (texture, source)
{
    this.texture = texture;

    this.image = source;

    this.compressionAlgorithm = null;

    /**
    * The Resolution of the texture.
    *
    * @property resolution
    * @type Number
    */
    this.resolution = 1;
    
    /**
    * The width of the Texture.
    *
    * @property width
    * @type Number
    * @readOnly
    */
    this.width = source.naturalWidth || source.width || 0;

    /**
    * The height of the Texture.
    *
    * @property height
    * @type Number
    * @readOnly
    */
    this.height = source.naturalHeight || source.height || 0;

    /**
    * The scale mode to apply when scaling this texture.
    * NEAREST or DEFAULT
    *
    * @property scaleMode
    * @type {Number}
    * @default Phaser.scaleModes.DEFAULT;
    */
    this.scaleMode = ScaleModes.DEFAULT;

    /**
    * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
    *
    * @property premultipliedAlpha
    * @type Boolean
    * @default true
    */
    this.premultipliedAlpha = true;

    /**
    * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
    * Also the texture must be a power of two size to work
    *
    * @property mipmapLevel
    * @type {integer}
    */
    this.mipmapLevel = 0;

    /**
    * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
    *
    * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
    * that has children that you do want to render, without causing a batch flush in the process.
    *
    * @property renderable
    * @type Boolean
    */
    this.renderable = true;

    /**
    * @property isPowerOf2
    * @type boolean
    */
    this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);

    /**
    * @property glTexture
    */
    this.glTexture = null;

    /**
    * The multi texture batching index number.
    * @property glTextureIndex
    * @type Number
    */
    this.glTextureIndex = 0;

    /**
    * The timestamp when this texture was last used by the WebGL renderer.
    * Can be used to purge out 'dead' textures from GPU memory.
    * @property glLastUsed
    * @type Number
    */
    this.glLastUsed = 0;

    /**
    * @property glDirty
    */
    this.glDirty = true;

    var game = texture.manager.game;

    if (game.config.renderType === CONST.WEBGL)
    {
        CreateTexture2DFromSource(game.renderer.gl, this);
    }
};

module.exports = TextureSource;


/***/ },
/* 622 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var CanvasTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = CanvasTextureParser;


/***/ },
/* 623 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.Image
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var ImageTextureParser = function (texture, sourceIndex)
{
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    return texture;
};

module.exports = ImageTextureParser;


/***/ },
/* 624 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONArrayTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Array given, missing \'frames\' array');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed array
    var frames = json['frames'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        var src = frames[i];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONArrayTextureParser;


/***/ },
/* 625 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a JSON Array and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var JSONHashTextureParser = function (texture, sourceIndex, json)
{
    //  Malformed?
    if (!json['frames'])
    {
        console.warn('Invalid Texture Atlas JSON Hash given, missing \'frames\' Object');
        return;
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];
    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    //  By this stage frames is a fully parsed Object
    var frames = json['frames'];
    var newFrame;

    for (var key in frames)
    {
        var src = frames[key];

        //  The frame values are the exact coordinates to cut the frame out of the atlas from
        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);

        //  These are the original (non-trimmed) sprite values
        if (src.trimmed)
        {
            newFrame.setTrim(
                src.sourceSize.w,
                src.sourceSize.h,
                src.spriteSourceSize.x,
                src.spriteSourceSize.y,
                src.spriteSourceSize.w,
                src.spriteSourceSize.h
            );
        }

        if (src.rotated)
        {
            newFrame.rotated = true;
            newFrame.updateUVsInverted();
        }
    }

    return texture;
};

module.exports = JSONHashTextureParser;


/***/ },
/* 626 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses a Pyxel JSON File and extracts the frame data from it.
*
* @class Phaser.TextureParser.JSONArray
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} json - The JSON data from the Texture Atlas. Must be in Pyxel JSON format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var PyxelTextureParser = function (texture, json)
{
    //  Malformed? There are a few keys to check here.
    var signature = [ 'layers', 'tilewidth', 'tileheight', 'tileswide', 'tileshigh' ];

    signature.forEach(function (key)
    {
        if (!json[key])
        {
            // console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.');
            // console.log(json);
            return;
        }
    });

    // For this purpose, I only care about parsing tilemaps with a single layer.
    if (json['layers'].length !== 1)
    {
        // console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');
        // console.log(json);
        return;
    }

    var data = new Phaser.FrameData();

    var tileheight = json['tileheight'];
    var tilewidth = json['tilewidth'];

    var frames = json['layers'][0]['tiles'];
    var newFrame;

    for (var i = 0; i < frames.length; i++)
    {
        newFrame = data.addFrame(new Phaser.Frame(
            i,
            frames[i].x,
            frames[i].y,
            tilewidth,
            tileheight,
            "frame_" + i  // No names are included in pyxel tilemap data.
        ));

        // No trim data is included.
        newFrame.setTrim(false);
    }

    return data;
};

module.exports = PyxelTextureParser;


/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

var GetObjectValue = __webpack_require__(9);

/**
* Parse a Sprite Sheet and extracts the frame data from it.
*
* @class Phaser.TextureParser.SpriteSheet
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {string} key - The key of the Frame within the Texture that the Sprite Sheet is stored in.
* @param {number} frameWidth - The fixed width of each frame.
* @param {number} frameHeight - The fixed height of each frame.
* @param {number} [startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
* @param {number} [endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
* @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
* @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var SpriteSheetTextureParser = function (texture, sourceIndex, x, y, width, height, config)
{
    var frameWidth = GetObjectValue(config, 'frameWidth', null);
    var frameHeight = GetObjectValue(config, 'frameHeight', frameWidth);

    //  If missing we can't proceed
    if (frameWidth === null)
    {
        throw new Error('TextureManager.SpriteSheetTextureParser: Invalid frameWidth given.');
    }

    //  Add in a __BASE entry (for the entire atlas)
    var source = texture.source[sourceIndex];

    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);

    var startFrame = GetObjectValue(config, 'startFrame', 0);
    var endFrame = GetObjectValue(config, 'endFrame', -1);
    var margin = GetObjectValue(config, 'margin', 0);
    var spacing = GetObjectValue(config, 'spacing', 0);

    var row = Math.floor((width - margin) / (frameWidth + spacing));
    var column = Math.floor((height - margin) / (frameHeight + spacing));
    var total = row * column;

    if (startFrame > total || startFrame < -total)
    {
        startFrame = 0;
    }

    if (startFrame < 0)
    {
        //  Allow negative skipframes.
        startFrame = total + startFrame;
    }

    if (endFrame !== -1)
    {
        total = startFrame + (endFrame + 1);
    }

    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;

    for (var i = 0; i < total; i++)
    {
        ax = 0;
        ay = 0;

        var w = fx + frameWidth;
        var h = fy + frameHeight;

        if (w > width)
        {
            ax = w - width;
        }

        if (h > height)
        {
            ay = h - height;
        }

        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);

        fx += frameWidth + spacing;

        if (fx + frameWidth > width)
        {
            fx = margin;
            fy += frameHeight + spacing;
        }
    }

    return texture;
};

module.exports = SpriteSheetTextureParser;


/***/ },
/* 628 */
/***/ function(module, exports) {

/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Parses the XML and extracts the frame data from it.
*
* @class Phaser.TextureParser.StarlingXML
* @static
* @param {Phaser.Texture} texture - The parent Texture.
* @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
* @return {Phaser.FrameData} A FrameData object containing the parsed frames.
*/
var StarlingXMLTextureParser = function (texture, xml)
{
    //  Malformed?
    if (!xml.getElementsByTagName('TextureAtlas'))
    {
        // console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        return;
    }

    //  Let's create some frames then
    var data = new Phaser.FrameData();
    var frames = xml.getElementsByTagName('SubTexture');
    var newFrame;

    var name;
    var frame;
    var x;
    var y;
    var width;
    var height;
    var frameX;
    var frameY;
    var frameWidth;
    var frameHeight;

    for (var i = 0; i < frames.length; i++)
    {
        frame = frames[i].attributes;

        name = frame.name.value;
        x = parseInt(frame.x.value, 10);
        y = parseInt(frame.y.value, 10);
        width = parseInt(frame.width.value, 10);
        height = parseInt(frame.height.value, 10);

        frameX = null;
        frameY = null;

        if (frame.frameX)
        {
            frameX = Math.abs(parseInt(frame.frameX.value, 10));
            frameY = Math.abs(parseInt(frame.frameY.value, 10));
            frameWidth = parseInt(frame.frameWidth.value, 10);
            frameHeight = parseInt(frame.frameHeight.value, 10);
        }

        newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name));

        //  Trimmed?
        if (frameX !== null || frameY !== null)
        {
            newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
        }
    }

    return data;

};

module.exports = StarlingXMLTextureParser;


/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {


module.exports = {
    Canvas: __webpack_require__(622),
    Image: __webpack_require__(623),
    SpriteSheet: __webpack_require__(627),
    JSONArray: __webpack_require__(624),
    JSONHash: __webpack_require__(625),
    StarlingXML: __webpack_require__(628),
    Pyxel: __webpack_require__(626)
};


/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

var CONST = __webpack_require__(195);

var AlignInMap = [];

AlignInMap[CONST.BOTTOM_CENTER] = __webpack_require__(186);
AlignInMap[CONST.BOTTOM_LEFT] = __webpack_require__(187);
AlignInMap[CONST.BOTTOM_RIGHT] = __webpack_require__(188);
AlignInMap[CONST.CENTER] = __webpack_require__(189);
AlignInMap[CONST.LEFT_CENTER] = __webpack_require__(190);
AlignInMap[CONST.RIGHT_CENTER] = __webpack_require__(191);
AlignInMap[CONST.TOP_CENTER] = __webpack_require__(192);
AlignInMap[CONST.TOP_LEFT] = __webpack_require__(193);
AlignInMap[CONST.TOP_RIGHT] = __webpack_require__(194);

var AlignIn = function (child, container, position, offsetX, offsetY)
{
    return AlignInMap[position](child, container, offsetX, offsetY);
};

module.exports = AlignIn;


/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(33);
var GetBottom = __webpack_require__(13);
var SetCenterX = __webpack_require__(35);
var SetTop = __webpack_require__(20);

var ToBottomCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomCenter;


/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetBottom = __webpack_require__(13);
var SetLeft = __webpack_require__(18);
var SetTop = __webpack_require__(20);

var ToBottomLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomLeft;


/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetBottom = __webpack_require__(13);
var SetRight = __webpack_require__(19);
var SetTop = __webpack_require__(20);

var ToBottomRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToBottomRight;


/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetBottom = __webpack_require__(13);
var SetRight = __webpack_require__(19);
var SetBottom = __webpack_require__(17);

var ToLeftBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftBottom;


/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetCenterY = __webpack_require__(34);
var SetRight = __webpack_require__(19);
var SetCenterY = __webpack_require__(36);

var ToLeftCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToLeftCenter;


/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetTop = __webpack_require__(16);
var SetRight = __webpack_require__(19);
var SetTop = __webpack_require__(20);

var ToLeftTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetLeft(parent) - offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToLeftTop;


/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetBottom = __webpack_require__(13);
var SetLeft = __webpack_require__(18);
var SetBottom = __webpack_require__(17);

var ToRightBottom = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetBottom(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightBottom;


/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetCenterY = __webpack_require__(34);
var SetLeft = __webpack_require__(18);
var SetCenterY = __webpack_require__(36);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetCenterY(gameObject, GetCenterY(parent) + offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetTop = __webpack_require__(16);
var SetLeft = __webpack_require__(18);
var SetTop = __webpack_require__(20);

var ToRightTop = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetRight(parent) + offsetX);
    SetTop(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToRightTop;


/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

var GetCenterX = __webpack_require__(33);
var GetTop = __webpack_require__(16);
var SetCenterX = __webpack_require__(35);
var SetBottom = __webpack_require__(17);

var ToTopCenter = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopCenter;


/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

var GetLeft = __webpack_require__(14);
var GetTop = __webpack_require__(16);
var SetLeft = __webpack_require__(18);
var SetBottom = __webpack_require__(17);

var ToTopLeft = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(parent) - offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopLeft;


/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

var GetRight = __webpack_require__(15);
var GetTop = __webpack_require__(16);
var SetRight = __webpack_require__(19);
var SetBottom = __webpack_require__(17);

var ToTopRight = function (gameObject, parent, offsetX, offsetY)
{
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(parent) + offsetX);
    SetBottom(gameObject, GetTop(parent) - offsetY);

    return gameObject;
};

module.exports = ToTopRight;


/***/ },
/* 643 */
/***/ function(module, exports) {

/**
* Snaps a value to the nearest value in an array.
* The result will always be in the range `[first_value, last_value]`.
*
* @method
* @param {number} value - The search value
* @param {number[]} arr - The input array which _must_ be sorted.
* @return {number} The nearest value found.
*/
var FindClosestInSorted = function (value, array)
{
    if (!array.length)
    {
        return NaN;
    }
    else if (array.length === 1 || value < array[0])
    {
        return array[0];
    }

    var i = 1;

    while (array[i] < value)
    {
        i++;
    }

    var low = array[i - 1];
    var high = (i < array.length) ? array[i] : Number.POSITIVE_INFINITY;

    return ((high - value) <= (value - low)) ? high : low;
};

module.exports = FindClosestInSorted;


/***/ },
/* 644 */
/***/ function(module, exports) {

/**
* Fetch a random entry from the given array.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was selected.
*/

var GetRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return (array[randomIndex] === undefined) ? null : array[randomIndex];
};

module.exports = GetRandomElement;


/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

var RoundAwayFromZero = __webpack_require__(167);

/**
* Create an array of numbers (positive and/or negative) progressing from `start`
* up to but not including `end` by advancing by `step`.
*
* If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
*
* Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
* for forward compatibility make sure to pass in actual numbers.
*
* @method Phaser.ArrayUtils#numberArrayStep
* @param {number} start - The start of the range.
* @param {number} [end] - The end of the range.
* @param {number} [step=1] - The value to increment or decrement by.
* @returns {Array} Returns the new array of numbers.
* @example
* NumberArrayStep(4);
* // => [0, 1, 2, 3]
*
* NumberArrayStep(1, 5);
* // => [1, 2, 3, 4]
*
* NumberArrayStep(0, 20, 5);
* // => [0, 5, 10, 15]
*
* NumberArrayStep(0, -4, -1);
* // => [0, -1, -2, -3]
*
* NumberArrayStep(1, 4, 0);
* // => [1, 1, 1]
*
* NumberArrayStep(0);
* // => []
*/
var NumberArrayStep = function (start, end, step)
{
    if (start === undefined) { start = 0; }
    if (end === undefined) { end = null; }
    if (step === undefined) { step = 1; }

    if (end === null)
    {
        end = start;
        start = 0;
    }

    var result = [];

    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);

    for (var i = 0; i < total; i++)
    {
        result.push(start);
        start += step;
    }

    return result;
};

module.exports = NumberArrayStep;


/***/ },
/* 646 */
/***/ function(module, exports, __webpack_require__) {

var SpliceOne = __webpack_require__(202);

/**
* Removes a random object from the given array and returns it.
*
* Will return null if there are no array items that fall within the specified range
* or if there is no item for the randomly chosen index.
*
* @method
* @param {any[]} objects - An array of objects.
* @param {integer} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.
* @param {integer} length - Optional restriction on the number of values you want to randomly select from.
* @return {object} The random object that was removed.
*/

var RemoveRandomElement = function (array, start, length)
{
    if (start === undefined) { start = 0; }
    if (length === undefined) { length = array.length; }

    var randomIndex = start + Math.floor(Math.random() * length);

    return SpliceOne(array, randomIndex);
};

module.exports = RemoveRandomElement;


/***/ },
/* 647 */
/***/ function(module, exports, __webpack_require__) {

//! stable.js 0.1.6, https://github.com/Two-Screen/stable
//! © 2017 Angry Bytes and contributors. MIT licensed.

(function() {

// A stable array sort, because `Array#sort()` is not guaranteed stable.
// This is an implementation of merge sort, without recursion.

var stable = function(arr, comp) {
    return exec(arr.slice(), comp);
};

stable.inplace = function(arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
        pass(result, null, arr.length, arr);
    }

    return arr;
};

// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
        comp = function(a, b) {
            return String(a).localeCompare(b);
        };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
        return arr;
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);

        var tmp = arr;
        arr = buffer;
        buffer = tmp;
    }

    return arr;
}

// Run a single pass with the given chunk size.
var pass = function(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len) r = len;
        if (e > len) e = len;

        // Iterate both chunks in parallel.
        li = l;
        ri = r;
        while (true) {
            // Compare the chunks.
            if (li < r && ri < e) {
                // This works for a regular `sort()` compatible comparator,
                // but also for a simple comparator like: `a > b`
                if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                }
                else {
                    result[i++] = arr[ri++];
                }
            }
            // Nothing to compare, just flush what's left.
            else if (li < r) {
                result[i++] = arr[li++];
            }
            else if (ri < e) {
                result[i++] = arr[ri++];
            }
            // Both iterators are at the chunk ends.
            else {
                break;
            }
        }
    }
};

// Export using CommonJS or to the window.
if (true) {
    module.exports = stable;
}
else {
    window.stable = stable;
}

})();

/***/ },
/* 648 */
/***/ function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetX = function (gameObject)
{
    return gameObject.width * gameObject.originX;
};

module.exports = GetOffsetX;


/***/ },
/* 649 */
/***/ function(module, exports) {

/**
* The amount the Game Object is visually offset from its x coordinate.
* This is the same as `width * origin.x`.
* It will only be > 0 if origin.x is not equal to zero.
*
* @property {number} offsetX
* @readOnly
*/

var GetOffsetY = function (gameObject)
{
    return gameObject.height * gameObject.originY;
};

module.exports = GetOffsetY;


/***/ },
/* 650 */
/***/ function(module, exports) {

/**
* Takes the given string and pads it out, to the length required, using the character
* specified. For example if you need a string to be 6 characters long, you can call:
*
* `pad('bob', 6, '-', 2)`
*
* This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
*
* You can also use it to pad numbers (they are always returned as strings):
* 
* `pad(512, 6, '0', 1)`
*
* Would return: `000512` with the string padded to the left.
*
* If you don't specify a direction it'll pad to both sides:
* 
* `pad('c64', 7, '*')`
*
* Would return: `**c64**`
*
* @method Phaser.Utils.pad
* @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
* @param {integer} [len=0] - The number of characters to be added.
* @param {string} [pad=" "] - The string to pad it out with (defaults to a space).
* @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).
* @return {string} The padded string.
*/
var Pad = function (str, len, pad, dir)
{
    if (len === undefined) { var len = 0; }
    if (pad === undefined) { var pad = ' '; }
    if (dir === undefined) { var dir = 3; }

    str = str.toString();

    var padlen = 0;

    if (len + 1 >= str.length)
    {
        switch (dir)
        {
            case 1:
                str = new Array(len + 1 - str.length).join(pad) + str;
                break;

            case 3:
                var right = Math.ceil((padlen = len - str.length) / 2);
                var left = padlen - right;
                str = new Array(left+1).join(pad) + str + new Array(right+1).join(pad);
                break;

            default:
                str = str + new Array(len + 1 - str.length).join(pad);
                break;
        }
    }

    return str;

};

module.exports = Pad;


/***/ },
/* 651 */
/***/ function(module, exports) {

/**
* Takes the given string and reverses it, returning the reversed string.
* For example if given the string `Atari 520ST` it would return `TS025 iratA`.
*
* @method Phaser.Utils.reverseString
* @param {string} string - The string to be reversed.
* @return {string} The reversed string.
*/
var ReverseString = function (string)
{
    return string.split('').reverse().join('');
};

module.exports = ReverseString;


/***/ },
/* 652 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 653 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {__webpack_require__(212);

var CONST = __webpack_require__(2);
var Extend = __webpack_require__(55);

//  This object is exported globally

var Phaser = {

    Actions: __webpack_require__(86),

    DOM: __webpack_require__(206),

    Game: __webpack_require__(205),

    Event: __webpack_require__(10),
    EventDispatcher: __webpack_require__(26),

    Math: __webpack_require__(87),

    Components: __webpack_require__(5),

    Geom: __webpack_require__(208),

    Graphics: __webpack_require__(209),

    Input: __webpack_require__(210),

    GameObjects: __webpack_require__(207),

    State: __webpack_require__(88),

    Loader: {

        ImageFile: __webpack_require__(37)

    },

    Sound: __webpack_require__(213),

    Physics: __webpack_require__(211),

    Class: __webpack_require__(3),

    Utils: {

        Align: __webpack_require__(214),
        Array: __webpack_require__(215),
        Bounds: __webpack_require__(216),
        Objects: __webpack_require__(217),
        String: __webpack_require__(218)

    }

};

//   Merge in the consts

Phaser = Extend(false, Phaser, CONST);

//  Export it

module.exports = Phaser;

global.Phaser = Phaser;

/*
 * “Sometimes, the elegant implementation is just a function.
 * Not a method. Not a class. Not a framework. Just a function.”
 * - John Carmack
 */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(89)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAxZTMxYzgwYmY3NzVlMDcxMDQxMyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Db21tb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9DbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvVmVjdG9yLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvR2V0T2JqZWN0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL2V2ZW50cy9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9HZXRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldFRvcC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9TZXRSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL1NldFRvcC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9PUy5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL09TLmpzIiwid2VicGFjazovLy8uLi9kb20vQ2FudmFzUG9vbC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RvbS9DYW52YXNQb29sLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9ib2R5L0NvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9WZXJ0aWNlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1ZlcnRpY2VzLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9GaWxlLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0FuZ2xlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL0NvbG9yLmpzIiwid2VicGFjazovLy8uLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldENlbnRlclkuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJYLmpzIiwid2VicGFjazovLy8uLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9JbWFnZUZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Cb2R5LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L0NvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvU2xlZXBpbmcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1NsZWVwaW5nLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci9TY2FsZU1vZGVzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1BhaXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0J1ZmZlcjMyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9zaGFkZXIvQ3JlYXRlUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0JpbmRWZXJ0ZXhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL1ZlcnRleEFycmF5LmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvRXh0ZW5kLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvb2JqZWN0L0V4dGVuZC5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0NvbW1hbmRzLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvem9uZS9ab25lLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvem9uZS9ab25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9GaW5kVC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kWFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRG90LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9Db250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvR2V0QXNwZWN0UmF0aW8uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvQ29udGFpbnNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9Sb3RhdGVBcm91bmRYWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5Q29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9YSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0RldGVjdG9yLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0RldGVjdG9yLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vR3JpZC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9HcmlkLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vU0FULmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1NBVC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Nb3VzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQm9kaWVzLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Cb2RpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L0F4ZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9BeGVzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9yZW5kZXIvUmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvQmxlbmRNb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvYnVmZmVyL0J1ZmZlcjE2LmpzIiwid2VicGFjazovLy8uLi91dGlscy9OT09QLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N0YXRlLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uLi9jYW52YXMvR2V0Q29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9EYXRhLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9EYXRhLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvQ2FudmFzRmVhdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL0FkZFRvRE9NLmpzIiwid2VicGFjazovLy8uLi9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2RvbS9ET01Db250ZW50TG9hZGVkLmpzIiwid2VicGFjazovLy8uLi9kb20vUGFyc2VYTUwuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kb20vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvR2V0Qml0bWFwVGV4dFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2xheWVyL0xheWVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9lbGxpcHNlL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvTGluZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9Ob3JtYWxBbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvR2V0TWFnbml0dWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZVNxLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L011bHRpcGx5LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvTm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvbHlnb24vQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9EZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvQ2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvRGVjb21wb3NlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0luQ2VudGVyLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvQWRkLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Db2xvckRvZGdlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0Rhcmtlbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaWdodGVuLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckJ1cm4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckJ1cm4uanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyRG9kZ2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUmVmbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9WaXZpZExpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9WaXZpZExpZ2h0LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9Db21wb25lbnRUb0hleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IzMi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSFNWVG9SR0IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSGV4U3RyaW5nVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL0hleFN0cmluZ1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSHVlVG9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvSW50ZWdlclRvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb1JHQi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvUkdCU3RyaW5nVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL1JHQlN0cmluZ1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL1ZhbHVlVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2NvbWJvL0tleUNvbWJvLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9rZXlib2FyZC9jb21iby9Qcm9jZXNzS2V5Q29tYm8uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvS2V5LmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9NZXJnZVhIUlNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Jlcm5zdGVpbi5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvQmVybnN0ZWluLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvRmFjdG9yaWFsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0xpbmVhci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3VuZEF3YXlGcm9tWmVyby5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9TbW9vdGhTdGVwLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1Ntb290aGVyU3RlcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9Ob3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvV3JhcC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9ib2R5L1dvcmxkLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Xb3JsZC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0NvbnRhY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlycy5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlycy5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1Jlc29sdmVyLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL1Jlc29sdmVyLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL0VuZ2luZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRW5naW5lLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL01ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL01ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUGx1Z2luLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvY29yZS9QbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvcG9seS1kZWNvbXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1N5c3RlbXMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9TeXN0ZW1zLmpzIiwid2VicGFjazovLy8uLi9zdHJ1Y3RzL1NldC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JbkJvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JbkJvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JbkNlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5MZWZ0Q2VudGVyLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5MZWZ0Q2VudGVyLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5SaWdodENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Ub3BDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9JblRvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vSW5Ub3BMZWZ0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Ub3BMZWZ0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vSW5Ub3BSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L051bWJlckFycmF5LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9RdWlja1NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9SYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYXJyYXkvUm90YXRlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1NwbGljZU9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYm91bmRzL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uLi91dGlscy9vYmplY3QvSXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9HYW1lLmpzIiwid2VicGFjazovLy8uLi9kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3BvbHlmaWxscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zb3VuZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi91dGlscy9ib3VuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9ib3VuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL0FuZ2xlLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL0NhbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvR3JpZEFsaWduLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9HcmlkQWxpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvSW5jQWxwaGEuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvSW5jWC5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9JbmNYWS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9JbmNZLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1BsYWNlT25DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUGxhY2VPbkxpbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hY3Rpb25zL1BsYWNlT25MaW5lLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1BsYWNlT25SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hY3Rpb25zL1BsYWNlT25SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUGxhY2VPblRyaWFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9QbGFjZU9uVHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUmFuZG9tQ2lyY2xlLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9SYW5kb21DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUmFuZG9tRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FjdGlvbnMvUmFuZG9tRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9SYW5kb21MaW5lLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9SYW5kb21MaW5lLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1JhbmRvbVJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FjdGlvbnMvUmFuZG9tUmVjdGFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1JhbmRvbVRyaWFuZ2xlLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9SYW5kb21UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUm90YXRlQXJvdW5kLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9Sb3RhdGVBcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvUm90YXRlQXJvdW5kRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hY3Rpb25zL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1NjYWxlWC5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9TY2FsZVhZLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1NjYWxlWS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9TZXRBbHBoYS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9TZXRPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvU2V0Um90YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvU2V0U2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvU2V0U2NhbGVYLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1NldFNjYWxlWS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9TZXRWaXNpYmxlLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1NldFguanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvU2V0WFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2FjdGlvbnMvU2V0WS5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9TbW9vdGhTdGVwLmpzIiwid2VicGFjazovLy9zcmMvYWN0aW9ucy9TbW9vdGhTdGVwLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1Ntb290aGVyU3RlcC5qcyIsIndlYnBhY2s6Ly8vc3JjL2FjdGlvbnMvU21vb3RoZXJTdGVwLmpzIiwid2VicGFjazovLy8uLi9hY3Rpb25zL1NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi4vYWN0aW9ucy9Ub2dnbGVWaXNpYmxlLmpzIiwid2VicGFjazovLy8uLi9hbmltYXRpb24vQW5pbWF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FuaW1hdGlvbi9BbmltYXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9ib290L0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvQ29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvYm9vdC9DcmVhdGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vYm9vdC9EZWJ1Z0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2Jvb3QvRGVidWdIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2Jvb3QvTWFpbkxvb3AuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ib290L01haW5Mb29wLmpzIiwid2VicGFjazovLy8uLi9jYWNoZS9CYXNlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jYWNoZS9CYXNlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhY2hlL0NhY2hlLmpzIiwid2VicGFjazovLy9zcmMvY2FjaGUvQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhY2hlL0NhY2hlRW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvY2FjaGUvZXZlbnRzL0NhY2hlQWRkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvY2FjaGUvZXZlbnRzL0NhY2hlUmVtb3ZlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NhY2hlL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhY2hlL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vY2FtZXJhL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vc3JjL2NhbWVyYS9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4uL2NoZWNrc3VtLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL0FscGhhLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9BbHBoYS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9CbGVuZE1vZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL0JsZW5kTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9Db2xvci5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9GbGlwLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL0dldEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9PcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvUmVuZGVyUGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9TY2FsZU1vZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL1NjYWxlTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vY29tcG9uZW50cy9TaXplLmpzIiwid2VicGFjazovLy8uLi9jb21wb25lbnRzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL2NvbXBvbmVudHMvVmlzaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL0F1ZGlvLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9GdWxsc2NyZWVuLmpzIiwid2VicGFjazovLy8uLi9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9kZXZpY2UvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vc3JjL2RldmljZS9WaWRlby5qcyIsIndlYnBhY2s6Ly8vLi4vZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZGV2aWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9kb20vQWRkRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZG9tL1JlbW92ZUV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9SZW1vdmVGcm9tRE9NLmpzIiwid2VicGFjazovLy8uLi9kb20vVG91Y2hBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2RvbS9Vc2VyU2VsZWN0LmpzIiwid2VicGFjazovLy8uLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzIiwid2VicGFjazovLy9zcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi4vZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVhNTEJpdG1hcEZvbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlcldlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQm9iLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyUmVuZGVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUNhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlUmVuZGVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvdGV4dC9HZXRUZXh0U2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvdGV4dC9NZWFzdXJlVGV4dC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL3RleHQvTWVhc3VyZVRleHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3RleHQvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvdGV4dC9UZXh0U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRDYW52YXNSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dFJlbmRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRXZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9nYW1lb2JqZWN0cy96b25lL1pvbmVGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvZ2FtZW9iamVjdHMvem9uZS9ab25lRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQXJlYS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ2lyY3VtZmVyZW5jZVBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vY2lyY2xlL0Nsb25lLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9jaXJjbGUvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vY2lyY2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9FcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2VsbGlwc2UvR2V0Qm91bmRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2VsbGlwc2UvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vZWxsaXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL0dldEFuZ2xlV2l0aERpc3RhbmNlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0UG9pbnRXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvR2V0UG9pbnRXaXRoRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaGVybWl0ZS9HZXRYLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2hlcm1pdGUvR2V0WS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL0hlcm1pdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9oZXJtaXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvQ2lyY2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9HZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmVTZWdtZW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1RyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvQ2lyY2xlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9UcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvVHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0NlbnRlck9uLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0dldE1pZFBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvR2V0Tm9ybWFsLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL0dldE5vcm1hbC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0hlaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbFguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvTm9ybWFsWC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvTm9ybWFsWS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1BlcnBTbG9wZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vbGluZS9SZWZsZWN0QW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUm90YXRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL2xpbmUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9TZXRUb0FuZ2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL2xpbmUvU2xvcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vbGluZS9XaWR0aC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9saW5lL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0FkZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9DZWlsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Db3B5RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Dcm9zcy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9EaXZpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvRXF1YWxzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0Zsb29yLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvSW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvSW52ZXJ0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9OZWdhdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9pbnQvUGVycC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2ludC9Qcm9qZWN0VW5pdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9SUGVycC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9TZXRNYWduaXR1ZGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2ludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcG9seWdvbi9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL0dldEFBQkIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcG9seWdvbi9HZXROdW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZWlsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvQ29weUZyb20uanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9GaXRPdXRzaWRlLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0Zsb29yQWxsLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9HZXRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0dldFNpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL0luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlUG9pbnRzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL01lcmdlWFkuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL09mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvT2Zmc2V0UG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vcmVjdGFuZ2xlL092ZXJsYXBzLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXJQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vcmVjdGFuZ2xlL1BlcmltZXRlclBvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3JlY3RhbmdsZS9TY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvVW5pb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS9yZWN0YW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3JlY3RhbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9BcmVhLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0J1aWxkRXF1aWxhdGVyYWwuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3RyaWFuZ2xlL0J1aWxkRXF1aWxhdGVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9CdWlsZFJpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS90cmlhbmdsZS9CdWlsZFJpZ2h0LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0NlbnRlck9uLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS90cmlhbmdsZS9DZW50ZXJPbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9DaXJjdW1DZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0Nsb25lLmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS90cmlhbmdsZS9DbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy9zcmMvZ2VvbS90cmlhbmdsZS9Db250YWluc1BvaW50LmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0NvcHlGcm9tLmpzIiwid2VicGFjazovLy8uLi9nZW9tL3RyaWFuZ2xlL0VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3RyaWFuZ2xlL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ2VvbS90cmlhbmdsZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dlb20vdHJpYW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9nZW9tL3RyaWFuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9FeGNsdXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvR2xvdy5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvR2xvdy5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTGlnaHQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTWl4LmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9IYXJkTWl4LmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckxpZ2h0LmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9NdWx0aXBseS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9OZWdhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9Ob3JtYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvUGhvZW5peC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvUGluTGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvU2NyZWVuLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9ibGVuZG1vZGVzL1NvZnRMaWdodC5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0NTU1RvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9Db2xvclRvUkdCQS5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvSFNMVG9Db2xvci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL0hTTFRvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dyYXBoaWNzL2NvbG9yL0hTVkNvbG9yV2hlZWwuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9IU1ZDb2xvcldoZWVsLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9JbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL0ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9SR0JUb0hTVi5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvUkdCVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9ncmFwaGljcy9jb2xvci9SR0JUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vZ3JhcGhpY3MvY29sb3IvUmFuZG9tUkdCLmpzIiwid2VicGFjazovLy9zcmMvZ3JhcGhpY3MvY29sb3IvUmFuZG9tUkdCLmpzIiwid2VicGFjazovLy8uLi9ncmFwaGljcy9jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2dyYXBoaWNzL2NvbG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2NvbWJvL0FkdmFuY2VLZXlDb21iby5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm9NYXRjaEV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm9NYXRjaEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9jb21iby9SZXNldEtleUNvbWJvLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleURvd25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5VXBFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2lucHV0L2tleWJvYXJkL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9rZXlzL0Rvd25EdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9KdXN0RG93bi5qcyIsIndlYnBhY2s6Ly8vLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9KdXN0VXAuanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleURvd24uanMiLCJ3ZWJwYWNrOi8vLy4uL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleVVwLmpzIiwid2VicGFjazovLy8uLi9pbnB1dC9rZXlib2FyZC9rZXlzL1VwRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL0Jhc2VMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9HZXRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9YSFJMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvWEhSTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9ldmVudHMvTG9hZGVyU3RhcnRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9ldmVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwid2VicGFjazovLy8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpdG1hcEZvbnRGaWxlLmpzIiwid2VicGFjazovLy9zcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9HTFNMRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvU1ZHRmlsZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvU1ZHRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbG9hZGVyL2ZpbGV0eXBlcy9TcHJpdGVTaGVldC5qcyIsIndlYnBhY2s6Ly8vc3JjL2xvYWRlci9maWxldHlwZXMvU3ByaXRlU2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9sb2FkZXIvZmlsZXR5cGVzL1RleHRGaWxlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0F2ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvQ2VpbFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0RlZ1RvUmFkLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9EZWdUb1JhZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9EaWZmZXJlbmNlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL0Zsb2F0QmV0d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9GbG9vclRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL01heEFkZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9NaW5TdWIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUGVyY2VudC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9SYWRUb0RlZy5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvUmFkVG9EZWcuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvUm90YXRlLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1JvdGF0ZUFyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9Sb3VuZFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1NpbkNvc1RhYmxlR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL1dpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9CZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL0JldHdlZW5Qb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50c1kuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvQmV0d2VlblkuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9hbmdsZS9Sb3RhdGVUby5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvYW5nbGUvUm90YXRlVG8uanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2FuZ2xlL2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9hbmdsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVBvd2VyLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlU3F1YXJlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL21hdGgvZGlzdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0JhY2suanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0JvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvQ2lyY3VsYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL0N1YmljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9FbGFzdGljLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9FeHBvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Vhc2luZy9MaW5lYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVhcnRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvUXVpbnRpYy5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvU2luZS5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9lYXNpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2Vhc2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9mdXp6eS9DZWlsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0VxdWFsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0Zsb29yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0dyZWF0ZXJUaGFuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L0xlc3NUaGFuLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2Z1enp5L2luZGV4LmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9mdXp6eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vQmV6aWVySW50ZXJwb2xhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy9zcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9HZXRQb3dlck9mVHdvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3BvdzIvSXNWYWx1ZVBvd2VyT2ZUd28uanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL3BvdzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL21hdGgvcG93Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9yYW5kb20tZGF0YS1nZW5lcmF0b3IvUmFuZG9tRGF0YUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbWF0aC9zbmFwL1NuYXBDZWlsLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcEZsb29yLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvU25hcFRvLmpzIiwid2VicGFjazovLy8uLi9tYXRoL3NuYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYXRoL3NuYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9RdWVyeS5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9RdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL01hdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1J1bm5lci5qcyIsIndlYnBhY2s6Ly8vLi4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Db21wb3NpdGVzLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Db21wb3NpdGVzLmpzIiwid2VicGFjazovLy8uLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9TdmcuanMiLCJ3ZWJwYWNrOi8vL3NyYy9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9TdmcuanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL21vZHVsZS9tYWluLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvbW9kdWxlL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4uL3BoeXNpY3MvbWF0dGVyLWpzL3JlbmRlci9SZW5kZXJQaXhpLmpzIiwid2VicGFjazovLy9zcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlclBpeGkuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvQXJyYXkuaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvRnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL01hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9VaW50MzJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vcG9seWZpbGxzL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3BvbHlmaWxscy9wZXJmb3JtYW5jZS5ub3cuanMiLCJ3ZWJwYWNrOi8vL3NyYy9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9CbGl0SW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9EcmF3SW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL2NhbnZhcy91dGlscy9HZXRCbGVuZE1vZGVzLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9BQVF1YWRCYXRjaC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0FBUXVhZEJhdGNoLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9GcmFnbWVudFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvVmVydGV4U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvQmxpdHRlckJhdGNoLmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0ZyYWdtZW50U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvVmVydGV4U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2JsaXR0ZXIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvRnJhZ21lbnRTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvU2hhcGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvU2hhcGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9WZXJ0ZXhTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvY29uc3QuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2NvbnN0LmpzIiwid2VicGFjazovLy9zcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9lYXJjdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvZWFyY3V0LmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9GcmFnbWVudFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2guanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvVmVydGV4U2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc3ByaXRlL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9yZW5kZXJlci93ZWJnbC91dGlscy9DcmVhdGVFbXB0eVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc291bmQvZHluYW1pYy9GWC5qcyIsIndlYnBhY2s6Ly8vc3JjL3NvdW5kL2R5bmFtaWMvRlguanMiLCJ3ZWJwYWNrOi8vLy4uL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3NyYy9zb3VuZC9keW5hbWljL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9HbG9iYWxTdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9HbG9iYWxTdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL1NldHRpbmdzLmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0NhbWVyYU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0NhbWVyYU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RDcmVhdG9yLmpzIiwid2VicGFjazovLy8uLi9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzIiwid2VicGFjazovLy9zcmMvc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RhdGUvc3lzdGVtcy9TdGF0ZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0YXRlL3N5c3RlbXMvVXBkYXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vc3RydWN0cy9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3N0cnVjdHMvUlRyZWUuanMiLCJ3ZWJwYWNrOi8vL3NyYy9zdHJ1Y3RzL1JUcmVlLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9GcmFtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL0ZyYW1lLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9UZXh0dXJlLmpzIiwid2VicGFjazovLy9zcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvVGV4dHVyZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9JbWFnZVRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvSlNPTkFycmF5VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OSGFzaFRleHR1cmVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3RleHR1cmVzL3BhcnNlcnMvUHl4ZWxUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL1Nwcml0ZVNoZWV0VGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyLmpzIiwid2VicGFjazovLy8uLi90ZXh0dXJlcy9wYXJzZXJzL1N0YXJsaW5nWE1MVGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vc3JjL3RleHR1cmVzL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL0FsaWduSW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9BbGlnbkluLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvQm90dG9tQ2VudGVyLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub0JvdHRvbUxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvQm90dG9tUmlnaHQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub0xlZnRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub0xlZnRCb3R0b20uanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvTGVmdENlbnRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvTGVmdENlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub1JpZ2h0Qm90dG9tLmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYWxpZ24vVG9SaWdodEJvdHRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYWxpZ24vVG9SaWdodENlbnRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRDZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvUmlnaHRUb3AuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3V0aWxzL2FsaWduL1RvVG9wQ2VudGVyLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hbGlnbi9Ub1RvcExlZnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub1RvcExlZnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FsaWduL1RvVG9wUmlnaHQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9GaW5kQ2xvc2VzdEluU29ydGVkLmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9HZXRSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9OdW1iZXJBcnJheVN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy91dGlscy9hcnJheS9SZW1vdmVSYW5kb21FbGVtZW50LmpzIiwid2VicGFjazovLy8uLi91dGlscy9hcnJheS9TdGFibGVTb3J0LmpzIiwid2VicGFjazovLy9zcmMvdXRpbHMvYXJyYXkvU3RhYmxlU29ydC5qcyIsIndlYnBhY2s6Ly8vLi4vdXRpbHMvYm91bmRzL0dldE9mZnNldFguanMiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzL2JvdW5kcy9HZXRPZmZzZXRZLmpzIiwid2VicGFjazovLy8uLi91dGlscy9zdHJpbmcvUGFkLmpzIiwid2VicGFjazovLy8uLi91dGlscy9zdHJpbmcvUmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3JpY2gvRG9jdW1lbnRzL3BoYXNlci92My9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vc3JjL3BoYXNlci5qcyIsIndlYnBhY2s6Ly8vLi4vcGhhc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7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QThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNURBOztBQUVBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEs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QSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQSwrQ0NBQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsR0FBRyx1QkFBdUIsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDclFBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNq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QTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRXpwQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRTdHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYSxHQUFHLGVBQWUsR0FBRyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlELFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2Qix1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwrQztBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRTViRCxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FFeE5BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDBCQUEwQixPQUFPO0FBQ2pDLDhCQUE4QixXQUFXO0FBQ3pDLCtCQUErQixZQUFZOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCOztBQUVuRDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM3TkEsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7O0FBRWxEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDekxBLFNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU8sc0dBQXNHO0FBQzlIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRTVLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQyw4QkFBOEIsV0FBVztBQUN6Qyw2QkFBNkIsVUFBVTtBQUN2Qyw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7OztBQUdEOzs7Ozs7O0FFaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwQkEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7QUFDdkMsK0JBQStCLFFBQVE7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQyxvQkFBb0IsYUFBYTtBQUNqQztBQUNBLDhCQUE4QixhQUFhO0FBQzNDLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCwyQ0FBMkM7QUFDOUY7QUFDQSxtREFBbUQseUNBQXlDO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxREFBcUQsdUJBQXVCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYSxHQUFHLGVBQWUsR0FBRyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUVoSUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsY0FBYzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDakRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUU3SEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkEsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkEsb0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFakZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FFbkNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUU3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsb0JBQW9CO0FBQzlCLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsTUFBTTtBQUNoQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0MsZ0NBQWdDLGNBQWM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQsNEJBQTRCLFVBQVU7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkZBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hELDhCQUE4QixjQUFjO0FBQzVDLDZCQUE2QixXQUFXO0FBQ3hDLGlDQUFpQyxlQUFlO0FBQ2hELGdDQUFnQyxhQUFhOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7O0FBRUEsZ0VBQWdFLHdCQUF3QjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUUxR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxXQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0QsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRWhVRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSztBQUNwQixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1Qzs7QUFFQSw0QjtBQUNBLDBCO0FBQ0EsYUFBYSxzQjtBQUNiLDBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFN1FEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUV4TUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBLHlCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5QjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixrQkFBa0I7QUFDekM7O0FBRUEsK0JBQStCLGtCQUFrQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlELHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsd0JBQXdCO0FBQ3RFLG9DQUFvQyxhQUFhOztBQUVqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRTFVRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQSwyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFL0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwrQkFBK0Isd0JBQXdCLEVBQUUsYUFBYTs7QUFFbEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEM7QUFDQSxrQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0Msa0JBQWtCO0FBQ2xCOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLG9HOztBQUVBLDZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFNzdDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ05BOztBQUVBOztBQUVBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUV6Q0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFbkRBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUV0Q0E7O0FBRUE7QUFDQSxpQkFBaUIsYUFBYSxFQUFFOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUVqU0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRS9FQSxTQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbk9BO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCOztBQUU5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLFNDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFckRBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRWhIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0dBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUMsaUNBQWlDLFdBQVc7QUFDNUMsa0NBQWtDLGdCQUFnQjs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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QTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUV4QkEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUU5VUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FFckNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUV2YUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTztBQUNyQyxpQ0FBaUMsV0FBVzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FFN1FBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQywwQkFBMEIsT0FBTztBQUNqQywrQkFBK0IsWUFBWTs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQ3hKQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVB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QjtBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1SUEsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVhBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEEsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXBCQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVwRUEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHFDQUFxQyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFdENBLDhDQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN4Q0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBRTdJQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXhEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN4R0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBRXpCQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFdENBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFN0NBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsTUFBTTtBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBLFdDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEEsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUI7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25ELHNCQUFzQiwyQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLDZCQUE2QixRQUFRLDJCQUEyQjtBQUN4Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsTUFBTTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsS0FBSztBQUNyQixpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsV0FBVztBQUMzQixpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxDQUFDOzs7Ozs7O0FFaklEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQ3JDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQSw4QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7O0FFM0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRXZWRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNELDhCQUE4Qjs7QUFFcEY7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCwrQkFBK0I7O0FBRXRGO0FBQ0Esb0RBQW9ELDRCQUE0Qjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxD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QUEsQ0NBQSxHREFBO0FBQ0Esd0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUxSkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuTEEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwyQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBOztBQ0VBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTtBQ0NBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7QUFFQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOzs7Ozs7O0FFL0JBOztBQUVBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTs7QUFFQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRVBBOztBQUVBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTkE7O0FBRUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBOzs7Ozs7O0FFTEEsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBO0FEQ0EsbUJDQUEsQ0RBQSxHQ0FBOzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVOQTs7QUFFQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTFCQTs7QUFFQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTs7QUFFQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7Ozs7Ozs7QUVwQkE7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVMQTs7QUFFQSxTQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFTEE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxXQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0lBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxpQ0FBaUMsaUJBQWlCOztBQUVsRDtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ25CQSxzQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXRCQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVsQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIscUVBQXFFO0FBQ25HLDhCQUE4QixxRUFBcUU7QUFDbkcsOEJBQThCLHFFQUFxRTs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkEsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkEsMkJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVwQkEsK0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbkJBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsOEJBQThCLFdBQVc7O0FBRXpDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QyxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsOEJBQThCLFdBQVc7O0FBRXpDLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTs7QUFFdkMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1pBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFckRBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxXQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsV0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixhQUFhOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFakZBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EscUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXhGQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRTNGQSw0QkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxvQ0FBb0MseUJBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXpQQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkRBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWRBOztBQUVBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLHNCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFdBQVc7QUFDM0Msa0NBQWtDLGFBQWE7QUFDL0MsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0Msa0NBQWtDLGFBQWE7QUFDL0MsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXhOQTtBQUNBO0FBQ0E7QUFDQSwwQjs7Ozs7O0FDSEEsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQSxjQUFjOztBQUVkOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBRXBDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLGNBQWMsUUFBUTtBQUN0QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDOXNCQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7OztBQzVZQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ25DQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsbUNBQW1DOztBQUVqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLDhCQUE4QixPQUFPOztBQUVyQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUUzUUEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUViQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0MsaUNBQWlDLGNBQWM7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQywwRUFBMEU7O0FBRXBIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEpBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkJBOztBQUVBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLDBFQUEwRTs7QUFFcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUzTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0hBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkJBOztBQUVBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXpMQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFbkJBOztBQUVBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDREQUE0RCxzQkFBc0I7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFclVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1JBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsdUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyx3RUFBd0U7QUFDdEYsY0FBYyxjQUFjO0FBQzVCLGNBQWMsYUFBYTtBQUMzQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFx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QTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhC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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7O0FBRUEsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw0QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVpBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUUzWUE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsK0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsMEJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsK0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRWJBLHNCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5QkEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsMkJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLHdCQUF3QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDckZBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUVoQkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXRFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ1hBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFdkNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUU5QkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWpFQTs7QUFFQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw4QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7O0FFbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkEsV0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZCxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxpQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLGlCQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUkEsaUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEIsVUFBVSxZQUFZO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFakJBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFVkEscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBOztBQUVBLFdDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EseUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTVCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVyQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWJBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVUQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEEsVUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFbkJBLFVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLENEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWxCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFVkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUU3QkEsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FFZkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQSx5QkFB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEMsdUJBQXVCLG9CQUFvQjtBQUMzQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNycEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUMsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRVZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRVBBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkEscUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTNCQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFM0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkEsaUJDQUEsbUJEQUEsQ0NBQSxDREFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxjQUFjOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVsQkE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLDBCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLHNCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNB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QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkEscUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVWQSxxQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVQQTs7QUFFQSxlQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw0QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw0QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx3QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSw2QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwwQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7Ozs7Ozs7QUUxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSw2RjtBQUNBO0FBQ0E7QUFDQSwyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUUzQkEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVuQkEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVsQkE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0EsMkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hCQTs7QUFFQTs7QUFFQSxTQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxZQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRTlCQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXpCQSxlQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU87O0FBRWpDOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFMUJBLGFDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qyw4QkFBOEIsV0FBVzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsOEJBQThCLFdBQVc7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTs7Ozs7OztBQ2pEQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVqQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLDRCQUE0QixXQUFXOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTs7QUFFQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxzQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUV2QkE7O0FBRUEsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FFcENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBLFlDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDWEEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBLFlDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVaQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0Esb0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBRTFDQTs7QUFFQTs7QUFFQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsU0NBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBOzs7Ozs7O0FFaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlOztBQUVoRDtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7O0FBRWhEO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDZEEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esc0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRixxQkFBcUI7O0FBRXJHO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx5REFBeUQ7O0FBRTNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUVuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSx1QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRXJDQSxZQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFWkEsWUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRVpBOztBQUVBLHdCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLDJCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTs7Ozs7OztBRUxBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBOzs7Ozs7OztBRWxCQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLFdDQUEsbUJEQUEs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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdERBOztBQUVBLFVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFdDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxVQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLFlDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsVUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7Ozs7Ozs7QUVkQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjs7QUFFbEQ7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCOztBQUVsRDtBQUNBOztBQUVBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNQQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxJOzs7Ozs7QUV4TkQsOEJDQUEsbUJEQUEsQ0NBQSxHREFBOztBQUVBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsbUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsaUJDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0Esa0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxlQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxvQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGtCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUVsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsQ0RBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwrQkFBK0Isd0JBQXdCLEVBQUUsYUFBYTs7QUFFbEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsa0RBQWtELGNBQWM7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDO0FBQ0EseUQ7QUFDQTs7QUFFQTtBQUNBLDZDO0FBQ0EscUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsS0FBSztBQUNwQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBRWxnQkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ3BMRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFCQUFxQjs7QUFFaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCOztBQUU5RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBRXJSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVDQSxZQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUU3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsWUNBQSxtQkRBQSxDQ0FBLENEQUE7QUFDQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSwyQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxtQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELHFCQUFxQjtBQUM5RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FFN1hBLHNCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG9CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLG1CQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLHVCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUEsbUJDQUEsbUJEQUEsQ0NBQSxDREFBO0FBQ0EsWUNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Szs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFF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QSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUEsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsR0RBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxHREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxvQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxxQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxrQkNBQSxtQkRBQSxDQ0FBLEdEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQSx5QkNBQSxtQkRBQSxDQ0FBLEdEQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7Ozs7OztBRTFWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7O0FBRWhEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDOUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcEtBLGtCQ0FBLG1CREFBLENDQUEsR0RBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7Ozs7Ozs7QUVuQkEsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxpQkNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsY0NBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxhQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLGdDQUFnQyxhQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUVoQkEsZUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxnQkNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGdCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MsZ0NBQWdDLGFBQWE7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBRWhCQSxlQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGNDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGVDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsYUNBQSxtQkRBQSxDQ0FBLEVEQUE7QUFDQSxjQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxnQ0FBZ0MsYUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FFaEJBLGlCQ0FBLG1CREFBLENDQUEsRURBQTtBQUNBLGFDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsaUJDQUEsbUJEQUEsQ0NBQSxFREFBO0FBQ0EsZ0JDQUEsbUJEQUEs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7OzhDQ25MdEMsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLFlEQUEsbUJDQUEsQ0RBQSxDQ0FBO0FBQ0EsYURBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUE7O0FBRUE7O0FBRUEsYURBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUEsU0RBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUEsVURBQSxtQkNBQSxDREFBLEdDQUE7O0FBRUEsV0RBQSxtQkNBQSxDREFBLEVDQUE7QUFDQSxxQkRBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUEsVURBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUEsZ0JEQUEsbUJDQUEsQ0RBQSxDQ0FBOztBQUVBLFVEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLGNEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLFdEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBLGlCREFBLG1CQ0FBLENEQUEsR0NBQTs7QUFFQSxXREFBLG1CQ0FBLENEQUEsRUNBQTs7QUFFQTs7QUFFQSxtQkRBQSxtQkNBQSxDREFBLEVDQUE7O0FBRUEsS0FBSzs7QUFFTCxXREFBLG1CQ0FBLENEQUEsR0NBQTs7QUFFQSxhREFBLG1CQ0FBLENEQUEsR0NBQTs7QUFFQSxXREFBLG1CQ0FBLENEQUEsQ0NBQTs7QUFFQTs7QUFFQSxlREFBLG1CQ0FBLENEQUEsR0NBQTtBQUNBLGVEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0EsZ0JEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0EsaUJEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0EsZ0JEQUEsbUJDQUEsQ0RBQSxHQ0FBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoicGhhc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJQaGFzZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUGhhc2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBoYXNlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9yeSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb3J5IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHR9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjUzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxZTMxYzgwYmY3NzVlMDcxMDQxMyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Db21tb25gIG1vZHVsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSBjb21tb24gdG8gYWxsIG1vZHVsZXMuXG4qXG4qIEBjbGFzcyBDb21tb25cbiovXG5cbnZhciBDb21tb24gPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tb247XG5cbihmdW5jdGlvbigpIHtcblxuICAgIENvbW1vbi5fbmV4dElkID0gMDtcbiAgICBDb21tb24uX3NlZWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kcyB0aGUgb2JqZWN0IGluIHRoZSBmaXJzdCBhcmd1bWVudCB1c2luZyB0aGUgb2JqZWN0IGluIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgKiBAcGFyYW0ge30gb2JqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkZWVwXG4gICAgICogQHJldHVybiB7fSBvYmogZXh0ZW5kZWRcbiAgICAgKi9cbiAgICBDb21tb24uZXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBkZWVwKSB7XG4gICAgICAgIHZhciBhcmdzU3RhcnQsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgZGVlcENsb25lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVlcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBhcmdzU3RhcnQgPSAyO1xuICAgICAgICAgICAgZGVlcENsb25lID0gZGVlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3NTdGFydCA9IDE7XG4gICAgICAgICAgICBkZWVwQ2xvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3NTdGFydDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWVwQ2xvbmUgJiYgc291cmNlW3Byb3BdICYmIHNvdXJjZVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtwcm9wXSB8fCBvYmpbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IG9ialtwcm9wXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21tb24uZXh0ZW5kKG9ialtwcm9wXSwgZGVlcENsb25lLCBzb3VyY2VbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xvbmUgb2YgdGhlIG9iamVjdCwgaWYgZGVlcCBpcyB0cnVlIHJlZmVyZW5jZXMgd2lsbCBhbHNvIGJlIGNsb25lZC5cbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHBhcmFtIHt9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZGVlcFxuICAgICAqIEByZXR1cm4ge30gb2JqIGNsb25lZFxuICAgICAqL1xuICAgIENvbW1vbi5jbG9uZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCkge1xuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZCh7fSwgZGVlcCwgb2JqKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBrZXlzIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2Qga2V5c1xuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIENvbW1vbi5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgICAgIC8vIGF2b2lkIGhhc093blByb3BlcnR5IGZvciBwZXJmb3JtYW5jZVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdGhlIG9iamVjdHMgcHJvcGVydHkgdmFsdWVzXG4gICAgICovXG4gICAgQ29tbW9uLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBhdm9pZCBoYXNPd25Qcm9wZXJ0eSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGZyb20gYGJhc2VgIHJlbGF0aXZlIHRvIHRoZSBgcGF0aGAgc3RyaW5nLlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHBhcmFtIHt9IG9iaiBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAsIGUuZy4gJ0Zvby5CYXIuYmF6J1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dIFBhdGggc2xpY2UgYmVnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcbiAgICAgKiBAcmV0dXJuIHt9IFRoZSBvYmplY3QgYXQgdGhlIGdpdmVuIHBhdGhcbiAgICAgKi9cbiAgICBDb21tb24uZ2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoYmVnaW4sIGVuZCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgb24gYGJhc2VgIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBgcGF0aGAgc3RyaW5nLlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHt9IG9iaiBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAsIGUuZy4gJ0Zvby5CYXIuYmF6J1xuICAgICAqIEBwYXJhbSB7fSB2YWwgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dIFBhdGggc2xpY2UgYmVnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcbiAgICAgKiBAcmV0dXJuIHt9IFBhc3MgdGhyb3VnaCBgdmFsYCBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBDb21tb24uc2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLicpLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICBDb21tb24uZ2V0KG9iaiwgcGF0aCwgMCwgLTEpW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGhleCBjb2xvdXIgc3RyaW5nIG1hZGUgYnkgbGlnaHRlbmluZyBvciBkYXJrZW5pbmcgY29sb3IgYnkgcGVyY2VudC5cbiAgICAgKiBAbWV0aG9kIHNoYWRlQ29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBoZXggY29sb3VyXG4gICAgICovXG4gICAgQ29tbW9uLnNoYWRlQ29sb3IgPSBmdW5jdGlvbihjb2xvciwgcGVyY2VudCkgeyAgIFxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1NjAyNDgvcHJvZ3JhbW1hdGljYWxseS1saWdodGVuLW9yLWRhcmtlbi1hLWhleC1jb2xvclxuICAgICAgICB2YXIgY29sb3JJbnRlZ2VyID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksMTYpLCBcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGgucm91bmQoMi41NSAqIHBlcmNlbnQpLCBcbiAgICAgICAgICAgIFIgPSAoY29sb3JJbnRlZ2VyID4+IDE2KSArIGFtb3VudCwgXG4gICAgICAgICAgICBCID0gKGNvbG9ySW50ZWdlciA+PiA4ICYgMHgwMEZGKSArIGFtb3VudCwgXG4gICAgICAgICAgICBHID0gKGNvbG9ySW50ZWdlciAmIDB4MDAwMEZGKSArIGFtb3VudDtcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgKDB4MTAwMDAwMCArIChSIDwgMjU1ID8gUiA8IDEgPyAwIDogUiA6MjU1KSAqIDB4MTAwMDAgXG4gICAgICAgICAgICAgICAgKyAoQiA8IDI1NSA/IEIgPCAxID8gMCA6IEIgOiAyNTUpICogMHgxMDAgXG4gICAgICAgICAgICAgICAgKyAoRyA8IDI1NSA/IEcgPCAxID8gMCA6IEcgOiAyNTUpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxuICAgICAqIEBtZXRob2Qgc2h1ZmZsZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybiB7YXJyYXl9IGFycmF5IHNodWZmbGVkIHJhbmRvbWx5XG4gICAgICovXG4gICAgQ29tbW9uLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKENvbW1vbi5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBjaG9vc2VzIGEgdmFsdWUgZnJvbSBhIGxpc3Qgd2l0aCBlcXVhbCBwcm9iYWJpbGl0eS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxuICAgICAqIEBtZXRob2QgY2hvb3NlXG4gICAgICogQHBhcmFtIHthcnJheX0gY2hvaWNlc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSByYW5kb20gY2hvaWNlIG9iamVjdCBmcm9tIHRoZSBhcnJheVxuICAgICAqL1xuICAgIENvbW1vbi5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzKSB7XG4gICAgICAgIHJldHVybiBjaG9pY2VzW01hdGguZmxvb3IoQ29tbW9uLnJhbmRvbSgpICogY2hvaWNlcy5sZW5ndGgpXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqIEBtZXRob2QgaXNFbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBDb21tb24uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg0Mjg2L2phdmFzY3JpcHQtaXNkb20taG93LWRvLXlvdS1jaGVjay1pZi1hLWphdmFzY3JpcHQtb2JqZWN0LWlzLWEtZG9tLW9iamVjdFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqPT09XCJvYmplY3RcIikgJiZcbiAgICAgICAgICAgICAgKG9iai5ub2RlVHlwZT09PTEpICYmICh0eXBlb2Ygb2JqLnN0eWxlID09PSBcIm9iamVjdFwiKSAmJlxuICAgICAgICAgICAgICAodHlwZW9mIG9iai5vd25lckRvY3VtZW50ID09PVwib2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAqIEBtZXRob2QgaXNBcnJheVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgaXNQbGFpbk9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBwbGFpbiBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcuXG4gICAgICogQG1ldGhvZCBpc1N0cmluZ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdpdmVuIHZhbHVlIGNsYW1wZWQgYmV0d2VlbiBhIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuXG4gICAgICogQG1ldGhvZCBjbGFtcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgY2xhbXBlZCBiZXR3ZWVuIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxuICAgICAqL1xuICAgIENvbW1vbi5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAbWV0aG9kIHNpZ25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0xIGlmIG5lZ2F0aXZlLCArMSBpZiAwIG9yIHBvc2l0aXZlXG4gICAgICovXG4gICAgQ29tbW9uLnNpZ24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiAxO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lc3RhbXAgKGhpZ2gtcmVzIGlmIGF2YWlsYWJsZSkuXG4gICAgICogQG1ldGhvZCBub3dcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IHRpbWVzdGFtcCAoaGlnaC1yZXMgaWYgYXZhaWxhYmxlKVxuICAgICAqL1xuICAgIENvbW1vbi5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjEyOTQvaG93LWRvLXlvdS1nZXQtYS10aW1lc3RhbXAtaW4tamF2YXNjcmlwdFxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kYXZpZHdhdGVyc3Rvbi8yOTgyNTMxXG5cbiAgICAgICAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHt9O1xuXG4gICAgICAgIHBlcmZvcm1hbmNlLm5vdyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3cgICAgfHxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgICAgfHxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgICAgfHxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm9Ob3cgICAgICAgICAgfHxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgICAgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKTsgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gdmFsdWUgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bSB2YWx1ZSBpbmNsdXNpdmUuXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cbiAgICAgKiBAbWV0aG9kIHJhbmRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heCBpbmNsdXNpdmVcbiAgICAgKi9cbiAgICBDb21tb24ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgbWluID0gKHR5cGVvZiBtaW4gIT09IFwidW5kZWZpbmVkXCIpID8gbWluIDogMDtcbiAgICAgICAgbWF4ID0gKHR5cGVvZiBtYXggIT09IFwidW5kZWZpbmVkXCIpID8gbWF4IDogMTtcbiAgICAgICAgcmV0dXJuIG1pbiArIF9zZWVkZWRSYW5kb20oKSAqIChtYXggLSBtaW4pO1xuICAgIH07XG5cbiAgICB2YXIgX3NlZWRlZFJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZ3J5bWFuLzM4MzA0ODlcbiAgICAgICAgQ29tbW9uLl9zZWVkID0gKENvbW1vbi5fc2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7XG4gICAgICAgIHJldHVybiBDb21tb24uX3NlZWQgLyAyMzMyODA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQ1NTIGhleCBjb2xvdXIgc3RyaW5nIGludG8gYW4gaW50ZWdlci5cbiAgICAgKiBAbWV0aG9kIGNvbG9yVG9OdW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBDU1MgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIENvbW1vbi5jb2xvclRvTnVtYmVyID0gZnVuY3Rpb24oY29sb3JTdHJpbmcpIHtcbiAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5yZXBsYWNlKCcjJywnJyk7XG5cbiAgICAgICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLmNoYXJBdCgwKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvclN0cmluZy5jaGFyQXQoMSkgKyBjb2xvclN0cmluZy5jaGFyQXQoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDIpICsgY29sb3JTdHJpbmcuY2hhckF0KDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zb2xlIGxvZ2dpbmcgbGV2ZWwgdG8gdXNlLCB3aGVyZSBlYWNoIGxldmVsIGluY2x1ZGVzIGFsbCBsZXZlbHMgYWJvdmUgYW5kIGV4Y2x1ZGVzIHRoZSBsZXZlbHMgYmVsb3cuXG4gICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgaXMgJ2RlYnVnJyB3aGljaCBzaG93cyBhbGwgY29uc29sZSBtZXNzYWdlcy4gIFxuICAgICAqXG4gICAgICogUG9zc2libGUgbGV2ZWwgdmFsdWVzIGFyZTpcbiAgICAgKiAtIDAgPSBOb25lXG4gICAgICogLSAxID0gRGVidWdcbiAgICAgKiAtIDIgPSBJbmZvXG4gICAgICogLSAzID0gV2FyblxuICAgICAqIC0gNCA9IEVycm9yXG4gICAgICogQHByb3BlcnR5IENvbW1vbi5sb2dMZXZlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIENvbW1vbi5sb2dMZXZlbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmxvZ2AgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxuICAgICAqIEBtZXRob2QgbG9nXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmluZm9gIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cbiAgICAgKiBAbWV0aG9kIGluZm9cbiAgICAgKiBAcGFyYW0gLi4ub2JqcyB7fSBUaGUgb2JqZWN0cyB0byBsb2cuXG4gICAgICovXG4gICAgQ29tbW9uLmluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBgY29uc29sZS53YXJuYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXG4gICAgICogQG1ldGhvZCB3YXJuXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIHNlcXVlbnRpYWwgSUQuXG4gICAgICogQG1ldGhvZCBuZXh0SWRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBzZXF1ZW50aWFsIElEXG4gICAgICovXG4gICAgQ29tbW9uLm5leHRJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ29tbW9uLl9uZXh0SWQrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBjcm9zcyBicm93c2VyIGNvbXBhdGlibGUgaW5kZXhPZiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAbWV0aG9kIGluZGV4T2ZcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBoYXlzdGFja1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZWVkbGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG90aGVyd2lzZSAtMS5cbiAgICAgKi9cbiAgICBDb21tb24uaW5kZXhPZiA9IGZ1bmN0aW9uKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKGhheXN0YWNrLmluZGV4T2YpXG4gICAgICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChoYXlzdGFja1tpXSA9PT0gbmVlZGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGNyb3NzIGJyb3dzZXIgY29tcGF0aWJsZSBhcnJheSBtYXAgaW1wbGVtZW50YXRpb24uXG4gICAgICogQG1ldGhvZCBtYXBcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge2FycmF5fSBWYWx1ZXMgZnJvbSBsaXN0IHRyYW5zZm9ybWVkIGJ5IGZ1bmMuXG4gICAgICovXG4gICAgQ29tbW9uLm1hcCA9IGZ1bmN0aW9uKGxpc3QsIGZ1bmMpIHtcbiAgICAgICAgaWYgKGxpc3QubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5tYXAoZnVuYyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFwcGVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBtYXBwZWQucHVzaChmdW5jKGxpc3RbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZGlyZWN0ZWQgZ3JhcGggYW5kIHJldHVybnMgdGhlIHBhcnRpYWxseSBvcmRlcmVkIHNldCBvZiB2ZXJ0aWNlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cbiAgICAgKiBDaXJjdWxhciBkZXBlbmRlbmNpZXMgYXJlIGFsbG93ZWQuXG4gICAgICogQG1ldGhvZCB0b3BvbG9naWNhbFNvcnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gUGFydGlhbGx5IG9yZGVyZWQgc2V0IG9mIHZlcnRpY2VzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuICAgICAqL1xuICAgIENvbW1vbi50b3BvbG9naWNhbFNvcnQgPSBmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAvLyBodHRwczovL21nZWNoZXYuZ2l0aHViLmlvL2phdmFzY3JpcHQtYWxnb3JpdGhtcy9ncmFwaHNfb3RoZXJzX3RvcG9sb2dpY2FsLXNvcnQuanMuaHRtbFxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB2aXNpdGVkID0gW10sXG4gICAgICAgICAgICB0ZW1wID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZSBpbiBncmFwaCkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW25vZGVdICYmICF0ZW1wW25vZGVdKSB7XG4gICAgICAgICAgICAgICAgX3RvcG9sb2dpY2FsU29ydChub2RlLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBfdG9wb2xvZ2ljYWxTb3J0ID0gZnVuY3Rpb24obm9kZSwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGhbbm9kZV0gfHwgW107XG4gICAgICAgIHRlbXBbbm9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0ZW1wW25laWdoYm9yXSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtuZWlnaGJvcl0pIHtcbiAgICAgICAgICAgICAgICBfdG9wb2xvZ2ljYWxTb3J0KG5laWdoYm9yLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbbm9kZV0gPSBmYWxzZTtcbiAgICAgICAgdmlzaXRlZFtub2RlXSA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIF9uXyBmdW5jdGlvbnMgYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlbSBpbiBvcmRlci5cbiAgICAgKiBUaGUgYXJndW1lbnRzIGFwcGxpZWQgd2hlbiBjYWxsaW5nIHRoZSBuZXcgZnVuY3Rpb24gd2lsbCBhbHNvIGJlIGFwcGxpZWQgdG8gZXZlcnkgZnVuY3Rpb24gcGFzc2VkLlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcmVmZXJzIHRvIHRoZSBsYXN0IHZhbHVlIHJldHVybmVkIGluIHRoZSBjaGFpbiB0aGF0IHdhcyBub3QgYHVuZGVmaW5lZGAuXG4gICAgICogVGhlcmVmb3JlIGlmIGEgcGFzc2VkIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLCB0aGUgcHJldmlvdXNseSByZXR1cm5lZCB2YWx1ZSBpcyBtYWludGFpbmVkLlxuICAgICAqIEFmdGVyIGFsbCBwYXNzZWQgZnVuY3Rpb25zIGhhdmUgYmVlbiBjYWxsZWQgdGhlIG5ldyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXN0IHJldHVybmVkIHZhbHVlIChpZiBhbnkpLlxuICAgICAqIElmIGFueSBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9ucyBhcmUgYSBjaGFpbiwgdGhlbiB0aGUgY2hhaW4gd2lsbCBiZSBmbGF0dGVuZWQuXG4gICAgICogQG1ldGhvZCBjaGFpblxuICAgICAqIEBwYXJhbSAuLi5mdW5jcyB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbnMgdG8gY2hhaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHBhc3NlZCBmdW5jdGlvbnMgaW4gb3JkZXIuXG4gICAgICovXG4gICAgQ29tbW9uLmNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmdW5jcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGZ1bmMuX2NoYWluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIGFscmVhZHkgY2hhaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBmdW5jcy5wdXNoLmFwcGx5KGZ1bmNzLCBmdW5jLl9jaGFpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnVuY3MucHVzaChmdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9kZXZ0b29scy1kb2NzL2lzc3Vlcy81MyNpc3N1ZWNvbW1lbnQtNTE5NDEzNThcbiAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0LFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jc1tpXS5hcHBseShsYXN0UmVzdWx0LCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2hhaW4uX2NoYWluZWQgPSBmdW5jcztcblxuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBiZWZvcmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYGJhc2VgLlxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxuICAgICAqIEBtZXRob2QgY2hhaW5QYXRoQmVmb3JlXG4gICAgICogQHBhcmFtIHt9IGJhc2UgVGhlIGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYmVmb3JlIHRoZSBvcmlnaW5hbFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxuICAgICAqL1xuICAgIENvbW1vbi5jaGFpblBhdGhCZWZvcmUgPSBmdW5jdGlvbihiYXNlLCBwYXRoLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uc2V0KGJhc2UsIHBhdGgsIENvbW1vbi5jaGFpbihcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICBDb21tb24uZ2V0KGJhc2UsIHBhdGgpXG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYWZ0ZXIgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYGJhc2VgLlxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxuICAgICAqIEBtZXRob2QgY2hhaW5QYXRoQWZ0ZXJcbiAgICAgKiBAcGFyYW0ge30gYmFzZSBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBhZnRlciB0aGUgb3JpZ2luYWxcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcbiAgICAgKi9cbiAgICBDb21tb24uY2hhaW5QYXRoQWZ0ZXIgPSBmdW5jdGlvbihiYXNlLCBwYXRoLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uc2V0KGJhc2UsIHBhdGgsIENvbW1vbi5jaGFpbihcbiAgICAgICAgICAgIENvbW1vbi5nZXQoYmFzZSwgcGF0aCksXG4gICAgICAgICAgICBmdW5jXG4gICAgICAgICkpO1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL0NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgc2V0VG86IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHtcblxuICAgIFZFUlNJT046ICczLjAuMCcsXG5cbiAgICBBVVRPOiAwLFxuICAgIENBTlZBUzogMSxcbiAgICBXRUJHTDogMixcbiAgICBIRUFETEVTUzogM1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRha2VuIGZyb20ga2xhc3NlIGJ5IG1hdHRkZXNsIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9rbGFzc2VcblxuZnVuY3Rpb24gaGFzR2V0dGVyT3JTZXR0ZXIgKGRlZilcbntcbiAgICByZXR1cm4gKCEhZGVmLmdldCAmJiB0eXBlb2YgZGVmLmdldCA9PT0gJ2Z1bmN0aW9uJykgfHwgKCEhZGVmLnNldCAmJiB0eXBlb2YgZGVmLnNldCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5IChkZWZpbml0aW9uLCBrLCBpc0NsYXNzRGVzY3JpcHRvcilcbntcbiAgICAvLyAgVGhpcyBtYXkgYmUgYSBsaWdodHdlaWdodCBvYmplY3QsIE9SIGl0IG1pZ2h0IGJlIGEgcHJvcGVydHkgdGhhdCB3YXMgZGVmaW5lZCBwcmV2aW91c2x5LlxuICAgIFxuICAgIC8vICBGb3Igc2ltcGxlIGNsYXNzIGRlc2NyaXB0b3JzIHdlIGNhbiBqdXN0IGFzc3VtZSBpdHMgTk9UIHByZXZpb3VzbHkgZGVmaW5lZC5cbiAgICB2YXIgZGVmID0gKGlzQ2xhc3NEZXNjcmlwdG9yKSA/IGRlZmluaXRpb25ba10gOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmluaXRpb24sIGspO1xuXG4gICAgaWYgKCFpc0NsYXNzRGVzY3JpcHRvciAmJiBkZWYudmFsdWUgJiYgdHlwZW9mIGRlZi52YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAge1xuICAgICAgICBkZWYgPSBkZWYudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gIFRoaXMgbWlnaHQgYmUgYSByZWd1bGFyIHByb3BlcnR5LCBvciBpdCBtYXkgYmUgYSBnZXR0ZXIvc2V0dGVyIHRoZSB1c2VyIGRlZmluZWQgaW4gYSBjbGFzcy5cbiAgICBpZiAoZGVmICYmIGhhc0dldHRlck9yU2V0dGVyKGRlZikpXG4gICAge1xuICAgICAgICBpZiAodHlwZW9mIGRlZi5lbnVtZXJhYmxlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVmLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY29uZmlndXJhYmxlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVmLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb25Db25maWd1cmFibGUgKG9iaiwgaylcbntcbiAgICB2YXIgcHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrKTtcblxuICAgIGlmICghcHJvcClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcC52YWx1ZSAmJiB0eXBlb2YgcHJvcC52YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAge1xuICAgICAgICBwcm9wID0gcHJvcC52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcC5jb25maWd1cmFibGUgPT09IGZhbHNlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQgKGN0b3IsIGRlZmluaXRpb24sIGlzQ2xhc3NEZXNjcmlwdG9yLCBleHRlbmQpXG57XG4gICAgZm9yICh2YXIgayBpbiBkZWZpbml0aW9uKVxuICAgIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWYgPSBnZXRQcm9wZXJ0eShkZWZpbml0aW9uLCBrLCBpc0NsYXNzRGVzY3JpcHRvcik7XG5cbiAgICAgICAgaWYgKGRlZiAhPT0gZmFsc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBJZiBFeHRlbmRzIGlzIHVzZWQsIHdlIHdpbGwgY2hlY2sgaXRzIHByb3RvdHlwZSB0byBzZWUgaWYgdGhlIGZpbmFsIHZhcmlhYmxlIGV4aXN0cy5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGV4dGVuZCB8fCBjdG9yO1xuXG4gICAgICAgICAgICBpZiAoaGFzTm9uQ29uZmlndXJhYmxlKHBhcmVudC5wcm90b3R5cGUsIGspKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBKdXN0IHNraXAgdGhlIGZpbmFsIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgaWYgKENsYXNzLmlnbm9yZUZpbmFscylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vICBXZSBjYW5ub3QgcmUtZGVmaW5lIGEgcHJvcGVydHkgdGhhdCBpcyBjb25maWd1cmFibGU9ZmFsc2UuXG4gICAgICAgICAgICAgICAgLy8gIFNvIHdlIHdpbGwgY29uc2lkZXIgdGhlbSBmaW5hbCBhbmQgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgYnlcbiAgICAgICAgICAgICAgICAvLyAgZGVmYXVsdCBzbyBpdCBpcyBjbGVhciB0byB0aGUgZGV2ZWxvcGVyIHdoYXQgaXMgaGFwcGVuaW5nLlxuICAgICAgICAgICAgICAgIC8vICBZb3UgY2FuIHNldCBpZ25vcmVGaW5hbHMgdG8gdHJ1ZSBpZiB5b3UgbmVlZCB0byBleHRlbmQgYSBjbGFzc1xuICAgICAgICAgICAgICAgIC8vICB3aGljaCBoYXMgY29uZmlndXJhYmxlPWZhbHNlOyBpdCB3aWxsIHNpbXBseSBub3QgcmUtZGVmaW5lIGZpbmFsIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgb3ZlcnJpZGUgZmluYWwgcHJvcGVydHkgXFwnJyArIGsgKyAnXFwnLCBzZXQgQ2xhc3MuaWdub3JlRmluYWxzID0gdHJ1ZSB0byBza2lwJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgaywgZGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlW2tdID0gZGVmaW5pdGlvbltrXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbWl4aW4gKG15Q2xhc3MsIG1peGlucylcbntcbiAgICBpZiAoIW1peGlucylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWl4aW5zKSlcbiAgICB7XG4gICAgICAgIG1peGlucyA9IFsgbWl4aW5zIF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBleHRlbmQobXlDbGFzcywgbWl4aW5zW2ldLnByb3RvdHlwZSB8fCBtaXhpbnNbaV0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNsYXNzIHdpdGggdGhlIGdpdmVuIGRlc2NyaXB0b3IuXG4gKiBUaGUgY29uc3RydWN0b3IsIGRlZmluZWQgYnkgdGhlIG5hbWUgYGluaXRpYWxpemVgLFxuICogaXMgYW4gb3B0aW9uYWwgZnVuY3Rpb24uIElmIHVuc3BlY2lmaWVkLCBhbiBhbm9ueW1vdXNcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB3aGljaCBjYWxscyB0aGUgcGFyZW50IGNsYXNzIChpZlxuICogb25lIGV4aXN0cykuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBgRXh0ZW5kc2AgYW5kIGBNaXhpbnNgIHRvIHByb3ZpZGUgc3ViY2xhc3NpbmdcbiAqIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAY2xhc3MgIENsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGEgZGljdGlvbmFyeSBvZiBmdW5jdGlvbnMgZm9yIHRoZSBjbGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBNeUNsYXNzID0gbmV3IFBoYXNlci5DbGFzcyh7XG4gKiAgICAgIFxuICogICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgdGhpcy5mb28gPSAyLjA7XG4gKiAgICAgICAgICB9LFxuICpcbiAqICAgICAgICAgIGJhcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9vICsgNTtcbiAqICAgICAgICAgIH1cbiAqICAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIENsYXNzIChkZWZpbml0aW9uKVxue1xuICAgIGlmICghZGVmaW5pdGlvbilcbiAgICB7XG4gICAgICAgIGRlZmluaXRpb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyAgVGhlIHZhcmlhYmxlIG5hbWUgaGVyZSBkaWN0YXRlcyB3aGF0IHdlIHNlZSBpbiBDaHJvbWUgZGVidWdnZXJcbiAgICB2YXIgaW5pdGlhbGl6ZTtcbiAgICB2YXIgRXh0ZW5kcztcblxuICAgIGlmIChkZWZpbml0aW9uLmluaXRpYWxpemUpXG4gICAge1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluaXRpb24uaW5pdGlhbGl6ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsaXplIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbGl6ZSA9IGRlZmluaXRpb24uaW5pdGlhbGl6ZTtcblxuICAgICAgICAvLyAgVXN1YWxseSB3ZSBzaG91bGQgYXZvaWQgJ2RlbGV0ZScgaW4gVjggYXQgYWxsIGNvc3RzLlxuICAgICAgICAvLyAgSG93ZXZlciwgaXRzIHVubGlrZWx5IHRvIG1ha2UgYW55IHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcbiAgICAgICAgLy8gIGhlcmUgc2luY2Ugd2Ugb25seSBjYWxsIHRoaXMgb24gY2xhc3MgY3JlYXRpb24gKGkuZS4gbm90IG9iamVjdCBjcmVhdGlvbikuXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLmluaXRpYWxpemU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLkV4dGVuZHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gZGVmaW5pdGlvbi5FeHRlbmRzO1xuXG4gICAgICAgICAgICBpbml0aWFsaXplID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmluaXRpb24uRXh0ZW5kcylcbiAgICB7XG4gICAgICAgIGluaXRpYWxpemUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShkZWZpbml0aW9uLkV4dGVuZHMucHJvdG90eXBlKTtcbiAgICAgICAgaW5pdGlhbGl6ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbml0aWFsaXplO1xuXG4gICAgICAgIC8vICBGb3IgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHRvIHdvcmssIHdlIG5lZWQgdG8gYWN0IGRpcmVjdGx5IG9uIHRoZSBFeHRlbmRzIChvciBNaXhpbilcblxuICAgICAgICBFeHRlbmRzID0gZGVmaW5pdGlvbi5FeHRlbmRzO1xuXG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLkV4dGVuZHM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGluaXRpYWxpemUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaW5pdGlhbGl6ZTtcbiAgICB9XG5cbiAgICAvLyAgR3JhYiB0aGUgbWl4aW5zLCBpZiB0aGV5IGFyZSBzcGVjaWZpZWQuLi5cbiAgICB2YXIgbWl4aW5zID0gbnVsbDtcblxuICAgIGlmIChkZWZpbml0aW9uLk1peGlucylcbiAgICB7XG4gICAgICAgIG1peGlucyA9IGRlZmluaXRpb24uTWl4aW5zO1xuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5NaXhpbnM7XG4gICAgfVxuXG4gICAgLy8gIEZpcnN0LCBtaXhpbiBpZiB3ZSBjYW4uXG4gICAgbWl4aW4oaW5pdGlhbGl6ZSwgbWl4aW5zKTtcblxuICAgIC8vICBOb3cgd2UgZ3JhYiB0aGUgYWN0dWFsIGRlZmluaXRpb24gd2hpY2ggZGVmaW5lcyB0aGUgb3ZlcnJpZGVzLlxuICAgIGV4dGVuZChpbml0aWFsaXplLCBkZWZpbml0aW9uLCB0cnVlLCBFeHRlbmRzKTtcblxuICAgIHJldHVybiBpbml0aWFsaXplO1xufVxuXG5DbGFzcy5leHRlbmQgPSBleHRlbmQ7XG5DbGFzcy5taXhpbiA9IG1peGluO1xuQ2xhc3MuaWdub3JlRmluYWxzID0gZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9DbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgZ2xvYmFsIGxldmVsIGNvbnRhaW5lciBvZiBGYWN0b3J5IGluc3RhbmNlcy5cbiogRmFjdG9yaWVzIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB0aGlzIGNvbnRhaW5lciAod2hlbiByZXF1aXJlZClcbipcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiovXG5cbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIEZhY3RvcnlDb250YWluZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKCdGYWN0b3J5Q29udGFpbmVyIGlzIGFsaXZlJyk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZhY3RvcnkpXG4gICAge1xuICAgICAgICBpZiAoZmFjdG9yaWVzLmhhc093blByb3BlcnR5KGZhY3RvcnkuS0VZKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FscmVhZHkgcmVnaXN0ZXJlZCcsIGZhY3RvcnkuS0VZKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShmYWN0b3J5LktFWSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcnLCBmYWN0b3J5LktFWSk7XG5cbiAgICAgICAgICAgIGZhY3Rvcmllc1tmYWN0b3J5LktFWV0gPSB7XG4gICAgICAgICAgICAgICAgYWRkOiBmYWN0b3J5LmFkZCxcbiAgICAgICAgICAgICAgICBtYWtlOiBmYWN0b3J5Lm1ha2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0VHlwZSA9IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFjdG9yaWVzW2tleV07XG4gICAgfTtcblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uIChkZXN0LCBpc0ZhY3RvcnkpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBmYWN0b3J5IGluIGZhY3RvcmllcylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZhY3Rvcmllcy5oYXNPd25Qcm9wZXJ0eShmYWN0b3J5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9hZGluZycsIGZhY3RvcnkpO1xuXG4gICAgICAgICAgICAgICAgZGVzdFtmYWN0b3J5XSA9IChpc0ZhY3RvcnkpID8gZmFjdG9yaWVzW2ZhY3RvcnldLmFkZCA6IGZhY3Rvcmllc1tmYWN0b3J5XS5tYWtlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQWxwaGE6IHJlcXVpcmUoJy4vQWxwaGEnKSxcbiAgICBCbGVuZE1vZGU6IHJlcXVpcmUoJy4vQmxlbmRNb2RlJyksXG4gICAgQ2hpbGRyZW46IHJlcXVpcmUoJy4vQ2hpbGRyZW4nKSxcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxuICAgIERhdGE6IHJlcXVpcmUoJy4vRGF0YScpLFxuICAgIEZsaXA6IHJlcXVpcmUoJy4vRmxpcCcpLFxuICAgIEdldEJvdW5kczogcmVxdWlyZSgnLi9HZXRCb3VuZHMnKSxcbiAgICBPcmlnaW46IHJlcXVpcmUoJy4vT3JpZ2luJyksXG4gICAgUmVuZGVyUGFzczogcmVxdWlyZSgnLi9SZW5kZXJQYXNzJyksXG4gICAgU2NhbGVNb2RlOiByZXF1aXJlKCcuL1NjYWxlTW9kZScpLFxuICAgIFNpemU6IHJlcXVpcmUoJy4vU2l6ZScpLFxuICAgIFRleHR1cmU6IHJlcXVpcmUoJy4vVGV4dHVyZScpLFxuICAgIFRyYW5zZm9ybTogcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBUcmFuc2Zvcm1NYXRyaXg6IHJlcXVpcmUoJy4vVHJhbnNmb3JtTWF0cml4JyksXG4gICAgVmlzaWJsZTogcmVxdWlyZSgnLi9WaXNpYmxlJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9pbmRleC5qcyIsInZhciBNQVRIX0NPTlNUID0ge1xuXG4gICAgUEkyOiBNYXRoLlBJICogMixcbiAgICBUQVU6IE1hdGguUEkgKiAwLjUsXG4gICAgRVBTSUxPTjogMS4wZS02LFxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1BVEhfQ09OU1Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUaGUgYE1hdHRlci5Cb3VuZHNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyAoQUFCQikuXG4qXG4qIEBjbGFzcyBCb3VuZHNcbiovXG5cbnZhciBCb3VuZHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHM7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgZm9yIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7Ym91bmRzfSBBIG5ldyBib3VuZHMgb2JqZWN0XG4gICAgICovXG4gICAgQm91bmRzLmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB7IFxuICAgICAgICAgICAgbWluOiB7IHg6IDAsIHk6IDAgfSwgXG4gICAgICAgICAgICBtYXg6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZlcnRpY2VzKVxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShib3VuZHMsIHZlcnRpY2VzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYm91bmRzIHVzaW5nIHRoZSBnaXZlbiB2ZXJ0aWNlcyBhbmQgZXh0ZW5kcyB0aGUgYm91bmRzIGdpdmVuIGEgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb3VuZHMudXBkYXRlID0gZnVuY3Rpb24oYm91bmRzLCB2ZXJ0aWNlcywgdmVsb2NpdHkpIHtcbiAgICAgICAgYm91bmRzLm1pbi54ID0gSW5maW5pdHk7XG4gICAgICAgIGJvdW5kcy5tYXgueCA9IC1JbmZpbml0eTtcbiAgICAgICAgYm91bmRzLm1pbi55ID0gSW5maW5pdHk7XG4gICAgICAgIGJvdW5kcy5tYXgueSA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPiBib3VuZHMubWF4LngpIGJvdW5kcy5tYXgueCA9IHZlcnRleC54O1xuICAgICAgICAgICAgaWYgKHZlcnRleC54IDwgYm91bmRzLm1pbi54KSBib3VuZHMubWluLnggPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueSA+IGJvdW5kcy5tYXgueSkgYm91bmRzLm1heC55ID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPCBib3VuZHMubWluLnkpIGJvdW5kcy5taW4ueSA9IHZlcnRleC55O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodmVsb2NpdHkpIHtcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eS54ID4gMCkge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueCArPSB2ZWxvY2l0eS54O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLnggKz0gdmVsb2NpdHkueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLm1heC55ICs9IHZlbG9jaXR5Lnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueSArPSB2ZWxvY2l0eS55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRzIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJvdW5kcyBjb250YWluIHRoZSBwb2ludCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQm91bmRzLmNvbnRhaW5zID0gZnVuY3Rpb24oYm91bmRzLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBib3VuZHMubWluLnggJiYgcG9pbnQueCA8PSBib3VuZHMubWF4LnggXG4gICAgICAgICAgICAgICAmJiBwb2ludC55ID49IGJvdW5kcy5taW4ueSAmJiBwb2ludC55IDw9IGJvdW5kcy5tYXgueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYm91bmRzIGludGVyc2VjdC5cbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc0FcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzQlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJvdW5kcyBvdmVybGFwLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBCb3VuZHMub3ZlcmxhcHMgPSBmdW5jdGlvbihib3VuZHNBLCBib3VuZHNCKSB7XG4gICAgICAgIHJldHVybiAoYm91bmRzQS5taW4ueCA8PSBib3VuZHNCLm1heC54ICYmIGJvdW5kc0EubWF4LnggPj0gYm91bmRzQi5taW4ueFxuICAgICAgICAgICAgICAgICYmIGJvdW5kc0EubWF4LnkgPj0gYm91bmRzQi5taW4ueSAmJiBib3VuZHNBLm1pbi55IDw9IGJvdW5kc0IubWF4LnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBib3VuZHMgYnkgdGhlIGdpdmVuIHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICovXG4gICAgQm91bmRzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGJvdW5kcywgdmVjdG9yKSB7XG4gICAgICAgIGJvdW5kcy5taW4ueCArPSB2ZWN0b3IueDtcbiAgICAgICAgYm91bmRzLm1heC54ICs9IHZlY3Rvci54O1xuICAgICAgICBib3VuZHMubWluLnkgKz0gdmVjdG9yLnk7XG4gICAgICAgIGJvdW5kcy5tYXgueSArPSB2ZWN0b3IueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoZSBib3VuZHMgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2Qgc2hpZnRcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQm91bmRzLnNoaWZ0ID0gZnVuY3Rpb24oYm91bmRzLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZGVsdGFYID0gYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgZGVsdGFZID0gYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55O1xuICAgICAgICAgICAgXG4gICAgICAgIGJvdW5kcy5taW4ueCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGJvdW5kcy5tYXgueCA9IHBvc2l0aW9uLnggKyBkZWx0YVg7XG4gICAgICAgIGJvdW5kcy5taW4ueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGJvdW5kcy5tYXgueSA9IHBvc2l0aW9uLnkgKyBkZWx0YVk7XG4gICAgfTtcbiAgICBcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9Cb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBgTWF0dGVyLlZlY3RvcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgdmVjdG9ycy5cbiogVmVjdG9ycyBhcmUgdGhlIGJhc2lzIG9mIGFsbCB0aGUgZ2VvbWV0cnkgcmVsYXRlZCBvcGVyYXRpb25zIGluIHRoZSBlbmdpbmUuXG4qIEEgYE1hdHRlci5WZWN0b3JgIG9iamVjdCBpcyBvZiB0aGUgZm9ybSBgeyB4OiAwLCB5OiAwIH1gLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgVmVjdG9yXG4qL1xuXG4vLyBUT0RPOiBjb25zaWRlciBwYXJhbXMgZm9yIHJldXNpbmcgdmVjdG9yIG9iamVjdHNcblxudmFyIFZlY3RvciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4geyB4OiB4IHx8IDAsIHk6IHkgfHwgMCB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIGB4YCBhbmQgYHlgIGNvcGllZCBmcm9tIHRoZSBnaXZlbiBgdmVjdG9yYC5cbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgY2xvbmVkIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5jbG9uZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCwgeTogdmVjdG9yLnkgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIGEgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgbWFnbml0dWRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXG4gICAgICovXG4gICAgVmVjdG9yLm1hZ25pdHVkZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh2ZWN0b3IueCAqIHZlY3Rvci54KSArICh2ZWN0b3IueSAqIHZlY3Rvci55KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hZ25pdHVkZSAobGVuZ3RoKSBvZiBhIHZlY3RvciAodGhlcmVmb3JlIHNhdmluZyBhIGBzcXJ0YCBvcGVyYXRpb24pLlxuICAgICAqIEBtZXRob2QgbWFnbml0dWRlU3F1YXJlZFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXG4gICAgICovXG4gICAgVmVjdG9yLm1hZ25pdHVkZVNxdWFyZWQgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuICh2ZWN0b3IueCAqIHZlY3Rvci54KSArICh2ZWN0b3IueSAqIHZlY3Rvci55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgdmVjdG9yIGFib3V0ICgwLCAwKSBieSBzcGVjaWZpZWQgYW5nbGUuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCAoMCwgMClcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlID0gZnVuY3Rpb24odmVjdG9yLCBhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxuICAgICAgICAgICAgeTogdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvc1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgYSBzcGVjaWZpZWQgcG9pbnQgYnkgc3BlY2lmaWVkIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlQWJvdXRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlQWJvdXQgPSBmdW5jdGlvbih2ZWN0b3IsIGFuZ2xlLCBwb2ludCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICB2YXIgeCA9IHBvaW50LnggKyAoKHZlY3Rvci54IC0gcG9pbnQueCkgKiBjb3MgLSAodmVjdG9yLnkgLSBwb2ludC55KSAqIHNpbik7XG4gICAgICAgIG91dHB1dC55ID0gcG9pbnQueSArICgodmVjdG9yLnggLSBwb2ludC54KSAqIHNpbiArICh2ZWN0b3IueSAtIHBvaW50LnkpICogY29zKTtcbiAgICAgICAgb3V0cHV0LnggPSB4O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpc2VzIGEgdmVjdG9yIChzdWNoIHRoYXQgaXRzIG1hZ25pdHVkZSBpcyBgMWApLlxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIG5vcm1hbGlzZWRcbiAgICAgKi9cbiAgICBWZWN0b3Iubm9ybWFsaXNlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBWZWN0b3IubWFnbml0dWRlKHZlY3Rvcik7XG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gbWFnbml0dWRlLCB5OiB2ZWN0b3IueSAvIG1hZ25pdHVkZSB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIHZlY3RvcnNcbiAgICAgKi9cbiAgICBWZWN0b3IuZG90ID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueCkgKyAodmVjdG9yQS55ICogdmVjdG9yQi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGNyb3NzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzXG4gICAgICovXG4gICAgVmVjdG9yLmNyb3NzID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueSkgLSAodmVjdG9yQS55ICogdmVjdG9yQi54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JDXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdGhyZWUgdmVjdG9yc1xuICAgICAqL1xuICAgIFZlY3Rvci5jcm9zczMgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCB2ZWN0b3JDKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yQi54IC0gdmVjdG9yQS54KSAqICh2ZWN0b3JDLnkgLSB2ZWN0b3JBLnkpIC0gKHZlY3RvckIueSAtIHZlY3RvckEueSkgKiAodmVjdG9yQy54IC0gdmVjdG9yQS54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBhZGRlZFxuICAgICAqL1xuICAgIFZlY3Rvci5hZGQgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICBvdXRwdXQueCA9IHZlY3RvckEueCArIHZlY3RvckIueDtcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3JBLnkgKyB2ZWN0b3JCLnk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBzdWJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBzdWJ0cmFjdGVkXG4gICAgICovXG4gICAgVmVjdG9yLnN1YiA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIG91dHB1dCkge1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIG91dHB1dC54ID0gdmVjdG9yQS54IC0gdmVjdG9yQi54O1xuICAgICAgICBvdXRwdXQueSA9IHZlY3RvckEueSAtIHZlY3RvckIueTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBhbmQgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWx0XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBtdWx0aXBsaWVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5tdWx0ID0gZnVuY3Rpb24odmVjdG9yLCBzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggKiBzY2FsYXIsIHk6IHZlY3Rvci55ICogc2NhbGFyIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBkaXZpZGVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5kaXYgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCAvIHNjYWxhciwgeTogdmVjdG9yLnkgLyBzY2FsYXIgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IuIFNldCBgbmVnYXRlYCB0byB0cnVlIGZvciB0aGUgcGVycGVuZGljdWxhciBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICAgICAqIEBtZXRob2QgcGVycFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtuZWdhdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgcGVycGVuZGljdWxhciB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IucGVycCA9IGZ1bmN0aW9uKHZlY3RvciwgbmVnYXRlKSB7XG4gICAgICAgIG5lZ2F0ZSA9IG5lZ2F0ZSA9PT0gdHJ1ZSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHsgeDogbmVnYXRlICogLXZlY3Rvci55LCB5OiBuZWdhdGUgKiB2ZWN0b3IueCB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGJvdGggY29tcG9uZW50cyBvZiBhIHZlY3RvciBzdWNoIHRoYXQgaXQgcG9pbnRzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogQG1ldGhvZCBuZWdcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgbmVnYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubmVnID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB7IHg6IC12ZWN0b3IueCwgeTogLXZlY3Rvci55IH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0aGUgdHdvIHZlY3RvcnMgcmVsYXRpdmUgdG8gdGhlIHgtYXhpcy5cbiAgICAgKiBAbWV0aG9kIGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBWZWN0b3IuYW5nbGUgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHZlY3RvckIueSAtIHZlY3RvckEueSwgdmVjdG9yQi54IC0gdmVjdG9yQS54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHZlY3RvciBwb29sIChub3QgdGhyZWFkLXNhZmUpLlxuICAgICAqIEBwcm9wZXJ0eSBfdGVtcFxuICAgICAqIEB0eXBlIHt2ZWN0b3JbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZlY3Rvci5fdGVtcCA9IFtcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKCksIFxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKSwgXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpXG4gICAgXTtcblxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9WZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFNvdXJjZSBvYmplY3Rcbi8vICBUaGUga2V5IGFzIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBrZXlzLCBpLmUuICdiYW5uZXInLCBvciAnYmFubmVyLmhpZGVCYW5uZXInXG4vLyAgVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBrZXkgZG9lc24ndCBleGlzdFxuXG52YXIgR2V0T2JqZWN0VmFsdWUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSlcbntcbiAgICBpZiAoIXNvdXJjZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleS5pbmRleE9mKCcuJykpXG4gICAge1xuICAgICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgcGFyZW50ID0gc291cmNlO1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgLy8gIFVzZSBmb3IgbG9vcCBoZXJlIHNvIHdlIGNhbiBicmVhayBlYXJseVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gIFllcyBpdCBoYXMgYSBrZXkgcHJvcGVydHksIGxldCdzIGNhcnJ5IG9uIGRvd25cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmVudFtrZXlzW2ldXTtcblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgQ2FuJ3QgZ28gYW55IGZ1cnRoZXIsIHNvIHJlc2V0IHRvIGRlZmF1bHRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkgPyBzb3VyY2Vba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9iamVjdFZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudCA9IGZ1bmN0aW9uICh0eXBlKVxue1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvLyAgVGhlIGVsZW1lbnQgdGhhdCBpbml0aWF0ZWQgdGhlIGV2ZW50LlxuICAgIHRoaXMudGFyZ2V0O1xuXG4gICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50O1xuXG5FdmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICByZXNldDogZnVuY3Rpb24gKHRhcmdldClcbiAgICB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IHRydWU7XG4gICAgfSxcblxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IGZhbHNlO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2V2ZW50cy9FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZJTEVfQ09OU1QgPSB7XG5cbiAgICBMT0FERVJfSURMRTogMCxcbiAgICBMT0FERVJfTE9BRElORzogMSxcbiAgICBMT0FERVJfUFJPQ0VTU0lORzogMixcbiAgICBMT0FERVJfQ09NUExFVEU6IDMsXG4gICAgTE9BREVSX0RFU1RST1lFRDogNCxcblxuICAgIEZJTEVfUEVORElORzogNSwgICAgICAvLyBmaWxlIGlzIGluIHRoZSBsb2FkIHF1ZXVlIGJ1dCBub3QgeWV0IHN0YXJ0ZWRcbiAgICBGSUxFX0xPQURJTkc6IDYsICAgICAgLy8gZmlsZSBoYXMgYmVlbiBzdGFydGVkIHRvIGxvYWQgYnkgdGhlIGxvYWRlciAob25Mb2FkIGNhbGxlZClcbiAgICBGSUxFX0xPQURFRDogNywgICAgICAgLy8gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgYXdhaXRpbmcgcHJvY2Vzc2luZ1xuICAgIEZJTEVfRkFJTEVEOiA4LCAgICAgICAvLyBmaWxlIGZhaWxlZCB0byBsb2FkXG4gICAgRklMRV9QUk9DRVNTSU5HOiA5LCAgIC8vIGZpbGUgaXMgYmVpbmcgcHJvY2Vzc2VkIChvblByb2Nlc3MgY2FsbGJhY2spXG4gICAgRklMRV9XQUlUSU5HX0xJTktGSUxFOiAxMCwgICAvLyBmaWxlIGlzIGJlaW5nIHByb2Nlc3NlZCAob25Qcm9jZXNzIGNhbGxiYWNrKVxuICAgIEZJTEVfRVJST1JFRDogMTEsICAgLy8gZmlsZSBpcyBiZWluZyBwcm9jZXNzZWQgKG9uUHJvY2VzcyBjYWxsYmFjaylcbiAgICBGSUxFX0NPTVBMRVRFOiAxMiwgICAgIC8vIGZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcbiAgICBGSUxFX0RFU1RST1lFRDogMTMsICAgICAvLyBmaWxlIGhhcyBiZWVuIGRlc3Ryb3llZFxuXG4gICAgVEVYVFVSRV9BVExBU19KU09OX0FSUkFZOiAyMCxcbiAgICBURVhUVVJFX0FUTEFTX0pTT05fSEFTSDogMjFcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGSUxFX0NPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi91dGlscy9DbGFzcycpO1xuXG4vKipcbiogVGhpcyBpcyB0aGUgYmFzZSBHYW1lIE9iamVjdCBjbGFzcyB0aGF0IHlvdSBjYW4gdXNlIHdoZW4gY3JlYXRpbmcgeW91ciBvd24gZXh0ZW5kZWQgR2FtZSBPYmplY3RzLlxuKlxuKiBAY2xhc3NcbiovXG5cbnZhciBHYW1lT2JqZWN0ID0gbmV3IENsYXNzKHtcblxuICAgIGluaXRpYWxpemU6XG5cbiAgICBmdW5jdGlvbiBHYW1lT2JqZWN0IChzdGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICB0aGlzLmlkID0gMDtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgLy8gIDAwMDEgfCAwMDEwIHwgMDEwMCB8IDEwMDBcbiAgICAgICAgLy8gIFdpbGwgUmVuZGVyIGJpdG1hc2sgZmxhZ3MgZm9yIHRoZSBjb21wb25lbnRzIFZpc2libGUsIEFscGhhLCBUcmFuc2Zvcm0gYW5kIFRleHR1cmUgcmVzcGVjdGl2ZWx5XG4gICAgICAgIHRoaXMucmVuZGVyTWFzayA9IDE1O1xuICAgICAgICB0aGlzLnJlbmRlckZsYWdzID0gMTU7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9HYW1lT2JqZWN0LmpzIiwiLyoqXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXG4qXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4qL1xuXG52YXIgR2V0Qm90dG9tID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXG57XG4gICAgcmV0dXJuIChnYW1lT2JqZWN0LnkgKyBnYW1lT2JqZWN0LmhlaWdodCkgLSAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRCb3R0b207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0Qm90dG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiovXG5cbnZhciBHZXRMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXG57XG4gICAgcmV0dXJuIGdhbWVPYmplY3QueCAtIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0TGVmdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9HZXRMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiovXG5cbnZhciBHZXRSaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxue1xuICAgIHJldHVybiAoZ2FtZU9iamVjdC54ICsgZ2FtZU9iamVjdC53aWR0aCkgLSAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFJpZ2h0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYm91bmRzL0dldFJpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHkgLSBvZmZzZXRZYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxuKi9cblxudmFyIEdldFRvcCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxue1xuICAgIHJldHVybiBnYW1lT2JqZWN0LnkgLSAoZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRUb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiovXG5cbnZhciBTZXRCb3R0b20gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgdmFsdWUpXG57XG4gICAgZ2FtZU9iamVjdC55ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC5oZWlnaHQpICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRCb3R0b207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0Qm90dG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZSBPYmplY3QuXG4qIFRoaXMgaXMgdGhlIHNhbWUgYXMgYHggLSBvZmZzZXRYYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiovXG5cbnZhciBTZXRMZWZ0ID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxue1xuICAgIGdhbWVPYmplY3QueCA9IHZhbHVlICsgKGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblgpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldExlZnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0TGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB4IC0gb2Zmc2V0WGAuXG4qXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4qL1xuXG52YXIgU2V0UmlnaHQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgdmFsdWUpXG57XG4gICAgZ2FtZU9iamVjdC54ID0gKHZhbHVlIC0gZ2FtZU9iamVjdC53aWR0aCkgKyAoZ2FtZU9iamVjdC53aWR0aCAqIGdhbWVPYmplY3Qub3JpZ2luWCk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0UmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0UmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgeSAtIG9mZnNldFlgLlxuKlxuKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4qL1xuXG52YXIgU2V0VG9wID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHZhbHVlKVxue1xuICAgIGdhbWVPYmplY3QueSA9IHZhbHVlICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRUb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvT1MuanMiLCJ2YXIgT1MgPSB7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGVza3RvcCAtIElzIHJ1bm5pbmcgb24gYSBkZXNrdG9wP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGRlc2t0b3A6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYkFwcCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYXMgYSBXZWJBcHAsIGkuZS4gd2l0aGluIGEgV2ViVmlld1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdlYkFwcDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaU9TIC0gSXMgcnVubmluZyBvbiBpT1M/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgaU9TOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlPU1ZlcnNpb24gLSBJZiBydW5uaW5nIGluIGlPUyB0aGlzIHdpbGwgY29udGFpbiB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgaU9TVmVyc2lvbjogMCxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpUGhvbmUgLSBJcyBydW5uaW5nIG9uIGlQaG9uZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpUGhvbmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlQYWQgLSBJcyBydW5uaW5nIG9uIGlQYWQ/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgaVBhZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29jb29uSlMgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIENvY29vbkpTP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNvY29vbkpTOiBmYWxzZSxcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29jb29uSlNBcHAgLSBJcyB0aGlzIGdhbWUgcnVubmluZyB3aXRoIENvY29vbkpTLkFwcD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjb2Nvb25KU0FwcDogZmFsc2UsXG4gICAgXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvcmRvdmEgLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEFwYWNoZSBDb3Jkb3ZhP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNvcmRvdmE6IGZhbHNlLFxuICAgIFxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBub2RlIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBOb2RlLmpzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG5vZGU6IGZhbHNlLFxuICAgIFxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBub2RlV2Via2l0IC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciBOb2RlLVdlYmtpdD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBub2RlV2Via2l0OiBmYWxzZSxcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWxlY3Ryb24gLSBJcyB0aGUgZ2FtZSBydW5uaW5nIHVuZGVyIEdpdEh1YiBFbGVjdHJvbj9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBlbGVjdHJvbjogZmFsc2UsXG4gICAgXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVqZWN0YSAtIElzIHRoZSBnYW1lIHJ1bm5pbmcgdW5kZXIgRWplY3RhP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVqZWN0YTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3Jvc3N3YWxrIC0gSXMgdGhlIGdhbWUgcnVubmluZyB1bmRlciB0aGUgSW50ZWwgQ3Jvc3N3YWxrIFhESz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjcm9zc3dhbGs6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuZHJvaWQgLSBJcyBydW5uaW5nIG9uIGFuZHJvaWQ/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgYW5kcm9pZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2hyb21lT1MgLSBJcyBydW5uaW5nIG9uIGNocm9tZU9TP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNocm9tZU9TOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBsaW51eCAtIElzIHJ1bm5pbmcgb24gbGludXg/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbGludXg6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hY09TIC0gSXMgcnVubmluZyBvbiBtYWNPUz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBtYWNPUzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2luZG93cyAtIElzIHJ1bm5pbmcgb24gd2luZG93cz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3aW5kb3dzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3aW5kb3dzUGhvbmUgLSBJcyBydW5uaW5nIG9uIGEgV2luZG93cyBQaG9uZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB3aW5kb3dzUGhvbmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpdGEgLSBJcyBydW5uaW5nIG9uIGEgUGxheVN0YXRpb24gVml0YT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB2aXRhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBraW5kbGUgLSBJcyBydW5uaW5nIG9uIGFuIEFtYXpvbiBLaW5kbGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAga2luZGxlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gLSBQaXhlbFJhdGlvIG9mIHRoZSBob3N0IGRldmljZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBwaXhlbFJhdGlvOiAxXG5cbn07XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgaWYgKC9XaW5kb3dzLy50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLndpbmRvd3MgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgvTWFjIE9TLy50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLm1hY09TID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLmxpbnV4ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MuYW5kcm9pZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9pUFthb11kfGlQaG9uZS9pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MuaU9TID0gdHJ1ZTtcbiAgICAgICAgKG5hdmlnYXRvci5hcHBWZXJzaW9uKS5tYXRjaCgvT1MgKFxcZCspLyk7XG4gICAgICAgIE9TLmlPU1ZlcnNpb24gPSBwYXJzZUludChSZWdFeHAuJDEsIDEwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL0tpbmRsZS8udGVzdCh1YSkgfHwgKC9cXGJLRltBLVpdW0EtWl0rLykudGVzdCh1YSkgfHwgKC9TaWxrLipNb2JpbGUgU2FmYXJpLykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy5raW5kbGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBOT1QgZGV0ZWN0IGVhcmx5IGdlbmVyYXRpb25zIG9mIEtpbmRsZSBGaXJlLCBJIHRoaW5rIHRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheS4uLlxuICAgICAgICAvLyBFLmcuIFwiTW96aWxsYS81LjAgKE1hY2ludG9zaDsgVTsgSW50ZWwgTWFjIE9TIFggMTBfNl8zOyBlbi11czsgU2lsay8xLjEuMC04MCkgQXBwbGVXZWJLaXQvNTMzLjE2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi81LjAgU2FmYXJpLzUzMy4xNiBTaWxrLUFjY2VsZXJhdGVkPXRydWVcIlxuICAgIH1cbiAgICBlbHNlIGlmICgvQ3JPUy8udGVzdCh1YSkpXG4gICAge1xuICAgICAgICBPUy5jaHJvbWVPUyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgvUGxheXN0YXRpb24gVml0YS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1Mudml0YSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1YSkgfHwgKC9JRU1vYmlsZS9pKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIE9TLmFuZHJvaWQgPSBmYWxzZTtcbiAgICAgICAgT1MuaU9TID0gZmFsc2U7XG4gICAgICAgIE9TLm1hY09TID0gZmFsc2U7XG4gICAgICAgIE9TLndpbmRvd3MgPSB0cnVlO1xuICAgICAgICBPUy53aW5kb3dzUGhvbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzaWxrID0gKC9TaWxrLykudGVzdCh1YSk7XG5cbiAgICBpZiAoT1Mud2luZG93cyB8fCBPUy5tYWNPUyB8fCAoT1MubGludXggJiYgIXNpbGspIHx8IE9TLmNocm9tZU9TKVxuICAgIHtcbiAgICAgICAgT1MuZGVza3RvcCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gIFdpbmRvd3MgUGhvbmUgLyBUYWJsZSByZXNldFxuICAgIGlmIChPUy53aW5kb3dzUGhvbmUgfHwgKCgvV2luZG93cyBOVC9pLnRlc3QodWEpKSAmJiAoL1RvdWNoL2kudGVzdCh1YSkpKSlcbiAgICB7XG4gICAgICAgIE9TLmRlc2t0b3AgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAgV2ViQXBwIG1vZGUgaW4gaU9TXG4gICAgaWYgKG5hdmlnYXRvci5zdGFuZGFsb25lKVxuICAgIHtcbiAgICAgICAgT1Mud2ViQXBwID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICE9PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBPUy5jb3Jkb3ZhID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJykpXG4gICAge1xuICAgICAgICBPUy5ub2RlID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKE9TLm5vZGUgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT09ICdvYmplY3QnKVxuICAgIHtcbiAgICAgICAgT1Mubm9kZVdlYmtpdCA9ICEhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXTtcbiAgICAgICAgXG4gICAgICAgIE9TLmVsZWN0cm9uID0gISFwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uO1xuICAgIH1cbiAgICBcbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXG4gICAge1xuICAgICAgICBPUy5jb2Nvb25KUyA9IHRydWU7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIE9TLmNvY29vbkpTQXBwID0gKHR5cGVvZiBDb2Nvb25KUyAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcilcbiAgICAgICAge1xuICAgICAgICAgICAgT1MuY29jb29uSlNBcHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cuZWplY3RhICE9PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBPUy5lamVjdGEgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICgoL0Nyb3Nzd2Fsay8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgT1MuY3Jvc3N3YWxrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBPUy5pUGhvbmUgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2lwaG9uZScpICE9PSAtMTtcbiAgICBPUy5pUGFkID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpcGFkJykgIT09IC0xO1xuXG4gICAgT1MucGl4ZWxSYXRpbyA9IHdpbmRvd1snZGV2aWNlUGl4ZWxSYXRpbyddIHx8IDE7XG5cbiAgICByZXR1cm4gT1M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL09TLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIFRoZSBwb29sIGludG8gd2hpY2ggdGhlIGNhbnZhcyBlbGVtZW50cyBhcmUgcGxhY2VkLlxuICpcbiAqIEBwcm9wZXJ0eSBwb29sXG4gKiBAdHlwZSBBcnJheVxuICovXG52YXIgcG9vbCA9IFtdO1xuXG4vLyAgVGhpcyBzaW5nbGV0b24gaXMgaW5zdGFudGlhdGVkIGFzIHNvb24gYXMgUGhhc2VyIGxvYWRzLFxuLy8gIGJlZm9yZSBhIFBoYXNlci5HYW1lIGluc3RhbmNlIGhhcyBldmVuIGJlZW4gY3JlYXRlZC5cbi8vICBXaGljaCBtZWFucyBhbGwgaW5zdGFuY2VzIG9mIFBoYXNlciBHYW1lcyBvbiB0aGUgc2FtZSBwYWdlXG4vLyAgY2FuIHNoYXJlIHRoZSBvbmUgc2luZ2xlIHBvb2xcblxuLyoqXG4qIFRoZSBDYW52YXNQb29sIGlzIGEgZ2xvYmFsIHN0YXRpYyBvYmplY3QsIHRoYXQgYWxsb3dzIFBoYXNlciB0byByZWN5Y2xlIGFuZCBwb29sIENhbnZhcyBET00gZWxlbWVudHMuXG4qXG4qIEBjbGFzcyBQaGFzZXIuQ2FudmFzUG9vbFxuKiBAc3RhdGljXG4qL1xudmFyIENhbnZhc1Bvb2wgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIG5ldyBDYW52YXMgRE9NIGVsZW1lbnQsIG9yIHB1bGxzIG9uZSBmcm9tIHRoZSBwb29sIGlmIGZyZWUuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5jcmVhdGVcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBwYXJhbSB7YW55fSBwYXJlbnQgLSBUaGUgcGFyZW50IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIGNhbnZhcyBlbGVtZW50LlxuICAgICovXG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIHR5cGUpXG4gICAge1xuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDE7IH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7IGhlaWdodCA9IDE7IH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XG5cbiAgICAgICAgdmFyIGNhbnZhcztcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZpcnN0KHR5cGUpO1xuXG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXNQb29sLmNyZWF0ZSBuZXcnKTtcblxuICAgICAgICAgICAgY29udGFpbmVyID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgIGNhbnZhczogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcG9vbC5wdXNoKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGNhbnZhcyA9IGNvbnRhaW5lci5jYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5jcmVhdGUgZXhpc3RpbmcnKTtcblxuICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZTJEID0gZnVuY3Rpb24gKHBhcmVudCwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybiBjcmVhdGUocGFyZW50LCB3aWR0aCwgaGVpZ2h0LCBDT05TVC5DQU5WQVMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV2ViR0wgPSBmdW5jdGlvbiAocGFyZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZShwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIENPTlNULldFQkdMKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBmcmVlIGNhbnZhcyBpbmRleCBmcm9tIHRoZSBwb29sLlxuICAgICpcbiAgICAqIEBzdGF0aWNcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhc1Bvb2wuZ2V0Rmlyc3RcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHZhciBmaXJzdCA9IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gQ09OU1QuQ0FOVkFTOyB9XG5cbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudCAmJiBjb250YWluZXIudHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBMb29rcyB1cCBhIGNhbnZhcyBiYXNlZCBvbiBpdHMgcGFyZW50LCBhbmQgaWYgZm91bmQgcHV0cyBpdCBiYWNrIGluIHRoZSBwb29sLCBmcmVlaW5nIGl0IHVwIGZvciByZS11c2UuXG4gICAgKiBUaGUgY2FudmFzIGhhcyBpdHMgd2lkdGggYW5kIGhlaWdodCBzZXQgdG8gMSwgYW5kIGl0cyBwYXJlbnQgYXR0cmlidXRlIG51bGxlZC5cbiAgICAqIFxuICAgICogQHN0YXRpY1xuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVcbiAgICAqIEBwYXJhbSB7YW55fEhUTUxDYW52YXNFbGVtZW50fSBwYXJlbnQgLSBUaGUgcGFyZW50IG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAqL1xuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50KVxuICAgIHtcbiAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgcGFyZW50IGlzIGEgY2FudmFzIG9iamVjdFxuICAgICAgICB2YXIgaXNDYW52YXMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcblxuICAgICAgICBwb29sLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKChpc0NhbnZhcyAmJiBjb250YWluZXIuY2FudmFzID09PSBwYXJlbnQpIHx8ICghaXNDYW52YXMgJiYgY29udGFpbmVyLnBhcmVudCA9PT0gcGFyZW50KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzUG9vbC5yZW1vdmUgZm91bmQgYW5kIHJlbW92ZWQnKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiB1c2VkIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cbiAgICAqIFxuICAgICogQHN0YXRpY1xuICAgICogQG1ldGhvZCBQaGFzZXIuQ2FudmFzUG9vbC5nZXRUb3RhbFxuICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGluLXVzZSAocGFyZW50ZWQpIGNhbnZhcyBlbGVtZW50cyBpbiB0aGUgcG9vbC5cbiAgICAqL1xuICAgIHZhciB0b3RhbCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgYyA9IDA7XG5cbiAgICAgICAgcG9vbC5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIucGFyZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIGZyZWUgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxuICAgICogXG4gICAgKiBAc3RhdGljXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXNQb29sLmdldEZyZWVcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmcmVlICh1bi1wYXJlbnRlZCkgY2FudmFzIGVsZW1lbnRzIGluIHRoZSBwb29sLlxuICAgICovXG4gICAgdmFyIGZyZWUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHBvb2wubGVuZ3RoIC0gdG90YWwoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICAgIGNyZWF0ZTJEOiBjcmVhdGUyRCxcbiAgICAgICAgY3JlYXRlV2ViR0w6IGNyZWF0ZVdlYkdMLFxuICAgICAgICBmaXJzdDogZmlyc3QsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICB0b3RhbDogdG90YWwsXG4gICAgICAgIGZyZWU6IGZyZWUsXG4gICAgICAgIHBvb2w6IHBvb2xcbiAgICB9O1xufTtcblxuLy8gIElmIHdlIGV4cG9ydCB0aGUgY2FsbGVkIGZ1bmN0aW9uIGhlcmUsIGl0J2xsIG9ubHkgYmUgaW52b2tlZCBvbmNlIChub3QgZXZlcnkgdGltZSBpdCdzIHJlcXVpcmVkKS5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzUG9vbCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL0NhbnZhc1Bvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvbS9DYW52YXNQb29sLmpzIiwiLyoqXG4qIFRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29tcG9zaXRlIGJvZGllcy5cbiogQSBjb21wb3NpdGUgYm9keSBpcyBhIGNvbGxlY3Rpb24gb2YgYE1hdHRlci5Cb2R5YCwgYE1hdHRlci5Db25zdHJhaW50YCBhbmQgb3RoZXIgYE1hdHRlci5Db21wb3NpdGVgLCB0aGVyZWZvcmUgY29tcG9zaXRlcyBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUuXG4qIEl0IGlzIGltcG9ydGFudCB0byB1c2UgdGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB0byBtb2RpZnkgY29tcG9zaXRlcywgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoZWlyIHByb3BlcnRpZXMuXG4qIE5vdGUgdGhhdCB0aGUgYE1hdHRlci5Xb3JsZGAgb2JqZWN0IGlzIGFsc28gYSB0eXBlIG9mIGBNYXR0ZXIuQ29tcG9zaXRlYCBhbmQgYXMgc3VjaCBhbGwgY29tcG9zaXRlIG1ldGhvZHMgaGVyZSBjYW4gYWxzbyBvcGVyYXRlIG9uIGEgYE1hdHRlci5Xb3JsZGAuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb21wb3NpdGVcbiovXG5cbnZhciBDb21wb3NpdGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGU7XG5cbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4vQm9keScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvc2l0ZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJpdGVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICBpZDogQ29tbW9uLm5leHRJZCgpLFxuICAgICAgICAgICAgdHlwZTogJ2NvbXBvc2l0ZScsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBpc01vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGJvZGllczogW10sIFxuICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLCBcbiAgICAgICAgICAgIGNvbXBvc2l0ZXM6IFtdLFxuICAgICAgICAgICAgbGFiZWw6ICdDb21wb3NpdGUnLFxuICAgICAgICAgICAgcGx1Z2luOiB7fVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcG9zaXRlJ3MgYGlzTW9kaWZpZWRgIGZsYWcuIFxuICAgICAqIElmIGB1cGRhdGVQYXJlbnRzYCBpcyB0cnVlLCBhbGwgcGFyZW50cyB3aWxsIGJlIHNldCAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIElmIGB1cGRhdGVDaGlsZHJlbmAgaXMgdHJ1ZSwgYWxsIGNoaWxkcmVuIHdpbGwgYmUgc2V0IChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogQG1ldGhvZCBzZXRNb2RpZmllZFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVQYXJlbnRzPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZUNoaWxkcmVuPWZhbHNlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgY29tcG9zaXRlLmlzTW9kaWZpZWQgPSBpc01vZGlmaWVkO1xuXG4gICAgICAgIGlmICh1cGRhdGVQYXJlbnRzICYmIGNvbXBvc2l0ZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUucGFyZW50LCBpc01vZGlmaWVkLCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbXBvc2l0ZSA9IGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldO1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjaGlsZENvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgYWRkIGZ1bmN0aW9uLiBBZGRzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlQWRkYCBhbmQgYGFmdGVyQWRkYCBldmVudHMgb24gdGhlIGBjb21wb3NpdGVgLlxuICAgICAqIEBtZXRob2QgYWRkXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGQgPSBmdW5jdGlvbihjb21wb3NpdGUsIG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLmNvbmNhdChvYmplY3QpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGNvbXBvc2l0ZSwgJ2JlZm9yZUFkZCcsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTtcblxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFkZGluZyBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChvYmoucGFyZW50ICE9PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ0NvbXBvc2l0ZS5hZGQ6IHNraXBwZWQgYWRkaW5nIGEgY29tcG91bmQgYm9keSBwYXJ0ICh5b3UgbXVzdCBhZGQgaXRzIHBhcmVudCBpbnN0ZWFkKScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUoY29tcG9zaXRlLCBvYmopO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2VDb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iai5jb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYWZ0ZXJBZGQnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgcmVtb3ZlIGZ1bmN0aW9uLiBSZW1vdmVzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVJlbW92ZWAgYW5kIGBhZnRlclJlbW92ZWAgZXZlbnRzIG9uIHRoZSBgY29tcG9zaXRlYC5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0LCBkZWVwKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gW10uY29uY2F0KG9iamVjdCk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlUmVtb3ZlJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGUsIG9iaiwgZGVlcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZUNvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlclJlbW92ZScsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXBvc2l0ZSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBvYmplY3RzIGZyb20gY29tcG9zaXRlQiBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCKSB7XG4gICAgICAgIGNvbXBvc2l0ZUEuY29tcG9zaXRlcy5wdXNoKGNvbXBvc2l0ZUIpO1xuICAgICAgICBjb21wb3NpdGVCLnBhcmVudCA9IGNvbXBvc2l0ZUE7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGVBLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCLCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZUEuY29tcG9zaXRlcywgY29tcG9zaXRlQik7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGVBdChjb21wb3NpdGVBLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlQSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlQS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlKGNvbXBvc2l0ZUEuY29tcG9zaXRlc1tpXSwgY29tcG9zaXRlQiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlQTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbXBvc2l0ZSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbXBvc2l0ZUF0XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGVBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbXBvc2l0ZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYm9keSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRCb2R5XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBib2R5IGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZEJvZHkgPSBmdW5jdGlvbihjb21wb3NpdGUsIGJvZHkpIHtcbiAgICAgICAgY29tcG9zaXRlLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBib2R5IGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBib2R5IHJlbW92ZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgYm9keSwgZGVlcCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBDb21tb24uaW5kZXhPZihjb21wb3NpdGUuYm9kaWVzLCBib2R5KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQm9keShjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwgYm9keSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlBdFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUJvZHlBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmJvZGllcy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb25zdHJhaW50IHRvIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgY29uc3RyYWludCkge1xuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29uc3RyYWludCBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQsIGRlZXApIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnRBdChjb21wb3NpdGUsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludChjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwgY29uc3RyYWludCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRBdFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29uc3RyYWludCByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnRBdCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgYm9kaWVzLCBjb25zdHJhaW50cyBhbmQgY29tcG9zaXRlcyBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogT3B0aW9uYWxseSBjbGVhcmluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdGF0aWNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5jbGVhciA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwga2VlcFN0YXRpYywgZGVlcCkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmNsZWFyKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBrZWVwU3RhdGljLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGtlZXBTdGF0aWMpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMgPSBjb21wb3NpdGUuYm9kaWVzLmZpbHRlcihmdW5jdGlvbihib2R5KSB7IHJldHVybiBib2R5LmlzU3RhdGljOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5jb25zdHJhaW50cy5sZW5ndGggPSAwO1xuICAgICAgICBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUsIGluY2x1ZGluZyBhbGwgYm9kaWVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxCb2RpZXNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBBbGwgdGhlIGJvZGllc1xuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hbGxCb2RpZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuYm9kaWVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYm9kaWVzID0gYm9kaWVzLmNvbmNhdChDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldKSk7XG5cbiAgICAgICAgcmV0dXJuIGJvZGllcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY29uc3RyYWludHMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb25zdHJhaW50cyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgYWxsQ29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29uc3RyYWludFtdfSBBbGwgdGhlIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29uc3RyYWludHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcblxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNvbXBvc2l0ZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb21wb3NpdGVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxDb21wb3NpdGVzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZVtdfSBBbGwgdGhlIGNvbXBvc2l0ZXNcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xuICAgICAgICB2YXIgY29tcG9zaXRlcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29tcG9zaXRlcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbXBvc2l0ZXMgPSBjb21wb3NpdGVzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgY29tcG9zaXRlIHJlY3Vyc2l2ZWx5IGZvciBhbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHR5cGUgYW5kIGlkIHN1cHBsaWVkLCBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHJlcXVlc3RlZCBvYmplY3QsIGlmIGZvdW5kXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmdldCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaWQsIHR5cGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMsXG4gICAgICAgICAgICBvYmplY3Q7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkuY29uY2F0KGNvbXBvc2l0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqZWN0cylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIG9iamVjdCA9IG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkgeyBcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuaWQudG9TdHJpbmcoKSA9PT0gaWQudG9TdHJpbmcoKTsgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmplY3QubGVuZ3RoID09PSAwID8gbnVsbCA6IG9iamVjdFswXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGdpdmVuIG9iamVjdChzKSBmcm9tIGNvbXBvc2l0ZUEgdG8gY29tcG9zaXRlQiAoZXF1YWwgdG8gYSByZW1vdmUgZm9sbG93ZWQgYnkgYW4gYWRkKS5cbiAgICAgKiBAbWV0aG9kIG1vdmVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZUF9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBvYmplY3RzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGVCfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZUFcbiAgICAgKi9cbiAgICBDb21wb3NpdGUubW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIG9iamVjdHMsIGNvbXBvc2l0ZUIpIHtcbiAgICAgICAgQ29tcG9zaXRlLnJlbW92ZShjb21wb3NpdGVBLCBvYmplY3RzKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZChjb21wb3NpdGVCLCBvYmplY3RzKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGlkcyBmb3IgYWxsIG9iamVjdHMgaW4gdGhlIGNvbXBvc2l0ZSwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCByZWJhc2VcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZWJhc2UgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqZWN0c1tpXS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIHRoZWlyIGN1cnJlbnQgcG9zaXRpb25zLCBcbiAgICAgKiB3aXRob3V0IGltcGFydGluZyBhbnkgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgdHJhbnNsYXRpb24sIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQm9keS50cmFuc2xhdGUoYm9kaWVzW2ldLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbXBvc2l0ZSBieSBhIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBnaXZlbiBwb2ludCwgd2l0aG91dCBpbXBhcnRpbmcgYW55IGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJvdGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgcm90YXRpb24sIHBvaW50LCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKSxcbiAgICAgICAgICAgIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnJvdGF0ZShib2R5LCByb3RhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlLCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludC5cbiAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnNjYWxlID0gZnVuY3Rpb24oY29tcG9zaXRlLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQsIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyBkeCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgZHkgKiBzY2FsZVlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnNjYWxlKGJvZHksIHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLmFkZGAgaXMgbWFkZSwgYmVmb3JlIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVBZGRcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0byBiZSBhZGRlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUuYWRkYCBpcyBtYWRlLCBhZnRlciBvYmplY3RzIGhhdmUgYmVlbiBhZGRlZC5cbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJBZGRcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0aGF0IGhhdmUgYmVlbiBhZGRlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUucmVtb3ZlYCBpcyBtYWRlLCBiZWZvcmUgb2JqZWN0cyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVtb3ZlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdG8gYmUgcmVtb3ZlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUucmVtb3ZlYCBpcyBtYWRlLCBhZnRlciBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICpcbiAgICAqIEBldmVudCBhZnRlclJlbW92ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYENvbXBvc2l0ZS5jcmVhdGVgIGJ5IGBDb21tb24ubmV4dElkYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IFwiY29tcG9zaXRlXCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBjb21wb3NpdGVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJDb21wb3NpdGVcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbXBvc2l0ZSBoYXMgYmVlbiBtb2RpZmllZCBkdXJpbmcgdGhlIGN1cnJlbnQgc3RlcC5cbiAgICAgKiBNb3N0IGBNYXR0ZXIuQ29tcG9zaXRlYCBtZXRob2RzIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhpcyBmbGFnIHRvIGB0cnVlYCB0byBpbmZvcm0gdGhlIGVuZ2luZSBvZiBjaGFuZ2VzIHRvIGJlIGhhbmRsZWQuXG4gICAgICogSWYgeW91IG5lZWQgdG8gY2hhbmdlIGl0IG1hbnVhbGx5LCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5zZXRNb2RpZmllZGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlzTW9kaWZpZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBgQ29tcG9zaXRlYCB0aGF0IGlzIHRoZSBwYXJlbnQgb2YgdGhpcyBjb21wb3NpdGUuIEl0IGlzIGF1dG9tYXRpY2FsbHkgbWFuYWdlZCBieSB0aGUgYE1hdHRlci5Db21wb3NpdGVgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XG4gICAgICogQHR5cGUgY29tcG9zaXRlXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYEJvZHlgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgYm9kaWVzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbEJvZGllc2AgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIGJvZHlbXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBgQ29uc3RyYWludGAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb25zdHJhaW50cyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxDb25zdHJhaW50c2AgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUgY29uc3RyYWludFtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBDb21wb3NpdGVgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgY29tcG9zaXRlcyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29tcG9zaXRlc1xuICAgICAqIEB0eXBlIGNvbXBvc2l0ZVtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Db21wb3NpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQ29tcG9zaXRlLmpzIiwiLyoqXG4qIFRoZSBgTWF0dGVyLkV2ZW50c2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgdG8gZmlyZSBhbmQgbGlzdGVuIHRvIGV2ZW50cyBvbiBvdGhlciBvYmplY3RzLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgRXZlbnRzXG4qL1xuXG52YXIgRXZlbnRzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuXG52YXIgQ29tbW9uID0gcmVxdWlyZSgnLi9Db21tb24nKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYC5cbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBFdmVudHMub24gPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgIG5hbWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgb2JqZWN0LmV2ZW50cyA9IG9iamVjdC5ldmVudHMgfHwge307XG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVdID0gb2JqZWN0LmV2ZW50c1tuYW1lXSB8fCBbXTtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGV2ZW50IGNhbGxiYWNrLiBJZiBubyBjYWxsYmFjaywgY2xlYXJzIGFsbCBjYWxsYmFja3MgaW4gYGV2ZW50TmFtZXNgLiBJZiBubyBgZXZlbnROYW1lc2AsIGNsZWFycyBhbGwgZXZlbnRzLlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBFdmVudHMub2ZmID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBFdmVudHMub2ZmKG9iamVjdCwgY2FsbGJhY2spXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBldmVudE5hbWVzO1xuICAgICAgICAgICAgZXZlbnROYW1lcyA9IENvbW1vbi5rZXlzKG9iamVjdC5ldmVudHMpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gb2JqZWN0LmV2ZW50c1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tzID0gW107XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2pdICE9PSBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVzW2ldXSA9IG5ld0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBhbGwgdGhlIGNhbGxiYWNrcyBzdWJzY3JpYmVkIHRvIHRoZSBnaXZlbiBvYmplY3QncyBgZXZlbnROYW1lYCwgaW4gdGhlIG9yZGVyIHRoZXkgc3Vic2NyaWJlZCwgaWYgYW55LlxuICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7fSBldmVudFxuICAgICAqL1xuICAgIEV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBldmVudCkge1xuICAgICAgICB2YXIgbmFtZXMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2tzLFxuICAgICAgICAgICAgZXZlbnRDbG9uZTtcblxuICAgICAgICBpZiAob2JqZWN0LmV2ZW50cykge1xuICAgICAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICAgICAgICBldmVudCA9IHt9O1xuXG4gICAgICAgICAgICBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBvYmplY3QuZXZlbnRzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBldmVudENsb25lID0gQ29tbW9uLmNsb25lKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUuc291cmNlID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Nbal0uYXBwbHkob2JqZWN0LCBbZXZlbnRDbG9uZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvRXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL0V2ZW50cy5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5WZXJ0aWNlc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgc2V0cyBvZiB2ZXJ0aWNlcy5cbiogQSBzZXQgb2YgdmVydGljZXMgaXMgYW4gYXJyYXkgb2YgYE1hdHRlci5WZWN0b3JgIHdpdGggYWRkaXRpb25hbCBpbmRleGluZyBwcm9wZXJ0aWVzIGluc2VydGVkIGJ5IGBWZXJ0aWNlcy5jcmVhdGVgLlxuKiBBIGBNYXR0ZXIuQm9keWAgbWFpbnRhaW5zIGEgc2V0IG9mIHZlcnRpY2VzIHRvIHJlcHJlc2VudCB0aGUgc2hhcGUgb2YgdGhlIG9iamVjdCAoaXRzIGNvbnZleCBodWxsKS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFZlcnRpY2VzXG4qL1xuXG52YXIgVmVydGljZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0aWNlcztcblxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGBNYXR0ZXIuQm9keWAgY29tcGF0aWJsZSB2ZXJ0aWNlcy5cbiAgICAgKiBUaGUgYHBvaW50c2AgYXJndW1lbnQgYWNjZXB0cyBhbiBhcnJheSBvZiBgTWF0dGVyLlZlY3RvcmAgcG9pbnRzIG9yaWVudGF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4gYCgwLCAwKWAsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XVxuICAgICAqXG4gICAgICogVGhlIGBWZXJ0aWNlcy5jcmVhdGVgIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHZlcnRpY2VzLCB3aGljaCBhcmUgc2ltaWxhciB0byBNYXR0ZXIuVmVjdG9yIG9iamVjdHMsXG4gICAgICogYnV0IHdpdGggc29tZSBhZGRpdGlvbmFsIHJlZmVyZW5jZXMgcmVxdWlyZWQgZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIHJvdXRpbmVzLlxuICAgICAqXG4gICAgICogVmVydGljZXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gY2xvY2t3aXNlIG9yZGVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBgYm9keWAgYXJndW1lbnQgaXMgbm90IG9wdGlvbmFsLCBhIGBNYXR0ZXIuQm9keWAgcmVmZXJlbmNlIG11c3QgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yW119IHBvaW50c1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBvaW50cywgYm9keSkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgIHZlcnRleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGlzSW50ZXJuYWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgY29udGFpbmluZyBvcmRlcmVkIHggeSBwYWlycyBzZXBhcmF0ZWQgYnkgc3BhY2VzIChhbmQgb3B0aW9uYWxseSBjb21tYXMpLCBcbiAgICAgKiBpbnRvIGEgYE1hdHRlci5WZXJ0aWNlc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gYE1hdHRlci5Cb2R5YC5cbiAgICAgKiBGb3IgcGFyc2luZyBTVkcgcGF0aHMsIHNlZSBgU3ZnLnBhdGhUb1ZlcnRpY2VzYC5cbiAgICAgKiBAbWV0aG9kIGZyb21QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5mcm9tUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgdmFyIHBhdGhQYXR0ZXJuID0gL0w/XFxzKihbXFwtXFxkXFwuZV0rKVtcXHMsXSooW1xcLVxcZFxcLmVdKykqL2lnLFxuICAgICAgICAgICAgcG9pbnRzID0gW107XG5cbiAgICAgICAgcGF0aC5yZXBsYWNlKHBhdGhQYXR0ZXJuLCBmdW5jdGlvbihtYXRjaCwgeCwgeSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiBwYXJzZUZsb2F0KHgpLCB5OiBwYXJzZUZsb2F0KHkpIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gVmVydGljZXMuY3JlYXRlKHBvaW50cywgYm9keSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNlbnRyZSAoY2VudHJvaWQpIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBjZW50cmVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gVGhlIGNlbnRyZSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNlbnRyZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBhcmVhID0gVmVydGljZXMuYXJlYSh2ZXJ0aWNlcywgdHJ1ZSksXG4gICAgICAgICAgICBjZW50cmUgPSB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGNyb3NzLFxuICAgICAgICAgICAgdGVtcCxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaiA9IChpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjcm9zcyA9IFZlY3Rvci5jcm9zcyh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbal0pO1xuICAgICAgICAgICAgdGVtcCA9IFZlY3Rvci5tdWx0KFZlY3Rvci5hZGQodmVydGljZXNbaV0sIHZlcnRpY2VzW2pdKSwgY3Jvc3MpO1xuICAgICAgICAgICAgY2VudHJlID0gVmVjdG9yLmFkZChjZW50cmUsIHRlbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFZlY3Rvci5kaXYoY2VudHJlLCA2ICogYXJlYSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgKG1lYW4pIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBtZWFuXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBhdmVyYWdlIHBvaW50XG4gICAgICovXG4gICAgVmVydGljZXMubWVhbiA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXZlcmFnZS54ICs9IHZlcnRpY2VzW2ldLng7XG4gICAgICAgICAgICBhdmVyYWdlLnkgKz0gdmVydGljZXNbaV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBWZWN0b3IuZGl2KGF2ZXJhZ2UsIHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFyZWEgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGFyZWFcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gc2lnbmVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXJlYVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmFyZWEgPSBmdW5jdGlvbih2ZXJ0aWNlcywgc2lnbmVkKSB7XG4gICAgICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgICAgIGogPSB2ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgKz0gKHZlcnRpY2VzW2pdLnggLSB2ZXJ0aWNlc1tpXS54KSAqICh2ZXJ0aWNlc1tqXS55ICsgdmVydGljZXNbaV0ueSk7XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gYXJlYSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFyZWEpIC8gMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKHNlY29uZCBtb21lbnQgb2YgYXJlYSkgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcyBnaXZlbiB0aGUgdG90YWwgbWFzcy5cbiAgICAgKiBAbWV0aG9kIGluZXJ0aWFcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9seWdvbidzIG1vbWVudCBvZiBpbmVydGlhXG4gICAgICovXG4gICAgVmVydGljZXMuaW5lcnRpYSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXNzKSB7XG4gICAgICAgIHZhciBudW1lcmF0b3IgPSAwLFxuICAgICAgICAgICAgZGVub21pbmF0b3IgPSAwLFxuICAgICAgICAgICAgdiA9IHZlcnRpY2VzLFxuICAgICAgICAgICAgY3Jvc3MsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvbHlnb24ncyBtb21lbnQgb2YgaW5lcnRpYSwgdXNpbmcgc2Vjb25kIG1vbWVudCBvZiBhcmVhXG4gICAgICAgIC8vIGh0dHA6Ly93d3cucGh5c2ljc2ZvcnVtcy5jb20vc2hvd3RocmVhZC5waHA/dD0yNTI5M1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHYubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGogPSAobiArIDEpICUgdi5sZW5ndGg7XG4gICAgICAgICAgICBjcm9zcyA9IE1hdGguYWJzKFZlY3Rvci5jcm9zcyh2W2pdLCB2W25dKSk7XG4gICAgICAgICAgICBudW1lcmF0b3IgKz0gY3Jvc3MgKiAoVmVjdG9yLmRvdCh2W2pdLCB2W2pdKSArIFZlY3Rvci5kb3QodltqXSwgdltuXSkgKyBWZWN0b3IuZG90KHZbbl0sIHZbbl0pKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IGNyb3NzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChtYXNzIC8gNikgKiAobnVtZXJhdG9yIC8gZGVub21pbmF0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBzZXQgb2YgdmVydGljZXMgaW4tcGxhY2UuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyXG4gICAgICovXG4gICAgVmVydGljZXMudHJhbnNsYXRlID0gZnVuY3Rpb24odmVydGljZXMsIHZlY3Rvciwgc2NhbGFyKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoc2NhbGFyKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ICs9IHZlY3Rvci54ICogc2NhbGFyO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgKz0gdmVjdG9yLnkgKiBzY2FsYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ICs9IHZlY3Rvci54O1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgKz0gdmVjdG9yLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIHNldCBvZiB2ZXJ0aWNlcyBpbi1wbGFjZS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICovXG4gICAgVmVydGljZXMucm90YXRlID0gZnVuY3Rpb24odmVydGljZXMsIGFuZ2xlLCBwb2ludCkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZSA9IHZlcnRpY2VzW2ldLFxuICAgICAgICAgICAgICAgIGR4ID0gdmVydGljZS54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IHZlcnRpY2UueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2ZXJ0aWNlLnggPSBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pO1xuICAgICAgICAgICAgdmVydGljZS55ID0gcG9pbnQueSArIChkeCAqIHNpbiArIGR5ICogY29zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBwb2ludGAgaXMgaW5zaWRlIHRoZSBzZXQgb2YgYHZlcnRpY2VzYC5cbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2ZXJ0aWNlcyBjb250YWlucyBwb2ludCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgVmVydGljZXMuY29udGFpbnMgPSBmdW5jdGlvbih2ZXJ0aWNlcywgcG9pbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2UgPSB2ZXJ0aWNlc1tpXSxcbiAgICAgICAgICAgICAgICBuZXh0VmVydGljZSA9IHZlcnRpY2VzWyhpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdO1xuICAgICAgICAgICAgaWYgKChwb2ludC54IC0gdmVydGljZS54KSAqIChuZXh0VmVydGljZS55IC0gdmVydGljZS55KSArIChwb2ludC55IC0gdmVydGljZS55KSAqICh2ZXJ0aWNlLnggLSBuZXh0VmVydGljZS54KSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoZSB2ZXJ0aWNlcyBmcm9tIGEgcG9pbnQgKGRlZmF1bHQgaXMgY2VudHJlKSBpbi1wbGFjZS5cbiAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLnNjYWxlID0gZnVuY3Rpb24odmVydGljZXMsIHNjYWxlWCwgc2NhbGVZLCBwb2ludCkge1xuICAgICAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcblxuICAgICAgICBwb2ludCA9IHBvaW50IHx8IFZlcnRpY2VzLmNlbnRyZSh2ZXJ0aWNlcyk7XG5cbiAgICAgICAgdmFyIHZlcnRleCxcbiAgICAgICAgICAgIGRlbHRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgZGVsdGEgPSBWZWN0b3Iuc3ViKHZlcnRleCwgcG9pbnQpO1xuICAgICAgICAgICAgdmVydGljZXNbaV0ueCA9IHBvaW50LnggKyBkZWx0YS54ICogc2NhbGVYO1xuICAgICAgICAgICAgdmVydGljZXNbaV0ueSA9IHBvaW50LnkgKyBkZWx0YS55ICogc2NhbGVZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFtZmVycyBhIHNldCBvZiB2ZXJ0aWNlcyBieSBnaXZpbmcgdGhlbSByb3VuZGVkIGNvcm5lcnMsIHJldHVybnMgYSBuZXcgc2V0IG9mIHZlcnRpY2VzLlxuICAgICAqIFRoZSByYWRpdXMgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIG51bWJlciBvciBhbiBhcnJheSB0byBzcGVjaWZ5IHRoZSByYWRpdXMgZm9yIGVhY2ggdmVydGV4LlxuICAgICAqIEBtZXRob2QgY2hhbWZlclxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eU1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5TWF4XG4gICAgICovXG4gICAgVmVydGljZXMuY2hhbWZlciA9IGZ1bmN0aW9uKHZlcnRpY2VzLCByYWRpdXMsIHF1YWxpdHksIHF1YWxpdHlNaW4sIHF1YWxpdHlNYXgpIHtcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IFs4XTtcblxuICAgICAgICBpZiAoIXJhZGl1cy5sZW5ndGgpXG4gICAgICAgICAgICByYWRpdXMgPSBbcmFkaXVzXTtcblxuICAgICAgICAvLyBxdWFsaXR5IGRlZmF1bHRzIHRvIC0xLCB3aGljaCBpcyBhdXRvXG4gICAgICAgIHF1YWxpdHkgPSAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSA/IHF1YWxpdHkgOiAtMTtcbiAgICAgICAgcXVhbGl0eU1pbiA9IHF1YWxpdHlNaW4gfHwgMjtcbiAgICAgICAgcXVhbGl0eU1heCA9IHF1YWxpdHlNYXggfHwgMTQ7XG5cbiAgICAgICAgdmFyIG5ld1ZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZXZWZXJ0ZXggPSB2ZXJ0aWNlc1tpIC0gMSA+PSAwID8gaSAtIDEgOiB2ZXJ0aWNlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXSxcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4ID0gdmVydGljZXNbKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgY3VycmVudFJhZGl1cyA9IHJhZGl1c1tpIDwgcmFkaXVzLmxlbmd0aCA/IGkgOiByYWRpdXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UmFkaXVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3VmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJldk5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoeyBcbiAgICAgICAgICAgICAgICB4OiB2ZXJ0ZXgueSAtIHByZXZWZXJ0ZXgueSwgXG4gICAgICAgICAgICAgICAgeTogcHJldlZlcnRleC54IC0gdmVydGV4LnhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbmV4dE5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoeyBcbiAgICAgICAgICAgICAgICB4OiBuZXh0VmVydGV4LnkgLSB2ZXJ0ZXgueSwgXG4gICAgICAgICAgICAgICAgeTogdmVydGV4LnggLSBuZXh0VmVydGV4LnhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSYWRpdXMgPSBNYXRoLnNxcnQoMiAqIE1hdGgucG93KGN1cnJlbnRSYWRpdXMsIDIpKSxcbiAgICAgICAgICAgICAgICByYWRpdXNWZWN0b3IgPSBWZWN0b3IubXVsdChDb21tb24uY2xvbmUocHJldk5vcm1hbCksIGN1cnJlbnRSYWRpdXMpLFxuICAgICAgICAgICAgICAgIG1pZE5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoVmVjdG9yLm11bHQoVmVjdG9yLmFkZChwcmV2Tm9ybWFsLCBuZXh0Tm9ybWFsKSwgMC41KSksXG4gICAgICAgICAgICAgICAgc2NhbGVkVmVydGV4ID0gVmVjdG9yLnN1Yih2ZXJ0ZXgsIFZlY3Rvci5tdWx0KG1pZE5vcm1hbCwgZGlhZ29uYWxSYWRpdXMpKTtcblxuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IHF1YWxpdHk7XG5cbiAgICAgICAgICAgIGlmIChxdWFsaXR5ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVjaWRlIHByZWNpc2lvblxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgucG93KGN1cnJlbnRSYWRpdXMsIDAuMzIpICogMS43NTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlY2lzaW9uID0gQ29tbW9uLmNsYW1wKHByZWNpc2lvbiwgcXVhbGl0eU1pbiwgcXVhbGl0eU1heCk7XG5cbiAgICAgICAgICAgIC8vIHVzZSBhbiBldmVuIHZhbHVlIGZvciBwcmVjaXNpb24sIG1vcmUgbGlrZWx5IHRvIHJlZHVjZSBheGVzIGJ5IHVzaW5nIHN5bW1ldHJ5XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICUgMiA9PT0gMSlcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gKz0gMTtcblxuICAgICAgICAgICAgdmFyIGFscGhhID0gTWF0aC5hY29zKFZlY3Rvci5kb3QocHJldk5vcm1hbCwgbmV4dE5vcm1hbCkpLFxuICAgICAgICAgICAgICAgIHRoZXRhID0gYWxwaGEgLyBwcmVjaXNpb247XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJlY2lzaW9uOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdWZXJ0aWNlcy5wdXNoKFZlY3Rvci5hZGQoVmVjdG9yLnJvdGF0ZShyYWRpdXNWZWN0b3IsIHRoZXRhICogaiksIHNjYWxlZFZlcnRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgaW5wdXQgdmVydGljZXMgaW50byBjbG9ja3dpc2Ugb3JkZXIgaW4gcGxhY2UuXG4gICAgICogQG1ldGhvZCBjbG9ja3dpc2VTb3J0XG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0ID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdmFyIGNlbnRyZSA9IFZlcnRpY2VzLm1lYW4odmVydGljZXMpO1xuXG4gICAgICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24odmVydGV4QSwgdmVydGV4Qikge1xuICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci5hbmdsZShjZW50cmUsIHZlcnRleEEpIC0gVmVjdG9yLmFuZ2xlKGNlbnRyZSwgdmVydGV4Qik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB2ZXJ0aWNlcyBmb3JtIGEgY29udmV4IHNoYXBlICh2ZXJ0aWNlcyBtdXN0IGJlIGluIGNsb2Nrd2lzZSBvcmRlcikuXG4gICAgICogQG1ldGhvZCBpc0NvbnZleFxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7Ym9vbH0gYHRydWVgIGlmIHRoZSBgdmVydGljZXNgIGFyZSBjb252ZXgsIGBmYWxzZWAgaWYgbm90IChvciBgbnVsbGAgaWYgbm90IGNvbXB1dGFibGUpLlxuICAgICAqL1xuICAgIFZlcnRpY2VzLmlzQ29udmV4ID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgLy8gaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvbHlnb25tZXNoL1xuXG4gICAgICAgIHZhciBmbGFnID0gMCxcbiAgICAgICAgICAgIG4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICB6O1xuXG4gICAgICAgIGlmIChuIDwgMylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGogPSAoaSArIDEpICUgbjtcbiAgICAgICAgICAgIGsgPSAoaSArIDIpICUgbjtcbiAgICAgICAgICAgIHogPSAodmVydGljZXNbal0ueCAtIHZlcnRpY2VzW2ldLngpICogKHZlcnRpY2VzW2tdLnkgLSB2ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgIHogLT0gKHZlcnRpY2VzW2pdLnkgLSB2ZXJ0aWNlc1tpXS55KSAqICh2ZXJ0aWNlc1trXS54IC0gdmVydGljZXNbal0ueCk7XG5cbiAgICAgICAgICAgIGlmICh6IDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWcgfD0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeiA+IDApIHtcbiAgICAgICAgICAgICAgICBmbGFnIHw9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbGFnID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWcgIT09IDApe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgaW5wdXQgdmVydGljZXMgYXMgYSBuZXcgYXJyYXkgb2YgcG9pbnRzLlxuICAgICAqIEBtZXRob2QgaHVsbFxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiBbdmVydGV4XSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIFZlcnRpY2VzLmh1bGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICAvLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpblxuXG4gICAgICAgIHZhciB1cHBlciA9IFtdLFxuICAgICAgICAgICAgbG93ZXIgPSBbXSwgXG4gICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIHNvcnQgdmVydGljZXMgb24geC1heGlzICh5LWF4aXMgZm9yIHRpZXMpXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuc2xpY2UoMCk7XG4gICAgICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24odmVydGV4QSwgdmVydGV4Qikge1xuICAgICAgICAgICAgdmFyIGR4ID0gdmVydGV4QS54IC0gdmVydGV4Qi54O1xuICAgICAgICAgICAgcmV0dXJuIGR4ICE9PSAwID8gZHggOiB2ZXJ0ZXhBLnkgLSB2ZXJ0ZXhCLnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGJ1aWxkIGxvd2VyIGh1bGxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyIFxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczMobG93ZXJbbG93ZXIubGVuZ3RoIC0gMl0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG93ZXIucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgdXBwZXIgaHVsbFxuICAgICAgICBmb3IgKGkgPSB2ZXJ0aWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgIHdoaWxlICh1cHBlci5sZW5ndGggPj0gMiBcbiAgICAgICAgICAgICAgICAgICAmJiBWZWN0b3IuY3Jvc3MzKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDJdLCB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgdmVydGV4KSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwcGVyLnB1c2godmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmNhdGVuYXRpb24gb2YgdGhlIGxvd2VyIGFuZCB1cHBlciBodWxscyBnaXZlcyB0aGUgY29udmV4IGh1bGxcbiAgICAgICAgLy8gb21pdCBsYXN0IHBvaW50cyBiZWNhdXNlIHRoZXkgYXJlIHJlcGVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIGxpc3RcbiAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgIGxvd2VyLnBvcCgpO1xuXG4gICAgICAgIHJldHVybiB1cHBlci5jb25jYXQobG93ZXIpO1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9nZW9tZXRyeS9WZXJ0aWNlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvVmVydGljZXMuanMiLCJ2YXIgRXZlbnRCaW5kaW5nID0gcmVxdWlyZSgnLi9FdmVudEJpbmRpbmcnKTtcblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHRoaXMuaGFzRmlsdGVycyA9IGZhbHNlO1xufTtcblxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50RGlzcGF0Y2hlcjtcblxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGdldEJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3MuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUJpbmRpbmc6IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldEJpbmRpbmcodHlwZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBuZXcgRXZlbnRCaW5kaW5nKHRoaXMsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHByaW9yaXR5KVxuICAgIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHsgcHJpb3JpdHkgPSAwOyB9XG5cbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmNyZWF0ZUJpbmRpbmcodHlwZSk7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRpbmcuYWRkKGxpc3RlbmVyLCBwcmlvcml0eSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uY2U6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgcHJpb3JpdHkpXG4gICAge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkgeyBwcmlvcml0eSA9IDA7IH1cblxuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuY3JlYXRlQmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5hZGQobGlzdGVuZXIsIHByaW9yaXR5LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAgQWRkIGEgY2FsbGJhY2sgdGhhdCBpcyBub3RpZmllZCBldmVyeSB0aW1lIHRoaXMgRXZlbnREaXNwYXRjaGVyIGRpc3BhdGNoZXMgYW4gZXZlbnRcbiAgICAvLyAgbm8gbWF0dGVyIHdoYXQgdGhlIGV2ZW50IHR5cGUgaXMuIEZpbHRlcnMgYXJlIGludm9rZWQgZmlyc3QsIGJlZm9yZSBhbnkgYmluZGluZ3MsXG4gICAgLy8gIGFuZCBjYW4gc3RvcCBldmVudHMgaWYgdGhleSB3aXNoIChpbiB3aGljaCBjYXNlIHRoZXknbGwgbmV2ZXIgcmVhY2ggdGhlIGJpbmRpbmdzKVxuICAgIGZpbHRlcjogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmZpbHRlcnMuaW5kZXhPZihjYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKGkgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgQWRkIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBSZW1vdmUgdGhlIGZpbHRlclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gKHRoaXMuZmlsdGVycy5sZW5ndGggPiAwKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpXG4gICAge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcuaGFzKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0b3RhbDogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcudG90YWwoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAvLyAgSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIHRoZSBFdmVudERpc3BhdGNoZXIsIGEgY2FsbCB0byB0aGlzIG1ldGhvZCBoYXMgbm8gZWZmZWN0LlxuICAgIG9mZjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKVxuICAgIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcodHlwZSk7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRpbmcucmVtb3ZlKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGlzcGF0Y2hIYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBldmVudC5yZXNldCh0aGlzKTtcblxuICAgICAgICAvLyAgUGFzcyB0aGUgZXZlbnQgdGhyb3VnaCB0aGUgZmlsdGVycyBmaXJzdFxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZpbHRlcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgICAgIC8vICBEaWQgdGhlIGZpbHRlciBraWxsIHRoZSBldmVudD8gSWYgc28sIHdlIGNhbiBhYm9ydCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Ll9wcm9wYWdhdGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcoZXZlbnQudHlwZSk7XG5cbiAgICAgICAgaWYgKGJpbmRpbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRpbmcuZGlzcGF0Y2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hIYW5kbGVyKGV2ZW50W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgYnV0IHJldGFpbnMgdGhlIGV2ZW50IHR5cGUgZW50cmllc1xuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5yZW1vdmVBbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGxGaWx0ZXJzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5oYXNGaWx0ZXJzID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyh0eXBlKTtcblxuICAgICAgICBpZiAoYmluZGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRlbGV0ZUFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGJpbmRpbmcgaW4gdGhpcy5iaW5kaW5ncylcbiAgICAgICAge1xuICAgICAgICAgICAgYmluZGluZy5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmRlbGV0ZUFsbCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEZpbHRlcnMoKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnREaXNwYXRjaGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIlxuLy8gIEVuY2Fwc3VsYXRlcyBhIDJEIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb3JuZXIgcG9pbnQgaW4gdGhlIHRvcC1sZWZ0XG4vLyAgYW5kIGl0cyBleHRlbmRzIGluIHggKHdpZHRoKSBhbmQgeSAoaGVpZ2h0KVxuXG52YXIgUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDA7IH1cbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG5cblJlY3RhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cblxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCk7XG4gICAgfSxcblxuICAgIC8vICBUT1BcbiAgICBnZXRMaW5lQTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLngsIHkxOiB0aGlzLnksIHgyOiB0aGlzLnJpZ2h0LCB5MjogdGhpcy55IH07XG4gICAgfSxcblxuICAgIC8vICBSSUdIVFxuICAgIGdldExpbmVCOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMucmlnaHQsIHkxOiB0aGlzLnksIHgyOiB0aGlzLnJpZ2h0LCB5MjogdGhpcy5ib3R0b20gfTtcbiAgICB9LFxuXG4gICAgLy8gIEJPVFRPTVxuICAgIGdldExpbmVDOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMucmlnaHQsIHkxOiB0aGlzLmJvdHRvbSwgeDI6IHRoaXMueCwgeTI6IHRoaXMuYm90dG9tIH07XG4gICAgfSxcblxuICAgIC8vICBMRUZUXG4gICAgZ2V0TGluZUQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54LCB5MTogdGhpcy5ib3R0b20sIHgyOiB0aGlzLngsIHkyOiB0aGlzLnkgfTtcbiAgICB9XG5cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlY3RhbmdsZS5wcm90b3R5cGUsIHtcblxuICAgIGxlZnQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICByaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdmFsdWUgLSB0aGlzLng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0b3A6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9ICh0aGlzLmJvdHRvbSAtIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJvdHRvbToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjZW50ZXJYOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyAodGhpcy53aWR0aCAvIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSAtICh0aGlzLndpZHRoIC8gMik7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjZW50ZXJZOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyAodGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUgLSAodGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRVUkwgPSByZXF1aXJlKCcuL0dldFVSTCcpO1xudmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIFhIUkxvYWRlciA9IHJlcXVpcmUoJy4vWEhSTG9hZGVyJyk7XG52YXIgWEhSU2V0dGluZ3MgPSByZXF1aXJlKCcuL1hIUlNldHRpbmdzJyk7XG52YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xuXG52YXIgRmlsZSA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHVybCwgcmVzcG9uc2VUeXBlLCB4aHJTZXR0aW5ncywgY29uZmlnKVxue1xuICAgIC8vICBmaWxlIHR5cGUgKGltYWdlLCBqc29uLCBldGMpIGZvciBzb3J0aW5nIHdpdGhpbiB0aGUgTG9hZGVyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8vICB1bmlxdWUgY2FjaGUga2V5ICh1bmlxdWUgd2l0aGluIGl0cyBmaWxlIHR5cGUpXG4gICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICAvLyAgVGhlIFVSTCBvZiB0aGUgZmlsZSwgbm90IGluY2x1ZGluZyBiYXNlVVJMXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvLyAgU2V0IHdoZW4gdGhlIExvYWRlciBjYWxscyAnbG9hZCcgb24gdGhpcyBmaWxlXG4gICAgdGhpcy5zcmMgPSAnJztcblxuICAgIHRoaXMueGhyU2V0dGluZ3MgPSBYSFJTZXR0aW5ncyhyZXNwb25zZVR5cGUpO1xuXG4gICAgaWYgKHhoclNldHRpbmdzKVxuICAgIHtcbiAgICAgICAgdGhpcy54aHJTZXR0aW5ncyA9IE1lcmdlWEhSU2V0dGluZ3ModGhpcy54aHJTZXR0aW5ncywgeGhyU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHRoaXMueGhyTG9hZGVyID0gbnVsbDtcblxuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BFTkRJTkc7XG5cbiAgICAvLyAgU2V0IGJ5IG9uUHJvZ3Jlc3MgKG9ubHkgaWYgbG9hZGluZyB2aWEgWEhSKVxuICAgIHRoaXMuYnl0ZXNUb3RhbCA9IDA7XG4gICAgdGhpcy5ieXRlc0xvYWRlZCA9IC0xO1xuICAgIHRoaXMucGVyY2VudENvbXBsZXRlID0gLTE7XG5cbiAgICAvLyAgRm9yIENPUnMgYmFzZWQgbG9hZGluZy5cbiAgICAvLyAgSWYgdGhpcyBpcyB1bmRlZmluZWQgdGhlbiB0aGUgRmlsZSB3aWxsIGNoZWNrIEJhc2VMb2FkZXIuY3Jvc3NPcmlnaW4gYW5kIHVzZSB0aGF0IChpZiBzZXQpXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcblxuICAgIC8vICBUaGUgYWN0dWFsIHByb2Nlc3NlZCBmaWxlIGRhdGFcbiAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyAgQSBjb25maWcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYnkgZmlsZSB0eXBlcyB0byBzdG9yZSB0cmFuc2l0aW9uYWwgZGF0YVxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgLy8gIE11bHRpcGFydCBmaWxlPyAoaS5lLiBhbiBhdGxhcyBhbmQgaXRzIGpzb24gdG9nZXRoZXIpXG4gICAgdGhpcy5saW5rRmlsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmtUeXBlID0gJyc7XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbn07XG5cbkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsZTtcblxuRmlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICByZXNldFhIUjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMueGhyTG9hZGVyLm9ubG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy54aHJMb2FkZXIub25lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy54aHJMb2FkZXIub25wcm9ncmVzcyA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLy8gIENhbGxlZCB3aGVuIHRoZSBJbWFnZSBsb2Fkc1xuICAgIC8vICBQcm9ncmVzc0V2ZW50XG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICB0aGlzLnJlc2V0WEhSKCk7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgb25FcnJvcjogZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZXNldFhIUigpO1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcywgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ieXRlc0xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNUb3RhbCA9IGV2ZW50LnRvdGFsO1xuXG4gICAgICAgICAgICB0aGlzLnBlcmNlbnRDb21wbGV0ZSA9IE1hdGgubWluKCh0aGlzLmJ5dGVzTG9hZGVkIC8gdGhpcy5ieXRlc1RvdGFsKSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBlcmNlbnRDb21wbGV0ZSArICclICgnICsgdGhpcy5ieXRlc0xvYWRlZCArICcgYnl0ZXMpJyk7XG4gICAgfSxcblxuICAgIG9uUHJvY2VzczogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcblxuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtGaWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rRmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9XQUlUSU5HX0xJTktGSUxFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGFuZCBpcyB3YWl0aW5nIGZvciB0aGlzIGZpbGUsIHNvIGxldCdzIGRvIHRoZW0gYm90aFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xuICAgICAgICAgICAgICAgIHRoaXMubGlua0ZpbGUuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBUaGUgbGlua2ZpbGUgc3RpbGwgaGFzbid0IGZpbmlzaGVkIGxvYWRpbmcgYW5kL29yIHByb2Nlc3NpbmcgeWV0XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfV0FJVElOR19MSU5LRklMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0NPTVBMRVRFO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICBDYWxsZWQgYnkgdGhlIExvYWRlciwgc3RhcnRzIHRoZSBhY3R1YWwgZmlsZSBkb3dubG9hZGluZ1xuICAgIGxvYWQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzZVVSTCwgZ2xvYmFsWEhSKVxuICAgIHtcbiAgICAgICAgaWYgKGJhc2VVUkwgPT09IHVuZGVmaW5lZCkgeyBiYXNlVVJMID0gJyc7IH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgdGhpcy5zcmMgPSBHZXRVUkwodGhpcywgYmFzZVVSTCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3JjLmluZGV4T2YoJ2RhdGE6JykgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhbCBkYXRhIFVSSScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy54aHJMb2FkZXIgPSBYSFJMb2FkZXIodGhpcywgZ2xvYmFsWEhSKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9GaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvRmlsZS5qcyIsInZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBY29zID0gTWF0aC5hY29zO1xudmFyIG1hdGhBdGFuID0gTWF0aC5hdGFuO1xuXG52YXIgVHJhbnNmb3JtTWF0cml4ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSkgXG57XG4gICAgYSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGEgOiAxO1xuICAgIGIgPSB0eXBlb2YgYiA9PT0gJ251bWJlcicgPyBiIDogMDtcbiAgICBjID0gdHlwZW9mIGMgPT09ICdudW1iZXInID8gYyA6IDA7XG4gICAgZCA9IHR5cGVvZiBkID09PSAnbnVtYmVyJyA/IGQgOiAxO1xuICAgIHR4ID0gdHlwZW9mIHR4ID09PSAnbnVtYmVyJyA/IHR4IDogMDtcbiAgICB0eSA9IHR5cGVvZiB0eSA9PT0gJ251bWJlcicgPyB0eSA6IDA7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoW2EsIGIsIGMsIGQsIHR4LCB0eSwgMCwgMCwgMV0pO1xuICAgIHRoaXMuZGVjb21wb3NlZE1hdHJpeCA9IHtcbiAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgdHJhbnNsYXRlWTogMCxcbiAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbn07XG5cblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUubG9hZElkZW50aXR5ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgXG4gICAgbWF0cml4WzBdID0gMTtcbiAgICBtYXRyaXhbMV0gPSAwO1xuICAgIG1hdHJpeFsyXSA9IDA7XG4gICAgbWF0cml4WzNdID0gMTtcbiAgICBtYXRyaXhbNF0gPSAwO1xuICAgIG1hdHJpeFs1XSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuXG4gICAgbWF0cml4WzRdID0gbWF0cml4WzBdICogeCArIG1hdHJpeFsyXSAqIHkgKyBtYXRyaXhbNF07XG4gICAgbWF0cml4WzVdID0gbWF0cml4WzFdICogeCArIG1hdHJpeFszXSAqIHkgKyBtYXRyaXhbNV07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cbiAgICBtYXRyaXhbMF0gPSBtYXRyaXhbMF0gKiB4O1xuICAgIG1hdHJpeFsxXSA9IG1hdHJpeFsxXSAqIHg7XG4gICAgbWF0cml4WzJdID0gbWF0cml4WzJdICogeTtcbiAgICBtYXRyaXhbM10gPSBtYXRyaXhbM10gKiB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChyYWRpYW4pXG57XG4gICAgdmFyIHJhZGlhblNpbiA9IG1hdGhTaW4ocmFkaWFuKTtcbiAgICB2YXIgcmFkaWFuQ29zID0gbWF0aENvcyhyYWRpYW4pO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHJhZGlhbkNvcywgLXJhZGlhblNpbiwgcmFkaWFuU2luLCByYWRpYW5Db3MsIDAsIDApO1xufTtcblxuVHJhbnNmb3JtTWF0cml4LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdGhlck1hdHJpeClcbntcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgdmFyIGEwID0gbWF0cml4WzBdO1xuICAgIHZhciBiMCA9IG1hdHJpeFsxXTtcbiAgICB2YXIgYzAgPSBtYXRyaXhbMl07XG4gICAgdmFyIGQwID0gbWF0cml4WzNdO1xuICAgIHZhciB0eDAgPSBtYXRyaXhbNF07XG4gICAgdmFyIHR5MCA9IG1hdHJpeFs1XTtcbiAgICB2YXIgYTEgPSBvdGhlck1hdHJpeFswXTtcbiAgICB2YXIgYjEgPSBvdGhlck1hdHJpeFsxXTtcbiAgICB2YXIgYzEgPSBvdGhlck1hdHJpeFsyXTtcbiAgICB2YXIgZDEgPSBvdGhlck1hdHJpeFszXTtcbiAgICB2YXIgdHgxID0gb3RoZXJNYXRyaXhbNF07XG4gICAgdmFyIHR5MSA9IG90aGVyTWF0cml4WzVdO1xuXG4gICAgbWF0cml4WzBdID0gYTEgKiBhMCArIGIxICogYzA7XG4gICAgbWF0cml4WzFdID0gYTEgKiBiMCArIGIxICogZDA7XG4gICAgbWF0cml4WzJdID0gYzEgKiBhMCArIGQxICogYzA7XG4gICAgbWF0cml4WzNdID0gYzEgKiBiMCArIGQxICogZDA7XG4gICAgbWF0cml4WzRdID0gdHgxICogYTAgKyB0eTEgKiBjMCArIHR4MDtcbiAgICBtYXRyaXhbNV0gPSB0eDEgKiBiMCArIHR5MSAqIGQwICsgdHkwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB0eCwgdHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIHZhciBhMCA9IG1hdHJpeFswXTtcbiAgICB2YXIgYjAgPSBtYXRyaXhbMV07XG4gICAgdmFyIGMwID0gbWF0cml4WzJdO1xuICAgIHZhciBkMCA9IG1hdHJpeFszXTtcbiAgICB2YXIgdHgwID0gbWF0cml4WzRdO1xuICAgIHZhciB0eTAgPSBtYXRyaXhbNV07XG5cbiAgICBtYXRyaXhbMF0gPSBhICogYTAgKyBiICogYzA7XG4gICAgbWF0cml4WzFdID0gYSAqIGIwICsgYiAqIGQwO1xuICAgIG1hdHJpeFsyXSA9IGMgKiBhMCArIGQgKiBjMDtcbiAgICBtYXRyaXhbM10gPSBjICogYjAgKyBkICogZDA7XG4gICAgbWF0cml4WzRdID0gdHggKiBhMCArIHR5ICogYzAgKyB0eDA7XG4gICAgbWF0cml4WzVdID0gdHggKiBiMCArIHR5ICogZDAgKyB0eTA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblRyYW5zZm9ybU1hdHJpeC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSlcbntcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cbiAgICBtYXRyaXhbMF0gPSBhO1xuICAgIG1hdHJpeFsxXSA9IGI7XG4gICAgbWF0cml4WzJdID0gYztcbiAgICBtYXRyaXhbM10gPSBkO1xuICAgIG1hdHJpeFs0XSA9IHR4O1xuICAgIG1hdHJpeFs1XSA9IHR5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLmRlY29tcG9zZU1hdHJpeCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGRlY29tcG9zZWRNYXRyaXggPSB0aGlzLmRlY29tcG9zZWRNYXRyaXg7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIHZhciBhID0gbWF0cml4WzBdO1xuICAgIHZhciBiID0gbWF0cml4WzFdO1xuICAgIHZhciBjID0gbWF0cml4WzJdO1xuICAgIHZhciBkID0gbWF0cml4WzNdO1xuICAgIHZhciBhMiA9IGEgKiBhO1xuICAgIHZhciBiMiA9IGIgKiBiO1xuICAgIHZhciBjMiA9IGMgKiBjO1xuICAgIHZhciBkMiA9IGQgKiBkO1xuICAgIHZhciBzeCA9IG1hdGhTcXJ0KGEyICsgYzIpO1xuICAgIHZhciBzeSA9IG1hdGhTcXJ0KGIyICsgZDIpO1xuXG4gICAgZGVjb21wb3NlZE1hdHJpeC50cmFuc2xhdGVYID0gbWF0cml4WzRdO1xuICAgIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWSA9IG1hdHJpeFs1XTtcbiAgICBkZWNvbXBvc2VkTWF0cml4LnNjYWxlWCA9IHN4O1xuICAgIGRlY29tcG9zZWRNYXRyaXguc2NhbGVZID0gc3k7XG4gICAgZGVjb21wb3NlZE1hdHJpeC5yb3RhdGlvbiA9IG1hdGhBY29zKGEgLyBzeCkgKiAobWF0aEF0YW4oLWMgLyBhKSA8IDAgPyAtMSA6IDEpO1xuXG4gICAgcmV0dXJuIGRlY29tcG9zZWRNYXRyaXg7XG59O1xuXG4vKiBpZGVudGl0eSArIHRyYW5zbGF0ZSArIHJvdGF0ZSArIHNjYWxlICovXG5UcmFuc2Zvcm1NYXRyaXgucHJvdG90eXBlLmFwcGx5SVRSUyA9IGZ1bmN0aW9uICh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpIFxue1xuICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICB2YXIgYSA9IDE7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgZCA9IDE7XG4gICAgdmFyIGUgPSAwO1xuICAgIHZhciBmID0gMDtcbiAgICB2YXIgc3IgPSBtYXRoU2luKHJvdGF0aW9uKTtcbiAgICB2YXIgY3IgPSBtYXRoQ29zKHJvdGF0aW9uKTtcblxuICAgIC8vIFRyYW5zbGF0ZVxuICAgIG1hdHJpeFs0XSA9IGEgKiB4ICsgYyAqIHkgKyBlO1xuICAgIG1hdHJpeFs1XSA9IGIgKiB4ICsgZCAqIHkgKyBmO1xuXG4gICAgLy8gUm90YXRlXG4gICAgbWF0cml4WzBdID0gY3IgKiBhICsgLXNyICogYztcbiAgICBtYXRyaXhbMV0gPSBjciAqIGIgKyAtc3IgKiBkO1xuICAgIG1hdHJpeFsyXSA9IHNyICogYSArIGNyICogYztcbiAgICBtYXRyaXhbM10gPSBzciAqIGIgKyBjciAqIGQ7XG5cbiAgICAvLyBTY2FsZVxuICAgIG1hdHJpeFswXSA9IG1hdHJpeFswXSAqIHNjYWxlWDtcbiAgICBtYXRyaXhbMV0gPSBtYXRyaXhbMV0gKiBzY2FsZVg7XG4gICAgbWF0cml4WzJdID0gbWF0cml4WzJdICogc2NhbGVZO1xuICAgIG1hdHJpeFszXSA9IG1hdHJpeFszXSAqIHNjYWxlWTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1NYXRyaXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xuXG52YXIgQnJvd3NlciA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhcm9yYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQXJvcmEuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgYXJvcmE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNocm9tZSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gQ2hyb21lLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNocm9tZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaHJvbWVWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBDaHJvbWUgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGNocm9tZVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXBpcGhhbnkgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIEVwaXBoYW55LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVwaXBoYW55OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaXJlZm94IC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBGaXJlZm94LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGZpcmVmb3g6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gZmlyZWZveFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEZpcmVmb3ggdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGZpcmVmb3hWZXJzaW9uOiAwLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vYmlsZVNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gTW9iaWxlIFNhZmFyaS5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBtb2JpbGVTYWZhcmk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGllIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZVZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gQmV5b25kIElFMTAgeW91IHNob3VsZCB1c2UgRGV2aWNlLnRyaWRlbnQgYW5kIERldmljZS50cmlkZW50VmVyc2lvbi5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBpZVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWlkb3JpIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWRvcmkuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbWlkb3JpOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvcGVyYSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gT3BlcmEuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgb3BlcmE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNhZmFyaSAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgaW4gU2FmYXJpLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHNhZmFyaTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYWZhcmlWZXJzaW9uIC0gSWYgcnVubmluZyBpbiBTYWZhcmkgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHNhZmFyaVZlcnNpb246IDAsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJpZGVudCAtIFNldCB0byB0cnVlIGlmIHJ1bm5pbmcgYSBUcmlkZW50IHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXIgKElFMTErKVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRyaWRlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdHJpZGVudFZlcnNpb24gLSBJZiBydW5uaW5nIGluIEludGVybmV0IEV4cGxvcmVyIDExIHRoaXMgd2lsbCBjb250YWluIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci4gU2VlIHtAbGluayBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1Mzc1MDModj12cy44NSkuYXNweH1cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0cmlkZW50VmVyc2lvbjogMCxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlZGdlIC0gU2V0IHRvIHRydWUgaWYgcnVubmluZyBpbiBNaWNyb3NvZnQgRWRnZSBicm93c2VyLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGVkZ2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNpbGsgLSBTZXQgdG8gdHJ1ZSBpZiBydW5uaW5nIGluIHRoZSBTaWxrIGJyb3dzZXIgKGFzIHVzZWQgb24gdGhlIEFtYXpvbiBLaW5kbGUpXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgc2lsazogZmFsc2VcblxufTtcblxuZnVuY3Rpb24gaW5pdCAoKVxue1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAoKC9Bcm9yYS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5hcm9yYSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9FZGdlXFwvXFxkKy8udGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0Nocm9tZVxcLyhcXGQrKS8pLnRlc3QodWEpICYmICFPUy53aW5kb3dzUGhvbmUpXG4gICAge1xuICAgICAgICBCcm93c2VyLmNocm9tZSA9IHRydWU7XG4gICAgICAgIEJyb3dzZXIuY2hyb21lVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0VwaXBoYW55LykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLmVwaXBoYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKC9GaXJlZm94XFxEKyhcXGQrKS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgQnJvd3Nlci5maXJlZm94VmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL0FwcGxlV2ViS2l0LykudGVzdCh1YSkgJiYgT1MuaU9TKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5tb2JpbGVTYWZhcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL01TSUUgKFxcZCtcXC5cXGQrKTsvKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLmllVmVyc2lvbiA9IHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL01pZG9yaS8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5taWRvcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL09wZXJhLykudGVzdCh1YSkpXG4gICAge1xuICAgICAgICBCcm93c2VyLm9wZXJhID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKC9TYWZhcmkvKS50ZXN0KHVhKSAmJiAhT1Mud2luZG93c1Bob25lKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoL1RyaWRlbnRcXC8oXFxkK1xcLlxcZCspKC4qKXJ2OihcXGQrXFwuXFxkKykvKS50ZXN0KHVhKSlcbiAgICB7XG4gICAgICAgIEJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLnRyaWRlbnQgPSB0cnVlO1xuICAgICAgICBCcm93c2VyLnRyaWRlbnRWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XG4gICAgICAgIEJyb3dzZXIuaWVWZXJzaW9uID0gcGFyc2VJbnQoUmVnRXhwLiQzLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gIFNpbGsgZ2V0cyBpdHMgb3duIGlmIGNsYXVzZSBiZWNhdXNlIGl0cyB1YSBhbHNvIGNvbnRhaW5zICdTYWZhcmknXG4gICAgaWYgKCgvU2lsay8pLnRlc3QodWEpKVxuICAgIHtcbiAgICAgICAgQnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gQnJvd3Nlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0Jyb3dzZXIuanMiLCJ2YXIgQW5nbGUgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gTWF0aC5hdGFuMihsaW5lLnkyIC0gbGluZS55MSwgbGluZS54MiAtIGxpbmUueDEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9BbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldENvbG9yID0gcmVxdWlyZSgnLi9HZXRDb2xvcicpO1xudmFyIEdldENvbG9yMzIgPSByZXF1aXJlKCcuL0dldENvbG9yMzInKTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxue1xuICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZCkgeyByZWQgPSAwOyB9XG4gICAgaWYgKGdyZWVuID09PSB1bmRlZmluZWQpIHsgZ3JlZW4gPSAwOyB9XG4gICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMDsgfVxuICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMjU1OyB9XG5cbiAgICAvLyAgQWxsIHByaXZhdGVcbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuZyA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmEgPSAyNTU7XG5cbiAgICB0aGlzLmdsID0gWyAwLjAsIDAuMCwgMC4wLCAxLjAgXTtcblxuICAgIHRoaXMuX2NvbG9yID0gMDtcbiAgICB0aGlzLl9jb2xvcjMyID0gMDtcbiAgICB0aGlzLl9yZ2JhID0gJyc7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0VG8ocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmNvbnRydXNjdG9yID0gQ29sb3I7XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblxuICAgIHRyYW5zcGFyZW50OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWQgPSAwO1xuICAgICAgICB0aGlzLmdyZWVuID0gMDtcbiAgICAgICAgdGhpcy5ibHVlID0gMDtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDA7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIC8vICBWYWx1ZXMgYXJlIGluIHRoZSByYW5nZSAwIHRvIDI1NVxuICAgIHNldFRvOiBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpXG4gICAge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgeyBhbHBoYSA9IDI1NTsgfVxuXG4gICAgICAgIHRoaXMucmVkID0gcmVkO1xuICAgICAgICB0aGlzLmdyZWVuID0gZ3JlZW47XG4gICAgICAgIHRoaXMuYmx1ZSA9IGJsdWU7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gIFZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIDAgdG8gMVxuICAgIHNldEdMVG86IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcbiAgICB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7IGFscGhhID0gMTsgfVxuXG4gICAgICAgIHRoaXMucmVkR0wgPSByZWQ7XG4gICAgICAgIHRoaXMuZ3JlZW5HTCA9IGdyZWVuO1xuICAgICAgICB0aGlzLmJsdWVHTCA9IGJsdWU7XG4gICAgICAgIHRoaXMuYWxwaGFHTCA9IGFscGhhO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRGcm9tUkdCOiBmdW5jdGlvbiAoY29sb3IpXG4gICAge1xuICAgICAgICB0aGlzLnJlZCA9IGNvbG9yLnI7XG4gICAgICAgIHRoaXMuZ3JlZW4gPSBjb2xvci5nO1xuICAgICAgICB0aGlzLmJsdWUgPSBjb2xvci5iO1xuXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eSgnYScpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFscGhhID0gY29sb3IuYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29sb3IgPSBHZXRDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgICAgdGhpcy5fY29sb3IzMiA9IEdldENvbG9yMzIodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcbiAgICAgICAgdGhpcy5fcmdiYSA9ICdyZ2JhKCcgKyB0aGlzLnIgKyAnLCcgKyB0aGlzLmcgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyAoMjU1IC8gdGhpcy5hKSArICcpJztcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBTYW1lIGFzIHNldFJHQiBidXQgcGVyZm9ybXMgc2FmZXR5IGNoZWNrcyBvbiBhbGwgdGhlIHZhbHVlcyBnaXZlblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICBjb2xvcjoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb2xvcjMyOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjMyO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmdiYToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmdiYTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMSByYW5nZVxuICAgIHJlZEdMOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsWzBdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5mbG9vcih0aGlzLmdsWzBdICogMjU1KTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBncmVlbkdMOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsWzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsWzFdID0gTWF0aC5taW4oTWF0aC5hYnModmFsdWUpLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5nID0gTWF0aC5mbG9vcih0aGlzLmdsWzFdICogMjU1KTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBibHVlR0w6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbMl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2xbMl0gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xuXG4gICAgICAgICAgICB0aGlzLmIgPSBNYXRoLmZsb29yKHRoaXMuZ2xbMl0gKiAyNTUpO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFscGhhR0w6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xbM107XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2xbM10gPSBNYXRoLm1pbihNYXRoLmFicyh2YWx1ZSksIDEpO1xuXG4gICAgICAgICAgICB0aGlzLmEgPSBNYXRoLmZsb29yKHRoaXMuZ2xbM10gKiAyNTUpO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vICBHZXRzIGFuZCBzZXRzIHRoZSByZWQgdmFsdWUsIG5vcm1hbGl6ZWQgdG8gdGhlIDAgdG8gMjU1IHJhbmdlXG4gICAgcmVkOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLnIgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcblxuICAgICAgICAgICAgdGhpcy5nbFswXSA9IHZhbHVlIC8gMjU1O1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdyZWVuOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbih2YWx1ZSwgMjU1KTtcblxuICAgICAgICAgICAgdGhpcy5nbFsxXSA9IHZhbHVlIC8gMjU1O1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJsdWU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XG5cbiAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKHZhbHVlLCAyNTUpO1xuXG4gICAgICAgICAgICB0aGlzLmdsWzJdID0gdmFsdWUgLyAyNTU7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYWxwaGE6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKE1hdGguYWJzKHZhbHVlKSk7XG5cbiAgICAgICAgICAgIHRoaXMuYSA9IE1hdGgubWluKHZhbHVlLCAyNTUpO1xuXG4gICAgICAgICAgICB0aGlzLmdsWzNdID0gdmFsdWUgLyAyNTU7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0NvbG9yLmpzIiwiLyoqXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcbiovXG5cbnZhciBHZXRDZW50ZXJYID0gZnVuY3Rpb24gKGdhbWVPYmplY3QpXG57XG4gICAgcmV0dXJuIGdhbWVPYmplY3QueCAtIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YKSArIChnYW1lT2JqZWN0LndpZHRoICogMC41KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudGVyWDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9HZXRDZW50ZXJYLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGNlbnRlciB4IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxuKlxuKiBAcHJvcGVydHkge251bWJlcn0gY2VudGVyWFxuKi9cblxudmFyIEdldENlbnRlclkgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcbntcbiAgICByZXR1cm4gZ2FtZU9iamVjdC55IC0gKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZKSArIChnYW1lT2JqZWN0LmhlaWdodCAqIDAuNSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRlclk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0Q2VudGVyWS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcbiovXG5cbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkdldENlbnRlclgoYm9iKVxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyT24oYm9iLCB4LCB5KVxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWChib2IsIHgpXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJZKGJvYiwgeClcblxudmFyIFNldENlbnRlclggPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeClcbntcbiAgICB2YXIgb2Zmc2V0WCA9IGdhbWVPYmplY3Qud2lkdGggKiBnYW1lT2JqZWN0Lm9yaWdpblg7XG5cbiAgICBnYW1lT2JqZWN0LnggPSAoeCArIG9mZnNldFgpIC0gKGdhbWVPYmplY3Qud2lkdGggKiAwLjUpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENlbnRlclg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvU2V0Q2VudGVyWC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBjZW50ZXIgeCBjb29yZGluYXRlIG9mIHRoZSBHYW1lIE9iamVjdC5cbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgKHggLSBvZmZzZXRYKSArICh3aWR0aCAvIDIpYC5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IGNlbnRlclhcbiovXG5cbi8vICBQaGFzZXIuVXRpbHMuQm91bmRzLkdldENlbnRlclgoYm9iKVxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyT24oYm9iLCB4LCB5KVxuLy8gIFBoYXNlci5VdGlscy5Cb3VuZHMuQ2VudGVyWChib2IsIHgpXG4vLyAgUGhhc2VyLlV0aWxzLkJvdW5kcy5DZW50ZXJZKGJvYiwgeClcblxudmFyIFNldENlbnRlclkgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgeSlcbntcbiAgICB2YXIgb2Zmc2V0WSA9IGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5vcmlnaW5ZO1xuXG4gICAgZ2FtZU9iamVjdC55ID0gKHkgKyBvZmZzZXRZKSAtIChnYW1lT2JqZWN0LmhlaWdodCAqIDAuNSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2VudGVyWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9TZXRDZW50ZXJZLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcblxudmFyIEltYWdlRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MsIGNvbmZpZylcbntcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxuXG4gICAgaWYgKCFrZXkpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLmltYWdlXFwnIGludmFsaWQga2V5IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIGlmICghdXJsKVxuICAgIHtcbiAgICAgICAgdXJsID0gcGF0aCArIGtleSArICcucG5nJztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcbiAgICB9XG5cbiAgICBGaWxlLmNhbGwodGhpcywgJ2ltYWdlJywga2V5LCB1cmwsICdibG9iJywgeGhyU2V0dGluZ3MsIGNvbmZpZyk7XG59O1xuXG5JbWFnZUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XG5JbWFnZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VGaWxlO1xuXG5JbWFnZUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcbntcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xuXG4gICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XG5cbiAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZGF0YS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XG5cbiAgICAgICAgX3RoaXMub25Db21wbGV0ZSgpO1xuXG4gICAgICAgIGNhbGxiYWNrKF90aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kYXRhLm9uZXJyb3IgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChfdGhpcy5kYXRhLnNyYyk7XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XG5cbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xuICAgIH07XG5cbiAgICB0aGlzLmRhdGEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnhockxvYWRlci5yZXNwb25zZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZS5qcyIsIi8vIEEgdHJpYW5nbGUgaXMgYSBwbGFuZSBjcmVhdGVkIGJ5IGNvbm5lY3RpbmcgdGhyZWUgcG9pbnRzLlxuLy8gVGhlIGZpcnN0IHR3byBhcmd1bWVudHMgc3BlY2lmeSB0aGUgZmlyc3QgcG9pbnQsIHRoZSBtaWRkbGUgdHdvIGFyZ3VtZW50c1xuLy8gc3BlY2lmeSB0aGUgc2Vjb25kIHBvaW50LCBhbmQgdGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSB0aGlyZCBwb2ludC5cblxudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXG57XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG5cbiAgICB0aGlzLngyID0gMDtcbiAgICB0aGlzLnkyID0gMDtcblxuICAgIHRoaXMueDMgPSAwO1xuICAgIHRoaXMueTMgPSAwO1xuXG4gICAgdGhpcy5zZXRUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyaWFuZ2xlO1xuXG5UcmlhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXG4gICAge1xuICAgICAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxuICAgICAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cbiAgICAgICAgaWYgKHgzID09PSB1bmRlZmluZWQpIHsgeDMgPSAwOyB9XG4gICAgICAgIGlmICh5MyA9PT0gdW5kZWZpbmVkKSB7IHkzID0gMDsgfVxuXG4gICAgICAgIHRoaXMueDEgPSB4MTtcbiAgICAgICAgdGhpcy55MSA9IHkxO1xuXG4gICAgICAgIHRoaXMueDIgPSB4MjtcbiAgICAgICAgdGhpcy55MiA9IHkyO1xuXG4gICAgICAgIHRoaXMueDMgPSB4MztcbiAgICAgICAgdGhpcy55MyA9IHkzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMaW5lQTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLngxLCB5MTogdGhpcy55MSwgeDI6IHRoaXMueDIsIHkyOiB0aGlzLnkyIH07XG4gICAgfSxcblxuICAgIGdldExpbmVCOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDIsIHkxOiB0aGlzLnkyLCB4MjogdGhpcy54MywgeTI6IHRoaXMueTMgfTtcbiAgICB9LFxuXG4gICAgZ2V0TGluZUM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4geyB4MTogdGhpcy54MywgeTE6IHRoaXMueTMsIHgyOiB0aGlzLngxLCB5MjogdGhpcy55MSB9O1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJpYW5nbGUucHJvdG90eXBlLCB7XG5cbiAgICBsZWZ0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy54MSA8PSB0aGlzLngyICYmIHRoaXMueDEgPD0gdGhpcy54MylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54MiA8PSB0aGlzLngxICYmIHRoaXMueDIgPD0gdGhpcy54MylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MiAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngzIC0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMueDEgLT0gZGlmZjtcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcbiAgICAgICAgICAgIHRoaXMueDMgLT0gZGlmZjtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLngxLCB0aGlzLngyLCB0aGlzLngzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy54MSA+PSB0aGlzLngyICYmIHRoaXMueDEgPj0gdGhpcy54MylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MSAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54MiA+PSB0aGlzLngxICYmIHRoaXMueDIgPj0gdGhpcy54MylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy54MiAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLngzIC0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMueDEgLT0gZGlmZjtcbiAgICAgICAgICAgIHRoaXMueDIgLT0gZGlmZjtcbiAgICAgICAgICAgIHRoaXMueDMgLT0gZGlmZjtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRvcDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy55MSwgdGhpcy55MiwgdGhpcy55Myk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcblxuICAgICAgICAgICAgaWYgKHRoaXMueTEgPD0gdGhpcy55MiAmJiB0aGlzLnkxIDw9IHRoaXMueTMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTEgLSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueTIgPD0gdGhpcy55MSAmJiB0aGlzLnkyIDw9IHRoaXMueTMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTIgLSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy55MyAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnkxIC09IGRpZmY7XG4gICAgICAgICAgICB0aGlzLnkyIC09IGRpZmY7XG4gICAgICAgICAgICB0aGlzLnkzIC09IGRpZmY7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBib3R0b206IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueTEsIHRoaXMueTIsIHRoaXMueTMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnkxID49IHRoaXMueTIgJiYgdGhpcy55MSA+PSB0aGlzLnkzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkxIC0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnkyID49IHRoaXMueTEgJiYgdGhpcy55MiA+PSB0aGlzLnkzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnkyIC0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMueTMgLSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy55MSAtPSBkaWZmO1xuICAgICAgICAgICAgdGhpcy55MiAtPSBkaWZmO1xuICAgICAgICAgICAgdGhpcy55MyAtPSBkaWZmO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGJvZHkgbW9kZWxzLlxuKiBBIGBNYXR0ZXIuQm9keWAgaXMgYSByaWdpZCBib2R5IHRoYXQgY2FuIGJlIHNpbXVsYXRlZCBieSBhIGBNYXR0ZXIuRW5naW5lYC5cbiogRmFjdG9yaWVzIGZvciBjb21tb25seSB1c2VkIGJvZHkgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgcmVjdGFuZ2xlcywgY2lyY2xlcyBhbmQgb3RoZXIgcG9seWdvbnMpIGNhbiBiZSBmb3VuZCBpbiB0aGUgbW9kdWxlIGBNYXR0ZXIuQm9kaWVzYC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cblxuKiBAY2xhc3MgQm9keVxuKi9cblxudmFyIEJvZHkgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9BeGVzJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIEJvZHkuX2luZXJ0aWFTY2FsZSA9IDQ7XG4gICAgQm9keS5fbmV4dENvbGxpZGluZ0dyb3VwSWQgPSAxO1xuICAgIEJvZHkuX25leHROb25Db2xsaWRpbmdHcm91cElkID0gLTE7XG4gICAgQm9keS5fbmV4dENhdGVnb3J5ID0gMHgwMDAxO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBib2R5XG4gICAgICovXG4gICAgQm9keS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGlkOiBDb21tb24ubmV4dElkKCksXG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBsYWJlbDogJ0JvZHknLFxuICAgICAgICAgICAgcGFydHM6IFtdLFxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMIDQwIDAgTCA0MCA0MCBMIDAgNDAnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGZvcmNlOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHRvcnF1ZTogMCxcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjb25zdHJhaW50SW1wdWxzZTogeyB4OiAwLCB5OiAwLCBhbmdsZTogMCB9LFxuICAgICAgICAgICAgdG90YWxDb250YWN0czogMCxcbiAgICAgICAgICAgIHNwZWVkOiAwLFxuICAgICAgICAgICAgYW5ndWxhclNwZWVkOiAwLFxuICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwLFxuICAgICAgICAgICAgaXNTZW5zb3I6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgICAgICAgICBtb3Rpb246IDAsXG4gICAgICAgICAgICBzbGVlcFRocmVzaG9sZDogNjAsXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAwMSxcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiAwLFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuMSxcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiAwLjUsXG4gICAgICAgICAgICBmcmljdGlvbkFpcjogMC4wMSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3A6IDAuMDUsXG4gICAgICAgICAgICB0aW1lU2NhbGU6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3ByaXRlOiB7XG4gICAgICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYm9keSA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIF9pbml0UHJvcGVydGllcyhib2R5LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgZ3JvdXAgaW5kZXggZm9yIHdoaWNoIGJvZGllcyB3aWxsIGNvbGxpZGUuXG4gICAgICogSWYgYGlzTm9uQ29sbGlkaW5nYCBpcyBgdHJ1ZWAsIHJldHVybnMgdGhlIG5leHQgdW5pcXVlIGdyb3VwIGluZGV4IGZvciB3aGljaCBib2RpZXMgd2lsbCBfbm90XyBjb2xsaWRlLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBtZXRob2QgbmV4dEdyb3VwXG4gICAgICogQHBhcmFtIHtib29sfSBbaXNOb25Db2xsaWRpbmc9ZmFsc2VdXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBVbmlxdWUgZ3JvdXAgaW5kZXhcbiAgICAgKi9cbiAgICBCb2R5Lm5leHRHcm91cCA9IGZ1bmN0aW9uKGlzTm9uQ29sbGlkaW5nKSB7XG4gICAgICAgIGlmIChpc05vbkNvbGxpZGluZylcbiAgICAgICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Tm9uQ29sbGlkaW5nR3JvdXBJZC0tO1xuXG4gICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Q29sbGlkaW5nR3JvdXBJZCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZCAoc3RhcnRpbmcgYWZ0ZXIgdGhlIGluaXRpYWwgZGVmYXVsdCBjYXRlZ29yeSBgMHgwMDAxYCkuXG4gICAgICogVGhlcmUgYXJlIDMyIGF2YWlsYWJsZS4gU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZCBuZXh0Q2F0ZWdvcnlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBjYXRlZ29yeSBiaXRmaWVsZFxuICAgICAqL1xuICAgIEJvZHkubmV4dENhdGVnb3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEJvZHkuX25leHRDYXRlZ29yeSA9IEJvZHkuX25leHRDYXRlZ29yeSA8PCAxO1xuICAgICAgICByZXR1cm4gQm9keS5fbmV4dENhdGVnb3J5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlcyBib2R5IHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBfaW5pdFByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICB2YXIgX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBpbml0IHJlcXVpcmVkIHByb3BlcnRpZXMgKG9yZGVyIGlzIGltcG9ydGFudClcbiAgICAgICAgQm9keS5zZXQoYm9keSwge1xuICAgICAgICAgICAgYm91bmRzOiBib2R5LmJvdW5kcyB8fCBCb3VuZHMuY3JlYXRlKGJvZHkudmVydGljZXMpLFxuICAgICAgICAgICAgcG9zaXRpb25QcmV2OiBib2R5LnBvc2l0aW9uUHJldiB8fCBWZWN0b3IuY2xvbmUoYm9keS5wb3NpdGlvbiksXG4gICAgICAgICAgICBhbmdsZVByZXY6IGJvZHkuYW5nbGVQcmV2IHx8IGJvZHkuYW5nbGUsXG4gICAgICAgICAgICB2ZXJ0aWNlczogYm9keS52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHBhcnRzOiBib2R5LnBhcnRzIHx8IFtib2R5XSxcbiAgICAgICAgICAgIGlzU3RhdGljOiBib2R5LmlzU3RhdGljLFxuICAgICAgICAgICAgaXNTbGVlcGluZzogYm9keS5pc1NsZWVwaW5nLFxuICAgICAgICAgICAgcGFyZW50OiBib2R5LnBhcmVudCB8fCBib2R5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFZlcnRpY2VzLnJvdGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LmFuZ2xlLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgQXhlcy5yb3RhdGUoYm9keS5heGVzLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgQm91bmRzLnVwZGF0ZShib2R5LmJvdW5kcywgYm9keS52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG5cbiAgICAgICAgLy8gYWxsb3cgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHByb3BlcnRpZXNcbiAgICAgICAgQm9keS5zZXQoYm9keSwge1xuICAgICAgICAgICAgYXhlczogb3B0aW9ucy5heGVzIHx8IGJvZHkuYXhlcyxcbiAgICAgICAgICAgIGFyZWE6IG9wdGlvbnMuYXJlYSB8fCBib2R5LmFyZWEsXG4gICAgICAgICAgICBtYXNzOiBvcHRpb25zLm1hc3MgfHwgYm9keS5tYXNzLFxuICAgICAgICAgICAgaW5lcnRpYTogb3B0aW9ucy5pbmVydGlhIHx8IGJvZHkuaW5lcnRpYVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW5kZXIgcHJvcGVydGllc1xuICAgICAgICB2YXIgZGVmYXVsdEZpbGxTdHlsZSA9IChib2R5LmlzU3RhdGljID8gJyMyZTJiNDQnIDogQ29tbW9uLmNob29zZShbJyMwMDZCQTYnLCAnIzA0OTZGRicsICcjRkZCQzQyJywgJyNEODExNTknLCAnIzhGMkQ1NiddKSksXG4gICAgICAgICAgICBkZWZhdWx0U3Ryb2tlU3R5bGUgPSBDb21tb24uc2hhZGVDb2xvcihkZWZhdWx0RmlsbFN0eWxlLCAtMjApO1xuICAgICAgICBib2R5LnJlbmRlci5maWxsU3R5bGUgPSBib2R5LnJlbmRlci5maWxsU3R5bGUgfHwgZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgICAgYm9keS5yZW5kZXIuc3Ryb2tlU3R5bGUgPSBib2R5LnJlbmRlci5zdHJva2VTdHlsZSB8fCBkZWZhdWx0U3Ryb2tlU3R5bGU7XG4gICAgICAgIGJvZHkucmVuZGVyLnNwcml0ZS54T2Zmc2V0ICs9IC0oYm9keS5ib3VuZHMubWluLnggLSBib2R5LnBvc2l0aW9uLngpIC8gKGJvZHkuYm91bmRzLm1heC54IC0gYm9keS5ib3VuZHMubWluLngpO1xuICAgICAgICBib2R5LnJlbmRlci5zcHJpdGUueU9mZnNldCArPSAtKGJvZHkuYm91bmRzLm1pbi55IC0gYm9keS5wb3NpdGlvbi55KSAvIChib2R5LmJvdW5kcy5tYXgueSAtIGJvZHkuYm91bmRzLm1pbi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwcm9wZXJ0eSBhbmQgYSB2YWx1ZSAob3IgbWFwIG9mKSwgc2V0cyB0aGUgcHJvcGVydHkocykgb24gdGhlIGJvZHksIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXR0ZXIgZnVuY3Rpb25zIGlmIHRoZXkgZXhpc3QuXG4gICAgICogUHJlZmVyIHRvIHVzZSB0aGUgYWN0dWFsIHNldHRlciBmdW5jdGlvbnMgaW4gcGVyZm9ybWFuY2UgY3JpdGljYWwgc2l0dWF0aW9ucy5cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7fSBzZXR0aW5ncyBBIHByb3BlcnR5IG5hbWUgKG9yIG1hcCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMpIHRvIHNldCBvbiB0aGUgYm9keS5cbiAgICAgKiBAcGFyYW0ge30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBpZiBgc2V0dGluZ3NgIGlzIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUuXG4gICAgICovXG4gICAgQm9keS5zZXQgPSBmdW5jdGlvbihib2R5LCBzZXR0aW5ncywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHNldHRpbmdzO1xuICAgICAgICAgICAgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIHNldHRpbmdzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5nc1twcm9wZXJ0eV07XG5cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2lzU3RhdGljJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFN0YXRpYyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc1NsZWVwaW5nJzpcbiAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWFzcyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RlbnNpdHknOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0RGVuc2l0eShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbmVydGlhJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmVydGljZXMnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0VmVydGljZXMoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5nbGUnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0QW5nbGUoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmVsb2NpdHknOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0VmVsb2NpdHkoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5ndWxhclZlbG9jaXR5JzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldEFuZ3VsYXJWZWxvY2l0eShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwYXJ0cyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRQYXJ0cyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJvZHlbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5IGFzIHN0YXRpYywgaW5jbHVkaW5nIGlzU3RhdGljIGZsYWcgYW5kIHNldHRpbmcgbWFzcyBhbmQgaW5lcnRpYSB0byBJbmZpbml0eS5cbiAgICAgKiBAbWV0aG9kIHNldFN0YXRpY1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gaXNTdGF0aWNcbiAgICAgKi9cbiAgICBCb2R5LnNldFN0YXRpYyA9IGZ1bmN0aW9uKGJvZHksIGlzU3RhdGljKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcGFydC5pc1N0YXRpYyA9IGlzU3RhdGljO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBwYXJ0Ll9vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IHBhcnQucmVzdGl0dXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uOiBwYXJ0LmZyaWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBtYXNzOiBwYXJ0Lm1hc3MsXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWE6IHBhcnQuaW5lcnRpYSxcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eTogcGFydC5kZW5zaXR5LFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlTWFzczogcGFydC5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUluZXJ0aWE6IHBhcnQuaW52ZXJzZUluZXJ0aWFcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcGFydC5yZXN0aXR1dGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgcGFydC5tYXNzID0gcGFydC5pbmVydGlhID0gcGFydC5kZW5zaXR5ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgcGFydC5pbnZlcnNlTWFzcyA9IHBhcnQuaW52ZXJzZUluZXJ0aWEgPSAwO1xuXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvblByZXYueCA9IHBhcnQucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi55ID0gcGFydC5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIHBhcnQuYW5nbGVQcmV2ID0gcGFydC5hbmdsZTtcbiAgICAgICAgICAgICAgICBwYXJ0LmFuZ3VsYXJWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5hbmd1bGFyU3BlZWQgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnQubW90aW9uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC5fb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnJlc3RpdHV0aW9uID0gcGFydC5fb3JpZ2luYWwucmVzdGl0dXRpb247XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IHBhcnQuX29yaWdpbmFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHBhcnQubWFzcyA9IHBhcnQuX29yaWdpbmFsLm1hc3M7XG4gICAgICAgICAgICAgICAgcGFydC5pbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW5lcnRpYTtcbiAgICAgICAgICAgICAgICBwYXJ0LmRlbnNpdHkgPSBwYXJ0Ll9vcmlnaW5hbC5kZW5zaXR5O1xuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZU1hc3MgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VJbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW52ZXJzZUluZXJ0aWE7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgcGFydC5fb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFzcyBvZiB0aGUgYm9keS4gSW52ZXJzZSBtYXNzIGFuZCBkZW5zaXR5IGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuICAgICAqIEBtZXRob2Qgc2V0TWFzc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgICovXG4gICAgQm9keS5zZXRNYXNzID0gZnVuY3Rpb24oYm9keSwgbWFzcykge1xuICAgICAgICBib2R5Lm1hc3MgPSBtYXNzO1xuICAgICAgICBib2R5LmludmVyc2VNYXNzID0gMSAvIGJvZHkubWFzcztcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gYm9keS5tYXNzIC8gYm9keS5hcmVhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LiBNYXNzIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICogQG1ldGhvZCBzZXREZW5zaXR5XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldERlbnNpdHkgPSBmdW5jdGlvbihib2R5LCBkZW5zaXR5KSB7XG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBkZW5zaXR5ICogYm9keS5hcmVhKTtcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKGkuZS4gc2Vjb25kIG1vbWVudCBvZiBhcmVhKSBvZiB0aGUgYm9keSBvZiB0aGUgYm9keS4gXG4gICAgICogSW52ZXJzZSBpbmVydGlhIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuIE1hc3MgaXMgbm90IGNoYW5nZWQuXG4gICAgICogQG1ldGhvZCBzZXRJbmVydGlhXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZXJ0aWFcbiAgICAgKi9cbiAgICBCb2R5LnNldEluZXJ0aWEgPSBmdW5jdGlvbihib2R5LCBpbmVydGlhKSB7XG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IGluZXJ0aWE7XG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5J3MgdmVydGljZXMgYW5kIHVwZGF0ZXMgYm9keSBwcm9wZXJ0aWVzIGFjY29yZGluZ2x5LCBpbmNsdWRpbmcgaW5lcnRpYSwgYXJlYSBhbmQgbWFzcyAod2l0aCByZXNwZWN0IHRvIGBib2R5LmRlbnNpdHlgKS5cbiAgICAgKiBWZXJ0aWNlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgdG8gYmUgb3JpZW50YXRlZCBhcm91bmQgdGhlaXIgY2VudHJlIG9mIG1hc3MgYXMgdGhlIG9yaWdpbi5cbiAgICAgKiBUaGV5IGFyZSB0aGVuIGF1dG9tYXRpY2FsbHkgdHJhbnNsYXRlZCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBgYm9keS5wb3NpdGlvbmAuXG4gICAgICpcbiAgICAgKiBUaGUgYHZlcnRpY2VzYCBhcmd1bWVudCBzaG91bGQgYmUgcGFzc2VkIGFzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgKG9yIGEgYE1hdHRlci5WZXJ0aWNlc2AgYXJyYXkpLlxuICAgICAqIFZlcnRpY2VzIG11c3QgZm9ybSBhIGNvbnZleCBodWxsLCBjb25jYXZlIGh1bGxzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRWZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yW119IHZlcnRpY2VzXG4gICAgICovXG4gICAgQm9keS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uKGJvZHksIHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIGNoYW5nZSB2ZXJ0aWNlc1xuICAgICAgICBpZiAodmVydGljZXNbMF0uYm9keSA9PT0gYm9keSkge1xuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNyZWF0ZSh2ZXJ0aWNlcywgYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcHJvcGVydGllc1xuICAgICAgICBib2R5LmF4ZXMgPSBBeGVzLmZyb21WZXJ0aWNlcyhib2R5LnZlcnRpY2VzKTtcbiAgICAgICAgYm9keS5hcmVhID0gVmVydGljZXMuYXJlYShib2R5LnZlcnRpY2VzKTtcbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIGJvZHkuZGVuc2l0eSAqIGJvZHkuYXJlYSk7XG5cbiAgICAgICAgLy8gb3JpZW50IHZlcnRpY2VzIGFyb3VuZCB0aGUgY2VudHJlIG9mIG1hc3MgYXQgb3JpZ2luICgwLCAwKVxuICAgICAgICB2YXIgY2VudHJlID0gVmVydGljZXMuY2VudHJlKGJvZHkudmVydGljZXMpO1xuICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUoYm9keS52ZXJ0aWNlcywgY2VudHJlLCAtMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgd2hpbGUgdmVydGljZXMgYXJlIGF0IG9yaWdpbiAoMCwgMClcbiAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIEJvZHkuX2luZXJ0aWFTY2FsZSAqIFZlcnRpY2VzLmluZXJ0aWEoYm9keS52ZXJ0aWNlcywgYm9keS5tYXNzKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGdlb21ldHJ5XG4gICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgQm91bmRzLnVwZGF0ZShib2R5LmJvdW5kcywgYm9keS52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhcnRzIG9mIHRoZSBgYm9keWAgYW5kIHVwZGF0ZXMgbWFzcywgaW5lcnRpYSBhbmQgY2VudHJvaWQuXG4gICAgICogRWFjaCBwYXJ0IHdpbGwgaGF2ZSBpdHMgcGFyZW50IHNldCB0byBgYm9keWAuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgY29udmV4IGh1bGwgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGFuZCBzZXQgb24gYGJvZHlgLCB1bmxlc3MgYGF1dG9IdWxsYCBpcyBzZXQgdG8gYGZhbHNlLmBcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZmlyc3QgcGFydCBpbiBgYm9keS5wYXJ0c2Agd2lsbCBhbHdheXMgYmUgdGhlIGBib2R5YC5cbiAgICAgKiBAbWV0aG9kIHNldFBhcnRzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIFtib2R5XSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2F1dG9IdWxsPXRydWVdXG4gICAgICovXG4gICAgQm9keS5zZXRQYXJ0cyA9IGZ1bmN0aW9uKGJvZHksIHBhcnRzLCBhdXRvSHVsbCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBhZGQgYWxsIHRoZSBwYXJ0cywgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3QgcGFydCBpcyBhbHdheXMgdGhlIHBhcmVudCBib2R5XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgIGJvZHkucGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgYm9keS5wYXJ0cy5wdXNoKGJvZHkpO1xuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IGJvZHkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnBhcmVudCA9IGJvZHk7XG4gICAgICAgICAgICAgICAgYm9keS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF1dG9IdWxsID0gdHlwZW9mIGF1dG9IdWxsICE9PSAndW5kZWZpbmVkJyA/IGF1dG9IdWxsIDogdHJ1ZTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBjb252ZXggaHVsbCBvZiBhbGwgcGFydHMgdG8gc2V0IG9uIHRoZSBwYXJlbnQgYm9keVxuICAgICAgICBpZiAoYXV0b0h1bGwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQocGFydHNbaV0udmVydGljZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcblxuICAgICAgICAgICAgdmFyIGh1bGwgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICBodWxsQ2VudHJlID0gVmVydGljZXMuY2VudHJlKGh1bGwpO1xuXG4gICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIGh1bGwpO1xuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGh1bGxDZW50cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgdmFyIHRvdGFsID0gX3RvdGFsUHJvcGVydGllcyhib2R5KTtcblxuICAgICAgICBib2R5LmFyZWEgPSB0b3RhbC5hcmVhO1xuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueCA9IHRvdGFsLmNlbnRyZS54O1xuICAgICAgICBib2R5LnBvc2l0aW9uLnkgPSB0b3RhbC5jZW50cmUueTtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IHRvdGFsLmNlbnRyZS54O1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gdG90YWwuY2VudHJlLnk7XG5cbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHRvdGFsLm1hc3MpO1xuICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdG90YWwuaW5lcnRpYSk7XG4gICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwgdG90YWwuY2VudHJlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgaW5zdGFudGx5LiBWZWxvY2l0eSwgYW5nbGUsIGZvcmNlIGV0Yy4gYXJlIHVuY2hhbmdlZC5cbiAgICAgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQm9keS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IFZlY3Rvci5zdWIocG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ICs9IGRlbHRhLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgKz0gZGVsdGEueTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCArPSBkZWx0YS54O1xuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGRlbHRhLnk7XG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgZGVsdGEpO1xuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW5nbGUgb2YgdGhlIGJvZHkgaW5zdGFudGx5LiBBbmd1bGFyIHZlbG9jaXR5LCBwb3NpdGlvbiwgZm9yY2UgZXRjLiBhcmUgdW5jaGFuZ2VkLlxuICAgICAqIEBtZXRob2Qgc2V0QW5nbGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBCb2R5LnNldEFuZ2xlID0gZnVuY3Rpb24oYm9keSwgYW5nbGUpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gYW5nbGUgLSBib2R5LmFuZ2xlO1xuICAgICAgICBib2R5LmFuZ2xlUHJldiArPSBkZWx0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcbiAgICAgICAgICAgIHBhcnQuYW5nbGUgKz0gZGVsdGE7XG4gICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgZGVsdGEsIGJvZHkucG9zaXRpb24pO1xuICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBkZWx0YSk7XG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIFZlY3Rvci5yb3RhdGVBYm91dChwYXJ0LnBvc2l0aW9uLCBkZWx0YSwgYm9keS5wb3NpdGlvbiwgcGFydC5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBib2R5IGluc3RhbnRseS4gUG9zaXRpb24sIGFuZ2xlLCBmb3JjZSBldGMuIGFyZSB1bmNoYW5nZWQuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxuICAgICAqIEBtZXRob2Qgc2V0VmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldFZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSwgdmVsb2NpdHkpIHtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueCAtIHZlbG9jaXR5Lng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnkgLSB2ZWxvY2l0eS55O1xuICAgICAgICBib2R5LnZlbG9jaXR5LnggPSB2ZWxvY2l0eS54O1xuICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSB2ZWxvY2l0eS55O1xuICAgICAgICBib2R5LnNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShib2R5LnZlbG9jaXR5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSBpbnN0YW50bHkuIFBvc2l0aW9uLCBhbmdsZSwgZm9yY2UgZXRjLiBhcmUgdW5jaGFuZ2VkLiBTZWUgYWxzbyBgQm9keS5hcHBseUZvcmNlYC5cbiAgICAgKiBAbWV0aG9kIHNldEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eVxuICAgICAqL1xuICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSwgdmVsb2NpdHkpIHtcbiAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlIC0gdmVsb2NpdHk7XG4gICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gTWF0aC5hYnMoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGJvZHkgYnkgYSBnaXZlbiB2ZWN0b3IgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb24sIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIEJvZHkudHJhbnNsYXRlID0gZnVuY3Rpb24oYm9keSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCBWZWN0b3IuYWRkKGJvZHkucG9zaXRpb24sIHRyYW5zbGF0aW9uKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYSBib2R5IGJ5IGEgZ2l2ZW4gYW5nbGUgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgYW5nbGUsIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSBhbmd1bGFyIHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICovXG4gICAgQm9keS5yb3RhdGUgPSBmdW5jdGlvbihib2R5LCByb3RhdGlvbikge1xuICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIGJvZHkuYW5nbGUgKyByb3RhdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgYm9keSwgaW5jbHVkaW5nIHVwZGF0aW5nIHBoeXNpY2FsIHByb3BlcnRpZXMgKG1hc3MsIGFyZWEsIGF4ZXMsIGluZXJ0aWEpLCBmcm9tIGEgd29ybGQtc3BhY2UgcG9pbnQgKGRlZmF1bHQgaXMgYm9keSBjZW50cmUpLlxuICAgICAqIEBtZXRob2Qgc2NhbGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbcG9pbnRdXG4gICAgICovXG4gICAgQm9keS5zY2FsZSA9IGZ1bmN0aW9uKGJvZHksIHNjYWxlWCwgc2NhbGVZLCBwb2ludCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcblxuICAgICAgICAgICAgLy8gc2NhbGUgdmVydGljZXNcbiAgICAgICAgICAgIFZlcnRpY2VzLnNjYWxlKHBhcnQudmVydGljZXMsIHNjYWxlWCwgc2NhbGVZLCBib2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHBhcnQuYXhlcyA9IEF4ZXMuZnJvbVZlcnRpY2VzKHBhcnQudmVydGljZXMpO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmFyZWEgPSBWZXJ0aWNlcy5hcmVhKHBhcnQudmVydGljZXMpO1xuICAgICAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhwYXJ0LCBib2R5LmRlbnNpdHkgKiBwYXJ0LmFyZWEpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgKHJlcXVpcmVzIHZlcnRpY2VzIHRvIGJlIGF0IG9yaWdpbilcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgeyB4OiAtcGFydC5wb3NpdGlvbi54LCB5OiAtcGFydC5wb3NpdGlvbi55IH0pO1xuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShwYXJ0LCBWZXJ0aWNlcy5pbmVydGlhKHBhcnQudmVydGljZXMsIHBhcnQubWFzcykpO1xuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCB7IHg6IHBhcnQucG9zaXRpb24ueCwgeTogcGFydC5wb3NpdGlvbi55IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm91bmRzXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBjaXJjbGVzXG4gICAgICAgIGlmIChib2R5LmNpcmNsZVJhZGl1cykgeyBcbiAgICAgICAgICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xuICAgICAgICAgICAgICAgIGJvZHkuY2lyY2xlUmFkaXVzICo9IHNjYWxlWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYm9keSBpcyBubyBsb25nZXIgYSBjaXJjbGVcbiAgICAgICAgICAgICAgICBib2R5LmNpcmNsZVJhZGl1cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJvZHkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IF90b3RhbFByb3BlcnRpZXMoYm9keSk7XG4gICAgICAgICAgICBib2R5LmFyZWEgPSB0b3RhbC5hcmVhO1xuICAgICAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHRvdGFsLm1hc3MpO1xuICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIHRvdGFsLmluZXJ0aWEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2ltdWxhdGlvbiBzdGVwIGZvciB0aGUgZ2l2ZW4gYGJvZHlgLCBpbmNsdWRpbmcgdXBkYXRpbmcgcG9zaXRpb24gYW5kIGFuZ2xlIHVzaW5nIFZlcmxldCBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvcnJlY3Rpb25cbiAgICAgKi9cbiAgICBCb2R5LnVwZGF0ZSA9IGZ1bmN0aW9uKGJvZHksIGRlbHRhVGltZSwgdGltZVNjYWxlLCBjb3JyZWN0aW9uKSB7XG4gICAgICAgIHZhciBkZWx0YVRpbWVTcXVhcmVkID0gTWF0aC5wb3coZGVsdGFUaW1lICogdGltZVNjYWxlICogYm9keS50aW1lU2NhbGUsIDIpO1xuXG4gICAgICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgICAgdmFyIGZyaWN0aW9uQWlyID0gMSAtIGJvZHkuZnJpY3Rpb25BaXIgKiB0aW1lU2NhbGUgKiBib2R5LnRpbWVTY2FsZSxcbiAgICAgICAgICAgIHZlbG9jaXR5UHJldlggPSBib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54LFxuICAgICAgICAgICAgdmVsb2NpdHlQcmV2WSA9IGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2Lnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9ICh2ZWxvY2l0eVByZXZYICogZnJpY3Rpb25BaXIgKiBjb3JyZWN0aW9uKSArIChib2R5LmZvcmNlLnggLyBib2R5Lm1hc3MpICogZGVsdGFUaW1lU3F1YXJlZDtcbiAgICAgICAgYm9keS52ZWxvY2l0eS55ID0gKHZlbG9jaXR5UHJldlkgKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkuZm9yY2UueSAvIGJvZHkubWFzcykgKiBkZWx0YVRpbWVTcXVhcmVkO1xuXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnk7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBib2R5LnZlbG9jaXR5Lng7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFuZ3VsYXIgdmVsb2NpdHkgd2l0aCBWZXJsZXQgaW50ZWdyYXRpb25cbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSAoKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgKiBmcmljdGlvbkFpciAqIGNvcnJlY3Rpb24pICsgKGJvZHkudG9ycXVlIC8gYm9keS5pbmVydGlhKSAqIGRlbHRhVGltZVNxdWFyZWQ7XG4gICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZTtcbiAgICAgICAgYm9keS5hbmdsZSArPSBib2R5LmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgICAgICAvLyB0cmFjayBzcGVlZCBhbmQgYWNjZWxlcmF0aW9uXG4gICAgICAgIGJvZHkuc3BlZWQgPSBWZWN0b3IubWFnbml0dWRlKGJvZHkudmVsb2NpdHkpO1xuICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IE1hdGguYWJzKGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG5cbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkudmVsb2NpdHkueDtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgKz0gYm9keS52ZWxvY2l0eS55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9keS5hbmd1bGFyVmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgYm9keS5hbmd1bGFyVmVsb2NpdHksIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGZvcmNlIHRvIGEgYm9keSBmcm9tIGEgZ2l2ZW4gd29ybGQtc3BhY2UgcG9zaXRpb24sIGluY2x1ZGluZyByZXN1bHRpbmcgdG9ycXVlLlxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBmb3JjZVxuICAgICAqL1xuICAgIEJvZHkuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uLCBmb3JjZSkge1xuICAgICAgICBib2R5LmZvcmNlLnggKz0gZm9yY2UueDtcbiAgICAgICAgYm9keS5mb3JjZS55ICs9IGZvcmNlLnk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IHBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uLnkgfTtcbiAgICAgICAgYm9keS50b3JxdWUgKz0gb2Zmc2V0LnggKiBmb3JjZS55IC0gb2Zmc2V0LnkgKiBmb3JjZS54O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW1zIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHkuXG4gICAgICogQG1ldGhvZCBfdG90YWxQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt9XG4gICAgICovXG4gICAgdmFyIF90b3RhbFByb3BlcnRpZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZWNvdXJzZXMub3UuZWR1L2NnaS1iaW4vZWJvb2suY2dpP2RvYz0mdG9waWM9c3QmY2hhcF9zZWM9MDcuMiZwYWdlPXRoZW9yeVxuICAgICAgICAvLyBodHRwOi8vb3V0cHV0LnRvL3NpZGV3YXkvZGVmYXVsdC5hc3A/cW5vPTEyMTEwMDA4N1xuXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICAgIGFyZWE6IDAsXG4gICAgICAgICAgICBpbmVydGlhOiAwLFxuICAgICAgICAgICAgY2VudHJlOiB7IHg6IDAsIHk6IDAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN1bSB0aGUgcHJvcGVydGllcyBvZiBhbGwgY29tcG91bmQgcGFydHMgb2YgdGhlIHBhcmVudCBib2R5XG4gICAgICAgIGZvciAodmFyIGkgPSBib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcHJvcGVydGllcy5tYXNzICs9IHBhcnQubWFzcztcbiAgICAgICAgICAgIHByb3BlcnRpZXMuYXJlYSArPSBwYXJ0LmFyZWE7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmluZXJ0aWEgKz0gcGFydC5pbmVydGlhO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jZW50cmUgPSBWZWN0b3IuYWRkKHByb3BlcnRpZXMuY2VudHJlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IubXVsdChwYXJ0LnBvc2l0aW9uLCBwYXJ0Lm1hc3MgIT09IEluZmluaXR5ID8gcGFydC5tYXNzIDogMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5jZW50cmUgPSBWZWN0b3IuZGl2KHByb3BlcnRpZXMuY2VudHJlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMubWFzcyAhPT0gSW5maW5pdHkgPyBwcm9wZXJ0aWVzLm1hc3MgOiBib2R5LnBhcnRzLmxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IHN0YXJ0cyBzbGVlcGluZyAod2hlcmUgYHRoaXNgIGlzIHRoZSBib2R5KS5cbiAgICAqXG4gICAgKiBAZXZlbnQgc2xlZXBTdGFydFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIHN0YXJ0ZWQgc2xlZXBpbmdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgYm9keSBlbmRzIHNsZWVwaW5nICh3aGVyZSBgdGhpc2AgaXMgdGhlIGJvZHkpLlxuICAgICpcbiAgICAqIEBldmVudCBzbGVlcEVuZFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIGVuZGVkIHNsZWVwaW5nXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBCb2R5LmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJib2R5XCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkJvZHlcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYm9kaWVzIHRoYXQgbWFrZSB1cCB0aGlzIGJvZHkuIFxuICAgICAqIFRoZSBmaXJzdCBib2R5IGluIHRoZSBhcnJheSBtdXN0IGFsd2F5cyBiZSBhIHNlbGYgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGJvZHkgaW5zdGFuY2UuXG4gICAgICogQWxsIGJvZGllcyBpbiB0aGUgYHBhcnRzYCBhcnJheSB0b2dldGhlciBmb3JtIGEgc2luZ2xlIHJpZ2lkIGNvbXBvdW5kIGJvZHkuXG4gICAgICogUGFydHMgYXJlIGFsbG93ZWQgdG8gb3ZlcmxhcCwgaGF2ZSBnYXBzIG9yIGhvbGVzIG9yIGV2ZW4gZm9ybSBjb25jYXZlIGJvZGllcy5cbiAgICAgKiBQYXJ0cyB0aGVtc2VsdmVzIHNob3VsZCBuZXZlciBiZSBhZGRlZCB0byBhIGBXb3JsZGAsIG9ubHkgdGhlIHBhcmVudCBib2R5IHNob3VsZCBiZS5cbiAgICAgKiBVc2UgYEJvZHkuc2V0UGFydHNgIHdoZW4gc2V0dGluZyBwYXJ0cyB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBhcnRzXG4gICAgICogQHR5cGUgYm9keVtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgc2VsZiByZWZlcmVuY2UgaWYgdGhlIGJvZHkgaXMgX25vdF8gYSBwYXJ0IG9mIGFub3RoZXIgYm9keS5cbiAgICAgKiBPdGhlcndpc2UgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgYm9keSB0aGF0IHRoaXMgaXMgYSBwYXJ0IG9mLlxuICAgICAqIFNlZSBgYm9keS5wYXJ0c2AuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XG4gICAgICogQHR5cGUgYm9keVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCBzcGVjaWZ5aW5nIHRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBWZWN0b3JgIG9iamVjdHMgdGhhdCBzcGVjaWZ5IHRoZSBjb252ZXggaHVsbCBvZiB0aGUgcmlnaWQgYm9keS5cbiAgICAgKiBUaGVzZSBzaG91bGQgYmUgcHJvdmlkZWQgYWJvdXQgdGhlIG9yaWdpbiBgKDAsIDApYC4gRS5nLlxuICAgICAqXG4gICAgICogICAgIFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XVxuICAgICAqXG4gICAgICogV2hlbiBwYXNzZWQgdmlhIGBCb2R5LmNyZWF0ZWAsIHRoZSB2ZXJ0aWNlcyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byBgYm9keS5wb3NpdGlvbmAgKGkuZS4gd29ybGQtc3BhY2UsIGFuZCBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgc2ltdWxhdGlvbikuXG4gICAgICogVGhlIGBWZWN0b3JgIG9iamVjdHMgYXJlIGFsc28gYXVnbWVudGVkIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIGZvciBlZmZpY2llbnQgY29sbGlzaW9uIGRldGVjdGlvbi4gXG4gICAgICpcbiAgICAgKiBPdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgYGluZXJ0aWFgIGFuZCBgYm91bmRzYCBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIHBhc3NlZCB2ZXJ0aWNlcyAodW5sZXNzIHByb3ZpZGVkIHZpYSBgb3B0aW9uc2ApLlxuICAgICAqIENvbmNhdmUgaHVsbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLiBUaGUgbW9kdWxlIGBNYXR0ZXIuVmVydGljZXNgIGNvbnRhaW5zIHVzZWZ1bCBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggdmVydGljZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB2ZWN0b3JbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBmb3JjZSB0byBhcHBseSBpbiB0aGUgY3VycmVudCBzdGVwLiBJdCBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEJvZHkudXBkYXRlYC4gU2VlIGFsc28gYEJvZHkuYXBwbHlGb3JjZWAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdG9ycXVlICh0dXJuaW5nIGZvcmNlKSB0byBhcHBseSBpbiB0aGUgY3VycmVudCBzdGVwLiBJdCBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEJvZHkudXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0b3JxdWVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBzcGVlZCBvZiB0aGUgYm9keSBhZnRlciB0aGUgbGFzdCBgQm9keS51cGRhdGVgLiBJdCBpcyByZWFkLW9ubHkgYW5kIGFsd2F5cyBwb3NpdGl2ZSAoaXQncyB0aGUgbWFnbml0dWRlIG9mIGBib2R5LnZlbG9jaXR5YCkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgc3BlZWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgY3VycmVudCBhbmd1bGFyIHNwZWVkIG9mIHRoZSBib2R5IGFmdGVyIHRoZSBsYXN0IGBCb2R5LnVwZGF0ZWAuIEl0IGlzIHJlYWQtb25seSBhbmQgYWx3YXlzIHBvc2l0aXZlIChpdCdzIHRoZSBtYWduaXR1ZGUgb2YgYGJvZHkuYW5ndWxhclZlbG9jaXR5YCkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclNwZWVkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IF9tZWFzdXJlc18gdGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBtb2RpZnkgYSBib2R5J3MgdmVsb2NpdHkgZGlyZWN0bHksIHlvdSBzaG91bGQgZWl0aGVyIGFwcGx5IGEgZm9yY2Ugb3Igc2ltcGx5IGNoYW5nZSB0aGUgYm9keSdzIGBwb3NpdGlvbmAgKGFzIHRoZSBlbmdpbmUgdXNlcyBwb3NpdGlvbi1WZXJsZXQgaW50ZWdyYXRpb24pLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBfbWVhc3VyZXNfIHRoZSBjdXJyZW50IGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkgYWZ0ZXIgdGhlIGxhc3QgYEJvZHkudXBkYXRlYC4gSXQgaXMgcmVhZC1vbmx5LiBcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBtb2RpZnkgYSBib2R5J3MgYW5ndWxhciB2ZWxvY2l0eSBkaXJlY3RseSwgeW91IHNob3VsZCBhcHBseSBhIHRvcnF1ZSBvciBzaW1wbHkgY2hhbmdlIHRoZSBib2R5J3MgYGFuZ2xlYCAoYXMgdGhlIGVuZ2luZSB1c2VzIHBvc2l0aW9uLVZlcmxldCBpbnRlZ3JhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBib2R5IGlzIGNvbnNpZGVyZWQgc3RhdGljLiBBIHN0YXRpYyBib2R5IGNhbiBuZXZlciBjaGFuZ2UgcG9zaXRpb24gb3IgYW5nbGUgYW5kIGlzIGNvbXBsZXRlbHkgZml4ZWQuXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2V0IGEgYm9keSBhcyBzdGF0aWMgYWZ0ZXIgaXRzIGNyZWF0aW9uLCB5b3Ugc2hvdWxkIHVzZSBgQm9keS5zZXRTdGF0aWNgIGFzIHRoaXMgcmVxdWlyZXMgbW9yZSB0aGFuIGp1c3Qgc2V0dGluZyB0aGlzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNTdGF0aWNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYm9keSBpcyBhIHNlbnNvci4gU2Vuc29yIHRyaWdnZXJzIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBkb2Vzbid0IHJlYWN0IHdpdGggY29sbGlkaW5nIGJvZHkgcGh5c2ljYWxseS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc1NlbnNvclxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcGluZy4gQSBzbGVlcGluZyBib2R5IGFjdHMgc2ltaWxhciB0byBhIHN0YXRpYyBib2R5LCBleGNlcHQgaXQgaXMgb25seSB0ZW1wb3JhcnkgYW5kIGNhbiBiZSBhd29rZW4uXG4gICAgICogSWYgeW91IG5lZWQgdG8gc2V0IGEgYm9keSBhcyBzbGVlcGluZywgeW91IHNob3VsZCB1c2UgYFNsZWVwaW5nLnNldGAgYXMgdGhpcyByZXF1aXJlcyBtb3JlIHRoYW4ganVzdCBzZXR0aW5nIHRoaXMgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc1NsZWVwaW5nXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgX21lYXN1cmVzXyB0aGUgYW1vdW50IG9mIG1vdmVtZW50IGEgYm9keSBjdXJyZW50bHkgaGFzIChhIGNvbWJpbmF0aW9uIG9mIGBzcGVlZGAgYW5kIGBhbmd1bGFyU3BlZWRgKS4gSXQgaXMgcmVhZC1vbmx5IGFuZCBhbHdheXMgcG9zaXRpdmUuXG4gICAgICogSXQgaXMgdXNlZCBhbmQgdXBkYXRlZCBieSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIGR1cmluZyBzaW11bGF0aW9uIHRvIGRlY2lkZSBpZiBhIGJvZHkgaGFzIGNvbWUgdG8gcmVzdC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBtb3Rpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIHVwZGF0ZXMgaW4gd2hpY2ggdGhpcyBib2R5IG11c3QgaGF2ZSBuZWFyLXplcm8gdmVsb2NpdHkgYmVmb3JlIGl0IGlzIHNldCBhcyBzbGVlcGluZyBieSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIChpZiBzbGVlcGluZyBpcyBlbmFibGVkIGJ5IHRoZSBlbmdpbmUpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGhyZXNob2xkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgNjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LCB0aGF0IGlzIGl0cyBtYXNzIHBlciB1bml0IGFyZWEuXG4gICAgICogSWYgeW91IHBhc3MgdGhlIGRlbnNpdHkgdmlhIGBCb2R5LmNyZWF0ZWAgdGhlIGBtYXNzYCBwcm9wZXJ0eSBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZm9yIHlvdSBiYXNlZCBvbiB0aGUgc2l6ZSAoYXJlYSkgb2YgdGhlIG9iamVjdC5cbiAgICAgKiBUaGlzIGlzIGdlbmVyYWxseSBwcmVmZXJhYmxlIHRvIHNpbXBseSBzZXR0aW5nIG1hc3MgYW5kIGFsbG93cyBmb3IgbW9yZSBpbnR1aXRpdmUgZGVmaW5pdGlvbiBvZiBtYXRlcmlhbHMgKGUuZy4gcm9jayBoYXMgYSBoaWdoZXIgZGVuc2l0eSB0aGFuIHdvb2QpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRlbnNpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG1hc3Mgb2YgdGhlIGJvZHksIGFsdGhvdWdoIGl0IG1heSBiZSBtb3JlIGFwcHJvcHJpYXRlIHRvIHNwZWNpZnkgdGhlIGBkZW5zaXR5YCBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgICAqIElmIHlvdSBtb2RpZnkgdGhpcyB2YWx1ZSwgeW91IG11c3QgYWxzbyBtb2RpZnkgdGhlIGBib2R5LmludmVyc2VNYXNzYCBwcm9wZXJ0eSAoYDEgLyBtYXNzYCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keSAoYDEgLyBtYXNzYCkuXG4gICAgICogSWYgeW91IG1vZGlmeSB0aGlzIHZhbHVlLCB5b3UgbXVzdCBhbHNvIG1vZGlmeSB0aGUgYGJvZHkubWFzc2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZU1hc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBtb21lbnQgb2YgaW5lcnRpYSAoaS5lLiBzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBib2R5LlxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgYW5kIGRlbnNpdHkgaW4gYEJvZHkuY3JlYXRlYC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbnZlcnNlSW5lcnRpYWAgcHJvcGVydHkgKGAxIC8gaW5lcnRpYWApLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5IChgMSAvIGluZXJ0aWFgKS5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5IHRoaXMgdmFsdWUsIHlvdSBtdXN0IGFsc28gbW9kaWZ5IHRoZSBgYm9keS5pbmVydGlhYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlSW5lcnRpYVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHJlc3RpdHV0aW9uIChlbGFzdGljaXR5KSBvZiB0aGUgYm9keS4gVGhlIHZhbHVlIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGAoMCwgMSlgLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIGNvbGxpc2lvbnMgbWF5IGJlIHBlcmZlY3RseSBpbmVsYXN0aWMgYW5kIG5vIGJvdW5jaW5nIG1heSBvY2N1ci4gXG4gICAgICogQSB2YWx1ZSBvZiBgMC44YCBtZWFucyB0aGUgYm9keSBtYXkgYm91bmNlIGJhY2sgd2l0aCBhcHByb3hpbWF0ZWx5IDgwJSBvZiBpdHMga2luZXRpYyBlbmVyZ3kuXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYHJlc3RpdHV0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XG4gICAgICpcbiAgICAgKiAgICAgTWF0aC5tYXgoYm9keUEucmVzdGl0dXRpb24sIGJvZHlCLnJlc3RpdHV0aW9uKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGZyaWN0aW9uIG9mIHRoZSBib2R5LiBUaGUgdmFsdWUgaXMgYWx3YXlzIHBvc2l0aXZlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYCgwLCAxKWAuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgdGhhdCB0aGUgYm9keSBtYXkgc2xpZGUgaW5kZWZpbml0ZWx5LlxuICAgICAqIEEgdmFsdWUgb2YgYDFgIG1lYW5zIHRoZSBib2R5IG1heSBjb21lIHRvIGEgc3RvcCBhbG1vc3QgaW5zdGFudGx5IGFmdGVyIGEgZm9yY2UgaXMgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3RzIG9mIHRoZSB2YWx1ZSBtYXkgYmUgbm9uLWxpbmVhci4gXG4gICAgICogSGlnaCB2YWx1ZXMgbWF5IGJlIHVuc3RhYmxlIGRlcGVuZGluZyBvbiB0aGUgYm9keS5cbiAgICAgKiBUaGUgZW5naW5lIHVzZXMgYSBDb3Vsb21iIGZyaWN0aW9uIG1vZGVsIGluY2x1ZGluZyBzdGF0aWMgYW5kIGtpbmV0aWMgZnJpY3Rpb24uXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYGZyaWN0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XG4gICAgICpcbiAgICAgKiAgICAgTWF0aC5taW4oYm9keUEuZnJpY3Rpb24sIGJvZHlCLmZyaWN0aW9uKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgc3RhdGljIGZyaWN0aW9uIG9mIHRoZSBib2R5IChpbiB0aGUgQ291bG9tYiBmcmljdGlvbiBtb2RlbCkuIFxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgJ3N0aWNrJyB3aGVuIGl0IGlzIG5lYXJseSBzdGF0aW9uYXJ5IGFuZCBvbmx5IGR5bmFtaWMgYGZyaWN0aW9uYCBpcyB1c2VkLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlIChlLmcuIGAxMGApLCB0aGUgbW9yZSBmb3JjZSBpdCB3aWxsIHRha2UgdG8gaW5pdGlhbGx5IGdldCB0aGUgYm9keSBtb3Zpbmcgd2hlbiBuZWFybHkgc3RhdGlvbmFyeS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgYGZyaWN0aW9uYCBwcm9wZXJ0eSB0byBtYWtlIGl0IGVhc2llciB0byBjaGFuZ2UgYGZyaWN0aW9uYCBhbmQgbWFpbnRhaW4gYW4gYXBwcm9wcmlhdGUgYW1vdW50IG9mIHN0YXRpYyBmcmljdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0YXRpY1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGFpciBmcmljdGlvbiBvZiB0aGUgYm9keSAoYWlyIHJlc2lzdGFuY2UpLiBcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGUgYm9keSB3aWxsIG5ldmVyIHNsb3cgYXMgaXQgbW92ZXMgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGZhc3RlciBhIGJvZHkgc2xvd3Mgd2hlbiBtb3ZpbmcgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgZWZmZWN0cyBvZiB0aGUgdmFsdWUgYXJlIG5vbi1saW5lYXIuIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQWlyXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBmaWx0ZXJpbmcgcHJvcGVydGllcyBvZiB0aGlzIGJvZHkuXG4gICAgICpcbiAgICAgKiBDb2xsaXNpb25zIGJldHdlZW4gdHdvIGJvZGllcyB3aWxsIG9iZXkgdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgdGhlIHNhbWUgbm9uLXplcm8gdmFsdWUgb2YgYGNvbGxpc2lvbkZpbHRlci5ncm91cGAsXG4gICAgICogICB0aGV5IHdpbGwgYWx3YXlzIGNvbGxpZGUgaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlLCBhbmQgdGhleSB3aWxsIG5ldmVyIGNvbGxpZGVcbiAgICAgKiAgIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBvZiBgY29sbGlzaW9uRmlsdGVyLmdyb3VwYCBvciBpZiBvbmVcbiAgICAgKiAgIChvciBib3RoKSBvZiB0aGUgYm9kaWVzIGhhcyBhIHZhbHVlIG9mIDAsIHRoZW4gdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMgYXBwbHkgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIEVhY2ggYm9keSBiZWxvbmdzIHRvIGEgY29sbGlzaW9uIGNhdGVnb3J5LCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5YC4gVGhpc1xuICAgICAqIHZhbHVlIGlzIHVzZWQgYXMgYSBiaXQgZmllbGQgYW5kIHRoZSBjYXRlZ29yeSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBtZWFuaW5nIHRoYXRcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBhIHBvd2VyIG9mIHR3byBpbiB0aGUgcmFuZ2UgWzEsIDJeMzFdLiBUaHVzLCB0aGVyZSBhcmUgMzJcbiAgICAgKiBkaWZmZXJlbnQgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogRWFjaCBib2R5IGFsc28gZGVmaW5lcyBhIGNvbGxpc2lvbiBiaXRtYXNrLCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLm1hc2tgIHdoaWNoIHNwZWNpZmllc1xuICAgICAqIHRoZSBjYXRlZ29yaWVzIGl0IGNvbGxpZGVzIHdpdGggKHRoZSB2YWx1ZSBpcyB0aGUgYml0d2lzZSBBTkQgdmFsdWUgb2YgYWxsIHRoZXNlIGNhdGVnb3JpZXMpLlxuICAgICAqXG4gICAgICogVXNpbmcgdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMsIHR3byBib2RpZXMgYEFgIGFuZCBgQmAgY29sbGlkZSBpZiBlYWNoIGluY2x1ZGVzIHRoZSBvdGhlcidzXG4gICAgICogY2F0ZWdvcnkgaW4gaXRzIG1hc2ssIGkuZS4gYChjYXRlZ29yeUEgJiBtYXNrQikgIT09IDBgIGFuZCBgKGNhdGVnb3J5QiAmIG1hc2tBKSAhPT0gMGBcbiAgICAgKiBhcmUgYm90aCB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gSW50ZWdlciBgTnVtYmVyYCwgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBncm91cCB0aGlzIGJvZHkgYmVsb25ncyB0by5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXIuZ3JvdXBcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGJpdCBmaWVsZCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGNhdGVnb3J5IHRoaXMgYm9keSBiZWxvbmdzIHRvLlxuICAgICAqIFRoZSBjYXRlZ29yeSB2YWx1ZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBmb3IgZXhhbXBsZSBgMHgwMDAxYC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoZXJlIGFyZSB1cCB0byAzMiB1bmlxdWUgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5jYXRlZ29yeVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYml0IG1hc2sgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBjYXRlZ29yaWVzIHRoaXMgYm9keSBtYXkgY29sbGlkZSB3aXRoLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5tYXNrXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgYSB0b2xlcmFuY2Ugb24gaG93IGZhciBhIGJvZHkgaXMgYWxsb3dlZCB0byAnc2luaycgb3Igcm90YXRlIGludG8gb3RoZXIgYm9kaWVzLlxuICAgICAqIEF2b2lkIGNoYW5naW5nIHRoaXMgdmFsdWUgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIHRoZSBwdXJwb3NlIG9mIGBzbG9wYCBpbiBwaHlzaWNzIGVuZ2luZXMuXG4gICAgICogVGhlIGRlZmF1bHQgc2hvdWxkIGdlbmVyYWxseSBzdWZmaWNlLCBhbHRob3VnaCB2ZXJ5IGxhcmdlIGJvZGllcyBtYXkgcmVxdWlyZSBsYXJnZXIgdmFsdWVzIGZvciBzdGFibGUgc3RhY2tpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2xvcFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuMDVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBhbGxvd3MgcGVyLWJvZHkgdGltZSBzY2FsaW5nLCBlLmcuIGEgZm9yY2UtZmllbGQgd2hlcmUgYm9kaWVzIGluc2lkZSBhcmUgaW4gc2xvdy1tb3Rpb24sIHdoaWxlIG90aGVycyBhcmUgYXQgZnVsbCBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lU2NhbGVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBib2R5IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIub3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSBzcHJpdGUgcHJvcGVydGllcyB0byB1c2Ugd2hlbiByZW5kZXJpbmcsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgc3ByaXRlIHRleHR1cmUsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnRleHR1cmVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHgtYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueFNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSB3aWR0aCkuXG4gICAgICAqXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnhPZmZzZXRcbiAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICovXG5cbiAgICAgLyoqXG4gICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSAobm9ybWFsaXNlZCBieSB0ZXh0dXJlIGhlaWdodCkuXG4gICAgICAqXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnlPZmZzZXRcbiAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbGluZSB3aWR0aCB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIubGluZVdpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMS41XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgKGlmIGEgc3ByaXRlIGlzIG5vdCBkZWZpbmVkKS5cbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmZpbGxTdHlsZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IGEgcmFuZG9tIGNvbG91clxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3Ryb2tlU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHVuaXF1ZSBheGlzIHZlY3RvcnMgKGVkZ2Ugbm9ybWFscykgdXNlZCBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAgICAgKiBUaGVzZSBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlIGdpdmVuIGNvbnZleCBodWxsIChgdmVydGljZXNgIGFycmF5KSBpbiBgQm9keS5jcmVhdGVgLlxuICAgICAqIFRoZXkgYXJlIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBheGVzXG4gICAgICogQHR5cGUgdmVjdG9yW11cbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IF9tZWFzdXJlc18gdGhlIGFyZWEgb2YgdGhlIGJvZHkncyBjb252ZXggaHVsbCwgY2FsY3VsYXRlZCBhdCBjcmVhdGlvbiBieSBgQm9keS5jcmVhdGVgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFyZWFcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgQUFCQiByZWdpb24gZm9yIHRoZSBib2R5LlxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIHRoZSBnaXZlbiBjb252ZXggaHVsbCAoYHZlcnRpY2VzYCBhcnJheSkgaW4gYEJvZHkuY3JlYXRlYCBhbmQgY29uc3RhbnRseSB1cGRhdGVkIGJ5IGBCb2R5LnVwZGF0ZWAgZHVyaW5nIHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgYm91bmRzXG4gICAgICovXG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9ib2R5L0JvZHkuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2JvZHkvQm9keS5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Db25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb25zdHJhaW50cy5cbiogQ29uc3RyYWludHMgYXJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgdGhhdCBhIGZpeGVkIGRpc3RhbmNlIG11c3QgYmUgbWFpbnRhaW5lZCBiZXR3ZWVuIHR3byBib2RpZXMgKG9yIGEgYm9keSBhbmQgYSBmaXhlZCB3b3JsZC1zcGFjZSBwb3NpdGlvbikuXG4qIFRoZSBzdGlmZm5lc3Mgb2YgY29uc3RyYWludHMgY2FuIGJlIG1vZGlmaWVkIHRvIGNyZWF0ZSBzcHJpbmdzIG9yIGVsYXN0aWMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb25zdHJhaW50XG4qL1xuXG4vLyBUT0RPOiBmaXggaW5zdGFiaWxpdHkgaXNzdWVzIHdpdGggdG9ycXVlXG4vLyBUT0RPOiBsaW5rZWQgY29uc3RyYWludHNcbi8vIFRPRE86IGJyZWFrYWJsZSBjb25zdHJhaW50c1xuLy8gVE9ETzogY29sbGlzaW9uIGNvbnN0cmFpbnRzXG4vLyBUT0RPOiBhbGxvdyBjb25zdHJhaW5lZCBib2RpZXMgdG8gc2xlZXBcbi8vIFRPRE86IGhhbmRsZSAwIGxlbmd0aCBjb25zdHJhaW50cyBwcm9wZXJseVxuLy8gVE9ETzogaW1wdWxzZSBjYWNoaW5nIGFuZCB3YXJtaW5nXG5cbnZhciBDb25zdHJhaW50ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcbnZhciBTbGVlcGluZyA9IHJlcXVpcmUoJy4uL2NvcmUvU2xlZXBpbmcnKTtcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQXhlcycpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciBfbWluTGVuZ3RoID0gMC4wMDAwMDEsXG4gICAgICAgIF9taW5EaWZmZXJlbmNlID0gMC4wMDE7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnN0cmFpbnQuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICovXG4gICAgQ29uc3RyYWludC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gb3B0aW9ucztcblxuICAgICAgICAvLyBpZiBib2RpZXMgZGVmaW5lZCBidXQgbm8gcG9pbnRzLCB1c2UgYm9keSBjZW50cmVcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUEgJiYgIWNvbnN0cmFpbnQucG9pbnRBKVxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUIgJiYgIWNvbnN0cmFpbnQucG9pbnRCKVxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3RhdGljIGxlbmd0aCB1c2luZyBpbml0aWFsIHdvcmxkIHNwYWNlIHBvaW50c1xuICAgICAgICB2YXIgaW5pdGlhbFBvaW50QSA9IGNvbnN0cmFpbnQuYm9keUEgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKSA6IGNvbnN0cmFpbnQucG9pbnRBLFxuICAgICAgICAgICAgaW5pdGlhbFBvaW50QiA9IGNvbnN0cmFpbnQuYm9keUIgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKSA6IGNvbnN0cmFpbnQucG9pbnRCLFxuICAgICAgICAgICAgbGVuZ3RoID0gVmVjdG9yLm1hZ25pdHVkZShWZWN0b3Iuc3ViKGluaXRpYWxQb2ludEEsIGluaXRpYWxQb2ludEIpKTtcbiAgICBcbiAgICAgICAgY29uc3RyYWludC5sZW5ndGggPSBjb25zdHJhaW50Lmxlbmd0aCB8fCBsZW5ndGggfHwgX21pbkxlbmd0aDtcblxuICAgICAgICAvLyByZW5kZXJcbiAgICAgICAgdmFyIHJlbmRlciA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogJyNmZmZmZmYnXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdHJhaW50LnJlbmRlciA9IENvbW1vbi5leHRlbmQocmVuZGVyLCBjb25zdHJhaW50LnJlbmRlcik7XG5cbiAgICAgICAgLy8gb3B0aW9uIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0cmFpbnQuaWQgPSBjb25zdHJhaW50LmlkIHx8IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgY29uc3RyYWludC5sYWJlbCA9IGNvbnN0cmFpbnQubGFiZWwgfHwgJ0NvbnN0cmFpbnQnO1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSAnY29uc3RyYWludCc7XG4gICAgICAgIGNvbnN0cmFpbnQuc3RpZmZuZXNzID0gY29uc3RyYWludC5zdGlmZm5lc3MgfHwgMTtcbiAgICAgICAgY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzID0gY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzIHx8IDA7XG4gICAgICAgIGNvbnN0cmFpbnQuYW5nbGVBID0gY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEuYW5nbGUgOiBjb25zdHJhaW50LmFuZ2xlQTtcbiAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBjb25zdHJhaW50LmJvZHlCID8gY29uc3RyYWludC5ib2R5Qi5hbmdsZSA6IGNvbnN0cmFpbnQuYW5nbGVCO1xuICAgICAgICBjb25zdHJhaW50LnBsdWdpbiA9IHt9O1xuXG4gICAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTb2x2ZXMgYWxsIGNvbnN0cmFpbnRzIGluIGEgbGlzdCBvZiBjb2xsaXNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzb2x2ZUFsbFxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludFtdfSBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnNvbHZlQWxsID0gZnVuY3Rpb24oY29uc3RyYWludHMsIHRpbWVTY2FsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlKGNvbnN0cmFpbnRzW2ldLCB0aW1lU2NhbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyBhIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzb2x2ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnNvbHZlID0gZnVuY3Rpb24oY29uc3RyYWludCwgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgIHBvaW50QiA9IGNvbnN0cmFpbnQucG9pbnRCO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByZWZlcmVuY2UgYW5nbGVcbiAgICAgICAgaWYgKGJvZHlBICYmICFib2R5QS5pc1N0YXRpYykge1xuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBWZWN0b3Iucm90YXRlKHBvaW50QSwgYm9keUEuYW5nbGUgLSBjb25zdHJhaW50LmFuZ2xlQSk7XG4gICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQSA9IGJvZHlBLmFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgcmVmZXJlbmNlIGFuZ2xlXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0gVmVjdG9yLnJvdGF0ZShwb2ludEIsIGJvZHlCLmFuZ2xlIC0gY29uc3RyYWludC5hbmdsZUIpO1xuICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBib2R5Qi5hbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludEFXb3JsZCA9IHBvaW50QSxcbiAgICAgICAgICAgIHBvaW50QldvcmxkID0gcG9pbnRCO1xuXG4gICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBwb2ludEEpO1xuICAgICAgICBpZiAoYm9keUIpIHBvaW50QldvcmxkID0gVmVjdG9yLmFkZChib2R5Qi5wb3NpdGlvbiwgcG9pbnRCKTtcblxuICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvaW50QVdvcmxkLCBwb2ludEJXb3JsZCksXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gVmVjdG9yLm1hZ25pdHVkZShkZWx0YSk7XG5cbiAgICAgICAgLy8gcHJldmVudCBzaW5ndWxhcml0eVxuICAgICAgICBpZiAoY3VycmVudExlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBfbWluTGVuZ3RoO1xuXG4gICAgICAgIC8vIHNvbHZlIGRpc3RhbmNlIGNvbnN0cmFpbnQgd2l0aCBHYXVzcy1TaWVkZWwgbWV0aG9kXG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gKGN1cnJlbnRMZW5ndGggLSBjb25zdHJhaW50Lmxlbmd0aCkgLyBjdXJyZW50TGVuZ3RoLFxuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLmRpdihkZWx0YSwgY3VycmVudExlbmd0aCksXG4gICAgICAgICAgICBmb3JjZSA9IFZlY3Rvci5tdWx0KGRlbHRhLCBkaWZmZXJlbmNlICogMC41ICogY29uc3RyYWludC5zdGlmZm5lc3MgKiB0aW1lU2NhbGUgKiB0aW1lU2NhbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gaWYgZGlmZmVyZW5jZSBpcyB2ZXJ5IHNtYWxsLCB3ZSBjYW4gc2tpcFxuICAgICAgICBpZiAoTWF0aC5hYnMoMSAtIChjdXJyZW50TGVuZ3RoIC8gY29uc3RyYWludC5sZW5ndGgpKSA8IF9taW5EaWZmZXJlbmNlICogdGltZVNjYWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciB2ZWxvY2l0eVBvaW50QSxcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCLFxuICAgICAgICAgICAgb2Zmc2V0QSxcbiAgICAgICAgICAgIG9mZnNldEIsXG4gICAgICAgICAgICBvQW4sXG4gICAgICAgICAgICBvQm4sXG4gICAgICAgICAgICBib2R5QURlbm9tLFxuICAgICAgICAgICAgYm9keUJEZW5vbTtcbiAgICBcbiAgICAgICAgaWYgKGJvZHlBICYmICFib2R5QS5pc1N0YXRpYykge1xuICAgICAgICAgICAgLy8gcG9pbnQgYm9keSBvZmZzZXRcbiAgICAgICAgICAgIG9mZnNldEEgPSB7IFxuICAgICAgICAgICAgICAgIHg6IHBvaW50QVdvcmxkLnggLSBib2R5QS5wb3NpdGlvbi54ICsgZm9yY2UueCwgXG4gICAgICAgICAgICAgICAgeTogcG9pbnRBV29ybGQueSAtIGJvZHlBLnBvc2l0aW9uLnkgKyBmb3JjZS55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmVsb2NpdHlcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2Lng7XG4gICAgICAgICAgICBib2R5QS52ZWxvY2l0eS55ID0gYm9keUEucG9zaXRpb24ueSAtIGJvZHlBLnBvc2l0aW9uUHJldi55O1xuICAgICAgICAgICAgYm9keUEuYW5ndWxhclZlbG9jaXR5ID0gYm9keUEuYW5nbGUgLSBib2R5QS5hbmdsZVByZXY7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGZpbmQgcG9pbnQgdmVsb2NpdHkgYW5kIGJvZHkgbWFzc1xuICAgICAgICAgICAgdmVsb2NpdHlQb2ludEEgPSBWZWN0b3IuYWRkKGJvZHlBLnZlbG9jaXR5LCBWZWN0b3IubXVsdChWZWN0b3IucGVycChvZmZzZXRBKSwgYm9keUEuYW5ndWxhclZlbG9jaXR5KSk7XG4gICAgICAgICAgICBvQW4gPSBWZWN0b3IuZG90KG9mZnNldEEsIG5vcm1hbCk7XG4gICAgICAgICAgICBib2R5QURlbm9tID0gYm9keUEuaW52ZXJzZU1hc3MgKyBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIG9BbiAqIG9BbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRBID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICBib2R5QURlbm9tID0gYm9keUEgPyBib2R5QS5pbnZlcnNlTWFzcyA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICBpZiAoYm9keUIgJiYgIWJvZHlCLmlzU3RhdGljKSB7XG4gICAgICAgICAgICAvLyBwb2ludCBib2R5IG9mZnNldFxuICAgICAgICAgICAgb2Zmc2V0QiA9IHsgXG4gICAgICAgICAgICAgICAgeDogcG9pbnRCV29ybGQueCAtIGJvZHlCLnBvc2l0aW9uLnggLSBmb3JjZS54LCBcbiAgICAgICAgICAgICAgICB5OiBwb2ludEJXb3JsZC55IC0gYm9keUIucG9zaXRpb24ueSAtIGZvcmNlLnkgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmVsb2NpdHlcbiAgICAgICAgICAgIGJvZHlCLnZlbG9jaXR5LnggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUIucG9zaXRpb25QcmV2Lng7XG4gICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS55ID0gYm9keUIucG9zaXRpb24ueSAtIGJvZHlCLnBvc2l0aW9uUHJldi55O1xuICAgICAgICAgICAgYm9keUIuYW5ndWxhclZlbG9jaXR5ID0gYm9keUIuYW5nbGUgLSBib2R5Qi5hbmdsZVByZXY7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgcG9pbnQgdmVsb2NpdHkgYW5kIGJvZHkgbWFzc1xuICAgICAgICAgICAgdmVsb2NpdHlQb2ludEIgPSBWZWN0b3IuYWRkKGJvZHlCLnZlbG9jaXR5LCBWZWN0b3IubXVsdChWZWN0b3IucGVycChvZmZzZXRCKSwgYm9keUIuYW5ndWxhclZlbG9jaXR5KSk7XG4gICAgICAgICAgICBvQm4gPSBWZWN0b3IuZG90KG9mZnNldEIsIG5vcm1hbCk7XG4gICAgICAgICAgICBib2R5QkRlbm9tID0gYm9keUIuaW52ZXJzZU1hc3MgKyBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIG9CbiAqIG9CbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICBib2R5QkRlbm9tID0gYm9keUIgPyBib2R5Qi5pbnZlcnNlTWFzcyA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByZWxhdGl2ZVZlbG9jaXR5ID0gVmVjdG9yLnN1Yih2ZWxvY2l0eVBvaW50QiwgdmVsb2NpdHlQb2ludEEpLFxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSA9IFZlY3Rvci5kb3Qobm9ybWFsLCByZWxhdGl2ZVZlbG9jaXR5KSAvIChib2R5QURlbm9tICsgYm9keUJEZW5vbSk7XG4gICAgXG4gICAgICAgIGlmIChub3JtYWxJbXB1bHNlID4gMCkgbm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgXG4gICAgICAgIHZhciBub3JtYWxWZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIHg6IG5vcm1hbC54ICogbm9ybWFsSW1wdWxzZSwgXG4gICAgICAgICAgICB5OiBub3JtYWwueSAqIG5vcm1hbEltcHVsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9ycXVlO1xuIFxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XG4gICAgICAgICAgICB0b3JxdWUgPSBWZWN0b3IuY3Jvc3Mob2Zmc2V0QSwgbm9ybWFsVmVsb2NpdHkpICogYm9keUEuaW52ZXJzZUluZXJ0aWEgKiAoMSAtIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyk7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYXBwbGllZCBpbXB1bHNlcyBmb3IgcG9zdCBzb2x2aW5nXG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS54IC09IGZvcmNlLng7XG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS55IC09IGZvcmNlLnk7XG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS5hbmdsZSArPSB0b3JxdWU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGZvcmNlc1xuICAgICAgICAgICAgYm9keUEucG9zaXRpb24ueCAtPSBmb3JjZS54O1xuICAgICAgICAgICAgYm9keUEucG9zaXRpb24ueSAtPSBmb3JjZS55O1xuICAgICAgICAgICAgYm9keUEuYW5nbGUgKz0gdG9ycXVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xuICAgICAgICAgICAgdG9ycXVlID0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIG5vcm1hbFZlbG9jaXR5KSAqIGJvZHlCLmludmVyc2VJbmVydGlhICogKDEgLSBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MpO1xuXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFwcGxpZWQgaW1wdWxzZXMgZm9yIHBvc3Qgc29sdmluZ1xuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UueCArPSBmb3JjZS54O1xuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UueSArPSBmb3JjZS55O1xuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UuYW5nbGUgLT0gdG9ycXVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhcHBseSBmb3JjZXNcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnggKz0gZm9yY2UueDtcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnkgKz0gZm9yY2UueTtcbiAgICAgICAgICAgIGJvZHlCLmFuZ2xlIC09IHRvcnF1ZTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGJvZHkgdXBkYXRlcyByZXF1aXJlZCBhZnRlciBzb2x2aW5nIGNvbnN0cmFpbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBwb3N0U29sdmVBbGxcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgQ29uc3RyYWludC5wb3N0U29sdmVBbGwgPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBib2R5LmNvbnN0cmFpbnRJbXB1bHNlO1xuXG4gICAgICAgICAgICBpZiAoaW1wdWxzZS54ID09PSAwICYmIGltcHVsc2UueSA9PT0gMCAmJiBpbXB1bHNlLmFuZ2xlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeSBhbmQgcmVzZXRcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGltcHVsc2UueDtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGltcHVsc2UueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1wdWxzZS5hbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgaW1wdWxzZS5hbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGltcHVsc2UuYW5nbGUsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltcHVsc2UuYW5nbGUgPSAwO1xuICAgICAgICAgICAgaW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgIGltcHVsc2UueSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYENvbXBvc2l0ZS5jcmVhdGVgIGJ5IGBDb21tb24ubmV4dElkYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IFwiY29uc3RyYWludFwiXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJDb25zdHJhaW50XCJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIHByb3BlcnRpZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhlIG1vZHVsZSBgTWF0dGVyLlJlbmRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci52aXNpYmxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBsaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgY29uc3RyYWludCBvdXRsaW5lLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIG5vIG91dGxpbmUgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIubGluZVdpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGNvbnN0cmFpbnQgb3V0bGluZS5cbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnN0cm9rZVN0eWxlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgYSByYW5kb20gY29sb3VyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgcG9zc2libGUgYEJvZHlgIHRoYXQgdGhpcyBjb25zdHJhaW50IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUgYm9keVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmQgcG9zc2libGUgYEJvZHlgIHRoYXQgdGhpcyBjb25zdHJhaW50IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUgYm9keVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgY29uc3RyYWludCBmcm9tIGNlbnRlciBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGlmIGRlZmluZWQsIG90aGVyd2lzZSBhIHdvcmxkLXNwYWNlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvaW50QVxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGNvbnN0cmFpbnQgZnJvbSBjZW50ZXIgb2YgdGhlIGBjb25zdHJhaW50LmJvZHlBYCBpZiBkZWZpbmVkLCBvdGhlcndpc2UgYSB3b3JsZC1zcGFjZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb2ludEJcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgc3RpZmZuZXNzIG9mIHRoZSBjb25zdHJhaW50LCBpLmUuIHRoZSByYXRlIGF0IHdoaWNoIGl0IHJldHVybnMgdG8gaXRzIHJlc3RpbmcgYGNvbnN0cmFpbnQubGVuZ3RoYC5cbiAgICAgKiBBIHZhbHVlIG9mIGAxYCBtZWFucyB0aGUgY29uc3RyYWludCBzaG91bGQgYmUgdmVyeSBzdGlmZi5cbiAgICAgKiBBIHZhbHVlIG9mIGAwLjJgIG1lYW5zIHRoZSBjb25zdHJhaW50IGFjdHMgbGlrZSBhIHNvZnQgc3ByaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXN0aW5nIGxlbmd0aCBvZiB0aGUgY29uc3RyYWludC4gXG4gICAgICogSXQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGluIGBDb25zdHJhaW50LmNyZWF0ZWAgZnJvbSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgYGNvbnN0cmFpbnQuYm9keUFgIGFuZCBgY29uc3RyYWludC5ib2R5QmAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvQ29uc3RyYWludC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29uc3RyYWludC9Db25zdHJhaW50LmpzIiwiLyoqXG4qIFRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyB0byBtYW5hZ2UgdGhlIHNsZWVwaW5nIHN0YXRlIG9mIGJvZGllcy5cbipcbiogQGNsYXNzIFNsZWVwaW5nXG4qL1xuXG52YXIgU2xlZXBpbmcgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGVlcGluZztcblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vRXZlbnRzJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIFNsZWVwaW5nLl9tb3Rpb25XYWtlVGhyZXNob2xkID0gMC4xODtcbiAgICBTbGVlcGluZy5fbW90aW9uU2xlZXBUaHJlc2hvbGQgPSAwLjA4O1xuICAgIFNsZWVwaW5nLl9taW5CaWFzID0gMC45O1xuXG4gICAgLyoqXG4gICAgICogUHV0cyBib2RpZXMgdG8gc2xlZXAgb3Igd2FrZXMgdGhlbSB1cCBkZXBlbmRpbmcgb24gdGhlaXIgbW90aW9uLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBTbGVlcGluZy51cGRhdGUgPSBmdW5jdGlvbihib2RpZXMsIHRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgdGltZUZhY3RvciA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSAqIHRpbWVTY2FsZTtcblxuICAgICAgICAvLyB1cGRhdGUgYm9kaWVzIHNsZWVwaW5nIHN0YXR1c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgbW90aW9uID0gYm9keS5zcGVlZCAqIGJvZHkuc3BlZWQgKyBib2R5LmFuZ3VsYXJTcGVlZCAqIGJvZHkuYW5ndWxhclNwZWVkO1xuXG4gICAgICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpZiB0aGV5IGhhdmUgYSBmb3JjZSBhcHBsaWVkXG4gICAgICAgICAgICBpZiAoYm9keS5mb3JjZS54ICE9PSAwIHx8IGJvZHkuZm9yY2UueSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaW5Nb3Rpb24gPSBNYXRoLm1pbihib2R5Lm1vdGlvbiwgbW90aW9uKSxcbiAgICAgICAgICAgICAgICBtYXhNb3Rpb24gPSBNYXRoLm1heChib2R5Lm1vdGlvbiwgbW90aW9uKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBiaWFzZWQgYXZlcmFnZSBtb3Rpb24gZXN0aW1hdGlvbiBiZXR3ZWVuIGZyYW1lc1xuICAgICAgICAgICAgYm9keS5tb3Rpb24gPSBTbGVlcGluZy5fbWluQmlhcyAqIG1pbk1vdGlvbiArICgxIC0gU2xlZXBpbmcuX21pbkJpYXMpICogbWF4TW90aW9uO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYm9keS5zbGVlcFRocmVzaG9sZCA+IDAgJiYgYm9keS5tb3Rpb24gPCBTbGVlcGluZy5fbW90aW9uU2xlZXBUaHJlc2hvbGQgKiB0aW1lRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5zbGVlcENvdW50ZXIgPj0gYm9keS5zbGVlcFRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChib2R5LnNsZWVwQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2V0IG9mIGNvbGxpZGluZyBwYWlycywgd2FrZXMgdGhlIHNsZWVwaW5nIGJvZGllcyBpbnZvbHZlZC5cbiAgICAgKiBAbWV0aG9kIGFmdGVyQ29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMgPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciB0aW1lRmFjdG9yID0gdGltZVNjYWxlICogdGltZVNjYWxlICogdGltZVNjYWxlO1xuXG4gICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGludm9sdmVkIGluIGNvbGxpc2lvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FrZSBpbmFjdGl2ZSBwYWlyc1xuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUEucGFyZW50LCBcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5Qi5wYXJlbnQ7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FrZSBpZiBhdCBsZWFzdCBvbmUgYm9keSBpcyBzdGF0aWNcbiAgICAgICAgICAgIGlmICgoYm9keUEuaXNTbGVlcGluZyAmJiBib2R5Qi5pc1NsZWVwaW5nKSB8fCBib2R5QS5pc1N0YXRpYyB8fCBib2R5Qi5pc1N0YXRpYylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTbGVlcGluZyB8fCBib2R5Qi5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsZWVwaW5nQm9keSA9IChib2R5QS5pc1NsZWVwaW5nICYmICFib2R5QS5pc1N0YXRpYykgPyBib2R5QSA6IGJvZHlCLFxuICAgICAgICAgICAgICAgICAgICBtb3ZpbmdCb2R5ID0gc2xlZXBpbmdCb2R5ID09PSBib2R5QSA/IGJvZHlCIDogYm9keUE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNsZWVwaW5nQm9keS5pc1N0YXRpYyAmJiBtb3ZpbmdCb2R5Lm1vdGlvbiA+IFNsZWVwaW5nLl9tb3Rpb25XYWtlVGhyZXNob2xkICogdGltZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoc2xlZXBpbmdCb2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogU2V0IGEgYm9keSBhcyBzbGVlcGluZyBvciBhd2FrZS5cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTbGVlcGluZ1xuICAgICAqL1xuICAgIFNsZWVwaW5nLnNldCA9IGZ1bmN0aW9uKGJvZHksIGlzU2xlZXBpbmcpIHtcbiAgICAgICAgdmFyIHdhc1NsZWVwaW5nID0gYm9keS5pc1NsZWVwaW5nO1xuXG4gICAgICAgIGlmIChpc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICBib2R5LmlzU2xlZXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgPSBib2R5LnNsZWVwVGhyZXNob2xkO1xuXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnkgPSAwO1xuXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueTtcblxuICAgICAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlO1xuICAgICAgICAgICAgYm9keS5zcGVlZCA9IDA7XG4gICAgICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IDA7XG4gICAgICAgICAgICBib2R5Lm1vdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGlmICghd2FzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihib2R5LCAnc2xlZXBTdGFydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5pc1NsZWVwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciA9IDA7XG5cbiAgICAgICAgICAgIGlmICh3YXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGJvZHksICdzbGVlcEVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvU2xlZXBpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvU2xlZXBpbmcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIERFRkFVTFQ6IDAsXG4gICAgTElORUFSOiAwLFxuICAgIE5FQVJFU1Q6IDFcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL1NjYWxlTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWlucyA9IGZ1bmN0aW9uIChjaXJjbGUsIHgsIHkpXG57XG4gICAgLy8gIENoZWNrIGlmIHgveSBhcmUgd2l0aGluIHRoZSBib3VuZHMgZmlyc3RcbiAgICBpZiAoY2lyY2xlLnJhZGl1cyA+IDAgJiYgeCA+PSBjaXJjbGUubGVmdCAmJiB4IDw9IGNpcmNsZS5yaWdodCAmJiB5ID49IGNpcmNsZS50b3AgJiYgeSA8PSBjaXJjbGUuYm90dG9tKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gKGNpcmNsZS54IC0geCkgKiAoY2lyY2xlLnggLSB4KTtcbiAgICAgICAgdmFyIGR5ID0gKGNpcmNsZS55IC0geSkgKiAoY2lyY2xlLnkgLSB5KTtcblxuICAgICAgICByZXR1cm4gKGR4ICsgZHkpIDw9IChjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGJhc2VkIG9mZiBhbiBleHBsYW5hdGlvbiBhbmQgZXhwYW5kZWQgbWF0aCBwcmVzZW50ZWQgYnkgUGF1bCBCb3Vya2U6XG4vLyAgU2VlIGh0dHA6J2xvY2FsLndhc3AudXdhLmVkdS5hdS9+cGJvdXJrZS9nZW9tZXRyeS9saW5lbGluZTJkL1xuXG52YXIgTGluZVRvTGluZSA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cblxuICAgIHZhciB4MSA9IGxpbmUxLngxO1xuICAgIHZhciB5MSA9IGxpbmUxLnkxO1xuICAgIHZhciB4MiA9IGxpbmUxLngyO1xuICAgIHZhciB5MiA9IGxpbmUxLnkyO1xuXG4gICAgdmFyIHgzID0gbGluZTIueDE7XG4gICAgdmFyIHkzID0gbGluZTIueTE7XG4gICAgdmFyIHg0ID0gbGluZTIueDI7XG4gICAgdmFyIHk0ID0gbGluZTIueTI7XG5cbiAgICB2YXIgbnVtQSA9ICh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgbnVtQiA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgZGVOb20gPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICAvLyAgTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhIGRpdmlzaW9uIGJ5IHplcm8gLSB0aGlzIGFsc28gaW5kaWNhdGVzIHRoYXQgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbC5cbiAgICAvLyAgSWYgbnVtQSBhbmQgbnVtQiB3ZXJlIGJvdGggZXF1YWwgdG8gemVybyB0aGUgbGluZXMgd291bGQgYmUgb24gdG9wIG9mIGVhY2ggb3RoZXIgKGNvaW5jaWRlbnRhbCkuXG4gICAgLy8gIFRoaXMgY2hlY2sgaXMgbm90IGRvbmUgYmVjYXVzZSBpdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGlzIGltcGxlbWVudGF0aW9uICh0aGUgcGFyYWxsZWwgY2hlY2sgYWNjb3VudHMgZm9yIHRoaXMpLlxuXG4gICAgaWYgKGRlTm9tID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vICBDYWxjdWxhdGUgdGhlIGludGVybWVkaWF0ZSBmcmFjdGlvbmFsIHBvaW50IHRoYXQgdGhlIGxpbmVzIHBvdGVudGlhbGx5IGludGVyc2VjdC5cblxuICAgIHZhciB1QSA9IG51bUEgLyBkZU5vbTtcbiAgICB2YXIgdUIgPSBudW1CIC8gZGVOb207XG5cbiAgICAvLyAgVGhlIGZyYWN0aW9uYWwgcG9pbnQgd2lsbCBiZSBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3QuXG4gICAgLy8gIElmIHRoZSBmcmFjdGlvbmFsIGNhbGN1bGF0aW9uIGlzIGxhcmdlciB0aGFuIDEgb3Igc21hbGxlciB0aGFuIDAgdGhlIGxpbmVzIHdvdWxkIG5lZWQgdG8gYmUgbG9uZ2VyIHRvIGludGVyc2VjdC5cblxuICAgIGlmICh1QSA+PSAwICYmIHVBIDw9IDEgJiYgdUIgPj0gMCAmJiB1QiA8PSAxKVxuICAgIHtcbiAgICAgICAgb3V0LnggPSB4MSArICh1QSAqICh4MiAtIHgxKSk7XG4gICAgICAgIG91dC55ID0geTEgKyAodUEgKiAoeTIgLSB5MSkpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVRvTGluZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L1xuXG52YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHgsIHkpXG57XG4gICAgdmFyIHYweCA9IHRyaWFuZ2xlLngzIC0gdHJpYW5nbGUueDE7XG4gICAgdmFyIHYweSA9IHRyaWFuZ2xlLnkzIC0gdHJpYW5nbGUueTE7XG5cbiAgICB2YXIgdjF4ID0gdHJpYW5nbGUueDIgLSB0cmlhbmdsZS54MTtcbiAgICB2YXIgdjF5ID0gdHJpYW5nbGUueTIgLSB0cmlhbmdsZS55MTtcblxuICAgIHZhciB2MnggPSB4IC0gdHJpYW5nbGUueDE7XG4gICAgdmFyIHYyeSA9IHkgLSB0cmlhbmdsZS55MTtcblxuICAgIHZhciBkb3QwMCA9ICh2MHggKiB2MHgpICsgKHYweSAqIHYweSk7XG4gICAgdmFyIGRvdDAxID0gKHYweCAqIHYxeCkgKyAodjB5ICogdjF5KTtcbiAgICB2YXIgZG90MDIgPSAodjB4ICogdjJ4KSArICh2MHkgKiB2MnkpO1xuICAgIHZhciBkb3QxMSA9ICh2MXggKiB2MXgpICsgKHYxeSAqIHYxeSk7XG4gICAgdmFyIGRvdDEyID0gKHYxeCAqIHYyeCkgKyAodjF5ICogdjJ5KTtcblxuICAgIC8vIENvbXB1dGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcbiAgICB2YXIgYiA9ICgoZG90MDAgKiBkb3QxMSkgLSAoZG90MDEgKiBkb3QwMSkpO1xuICAgIHZhciBpbnYgPSAoYiA9PT0gMCkgPyAwIDogKDEgLyBiKTtcbiAgICB2YXIgdSA9ICgoZG90MTEgKiBkb3QwMikgLSAoZG90MDEgKiBkb3QxMikpICogaW52O1xuICAgIHZhciB2ID0gKChkb3QwMCAqIGRvdDEyKSAtIChkb3QwMSAqIGRvdDAyKSkgKiBpbnY7XG5cbiAgICByZXR1cm4gKHUgPj0gMCAmJiB2ID49IDAgJiYgKHUgKyB2IDwgMSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWlucztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXcmFwID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heClcbntcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cbiAgICBpZiAocmFuZ2UgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgLSBtaW4pICUgcmFuZ2U7XG5cbiAgICBpZiAocmVzdWx0IDwgMClcbiAgICB7XG4gICAgICAgIHJlc3VsdCArPSByYW5nZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICsgbWluO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXcmFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9XcmFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGBNYXR0ZXIuUGFpcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIHBhaXJzLlxuKlxuKiBAY2xhc3MgUGFpclxuKi9cblxudmFyIFBhaXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWlyO1xuXG52YXIgQ29udGFjdCA9IHJlcXVpcmUoJy4vQ29udGFjdCcpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhaXIuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gY29sbGlzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqIEByZXR1cm4ge3BhaXJ9IEEgbmV3IHBhaXJcbiAgICAgKi9cbiAgICBQYWlyLmNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxpc2lvbiwgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QSxcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCLFxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgcGFyZW50QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xuXG4gICAgICAgIHZhciBwYWlyID0ge1xuICAgICAgICAgICAgaWQ6IFBhaXIuaWQoYm9keUEsIGJvZHlCKSxcbiAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCOiBib2R5QixcbiAgICAgICAgICAgIGNvbnRhY3RzOiB7fSxcbiAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzOiBbXSxcbiAgICAgICAgICAgIHNlcGFyYXRpb246IDAsXG4gICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlzU2Vuc29yOiBib2R5QS5pc1NlbnNvciB8fCBib2R5Qi5pc1NlbnNvcixcbiAgICAgICAgICAgIHRpbWVDcmVhdGVkOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICB0aW1lVXBkYXRlZDogdGltZXN0YW1wLFxuICAgICAgICAgICAgaW52ZXJzZU1hc3M6IHBhcmVudEEuaW52ZXJzZU1hc3MgKyBwYXJlbnRCLmludmVyc2VNYXNzLFxuICAgICAgICAgICAgZnJpY3Rpb246IE1hdGgubWluKHBhcmVudEEuZnJpY3Rpb24sIHBhcmVudEIuZnJpY3Rpb24pLFxuICAgICAgICAgICAgZnJpY3Rpb25TdGF0aWM6IE1hdGgubWF4KHBhcmVudEEuZnJpY3Rpb25TdGF0aWMsIHBhcmVudEIuZnJpY3Rpb25TdGF0aWMpLFxuICAgICAgICAgICAgcmVzdGl0dXRpb246IE1hdGgubWF4KHBhcmVudEEucmVzdGl0dXRpb24sIHBhcmVudEIucmVzdGl0dXRpb24pLFxuICAgICAgICAgICAgc2xvcDogTWF0aC5tYXgocGFyZW50QS5zbG9wLCBwYXJlbnRCLnNsb3ApXG4gICAgICAgIH07XG5cbiAgICAgICAgUGFpci51cGRhdGUocGFpciwgY29sbGlzaW9uLCB0aW1lc3RhbXApO1xuXG4gICAgICAgIHJldHVybiBwYWlyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgcGFpciBnaXZlbiBhIGNvbGxpc2lvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7cGFpcn0gcGFpclxuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICovXG4gICAgUGFpci51cGRhdGUgPSBmdW5jdGlvbihwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgY29udGFjdHMgPSBwYWlyLmNvbnRhY3RzLFxuICAgICAgICAgICAgc3VwcG9ydHMgPSBjb2xsaXNpb24uc3VwcG9ydHMsXG4gICAgICAgICAgICBhY3RpdmVDb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHMsXG4gICAgICAgICAgICBwYXJlbnRBID0gY29sbGlzaW9uLnBhcmVudEEsXG4gICAgICAgICAgICBwYXJlbnRCID0gY29sbGlzaW9uLnBhcmVudEI7XG4gICAgICAgIFxuICAgICAgICBwYWlyLmNvbGxpc2lvbiA9IGNvbGxpc2lvbjtcbiAgICAgICAgcGFpci5pbnZlcnNlTWFzcyA9IHBhcmVudEEuaW52ZXJzZU1hc3MgKyBwYXJlbnRCLmludmVyc2VNYXNzO1xuICAgICAgICBwYWlyLmZyaWN0aW9uID0gTWF0aC5taW4ocGFyZW50QS5mcmljdGlvbiwgcGFyZW50Qi5mcmljdGlvbik7XG4gICAgICAgIHBhaXIuZnJpY3Rpb25TdGF0aWMgPSBNYXRoLm1heChwYXJlbnRBLmZyaWN0aW9uU3RhdGljLCBwYXJlbnRCLmZyaWN0aW9uU3RhdGljKTtcbiAgICAgICAgcGFpci5yZXN0aXR1dGlvbiA9IE1hdGgubWF4KHBhcmVudEEucmVzdGl0dXRpb24sIHBhcmVudEIucmVzdGl0dXRpb24pO1xuICAgICAgICBwYWlyLnNsb3AgPSBNYXRoLm1heChwYXJlbnRBLnNsb3AsIHBhcmVudEIuc2xvcCk7XG4gICAgICAgIGFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1cHBvcnQgPSBzdXBwb3J0c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdElkID0gQ29udGFjdC5pZChzdXBwb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdCA9IGNvbnRhY3RzW2NvbnRhY3RJZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDb250YWN0cy5wdXNoKGNvbnRhY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNvbnRhY3RzLnB1c2goY29udGFjdHNbY29udGFjdElkXSA9IENvbnRhY3QuY3JlYXRlKHN1cHBvcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhaXIuc2VwYXJhdGlvbiA9IGNvbGxpc2lvbi5kZXB0aDtcbiAgICAgICAgICAgIFBhaXIuc2V0QWN0aXZlKHBhaXIsIHRydWUsIHRpbWVzdGFtcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFpci5pc0FjdGl2ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBQYWlyLnNldEFjdGl2ZShwYWlyLCBmYWxzZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFpciBhcyBhY3RpdmUgb3IgaW5hY3RpdmUuXG4gICAgICogQG1ldGhvZCBzZXRBY3RpdmVcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGlzQWN0aXZlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqL1xuICAgIFBhaXIuc2V0QWN0aXZlID0gZnVuY3Rpb24ocGFpciwgaXNBY3RpdmUsIHRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcGFpci50aW1lVXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIGZvciB0aGUgZ2l2ZW4gcGFpci5cbiAgICAgKiBAbWV0aG9kIGlkXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVuaXF1ZSBwYWlySWRcbiAgICAgKi9cbiAgICBQYWlyLmlkID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKSB7XG4gICAgICAgIGlmIChib2R5QS5pZCA8IGJvZHlCLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0EnICsgYm9keUEuaWQgKyAnQicgKyBib2R5Qi5pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnQScgKyBib2R5Qi5pZCArICdCJyArIGJvZHlBLmlkO1xuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9QYWlyLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpci5qcyIsInZhciBCdWZmZXIzMiA9IGZ1bmN0aW9uIChieXRlU2l6ZSlcbntcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcbiAgICB0aGlzLmR3b3JkQ2FwYWNpdHkgPSBieXRlU2l6ZSAvIDQ7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xuICAgIHRoaXMuZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlcik7XG4gICAgdGhpcy5pbnRWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5idWZmZXIpO1xuICAgIHRoaXMudWludFZpZXcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5idWZmZXIpO1xufTtcblxuQnVmZmVyMzIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmR3b3JkTGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5kd29yZExlbmd0aCAqIDQ7XG59O1xuXG5CdWZmZXIzMi5wcm90b3R5cGUuZ2V0Qnl0ZUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkgXG57XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG59O1xuXG5CdWZmZXIzMi5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiAoZHdvcmRTaXplKVxue1xuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy5kd29yZExlbmd0aDtcbiAgICB0aGlzLmR3b3JkTGVuZ3RoICs9IGR3b3JkU2l6ZTtcbiAgICByZXR1cm4gY3VycmVudExlbmd0aDtcbn07XG5cbkJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNGbG9hdCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuZmxvYXRWaWV3LnN1YmFycmF5KDAsIHRoaXMuZHdvcmRMZW5ndGgpO1xufTtcblxuQnVmZmVyMzIucHJvdG90eXBlLmdldFVzZWRCdWZmZXJBc0ludCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuaW50Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcbn07XG5cbkJ1ZmZlcjMyLnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNVaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy51aW50Vmlldy5zdWJhcnJheSgwLCB0aGlzLmR3b3JkTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyMzI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQnVmZmVyMzIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiAoZ2wsIGJ1ZmZlclR5cGUsIHVzYWdlLCBidWZmZXJEYXRhLCBidWZmZXJTaXplKVxue1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlclR5cGUsIGJ1ZmZlcik7XG4gICAgaWYgKGJ1ZmZlckRhdGEgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlckRhdGEpKVxuICAgIHtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShidWZmZXJUeXBlLCBidWZmZXJEYXRhLCB1c2FnZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYnVmZmVyU2l6ZSwgdXNhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy9idWZmZXIvQ3JlYXRlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcilcbntcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbS4gRXJyb3I6IFxcbicgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlUHJvZ3JhbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUpXG57XG4gICAgdmFyIHNoYWRlciA9IG51bGw7XG4gICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkICcgKyAoc2hhZGVyVHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogc2hhZGVyVHlwZSA9PT0gZ2wuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICdpbnZhbGlkJykgKyAnIHNoYWRlciBjb21waWxhdGlvbi4gRXJyb3I6IFxcbicgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlU2hhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uIChnbCwgdmFvKVxue1xuICAgIHZhciBhdHRyaWJ1dGVzID0gdmFvLmF0dHJpYnV0ZXM7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZhby5idWZmZXIpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYiA9IGF0dHJpYnV0ZXNbaW5kZXhdO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBhdHRyaWIubG9jYXRpb247XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgYXR0cmliLnNpemUsXG4gICAgICAgICAgICBhdHRyaWIudHlwZSxcbiAgICAgICAgICAgIGF0dHJpYi5ub3JtYWxpemVkLFxuICAgICAgICAgICAgYXR0cmliLnN0cmlkZSxcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXRcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmRWZXJ0ZXhBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpO1xuXG52YXIgQ3JlYXRlQXR0cmliRGVzYyA9IGZ1bmN0aW9uIChnbCwgcHJvZ3JhbSwgbmFtZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpXG57XG4gICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUoXG4gICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgICAgICBzaXplLFxuICAgICAgICB0eXBlLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIG9mZnNldFxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZUF0dHJpYkRlc2M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MuanMiLCJ2YXIgVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodmJvLCBhdHRyaWJ1dGVzKVxue1xuICAgIHRoaXMuYnVmZmVyID0gdmJvO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdmFvL1ZlcnRleEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpO1xuXG4vKipcbiogVGhpcyBpcyBhIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5leHRlbmQvXG4qIFxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5leHRlbmRcbiogQHBhcmFtIHtib29sZWFufSBkZWVwIC0gUGVyZm9ybSBhIGRlZXAgY29weT9cbiogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRvIGNvcHkgdG8uXG4qIEByZXR1cm4ge29iamVjdH0gVGhlIGV4dGVuZGVkIG9iamVjdC5cbiovXG52YXIgRXh0ZW5kID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpXG4gICAge1xuICAgICAgICBkZWVwID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgaSA9IDI7XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIFBoYXNlciBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICBpZiAobGVuZ3RoID09PSBpKVxuICAgIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLS1pO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChJc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgSXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gRXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL29iamVjdC9FeHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL29iamVjdC9FeHRlbmQuanMiLCJ2YXIgQ2FudmFzSW50ZXJwb2xhdGlvbiA9IHtcblxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgQ1NTIGltYWdlLXJlbmRlcmluZyBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gY2FudmFzIHRvIGJlICdjcmlzcCcgKGFrYSAnb3B0aW1pemUgY29udHJhc3QnIG9uIHdlYmtpdCkuXG4gICAgKiBOb3RlIHRoYXQgaWYgdGhpcyBkb2Vzbid0IGdpdmVuIHRoZSBkZXNpcmVkIHJlc3VsdCB0aGVuIHNlZSB0aGUgc2V0U21vb3RoaW5nRW5hYmxlZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0SW1hZ2VSZW5kZXJpbmdDcmlzcFxuICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0byBzZXQgaW1hZ2UtcmVuZGVyaW5nIGNyaXNwIG9uLlxuICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFJldHVybnMgdGhlIHNvdXJjZSBjYW52YXMuXG4gICAgKi9cbiAgICBzZXRDcmlzcDogZnVuY3Rpb24gKGNhbnZhcylcbiAgICB7XG4gICAgICAgIHZhciB0eXBlcyA9IFsgJ29wdGltaXplU3BlZWQnLCAnY3Jpc3AtZWRnZXMnLCAnLW1vei1jcmlzcC1lZGdlcycsICctd2Via2l0LW9wdGltaXplLWNvbnRyYXN0JywgJ29wdGltaXplLWNvbnRyYXN0JywgJ3BpeGVsYXRlZCcgXTtcblxuICAgICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZVsnaW1hZ2UtcmVuZGVyaW5nJ10gPSB0eXBlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXMuc3R5bGUubXNJbnRlcnBvbGF0aW9uTW9kZSA9ICduZWFyZXN0LW5laWdoYm9yJztcblxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIENTUyBpbWFnZS1yZW5kZXJpbmcgcHJvcGVydHkgb24gdGhlIGdpdmVuIGNhbnZhcyB0byBiZSAnYmljdWJpYycgKGFrYSAnYXV0bycpLlxuICAgICogTm90ZSB0aGF0IGlmIHRoaXMgZG9lc24ndCBnaXZlbiB0aGUgZGVzaXJlZCByZXN1bHQgdGhlbiBzZWUgdGhlIENhbnZhc1V0aWxzLnNldFNtb290aGluZ0VuYWJsZWQgbWV0aG9kLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkNhbnZhcy5zZXRJbWFnZVJlbmRlcmluZ0JpY3ViaWNcbiAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRvIHNldCBpbWFnZS1yZW5kZXJpbmcgYmljdWJpYyBvbi5cbiAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIHRoZSBzb3VyY2UgY2FudmFzLlxuICAgICovXG4gICAgc2V0QmljdWJpYzogZnVuY3Rpb24gKGNhbnZhcylcbiAgICB7XG4gICAgICAgIGNhbnZhcy5zdHlsZVsnaW1hZ2UtcmVuZGVyaW5nJ10gPSAnYXV0byc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5tc0ludGVycG9sYXRpb25Nb2RlID0gJ2JpY3ViaWMnO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0ludGVycG9sYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQVJDOiAwLFxuICAgIEJFR0lOX1BBVEg6IDEsXG4gICAgQ0xPU0VfUEFUSDogMixcbiAgICBGSUxMX1JFQ1Q6IDMsXG4gICAgTElORV9UTzogNCxcbiAgICBNT1ZFX1RPOiA1LFxuICAgIExJTkVfU1RZTEU6IDYsXG4gICAgRklMTF9TVFlMRTogNyxcbiAgICBGSUxMX1BBVEg6IDgsXG4gICAgU1RST0tFX1BBVEg6IDksXG4gICAgRklMTF9UUklBTkdMRTogMTAsXG4gICAgU1RST0tFX1RSSUFOR0xFOiAxMSxcbiAgICBMSU5FX0ZYX1RPOiAxMixcbiAgICBNT1ZFX0ZYX1RPOiAxM1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0NvbW1hbmRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xudmFyIFNwcml0ZVJlbmRlciA9IHJlcXVpcmUoJy4vU3ByaXRlUmVuZGVyJyk7XG5cbnZhciBTcHJpdGUgPSBuZXcgQ2xhc3Moe1xuXG4gICAgTWl4aW5zOiBbXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXG4gICAgICAgIENvbXBvbmVudHMuU2NhbGVNb2RlLFxuICAgICAgICBDb21wb25lbnRzLlNpemUsXG4gICAgICAgIENvbXBvbmVudHMuVGV4dHVyZSxcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxuICAgICAgICBTcHJpdGVSZW5kZXJcbiAgICBdLFxuXG4gICAgaW5pdGlhbGl6ZTpcblxuICAgIGZ1bmN0aW9uIFNwcml0ZSAoc3RhdGUsIHgsIHksIHRleHR1cmUsIGZyYW1lKVxuICAgIHtcbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgICAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSwgZnJhbWUpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xuICAgICAgICB0aGlzLnNldFNpemVUb0ZyYW1lKCk7XG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlLmpzIiwiXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcblxudmFyIFpvbmUgPSBuZXcgQ2xhc3Moe1xuXG4gICAgTWl4aW5zOiBbXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2Zvcm0sXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZVxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gWm9uZSAoc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oMCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBab25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvem9uZS9ab25lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy96b25lL1pvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgeCwgeSlcbntcbiAgICBpZiAoZWxsaXBzZS53aWR0aCA8PSAwIHx8IGVsbGlwc2UuaGVpZ2h0IDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuIFxuICAgIC8vICBOb3JtYWxpemUgdGhlIGNvb3JkcyB0byBhbiBlbGxpcHNlIHdpdGggY2VudGVyIDAsMCBhbmQgYSByYWRpdXMgb2YgMC41XG4gICAgdmFyIG5vcm14ID0gKCh4IC0gZWxsaXBzZS54KSAvIGVsbGlwc2Uud2lkdGgpIC0gMC41O1xuICAgIHZhciBub3JteSA9ICgoeSAtIGVsbGlwc2UueSkgLyBlbGxpcHNlLmhlaWdodCkgLSAwLjU7XG4gXG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG4gXG4gICAgcmV0dXJuIChub3JteCArIG5vcm15IDwgMC4yNSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQ29udmVydCBhIGRpc3RhbmNlIGFsb25nIHRoaXMgY3VydmUgaW50byBhIGB0aW1lYCB2YWx1ZSB3aGljaCB3aWxsIGJlIGJldHdlZW4gMCBhbmQgMS5cbiogXG4qIEZvciBleGFtcGxlIGlmIHRoaXMgY3VydmUgaGFzIGEgbGVuZ3RoIG9mIDEwMCBwaXhlbHMgdGhlbiBgZmluZFQoNTApYCB3b3VsZCByZXR1cm4gYDAuNWAuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZmluZFRcbiogQHBhcmFtIHtpbnRlZ2VyfSBkaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBpbnRvIHRoZSBjdXJ2ZSBpbiBwaXhlbHMuIFNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHRpbWUgKGB0YCkgdmFsdWUsIGEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuKi9cbnZhciBGaW5kVCA9IGZ1bmN0aW9uIChjdXJ2ZSwgZGlzdGFuY2UpXG57XG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyAgRmluZCB0aGUgX3BvaW50cyB3aGljaCBicmFja2V0IHRoZSBkaXN0YW5jZSB2YWx1ZVxuICAgIHZhciB0aSA9IE1hdGguZmxvb3IoZGlzdGFuY2UgLyBjdXJ2ZS5sZW5ndGggKiBjdXJ2ZS5fYWNjdXJhY3kpO1xuXG4gICAgd2hpbGUgKHRpID4gMCAmJiBjdXJ2ZS5fcG9pbnRzW3RpXSA+IGRpc3RhbmNlKVxuICAgIHtcbiAgICAgICAgdGktLTtcbiAgICB9XG5cbiAgICB3aGlsZSAodGkgPCBjdXJ2ZS5fYWNjdXJhY3kgJiYgY3VydmUuX3BvaW50c1t0aV0gPCBkaXN0YW5jZSlcbiAgICB7XG4gICAgICAgIHRpKys7XG4gICAgfVxuXG4gICAgLy8gIExpbmVhciBpbnRlcnBvbGF0aW9uIHRvIGdldCBhIG1vcmUgYWNjdXJhdGUgZml4XG4gICAgdmFyIGR0ID0gY3VydmUuX3BvaW50c1t0aV0gLSBjdXJ2ZS5fcG9pbnRzW3RpIC0gMV07XG4gICAgdmFyIGQgPSBkaXN0YW5jZSAtIGN1cnZlLl9wb2ludHNbdGkgLSAxXTtcblxuICAgIHJldHVybiAoKHRpIC0gMSkgLyBjdXJ2ZS5fYWNjdXJhY3kpICsgZCAvIChkdCAqIGN1cnZlLl9hY2N1cmFjeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9oZXJtaXRlL0ZpbmRULmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG4vKipcbiogR2V0IGEgcG9pbnQgb24gdGhlIGN1cnZlIHVzaW5nIHRoZSBgdGAgKHRpbWUpIHZhbHVlLCB3aGljaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRQb2ludFxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgdGltZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgZnJvbSB3aGljaCB0byBleHRyYWN0IGEgcG9pbnQuIFRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlIGFuZCAxIHRoZSBlbmQuXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gW3BvaW50XSAtIEFuIG9wdGlvbmFsIFBoYXNlci5Qb2ludCwgb3IgT2JqZWN0IGNvbnRhaW5pbmcgcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIGdpdmVuIHRoZSByZXN1bHRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBPYmplY3RzIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMuIElmIG9taXR0ZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCBpcyBjcmVhdGVkLlxuKiBAcmV0dXJuIHtQaGFzZXIuUG9pbnR9IEFuIE9iamVjdCB3aXRoIHRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGF0IHRoZSBzcGVjaWZpZWQgYHRgIHZhbHVlIHNldCBpbiBpdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy5cbiovXG52YXIgR2V0UG9pbnQgPSBmdW5jdGlvbiAoY3VydmUsIHQsIG91dClcbntcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7IHQgPSAwOyB9XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICBpZiAodCA8IDApXG4gICAge1xuICAgICAgICB0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodCA+IDEpXG4gICAge1xuICAgICAgICB0ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgdDIgPSB0ICogdDtcbiAgICB2YXIgdDMgPSB0ICogdDI7XG5cbiAgICBvdXQueCA9IHQzICogY3VydmUuX2F4ICsgdDIgKiBjdXJ2ZS5fYnggKyB0ICogY3VydmUuX3YxeCArIGN1cnZlLl9wMXg7XG4gICAgb3V0LnkgPSB0MyAqIGN1cnZlLl9heSArIHQyICogY3VydmUuX2J5ICsgdCAqIGN1cnZlLl92MXkgKyBjdXJ2ZS5fcDF5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0UG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0UG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludC5qcyIsIi8qKlxuKiBVc2luZyBCcmVzZW5oYW0ncyBsaW5lIGFsZ29yaXRobSB0aGlzIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcyBvbiB0aGlzIGxpbmUuXG4qIFRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgcm91bmRlZCBiZWZvcmUgdGhpcyBydW5zIGFzIHRoZSBhbGdvcml0aG0gd29ya3Mgb24gaW50ZWdlcnMuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUjY29vcmRpbmF0ZXNPbkxpbmVcbiogQHBhcmFtIHtudW1iZXJ9IFtzdGVwUmF0ZT0xXSAtIEhvdyBtYW55IHN0ZXBzIHdpbGwgd2UgcmV0dXJuPyAxID0gZXZlcnkgY29vcmRpbmF0ZSBvbiB0aGUgbGluZSwgMiA9IGV2ZXJ5IG90aGVyIGNvb3JkaW5hdGUsIGV0Yy5cbiogQHBhcmFtIHthcnJheX0gW3Jlc3VsdHNdIC0gVGhlIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLiBJZiBub3QgcHJvdmlkZWQgYSBuZXcgb25lIHdpbGwgYmUgZ2VuZXJhdGVkLlxuKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4qL1xudmFyIEdldFBvaW50c09uTGluZSA9IGZ1bmN0aW9uIChsaW5lLCBzdGVwUmF0ZSwgcmVzdWx0cylcbntcbiAgICBpZiAoc3RlcFJhdGUgPT09IHVuZGVmaW5lZCkgeyBzdGVwUmF0ZSA9IDE7IH1cbiAgICBpZiAocmVzdWx0cyA9PT0gdW5kZWZpbmVkKSB7IHJlc3VsdHMgPSBbXTsgfVxuXG4gICAgdmFyIHgxID0gTWF0aC5yb3VuZChsaW5lLngxKTtcbiAgICB2YXIgeTEgPSBNYXRoLnJvdW5kKGxpbmUueTEpO1xuICAgIHZhciB4MiA9IE1hdGgucm91bmQobGluZS54Mik7XG4gICAgdmFyIHkyID0gTWF0aC5yb3VuZChsaW5lLnkyKTtcblxuICAgIHZhciBkeCA9IE1hdGguYWJzKHgyIC0geDEpO1xuICAgIHZhciBkeSA9IE1hdGguYWJzKHkyIC0geTEpO1xuICAgIHZhciBzeCA9ICh4MSA8IHgyKSA/IDEgOiAtMTtcbiAgICB2YXIgc3kgPSAoeTEgPCB5MikgPyAxIDogLTE7XG4gICAgdmFyIGVyciA9IGR4IC0gZHk7XG5cbiAgICByZXN1bHRzLnB1c2goWyB4MSwgeTEgXSk7XG5cbiAgICB2YXIgaSA9IDE7XG5cbiAgICB3aGlsZSAoISgoeDEgPT09IHgyKSAmJiAoeTEgPT09IHkyKSkpXG4gICAge1xuICAgICAgICB2YXIgZTIgPSBlcnIgPDwgMTtcblxuICAgICAgICBpZiAoZTIgPiAtZHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVyciAtPSBkeTtcbiAgICAgICAgICAgIHgxICs9IHN4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUyIDwgZHgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVyciArPSBkeDtcbiAgICAgICAgICAgIHkxICs9IHN5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgJSBzdGVwUmF0ZSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFsgeDEsIHkxIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludHNPbkxpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0UG9pbnRzT25MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBSb3RhdGVBcm91bmRYWSA9IGZ1bmN0aW9uIChsaW5lLCB4LCB5LCBhbmdsZSlcbntcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIHZhciB0eCA9IGxpbmUueDEgLSB4O1xuICAgIHZhciB0eSA9IGxpbmUueTEgLSB5O1xuXG4gICAgbGluZS54MSA9IHR4ICogYyAtIHR5ICogcyArIHg7XG4gICAgbGluZS55MSA9IHR4ICogcyArIHR5ICogYyArIHk7XG5cbiAgICB0eCA9IGxpbmUueDIgLSB4O1xuICAgIHR5ID0gbGluZS55MiAtIHk7XG5cbiAgICBsaW5lLngyID0gdHggKiBjIC0gdHkgKiBzICsgeDtcbiAgICBsaW5lLnkyID0gdHggKiBzICsgdHkgKiBjICsgeTtcblxuICAgIHJldHVybiBsaW5lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRYWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRYWS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50QilcbntcbiAgICByZXR1cm4gKChwb2ludEEueCAqIHBvaW50Qi54KSArIChwb2ludEEueSAqIHBvaW50Qi55KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRG90LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29udGFpbnMgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcbntcbiAgICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChyZWN0LnggPD0geCAmJiByZWN0LnggKyByZWN0LndpZHRoID49IHggJiYgcmVjdC55IDw9IHkgJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0geSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIChyZWN0KVxue1xuICAgIHJldHVybiAocmVjdC5oZWlnaHQgPT09IDApID8gTmFOIDogcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBc3BlY3RSYXRpbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0dldEFzcGVjdFJhdGlvLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L1xuXG4vLyAgcG9pbnRzIGlzIGFuIGFycmF5IG9mIFBvaW50LWxpa2Ugb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllc1xuLy8gIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgcG9pbnRzIHRoYXQgYXJlIHdpdGhpbiB0aGUgdHJpYW5nbGUsIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vbmVcbi8vICBpZiAncmV0dXJuRmlyc3QnIGlzIHRydWUgaXQgd2lsbCByZXR1cm4gYWZ0ZXIgdGhlIGZpcnN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGUgaXMgZm91bmRcblxudmFyIENvbnRhaW5zQXJyYXkgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHBvaW50cywgcmV0dXJuRmlyc3QsIG91dClcbntcbiAgICBpZiAocmV0dXJuRmlyc3QgPT09IHVuZGVmaW5lZCkgeyByZXR1cm5GaXJzdCA9IGZhbHNlOyB9XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IFtdOyB9XG5cbiAgICB2YXIgdjB4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcbiAgICB2YXIgdjB5ID0gdHJpYW5nbGUueTMgLSB0cmlhbmdsZS55MTtcblxuICAgIHZhciB2MXggPSB0cmlhbmdsZS54MiAtIHRyaWFuZ2xlLngxO1xuICAgIHZhciB2MXkgPSB0cmlhbmdsZS55MiAtIHRyaWFuZ2xlLnkxO1xuXG4gICAgdmFyIGRvdDAwID0gKHYweCAqIHYweCkgKyAodjB5ICogdjB5KTtcbiAgICB2YXIgZG90MDEgPSAodjB4ICogdjF4KSArICh2MHkgKiB2MXkpO1xuICAgIHZhciBkb3QxMSA9ICh2MXggKiB2MXgpICsgKHYxeSAqIHYxeSk7XG5cbiAgICAvLyBDb21wdXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgdmFyIGIgPSAoKGRvdDAwICogZG90MTEpIC0gKGRvdDAxICogZG90MDEpKTtcbiAgICB2YXIgaW52ID0gKGIgPT09IDApID8gMCA6ICgxIC8gYik7XG5cbiAgICB2YXIgdTtcbiAgICB2YXIgdjtcbiAgICB2YXIgdjJ4O1xuICAgIHZhciB2Mnk7XG4gICAgdmFyIGRvdDAyO1xuICAgIHZhciBkb3QxMjtcblxuICAgIHZhciB4MSA9IHRyaWFuZ2xlLngxO1xuICAgIHZhciB5MSA9IHRyaWFuZ2xlLnkxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2MnggPSBwb2ludHNbaV0ueCAtIHgxO1xuICAgICAgICB2MnkgPSBwb2ludHNbaV0ueSAtIHkxO1xuXG4gICAgICAgIGRvdDAyID0gKHYweCAqIHYyeCkgKyAodjB5ICogdjJ5KTtcbiAgICAgICAgZG90MTIgPSAodjF4ICogdjJ4KSArICh2MXkgKiB2MnkpO1xuXG4gICAgICAgIHUgPSAoKGRvdDExICogZG90MDIpIC0gKGRvdDAxICogZG90MTIpKSAqIGludjtcbiAgICAgICAgdiA9ICgoZG90MDAgKiBkb3QxMikgLSAoZG90MDEgKiBkb3QwMikpICogaW52O1xuICAgIFxuICAgICAgICBpZiAodSA+PSAwICYmIHYgPj0gMCAmJiAodSArIHYgPCAxKSlcbiAgICAgICAge1xuICAgICAgICAgICAgb3V0LnB1c2goeyB4OiBwb2ludHNbaV0ueCwgeTogcG9pbnRzW2ldLnkgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0NvbnRhaW5zQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIFJvdGF0ZUFyb3VuZFhZID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5LCBhbmdsZSlcbntcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIHZhciB0eCA9IHRyaWFuZ2xlLngxIC0geDtcbiAgICB2YXIgdHkgPSB0cmlhbmdsZS55MSAtIHk7XG5cbiAgICB0cmlhbmdsZS54MSA9IHR4ICogYyAtIHR5ICogcyArIHg7XG4gICAgdHJpYW5nbGUueTEgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgdHggPSB0cmlhbmdsZS54MiAtIHg7XG4gICAgdHkgPSB0cmlhbmdsZS55MiAtIHk7XG5cbiAgICB0cmlhbmdsZS54MiA9IHR4ICogYyAtIHR5ICogcyArIHg7XG4gICAgdHJpYW5nbGUueTIgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgdHggPSB0cmlhbmdsZS54MyAtIHg7XG4gICAgdHkgPSB0cmlhbmdsZS55MyAtIHk7XG5cbiAgICB0cmlhbmdsZS54MyA9IHR4ICogYyAtIHR5ICogcyArIHg7XG4gICAgdHJpYW5nbGUueTMgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRYWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kWFkuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2l2ZW4gMyBjb2xvciB2YWx1ZXMgdGhpcyB3aWxsIHJldHVybiBhbiBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxuICpcbiAqIEBtZXRob2QgZ2V0Q29sb3JcbiAqIEBwYXJhbSB7aW50ZWdlcn0gciAtIFRoZSByZWQgY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBibHVlIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cbiAqIEByZXR1cm4ge2ludGVnZXJ9IEEgbmF0aXZlIGNvbG9yIHZhbHVlIGludGVnZXIgKGZvcm1hdDogMHhSUkdHQkIpLlxuICovXG52YXIgR2V0Q29sb3IgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSlcbntcbiAgICByZXR1cm4gcmVkIDw8IDE2IHwgZ3JlZW4gPDwgOCB8IGJsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldENvbG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvR2V0Q29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJBQ0tTUEFDRTogOCxcbiAgICBUQUI6IDksXG4gICAgRU5URVI6IDEzLFxuXG4gICAgU0hJRlQ6IDE2LFxuICAgIENUUkw6IDE3LFxuICAgIEFMVDogMTgsXG5cbiAgICBQQVVTRTogMTksXG4gICAgQ0FQU19MT0NLOiAyMCxcbiAgICBFU0M6IDI3LFxuICAgIFNQQUNFOiAzMixcblxuICAgIFBBR0VfVVA6IDMzLFxuICAgIFBBR0VfRE9XTjogMzQsXG4gICAgRU5EOiAzNSxcbiAgICBIT01FOiAzNixcblxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDAsXG5cbiAgICBQUklOVF9TQ1JFRU46IDQyLFxuICAgIElOU0VSVDogNDUsXG4gICAgREVMRVRFOiA0NixcblxuICAgIFpFUk86IDQ4LFxuICAgIE9ORTogNDksXG4gICAgVFdPOiA1MCxcbiAgICBUSFJFRTogNTEsXG4gICAgRk9VUjogNTIsXG4gICAgRklWRTogNTMsXG4gICAgU0lYOiA1NCxcbiAgICBTRVZFTjogNTUsXG4gICAgRUlHSFQ6IDU2LFxuICAgIE5JTkU6IDU3LFxuXG4gICAgQTogNjUsXG4gICAgQjogNjYsXG4gICAgQzogNjcsXG4gICAgRDogNjgsXG4gICAgRTogNjksXG4gICAgRjogNzAsXG4gICAgRzogNzEsXG4gICAgSDogNzIsXG4gICAgSTogNzMsXG4gICAgSjogNzQsXG4gICAgSzogNzUsXG4gICAgTDogNzYsXG4gICAgTTogNzcsXG4gICAgTjogNzgsXG4gICAgTzogNzksXG4gICAgUDogODAsXG4gICAgUTogODEsXG4gICAgUjogODIsXG4gICAgUzogODMsXG4gICAgVDogODQsXG4gICAgVTogODUsXG4gICAgVjogODYsXG4gICAgVzogODcsXG4gICAgWDogODgsXG4gICAgWTogODksXG4gICAgWjogOTAsXG5cbiAgICBGMTogMTEyLFxuICAgIEYyOiAxMTMsXG4gICAgRjM6IDExNCxcbiAgICBGNDogMTE1LFxuICAgIEY1OiAxMTYsXG4gICAgRjY6IDExNyxcbiAgICBGNzogMTE4LFxuICAgIEY4OiAxMTksXG4gICAgRjk6IDEyMCxcbiAgICBGMTA6IDEyMSxcbiAgICBGMTE6IDEyMixcbiAgICBGMTI6IDEyMyxcblxuICAgIFNFTUlDT0xPTjogMTg2LFxuICAgIFBMVVM6IDE4NyxcbiAgICBDT01NQTogMTg4LFxuICAgIE1JTlVTOiAxODksXG4gICAgUEVSSU9EOiAxOTAsXG4gICAgRk9SV0FEX1NMQVNIOiAxOTEsXG4gICAgQkFDS19TTEFTSDogMjIwLFxuICAgIFFVT1RFUzogMjIyXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9LZXlDb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIENyZWF0ZXMgYW4gWEhSU2V0dGluZ3MgT2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXNcblxudmFyIFhIUlNldHRpbmdzID0gZnVuY3Rpb24gKHJlc3BvbnNlVHlwZSwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkLCB0aW1lb3V0KVxue1xuICAgIGlmIChyZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgeyByZXNwb25zZVR5cGUgPSAnJzsgfVxuICAgIGlmIChhc3luYyA9PT0gdW5kZWZpbmVkKSB7IGFzeW5jID0gdHJ1ZTsgfVxuICAgIGlmICh1c2VyID09PSB1bmRlZmluZWQpIHsgdXNlciA9ICcnOyB9XG4gICAgaWYgKHBhc3N3b3JkID09PSB1bmRlZmluZWQpIHsgcGFzc3dvcmQgPSAnJzsgfVxuICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHsgdGltZW91dCA9IDA7IH1cblxuICAgIC8vIEJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCwgc2V0IHRoZSB4aHIucmVzcG9uc2VUeXBlIHRvIFwidGV4dFwiLCBcbiAgICAvLyBcImFycmF5YnVmZmVyXCIsIFwiYmxvYlwiLCBvciBcImRvY3VtZW50XCIsIGRlcGVuZGluZyBvbiB5b3VyIGRhdGEgbmVlZHMuIFxuICAgIC8vIE5vdGUsIHNldHRpbmcgeGhyLnJlc3BvbnNlVHlwZSA9ICcnIChvciBvbWl0dGluZykgd2lsbCBkZWZhdWx0IHRoZSByZXNwb25zZSB0byBcInRleHRcIi5cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgLy8gIElnbm9yZWQgYnkgdGhlIExvYWRlciwgb25seSB1c2VkIGJ5IEZpbGUuXG4gICAgICAgIHJlc3BvbnNlVHlwZTogcmVzcG9uc2VUeXBlLFxuXG4gICAgICAgIGFzeW5jOiBhc3luYyxcblxuICAgICAgICAvLyAgY3JlZGVudGlhbHNcbiAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuXG4gICAgICAgIC8vICB0aW1lb3V0IGluIG1zICgwID0gbm8gdGltZW91dClcbiAgICAgICAgdGltZW91dDogdGltZW91dCxcblxuICAgICAgICAvLyAgc2V0UmVxdWVzdEhlYWRlclxuICAgICAgICBoZWFkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyVmFsdWU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvLyAgb3ZlcnJpZGVNaW1lVHlwZVxuICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiB1bmRlZmluZWRcblxuICAgIH07XG4gICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUlNldHRpbmdzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL1hIUlNldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heClcbntcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIHAgPSBQb2ludCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLCB0aGUgaXRlbSB0byBiZSByb3RhdGVkXG4vLyAgeC95ID0gdGhlIGNvb3JkaW5hdGUgdG8gcm90YXRlIGFyb3VuZFxuLy8gIGFuZ2xlID0gcmFkaWFuc1xuLy8gIGRpc3RhbmNlID0gaW4gcHhcblxudmFyIFJvdGF0ZUFyb3VuZERpc3RhbmNlID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5LCBhbmdsZSwgZGlzdGFuY2UpXG57XG4gICAgdmFyIHQgPSBhbmdsZSArIE1hdGguYXRhbjIocG9pbnQueSAtIHksIHBvaW50LnggLSB4KTtcblxuICAgIHBvaW50LnggPSB4ICsgKGRpc3RhbmNlICogTWF0aC5jb3ModCkpO1xuICAgIHBvaW50LnkgPSB5ICsgKGRpc3RhbmNlICogTWF0aC5zaW4odCkpO1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmREaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXN0YW5jZUJldHdlZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgdmFyIGR4ID0geDEgLSB4MjtcbiAgICB2YXIgZHkgPSB5MSAtIHkyO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvRGlzdGFuY2VCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGBNYXR0ZXIuRGV0ZWN0b3JgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyBnaXZlbiBhIHNldCBvZiBwYWlycy5cbipcbiogQGNsYXNzIERldGVjdG9yXG4qL1xuXG4vLyBUT0RPOiBzcGVjdWxhdGl2ZSBjb250YWN0c1xuXG52YXIgRGV0ZWN0b3IgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXRlY3RvcjtcblxudmFyIFNBVCA9IHJlcXVpcmUoJy4vU0FUJyk7XG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpcicpO1xudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgY29sbGlzaW9ucyBnaXZlbiBhIGxpc3Qgb2YgcGFpcnMuXG4gICAgICogQG1ldGhvZCBjb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtwYWlyW119IGJyb2FkcGhhc2VQYWlyc1xuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gY29sbGlzaW9uc1xuICAgICAqL1xuICAgIERldGVjdG9yLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihicm9hZHBoYXNlUGFpcnMsIGVuZ2luZSkge1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IGVuZ2luZS5wYWlycy50YWJsZTtcblxuICAgICAgICAvLyBAaWYgREVCVUdcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBlbmdpbmUubWV0cmljcztcbiAgICAgICAgLy8gQGVuZGlmXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb2FkcGhhc2VQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gYnJvYWRwaGFzZVBhaXJzW2ldWzBdLCBcbiAgICAgICAgICAgICAgICBib2R5QiA9IGJyb2FkcGhhc2VQYWlyc1tpXVsxXTtcblxuICAgICAgICAgICAgaWYgKChib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSAmJiAoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghRGV0ZWN0b3IuY2FuQ29sbGlkZShib2R5QS5jb2xsaXNpb25GaWx0ZXIsIGJvZHlCLmNvbGxpc2lvbkZpbHRlcikpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIEBpZiBERUJVR1xuICAgICAgICAgICAgbWV0cmljcy5taWRwaGFzZVRlc3RzICs9IDE7XG4gICAgICAgICAgICAvLyBAZW5kaWZcblxuICAgICAgICAgICAgLy8gbWlkIHBoYXNlXG4gICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKGJvZHlBLmJvdW5kcywgYm9keUIuYm91bmRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5QS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBib2R5QS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEEgPSBib2R5QS5wYXJ0c1tqXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gYm9keUIucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keUIucGFydHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IGJvZHlCLnBhcnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnRBID09PSBib2R5QSAmJiBwYXJ0QiA9PT0gYm9keUIpIHx8IEJvdW5kcy5vdmVybGFwcyhwYXJ0QS5ib3VuZHMsIHBhcnRCLmJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGEgcHJldmlvdXMgY29sbGlzaW9uIHdlIGNvdWxkIHJldXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJJZCA9IFBhaXIuaWQocGFydEEsIHBhcnRCKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpciA9IHBhaXJzVGFibGVbcGFpcklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb2xsaXNpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpciAmJiBwYWlyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb2xsaXNpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hcnJvdyBwaGFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBTQVQuY29sbGlkZXMocGFydEEsIHBhcnRCLCBwcmV2aW91c0NvbGxpc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAaWYgREVCVUdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLm5hcnJvd3BoYXNlVGVzdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLnJldXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dSZXVzZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGVuZGlmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLmNvbGxpZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnMucHVzaChjb2xsaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAaWYgREVCVUdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBlbmRpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xsaXNpb25zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIHN1cHBsaWVkIGNvbGxpc2lvbiBmaWx0ZXJzIHdpbGwgYWxsb3cgYSBjb2xsaXNpb24gdG8gb2NjdXIuXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZCBjYW5Db2xsaWRlXG4gICAgICogQHBhcmFtIHt9IGZpbHRlckFcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQlxuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiBjb2xsaXNpb24gY2FuIG9jY3VyXG4gICAgICovXG4gICAgRGV0ZWN0b3IuY2FuQ29sbGlkZSA9IGZ1bmN0aW9uKGZpbHRlckEsIGZpbHRlckIpIHtcbiAgICAgICAgaWYgKGZpbHRlckEuZ3JvdXAgPT09IGZpbHRlckIuZ3JvdXAgJiYgZmlsdGVyQS5ncm91cCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJBLmdyb3VwID4gMDtcblxuICAgICAgICByZXR1cm4gKGZpbHRlckEubWFzayAmIGZpbHRlckIuY2F0ZWdvcnkpICE9PSAwICYmIChmaWx0ZXJCLm1hc2sgJiBmaWx0ZXJBLmNhdGVnb3J5KSAhPT0gMDtcbiAgICB9O1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29sbGlzaW9uL0RldGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vRGV0ZWN0b3IuanMiLCIvKipcbiogVGhlIGBNYXR0ZXIuR3JpZGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIGJyb2FkcGhhc2UgZ3JpZCBzdHJ1Y3R1cmVzLlxuKlxuKiBAY2xhc3MgR3JpZFxuKi9cblxudmFyIEdyaWQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuXG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpcicpO1xudmFyIERldGVjdG9yID0gcmVxdWlyZSgnLi9EZXRlY3RvcicpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZ3JpZC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7Z3JpZH0gQSBuZXcgZ3JpZFxuICAgICAqL1xuICAgIEdyaWQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb250cm9sbGVyOiBHcmlkLFxuICAgICAgICAgICAgZGV0ZWN0b3I6IERldGVjdG9yLmNvbGxpc2lvbnMsXG4gICAgICAgICAgICBidWNrZXRzOiB7fSxcbiAgICAgICAgICAgIHBhaXJzOiB7fSxcbiAgICAgICAgICAgIHBhaXJzTGlzdDogW10sXG4gICAgICAgICAgICBidWNrZXRXaWR0aDogNDgsXG4gICAgICAgICAgICBidWNrZXRIZWlnaHQ6IDQ4XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgYSBzaW5nbGUgZ3JpZCBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnVja2V0V2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA0OFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRIZWlnaHRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA0OFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ3JpZC5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Z3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVVwZGF0ZVxuICAgICAqL1xuICAgIEdyaWQudXBkYXRlID0gZnVuY3Rpb24oZ3JpZCwgYm9kaWVzLCBlbmdpbmUsIGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBpLCBjb2wsIHJvdyxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgYnVja2V0cyA9IGdyaWQuYnVja2V0cyxcbiAgICAgICAgICAgIGJ1Y2tldCxcbiAgICAgICAgICAgIGJ1Y2tldElkLFxuICAgICAgICAgICAgZ3JpZENoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBAaWYgREVCVUdcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBlbmdpbmUubWV0cmljcztcbiAgICAgICAgbWV0cmljcy5icm9hZHBoYXNlVGVzdHMgPSAwO1xuICAgICAgICAvLyBAZW5kaWZcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTbGVlcGluZyAmJiAhZm9yY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHVwZGF0ZSBvdXQgb2Ygd29ybGQgYm9kaWVzXG4gICAgICAgICAgICBpZiAoYm9keS5ib3VuZHMubWF4LnggPCB3b3JsZC5ib3VuZHMubWluLnggfHwgYm9keS5ib3VuZHMubWluLnggPiB3b3JsZC5ib3VuZHMubWF4LnhcbiAgICAgICAgICAgICAgICB8fCBib2R5LmJvdW5kcy5tYXgueSA8IHdvcmxkLmJvdW5kcy5taW4ueSB8fCBib2R5LmJvdW5kcy5taW4ueSA+IHdvcmxkLmJvdW5kcy5tYXgueSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIG5ld1JlZ2lvbiA9IF9nZXRSZWdpb24oZ3JpZCwgYm9keSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBib2R5IGhhcyBjaGFuZ2VkIGdyaWQgcmVnaW9uXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IG5ld1JlZ2lvbi5pZCAhPT0gYm9keS5yZWdpb24uaWQgfHwgZm9yY2VVcGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIEBpZiBERUJVR1xuICAgICAgICAgICAgICAgIG1ldHJpY3MuYnJvYWRwaGFzZVRlc3RzICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gQGVuZGlmXG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IGZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBib2R5LnJlZ2lvbiA9IG5ld1JlZ2lvbjtcblxuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IF9yZWdpb25VbmlvbihuZXdSZWdpb24sIGJvZHkucmVnaW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBncmlkIGJ1Y2tldHMgYWZmZWN0ZWQgYnkgcmVnaW9uIGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgdW5pb24gb2YgYm90aCByZWdpb25zXG4gICAgICAgICAgICAgICAgZm9yIChjb2wgPSB1bmlvbi5zdGFydENvbDsgY29sIDw9IHVuaW9uLmVuZENvbDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSB1bmlvbi5zdGFydFJvdzsgcm93IDw9IHVuaW9uLmVuZFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldElkID0gX2dldEJ1Y2tldElkKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IGJ1Y2tldHNbYnVja2V0SWRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJbnNpZGVOZXdSZWdpb24gPSAoY29sID49IG5ld1JlZ2lvbi5zdGFydENvbCAmJiBjb2wgPD0gbmV3UmVnaW9uLmVuZENvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcm93ID49IG5ld1JlZ2lvbi5zdGFydFJvdyAmJiByb3cgPD0gbmV3UmVnaW9uLmVuZFJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luc2lkZU9sZFJlZ2lvbiA9IChjb2wgPj0gYm9keS5yZWdpb24uc3RhcnRDb2wgJiYgY29sIDw9IGJvZHkucmVnaW9uLmVuZENvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcm93ID49IGJvZHkucmVnaW9uLnN0YXJ0Um93ICYmIHJvdyA8PSBib2R5LnJlZ2lvbi5lbmRSb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBvbGQgcmVnaW9uIGJ1Y2tldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnNpZGVOZXdSZWdpb24gJiYgaXNJbnNpZGVPbGRSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnNpZGVPbGRSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Y2tldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9idWNrZXRSZW1vdmVCb2R5KGdyaWQsIGJ1Y2tldCwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gbmV3IHJlZ2lvbiBidWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5yZWdpb24gPT09IG5ld1JlZ2lvbiB8fCAoaXNJbnNpZGVOZXdSZWdpb24gJiYgIWlzSW5zaWRlT2xkUmVnaW9uKSB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVja2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBfY3JlYXRlQnVja2V0KGJ1Y2tldHMsIGJ1Y2tldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYnVja2V0QWRkQm9keShncmlkLCBidWNrZXQsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBuZXcgcmVnaW9uXG4gICAgICAgICAgICAgICAgYm9keS5yZWdpb24gPSBuZXdSZWdpb247XG5cbiAgICAgICAgICAgICAgICAvLyBmbGFnIGNoYW5nZXMgc28gd2UgY2FuIHVwZGF0ZSBwYWlyc1xuICAgICAgICAgICAgICAgIGdyaWRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBwYWlycyBsaXN0IG9ubHkgaWYgcGFpcnMgY2hhbmdlZCAoaS5lLiBhIGJvZHkgY2hhbmdlZCByZWdpb24pXG4gICAgICAgIGlmIChncmlkQ2hhbmdlZClcbiAgICAgICAgICAgIGdyaWQucGFpcnNMaXN0ID0gX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdChncmlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmlkLlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge2dyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBHcmlkLmNsZWFyID0gZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBncmlkLmJ1Y2tldHMgPSB7fTtcbiAgICAgICAgZ3JpZC5wYWlycyA9IHt9O1xuICAgICAgICBncmlkLnBhaXJzTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgdW5pb24gb2YgdHdvIHJlZ2lvbnMuXG4gICAgICogQG1ldGhvZCBfcmVnaW9uVW5pb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSByZWdpb25BXG4gICAgICogQHBhcmFtIHt9IHJlZ2lvbkJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxuICAgICAqL1xuICAgIHZhciBfcmVnaW9uVW5pb24gPSBmdW5jdGlvbihyZWdpb25BLCByZWdpb25CKSB7XG4gICAgICAgIHZhciBzdGFydENvbCA9IE1hdGgubWluKHJlZ2lvbkEuc3RhcnRDb2wsIHJlZ2lvbkIuc3RhcnRDb2wpLFxuICAgICAgICAgICAgZW5kQ29sID0gTWF0aC5tYXgocmVnaW9uQS5lbmRDb2wsIHJlZ2lvbkIuZW5kQ29sKSxcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gTWF0aC5taW4ocmVnaW9uQS5zdGFydFJvdywgcmVnaW9uQi5zdGFydFJvdyksXG4gICAgICAgICAgICBlbmRSb3cgPSBNYXRoLm1heChyZWdpb25BLmVuZFJvdywgcmVnaW9uQi5lbmRSb3cpO1xuXG4gICAgICAgIHJldHVybiBfY3JlYXRlUmVnaW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZWdpb24gYSBnaXZlbiBib2R5IGZhbGxzIGluIGZvciBhIGdpdmVuIGdyaWQuXG4gICAgICogQG1ldGhvZCBfZ2V0UmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBib2R5XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICB2YXIgX2dldFJlZ2lvbiA9IGZ1bmN0aW9uKGdyaWQsIGJvZHkpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGJvZHkuYm91bmRzLFxuICAgICAgICAgICAgc3RhcnRDb2wgPSBNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAvIGdyaWQuYnVja2V0V2lkdGgpLFxuICAgICAgICAgICAgZW5kQ29sID0gTWF0aC5mbG9vcihib3VuZHMubWF4LnggLyBncmlkLmJ1Y2tldFdpZHRoKSxcbiAgICAgICAgICAgIHN0YXJ0Um93ID0gTWF0aC5mbG9vcihib3VuZHMubWluLnkgLyBncmlkLmJ1Y2tldEhlaWdodCksXG4gICAgICAgICAgICBlbmRSb3cgPSBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAvIGdyaWQuYnVja2V0SGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gX2NyZWF0ZVJlZ2lvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlZ2lvbi5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVSZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBzdGFydENvbFxuICAgICAqIEBwYXJhbSB7fSBlbmRDb2xcbiAgICAgKiBAcGFyYW0ge30gc3RhcnRSb3dcbiAgICAgKiBAcGFyYW0ge30gZW5kUm93XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZVJlZ2lvbiA9IGZ1bmN0aW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpIHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBpZDogc3RhcnRDb2wgKyAnLCcgKyBlbmRDb2wgKyAnLCcgKyBzdGFydFJvdyArICcsJyArIGVuZFJvdyxcbiAgICAgICAgICAgIHN0YXJ0Q29sOiBzdGFydENvbCwgXG4gICAgICAgICAgICBlbmRDb2w6IGVuZENvbCwgXG4gICAgICAgICAgICBzdGFydFJvdzogc3RhcnRSb3csIFxuICAgICAgICAgICAgZW5kUm93OiBlbmRSb3cgXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJ1Y2tldCBpZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQG1ldGhvZCBfZ2V0QnVja2V0SWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge30gcm93XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBidWNrZXQgaWRcbiAgICAgKi9cbiAgICB2YXIgX2dldEJ1Y2tldElkID0gZnVuY3Rpb24oY29sdW1uLCByb3cpIHtcbiAgICAgICAgcmV0dXJuICdDJyArIGNvbHVtbiArICdSJyArIHJvdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVCdWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRzXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldElkXG4gICAgICogQHJldHVybiB7fSBidWNrZXRcbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uKGJ1Y2tldHMsIGJ1Y2tldElkKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXSA9IFtdO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYm9keSB0byBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRBZGRCb2R5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIHZhciBfYnVja2V0QWRkQm9keSA9IGZ1bmN0aW9uKGdyaWQsIGJ1Y2tldCwgYm9keSkge1xuICAgICAgICAvLyBhZGQgbmV3IHBhaXJzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUIgPSBidWNrZXRbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LmlkID09PSBib2R5Qi5pZCB8fCAoYm9keS5pc1N0YXRpYyAmJiBib2R5Qi5pc1N0YXRpYykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBidWNrZXRzIHRoZSBwYWlyIGV4aXN0cyBpblxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBHcmlkLnVwZGF0ZSB0byB3b3JrXG4gICAgICAgICAgICB2YXIgcGFpcklkID0gUGFpci5pZChib2R5LCBib2R5QiksXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcklkXTtcblxuICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBwYWlyWzJdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyaWQucGFpcnNbcGFpcklkXSA9IFtib2R5LCBib2R5QiwgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdG8gYm9kaWVzIChhZnRlciBwYWlycywgb3RoZXJ3aXNlIHBhaXJzIHdpdGggc2VsZilcbiAgICAgICAgYnVja2V0LnB1c2goYm9keSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBib2R5IGZyb20gYSBidWNrZXQuXG4gICAgICogQG1ldGhvZCBfYnVja2V0UmVtb3ZlQm9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGdyaWRcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0XG4gICAgICogQHBhcmFtIHt9IGJvZHlcbiAgICAgKi9cbiAgICB2YXIgX2J1Y2tldFJlbW92ZUJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gYnVja2V0XG4gICAgICAgIGJ1Y2tldC5zcGxpY2UoQ29tbW9uLmluZGV4T2YoYnVja2V0LCBib2R5KSwgMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhaXIgY291bnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCB0byB3b3JrXG4gICAgICAgICAgICB2YXIgYm9keUIgPSBidWNrZXRbaV0sXG4gICAgICAgICAgICAgICAgcGFpcklkID0gUGFpci5pZChib2R5LCBib2R5QiksXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcklkXTtcblxuICAgICAgICAgICAgaWYgKHBhaXIpXG4gICAgICAgICAgICAgICAgcGFpclsyXSAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxpc3Qgb2YgdGhlIGFjdGl2ZSBwYWlycyBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVBY3RpdmVQYWlyc0xpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBncmlkXG4gICAgICogQHJldHVybiBbXSBwYWlyc1xuICAgICAqL1xuICAgIHZhciBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0ID0gZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgcGFpcktleXMsXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgcGFpcnMgPSBbXTtcblxuICAgICAgICAvLyBncmlkLnBhaXJzIGlzIHVzZWQgYXMgYSBoYXNobWFwXG4gICAgICAgIHBhaXJLZXlzID0gQ29tbW9uLmtleXMoZ3JpZC5wYWlycyk7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGdyaWQucGFpcnNcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYWlyS2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcGFpciA9IGdyaWQucGFpcnNbcGFpcktleXNba11dO1xuXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGV4aXN0cyBpbiBhdCBsZWFzdCBvbmUgYnVja2V0XG4gICAgICAgICAgICAvLyBpdCBpcyBhIHBhaXIgdGhhdCBuZWVkcyBmdXJ0aGVyIGNvbGxpc2lvbiB0ZXN0aW5nIHNvIHB1c2ggaXRcbiAgICAgICAgICAgIGlmIChwYWlyWzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBncmlkLnBhaXJzW3BhaXJLZXlzW2tdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9O1xuICAgIFxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9HcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vR3JpZC5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5TQVRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyB1c2luZyB0aGUgU2VwYXJhdGluZyBBeGlzIFRoZW9yZW0uXG4qXG4qIEBjbGFzcyBTQVRcbiovXG5cbi8vIFRPRE86IHRydWUgY2lyY2xlcyBhbmQgY3VydmVzXG5cbnZhciBTQVQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVQ7XG5cbnZhciBWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlcnRpY2VzJyk7XG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzIHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbS5cbiAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gcHJldmlvdXNDb2xsaXNpb25cbiAgICAgKiBAcmV0dXJuIHtjb2xsaXNpb259IGNvbGxpc2lvblxuICAgICAqL1xuICAgIFNBVC5jb2xsaWRlcyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5QiwgcHJldmlvdXNDb2xsaXNpb24pIHtcbiAgICAgICAgdmFyIG92ZXJsYXBBQixcbiAgICAgICAgICAgIG92ZXJsYXBCQSwgXG4gICAgICAgICAgICBtaW5PdmVybGFwLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgY2FuUmV1c2VQcmV2Q29sID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzQ29sbGlzaW9uKSB7XG4gICAgICAgICAgICAvLyBlc3RpbWF0ZSB0b3RhbCBtb3Rpb25cbiAgICAgICAgICAgIHZhciBwYXJlbnRBID0gYm9keUEucGFyZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudEIgPSBib2R5Qi5wYXJlbnQsXG4gICAgICAgICAgICAgICAgbW90aW9uID0gcGFyZW50QS5zcGVlZCAqIHBhcmVudEEuc3BlZWQgKyBwYXJlbnRBLmFuZ3VsYXJTcGVlZCAqIHBhcmVudEEuYW5ndWxhclNwZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICsgcGFyZW50Qi5zcGVlZCAqIHBhcmVudEIuc3BlZWQgKyBwYXJlbnRCLmFuZ3VsYXJTcGVlZCAqIHBhcmVudEIuYW5ndWxhclNwZWVkO1xuXG4gICAgICAgICAgICAvLyB3ZSBtYXkgYmUgYWJsZSB0byAocGFydGlhbGx5KSByZXVzZSBjb2xsaXNpb24gcmVzdWx0IFxuICAgICAgICAgICAgLy8gYnV0IG9ubHkgc2FmZSBpZiBjb2xsaXNpb24gd2FzIHJlc3RpbmdcbiAgICAgICAgICAgIGNhblJldXNlUHJldkNvbCA9IHByZXZpb3VzQ29sbGlzaW9uICYmIHByZXZpb3VzQ29sbGlzaW9uLmNvbGxpZGVkICYmIG1vdGlvbiA8IDAuMjtcblxuICAgICAgICAgICAgLy8gcmV1c2UgY29sbGlzaW9uIG9iamVjdFxuICAgICAgICAgICAgY29sbGlzaW9uID0gcHJldmlvdXNDb2xsaXNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsaXNpb24gPSB7IGNvbGxpZGVkOiBmYWxzZSwgYm9keUE6IGJvZHlBLCBib2R5QjogYm9keUIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aW91c0NvbGxpc2lvbiAmJiBjYW5SZXVzZVByZXZDb2wpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbiByZXVzZSB0aGUgY29sbGlzaW9uIHJlc3VsdFxuICAgICAgICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHRlc3QgdGhlIHByZXZpb3VzbHkgZm91bmQgYXhpc1xuICAgICAgICAgICAgdmFyIGF4aXNCb2R5QSA9IGNvbGxpc2lvbi5heGlzQm9keSxcbiAgICAgICAgICAgICAgICBheGlzQm9keUIgPSBheGlzQm9keUEgPT09IGJvZHlBID8gYm9keUIgOiBib2R5QSxcbiAgICAgICAgICAgICAgICBheGVzID0gW2F4aXNCb2R5QS5heGVzW3ByZXZpb3VzQ29sbGlzaW9uLmF4aXNOdW1iZXJdXTtcblxuICAgICAgICAgICAgbWluT3ZlcmxhcCA9IF9vdmVybGFwQXhlcyhheGlzQm9keUEudmVydGljZXMsIGF4aXNCb2R5Qi52ZXJ0aWNlcywgYXhlcyk7XG4gICAgICAgICAgICBjb2xsaXNpb24ucmV1c2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG1pbk92ZXJsYXAub3ZlcmxhcCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IHJldXNlIGEgcmVzdWx0LCBwZXJmb3JtIGEgZnVsbCBTQVQgdGVzdFxuXG4gICAgICAgICAgICBvdmVybGFwQUIgPSBfb3ZlcmxhcEF4ZXMoYm9keUEudmVydGljZXMsIGJvZHlCLnZlcnRpY2VzLCBib2R5QS5heGVzKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBBQi5vdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdmVybGFwQkEgPSBfb3ZlcmxhcEF4ZXMoYm9keUIudmVydGljZXMsIGJvZHlBLnZlcnRpY2VzLCBib2R5Qi5heGVzKTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXBCQS5vdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3ZlcmxhcEFCLm92ZXJsYXAgPCBvdmVybGFwQkEub3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwQUI7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmF4aXNCb2R5ID0gYm9keUE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwQkE7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmF4aXNCb2R5ID0gYm9keUI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgcmV1c2UgbGF0ZXJcbiAgICAgICAgICAgIGNvbGxpc2lvbi5heGlzTnVtYmVyID0gbWluT3ZlcmxhcC5heGlzTnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGlzaW9uLmJvZHlBID0gYm9keUEuaWQgPCBib2R5Qi5pZCA/IGJvZHlBIDogYm9keUI7XG4gICAgICAgIGNvbGxpc2lvbi5ib2R5QiA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QiA6IGJvZHlBO1xuICAgICAgICBjb2xsaXNpb24uY29sbGlkZWQgPSB0cnVlO1xuICAgICAgICBjb2xsaXNpb24uZGVwdGggPSBtaW5PdmVybGFwLm92ZXJsYXA7XG4gICAgICAgIGNvbGxpc2lvbi5wYXJlbnRBID0gY29sbGlzaW9uLmJvZHlBLnBhcmVudDtcbiAgICAgICAgY29sbGlzaW9uLnBhcmVudEIgPSBjb2xsaXNpb24uYm9keUIucGFyZW50O1xuICAgICAgICBcbiAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUE7XG4gICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCO1xuXG4gICAgICAgIC8vIGVuc3VyZSBub3JtYWwgaXMgZmFjaW5nIGF3YXkgZnJvbSBib2R5QVxuICAgICAgICBpZiAoVmVjdG9yLmRvdChtaW5PdmVybGFwLmF4aXMsIFZlY3Rvci5zdWIoYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKSkgPCAwKSB7XG4gICAgICAgICAgICBjb2xsaXNpb24ubm9ybWFsID0ge1xuICAgICAgICAgICAgICAgIHg6IG1pbk92ZXJsYXAuYXhpcy54LFxuICAgICAgICAgICAgICAgIHk6IG1pbk92ZXJsYXAuYXhpcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlzaW9uLm5vcm1hbCA9IHtcbiAgICAgICAgICAgICAgICB4OiAtbWluT3ZlcmxhcC5heGlzLngsXG4gICAgICAgICAgICAgICAgeTogLW1pbk92ZXJsYXAuYXhpcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGlzaW9uLnRhbmdlbnQgPSBWZWN0b3IucGVycChjb2xsaXNpb24ubm9ybWFsKTtcblxuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24gPSBjb2xsaXNpb24ucGVuZXRyYXRpb24gfHwge307XG4gICAgICAgIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi54ID0gY29sbGlzaW9uLm5vcm1hbC54ICogY29sbGlzaW9uLmRlcHRoO1xuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSA9IGNvbGxpc2lvbi5ub3JtYWwueSAqIGNvbGxpc2lvbi5kZXB0aDsgXG5cbiAgICAgICAgLy8gZmluZCBzdXBwb3J0IHBvaW50cywgdGhlcmUgaXMgYWx3YXlzIGVpdGhlciBleGFjdGx5IG9uZSBvciB0d29cbiAgICAgICAgdmFyIHZlcnRpY2VzQiA9IF9maW5kU3VwcG9ydHMoYm9keUEsIGJvZHlCLCBjb2xsaXNpb24ubm9ybWFsKSxcbiAgICAgICAgICAgIHN1cHBvcnRzID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgc3VwcG9ydHMgZnJvbSBib2R5QiB0aGF0IGFyZSBpbnNpZGUgYm9keUFcbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCB2ZXJ0aWNlc0JbMF0pKVxuICAgICAgICAgICAgc3VwcG9ydHMucHVzaCh2ZXJ0aWNlc0JbMF0pO1xuXG4gICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5QS52ZXJ0aWNlcywgdmVydGljZXNCWzFdKSlcbiAgICAgICAgICAgIHN1cHBvcnRzLnB1c2godmVydGljZXNCWzFdKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBzdXBwb3J0cyBmcm9tIGJvZHlBIHRoYXQgYXJlIGluc2lkZSBib2R5QlxuICAgICAgICBpZiAoc3VwcG9ydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzQSA9IF9maW5kU3VwcG9ydHMoYm9keUIsIGJvZHlBLCBWZWN0b3IubmVnKGNvbGxpc2lvbi5ub3JtYWwpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5Qi52ZXJ0aWNlcywgdmVydGljZXNBWzBdKSlcbiAgICAgICAgICAgICAgICBzdXBwb3J0cy5wdXNoKHZlcnRpY2VzQVswXSk7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0cy5sZW5ndGggPCAyICYmIFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlCLnZlcnRpY2VzLCB2ZXJ0aWNlc0FbMV0pKVxuICAgICAgICAgICAgICAgIHN1cHBvcnRzLnB1c2godmVydGljZXNBWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBlZGdlIGNhc2Ugb2Ygb3ZlcmxhcHBpbmcgYnV0IG5vIHZlcnRleCBjb250YWlubWVudFxuICAgICAgICBpZiAoc3VwcG9ydHMubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgIHN1cHBvcnRzID0gW3ZlcnRpY2VzQlswXV07XG4gICAgICAgIFxuICAgICAgICBjb2xsaXNpb24uc3VwcG9ydHMgPSBzdXBwb3J0cztcblxuICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvdmVybGFwIGJldHdlZW4gdHdvIHNldHMgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBfb3ZlcmxhcEF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSB2ZXJ0aWNlc0FcbiAgICAgKiBAcGFyYW0ge30gdmVydGljZXNCXG4gICAgICogQHBhcmFtIHt9IGF4ZXNcbiAgICAgKiBAcmV0dXJuIHJlc3VsdFxuICAgICAqL1xuICAgIHZhciBfb3ZlcmxhcEF4ZXMgPSBmdW5jdGlvbih2ZXJ0aWNlc0EsIHZlcnRpY2VzQiwgYXhlcykge1xuICAgICAgICB2YXIgcHJvamVjdGlvbkEgPSBWZWN0b3IuX3RlbXBbMF0sIFxuICAgICAgICAgICAgcHJvamVjdGlvbkIgPSBWZWN0b3IuX3RlbXBbMV0sXG4gICAgICAgICAgICByZXN1bHQgPSB7IG92ZXJsYXA6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgIG92ZXJsYXAsXG4gICAgICAgICAgICBheGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXhpcyA9IGF4ZXNbaV07XG5cbiAgICAgICAgICAgIF9wcm9qZWN0VG9BeGlzKHByb2plY3Rpb25BLCB2ZXJ0aWNlc0EsIGF4aXMpO1xuICAgICAgICAgICAgX3Byb2plY3RUb0F4aXMocHJvamVjdGlvbkIsIHZlcnRpY2VzQiwgYXhpcyk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBNYXRoLm1pbihwcm9qZWN0aW9uQS5tYXggLSBwcm9qZWN0aW9uQi5taW4sIHByb2plY3Rpb25CLm1heCAtIHByb2plY3Rpb25BLm1pbik7XG5cbiAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQub3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCByZXN1bHQub3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXhpcyA9IGF4aXM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF4aXNOdW1iZXIgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvamVjdHMgdmVydGljZXMgb24gYW4gYXhpcyBhbmQgcmV0dXJucyBhbiBpbnRlcnZhbC5cbiAgICAgKiBAbWV0aG9kIF9wcm9qZWN0VG9BeGlzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gcHJvamVjdGlvblxuICAgICAqIEBwYXJhbSB7fSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7fSBheGlzXG4gICAgICovXG4gICAgdmFyIF9wcm9qZWN0VG9BeGlzID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgdmVydGljZXMsIGF4aXMpIHtcbiAgICAgICAgdmFyIG1pbiA9IFZlY3Rvci5kb3QodmVydGljZXNbMF0sIGF4aXMpLFxuICAgICAgICAgICAgbWF4ID0gbWluO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBkb3QgPSBWZWN0b3IuZG90KHZlcnRpY2VzW2ldLCBheGlzKTtcblxuICAgICAgICAgICAgaWYgKGRvdCA+IG1heCkgeyBcbiAgICAgICAgICAgICAgICBtYXggPSBkb3Q7IFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb3QgPCBtaW4pIHsgXG4gICAgICAgICAgICAgICAgbWluID0gZG90OyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2plY3Rpb24ubWluID0gbWluO1xuICAgICAgICBwcm9qZWN0aW9uLm1heCA9IG1heDtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEZpbmRzIHN1cHBvcnRpbmcgdmVydGljZXMgZ2l2ZW4gdHdvIGJvZGllcyBhbG9uZyBhIGdpdmVuIGRpcmVjdGlvbiB1c2luZyBoaWxsLWNsaW1iaW5nLlxuICAgICAqIEBtZXRob2QgX2ZpbmRTdXBwb3J0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGJvZHlBXG4gICAgICogQHBhcmFtIHt9IGJvZHlCXG4gICAgICogQHBhcmFtIHt9IG5vcm1hbFxuICAgICAqIEByZXR1cm4gW3ZlY3Rvcl1cbiAgICAgKi9cbiAgICB2YXIgX2ZpbmRTdXBwb3J0cyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgbm9ybWFsKSB7XG4gICAgICAgIHZhciBuZWFyZXN0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgdmVydGV4VG9Cb2R5ID0gVmVjdG9yLl90ZW1wWzBdLFxuICAgICAgICAgICAgdmVydGljZXMgPSBib2R5Qi52ZXJ0aWNlcyxcbiAgICAgICAgICAgIGJvZHlBUG9zaXRpb24gPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgICAgdmVydGV4LFxuICAgICAgICAgICAgdmVydGV4QSxcbiAgICAgICAgICAgIHZlcnRleEI7XG5cbiAgICAgICAgLy8gZmluZCBjbG9zZXN0IHZlcnRleCBvbiBib2R5QlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZlcnRleFRvQm9keS54ID0gdmVydGV4LnggLSBib2R5QVBvc2l0aW9uLng7XG4gICAgICAgICAgICB2ZXJ0ZXhUb0JvZHkueSA9IHZlcnRleC55IC0gYm9keUFQb3NpdGlvbi55O1xuICAgICAgICAgICAgZGlzdGFuY2UgPSAtVmVjdG9yLmRvdChub3JtYWwsIHZlcnRleFRvQm9keSk7XG5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZlcnRleEEgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG5leHQgY2xvc2VzdCB2ZXJ0ZXggdXNpbmcgdGhlIHR3byBjb25uZWN0ZWQgdG8gaXRcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IHZlcnRleEEuaW5kZXggLSAxID49IDAgPyB2ZXJ0ZXhBLmluZGV4IC0gMSA6IHZlcnRpY2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW3ByZXZJbmRleF07XG4gICAgICAgIHZlcnRleFRvQm9keS54ID0gdmVydGV4LnggLSBib2R5QVBvc2l0aW9uLng7XG4gICAgICAgIHZlcnRleFRvQm9keS55ID0gdmVydGV4LnkgLSBib2R5QVBvc2l0aW9uLnk7XG4gICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IC1WZWN0b3IuZG90KG5vcm1hbCwgdmVydGV4VG9Cb2R5KTtcbiAgICAgICAgdmVydGV4QiA9IHZlcnRleDtcblxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gKHZlcnRleEEuaW5kZXggKyAxKSAlIHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbbmV4dEluZGV4XTtcbiAgICAgICAgdmVydGV4VG9Cb2R5LnggPSB2ZXJ0ZXgueCAtIGJvZHlBUG9zaXRpb24ueDtcbiAgICAgICAgdmVydGV4VG9Cb2R5LnkgPSB2ZXJ0ZXgueSAtIGJvZHlBUG9zaXRpb24ueTtcbiAgICAgICAgZGlzdGFuY2UgPSAtVmVjdG9yLmRvdChub3JtYWwsIHZlcnRleFRvQm9keSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgdmVydGV4QiA9IHZlcnRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbdmVydGV4QSwgdmVydGV4Ql07XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9TQVQuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9TQVQuanMiLCIvKipcbiogVGhlIGBNYXR0ZXIuTW91c2VgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIG1vdXNlIGlucHV0cy5cbipcbiogQGNsYXNzIE1vdXNlXG4qL1xuXG52YXIgTW91c2UgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZTtcblxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtb3VzZSBpbnB1dC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHttb3VzZX0gQSBuZXcgbW91c2VcbiAgICAgKi9cbiAgICBNb3VzZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBtb3VzZSA9IHt9O1xuXG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgQ29tbW9uLmxvZygnTW91c2UuY3JlYXRlOiBlbGVtZW50IHdhcyB1bmRlZmluZWQsIGRlZmF1bHRpbmcgdG8gZG9jdW1lbnQuYm9keScsICd3YXJuJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG1vdXNlLmVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIG1vdXNlLmFic29sdXRlID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLm1vdXNlZG93blBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5vZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2Uuc2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IDA7XG4gICAgICAgIG1vdXNlLmJ1dHRvbiA9IC0xO1xuICAgICAgICBtb3VzZS5waXhlbFJhdGlvID0gbW91c2UuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGl4ZWwtcmF0aW8nKSB8fCAxO1xuXG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cyA9IHtcbiAgICAgICAgICAgIG1vdXNlbW92ZTogbnVsbCxcbiAgICAgICAgICAgIG1vdXNlZG93bjogbnVsbCxcbiAgICAgICAgICAgIG1vdXNldXA6IG51bGwsXG4gICAgICAgICAgICBtb3VzZXdoZWVsOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBtb3VzZS5tb3VzZW1vdmUgPSBmdW5jdGlvbihldmVudCkgeyBcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24oZXZlbnQsIG1vdXNlLmVsZW1lbnQsIG1vdXNlLnBpeGVsUmF0aW8pLFxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSAwO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgICAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZSA9IGV2ZW50O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW91c2UubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24oZXZlbnQsIG1vdXNlLmVsZW1lbnQsIG1vdXNlLnBpeGVsUmF0aW8pLFxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSAwO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbi54ID0gbW91c2UucG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLm1vdXNlZG93blBvc2l0aW9uLnkgPSBtb3VzZS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlZG93biA9IGV2ZW50O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW91c2UubW91c2V1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gLTE7XG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICAgICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbi54ID0gbW91c2UucG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLm1vdXNldXBQb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZXVwID0gZXZlbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgbW91c2UubW91c2V3aGVlbCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGV2ZW50LndoZWVsRGVsdGEgfHwgLWV2ZW50LmRldGFpbCkpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBNb3VzZS5zZXRFbGVtZW50KG1vdXNlLCBtb3VzZS5lbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gbW91c2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsZW1lbnQgdGhlIG1vdXNlIGlzIGJvdW5kIHRvIChhbmQgcmVsYXRpdmUgdG8pLlxuICAgICAqIEBtZXRob2Qgc2V0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIE1vdXNlLnNldEVsZW1lbnQgPSBmdW5jdGlvbihtb3VzZSwgZWxlbWVudCkge1xuICAgICAgICBtb3VzZS5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlLm1vdXNlbW92ZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2UubW91c2Vkb3duKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2UubW91c2V1cCk7XG4gICAgICAgIFxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZS5tb3VzZXdoZWVsKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG1vdXNlLm1vdXNld2hlZWwpO1xuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW91c2UubW91c2Vtb3ZlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgbW91c2UubW91c2Vkb3duKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlLm1vdXNldXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNhcHR1cmVkIHNvdXJjZSBldmVudHMuXG4gICAgICogQG1ldGhvZCBjbGVhclNvdXJjZUV2ZW50c1xuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICovXG4gICAgTW91c2UuY2xlYXJTb3VyY2VFdmVudHMgPSBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlZG93biA9IG51bGw7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZXVwID0gbnVsbDtcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNld2hlZWwgPSBudWxsO1xuICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW91c2UgcG9zaXRpb24gb2Zmc2V0LlxuICAgICAqIEBtZXRob2Qgc2V0T2Zmc2V0XG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gb2Zmc2V0XG4gICAgICovXG4gICAgTW91c2Uuc2V0T2Zmc2V0ID0gZnVuY3Rpb24obW91c2UsIG9mZnNldCkge1xuICAgICAgICBtb3VzZS5vZmZzZXQueCA9IG9mZnNldC54O1xuICAgICAgICBtb3VzZS5vZmZzZXQueSA9IG9mZnNldC55O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vdXNlIHBvc2l0aW9uIHNjYWxlLlxuICAgICAqIEBtZXRob2Qgc2V0U2NhbGVcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBzY2FsZVxuICAgICAqL1xuICAgIE1vdXNlLnNldFNjYWxlID0gZnVuY3Rpb24obW91c2UsIHNjYWxlKSB7XG4gICAgICAgIG1vdXNlLnNjYWxlLnggPSBzY2FsZS54O1xuICAgICAgICBtb3VzZS5zY2FsZS55ID0gc2NhbGUueTtcbiAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gYW4gZWxlbWVudCBnaXZlbiBhIHNjcmVlbiBwaXhlbCByYXRpby5cbiAgICAgKiBAbWV0aG9kIF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBldmVudFxuICAgICAqIEBwYXJhbSB7fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW9cbiAgICAgKiBAcmV0dXJuIHt9XG4gICAgICovXG4gICAgdmFyIF9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWxlbWVudCwgcGl4ZWxSYXRpbykge1xuICAgICAgICB2YXIgZWxlbWVudEJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICByb290Tm9kZSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgc2Nyb2xsWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxUb3AsXG4gICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgICB4LCB5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgIHggPSB0b3VjaGVzWzBdLnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSB0b3VjaGVzWzBdLnBhZ2VZIC0gZWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSBldmVudC5wYWdlWSAtIGVsZW1lbnRCb3VuZHMudG9wIC0gc2Nyb2xsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgeDogeCAvIChlbGVtZW50LmNsaWVudFdpZHRoIC8gKGVsZW1lbnQud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCkgKiBwaXhlbFJhdGlvKSxcbiAgICAgICAgICAgIHk6IHkgLyAoZWxlbWVudC5jbGllbnRIZWlnaHQgLyAoZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQpICogcGl4ZWxSYXRpbylcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Nb3VzZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29yZS9Nb3VzZS5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Cb2RpZXNgIG1vZHVsZSBjb250YWlucyBmYWN0b3J5IG1ldGhvZHMgZm9yIGNyZWF0aW5nIHJpZ2lkIGJvZHkgbW9kZWxzIFxuKiB3aXRoIGNvbW1vbmx5IHVzZWQgYm9keSBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucykuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBCb2RpZXNcbiovXG5cbi8vIFRPRE86IHRydWUgY2lyY2xlIGJvZGllc1xuXG52YXIgQm9kaWVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQm9kaWVzO1xuXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIGRlY29tcCA9IHJlcXVpcmUoJy4uLy4uL3BvbHktZGVjb21wLycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIHJlY3RhbmdsZSBodWxsLiBcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHJlY3RhbmdsZSBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLnJlY3RhbmdsZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIHJlY3RhbmdsZSA9IHsgXG4gICAgICAgICAgICBsYWJlbDogJ1JlY3RhbmdsZSBCb2R5JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBWZXJ0aWNlcy5mcm9tUGF0aCgnTCAwIDAgTCAnICsgd2lkdGggKyAnIDAgTCAnICsgd2lkdGggKyAnICcgKyBoZWlnaHQgKyAnIEwgMCAnICsgaGVpZ2h0KVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW1mZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICAgICAgcmVjdGFuZ2xlLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihyZWN0YW5nbGUudmVydGljZXMsIGNoYW1mZXIucmFkaXVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCByZWN0YW5nbGUsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbCB3aXRoIGEgdHJhcGV6b2lkIGh1bGwuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgdHJhcGV6b2lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvcGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7Ym9keX0gQSBuZXcgdHJhcGV6b2lkIGJvZHlcbiAgICAgKi9cbiAgICBCb2RpZXMudHJhcGV6b2lkID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2xvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgc2xvcGUgKj0gMC41O1xuICAgICAgICB2YXIgcm9vZiA9ICgxIC0gKHNsb3BlICogMikpICogd2lkdGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgeDEgPSB3aWR0aCAqIHNsb3BlLFxuICAgICAgICAgICAgeDIgPSB4MSArIHJvb2YsXG4gICAgICAgICAgICB4MyA9IHgyICsgeDEsXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGg7XG5cbiAgICAgICAgaWYgKHNsb3BlIDwgMC41KSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDEgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDIgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgzICsgJyAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFwZXpvaWQgPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdUcmFwZXpvaWQgQm9keScsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgodmVydGljZXNQYXRoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW1mZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICAgICAgdHJhcGV6b2lkLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcih0cmFwZXpvaWQudmVydGljZXMsIGNoYW1mZXIucmFkaXVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCB0cmFwZXpvaWQsIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSBjaXJjbGUgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNpZGVzXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IGNpcmNsZSBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLmNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgb3B0aW9ucywgbWF4U2lkZXMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGNpcmNsZSA9IHtcbiAgICAgICAgICAgIGxhYmVsOiAnQ2lyY2xlIEJvZHknLFxuICAgICAgICAgICAgY2lyY2xlUmFkaXVzOiByYWRpdXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFwcHJveGltYXRlIGNpcmNsZXMgd2l0aCBwb2x5Z29ucyB1bnRpbCB0cnVlIGNpcmNsZXMgaW1wbGVtZW50ZWQgaW4gU0FUXG4gICAgICAgIG1heFNpZGVzID0gbWF4U2lkZXMgfHwgMjU7XG4gICAgICAgIHZhciBzaWRlcyA9IE1hdGguY2VpbChNYXRoLm1heCgxMCwgTWF0aC5taW4obWF4U2lkZXMsIHJhZGl1cykpKTtcblxuICAgICAgICAvLyBvcHRpbWlzYXRpb246IGFsd2F5cyB1c2UgZXZlbiBudW1iZXIgb2Ygc2lkZXMgKGhhbGYgdGhlIG51bWJlciBvZiB1bmlxdWUgYXhlcylcbiAgICAgICAgaWYgKHNpZGVzICUgMiA9PT0gMSlcbiAgICAgICAgICAgIHNpZGVzICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIEJvZGllcy5wb2x5Z29uKHgsIHksIHNpZGVzLCByYWRpdXMsIENvbW1vbi5leHRlbmQoe30sIGNpcmNsZSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIHJlZ3VsYXIgcG9seWdvbiBodWxsIHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiBzaWRlcy4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBwb2x5Z29uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWRlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7Ym9keX0gQSBuZXcgcmVndWxhciBwb2x5Z29uIGJvZHlcbiAgICAgKi9cbiAgICBCb2RpZXMucG9seWdvbiA9IGZ1bmN0aW9uKHgsIHksIHNpZGVzLCByYWRpdXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHNpZGVzIDwgMylcbiAgICAgICAgICAgIHJldHVybiBCb2RpZXMuY2lyY2xlKHgsIHksIHJhZGl1cywgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBzaWRlcyxcbiAgICAgICAgICAgIHBhdGggPSAnJyxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoZXRhICogMC41O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gb2Zmc2V0ICsgKGkgKiB0aGV0YSksXG4gICAgICAgICAgICAgICAgeHggPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgICAgICAgICAgeXkgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXM7XG5cbiAgICAgICAgICAgIHBhdGggKz0gJ0wgJyArIHh4LnRvRml4ZWQoMykgKyAnICcgKyB5eS50b0ZpeGVkKDMpICsgJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvbHlnb24gPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdQb2x5Z29uIEJvZHknLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKHBhdGgpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbWZlcikge1xuICAgICAgICAgICAgdmFyIGNoYW1mZXIgPSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihwb2x5Z29uLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgcG9seWdvbiwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm9keSB1c2luZyB0aGUgc3VwcGxpZWQgdmVydGljZXMgKG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbXVsdGlwbGUgc2V0cyBvZiB2ZXJ0aWNlcykuXG4gICAgICogSWYgdGhlIHZlcnRpY2VzIGFyZSBjb252ZXgsIHRoZXkgd2lsbCBwYXNzIHRocm91Z2ggYXMgc3VwcGxpZWQuXG4gICAgICogT3RoZXJ3aXNlIGlmIHRoZSB2ZXJ0aWNlcyBhcmUgY29uY2F2ZSwgdGhleSB3aWxsIGJlIGRlY29tcG9zZWQgaWYgW3BvbHktZGVjb21wLmpzXShodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcG9seS1kZWNvbXAuanMpIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9jZXNzIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1cHBvcnQgY29tcGxleCBzZXRzIG9mIHZlcnRpY2VzIChlLmcuIHRob3NlIHdpdGggaG9sZXMgbWF5IGZhaWwpLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGRlY29tcG9zaXRpb24gd2lsbCBkaXNjYXJkIGNvbGxpbmVhciBlZGdlcyAodG8gaW1wcm92ZSBwZXJmb3JtYW5jZSkuXG4gICAgICogSXQgY2FuIGFsc28gb3B0aW9uYWxseSBkaXNjYXJkIGFueSBwYXJ0cyB0aGF0IGhhdmUgYW4gYXJlYSBsZXNzIHRoYW4gYG1pbmltdW1BcmVhYC5cbiAgICAgKiBJZiB0aGUgdmVydGljZXMgY2FuIG5vdCBiZSBkZWNvbXBvc2VkLCB0aGUgcmVzdWx0IHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBjb252ZXggaHVsbC5cbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBgTWF0dGVyLkJvZHlgIHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgZnJvbVZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSBbW3ZlY3Rvcl1dIHZlcnRleFNldHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sfSBbZmxhZ0ludGVybmFsPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtb3ZlQ29sbGluZWFyPTAuMDFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5pbXVtQXJlYT0xMF1cbiAgICAgKiBAcmV0dXJuIHtib2R5fVxuICAgICAqL1xuICAgIEJvZGllcy5mcm9tVmVydGljZXMgPSBmdW5jdGlvbih4LCB5LCB2ZXJ0ZXhTZXRzLCBvcHRpb25zLCBmbGFnSW50ZXJuYWwsIHJlbW92ZUNvbGxpbmVhciwgbWluaW11bUFyZWEpIHtcbiAgICAgICAgdmFyIGJvZHksXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIGlzQ29udmV4LFxuICAgICAgICAgICAgdmVydGljZXMsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgejtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcGFydHMgPSBbXTtcblxuICAgICAgICBmbGFnSW50ZXJuYWwgPSB0eXBlb2YgZmxhZ0ludGVybmFsICE9PSAndW5kZWZpbmVkJyA/IGZsYWdJbnRlcm5hbCA6IGZhbHNlO1xuICAgICAgICByZW1vdmVDb2xsaW5lYXIgPSB0eXBlb2YgcmVtb3ZlQ29sbGluZWFyICE9PSAndW5kZWZpbmVkJyA/IHJlbW92ZUNvbGxpbmVhciA6IDAuMDE7XG4gICAgICAgIG1pbmltdW1BcmVhID0gdHlwZW9mIG1pbmltdW1BcmVhICE9PSAndW5kZWZpbmVkJyA/IG1pbmltdW1BcmVhIDogMTA7XG5cbiAgICAgICAgaWYgKCFkZWNvbXApIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdCb2RpZXMuZnJvbVZlcnRpY2VzOiBwb2x5LWRlY29tcC5qcyByZXF1aXJlZC4gQ291bGQgbm90IGRlY29tcG9zZSB2ZXJ0aWNlcy4gRmFsbGJhY2sgdG8gY29udmV4IGh1bGwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdmVydGV4U2V0cyBpcyBhbiBhcnJheSBvZiBhcnJheXNcbiAgICAgICAgaWYgKCFDb21tb24uaXNBcnJheSh2ZXJ0ZXhTZXRzWzBdKSkge1xuICAgICAgICAgICAgdmVydGV4U2V0cyA9IFt2ZXJ0ZXhTZXRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodiA9IDA7IHYgPCB2ZXJ0ZXhTZXRzLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHZlcnRleFNldHNbdl07XG4gICAgICAgICAgICBpc0NvbnZleCA9IFZlcnRpY2VzLmlzQ29udmV4KHZlcnRpY2VzKTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udmV4IHx8ICFkZWNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb252ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBjb252ZXggaHVsbCB3aGVuIGRlY29tcG9zaXRpb24gaXMgbm90IHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gVmVydGljZXMuaHVsbCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYSBkZWNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGNvbmNhdmUgPSB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmVydGV4LngsIHZlcnRleC55XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2VzIGFyZSBjb25jYXZlIGFuZCBzaW1wbGUsIHdlIGNhbiBkZWNvbXBvc2UgaW50byBwYXJ0c1xuICAgICAgICAgICAgICAgIGRlY29tcC5tYWtlQ0NXKGNvbmNhdmUpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDb2xsaW5lYXIgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBkZWNvbXAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKGNvbmNhdmUsIHJlbW92ZUNvbGxpbmVhcik7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHF1aWNrIGRlY29tcG9zaXRpb24gYWxnb3JpdGhtIChCYXlheml0KVxuICAgICAgICAgICAgICAgIHZhciBkZWNvbXBvc2VkID0gZGVjb21wLnF1aWNrRGVjb21wKGNvbmNhdmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggZGVjb21wb3NlZCBjaHVua1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWNvbXBvc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IGRlY29tcG9zZWRbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB2ZXJ0aWNlcyBpbnRvIHRoZSBjb3JyZWN0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtWZXJ0aWNlcyA9IGNodW5rLm1hcChmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBzbWFsbCBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1BcmVhID4gMCAmJiBWZXJ0aWNlcy5hcmVhKGNodW5rVmVydGljZXMpIDwgbWluaW11bUFyZWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb21wb3VuZCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFZlcnRpY2VzLmNlbnRyZShjaHVua1ZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBjaHVua1ZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBib2R5IHBhcnRzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHNbaV0gPSBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHBhcnRzW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmbGFnIGludGVybmFsIGVkZ2VzIChjb2luY2lkZW50IHBhcnQgZWRnZXMpXG4gICAgICAgIGlmIChmbGFnSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciBjb2luY2lkZW50X21heF9kaXN0ID0gNTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gcGFydHNbaV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IHBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMocGFydEEuYm91bmRzLCBwYXJ0Qi5ib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF2ID0gcGFydEEudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJ2ID0gcGFydEIudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdmVydGljZXMgb2YgYm90aCBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnRBLnZlcnRpY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IHBhcnRCLnZlcnRpY2VzLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYSA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2WyhrICsgMSkgJSBwYXYubGVuZ3RoXSwgcGJ2W3pdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYiA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2W2tdLCBwYnZbKHogKyAxKSAlIHBidi5sZW5ndGhdKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYm90aCB2ZXJ0aWNlcyBhcmUgdmVyeSBjbG9zZSwgY29uc2lkZXIgdGhlIGVkZ2UgY29uY2lkZW50IChpbnRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhIDwgY29pbmNpZGVudF9tYXhfZGlzdCAmJiBkYiA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdltrXS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBidlt6XS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyZW50IGJvZHkgdG8gYmUgcmV0dXJuZWQsIHRoYXQgY29udGFpbnMgZ2VuZXJhdGVkIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBib2R5ID0gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IHBhcnRzOiBwYXJ0cy5zbGljZSgwKSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHsgeDogeCwgeTogeSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZmFjdG9yeS9Cb2RpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQm9kaWVzLmpzIiwiLyoqXG4qIFRoZSBgTWF0dGVyLkF4ZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgYXhlcy5cbipcbiogQGNsYXNzIEF4ZXNcbiovXG5cbnZhciBBeGVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQXhlcztcblxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBmcm9tVmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge2F4ZXN9IEEgbmV3IGF4ZXMgZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXNcbiAgICAgKi9cbiAgICBBeGVzLmZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBheGVzID0ge307XG5cbiAgICAgICAgLy8gZmluZCB0aGUgdW5pcXVlIGF4ZXMsIHVzaW5nIGVkZ2Ugbm9ybWFsIGdyYWRpZW50c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IChpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGgsIFxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpc2UoeyBcbiAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbal0ueSAtIHZlcnRpY2VzW2ldLnksIFxuICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1tpXS54IC0gdmVydGljZXNbal0ueFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gKG5vcm1hbC55ID09PSAwKSA/IEluZmluaXR5IDogKG5vcm1hbC54IC8gbm9ybWFsLnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBsaW1pdCBwcmVjaXNpb25cbiAgICAgICAgICAgIGdyYWRpZW50ID0gZ3JhZGllbnQudG9GaXhlZCgzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYXhlc1tncmFkaWVudF0gPSBub3JtYWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29tbW9uLnZhbHVlcyhheGVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhIHNldCBvZiBheGVzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7YXhlc30gYXhlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIEF4ZXMucm90YXRlID0gZnVuY3Rpb24oYXhlcywgYW5nbGUpIHtcbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpXSxcbiAgICAgICAgICAgICAgICB4eDtcbiAgICAgICAgICAgIHh4ID0gYXhpcy54ICogY29zIC0gYXhpcy55ICogc2luO1xuICAgICAgICAgICAgYXhpcy55ID0gYXhpcy54ICogc2luICsgYXhpcy55ICogY29zO1xuICAgICAgICAgICAgYXhpcy54ID0geHg7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvZ2VvbWV0cnkvQXhlcy5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5SZW5kZXJgIG1vZHVsZSBpcyBhIHNpbXBsZSBIVE1MNSBjYW52YXMgYmFzZWQgcmVuZGVyZXIgZm9yIHZpc3VhbGlzaW5nIGluc3RhbmNlcyBvZiBgTWF0dGVyLkVuZ2luZWAuXG4qIEl0IGlzIGludGVuZGVkIGZvciBkZXZlbG9wbWVudCBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLCBidXQgbWF5IGFsc28gYmUgc3VpdGFibGUgZm9yIHNpbXBsZSBnYW1lcy5cbiogSXQgaW5jbHVkZXMgYSBudW1iZXIgb2YgZHJhd2luZyBvcHRpb25zIGluY2x1ZGluZyB3aXJlZnJhbWUsIHZlY3RvciB3aXRoIHN1cHBvcnQgZm9yIHNwcml0ZXMgYW5kIHZpZXdwb3J0cy5cbipcbiogQGNsYXNzIFJlbmRlclxuKi9cblxudmFyIFJlbmRlciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcjtcblxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi9jb3JlL0V2ZW50cycpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIE1vdXNlID0gcmVxdWlyZSgnLi4vY29yZS9Nb3VzZScpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbihjYWxsYmFjayl7IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhDb21tb24ubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xuICAgXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlcmVyLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7cmVuZGVyfSBBIG5ldyByZW5kZXJlclxuICAgICAqL1xuICAgIFJlbmRlci5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlbmRlcixcbiAgICAgICAgICAgIGVuZ2luZTogbnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBjYW52YXM6IG51bGwsXG4gICAgICAgICAgICBtb3VzZTogbnVsbCxcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzE4MTgxZCcsXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lQmFja2dyb3VuZDogJyMwZjBmMTMnLFxuICAgICAgICAgICAgICAgIGhhc0JvdW5kczogISFvcHRpb25zLmJvdW5kcyxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd1NsZWVwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0Jyb2FkcGhhc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCb3VuZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0NvbGxpc2lvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dTZXBhcmF0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0F4ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dQb3NpdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dBbmdsZUluZGljYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0lkczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1NoYWRvd3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dWZXJ0ZXhOdW1iZXJzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93Q29udmV4SHVsbHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dJbnRlcm5hbEVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93TW91c2VQb3NpdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVuZGVyID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHJlbmRlci5jYW52YXMpIHtcbiAgICAgICAgICAgIHJlbmRlci5jYW52YXMud2lkdGggPSByZW5kZXIub3B0aW9ucy53aWR0aCB8fCByZW5kZXIuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgcmVuZGVyLmNhbnZhcy5oZWlnaHQgPSByZW5kZXIub3B0aW9ucy5oZWlnaHQgfHwgcmVuZGVyLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXIubW91c2UgPSBvcHRpb25zLm1vdXNlO1xuICAgICAgICByZW5kZXIuZW5naW5lID0gb3B0aW9ucy5lbmdpbmU7XG4gICAgICAgIHJlbmRlci5jYW52YXMgPSByZW5kZXIuY2FudmFzIHx8IF9jcmVhdGVDYW52YXMocmVuZGVyLm9wdGlvbnMud2lkdGgsIHJlbmRlci5vcHRpb25zLmhlaWdodCk7XG4gICAgICAgIHJlbmRlci5jb250ZXh0ID0gcmVuZGVyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICByZW5kZXIudGV4dHVyZXMgPSB7fTtcblxuICAgICAgICByZW5kZXIuYm91bmRzID0gcmVuZGVyLmJvdW5kcyB8fCB7IFxuICAgICAgICAgICAgbWluOiB7IFxuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBtYXg6IHsgXG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBSZW5kZXIuc2V0UGl4ZWxSYXRpbyhyZW5kZXIsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc0VsZW1lbnQocmVuZGVyLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZW5kZXIuZWxlbWVudC5hcHBlbmRDaGlsZChyZW5kZXIuY2FudmFzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENvbW1vbi5sb2coJ1JlbmRlci5jcmVhdGU6IG9wdGlvbnMuZWxlbWVudCB3YXMgdW5kZWZpbmVkLCByZW5kZXIuY2FudmFzIHdhcyBjcmVhdGVkIGJ1dCBub3QgYXBwZW5kZWQnLCAnd2FybicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHVwZGF0ZXMgdGhlIHJlbmRlciBjYW52YXMgb24gdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGV2ZW50LlxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5ydW4gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AodGltZSl7XG4gICAgICAgICAgICByZW5kZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgUmVuZGVyLndvcmxkKHJlbmRlcik7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuZHMgZXhlY3V0aW9uIG9mIGBSZW5kZXIucnVuYCBvbiB0aGUgZ2l2ZW4gYHJlbmRlcmAsIGJ5IGNhbmNlbGluZyB0aGUgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QgZXZlbnQgbG9vcC5cbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLnN0b3AgPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lKHJlbmRlci5mcmFtZVJlcXVlc3RJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlciBhbmQgdXBkYXRlcyB0aGUgY2FudmFzLlxuICAgICAqIFRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBjb3JyZWN0IHJhdGlvLCBwYXNzIHRoZSBzdHJpbmcgYCdhdXRvJ2AgZm9yIGBwaXhlbFJhdGlvYC5cbiAgICAgKiBAbWV0aG9kIHNldFBpeGVsUmF0aW9cbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW9cbiAgICAgKi9cbiAgICBSZW5kZXIuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKHJlbmRlciwgcGl4ZWxSYXRpbykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgY2FudmFzID0gcmVuZGVyLmNhbnZhcztcblxuICAgICAgICBpZiAocGl4ZWxSYXRpbyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gX2dldFBpeGVsUmF0aW8oY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGl4ZWwtcmF0aW8nLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gb3B0aW9ucy53aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9wdGlvbnMud2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKyAncHgnO1xuICAgICAgICByZW5kZXIuY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGFuZCBzaXplcyB0aGUgdmlld3BvcnQgYXJvdW5kIHRoZSBnaXZlbiBvYmplY3QgYm91bmRzLlxuICAgICAqIE9iamVjdHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBgb2JqZWN0LmJvdW5kc2BcbiAgICAgKiAtIGBvYmplY3QucG9zaXRpb25gXG4gICAgICogLSBgb2JqZWN0Lm1pbmAgYW5kIGBvYmplY3QubWF4YFxuICAgICAqIC0gYG9iamVjdC54YCBhbmQgYG9iamVjdC55YFxuICAgICAqIEBtZXRob2QgbG9va0F0XG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BhZGRpbmddXG4gICAgICogQHBhcmFtIHtib29sfSBbY2VudGVyPXRydWVdXG4gICAgICovXG4gICAgUmVuZGVyLmxvb2tBdCA9IGZ1bmN0aW9uKHJlbmRlciwgb2JqZWN0cywgcGFkZGluZywgY2VudGVyKSB7XG4gICAgICAgIGNlbnRlciA9IHR5cGVvZiBjZW50ZXIgIT09ICd1bmRlZmluZWQnID8gY2VudGVyIDogdHJ1ZTtcbiAgICAgICAgb2JqZWN0cyA9IENvbW1vbi5pc0FycmF5KG9iamVjdHMpID8gb2JqZWN0cyA6IFtvYmplY3RzXTtcbiAgICAgICAgcGFkZGluZyA9IHBhZGRpbmcgfHwge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaW5kIGJvdW5kcyBvZiBhbGwgb2JqZWN0c1xuICAgICAgICB2YXIgYm91bmRzID0ge1xuICAgICAgICAgICAgbWluOiB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSB9LFxuICAgICAgICAgICAgbWF4OiB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5IH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW2ldLFxuICAgICAgICAgICAgICAgIG1pbiA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1pbiA6IChvYmplY3QubWluIHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpLFxuICAgICAgICAgICAgICAgIG1heCA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1heCA6IChvYmplY3QubWF4IHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpOyBcblxuICAgICAgICAgICAgaWYgKG1pbiAmJiBtYXgpIHsgXG4gICAgICAgICAgICAgICAgaWYgKG1pbi54IDwgYm91bmRzLm1pbi54KSBcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pbi54ID0gbWluLng7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtYXgueCA+IGJvdW5kcy5tYXgueCkgXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueCA9IG1heC54O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pbi55IDwgYm91bmRzLm1pbi55KSBcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pbi55ID0gbWluLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4LnkgPiBib3VuZHMubWF4LnkpIFxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWF4LnkgPSBtYXgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgcmF0aW9zXG4gICAgICAgIHZhciB3aWR0aCA9IChib3VuZHMubWF4LnggLSBib3VuZHMubWluLngpICsgMiAqIHBhZGRpbmcueCxcbiAgICAgICAgICAgIGhlaWdodCA9IChib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpICsgMiAqIHBhZGRpbmcueSxcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSByZW5kZXIuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IHJlbmRlci5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICBvdXRlclJhdGlvID0gdmlld1dpZHRoIC8gdmlld0hlaWdodCxcbiAgICAgICAgICAgIGlubmVyUmF0aW8gPSB3aWR0aCAvIGhlaWdodCxcbiAgICAgICAgICAgIHNjYWxlWCA9IDEsXG4gICAgICAgICAgICBzY2FsZVkgPSAxO1xuXG4gICAgICAgIC8vIGZpbmQgc2NhbGUgZmFjdG9yXG4gICAgICAgIGlmIChpbm5lclJhdGlvID4gb3V0ZXJSYXRpbykge1xuICAgICAgICAgICAgc2NhbGVZID0gaW5uZXJSYXRpbyAvIG91dGVyUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVggPSBvdXRlclJhdGlvIC8gaW5uZXJSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBib3VuZHNcbiAgICAgICAgcmVuZGVyLm9wdGlvbnMuaGFzQm91bmRzID0gdHJ1ZTtcblxuICAgICAgICAvLyBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54ID0gYm91bmRzLm1pbi54O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1heC54ID0gYm91bmRzLm1pbi54ICsgd2lkdGggKiBzY2FsZVg7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnkgPSBib3VuZHMubWluLnk7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgPSBib3VuZHMubWluLnkgKyBoZWlnaHQgKiBzY2FsZVk7XG5cbiAgICAgICAgLy8gY2VudGVyXG4gICAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggKz0gd2lkdGggKiAwLjUgLSAod2lkdGggKiBzY2FsZVgpICogMC41O1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueCArPSB3aWR0aCAqIDAuNSAtICh3aWR0aCAqIHNjYWxlWCkgKiAwLjU7XG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55ICs9IGhlaWdodCAqIDAuNSAtIChoZWlnaHQgKiBzY2FsZVkpICogMC41O1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSArPSBoZWlnaHQgKiAwLjUgLSAoaGVpZ2h0ICogc2NhbGVZKSAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCAtPSBwYWRkaW5nLng7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggLT0gcGFkZGluZy54O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55IC09IHBhZGRpbmcueTtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSAtPSBwYWRkaW5nLnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1vdXNlXG4gICAgICAgIGlmIChyZW5kZXIubW91c2UpIHtcbiAgICAgICAgICAgIE1vdXNlLnNldFNjYWxlKHJlbmRlci5tb3VzZSwge1xuICAgICAgICAgICAgICAgIHg6IChyZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCkgLyByZW5kZXIuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgIHk6IChyZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSkgLyByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE1vdXNlLnNldE9mZnNldChyZW5kZXIubW91c2UsIHJlbmRlci5ib3VuZHMubWluKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHZpZXdwb3J0IHRyYW5zZm9ybXMgYmFzZWQgb24gYHJlbmRlci5ib3VuZHNgIHRvIGEgcmVuZGVyIGNvbnRleHQuXG4gICAgICogQG1ldGhvZCBzdGFydFZpZXdUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLnN0YXJ0Vmlld1RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgYm91bmRzU2NhbGVYID0gYm91bmRzV2lkdGggLyByZW5kZXIub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcblxuICAgICAgICByZW5kZXIuY29udGV4dC5zY2FsZSgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcbiAgICAgICAgcmVuZGVyLmNvbnRleHQudHJhbnNsYXRlKC1yZW5kZXIuYm91bmRzLm1pbi54LCAtcmVuZGVyLmJvdW5kcy5taW4ueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgdHJhbnNmb3JtcyBvbiB0aGUgcmVuZGVyIGNvbnRleHQuXG4gICAgICogQG1ldGhvZCBlbmRWaWV3VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5lbmRWaWV3VHJhbnNmb3JtID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIHJlbmRlci5jb250ZXh0LnNldFRyYW5zZm9ybShyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwLCByZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZ2l2ZW4gYGVuZ2luZWAncyBgTWF0dGVyLldvcmxkYCBvYmplY3QuXG4gICAgICogVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGFsbCByZW5kZXJpbmcgYW5kIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgc2NlbmUgY2hhbmdlcy5cbiAgICAgKiBAbWV0aG9kIHdvcmxkXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci53b3JsZCA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgY2FudmFzID0gcmVuZGVyLmNhbnZhcyxcbiAgICAgICAgICAgIGNvbnRleHQgPSByZW5kZXIuY29udGV4dCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGFsbEJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxuICAgICAgICAgICAgYWxsQ29uc3RyYWludHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMod29ybGQpLFxuICAgICAgICAgICAgYmFja2dyb3VuZCA9IG9wdGlvbnMud2lyZWZyYW1lcyA/IG9wdGlvbnMud2lyZWZyYW1lQmFja2dyb3VuZCA6IG9wdGlvbnMuYmFja2dyb3VuZCxcbiAgICAgICAgICAgIGJvZGllcyA9IFtdLFxuICAgICAgICAgICAgY29uc3RyYWludHMgPSBbXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBlbmdpbmUudGltaW5nLnRpbWVzdGFtcFxuICAgICAgICB9O1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJlbmRlciwgJ2JlZm9yZVJlbmRlcicsIGV2ZW50KTtcblxuICAgICAgICAvLyBhcHBseSBiYWNrZ3JvdW5kIGlmIGl0IGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmIChyZW5kZXIuY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQpXG4gICAgICAgICAgICBfYXBwbHlCYWNrZ3JvdW5kKHJlbmRlciwgYmFja2dyb3VuZCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhcyB3aXRoIGEgdHJhbnNwYXJlbnQgZmlsbCwgdG8gYWxsb3cgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIHRvIHNob3dcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWluJztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgICAgIC8vIGhhbmRsZSBib3VuZHNcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGJvZGllcyB0aGF0IGFyZSBub3QgaW4gdmlld1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbEJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYWxsQm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIHJlbmRlci5ib3VuZHMpKVxuICAgICAgICAgICAgICAgICAgICBib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBjb25zdHJhaW50cyB0aGF0IGFyZSBub3QgaW4gdmlld1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbENvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBhbGxDb25zdHJhaW50c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QVdvcmxkID0gY29uc3RyYWludC5wb2ludEEsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QldvcmxkID0gY29uc3RyYWludC5wb2ludEI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYm9keUEpIHBvaW50QVdvcmxkID0gVmVjdG9yLmFkZChib2R5QS5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEEpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50Qik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50QVdvcmxkIHx8ICFwb2ludEJXb3JsZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKHJlbmRlci5ib3VuZHMsIHBvaW50QVdvcmxkKSB8fCBCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRCV29ybGQpKVxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIHZpZXdcbiAgICAgICAgICAgIFJlbmRlci5zdGFydFZpZXdUcmFuc2Zvcm0ocmVuZGVyKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIG1vdXNlXG4gICAgICAgICAgICBpZiAocmVuZGVyLm1vdXNlKSB7XG4gICAgICAgICAgICAgICAgTW91c2Uuc2V0U2NhbGUocmVuZGVyLm1vdXNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IChyZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCkgLyByZW5kZXIuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB5OiAocmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnkpIC8gcmVuZGVyLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIE1vdXNlLnNldE9mZnNldChyZW5kZXIubW91c2UsIHJlbmRlci5ib3VuZHMubWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYWxsQ29uc3RyYWludHM7XG4gICAgICAgICAgICBib2RpZXMgPSBhbGxCb2RpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMud2lyZWZyYW1lcyB8fCAoZW5naW5lLmVuYWJsZVNsZWVwaW5nICYmIG9wdGlvbnMuc2hvd1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgLy8gZnVsbHkgZmVhdHVyZWQgcmVuZGVyaW5nIG9mIGJvZGllc1xuICAgICAgICAgICAgUmVuZGVyLmJvZGllcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29udmV4SHVsbHMpXG4gICAgICAgICAgICAgICAgUmVuZGVyLmJvZHlDb252ZXhIdWxscyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgIC8vIG9wdGltaXNlZCBtZXRob2QgZm9yIHdpcmVmcmFtZXMgb25seVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlXaXJlZnJhbWVzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dCb3VuZHMpXG4gICAgICAgICAgICBSZW5kZXIuYm9keUJvdW5kcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0F4ZXMgfHwgb3B0aW9ucy5zaG93QW5nbGVJbmRpY2F0b3IpXG4gICAgICAgICAgICBSZW5kZXIuYm9keUF4ZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Bvc2l0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5ib2R5UG9zaXRpb25zKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93VmVsb2NpdHkpXG4gICAgICAgICAgICBSZW5kZXIuYm9keVZlbG9jaXR5KHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93SWRzKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlJZHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dTZXBhcmF0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5zZXBhcmF0aW9ucyhyZW5kZXIsIGVuZ2luZS5wYWlycy5saXN0LCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29sbGlzaW9ucylcbiAgICAgICAgICAgIFJlbmRlci5jb2xsaXNpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dWZXJ0ZXhOdW1iZXJzKVxuICAgICAgICAgICAgUmVuZGVyLnZlcnRleE51bWJlcnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uKVxuICAgICAgICAgICAgUmVuZGVyLm1vdXNlUG9zaXRpb24ocmVuZGVyLCByZW5kZXIubW91c2UsIGNvbnRleHQpO1xuXG4gICAgICAgIFJlbmRlci5jb25zdHJhaW50cyhjb25zdHJhaW50cywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0Jyb2FkcGhhc2UgJiYgZW5naW5lLmJyb2FkcGhhc2UuY29udHJvbGxlciA9PT0gR3JpZClcbiAgICAgICAgICAgIFJlbmRlci5ncmlkKHJlbmRlciwgZW5naW5lLmJyb2FkcGhhc2UsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dEZWJ1ZylcbiAgICAgICAgICAgIFJlbmRlci5kZWJ1ZyhyZW5kZXIsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcykge1xuICAgICAgICAgICAgLy8gcmV2ZXJ0IHZpZXcgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0ocmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJlbmRlciwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBkZWJ1Z1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuZGVidWcgPSBmdW5jdGlvbihyZW5kZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgbWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBzcGFjZSA9IFwiICAgIFwiO1xuXG4gICAgICAgIGlmIChlbmdpbmUudGltaW5nLnRpbWVzdGFtcCAtIChyZW5kZXIuZGVidWdUaW1lc3RhbXAgfHwgMCkgPj0gNTAwKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmIChtZXRyaWNzLnRpbWluZykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gXCJmcHM6IFwiICsgTWF0aC5yb3VuZChtZXRyaWNzLnRpbWluZy5mcHMpICsgc3BhY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEBpZiBERUJVR1xuICAgICAgICAgICAgaWYgKG1ldHJpY3MuZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0cmljcy50aW1pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImRlbHRhOiBcIiArIG1ldHJpY3MudGltaW5nLmRlbHRhLnRvRml4ZWQoMykgKyBzcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImNvcnJlY3Rpb246IFwiICsgbWV0cmljcy50aW1pbmcuY29ycmVjdGlvbi50b0ZpeGVkKDMpICsgc3BhY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcImJvZGllczogXCIgKyBib2RpZXMubGVuZ3RoICsgc3BhY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5naW5lLmJyb2FkcGhhc2UuY29udHJvbGxlciA9PT0gR3JpZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImJ1Y2tldHM6IFwiICsgbWV0cmljcy5idWNrZXRzICsgc3BhY2U7XG5cbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiXFxuXCI7XG5cbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiY29sbGlzaW9uczogXCIgKyBtZXRyaWNzLmNvbGxpc2lvbnMgKyBzcGFjZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwicGFpcnM6IFwiICsgZW5naW5lLnBhaXJzLmxpc3QubGVuZ3RoICsgc3BhY2U7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcImJyb2FkOiBcIiArIG1ldHJpY3MuYnJvYWRFZmYgKyBzcGFjZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwibWlkOiBcIiArIG1ldHJpY3MubWlkRWZmICsgc3BhY2U7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIm5hcnJvdzogXCIgKyBtZXRyaWNzLm5hcnJvd0VmZiArIHNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQGVuZGlmICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHJlbmRlci5kZWJ1Z1N0cmluZyA9IHRleHQ7XG4gICAgICAgICAgICByZW5kZXIuZGVidWdUaW1lc3RhbXAgPSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXIuZGVidWdTdHJpbmcpIHtcbiAgICAgICAgICAgIGMuZm9udCA9IFwiMTJweCBBcmlhbFwiO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjUpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNwbGl0ID0gcmVuZGVyLmRlYnVnU3RyaW5nLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGMuZmlsbFRleHQoc3BsaXRbaV0sIDUwLCA1MCArIGkgKiAxOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgY29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnRbXX0gY29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuY29uc3RyYWludHMgPSBmdW5jdGlvbihjb25zdHJhaW50cywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LnJlbmRlci52aXNpYmxlIHx8ICFjb25zdHJhaW50LnBvaW50QSB8fCAhY29uc3RyYWludC5wb2ludEIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCO1xuXG4gICAgICAgICAgICBpZiAoYm9keUEpIHtcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMubW92ZVRvKGJvZHlBLnBvc2l0aW9uLnggKyBjb25zdHJhaW50LnBvaW50QS54LCBib2R5QS5wb3NpdGlvbi55ICsgY29uc3RyYWludC5wb2ludEEueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oY29uc3RyYWludC5wb2ludEEueCwgY29uc3RyYWludC5wb2ludEEueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib2R5Qikge1xuICAgICAgICAgICAgICAgIGMubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggKyBjb25zdHJhaW50LnBvaW50Qi54LCBib2R5Qi5wb3NpdGlvbi55ICsgY29uc3RyYWludC5wb2ludEIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGMubGluZVRvKGNvbnN0cmFpbnQucG9pbnRCLngsIGNvbnN0cmFpbnQucG9pbnRCLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSBjb25zdHJhaW50LnJlbmRlci5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IGNvbnN0cmFpbnQucmVuZGVyLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlTaGFkb3dzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVNoYWRvd3MgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5jaXJjbGVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuYXJjKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55LCBib2R5LmNpcmNsZVJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8oYm9keS52ZXJ0aWNlc1swXS54LCBib2R5LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYm9keS52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzW2pdLngsIGJvZHkudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBib2R5LnBvc2l0aW9uLnggLSByZW5kZXIub3B0aW9ucy53aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVkgPSBib2R5LnBvc2l0aW9uLnkgLSByZW5kZXIub3B0aW9ucy5oZWlnaHQgKiAwLjIsXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZVgpICsgTWF0aC5hYnMoZGlzdGFuY2VZKTtcblxuICAgICAgICAgICAgYy5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMTUpJztcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WCA9IDAuMDUgKiBkaXN0YW5jZVg7XG4gICAgICAgICAgICBjLnNoYWRvd09mZnNldFkgPSAwLjA1ICogZGlzdGFuY2VZO1xuICAgICAgICAgICAgYy5zaGFkb3dCbHVyID0gMSArIDEyICogTWF0aC5taW4oMSwgZGlzdGFuY2UgLyAxMDAwKTtcblxuICAgICAgICAgICAgYy5maWxsKCk7XG5cbiAgICAgICAgICAgIGMuc2hhZG93Q29sb3IgPSBudWxsO1xuICAgICAgICAgICAgYy5zaGFkb3dPZmZzZXRYID0gbnVsbDtcbiAgICAgICAgICAgIGMuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG4gICAgICAgICAgICBjLnNoYWRvd0JsdXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZGllc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZGllcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IG9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMgfHwgIW9wdGlvbnMud2lyZWZyYW1lcyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcbiAgICAgICAgICAgIGZvciAoayA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dTbGVlcGluZyAmJiBib2R5LmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDAuNSAqIHBhcnQucmVuZGVyLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnJlbmRlci5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSBwYXJ0LnJlbmRlci5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlbmRlci5zcHJpdGUgJiYgcGFydC5yZW5kZXIuc3ByaXRlLnRleHR1cmUgJiYgIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHNwcml0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gcGFydC5yZW5kZXIuc3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgc3ByaXRlLnRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTsgXG4gICAgICAgICAgICAgICAgICAgIGMucm90YXRlKHBhcnQuYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGMuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUud2lkdGggKiAtc3ByaXRlLnhPZmZzZXQgKiBzcHJpdGUueFNjYWxlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ICogLXNwcml0ZS55T2Zmc2V0ICogc3ByaXRlLnlTY2FsZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoICogc3ByaXRlLnhTY2FsZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCAqIHNwcml0ZS55U2NhbGVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdHJhbnNsYXRpb24sIGhvcGVmdWxseSBmYXN0ZXIgdGhhbiBzYXZlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICBjLnJvdGF0ZSgtcGFydC5hbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKC1wYXJ0LnBvc2l0aW9uLngsIC1wYXJ0LnBvc2l0aW9uLnkpOyBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHBvbHlnb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuY2lyY2xlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5hcmMocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnksIHBhcnQuY2lyY2xlUmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC52ZXJ0aWNlc1tqXS5pc0ludGVybmFsICYmICFzaG93SW50ZXJuYWxFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueCwgcGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9IHBhcnQucmVuZGVyLmZpbGxTdHlsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQucmVuZGVyLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gcGFydC5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSBwYXJ0LnJlbmRlci5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnI2JiYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pc2VkIG1ldGhvZCBmb3IgZHJhd2luZyBib2R5IHdpcmVmcmFtZXMgaW4gb25lIHBhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keVdpcmVmcmFtZXNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5V2lyZWZyYW1lcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIHNob3dJbnRlcm5hbEVkZ2VzID0gcmVuZGVyLm9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBhbGwgYm9kaWVzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBmb3IgKGsgPSBib2R5LnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IGJvZHkucGFydHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcblxuICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydC52ZXJ0aWNlc1tqIC0gMV0uaXNJbnRlcm5hbCB8fCBzaG93SW50ZXJuYWxFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudmVydGljZXNbal0uaXNJbnRlcm5hbCAmJiAhc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS54LCBwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWlzZWQgbWV0aG9kIGZvciBkcmF3aW5nIGJvZHkgY29udmV4IGh1bGwgd2lyZWZyYW1lcyBpbiBvbmUgcGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Q29udmV4SHVsbHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBjb252ZXggaHVsbHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlIHx8IGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBib2R5LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lVG8oYm9keS52ZXJ0aWNlc1tqXS54LCBib2R5LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBib2R5IHZlcnRleCBudW1iZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCB2ZXJ0ZXhOdW1iZXJzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIudmVydGV4TnVtYmVycyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBib2RpZXNbaV0ucGFydHM7XG4gICAgICAgICAgICBmb3IgKGsgPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBwYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNba107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsVGV4dChpICsgJ18nICsgaiwgcGFydC5wb3NpdGlvbi54ICsgKHBhcnQudmVydGljZXNbal0ueCAtIHBhcnQucG9zaXRpb24ueCkgKiAwLjgsIHBhcnQucG9zaXRpb24ueSArIChwYXJ0LnZlcnRpY2VzW2pdLnkgLSBwYXJ0LnBvc2l0aW9uLnkpICogMC44KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgbW91c2VQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24ocmVuZGVyLCBtb3VzZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XG4gICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC44KSc7XG4gICAgICAgIGMuZmlsbFRleHQobW91c2UucG9zaXRpb24ueCArICcgICcgKyBtb3VzZS5wb3NpdGlvbi55LCBtb3VzZS5wb3NpdGlvbi54ICsgNSwgbW91c2UucG9zaXRpb24ueSAtIDUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Qm91bmRzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keUJvdW5kcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnM7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjLnJlY3QocGFydC5ib3VuZHMubWluLngsIHBhcnQuYm91bmRzLm1pbi55LCBwYXJ0LmJvdW5kcy5tYXgueCAtIHBhcnQuYm91bmRzLm1pbi54LCBwYXJ0LmJvdW5kcy5tYXgueSAtIHBhcnQuYm91bmRzLm1pbi55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wOCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGFuZ2xlIGluZGljYXRvcnMgYW5kIGF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keUF4ZXNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5QXhlcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSBib2R5LnBhcnRzO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dBeGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFsbCBheGVzXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydC5heGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBhcnQuYXhlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQucG9zaXRpb24ueCArIGF4aXMueCAqIDIwLCBwYXJ0LnBvc2l0aW9uLnkgKyBheGlzLnkgKiAyMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnQuYXhlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGEgc2luZ2xlIGF4aXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbygocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnQudmVydGljZXNbMF0ueSArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnaW5kaWFucmVkJztcbiAgICAgICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpJztcbiAgICAgICAgICAgIGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ292ZXJsYXknO1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5UG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGN1cnJlbnQgcG9zaXRpb25zXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuICAgICAgICAgICAgICAgIGMuYXJjKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55LCAzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdpbmRpYW5yZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjUpJztcbiAgICAgICAgfVxuICAgICAgICBjLmZpbGwoKTtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgYy5hcmMoYm9keS5wb3NpdGlvblByZXYueCwgYm9keS5wb3NpdGlvblByZXYueSwgMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC44KSc7XG4gICAgICAgIGMuZmlsbCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IHZlbG9jaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlWZWxvY2l0eSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dDtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5LnBvc2l0aW9uLngsIGJvZHkucG9zaXRpb24ueSk7XG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnBvc2l0aW9uLnggKyAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgKiAyLCBib2R5LnBvc2l0aW9uLnkgKyAoYm9keS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvblByZXYueSkgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMubGluZVdpZHRoID0gMztcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdjb3JuZmxvd2VyYmx1ZSc7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlJZHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5SWRzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFib2RpZXNbaV0ucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcbiAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBjLmZvbnQgPSBcIjEycHggQXJpYWxcIjtcbiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO1xuICAgICAgICAgICAgICAgIGMuZmlsbFRleHQocGFydC5pZCwgcGFydC5wb3NpdGlvbi54ICsgMTAsIHBhcnQucG9zaXRpb24ueSAtIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBjb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5jb2xsaXNpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBwYWlycywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgY29ycmVjdGVkLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGNvbGxpc2lvbiBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gcGFpci5hY3RpdmVDb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gY29udGFjdC52ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgYy5yZWN0KHZlcnRleC54IC0gMS41LCB2ZXJ0ZXgueSAtIDEuNSwgMy41LCAzLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgIH1cbiAgICAgICAgYy5maWxsKCk7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAvLyByZW5kZXIgY29sbGlzaW9uIG5vcm1hbHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG5cbiAgICAgICAgICAgIGlmIChwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsUG9zWCA9IHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4LngsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1kgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC55O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1ggPSAocGFpci5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCArIHBhaXIuYWN0aXZlQ29udGFjdHNbMV0udmVydGV4LngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWSA9IChwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC55ICsgcGFpci5hY3RpdmVDb250YWN0c1sxXS52ZXJ0ZXgueSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uLmJvZHlCID09PSBjb2xsaXNpb24uc3VwcG9ydHNbMF0uYm9keSB8fCBjb2xsaXNpb24uYm9keUEuaXNTdGF0aWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8obm9ybWFsUG9zWCAtIGNvbGxpc2lvbi5ub3JtYWwueCAqIDgsIG5vcm1hbFBvc1kgLSBjb2xsaXNpb24ubm9ybWFsLnkgKiA4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhub3JtYWxQb3NYICsgY29sbGlzaW9uLm5vcm1hbC54ICogOCwgbm9ybWFsUG9zWSArIGNvbGxpc2lvbi5ub3JtYWwueSAqIDgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMubGluZVRvKG5vcm1hbFBvc1gsIG5vcm1hbFBvc1kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnb3JhbmdlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2Qgc2VwYXJhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLnNlcGFyYXRpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBwYWlycywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgY29ycmVjdGVkLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIHNlcGFyYXRpb25zXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QjtcblxuICAgICAgICAgICAgdmFyIGsgPSAxO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHlCLmlzU3RhdGljICYmICFib2R5QS5pc1N0YXRpYykgayA9IDAuNTtcbiAgICAgICAgICAgIGlmIChib2R5Qi5pc1N0YXRpYykgayA9IDA7XG5cbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHlCLnBvc2l0aW9uLngsIGJvZHlCLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgYy5saW5lVG8oYm9keUIucG9zaXRpb24ueCAtIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi54ICogaywgYm9keUIucG9zaXRpb24ueSAtIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi55ICogayk7XG5cbiAgICAgICAgICAgIGsgPSAxO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHlCLmlzU3RhdGljICYmICFib2R5QS5pc1N0YXRpYykgayA9IDAuNTtcbiAgICAgICAgICAgIGlmIChib2R5QS5pc1N0YXRpYykgayA9IDA7XG5cbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHlBLnBvc2l0aW9uLngsIGJvZHlBLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgYy5saW5lVG8oYm9keUEucG9zaXRpb24ueCArIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi54ICogaywgYm9keUEucG9zaXRpb24ueSArIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi55ICogayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNSknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdvcmFuZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGdyaWRcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmdyaWQgPSBmdW5jdGlvbihyZW5kZXIsIGdyaWQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zO1xuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTgwLDAsMC4xKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE4MCwwLDAuNSknO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgYnVja2V0S2V5cyA9IENvbW1vbi5rZXlzKGdyaWQuYnVja2V0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0SWQgPSBidWNrZXRLZXlzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZ3JpZC5idWNrZXRzW2J1Y2tldElkXS5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gYnVja2V0SWQuc3BsaXQoL0N8Ui8pO1xuICAgICAgICAgICAgYy5yZWN0KDAuNSArIHBhcnNlSW50KHJlZ2lvblsxXSwgMTApICogZ3JpZC5idWNrZXRXaWR0aCwgXG4gICAgICAgICAgICAgICAgICAgIDAuNSArIHBhcnNlSW50KHJlZ2lvblsyXSwgMTApICogZ3JpZC5idWNrZXRIZWlnaHQsIFxuICAgICAgICAgICAgICAgICAgICBncmlkLmJ1Y2tldFdpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5idWNrZXRIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBpbnNwZWN0b3JcbiAgICAgKiBAcGFyYW0ge2luc3BlY3Rvcn0gaW5zcGVjdG9yXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmluc3BlY3RvciA9IGZ1bmN0aW9uKGluc3BlY3RvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZW5naW5lID0gaW5zcGVjdG9yLmVuZ2luZSxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gaW5zcGVjdG9yLnNlbGVjdGVkLFxuICAgICAgICAgICAgcmVuZGVyID0gaW5zcGVjdG9yLnJlbmRlcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGJvdW5kcztcblxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHNXaWR0aCA9IHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgYm91bmRzU2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBib3VuZHNTY2FsZVgsIDEgLyBib3VuZHNTY2FsZVkpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLXJlbmRlci5ib3VuZHMubWluLngsIC1yZW5kZXIuYm91bmRzLm1pbi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZWN0ZWRbaV0uZGF0YTtcblxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjkpJztcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsMl0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcblxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBib2R5IHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBpdGVtLmJvdW5kcztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAtIDMpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSAtIDMpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLSBib3VuZHMubWluLnggKyA2KSwgTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkgKyA2KSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGNvbnN0cmFpbnQgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGl0ZW0ucG9pbnRBO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmJvZHlBKVxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGl0ZW0ucG9pbnRCO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnQueCwgcG9pbnQueSwgMTAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyIHNlbGVjdGlvbiByZWdpb25cbiAgICAgICAgaWYgKGluc3BlY3Rvci5zZWxlY3RTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjYpJztcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuMSknO1xuICAgICAgICAgICAgYm91bmRzID0gaW5zcGVjdG9yLnNlbGVjdEJvdW5kcztcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoTWF0aC5mbG9vcihib3VuZHMubWluLngpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54KSwgTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtMC41LCAtMC41KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcylcbiAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IHdpZHRoXG4gICAgICogQHBhcmFtIHt9IGhlaWdodFxuICAgICAqIEByZXR1cm4gY2FudmFzXG4gICAgICovXG4gICAgdmFyIF9jcmVhdGVDYW52YXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBtZXRob2QgX2dldFBpeGVsUmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gcGl4ZWwgcmF0aW9cbiAgICAgKi9cbiAgICB2YXIgX2dldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyA9IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVBpeGVsUmF0aW87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlcXVlc3RlZCB0ZXh0dXJlIChhbiBJbWFnZSkgdmlhIGl0cyBwYXRoXG4gICAgICogQG1ldGhvZCBfZ2V0VGV4dHVyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVBhdGhcbiAgICAgKiBAcmV0dXJuIHtJbWFnZX0gdGV4dHVyZVxuICAgICAqL1xuICAgIHZhciBfZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHJlbmRlciwgaW1hZ2VQYXRoKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdO1xuXG4gICAgICAgIGlmIChpbWFnZSlcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcblxuICAgICAgICBpbWFnZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlUGF0aDtcblxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGJhY2tncm91bmQgdG8gdGhlIGNhbnZhcyB1c2luZyBDU1MuXG4gICAgICogQG1ldGhvZCBhcHBseUJhY2tncm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxuICAgICAqL1xuICAgIHZhciBfYXBwbHlCYWNrZ3JvdW5kID0gZnVuY3Rpb24ocmVuZGVyLCBiYWNrZ3JvdW5kKSB7XG4gICAgICAgIHZhciBjc3NCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICAgICAgICBpZiAoLyhqcGd8Z2lmfHBuZykkLy50ZXN0KGJhY2tncm91bmQpKVxuICAgICAgICAgICAgY3NzQmFja2dyb3VuZCA9ICd1cmwoJyArIGJhY2tncm91bmQgKyAnKSc7XG5cbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gY3NzQmFja2dyb3VuZDtcbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiY29udGFpblwiO1xuICAgICAgICByZW5kZXIuY3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVJlbmRlclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGJhY2stcmVmZXJlbmNlIHRvIHRoZSBgTWF0dGVyLlJlbmRlcmAgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnRyb2xsZXJcbiAgICAgKiBAdHlwZSByZW5kZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgTWF0dGVyLkVuZ2luZWAgaW5zdGFuY2UgdG8gYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmdpbmVcbiAgICAgKiBAdHlwZSBlbmdpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBjYW52YXMgaXMgdG8gYmUgaW5zZXJ0ZWQgKGlmIGByZW5kZXIuY2FudmFzYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVsZW1lbnRcbiAgICAgKiBAdHlwZSBIVE1MRWxlbWVudFxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0byByZW5kZXIgdG8uIElmIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGNyZWF0ZWQgaWYgYHJlbmRlci5lbGVtZW50YCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2FudmFzXG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBgcmVuZGVyLmNhbnZhc2AgdG8gYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLndpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgODAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGByZW5kZXIuY2FudmFzYCB0byBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuaGVpZ2h0XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgNjAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgaWYgYHJlbmRlci5ib3VuZHNgIHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuaGFzQm91bmRzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgZHJhd2luZyB2aWV3IHJlZ2lvbi4gXG4gICAgICogUmVuZGVyaW5nIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cmFuc2Zvcm1lZCBhbmQgc2NhbGVkIHRvIGZpdCB3aXRoaW4gdGhlIGNhbnZhcyBzaXplIChgcmVuZGVyLm9wdGlvbnMud2lkdGhgIGFuZCBgcmVuZGVyLm9wdGlvbnMuaGVpZ2h0YCkuXG4gICAgICogVGhpcyBhbGxvd3MgZm9yIGNyZWF0aW5nIHZpZXdzIHRoYXQgY2FuIHBhbiBvciB6b29tIGFyb3VuZCB0aGUgc2NlbmUuXG4gICAgICogWW91IG11c3QgYWxzbyBzZXQgYHJlbmRlci5vcHRpb25zLmhhc0JvdW5kc2AgdG8gYHRydWVgIHRvIGVuYWJsZSBib3VuZGVkIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZHNcbiAgICAgKiBAdHlwZSBib3VuZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSAyZCByZW5kZXJpbmcgY29udGV4dCBmcm9tIHRoZSBgcmVuZGVyLmNhbnZhc2AgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XG4gICAgICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3ByaXRlIHRleHR1cmUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZXNcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgTk9STUFMOiAwLFxuICAgIEFERDogMSxcbiAgICBNVUxUSVBMWTogMixcbiAgICBTQ1JFRU46IDMsXG4gICAgT1ZFUkxBWTogNCxcbiAgICBEQVJLRU46IDUsXG4gICAgTElHSFRFTjogNixcbiAgICBDT0xPUl9ET0RHRTogNyxcbiAgICBDT0xPUl9CVVJOOiA4LFxuICAgIEhBUkRfTElHSFQ6IDksXG4gICAgU09GVF9MSUdIVDogMTAsXG4gICAgRElGRkVSRU5DRTogMTEsXG4gICAgRVhDTFVTSU9OOiAxMixcbiAgICBIVUU6IDEzLFxuICAgIFNBVFVSQVRJT046IDE0LFxuICAgIENPTE9SOiAxNSxcbiAgICBMVU1JTk9TSVRZOiAxNlxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvQmxlbmRNb2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJ1ZmZlcjE2ID0gZnVuY3Rpb24gKGJ5dGVTaXplKVxue1xuICAgIHRoaXMud29yZExlbmd0aCA9IDA7XG4gICAgdGhpcy53b3JkQ2FwYWNpdHkgPSBieXRlU2l6ZSAvIDI7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVNpemUpO1xuICAgIHRoaXMuaW50VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnVpbnRWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYnVmZmVyKTtcbn07XG5cbkJ1ZmZlcjE2LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy53b3JkTGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy53b3JkTGVuZ3RoICogMjtcbn07XG5cbkJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRCeXRlQ2FwYWNpdHkgPSBmdW5jdGlvbiAoKSBcbntcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbn07XG5cbkJ1ZmZlcjE2LnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uICh3b3JkU2l6ZSlcbntcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMud29yZExlbmd0aDtcbiAgICB0aGlzLndvcmRMZW5ndGggKz0gd29yZFNpemU7XG4gICAgcmV0dXJuIGN1cnJlbnRMZW5ndGg7XG59O1xuXG5CdWZmZXIxNi5wcm90b3R5cGUuZ2V0VXNlZEJ1ZmZlckFzU2hvcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmludFZpZXcuc3ViYXJyYXkoMCwgdGhpcy53b3JkTGVuZ3RoKTtcbn07XG5cbkJ1ZmZlcjE2LnByb3RvdHlwZS5nZXRVc2VkQnVmZmVyQXNXb3JkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy51aW50Vmlldy5zdWJhcnJheSgwLCB0aGlzLndvcmRMZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIxNjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL2J1ZmZlci9CdWZmZXIxNi5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgTk9PUCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gIE5PT1AgKE5vIE9wZXJhdGlvbikgQ2FsbGJhY2tcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTk9PUDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL05PT1AuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuQWN0aW9uc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEFuZ2xlOiByZXF1aXJlKCcuL0FuZ2xlJyksXG4gICAgQ2FsbDogcmVxdWlyZSgnLi9DYWxsJyksXG4gICAgR3JpZEFsaWduOiByZXF1aXJlKCcuL0dyaWRBbGlnbicpLFxuICAgIEluY0FscGhhOiByZXF1aXJlKCcuL0luY0FscGhhJyksXG4gICAgSW5jWDogcmVxdWlyZSgnLi9JbmNYJyksXG4gICAgSW5jWFk6IHJlcXVpcmUoJy4vSW5jWFknKSxcbiAgICBJbmNZOiByZXF1aXJlKCcuL0luY1knKSxcbiAgICBQbGFjZU9uQ2lyY2xlOiByZXF1aXJlKCcuL1BsYWNlT25DaXJjbGUnKSxcbiAgICBQbGFjZU9uTGluZTogcmVxdWlyZSgnLi9QbGFjZU9uTGluZScpLFxuICAgIFBsYWNlT25SZWN0YW5nbGU6IHJlcXVpcmUoJy4vUGxhY2VPblJlY3RhbmdsZScpLFxuICAgIFBsYWNlT25UcmlhbmdsZTogcmVxdWlyZSgnLi9QbGFjZU9uVHJpYW5nbGUnKSxcbiAgICBSYW5kb21DaXJjbGU6IHJlcXVpcmUoJy4vUmFuZG9tQ2lyY2xlJyksXG4gICAgUmFuZG9tRWxsaXBzZTogcmVxdWlyZSgnLi9SYW5kb21FbGxpcHNlJyksXG4gICAgUmFuZG9tTGluZTogcmVxdWlyZSgnLi9SYW5kb21MaW5lJyksXG4gICAgUmFuZG9tUmVjdGFuZ2xlOiByZXF1aXJlKCcuL1JhbmRvbVJlY3RhbmdsZScpLFxuICAgIFJhbmRvbVRyaWFuZ2xlOiByZXF1aXJlKCcuL1JhbmRvbVRyaWFuZ2xlJyksXG4gICAgUm90YXRlOiByZXF1aXJlKCcuL1JvdGF0ZScpLFxuICAgIFJvdGF0ZUFyb3VuZDogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmQnKSxcbiAgICBSb3RhdGVBcm91bmREaXN0YW5jZTogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmREaXN0YW5jZScpLFxuICAgIFNjYWxlWDogcmVxdWlyZSgnLi9TY2FsZVgnKSxcbiAgICBTY2FsZVhZOiByZXF1aXJlKCcuL1NjYWxlWFknKSxcbiAgICBTY2FsZVk6IHJlcXVpcmUoJy4vU2NhbGVZJyksXG4gICAgU2V0QWxwaGE6IHJlcXVpcmUoJy4vU2V0QWxwaGEnKSxcbiAgICBTZXRPcmlnaW46IHJlcXVpcmUoJy4vU2V0T3JpZ2luJyksXG4gICAgU2V0Um90YXRpb246IHJlcXVpcmUoJy4vU2V0Um90YXRpb24nKSxcbiAgICBTZXRTY2FsZTogcmVxdWlyZSgnLi9TZXRTY2FsZScpLFxuICAgIFNldFNjYWxlWDogcmVxdWlyZSgnLi9TZXRTY2FsZVgnKSxcbiAgICBTZXRTY2FsZVk6IHJlcXVpcmUoJy4vU2V0U2NhbGVZJyksXG4gICAgU2V0VmlzaWJsZTogcmVxdWlyZSgnLi9TZXRWaXNpYmxlJyksXG4gICAgU2V0WDogcmVxdWlyZSgnLi9TZXRYJyksXG4gICAgU2V0WFk6IHJlcXVpcmUoJy4vU2V0WFknKSxcbiAgICBTZXRZOiByZXF1aXJlKCcuL1NldFknKSxcbiAgICBTbW9vdGhlclN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoZXJTdGVwJyksXG4gICAgU21vb3RoU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhTdGVwJyksXG4gICAgU3ByZWFkOiByZXF1aXJlKCcuL1NwcmVhZCcpLFxuICAgIFRvZ2dsZVZpc2libGU6IHJlcXVpcmUoJy4vVG9nZ2xlVmlzaWJsZScpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hY3Rpb25zL2luZGV4LmpzIiwidmFyIFJORCA9IHJlcXVpcmUoJy4vcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvLyAgQ09OU1RzIChtYWtlcyB0aGVtIHZpc2libGUgdW5kZXIgUGhhc2VyLk1hdGgpXG4gICAgUEkyOiBNYXRoLlBJICogMixcbiAgICBUQVU6IE1hdGguUEkgKiAwLjUsXG4gICAgRVBTSUxPTjogMS4wZS02LFxuICAgIERFR19UT19SQUQ6IE1hdGguUEkgLyAxODAsXG4gICAgUkFEX1RPX0RFRzogMTgwIC8gTWF0aC5QSSxcblxuICAgIC8vICBDb2xsZWN0aW9ucyBvZiBmdW5jdGlvbnNcbiAgICBBbmdsZTogcmVxdWlyZSgnLi9hbmdsZS8nKSxcbiAgICBEaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZS8nKSxcbiAgICBFYXNpbmc6IHJlcXVpcmUoJy4vZWFzaW5nLycpLFxuICAgIEZ1enp5OiByZXF1aXJlKCcuL2Z1enp5LycpLFxuICAgIEludGVycG9sYXRpb246IHJlcXVpcmUoJy4vaW50ZXJwb2xhdGlvbi8nKSxcbiAgICBQb3cyOiByZXF1aXJlKCcuL3BvdzIvJyksXG4gICAgU25hcDogcmVxdWlyZSgnLi9zbmFwLycpLFxuXG4gICAgLy8gIFJhbmRvbSBEYXRhIEdlbmVyYXRvclxuICAgIFJORDogbmV3IFJORCgpLFxuXG4gICAgLy8gIFNpbmdsZSBmdW5jdGlvbnNcbiAgICBBdmVyYWdlOiByZXF1aXJlKCcuL0F2ZXJhZ2UnKSxcbiAgICBCZXJuc3RlaW46IHJlcXVpcmUoJy4vQmVybnN0ZWluJyksXG4gICAgQmV0d2VlbjogcmVxdWlyZSgnLi9CZXR3ZWVuJyksXG4gICAgQ2F0bXVsbFJvbTogcmVxdWlyZSgnLi9DYXRtdWxsUm9tJyksXG4gICAgQ2VpbFRvOiByZXF1aXJlKCcuL0NlaWxUbycpLFxuICAgIENsYW1wOiByZXF1aXJlKCcuL0NsYW1wJyksXG4gICAgRGVnVG9SYWQ6IHJlcXVpcmUoJy4vRGVnVG9SYWQnKSxcbiAgICBEaWZmZXJlbmNlOiByZXF1aXJlKCcuL0RpZmZlcmVuY2UnKSxcbiAgICBGYWN0b3JpYWw6IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyksXG4gICAgRmxvYXRCZXR3ZWVuOiByZXF1aXJlKCcuL0Zsb2F0QmV0d2VlbicpLFxuICAgIEZsb29yVG86IHJlcXVpcmUoJy4vRmxvb3JUbycpLFxuICAgIExpbmVhcjogcmVxdWlyZSgnLi9MaW5lYXInKSxcbiAgICBNYXhBZGQ6IHJlcXVpcmUoJy4vTWF4QWRkJyksXG4gICAgTWluU3ViOiByZXF1aXJlKCcuL01pblN1YicpLFxuICAgIFBlcmNlbnQ6IHJlcXVpcmUoJy4vUGVyY2VudCcpLFxuICAgIFJhZFRvRGVnOiByZXF1aXJlKCcuL1JhZFRvRGVnJyksXG4gICAgUm90YXRlOiByZXF1aXJlKCcuL1JvdGF0ZScpLFxuICAgIFJvdGF0ZUFyb3VuZDogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmQnKSxcbiAgICBSb3RhdGVBcm91bmREaXN0YW5jZTogcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmREaXN0YW5jZScpLFxuICAgIFJvdW5kQXdheUZyb21aZXJvOiByZXF1aXJlKCcuL1JvdW5kQXdheUZyb21aZXJvJyksXG4gICAgUm91bmRUbzogcmVxdWlyZSgnLi9Sb3VuZFRvJyksXG4gICAgU2luQ29zVGFibGVHZW5lcmF0b3I6IHJlcXVpcmUoJy4vU2luQ29zVGFibGVHZW5lcmF0b3InKSxcbiAgICBTbW9vdGhlclN0ZXA6IHJlcXVpcmUoJy4vU21vb3RoZXJTdGVwJyksXG4gICAgU21vb3RoU3RlcDogcmVxdWlyZSgnLi9TbW9vdGhTdGVwJyksXG4gICAgV2l0aGluOiByZXF1aXJlKCcuL1dpdGhpbicpLFxuICAgIFdyYXA6IHJlcXVpcmUoJy4vV3JhcCcpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2luZGV4LmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIFN5c3RlbXMgPSByZXF1aXJlKCcuL1N5c3RlbXMnKTtcblxuLyoqXG4qIEEgQmFzZSBTdGF0ZSBDbGFzcy5cbipcbiogQGNsYXNzIFBoYXNlci5TdGF0ZVxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgU3RhdGUgPSBmdW5jdGlvbiAoY29uZmlnKVxue1xuICAgIC8vICBUaGUgU3RhdGUgU3lzdGVtcy4gWW91IG11c3QgbmV2ZXIgb3ZlcndyaXRlIHRoaXMgcHJvcGVydHksIG9yIGFsbCBoZWxsIHdpbGwgYnJlYWsgbG9zZS5cbiAgICB0aGlzLnN5cyA9IG5ldyBTeXN0ZW1zKHRoaXMsIGNvbmZpZyk7XG5cbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zeXMuc2V0dGluZ3M7XG59O1xuXG5TdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGF0ZTtcblxuU3RhdGUucHJvdG90eXBlID0ge1xuXG4gICAgLy8gIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHlvdXIgb3duIFN0YXRlc1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgfSxcblxuICAgIC8vICBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSB5b3VyIG93biBTdGF0ZXNcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TdGF0ZS5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlLmw7IH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUuaTsgfVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNhbnZhcywgb3B0aW9ucylcbntcbiAgICByZXR1cm4gKFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCBvcHRpb25zKSB8fCBcbiAgICAgICAgbnVsbFxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldENvbnRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYW52YXMvR2V0Q29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50Jyk7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xuXG4vKipcbiogVGhlIERhdGEgQ29tcG9uZW50IGZlYXR1cmVzIGEgbWVhbnMgdG8gc3RvcmUgcGllY2VzIG9mIGRhdGEgc3BlY2lmaWMgdG8gYSBHYW1lIE9iamVjdCxcbiogc2VhcmNoIGl0LCBxdWVyeSBpdCwgYW5kIHJldHJpZXZlIGl0LlxuKlxuKiBAY2xhc3NcbiovXG52YXIgRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQpXG57XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIHRoaXMubGlzdCA9IHt9O1xuXG4gICAgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3MgPSB7fTtcblxuICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xufTtcblxuRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuICAgIC8vICBSZXRyaWV2ZXMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV07XG4gICAgfSxcblxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdGhpcy5saXN0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgcXVlcnk6IGZ1bmN0aW9uIChzZWFyY2gpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goc2VhcmNoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0aGlzLmxpc3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZnJvemVuKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSAnYmVmb3JlJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuX2JlZm9yZUNhbGxiYWNrc1trZXldO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKGxpc3RlbmVyLnNjb3BlLCB0aGlzLnBhcmVudCwga2V5LCBkYXRhKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XG5cbiAgICAgICAgLy8gIElmIHRoZXJlIGlzIGEgJ2FmdGVyJyBjYWxsYmFjaywgdGhlbiBjaGVjayBpdCBmb3IgYSByZXN1bHRcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcblxuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci5zY29wZSwgdGhpcy5wYXJlbnQsIGtleSwgZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCBzY29wZSlcbiAgICB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgUmVtb3ZlIGVudHJ5XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZnRlcjogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHNjb3BlKVxuICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBSZW1vdmUgZW50cnlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hZnRlckNhbGxiYWNrc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzY29wZTogc2NvcGUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFBhc3NlcyBhbGwgZGF0YSBlbnRyaWVzIHRvIHRoZSBnaXZlbiBjYWxsYmFjay4gU3RvcmVzIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBtZXRob2QgZWFjaFxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGVdIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3VtZW50c10gLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgYWZ0ZXIgdGhlIGdhbWUgb2JqZWN0LCBrZXksIGFuZCBkYXRhLlxuICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSlcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gWyB0aGlzLnBhcmVudCwgbnVsbCwgdW5kZWZpbmVkIF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgYXJnc1sxXSA9IGtleTtcbiAgICAgICAgICAgIGFyZ3NbMl0gPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lcmdlOiBmdW5jdGlvbiAoZGF0YSwgb3ZlcndyaXRlKVxuICAgIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJ3cml0ZSA9IHRydWU7IH1cblxuICAgICAgICAvLyAgTWVyZ2UgZGF0YSBmcm9tIGFub3RoZXIgY29tcG9uZW50IGludG8gdGhpcyBvbmVcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvdmVyd3JpdGUgfHwgKCFvdmVyd3JpdGUgJiYgIXRoaXMuaGFzKGtleSkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2Zyb3plbiAmJiB0aGlzLmhhcyhrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2JlZm9yZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmVmb3JlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWZ0ZXJDYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FmdGVyQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIEdldHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiAna2V5JywgZGVsZXRlcyBpdCBmcm9tIHRoaXMgRGF0YSBzdG9yZSwgdGhlbiByZXR1cm5zIGl0LlxuICAgIHBvcDogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuICYmIHRoaXMuaGFzKGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdFtrZXldO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9iZWZvcmVDYWxsYmFja3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9iZWZvcmVDYWxsYmFja3Nba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX2FmdGVyQ2FsbGJhY2tzKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWZ0ZXJDYWxsYmFja3Nba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0YS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogRnJlZXplIHRoaXMgRGF0YSBjb21wb25lbnQsIHNvIG5vIGNoYW5nZXMgY2FuIGJlIHdyaXR0ZW4gdG8gaXQuXG4gICAgKlxuICAgICogQG5hbWUgZnJlZXplXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZyZWV6ZVxuICAgICovXG4gICAgZnJlZXplOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm96ZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb3plbiA9ICh2YWx1ZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBjb3VudDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0RhdGEuanMiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XG5cbnZhciBDYW52YXNGZWF0dXJlcyA9IHtcblxuICAgIHN1cHBvcnROZXdCbGVuZE1vZGVzOiBmYWxzZSxcblxuICAgIHN1cHBvcnRJbnZlcnNlQWxwaGE6IGZhbHNlXG5cbn07XG5cbmZ1bmN0aW9uIGNoZWNrQmxlbmRNb2RlICgpXG57XG4gICAgdmFyIHBuZ0hlYWQgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBUUFBQUFCQVFNQUFBREQ4cDJPQUFBQUExQk1WRVgvJztcbiAgICB2YXIgcG5nRW5kID0gJ0FBQUFDa2xFUVZRSTEyTmdBQUFBQWdBQjRpRzhNd0FBQUFCSlJVNUVya0pnZ2c9PSc7XG5cbiAgICB2YXIgbWFnZW50YSA9IG5ldyBJbWFnZSgpO1xuICAgIG1hZ2VudGEuc3JjID0gcG5nSGVhZCArICdBUDgwNE9hNicgKyBwbmdFbmQ7XG5cbiAgICB2YXIgeWVsbG93ID0gbmV3IEltYWdlKCk7XG4gICAgeWVsbG93LnNyYyA9IHBuZ0hlYWQgKyAnL3dDS3h2UkYnICsgcG5nRW5kO1xuXG4gICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIDYsIDEpO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UobWFnZW50YSwgMCwgMCk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcblxuICAgIGlmICghY29udGV4dC5nZXRJbWFnZURhdGEoMiwgMCwgMSwgMSkpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgyLCAwLCAxLCAxKS5kYXRhO1xuXG4gICAgQ2FudmFzUG9vbC5yZW1vdmUodGhpcyk7XG5cbiAgICByZXR1cm4gKGRhdGFbMF0gPT09IDI1NSAmJiBkYXRhWzFdID09PSAwICYmIGRhdGFbMl0gPT09IDApO1xufVxuXG5mdW5jdGlvbiBjaGVja0ludmVyc2VBbHBoYSAoKVxue1xuICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzLCAyLCAxKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgxMCwgMjAsIDMwLCAwLjUpJztcblxuICAgIC8vICBEcmF3IGEgc2luZ2xlIHBpeGVsXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblxuICAgIC8vICBHZXQgdGhlIGNvbG9yIHZhbHVlc1xuICAgIHZhciBzMSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuXG4gICAgaWYgKHMxID09PSBudWxsKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vICBQbG90IHRoZW0gdG8geDJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShzMSwgMSwgMCk7XG5cbiAgICAvLyAgR2V0IHRob3NlIHZhbHVlc1xuICAgIHZhciBzMiA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDEsIDAsIDEsIDEpO1xuXG4gICAgLy8gIENvbXBhcmUgYW5kIHJldHVyblxuICAgIHJldHVybiAoczIuZGF0YVswXSA9PT0gczEuZGF0YVswXSAmJiBzMi5kYXRhWzFdID09PSBzMS5kYXRhWzFdICYmIHMyLmRhdGFbMl0gPT09IHMxLmRhdGFbMl0gJiYgczIuZGF0YVszXSA9PT0gczEuZGF0YVszXSk7XG59XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICBpZiAoZG9jdW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIENhbnZhc0ZlYXR1cmVzLnN1cHBvcnROZXdCbGVuZE1vZGVzID0gY2hlY2tCbGVuZE1vZGUoKTtcbiAgICAgICAgQ2FudmFzRmVhdHVyZXMuc3VwcG9ydEludmVyc2VBbHBoYSA9IGNoZWNrSW52ZXJzZUFscGhhKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENhbnZhc0ZlYXR1cmVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9DYW52YXNGZWF0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0NhbnZhc0ZlYXR1cmVzLmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcblxudmFyIEZlYXR1cmVzID0ge1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbnZhcyAtIElzIGNhbnZhcyBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgY2FudmFzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gY2FudmFzQml0Qmx0U2hpZnQgLSBUcnVlIGlmIGNhbnZhcyBzdXBwb3J0cyBhICdjb3B5JyBiaXRibHQgb250byBpdHNlbGYgd2hlbiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiByZWdpb25zIG92ZXJsYXAuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgY2FudmFzQml0Qmx0U2hpZnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2ViR0wgLSBJcyB3ZWJHTCBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgd2ViR0w6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGUgLSBJcyBmaWxlIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBmaWxlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBmaWxlU3lzdGVtIC0gSXMgZmlsZVN5c3RlbSBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgZmlsZVN5c3RlbTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jYWxTdG9yYWdlIC0gSXMgbG9jYWxTdG9yYWdlIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBsb2NhbFN0b3JhZ2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdvcmtlciAtIElzIHdvcmtlciBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgd29ya2VyOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBwb2ludGVyTG9jayAtIElzIFBvaW50ZXIgTG9jayBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgcG9pbnRlckxvY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpYnJhdGlvbiAtIERvZXMgdGhlIGRldmljZSBzdXBwb3J0IHRoZSBWaWJyYXRpb24gQVBJP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHZpYnJhdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZ2V0VXNlck1lZGlhIC0gRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgdGhlIGdldFVzZXJNZWRpYSBBUEk/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgZ2V0VXNlck1lZGlhOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiAtIElzIHRoZSBkZXZpY2UgYmlnIG9yIGxpdHRsZSBlbmRpYW4/IChvbmx5IGRldGVjdGVkIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFR5cGVkQXJyYXlzKVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIGxpdHRsZUVuZGlhbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3VwcG9ydDMyYml0IC0gRG9lcyB0aGUgZGV2aWNlIGNvbnRleHQgc3VwcG9ydCAzMmJpdCBwaXhlbCBtYW5pcHVsYXRpb24gdXNpbmcgYXJyYXkgYnVmZmVyIHZpZXdzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHN1cHBvcnQzMmJpdDogZmFsc2VcblxufTtcblxuLyoqXG4qIENoZWNrIExpdHRsZSBvciBCaWcgRW5kaWFuIHN5c3RlbS5cbipcbiogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXG4qL1xuZnVuY3Rpb24gY2hlY2tJc0xpdHRsZUVuZGlhbiAoKVxue1xuICAgIHZhciBhID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgdmFyIGMgPSBuZXcgVWludDMyQXJyYXkoYSk7XG5cbiAgICBiWzBdID0gMHhhMTtcbiAgICBiWzFdID0gMHhiMjtcbiAgICBiWzJdID0gMHhjMztcbiAgICBiWzNdID0gMHhkNDtcblxuICAgIGlmIChjWzBdID09PSAweGQ0YzNiMmExKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNbMF0gPT09IDB4YTFiMmMzZDQpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vICBDb3VsZCBub3QgZGV0ZXJtaW5lIGVuZGlhbm5lc3NcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgRmVhdHVyZXMuY2FudmFzID0gISF3aW5kb3dbJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCddIHx8IE9TLmNvY29vbkpTO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5sb2NhbFN0b3JhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBGZWF0dXJlcy5maWxlID0gISF3aW5kb3dbJ0ZpbGUnXSAmJiAhIXdpbmRvd1snRmlsZVJlYWRlciddICYmICEhd2luZG93WydGaWxlTGlzdCddICYmICEhd2luZG93WydCbG9iJ107XG4gICAgRmVhdHVyZXMuZmlsZVN5c3RlbSA9ICEhd2luZG93WydyZXF1ZXN0RmlsZVN5c3RlbSddO1xuXG4gICAgdmFyIGlzVWludDggPSBmYWxzZTtcblxuICAgIHZhciB0ZXN0V2ViR0wgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHdpbmRvd1snV2ViR0xSZW5kZXJpbmdDb250ZXh0J10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZVdlYkdMKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKE9TLmNvY29vbkpTKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNjcmVlbmNhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzMkQgPSBDYW52YXNQb29sLmNyZWF0ZTJEKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN0eDJEID0gY2FudmFzMkQuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIC8vICBDYW4ndCBiZSBkb25lIG9uIGEgd2ViZ2wgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGN0eDJELmNyZWF0ZUltYWdlRGF0YSgxLCAxKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIFRlc3QgdG8gc2VlIGlmIEltYWdlRGF0YSB1c2VzIENhbnZhc1BpeGVsQXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXkuXG4gICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIChAbWF0dGRlc2wpXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpc1VpbnQ4ID0gaW1hZ2UuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5O1xuXG4gICAgICAgICAgICAgICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcbiAgICAgICAgICAgICAgICBDYW52YXNQb29sLnJlbW92ZShjYW52YXMyRCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGN0eCAhPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgRmVhdHVyZXMud2ViR0wgPSB0cnVlOy8vdGVzdFdlYkdMKCk7XG5cbiAgICBGZWF0dXJlcy53b3JrZXIgPSAhIXdpbmRvd1snV29ya2VyJ107XG5cbiAgICBGZWF0dXJlcy5wb2ludGVyTG9jayA9ICdwb2ludGVyTG9ja0VsZW1lbnQnIGluIGRvY3VtZW50IHx8ICdtb3pQb2ludGVyTG9ja0VsZW1lbnQnIGluIGRvY3VtZW50IHx8ICd3ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQnIGluIGRvY3VtZW50O1xuXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iub0dldFVzZXJNZWRpYTtcblxuICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgJiYgISFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmICEhd2luZG93LlVSTDtcblxuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGZpcmVmb3ggKDwgMjEpIGFwcGFyZW50bHkgY2xhaW0gc3VwcG9ydCBidXQgdXNlciBtZWRpYSBkb2VzIG5vdCBhY3R1YWxseSB3b3JrXG4gICAgaWYgKEJyb3dzZXIuZmlyZWZveCAmJiBCcm93c2VyLmZpcmVmb3hWZXJzaW9uIDwgMjEpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy5nZXRVc2VyTWVkaWEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBFeGNsdWRlcyBpT1MgdmVyc2lvbnMgYXMgdGhleSBnZW5lcmFsbHkgd3JhcCBVSVdlYlZpZXcgKGVnLiBTYWZhcmkgV2ViS2l0KSBhbmQgaXRcbiAgICAvLyBpcyBzYWZlciB0byBub3QgdHJ5IGFuZCB1c2UgdGhlIGZhc3QgY29weS1vdmVyIG1ldGhvZC5cbiAgICBpZiAoIU9TLmlPUyAmJiAoQnJvd3Nlci5pZSB8fCBCcm93c2VyLmZpcmVmb3ggfHwgQnJvd3Nlci5jaHJvbWUpKVxuICAgIHtcbiAgICAgICAgRmVhdHVyZXMuY2FudmFzQml0Qmx0U2hpZnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEtub3duIG5vdCB0byB3b3JrXG4gICAgaWYgKEJyb3dzZXIuc2FmYXJpIHx8IEJyb3dzZXIubW9iaWxlU2FmYXJpKVxuICAgIHtcbiAgICAgICAgRmVhdHVyZXMuY2FudmFzQml0Qmx0U2hpZnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuYXZpZ2F0b3IudmlicmF0ZSA9IG5hdmlnYXRvci52aWJyYXRlIHx8IG5hdmlnYXRvci53ZWJraXRWaWJyYXRlIHx8IG5hdmlnYXRvci5tb3pWaWJyYXRlIHx8IG5hdmlnYXRvci5tc1ZpYnJhdGU7XG5cbiAgICBpZiAobmF2aWdhdG9yLnZpYnJhdGUpXG4gICAge1xuICAgICAgICBGZWF0dXJlcy52aWJyYXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgIHtcbiAgICAgICAgRmVhdHVyZXMubGl0dGxlRW5kaWFuID0gY2hlY2tJc0xpdHRsZUVuZGlhbigpO1xuICAgIH1cblxuICAgIEZlYXR1cmVzLnN1cHBvcnQzMmJpdCA9IChcbiAgICAgICAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBGZWF0dXJlcy5saXR0bGVFbmRpYW4gIT09IG51bGwgJiZcbiAgICAgICAgaXNVaW50OFxuICAgICk7XG5cbiAgICByZXR1cm4gRmVhdHVyZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0ZlYXR1cmVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvRmVhdHVyZXMuanMiLCJ2YXIgQWRkVG9ET00gPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50LCBvdmVyZmxvd0hpZGRlbilcbntcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4gPT09IHVuZGVmaW5lZCkgeyBvdmVyZmxvd0hpZGRlbiA9IHRydWU7IH1cblxuICAgIHZhciB0YXJnZXQ7XG5cbiAgICBpZiAocGFyZW50KVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgSG9wZWZ1bGx5IGFuIGVsZW1lbnQgSURcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmVudCA9PT0gJ29iamVjdCcgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgUXVpY2sgdGVzdCBmb3IgYSBIVE1MZWxlbWVudFxuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gIEZhbGxiYWNrLCBjb3ZlcnMgYW4gaW52YWxpZCBJRCBhbmQgYSBub24gSFRNTGVsZW1lbnQgb2JqZWN0XG4gICAgaWYgKCF0YXJnZXQpXG4gICAge1xuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGlmIChvdmVyZmxvd0hpZGRlbiAmJiB0YXJnZXQuc3R5bGUpXG4gICAge1xuICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkVG9ET007XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vQWRkVG9ET00uanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBPUyA9IHJlcXVpcmUoJy4uL2RldmljZS9PUycpO1xuXG52YXIgaXNCb290ZWQgPSBmYWxzZTtcblxudmFyIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spXG57XG4gICAgaWYgKGlzQm9vdGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpXG4gICAge1xuICAgICAgICBpc0Jvb3RlZCA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBjYWxsYmFjaygpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaXNCb290ZWQgPSB0cnVlO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgY2hlY2ssIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2hlY2ssIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNoZWNrLCB0cnVlKTtcblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBpZiAoIWRvY3VtZW50LmJvZHkpXG4gICAge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVjaywgMjApO1xuICAgIH1cbiAgICBlbHNlIGlmIChPUy5jb3Jkb3ZhICYmICFPUy5jb2Nvb25KUylcbiAgICB7XG4gICAgICAgIC8vICBSZWYuIGh0dHA6Ly9kb2NzLnBob25lZ2FwLmNvbS9lbi8zLjUuMC9jb3Jkb3ZhX2V2ZW50c19ldmVudHMubWQuaHRtbCNkZXZpY2VyZWFkeVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGNoZWNrLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjaGVjaywgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2hlY2ssIHRydWUpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ29udGVudExvYWRlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9ET01Db250ZW50TG9hZGVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb20vRE9NQ29udGVudExvYWRlZC5qcyIsInZhciBQYXJzZVhNTCA9IGZ1bmN0aW9uIChkYXRhKVxue1xuICAgIHZhciB4bWwgPSAnJztcblxuICAgIHRyeVxuICAgIHtcbiAgICAgICAgaWYgKHdpbmRvd1snRE9NUGFyc2VyJ10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICB4bWwgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKGRhdGEsICd0ZXh0L3htbCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgeG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgICAgIHhtbC5sb2FkWE1MKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKVxuICAgIHtcbiAgICAgICAgeG1sID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiB4bWw7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVhNTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9QYXJzZVhNTC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XG5cbi8qKlxuKiBBYnN0cmFjdHMgYXdheSB0aGUgdXNlIG9mIFJBRiBvciBzZXRUaW1lT3V0IGZvciB0aGUgY29yZSBnYW1lIHVwZGF0ZSBsb29wLlxuKlxuKiBAY2xhc3MgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtib29sZWFufSBbZm9yY2VTZXRUaW1lT3V0PWZhbHNlXSAtIFRlbGwgUGhhc2VyIHRvIHVzZSBzZXRUaW1lT3V0IGV2ZW4gaWYgcmFmIGlzIGF2YWlsYWJsZS5cbiovXG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKClcbntcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNSdW5uaW5nIC0gdHJ1ZSBpZiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaXMgcnVubmluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gTk9PUDtcblxuICAgIHRoaXMudGljayA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTZXRUaW1lT3V0ICAtIFRydWUgaWYgdGhlIGJyb3dzZXIgaXMgdXNpbmcgc2V0VGltZW91dCBpbnN0ZWFkIG9mIHJBZi5cbiAgICAqL1xuICAgIHRoaXMuaXNTZXRUaW1lT3V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lT3V0SUQgLSBUaGUgY2FsbGJhY2sgc2V0VGltZW91dCBvciByQWYgY2FsbGJhY2sgSUQgdXNlZCB3aGVuIGNhbGxpbmcgY2FuY2VsLlxuICAgICovXG4gICAgdGhpcy50aW1lT3V0SUQgPSBudWxsO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vICB0aW1lc3RhbXAgPSBET01IaWdoUmVzVGltZVN0YW1wXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAodGltZXN0YW1wKVxuICAgIHtcbiAgICAgICAgX3RoaXMudGljayA9IHRpbWVzdGFtcDtcblxuICAgICAgICBfdGhpcy50aW1lT3V0SUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gICAgfTtcblxuICAgIHZhciBzdGVwVGltZW91dCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgX3RoaXMudGljayA9IGQ7XG5cbiAgICAgICAgX3RoaXMudGltZU91dElEID0gd2luZG93LnNldFRpbWVvdXQoc3RlcFRpbWVvdXQsIF90aGlzLnRpbWVUb0NhbGwpO1xuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKGQpO1xuICAgIH07XG5cbiAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgIHRoaXMuc3RlcFRpbWVvdXQgPSBzdGVwVGltZW91dDtcbn07XG5cblJlcXVlc3RBbmltYXRpb25GcmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cblJlcXVlc3RBbmltYXRpb25GcmFtZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAqIFN0YXJ0cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJ1bm5pbmcgb3Igc2V0VGltZW91dCBpZiB1bmF2YWlsYWJsZSBpbiBicm93c2VyXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SZXF1ZXN0QW5pbWF0aW9uRnJhbWUjc3RhcnRcbiAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGZvcmNlU2V0VGltZU91dClcbiAgICB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICB0aGlzLmlzU2V0VGltZU91dCA9IGZvcmNlU2V0VGltZU91dDtcblxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLnRpbWVPdXRJRCA9IChmb3JjZVNldFRpbWVPdXQpID8gd2luZG93LnNldFRpbWVvdXQoX3RoaXMuc3RlcFRpbWVvdXQsIDApIDogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5zdGVwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBTdG9wcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gcnVubmluZy5cbiAgICAqIEBtZXRob2QgUGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZSNzdG9wXG4gICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5pc1NldFRpbWVPdXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lT3V0SUQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gTk9PUDtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9tL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsInZhciBFVkVOVF9DT05TVCA9IHtcblxuICAgIERJU1BBVENIRVJfSURMRTogMCxcbiAgICBESVNQQVRDSEVSX0RJU1BBVENISU5HOiAxLFxuICAgIERJU1BBVENIRVJfUkVNT1ZJTkc6IDIsXG4gICAgRElTUEFUQ0hFUl9ERVNUUk9ZRUQ6IDMsXG5cbiAgICBMSVNURU5FUl9QRU5ESU5HOiA0LFxuICAgIExJU1RFTkVSX0FDVElWRTogNSxcbiAgICBMSVNURU5FUl9SRU1PVklORzogNlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVWRU5UX0NPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZXZlbnRzL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBHZXRCaXRtYXBUZXh0U2l6ZSA9IGZ1bmN0aW9uIChzcmMpXG57XG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcbiAgICB2YXIgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuXG4gICAgdmFyIGJ4ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgYnkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBidyA9IDA7XG4gICAgdmFyIGJoID0gMDtcbiAgICBcbiAgICB2YXIgY2hhcnMgPSBzcmMuZm9udERhdGEuY2hhcnM7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcblxuICAgIHZhciB4QWR2YW5jZSA9IDA7XG4gICAgdmFyIHlBZHZhbmNlID0gMDtcblxuICAgIHZhciBpbmRleENvdW50ID0gMDtcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xuXG4gICAgdmFyIGdseXBoID0gbnVsbDtcbiAgICB2YXIgZ2x5cGhXID0gMDtcbiAgICB2YXIgZ2x5cGhIID0gMDtcblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG5cbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxuICAgIHtcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcblxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcbiAgICAgICAgeSA9IGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZTtcblxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChieCA+IHgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJ4ID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChieSA+IHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJ5ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBndyA9IHggKyBnbHlwaFcgLSBieDtcbiAgICAgICAgdmFyIGdoID0geSArIGdseXBoSCAtIGJ5O1xuXG4gICAgICAgIGlmIChidyA8IGd3KVxuICAgICAgICB7XG4gICAgICAgICAgICBidyA9IGd3O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoYmggPCBnaClcbiAgICAgICAge1xuICAgICAgICAgICAgYmggPSBnaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhBZHZhbmNlICs9IGdseXBoLnhBZHZhbmNlO1xuICAgICAgICBpbmRleENvdW50ICs9IDE7XG4gICAgICAgIGxhc3RHbHlwaCA9IGdseXBoO1xuICAgICAgICBsYXN0Q2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xuICAgIHZhciBzeCA9IHNjYWxlICogc3JjLnNjYWxlWDtcbiAgICB2YXIgc3kgPSBzY2FsZSAqIHNyYy5zY2FsZVk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbDoge1xuICAgICAgICAgICAgeDogYnggKiBzY2FsZSxcbiAgICAgICAgICAgIHk6IGJ5ICogc2NhbGUsXG4gICAgICAgICAgICB3aWR0aDogYncgKiBzY2FsZSxcbiAgICAgICAgICAgIGhlaWdodDogYmggKiBzY2FsZVxuICAgICAgICB9LFxuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICAgIHg6IHNyYy54ICsgKGJ4ICogc3gpLFxuICAgICAgICAgICAgeTogc3JjLnkgKyAoYnkgKiBzeSksXG4gICAgICAgICAgICB3aWR0aDogYncgKiBzeCxcbiAgICAgICAgICAgIGhlaWdodDogYmggKiBzeVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Qml0bWFwVGV4dFNpemU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L0dldEJpdG1hcFRleHRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYXNzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvQ2xhc3MnKTtcbnZhciBHYW1lT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vR2FtZU9iamVjdCcpO1xudmFyIENvbXBvbmVudHMgPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzJyk7XG52YXIgUmVuZGVyID0gcmVxdWlyZSgnLi9EeW5hbWljQml0bWFwVGV4dFJlbmRlcicpO1xudmFyIEdldEJpdG1hcFRleHRTaXplID0gcmVxdWlyZSgnLi4vR2V0Qml0bWFwVGV4dFNpemUnKTtcblxudmFyIER5bmFtaWNCaXRtYXBUZXh0ID0gbmV3IENsYXNzKHtcblxuICAgIE1peGluczogW1xuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJQYXNzLFxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXG4gICAgICAgIFJlbmRlclxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gRHluYW1pY0JpdG1hcFRleHQgKHN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcbiAgICB7XG4gICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHsgdGV4dCA9ICcnOyB9XG4gICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHsgc2l6ZSA9IDMyOyB9XG4gICAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7IGFsaWduID0gJ2xlZnQnOyB9XG5cbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgICAgICB0aGlzLmZvbnREYXRhID0gdGhpcy5zdGF0ZS5zeXMuY2FjaGUuYml0bWFwRm9udC5nZXQoZm9udCk7XG5cbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcblxuICAgICAgICB0aGlzLmRpc3BsYXlDYWxsYmFjaztcblxuICAgICAgICB0aGlzLnNldFRleHR1cmUoZm9udCk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlclBhc3NDb21wb25lbnQoKTtcbiAgICB9LFxuXG4gICAgc2V0RGlzcGxheUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2spXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BsYXlDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGb250U2l6ZTogZnVuY3Rpb24gKHNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0VGV4dDogZnVuY3Rpb24gKHRleHQpXG4gICAge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyB7XG4gICAgLy8gICAgIGxvY2FsOiB7XG4gICAgLy8gICAgICAgICB4LFxuICAgIC8vICAgICAgICAgeSxcbiAgICAvLyAgICAgICAgIHdpZHRoLFxuICAgIC8vICAgICAgICAgaGVpZ2h0XG4gICAgLy8gICAgIH0sXG4gICAgLy8gICAgIGdsb2JhbDoge1xuICAgIC8vICAgICAgICAgeCxcbiAgICAvLyAgICAgICAgIHksXG4gICAgLy8gICAgICAgICB3aWR0aCxcbiAgICAvLyAgICAgICAgIGhlaWdodFxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBsb2NhbCA9IHRoZSBCaXRtYXBUZXh0IGJhc2VkIG9uIGZvbnRTaXplIGFuZCAweDAgY29vcmRzXG4gICAgICAgIC8vICBnbG9iYWwgPSB0aGUgQml0bWFwVGV4dCwgdGFraW5nIGludG8gYWNjb3VudCBzY2FsZSBhbmQgd29ybGQgcG9zaXRpb25cblxuICAgICAgICByZXR1cm4gR2V0Qml0bWFwVGV4dFNpemUodGhpcyk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljQml0bWFwVGV4dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dC5qcyIsInZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL0NsYXNzJyk7XG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL0dhbWVPYmplY3QnKTtcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cycpO1xudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4vQml0bWFwVGV4dFJlbmRlcicpO1xudmFyIEdldEJpdG1hcFRleHRTaXplID0gcmVxdWlyZSgnLi4vR2V0Qml0bWFwVGV4dFNpemUnKTtcblxudmFyIEJpdG1hcFRleHQgPSBuZXcgQ2xhc3Moe1xuXG4gICAgTWl4aW5zOiBbXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcbiAgICAgICAgQ29tcG9uZW50cy5TaXplLFxuICAgICAgICBDb21wb25lbnRzLlRleHR1cmUsXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxuICAgICAgICBDb21wb25lbnRzLlJlbmRlclBhc3MsXG4gICAgICAgIENvbXBvbmVudHMuVmlzaWJsZSxcbiAgICAgICAgUmVuZGVyXG4gICAgXSxcblxuICAgIGluaXRpYWxpemU6XG5cbiAgICBmdW5jdGlvbiBCaXRtYXBUZXh0IChzdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXG4gICAge1xuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7IHRleHQgPSAnJzsgfVxuICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7IHNpemUgPSAzMjsgfVxuICAgICAgICBpZiAoYWxpZ24gPT09IHVuZGVmaW5lZCkgeyBhbGlnbiA9ICdsZWZ0JzsgfVxuXG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5mb250RGF0YSA9IHRoaXMuc3RhdGUuc3lzLmNhY2hlLmJpdG1hcEZvbnQuZ2V0KGZvbnQpO1xuXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IHNpemU7XG5cbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKGZvbnQpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xuICAgICAgICB0aGlzLnNldE9yaWdpbigwLCAwKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyUGFzc0NvbXBvbmVudCgpO1xuICAgIH0sXG5cbiAgICBzZXRGb250U2l6ZTogZnVuY3Rpb24gKHNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gc2l6ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0VGV4dDogZnVuY3Rpb24gKHRleHQpXG4gICAge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyB7XG4gICAgLy8gICAgIGxvY2FsOiB7XG4gICAgLy8gICAgICAgICB4LFxuICAgIC8vICAgICAgICAgeSxcbiAgICAvLyAgICAgICAgIHdpZHRoLFxuICAgIC8vICAgICAgICAgaGVpZ2h0XG4gICAgLy8gICAgIH0sXG4gICAgLy8gICAgIGdsb2JhbDoge1xuICAgIC8vICAgICAgICAgeCxcbiAgICAvLyAgICAgICAgIHksXG4gICAgLy8gICAgICAgICB3aWR0aCxcbiAgICAvLyAgICAgICAgIGhlaWdodFxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgZ2V0VGV4dEJvdW5kczogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBsb2NhbCA9IHRoZSBCaXRtYXBUZXh0IGJhc2VkIG9uIGZvbnRTaXplIGFuZCAweDAgY29vcmRzXG4gICAgICAgIC8vICBnbG9iYWwgPSB0aGUgQml0bWFwVGV4dCwgdGFraW5nIGludG8gYWNjb3VudCBzY2FsZSBhbmQgd29ybGQgcG9zaXRpb25cblxuICAgICAgICByZXR1cm4gR2V0Qml0bWFwVGV4dFNpemUodGhpcyk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHQuanMiLCJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XG52YXIgR2FtZU9iamVjdCA9IHJlcXVpcmUoJy4uL0dhbWVPYmplY3QnKTtcbnZhciBDb21wb25lbnRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cycpO1xudmFyIEJsaXR0ZXJSZW5kZXIgPSByZXF1aXJlKCcuL0JsaXR0ZXJSZW5kZXInKTtcbnZhciBCb2IgPSByZXF1aXJlKCcuL0JvYicpO1xuXG4vKipcbiogQSBCbGl0dGVyIEdhbWUgT2JqZWN0LlxuKlxuKiBUaGUgQmxpdHRlciBHYW1lIE9iamVjdCBpcyBhIHNwZWNpYWwgdHlwZSBvZiBDb250YWluZXIsIHRoYXQgY29udGFpbnMgQmxpdHRlci5Cb2Igb2JqZWN0cy5cbiogVGhlc2Ugb2JqZWN0cyBjYW4gYmUgdGhvdWdodCBvZiBhcyBqdXN0IHRleHR1cmUgZnJhbWVzIHdpdGggYSBwb3NpdGlvbiBhbmQgbm90aGluZyBtb3JlLlxuKiBCb2JzIGRvbid0IGhhdmUgYW55IHVwZGF0ZSBtZXRob2RzLCBvciB0aGUgYWJpbGl0eSB0byBoYXZlIGNoaWxkcmVuLCBvciBhbnkga2luZCBvZiBzcGVjaWFsIGVmZmVjdHMuXG4qIFRoZXkgYXJlIGVzc2VudGlhbGx5IGp1c3Qgc3VwZXItZmFzdCB0ZXh0dXJlIGZyYW1lIHJlbmRlcmVycywgYW5kIHRoZSBCbGl0dGVyIG9iamVjdCBjcmVhdGVzIGFuZCBtYW5hZ2VzIHRoZW0uXG4qXG4qIEBjbGFzcyBCbGl0dGVyXG4qIEBleHRlbmRzIFBoYXNlci5HYW1lT2JqZWN0XG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXG4qIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIEltYWdlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIEltYWdlIG1heSBiZSBpbi5cbiogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxuKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gLSBUaGUgdGV4dHVyZSB1c2VkIGJ5IHRoZSBJbWFnZSBkdXJpbmcgcmVuZGVyaW5nLiBJdCBjYW4gYmUgYSBzdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gdGhlIENhY2hlIGVudHJ5LCBvciBhbiBpbnN0YW5jZSBvZiBhIFJlbmRlclRleHR1cmUsIEJpdG1hcERhdGEgb3IgUElYSS5UZXh0dXJlLlxuKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiB0aGlzIEltYWdlIGlzIHVzaW5nIHBhcnQgb2YgYSBzcHJpdGUgc2hlZXQgb3IgdGV4dHVyZSBhdGxhcyB5b3UgY2FuIHNwZWNpZnkgdGhlIGV4YWN0IGZyYW1lIHRvIHVzZSBieSBnaXZpbmcgYSBzdHJpbmcgb3IgbnVtZXJpYyBpbmRleC5cbiovXG5cbnZhciBCbGl0dGVyID0gbmV3IENsYXNzKHtcblxuICAgIE1peGluczogW1xuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJQYXNzLFxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXG4gICAgICAgIEJsaXR0ZXJSZW5kZXJcbiAgICBdLFxuXG4gICAgaW5pdGlhbGl6ZTpcblxuICAgIGZ1bmN0aW9uIEJsaXR0ZXIgKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcbiAgICB7XG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENvbXBvbmVudHMuQ2hpbGRyZW4odGhpcyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJQYXNzQ29tcG9uZW50KCk7XG4gICAgfSxcblxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHksIGZyYW1lLCB2aXNpYmxlLCBpbmRleClcbiAgICB7XG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7IHZpc2libGUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyYW1lID09PSAnc3RyaW5nJylcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWUgPSB0aGlzLnRleHR1cmUuZ2V0KGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2IgPSBuZXcgQm9iKHRoaXMsIHgsIHksIGZyYW1lLCB2aXNpYmxlKTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZEF0KGJvYiwgaW5kZXgsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gYm9iO1xuICAgIH0sXG5cbiAgICAvLyAgZnJhbWUgTVVTVCBiZSBwYXJ0IG9mIHRoZSBCbGl0dGVyIHRleHR1cmVcbiAgICBjcmVhdGVGcm9tQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgcXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKVxuICAgIHtcbiAgICAgICAgdmFyIGJvYnMgPSB0aGlzLmNyZWF0ZU11bHRpcGxlKHF1YW50aXR5LCBmcmFtZSwgdmlzaWJsZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2JzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYm9iID0gYm9ic1tpXTtcblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBib2IsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvYnM7XG4gICAgfSxcblxuICAgIC8vICBmcmFtZSBNVVNUIGJlIHBhcnQgb2YgdGhlIEJsaXR0ZXIgdGV4dHVyZVxuICAgIGNyZWF0ZU11bHRpcGxlOiBmdW5jdGlvbiAocXVhbnRpdHksIGZyYW1lLCB2aXNpYmxlKVxuICAgIHtcbiAgICAgICAgaWYgKGZyYW1lID09PSB1bmRlZmluZWQpIHsgZnJhbWUgPSB0aGlzLmZyYW1lOyB9XG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhbWUpKVxuICAgICAgICB7XG4gICAgICAgICAgICBmcmFtZSA9IFsgZnJhbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2JzID0gW107XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgZnJhbWUuZm9yRWFjaChmdW5jdGlvbiAoc2luZ2xlRnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVhbnRpdHk7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBib2JzLnB1c2goX3RoaXMuY3JlYXRlKDAsIDAsIHNpbmdsZUZyYW1lLCB2aXNpYmxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBib2JzO1xuICAgIH0sXG5cbiAgICBjaGlsZENhblJlbmRlcjogZnVuY3Rpb24gKGNoaWxkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZC52aXNpYmxlICYmIGNoaWxkLmFscGhhID4gMCk7XG4gICAgfSxcblxuICAgIGdldFJlbmRlckxpc3Q6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0ID0gdGhpcy5jaGlsZHJlbi5saXN0LmZpbHRlcih0aGlzLmNoaWxkQ2FuUmVuZGVyLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckxpc3Q7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyLmpzIiwiXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcbnZhciBDb250YWluZXJSZW5kZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lclJlbmRlcicpO1xuXG52YXIgQ29udGFpbmVyID0gbmV3IENsYXNzKHtcblxuICAgIE1peGluczogW1xuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXG4gICAgICAgIENvbnRhaW5lclJlbmRlclxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDb21wb25lbnRzLkNoaWxkcmVuKHRoaXMpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvY29udGFpbmVyL0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXIuanMiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcbnZhciBSZW5kZXIgPSByZXF1aXJlKCcuL0dyYXBoaWNzUmVuZGVyJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuL0NvbW1hbmRzJyk7XG52YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xuXG52YXIgR3JhcGhpY3MgPSBuZXcgQ2xhc3Moe1xuXG4gICAgTWl4aW5zOiBbXG4gICAgICAgIENvbXBvbmVudHMuQWxwaGEsXG4gICAgICAgIENvbXBvbmVudHMuQmxlbmRNb2RlLFxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJQYXNzLFxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXG4gICAgICAgIFJlbmRlclxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gR3JhcGhpY3MgKHN0YXRlLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIHggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAneCcsIDApO1xuICAgICAgICB2YXIgeSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICd5JywgMCk7XG5cbiAgICAgICAgR2FtZU9iamVjdC5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xuXG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJQYXNzQ29tcG9uZW50KCk7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsbENvbG9yID0gLTE7XG4gICAgICAgIHRoaXMuZGVmYXVsdEZpbGxBbHBoYSA9IDE7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlV2lkdGggPSAxO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VDb2xvciA9IC0xO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdHJva2VBbHBoYSA9IDE7XG5cbiAgICAgICAgdGhpcy5zZXREZWZhdWx0U3R5bGVzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyAgU1RZTEVTXG5cbiAgICBzZXREZWZhdWx0U3R5bGVzOiBmdW5jdGlvbiAob3B0aW9ucylcbiAgICB7XG4gICAgICAgIGlmIChHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnbGluZVN0eWxlJywgbnVsbCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFN0cm9rZVdpZHRoID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ2xpbmVTdHlsZS53aWR0aCcsIDEpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlQ29sb3IgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnbGluZVN0eWxlLmNvbG9yJywgMHhmZmZmZmYpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U3Ryb2tlQWxwaGEgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnbGluZVN0eWxlLmFscGhhJywgMSk7XG5cbiAgICAgICAgICAgIHRoaXMubGluZVN0eWxlKHRoaXMuZGVmYXVsdFN0cm9rZVdpZHRoLCB0aGlzLmRlZmF1bHRTdHJva2VDb2xvciwgdGhpcy5kZWZhdWx0U3Ryb2tlQWxwaGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdmaWxsU3R5bGUnLCBudWxsKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0RmlsbENvbG9yID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ2ZpbGxTdHlsZS5jb2xvcicsIDB4ZmZmZmZmKTtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEZpbGxBbHBoYSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdmaWxsU3R5bGUuYWxwaGEnLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5kZWZhdWx0RmlsbENvbG9yLCB0aGlzLmRlZmF1bHRGaWxsQWxwaGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxpbmVTdHlsZTogZnVuY3Rpb24gKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxuICAgIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAxOyB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5MSU5FX1NUWUxFLFxuICAgICAgICAgICAgbGluZVdpZHRoLCBjb2xvciwgYWxwaGFcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmlsbFN0eWxlOiBmdW5jdGlvbiAoY29sb3IsIGFscGhhKVxuICAgIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHsgYWxwaGEgPSAxOyB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1NUWUxFLFxuICAgICAgICAgICAgY29sb3IsIGFscGhhXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBQQVRIXG5cbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcbiAgICAgICAgICAgIENvbW1hbmRzLkJFR0lOX1BBVEhcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5DTE9TRV9QQVRIXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpbGxQYXRoOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5GSUxMX1BBVEhcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3Ryb2tlUGF0aDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgQ29tbWFuZHMuU1RST0tFX1BBVEhcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIENJUkNMRVxuXG4gICAgZmlsbENpcmNsZVNoYXBlOiBmdW5jdGlvbiAoY2lyY2xlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbENpcmNsZShjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xuICAgIH0sXG5cbiAgICBzdHJva2VDaXJjbGVTaGFwZTogZnVuY3Rpb24gKGNpcmNsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cm9rZUNpcmNsZShjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xuICAgIH0sXG5cbiAgICBmaWxsQ2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxuICAgIHtcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNQVRIX0NPTlNULlBJMik7XG4gICAgICAgIHRoaXMuZmlsbFBhdGgoKTtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3Ryb2tlQ2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxuICAgIHtcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNQVRIX0NPTlNULlBJMik7XG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlUGF0aCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAgUkVDVEFOR0xFXG5cbiAgICBmaWxsUmVjdFNoYXBlOiBmdW5jdGlvbiAocmVjdClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGxSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgfSxcblxuICAgIHN0cm9rZVJlY3RTaGFwZTogZnVuY3Rpb24gKHJlY3QpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgfSxcblxuICAgIGZpbGxSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9SRUNULFxuICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdHJva2VSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5saW5lVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuc3Ryb2tlUGF0aCgpO1xuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAgUE9JTlRcblxuICAgIGZpbGxQb2ludFNoYXBlOiBmdW5jdGlvbiAocG9pbnQsIHNpemUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsUG9pbnQocG9pbnQueCwgcG9pbnQueSwgc2l6ZSk7XG4gICAgfSxcblxuICAgIGZpbGxQb2ludDogZnVuY3Rpb24gKHgsIHksIHNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcbiAgICAgICAgICAgIENvbW1hbmRzLkZJTExfUkVDVCxcbiAgICAgICAgICAgIHgsIHksIHNpemUsIHNpemVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIFRSSUFOR0xFXG5cbiAgICBmaWxsVHJpYW5nbGVTaGFwZTogZnVuY3Rpb24gKHRyaWFuZ2xlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbFRyaWFuZ2xlKHRyaWFuZ2xlLngxLCB0cmlhbmdsZS55MSwgdHJpYW5nbGUueDIsIHRyaWFuZ2xlLnkyLCB0cmlhbmdsZS54MywgdHJpYW5nbGUueTMpO1xuICAgIH0sXG5cbiAgICBzdHJva2VUcmlhbmdsZVNoYXBlOiBmdW5jdGlvbiAodHJpYW5nbGUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VUcmlhbmdsZSh0cmlhbmdsZS54MSwgdHJpYW5nbGUueTEsIHRyaWFuZ2xlLngyLCB0cmlhbmdsZS55MiwgdHJpYW5nbGUueDMsIHRyaWFuZ2xlLnkzKTtcbiAgICB9LFxuXG4gICAgZmlsbFRyaWFuZ2xlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MilcbiAgICB7XG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgQ29tbWFuZHMuRklMTF9UUklBTkdMRSxcbiAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTJcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3Ryb2tlVHJpYW5nbGU6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5TVFJPS0VfVFJJQU5HTEUsXG4gICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBMSU5FXG5cbiAgICBzdHJva2VMaW5lU2hhcGU6IGZ1bmN0aW9uIChsaW5lKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUJldHdlZW4obGluZS54MSwgbGluZS55MSwgbGluZS54MiwgbGluZS55Mik7XG4gICAgfSxcblxuICAgIGxpbmVCZXR3ZWVuOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG4gICAge1xuICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICB0aGlzLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICB0aGlzLnN0cm9rZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgQ29tbWFuZHMuTElORV9UTyxcbiAgICAgICAgICAgIHgsIHlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIHRoaXMuY29tbWFuZEJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgQ29tbWFuZHMuTU9WRV9UTyxcbiAgICAgICAgICAgIHgsIHlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbGluZUZ4VG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgcmdiKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb21tYW5kQnVmZmVyLnB1c2goXG4gICAgICAgICAgICBDb21tYW5kcy5MSU5FX0ZYX1RPLFxuICAgICAgICAgICAgeCwgeSwgd2lkdGgsIHJnYiwgMVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb3ZlRnhUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCByZ2IpXG4gICAge1xuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcbiAgICAgICAgICAgIENvbW1hbmRzLk1PVkVfRlhfVE8sXG4gICAgICAgICAgICB4LCB5LCB3aWR0aCwgcmdiLCAxXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBBUkNcblxuICAgIGFyYzogZnVuY3Rpb24gKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpXG4gICAge1xuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIucHVzaChcbiAgICAgICAgICAgIENvbW1hbmRzLkFSQyxcbiAgICAgICAgICAgIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2VcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmNvbW1hbmRCdWZmZXIubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0RmlsbENvbG9yID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlKHRoaXMuZGVmYXVsdEZpbGxDb2xvciwgdGhpcy5kZWZhdWx0RmlsbEFscGhhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRTdHJva2VDb2xvciA+IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmxpbmVTdHlsZSh0aGlzLmRlZmF1bHRTdHJva2VXaWR0aCwgdGhpcy5kZWZhdWx0U3Ryb2tlQ29sb3IsIHRoaXMuZGVmYXVsdFN0cm9rZUFscGhhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwiXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi9HYW1lT2JqZWN0Jyk7XG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMnKTtcbnZhciBJbWFnZVJlbmRlciA9IHJlcXVpcmUoJy4vSW1hZ2VSZW5kZXInKTtcblxudmFyIEltYWdlID0gbmV3IENsYXNzKHtcblxuICAgIE1peGluczogW1xuICAgICAgICBDb21wb25lbnRzLkFscGhhLFxuICAgICAgICBDb21wb25lbnRzLkJsZW5kTW9kZSxcbiAgICAgICAgQ29tcG9uZW50cy5GbGlwLFxuICAgICAgICBDb21wb25lbnRzLkdldEJvdW5kcyxcbiAgICAgICAgQ29tcG9uZW50cy5PcmlnaW4sXG4gICAgICAgIENvbXBvbmVudHMuUmVuZGVyUGFzcyxcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXG4gICAgICAgIENvbXBvbmVudHMuU2l6ZSxcbiAgICAgICAgQ29tcG9uZW50cy5UZXh0dXJlLFxuICAgICAgICBDb21wb25lbnRzLlRyYW5zZm9ybSxcbiAgICAgICAgQ29tcG9uZW50cy5WaXNpYmxlLFxuICAgICAgICBJbWFnZVJlbmRlclxuICAgIF0sXG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gSW1hZ2UgKHN0YXRlLCB4LCB5LCB0ZXh0dXJlLCBmcmFtZSlcbiAgICB7XG4gICAgICAgIEdhbWVPYmplY3QuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUsIGZyYW1lKTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih4LCB5KTtcbiAgICAgICAgdGhpcy5zZXRTaXplVG9GcmFtZSgpO1xuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJQYXNzQ29tcG9uZW50KCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2UuanMiLCJcbnZhciBDbGFzcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL0NsYXNzJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vLi4vc3RydWN0cy9TZXQnKTtcbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXkvUmFuZ2UnKTtcbnZhciBBY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vYWN0aW9ucy8nKTtcbnZhciBTcHJpdGUgPSByZXF1aXJlKCcuLi9zcHJpdGUvU3ByaXRlJyk7XG5cbnZhciBMYXllciA9IG5ldyBDbGFzcyh7XG5cbiAgICBpbml0aWFsaXplOlxuXG4gICAgZnVuY3Rpb24gTGF5ZXIgKHN0YXRlLCBjaGlsZHJlbilcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldChjaGlsZHJlbik7XG5cbiAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBTcHJpdGU7XG4gICAgfSxcblxuICAgIC8vICBMYXllciBtYW5hZ2VtZW50IG1ldGhvZHM6XG5cbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KGNoaWxkKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkTXVsdGlwbGU6IGZ1bmN0aW9uIChjaGlsZHJlbilcbiAgICB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSwgdmlzaWJsZSlcbiAgICB7XG4gICAgICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHsgdmlzaWJsZSA9IHRydWU7IH1cblxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLmNoaWxkcmVuLmFkZChuZXcgdGhpcy5jbGFzc1R5cGUodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xuXG4gICAgICAgIGNoaWxkLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgICAgIHRoaXMuYWRkKGNoaWxkKTtcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIGNyZWF0ZUZyb21Db25maWc6IGZ1bmN0aW9uIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIGtleSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdrZXknLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgZnJhbWUgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnZnJhbWUnLCBudWxsKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAndmlzaWJsZScsIHRydWUpO1xuXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG5cbiAgICAgICAgLy8gIENhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgYXQgbGVhc3QgYSBrZXlcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleSA9IFsga2V5IF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcmFtZSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBbIGZyYW1lIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQnVpbGQgYW4gYXJyYXkgb2Yga2V5IGZyYW1lIHBhaXJzIHRvIGxvb3AgdGhyb3VnaFxuXG4gICAgICAgIHZhciByZXBlYXQgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAncmVwZWF0JywgMCk7XG4gICAgICAgIHZhciByYW5kb21LZXkgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAncmFuZG9tS2V5JywgZmFsc2UpO1xuICAgICAgICB2YXIgcmFuZG9tRnJhbWUgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAncmFuZG9tRnJhbWUnLCBmYWxzZSk7XG4gICAgICAgIHZhciB5b3lvID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3lveW8nLCBmYWxzZSk7XG4gICAgICAgIHZhciBxdWFudGl0eSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdmcmFtZVF1YW50aXR5JywgMSk7XG4gICAgICAgIHZhciBtYXggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnbWF4JywgMCk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2Uoa2V5LCBmcmFtZSwge1xuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBxdHk6IHF1YW50aXR5LFxuICAgICAgICAgICAgcmFuZG9tOiByYW5kb21LZXksXG4gICAgICAgICAgICByYW5kb21COiByYW5kb21GcmFtZSxcbiAgICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgICAgICAgeW95bzogeW95b1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHJhbmdlLmxlbmd0aDsgYysrKVxuICAgICAgICB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy5jcmVhdGUoMCwgMCwgcmFuZ2VbY10uYSwgcmFuZ2VbY10uYiwgdmlzaWJsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFBvc3QtY3JlYXRpb24gb3B0aW9ucyAoYXBwbGllZCBvbmx5IHRvIHRob3NlIGl0ZW1zIGNyZWF0ZWQgaW4gdGhpcyBjYWxsKTpcblxuICAgICAgICB2YXIgeCA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdzZXRYWS54JywgMCk7XG4gICAgICAgIHZhciB5ID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3NldFhZLnknLCAwKTtcbiAgICAgICAgdmFyIHN0ZXBYID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3NldFhZLnN0ZXBYJywgMCk7XG4gICAgICAgIHZhciBzdGVwWSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdzZXRYWS5zdGVwWScsIDApO1xuXG4gICAgICAgIEFjdGlvbnMuU2V0WFkoZW50cmllcywgeCwgeSwgc3RlcFgsIHN0ZXBZKTtcblxuICAgICAgICB2YXIgcm90YXRpb24gPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnc2V0Um90YXRpb24udmFsdWUnLCAwKTtcbiAgICAgICAgdmFyIHN0ZXBSb3RhdGlvbiA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdzZXRSb3RhdGlvbi5zdGVwJywgMCk7XG5cbiAgICAgICAgQWN0aW9ucy5TZXRSb3RhdGlvbihlbnRyaWVzLCByb3RhdGlvbiwgc3RlcFJvdGF0aW9uKTtcblxuICAgICAgICB2YXIgc2NhbGVYID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3NldFNjYWxlLngnLCAxKTtcbiAgICAgICAgdmFyIHNjYWxlWSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdzZXRTY2FsZS55Jywgc2NhbGVYKTtcbiAgICAgICAgdmFyIHN0ZXBTY2FsZVggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnc2V0U2NhbGUuc3RlcFgnLCAwKTtcbiAgICAgICAgdmFyIHN0ZXBTY2FsZVkgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnc2V0U2NhbGUuc3RlcFknLCAwKTtcblxuICAgICAgICBBY3Rpb25zLlNldFNjYWxlKGVudHJpZXMsIHNjYWxlWCwgc2NhbGVZLCBzdGVwU2NhbGVYLCBzdGVwU2NhbGVZKTtcblxuICAgICAgICB2YXIgYWxwaGEgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnc2V0QWxwaGEudmFsdWUnLCAxKTtcbiAgICAgICAgdmFyIHN0ZXBBbHBoYSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdzZXRBbHBoYS5zdGVwJywgMCk7XG5cbiAgICAgICAgQWN0aW9ucy5TZXRBbHBoYShlbnRyaWVzLCBhbHBoYSwgc3RlcEFscGhhKTtcblxuICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICB9LFxuXG4gICAgY3JlYXRlTXVsdGlwbGU6IGZ1bmN0aW9uIChjb25maWcpXG4gICAge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uZmlnID0gWyBjb25maWcgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmNyZWF0ZUZyb21Db25maWcoY29uZmlnW2ldKTtcblxuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChlbnRyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2xlYXIoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvLyAgQ2hpbGQgcmVsYXRlZCBtZXRob2RzXG5cbiAgICBhbmdsZTogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5BbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ3JpZEFsaWduOiBmdW5jdGlvbiAob3B0aW9ucylcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuR3JpZEFsaWduKHRoaXMuY2hpbGRyZW4uZW50cmllcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluY0FscGhhOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXG4gICAge1xuICAgICAgICBBY3Rpb25zLkluY0FscGhhKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbmNYOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICBBY3Rpb25zLkluY1godGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluY1hZOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuSW5jWFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5jWTogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5JbmNZKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwbGFjZU9uQ2lyY2xlOiBmdW5jdGlvbiAoY2lyY2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSlcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuUGxhY2VPbkNpcmNsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGNpcmNsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwbGFjZU9uTGluZTogZnVuY3Rpb24gKGxpbmUpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlBsYWNlT25MaW5lKHRoaXMuY2hpbGRyZW4uZW50cmllcywgbGluZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHBsYWNlT25SZWN0YW5nbGU6IGZ1bmN0aW9uIChyZWN0LCBzaGlmdClcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuUGxhY2VPblJlY3RhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHJlY3QsIHNoaWZ0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcGxhY2VPblRyaWFuZ2xlOiBmdW5jdGlvbiAodHJpYW5nbGUsIHN0ZXBSYXRlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5QbGFjZU9uVHJpYW5nbGUodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB0cmlhbmdsZSwgc3RlcFJhdGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByYW5kb21DaXJjbGU6IGZ1bmN0aW9uIChjaXJjbGUpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlJhbmRvbUNpcmNsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIGNpcmNsZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJhbmRvbUVsbGlwc2U6IGZ1bmN0aW9uIChlbGxpcHNlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5SYW5kb21FbGxpcHNlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgZWxsaXBzZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJhbmRvbUxpbmU6IGZ1bmN0aW9uIChsaW5lKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5SYW5kb21MaW5lKHRoaXMuY2hpbGRyZW4uZW50cmllcywgbGluZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJhbmRvbVJlY3RhbmdsZTogZnVuY3Rpb24gKHJlY3QpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlJhbmRvbVJlY3RhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHJlY3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByYW5kb21UcmlhbmdsZTogZnVuY3Rpb24gKHRyaWFuZ2xlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5SYW5kb21UcmlhbmdsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHRyaWFuZ2xlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXG4gICAge1xuICAgICAgICBBY3Rpb25zLlJvdGF0ZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlLCBzdGVwKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcm90YXRlQXJvdW5kOiBmdW5jdGlvbiAocG9pbnQsIGFuZ2xlKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5Sb3RhdGVBcm91bmQodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBwb2ludCwgYW5nbGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByb3RhdGVBcm91bmREaXN0YW5jZTogZnVuY3Rpb24gKHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlJvdGF0ZUFyb3VuZERpc3RhbmNlKHRoaXMuY2hpbGRyZW4uZW50cmllcywgcG9pbnQsIGFuZ2xlLCBkaXN0YW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEFscGhhOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNldEFscGhhKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRPcmlnaW46IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TZXRPcmlnaW4odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGVYOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNjYWxlWCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGVYWTogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNjYWxlWFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGVZOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNjYWxlWSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uICh2YWx1ZSwgc3RlcClcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuU2V0Um90YXRpb24odGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSwgc3RlcFgsIHN0ZXBZKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TZXRTY2FsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHgsIHksIHN0ZXBYLCBzdGVwWSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNjYWxlWDogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TZXRTY2FsZVgodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNjYWxlWTogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TZXRTY2FsZVkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuU2V0VmlzaWJsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24gKHZhbHVlLCBzdGVwKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TZXRYKHRoaXMuY2hpbGRyZW4uZW50cmllcywgdmFsdWUsIHN0ZXApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRYWTogZnVuY3Rpb24gKHgsIHksIHN0ZXBYLCBzdGVwWSlcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuU2V0WFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB4LCB5LCBzdGVwWCwgc3RlcFkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbiAodmFsdWUsIHN0ZXApXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNldFkodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCB2YWx1ZSwgc3RlcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNtb290aGVyU3RlcDogZnVuY3Rpb24gKHByb3BlcnR5LCBtaW4sIG1heCwgaW5jKVxuICAgIHtcbiAgICAgICAgQWN0aW9ucy5TbW9vdGhlclN0ZXAodGhpcy5jaGlsZHJlbi5lbnRyaWVzLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNtb290aFN0ZXA6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuU21vb3RoU3RlcCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHByb3BlcnR5LCBtaW4sIG1heCwgaW5jKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3ByZWFkOiBmdW5jdGlvbiAocHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXG4gICAge1xuICAgICAgICBBY3Rpb25zLlNwcmVhZCh0aGlzLmNoaWxkcmVuLmVudHJpZXMsIHByb3BlcnR5LCBtaW4sIG1heCwgaW5jKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9nZ2xlVmlzaWJsZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIEFjdGlvbnMuVG9nZ2xlVmlzaWJsZSh0aGlzLmNoaWxkcmVuLmVudHJpZXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9sYXllci9MYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2xheWVyL0xheWVyLmpzIiwiXG52YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdhbWVPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9HYW1lT2JqZWN0Jyk7XG52YXIgQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbXBvbmVudHMnKTtcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vLi4vLi4vZG9tL0NhbnZhc1Bvb2wnKTtcbnZhciBUZXh0UmVuZGVyID0gcmVxdWlyZSgnLi9UZXh0UmVuZGVyJyk7XG52YXIgVGV4dFN0eWxlID0gcmVxdWlyZSgnLi4vVGV4dFN0eWxlJyk7XG52YXIgR2V0VGV4dFNpemUgPSByZXF1aXJlKCcuLi9HZXRUZXh0U2l6ZScpO1xuXG52YXIgVGV4dCA9IG5ldyBDbGFzcyh7XG5cbiAgICBNaXhpbnM6IFtcbiAgICAgICAgQ29tcG9uZW50cy5BbHBoYSxcbiAgICAgICAgQ29tcG9uZW50cy5CbGVuZE1vZGUsXG4gICAgICAgIENvbXBvbmVudHMuR2V0Qm91bmRzLFxuICAgICAgICBDb21wb25lbnRzLk9yaWdpbixcbiAgICAgICAgQ29tcG9uZW50cy5TY2FsZU1vZGUsXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNmb3JtLFxuICAgICAgICBDb21wb25lbnRzLlZpc2libGUsXG4gICAgICAgIENvbXBvbmVudHMuRmxpcCxcbiAgICAgICAgQ29tcG9uZW50cy5SZW5kZXJQYXNzLFxuICAgICAgICBUZXh0UmVuZGVyXG4gICAgXSxcblxuICAgIGluaXRpYWxpemU6XG5cbiAgICBmdW5jdGlvbiBUZXh0IChzdGF0ZSwgeCwgeSwgdGV4dCwgc3R5bGUpXG4gICAge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgeyB0ZXh0ID0gJyc7IH1cblxuICAgICAgICBHYW1lT2JqZWN0LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICAgIHRoaXMuc2V0T3JpZ2luKDAsIDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgdGV4dCBpcyByZW5kZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgdGV4dCBpcyByZW5kZXJlZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBUZXh0U3R5bGUodGhpcywgc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuYXV0b1JvdW5kID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgdG8gc3BsaXQgdGhlIHRleHQgdXAgaW50byBsaW5lcywgaW5cbiAgICAgICAgICogbXVsdGktbGluZSB0ZXh0LiBCeSBkZWZhdWx0IHRoaXMgaXMgYC8oPzpcXHJcXG58XFxyfFxcbikvYC5cbiAgICAgICAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBSZWdFeHAgdG8gYmUgYW55dGhpbmcgZWxzZSB0aGF0IHlvdSBtYXkgbmVlZC5cbiAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNwbGl0UmVnRXhwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwbGl0UmVnRXhwID0gLyg/OlxcclxcbnxcXHJ8XFxuKS87XG5cbiAgICAgICAgdGhpcy50ZXh0ID0gKEFycmF5LmlzQXJyYXkodGV4dCkpID8gdGV4dC5qb2luKCdcXG4nKSA6IHRleHQ7XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcblxuICAgICAgICB0aGlzLnBhZGRpbmcgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICB0aGlzLndpZHRoID0gMTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIHRoaXMuY2FudmFzVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5wcmV2SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0ZXh0ICE9PSAnJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0UmVuZGVyUGFzc0NvbXBvbmVudCgpO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbignXFxuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGV4dClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgfSxcblxuICAgIHNldEZvbnQ6IGZ1bmN0aW9uIChmb250KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0Rm9udChmb250KTtcbiAgICB9LFxuXG4gICAgc2V0Rml4ZWRTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldEZpeGVkU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoY29sb3IpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsOiBmdW5jdGlvbiAoY29sb3IpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRGaWxsKGNvbG9yKTtcbiAgICB9LFxuXG4gICAgc2V0U3Ryb2tlOiBmdW5jdGlvbiAoY29sb3IsIHRoaWNrbmVzcylcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFN0cm9rZShjb2xvciwgdGhpY2tuZXNzKTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZG93OiBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGJsdXIsIHNoYWRvd1N0cm9rZSwgc2hhZG93RmlsbClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvdyh4LCB5LCBjb2xvciwgYmx1ciwgc2hhZG93U3Ryb2tlLCBzaGFkb3dGaWxsKTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZG93T2Zmc2V0OiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd09mZnNldCh4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZG93Q29sb3I6IGZ1bmN0aW9uIChjb2xvcilcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd0NvbG9yKGNvbG9yKTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZG93Qmx1cjogZnVuY3Rpb24gKGJsdXIpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRTaGFkb3dCbHVyKGJsdXIpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dTdHJva2U6IGZ1bmN0aW9uIChlbmFibGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0U2hhZG93U3Ryb2tlKGVuYWJsZWQpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dGaWxsOiBmdW5jdGlvbiAoZW5hYmxlZClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNldFNoYWRvd0ZpbGwoZW5hYmxlZCk7XG4gICAgfSxcblxuICAgIHNldEFsaWduOiBmdW5jdGlvbiAoYWxpZ24pXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRBbGlnbihhbGlnbik7XG4gICAgfSxcblxuICAgIHNldE1heExpbmVzOiBmdW5jdGlvbiAobWF4KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0TWF4TGluZXMobWF4KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVGV4dDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIHZhciBzaXplID0gc3R5bGUubWV0cmljcztcblxuICAgICAgICB2YXIgb3V0cHV0VGV4dCA9IHRoaXMudGV4dDtcblxuICAgICAgICAvLyBpZiAoc3R5bGUud29yZFdyYXApXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIG91dHB1dFRleHQgPSB0aGlzLnJ1bldvcmRXcmFwKHRoaXMudGV4dCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyAgU3BsaXQgdGV4dCBpbnRvIGxpbmVzXG4gICAgICAgIHZhciBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQodGhpcy5zcGxpdFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIHRleHRTaXplID0gR2V0VGV4dFNpemUodGhpcywgc2l6ZSwgbGluZXMpO1xuXG4gICAgICAgIGlmICghc3R5bGUuZml4ZWRXaWR0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHlsZS5maXhlZEhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZU9yaWdpbigpO1xuXG4gICAgICAgIHZhciB3ID0gdGV4dFNpemUud2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHZhciBoID0gdGV4dFNpemUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IHcgfHwgY2FudmFzLmhlaWdodCAhPT0gaClcbiAgICAgICAge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGUuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5zeW5jRm9udChjYW52YXMsIGNvbnRleHQpO1xuXG4gICAgICAgIHZhciBsaW5lUG9zaXRpb25YO1xuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWTtcblxuICAgICAgICAvLyAgRHJhdyB0ZXh0IGxpbmUgYnkgbGluZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRTaXplLmxpbmVzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIHRleHRTaXplLmxpbmVIZWlnaHQpICsgc2l6ZS5hc2NlbnQ7XG5cbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZICs9ICh0ZXh0U2l6ZS5saW5lU3BhY2luZyAqIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSB0ZXh0U2l6ZS53aWR0aCAtIHRleHRTaXplLmxpbmVXaWR0aHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAodGV4dFNpemUud2lkdGggLSB0ZXh0U2l6ZS5saW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9Sb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gTWF0aC5yb3VuZChsaW5lUG9zaXRpb25YKTtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gTWF0aC5yb3VuZChsaW5lUG9zaXRpb25ZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZVRoaWNrbmVzcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnN5bmNTaGFkb3coY29udGV4dCwgc3R5bGUuc2hhZG93U3Ryb2tlKTtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCwgbGluZVBvc2l0aW9uWSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc3luY1NoYWRvdyhjb250ZXh0LCBzdHlsZS5zaGFkb3dGaWxsKTtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0LmpzIiwidmFyIENpcmNsZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHsgcmFkaXVzID0gMDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5fZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xufTtcblxuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcblxuQ2lyY2xlLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFRvOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHJhZGl1cyAqIDI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEVtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VG8oMCwgMCwgMCk7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpdXMgPD0gMCk7XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaXJjbGUucHJvdG90eXBlLCB7XG5cbiAgICByYWRpdXM6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9kaWFtZXRlciA9IHZhbHVlICogMjtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGRpYW1ldGVyOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFtZXRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlICogMC41O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgbGVmdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnggPSB2YWx1ZSArIHRoaXMuX3JhZGl1cztcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9wOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgLSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlICsgdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYm90dG9tOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlIC0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbi8qKlxuKiBSZXR1cm5zIGEgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludCBmcm9tIGFueXdoZXJlIHdpdGhpbiB0aGlzIENpcmNsZS5cbiogXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNyYW5kb21cbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8b2JqZWN0fSBbb3V0XSAtIEEgUGhhc2VyLlBvaW50LCBvciBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzLCB0aGF0IHRoZSB2YWx1ZXMgd2lsbCBiZSBzZXQgaW4uXG4qICAgICBJZiBubyBvYmplY3QgaXMgcHJvdmlkZWQgYSBuZXcgUGhhc2VyLlBvaW50IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuIEluIGhpZ2ggcGVyZm9ybWFuY2UgYXJlYXMgYXZvaWQgdGhpcyBieSByZS11c2luZyBhbiBleGlzdGluZyBvYmplY3QuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJhbmRvbSBwb2ludCBpbiBpdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy5cbiovXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGNpcmNsZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIHQgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpICsgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgciA9ICh1ID4gMSkgPyAyIC0gdSA6IHU7XG4gICAgdmFyIHggPSByICogTWF0aC5jb3ModCk7XG4gICAgdmFyIHkgPSByICogTWF0aC5zaW4odCk7XG5cbiAgICBvdXQueCA9IGNpcmNsZS54ICsgKHggKiBjaXJjbGUucmFkaXVzKTtcbiAgICBvdXQueSA9IGNpcmNsZS55ICsgKHkgKiBjaXJjbGUucmFkaXVzKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL1JhbmRvbS5qcyIsInZhciBFbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IDA7IH1cbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDA7IH1cbiAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMDsgfVxuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbkVsbGlwc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZTtcblxuRWxsaXBzZS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRUbzogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRFbXB0eTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFRvKDAsIDAsIDAsIDApO1xuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gd2lkdGg7IH1cblxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCk7XG4gICAgfSxcblxuICAgIC8vICBBS0EgU2VtaSBNaW5vciBBeGlzXG4gICAgZ2V0TWlub3JSYWRpdXM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpIC8gMjtcbiAgICB9LFxuXG4gICAgLy8gIEFLQSBTZW1pIE1ham9yIEF4aXNcbiAgICBnZXRNYWpvclJhZGl1czogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzZS5wcm90b3R5cGUsIHtcblxuICAgIGxlZnQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMucmlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgLSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICByaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMueClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdmFsdWUgLSB0aGlzLng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0b3A6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IHRoaXMuYm90dG9tKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9ICh0aGlzLmJvdHRvbSAtIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJvdHRvbToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLnkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsdWUgLSB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9FbGxpcHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcblxudmFyIFJhbmRvbSA9IGZ1bmN0aW9uIChlbGxpcHNlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICB2YXIgcCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICB2YXIgcyA9IE1hdGguc3FydChNYXRoLnJhbmRvbSgpKTtcblxuICAgIG91dC54ID0gZWxsaXBzZS54ICsgKChzICogTWF0aC5jb3MocCkpICogZWxsaXBzZS53aWR0aCAvIDIpO1xuICAgIG91dC55ID0gZWxsaXBzZS55ICsgKChzICogTWF0aC5zaW4ocCkpICogZWxsaXBzZS5oZWlnaHQgLyAyKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9SYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvUmFuZG9tLmpzIiwidmFyIEdldFBvaW50ID0gcmVxdWlyZSgnLi9HZXRQb2ludCcpO1xuXG4vKipcbiogQ2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIGFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgY3VydmVzIHRhbmdlbnQgYmFzZWQgb24gdGltZS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRBbmdsZVxuKiBAcGFyYW0ge251bWJlcn0gW3Q9MF0gLSBUaGUgYHRgICh0aW1lKSB2YWx1ZSBhdCB3aGljaCB0byBmaW5kIHRoZSBhbmdsZS4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgYHRgIHRpbWUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cbiovXG52YXIgR2V0QW5nbGUgPSBmdW5jdGlvbiAoY3VydmUsIHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxuXG4gICAgR2V0UG9pbnQoY3VydmUsIHQgLSAwLjAxLCBjdXJ2ZS5fdGVtcDEpO1xuICAgIEdldFBvaW50KGN1cnZlLCB0ICsgMC4wMSwgY3VydmUuX3RlbXAyKTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKGN1cnZlLl90ZW1wMi55IC0gY3VydmUuX3RlbXAxLnksIGN1cnZlLl90ZW1wMi54IC0gY3VydmUuX3RlbXAxLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZS5qcyIsIi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1hdHQgRGVzTGF1cmllcnNcbi8vICBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvbGluZS1jaXJjbGUtY29sbGlzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcblxudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vY2lyY2xlL0NvbnRhaW5zJyk7XG5cbnZhciB0bXAgPSB7IHg6IDAsIHk6IDAgfTtcblxudmFyIExpbmVUb0NpcmNsZSA9IGZ1bmN0aW9uIChsaW5lLCBjaXJjbGUsIG5lYXJlc3QpXG57XG4gICAgaWYgKG5lYXJlc3QgPT09IHVuZGVmaW5lZCkgeyBuZWFyZXN0ID0gdG1wOyB9XG5cbiAgICBpZiAoQ29udGFpbnMoY2lyY2xlLCBsaW5lLngxLCBsaW5lLnkxKSlcbiAgICB7XG4gICAgICAgIG5lYXJlc3QueCA9IGxpbmUueDE7XG4gICAgICAgIG5lYXJlc3QueSA9IGxpbmUueTE7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKENvbnRhaW5zKGNpcmNsZSwgbGluZS54MiwgbGluZS55MikpXG4gICAge1xuICAgICAgICBuZWFyZXN0LnggPSBsaW5lLngyO1xuICAgICAgICBuZWFyZXN0LnkgPSBsaW5lLnkyO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkeCA9IGxpbmUueDIgLSBsaW5lLngxO1xuICAgIHZhciBkeSA9IGxpbmUueTIgLSBsaW5lLnkxO1xuXG4gICAgdmFyIGxjeCA9IGNpcmNsZS54IC0gbGluZS54MTtcbiAgICB2YXIgbGN5ID0gY2lyY2xlLnkgLSBsaW5lLnkxO1xuXG4gICAgLy8gIHByb2plY3QgbGMgb250byBkLCByZXN1bHRpbmcgaW4gdmVjdG9yIHBcbiAgICB2YXIgZExlbjIgPSAoZHggKiBkeCkgKyAoZHkgKiBkeSk7XG4gICAgdmFyIHB4ID0gZHg7XG4gICAgdmFyIHB5ID0gZHk7XG5cbiAgICBpZiAoZExlbjIgPiAwKVxuICAgIHtcbiAgICAgICAgdmFyIGRwID0gKChsY3ggKiBkeCkgKyAobGN5ICogZHkpKSAvIGRMZW4yO1xuXG4gICAgICAgIHB4ICo9IGRwO1xuICAgICAgICBweSAqPSBkcDtcbiAgICB9XG5cbiAgICBuZWFyZXN0LnggPSBsaW5lLngxICsgcHg7XG4gICAgbmVhcmVzdC55ID0gbGluZS55MSArIHB5O1xuICAgIFxuICAgIC8vICBsZW4yIG9mIHBcbiAgICB2YXIgcExlbjIgPSAocHggKiBweCkgKyAocHkgKiBweSk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgcExlbjIgPD0gZExlbjIgJiZcbiAgICAgICAgKChweCAqIGR4KSArIChweSAqIGR5KSkgPj0gMCAmJlxuICAgICAgICBDb250YWlucyhjaXJjbGUsIG5lYXJlc3QueCwgbmVhcmVzdC55KVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb0NpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9MaW5lVG9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvTGluZVRvQ2lyY2xlLmpzIiwidmFyIFBvaW50VG9MaW5lID0gZnVuY3Rpb24gKHBvaW50LCBsaW5lKVxue1xuICAgIHJldHVybiAoKHBvaW50LnggLSBsaW5lLngxKSAqIChsaW5lLnkyIC0gbGluZS55MSkgPT09IChsaW5lLngyIC0gbGluZS54MSkgKiAocG9pbnQueSAtIGxpbmUueTEpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUG9pbnRUb0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxue1xuICAgIGlmIChyZWN0QS53aWR0aCA8PSAwIHx8IHJlY3RBLmhlaWdodCA8PSAwIHx8IHJlY3RCLndpZHRoIDw9IDAgfHwgcmVjdEIuaGVpZ2h0IDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEocmVjdEEucmlnaHQgPCByZWN0Qi54IHx8IHJlY3RBLmJvdHRvbSA8IHJlY3RCLnkgfHwgcmVjdEEueCA+IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLnkgPiByZWN0Qi5ib3R0b20pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1JlY3RhbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9SZWN0YW5nbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBEZWZpbmVzIGEgTGluZSBzZWdtZW50LCBhIHBhcnQgb2YgYSBsaW5lIGJldHdlZW4gdHdvIGVuZHBvaW50c1xuXG52YXIgTGluZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcbntcbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcbiAgICB0aGlzLngyID0gMDtcbiAgICB0aGlzLnkyID0gMDtcblxuICAgIHRoaXMuc2V0VG8oeDEsIHkxLCB4MiwgeTIpO1xufTtcblxuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lO1xuXG5MaW5lLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG4gICAge1xuICAgICAgICBpZiAoeDEgPT09IHVuZGVmaW5lZCkgeyB4MSA9IDA7IH1cbiAgICAgICAgaWYgKHkxID09PSB1bmRlZmluZWQpIHsgeTEgPSAwOyB9XG4gICAgICAgIGlmICh4MiA9PT0gdW5kZWZpbmVkKSB7IHgyID0gMDsgfVxuICAgICAgICBpZiAoeTIgPT09IHVuZGVmaW5lZCkgeyB5MiA9IDA7IH1cblxuICAgICAgICB0aGlzLngxID0geDE7XG4gICAgICAgIHRoaXMueTEgPSB5MTtcblxuICAgICAgICB0aGlzLngyID0geDI7XG4gICAgICAgIHRoaXMueTIgPSB5MjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRBOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHRoaXMueDEsIHkxOiB0aGlzLnkxIH07XG4gICAgfSxcblxuICAgIGdldFBvaW50QjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB7IHgxOiB0aGlzLngyLCB5MTogdGhpcy55MiB9O1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTGluZS5wcm90b3R5cGUsIHtcblxuICAgIGxlZnQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy54MSA8PSB0aGlzLngyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICByaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy54MSwgdGhpcy54Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLngxID4gdGhpcy54MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdG9wOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnkxLCB0aGlzLnkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMueTEgPD0gdGhpcy55MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYm90dG9tOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnkxLCB0aGlzLnkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMueTEgPiB0aGlzLnkyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG52YXIgV3JhcCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvV3JhcCcpO1xudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xuXG52YXIgTm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICB2YXIgYW5nbGUgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xuXG4gICAgcmV0dXJuIFdyYXAoYW5nbGUsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsQW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvTm9ybWFsQW5nbGUuanMiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKGxpbmUsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIHZhciB0ID0gTWF0aC5yYW5kb20oKTtcblxuICAgIG91dC54ID0gbGluZS54MSArIHQgKiAobGluZS54MiAtIGxpbmUueDEpO1xuICAgIG91dC55ID0gbGluZS55MSArIHQgKiAobGluZS55MiAtIGxpbmUueTEpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9SYW5kb20uanMiLCJ2YXIgR2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHBvaW50LnggKiBwb2ludC54KSArIChwb2ludC55ICogcG9pbnQueSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRNYWduaXR1ZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0dldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRNYWduaXR1ZGVTcSA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICByZXR1cm4gKHBvaW50LnggKiBwb2ludC54KSArIChwb2ludC55ICogcG9pbnQueSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1hZ25pdHVkZVNxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9HZXRNYWduaXR1ZGVTcS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNdWx0aXBseSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54ICo9IHg7XG4gICAgcG9pbnQueSAqPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTXVsdGlwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGUnKTtcblxudmFyIE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICBpZiAocG9pbnQueCAhPT0gMCAmJiBwb2ludC55ICE9PSAwKVxuICAgIHtcbiAgICAgICAgdmFyIG0gPSBHZXRNYWduaXR1ZGUocG9pbnQpO1xuXG4gICAgICAgIHBvaW50LnggLz0gbTtcbiAgICAgICAgcG9pbnQueSAvPSBtO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05vcm1hbGl6ZS5qcyIsIi8qKlxuKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4qXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXG4qL1xudmFyIENvbnRhaW5zID0gZnVuY3Rpb24gKHBvbHlnb24sIHgsIHkpXG57XG4gICAgLy8gIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LmVjc2UucnBpLmVkdS9Ib21lcGFnZXMvd3JmL1Jlc2VhcmNoL1Nob3J0X05vdGVzL3BucG9seS5odG1sIGJ5IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YVxuXG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IC0xLCBqID0gcG9seWdvbi5wb2ludHMubGVuZ3RoIC0gMTsgKytpIDwgcG9seWdvbi5wb2ludHMubGVuZ3RoOyBqID0gaSlcbiAgICB7XG4gICAgICAgIHZhciBpeCA9IHBvbHlnb24ucG9pbnRzW2ldLng7XG4gICAgICAgIHZhciBpeSA9IHBvbHlnb24ucG9pbnRzW2ldLnk7XG5cbiAgICAgICAgdmFyIGp4ID0gcG9seWdvbi5wb2ludHNbal0ueDtcbiAgICAgICAgdmFyIGp5ID0gcG9seWdvbi5wb2ludHNbal0ueTtcblxuICAgICAgICBpZiAoKChpeSA8PSB5ICYmIHkgPCBqeSkgfHwgKGp5IDw9IHkgJiYgeSA8IGl5KSkgJiYgKHggPCAoanggLSBpeCkgKiAoeSAtIGl5KSAvIChqeSAtIGl5KSArIGl4KSlcbiAgICAgICAge1xuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnNpZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKVxue1xuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyZWEgLSBUaGUgYXJlYSBvZiB0aGlzIFBvbHlnb24uXG4gICAgKi9cbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXIgcGFpciBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGlzIHBvbHlnb24uIEkuZS4gWyB7eCx5fSwge3gseX0sIHt4LHl9IF1cbiAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICBpZiAocG9pbnRzKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRUbyhwb2ludHMpO1xuICAgIH1cbn07XG5cblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcblxuUG9seWdvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgUG9seWdvbiB0byB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICAqXG4gICAgICogVGhlIHBvaW50cyBjYW4gYmUgc2V0IGZyb20gYSB2YXJpZXR5IG9mIGZvcm1hdHM6XG4gICAgICpcbiAgICAgKiAtIEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHM6IGBbbmV3IFBoYXNlci5Qb2ludCh4MSwgeTEpLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHB1YmxpYyB4L3kgcHJvcGVydGllczogYFtvYmoxLCBvYmoyLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2YgcGFpcmVkIG51bWJlcnMgdGhhdCByZXByZXNlbnQgcG9pbnQgY29vcmRpbmF0ZXM6IGBbeDEseTEsIHgyLHkyLCAuLi5dYFxuICAgICAqIC0gQW4gYXJyYXkgb2YgYXJyYXlzIHdpdGggdHdvIGVsZW1lbnRzIHJlcHJlc2VudGluZyB4L3kgY29vcmRpbmF0ZXM6IGBbW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi5dYFxuICAgICAqXG4gICAgICogYHNldFRvYCBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzIHRvIHJlbW92ZSBhbGwgcG9pbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBQaGFzZXIuUG9seWdvbiNzZXRUb1xuICAgICAqIEBwYXJhbSB7UGhhc2VyLlBvaW50W118bnVtYmVyW118Li4uUGhhc2VyLlBvaW50fC4uLm51bWJlcn0gcG9pbnRzIC0gVGhlIHBvaW50cyB0byBzZXQuXG4gICAgICogQHJldHVybiB7UGhhc2VyLlBvbHlnb259IFRoaXMgUG9seWdvbiBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRUbzogZnVuY3Rpb24gKHBvaW50cylcbiAgICB7XG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB2YXIgeTAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICAvLyAgVGhlIHBvaW50cyBhcmd1bWVudCBpcyBhbiBhcnJheSwgc28gaXRlcmF0ZSB0aHJvdWdoIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRzW2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgQW4gYXJyYXkgb2YgYXJyYXlzP1xuICAgICAgICAgICAgICAgIHAueCA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICBwLnkgPSBwb2ludHNbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9pbnRzW2ldLng7XG4gICAgICAgICAgICAgICAgcC55ID0gcG9pbnRzW2ldLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgIC8vICBMb3dlc3QgYm91bmRhcnlcbiAgICAgICAgICAgIGlmIChwLnkgPCB5MClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5MCA9IHAueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQXJlYSh5MCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uIFRoaXMgaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9wZXJ0eSBQb2x5Z29uLmFyZWFcbiAgICAgKlxuICAgICAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY2FsY3VsYXRlQXJlYVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIGxvd2VzdCBib3VuZGFyeVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWEgb2YgdGhlIFBvbHlnb24uXG4gICAgICovXG4gICAgY2FsY3VsYXRlQXJlYTogZnVuY3Rpb24gKHkwKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIHAxO1xuICAgICAgICB2YXIgcDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgc3VtICs9IChwMi54IC0gcDEueCkgKiAocDEueSArIHAyLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcDEgPSB0aGlzLnBvaW50c1swXTtcbiAgICAgICAgcDIgPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBzdW0gKz0gKHAxLnggLSBwMi54KSAqIChwMi55ICsgcDEueSk7XG5cbiAgICAgICAgdGhpcy5hcmVhID0gLXN1bSAqIDAuNTtcblxuICAgICAgICAvLyB2YXIgcDE7XG4gICAgICAgIC8vIHZhciBwMjtcbiAgICAgICAgLy8gdmFyIGF2Z0hlaWdodDtcbiAgICAgICAgLy8gdmFyIHdpZHRoO1xuXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgcDEgPSB0aGlzLnBvaW50c1tpXTtcblxuICAgICAgICAvLyAgICAgaWYgKGkgPT09IGxlbiAtIDEpXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgcDIgPSB0aGlzLnBvaW50c1swXTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGVsc2VcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcbiAgICAgICAgLy8gICAgIH1cblxuICAgICAgICAvLyAgICAgYXZnSGVpZ2h0ID0gKChwMS55IC0geTApICsgKHAyLnkgLSB5MCkpIC8gMjtcbiAgICAgICAgLy8gICAgIHdpZHRoID0gcDEueCAtIHAyLng7XG4gICAgICAgIC8vICAgICB0aGlzLmFyZWEgKz0gYXZnSGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVjb21wb3NlID0gZnVuY3Rpb24gKHJlY3QsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gW107IH1cblxuICAgIG91dC5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgfSk7XG4gICAgb3V0LnB1c2goeyB4OiByZWN0LnJpZ2h0LCB5OiByZWN0LnkgfSk7XG4gICAgb3V0LnB1c2goeyB4OiByZWN0LnJpZ2h0LCB5OiByZWN0LmJvdHRvbSB9KTtcbiAgICBvdXQucHVzaCh7IHg6IHJlY3QueCwgeTogcmVjdC5ib3R0b20gfSk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvbXBvc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9EZWNvbXBvc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyaW1ldGVyID0gcmVxdWlyZSgnLi9QZXJpbWV0ZXInKTtcblxuLy8gIFJldHVybiBhbiBhcnJheSBvZiBwb2ludHMgZnJvbSB0aGUgcGVyaW1ldGVyIG9mIHRoZSByZWN0YW5nbGVcbi8vICBlYWNoIHNwYWNlZCBvdXQgYmFzZWQgb24gdGhlIHF1YW50aXR5IG9yIHN0ZXAgcmVxdWlyZWRcblxudmFyIE1hcmNoaW5nQW50cyA9IGZ1bmN0aW9uIChyZWN0LCBzdGVwLCBxdWFudGl0eSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxuXG4gICAgaWYgKCFzdGVwICYmICFxdWFudGl0eSlcbiAgICB7XG4gICAgICAgIC8vICBCYWlsIG91dFxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICBJZiBzdGVwIGlzIGEgZmFsc2V5IHZhbHVlIChmYWxzZSwgbnVsbCwgMCwgdW5kZWZpbmVkLCBldGMpIHRoZW4gd2UgY2FsY3VsYXRlXG4gICAgLy8gIGl0IGJhc2VkIG9uIHRoZSBxdWFudGl0eSBpbnN0ZWFkLCBvdGhlcndpc2Ugd2UgYWx3YXlzIHVzZSB0aGUgc3RlcCB2YWx1ZVxuICAgIGlmICghc3RlcClcbiAgICB7XG4gICAgICAgIHN0ZXAgPSBQZXJpbWV0ZXIocmVjdCkgLyBxdWFudGl0eTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcXVhbnRpdHkgPSBNYXRoLnJvdW5kKFBlcmltZXRlcihyZWN0KSAvIHN0ZXApO1xuICAgIH1cblxuICAgIHZhciB4ID0gcmVjdC54O1xuICAgIHZhciB5ID0gcmVjdC55O1xuICAgIHZhciBmYWNlID0gMDtcblxuICAgIC8vICBMb29wIGFjcm9zcyBlYWNoIGZhY2Ugb2YgdGhlIHJlY3RhbmdsZVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFudGl0eTsgaSsrKVxuICAgIHtcbiAgICAgICAgb3V0LnB1c2goeyB4OiB4LCB5OiB5IH0pO1xuXG4gICAgICAgIHN3aXRjaCAoZmFjZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFRvcCBmYWNlXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgeCArPSBzdGVwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHggPj0gcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAxO1xuICAgICAgICAgICAgICAgICAgICB5ICs9ICh4IC0gcmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gIFJpZ2h0IGZhY2VcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB5ICs9IHN0ZXA7XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA+PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2UgPSAyO1xuICAgICAgICAgICAgICAgICAgICB4IC09ICh5IC0gcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyAgQm90dG9tIGZhY2VcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB4IC09IHN0ZXA7XG5cbiAgICAgICAgICAgICAgICBpZiAoeCA8PSByZWN0LmxlZnQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmYWNlID0gMztcbiAgICAgICAgICAgICAgICAgICAgeSAtPSAocmVjdC5sZWZ0IC0geCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyAgTGVmdCBmYWNlXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgeSAtPSBzdGVwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHkgPD0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmYWNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJlY3QudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmNoaW5nQW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL01hcmNoaW5nQW50cy5qcyIsInZhciBQZXJpbWV0ZXIgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZXR1cm4gMiAqIChyZWN0LndpZHRoICsgcmVjdC5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJpbWV0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgUmFuZG9tID0gZnVuY3Rpb24gKHJlY3QsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIG91dC54ID0gcmVjdC54ICsgKE1hdGgucmFuZG9tKCkgKiByZWN0LndpZHRoKTtcbiAgICBvdXQueSA9IHJlY3QueSArIChNYXRoLnJhbmRvbSgpICogcmVjdC5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvUmFuZG9tLmpzIiwiLy8gIFRoZSB0aHJlZSBtZWRpYW5zICh0aGUgbGluZXMgZHJhd24gZnJvbSB0aGUgdmVydGljZXMgdG8gdGhlIGJpc2VjdG9ycyBvZiB0aGUgb3Bwb3NpdGUgc2lkZXMpXG4vLyAgbWVldCBpbiB0aGUgY2VudHJvaWQgb3IgY2VudGVyIG9mIG1hc3MgKGNlbnRlciBvZiBncmF2aXR5KS5cbi8vICBUaGUgY2VudHJvaWQgZGl2aWRlcyBlYWNoIG1lZGlhbiBpbiBhIHJhdGlvIG9mIDI6MVxuXG52YXIgQ2VudHJvaWQgPSBmdW5jdGlvbiAodHJpYW5nbGUsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cblxuICAgIG91dC54ID0gKHRyaWFuZ2xlLngxICsgdHJpYW5nbGUueDIgKyB0cmlhbmdsZS54MykgLyAzO1xuICAgIG91dC55ID0gKHRyaWFuZ2xlLnkxICsgdHJpYW5nbGUueTIgKyB0cmlhbmdsZS55MykgLyAzO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VudHJvaWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0NlbnRyb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERlY29tcG9zZSA9IGZ1bmN0aW9uICh0cmlhbmdsZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBbXTsgfVxuXG4gICAgb3V0LnB1c2goeyB4OiB0cmlhbmdsZS54MSwgeTogdHJpYW5nbGUueTEgfSk7XG4gICAgb3V0LnB1c2goeyB4OiB0cmlhbmdsZS54MiwgeTogdHJpYW5nbGUueTIgfSk7XG4gICAgb3V0LnB1c2goeyB4OiB0cmlhbmdsZS54MywgeTogdHJpYW5nbGUueTMgfSk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvbXBvc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0RlY29tcG9zZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSB0aHJlZSBhbmdsZSBiaXNlY3RvcnMgb2YgYSB0cmlhbmdsZSBtZWV0IGluIG9uZSBwb2ludCBjYWxsZWQgdGhlIGluY2VudGVyLlxuLy8gSXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgaW5jaXJjbGUsIHRoZSBjaXJjbGUgaW5zY3JpYmVkIGluIHRoZSB0cmlhbmdsZS5cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoICh4MSwgeTEsIHgyLCB5MilcbntcbiAgICB2YXIgeCA9IHgxIC0geDI7XG4gICAgdmFyIHkgPSB5MSAtIHkyO1xuICAgIHZhciBtYWduaXR1ZGUgPSAoeCAqIHgpICsgKHkgKiB5KTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQobWFnbml0dWRlKTtcbn1cblxudmFyIEluQ2VudGVyID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XG5cbiAgICB2YXIgeDEgPSB0cmlhbmdsZS54MTtcbiAgICB2YXIgeTEgPSB0cmlhbmdsZS55MTtcblxuICAgIHZhciB4MiA9IHRyaWFuZ2xlLngyO1xuICAgIHZhciB5MiA9IHRyaWFuZ2xlLnkyO1xuXG4gICAgdmFyIHgzID0gdHJpYW5nbGUueDM7XG4gICAgdmFyIHkzID0gdHJpYW5nbGUueTM7XG5cbiAgICB2YXIgZDEgPSBnZXRMZW5ndGgoeDMsIHkzLCB4MiwgeTIpO1xuICAgIHZhciBkMiA9IGdldExlbmd0aCh4MSwgeTEsIHgzLCB5Myk7XG4gICAgdmFyIGQzID0gZ2V0TGVuZ3RoKHgyLCB5MiwgeDEsIHkxKTtcblxuICAgIHZhciBwID0gZDEgKyBkMiArIGQzO1xuXG4gICAgb3V0LnggPSAoeDEgKiBkMSArIHgyICogZDIgKyB4MyAqIGQzKSAvIHA7XG4gICAgb3V0LnkgPSAoeTEgKiBkMSArIHkyICogZDIgKyB5MyAqIGQzKSAvIHA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbkNlbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvSW5DZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5KVxue1xuICAgIHRyaWFuZ2xlLngxICs9IHg7XG4gICAgdHJpYW5nbGUueTEgKz0geTtcblxuICAgIHRyaWFuZ2xlLngyICs9IHg7XG4gICAgdHJpYW5nbGUueTIgKz0geTtcblxuICAgIHRyaWFuZ2xlLngzICs9IHg7XG4gICAgdHJpYW5nbGUueTMgKz0geTtcblxuICAgIHJldHVybiB0cmlhbmdsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBSYW5kb20gPSBmdW5jdGlvbiAodHJpYW5nbGUsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cblxuICAgIC8vICBCYXNpcyB2ZWN0b3JzXG4gICAgdmFyIHV4ID0gdHJpYW5nbGUueDIgLSB0cmlhbmdsZS54MTtcbiAgICB2YXIgdXkgPSB0cmlhbmdsZS55MiAtIHRyaWFuZ2xlLnkxO1xuXG4gICAgdmFyIHZ4ID0gdHJpYW5nbGUueDMgLSB0cmlhbmdsZS54MTtcbiAgICB2YXIgdnkgPSB0cmlhbmdsZS55MyAtIHRyaWFuZ2xlLnkxO1xuXG4gICAgLy8gIFJhbmRvbSBwb2ludCB3aXRoaW4gdGhlIHVuaXQgc3F1YXJlXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBzID0gTWF0aC5yYW5kb20oKTtcblxuICAgIC8vICBQb2ludCBvdXRzaWRlIHRoZSB0cmlhbmdsZT8gUmVtYXAgaXQuXG4gICAgaWYgKHIgKyBzID49IDEpXG4gICAge1xuICAgICAgICByID0gMSAtIHI7XG4gICAgICAgIHMgPSAxIC0gcztcbiAgICB9XG5cbiAgICBvdXQueCA9IHRyaWFuZ2xlLngxICsgKCh1eCAqIHIpICsgKHZ4ICogcykpO1xuICAgIG91dC55ID0gdHJpYW5nbGUueTEgKyAoKHV5ICogcikgKyAodnkgKiBzKSk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL1JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBBZGRzIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycyB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgdmFsdWUsIHVwIHRvIGEgbWF4aW11bSBvZiAyNTUuXG4qXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRBZGRcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgQWRkID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGgubWluKDI1NSwgYSArIGIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBEYXJrZW5zIHRoZSBiYWNrZHJvcCBjb2xvciB0byByZWZsZWN0IHRoZSBzb3VyY2UgY29sb3IuXG4qIFBhaW50aW5nIHdpdGggd2hpdGUgcHJvZHVjZXMgbm8gY2hhbmdlLiBcbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZENvbG9yQnVyblxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBDb2xvckJ1cm4gPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGIgPT09IDApID8gYiA6IE1hdGgubWF4KDAsICgyNTUgLSAoKDI1NSAtIGEpIDw8IDgpIC8gYikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvckJ1cm47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yQnVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBCcmlnaHRlbnMgdGhlIGJhY2tkcm9wIGNvbG9yIHRvIHJlZmxlY3QgdGhlIHNvdXJjZSBjb2xvci4gXG4qIFBhaW50aW5nIHdpdGggYmxhY2sgcHJvZHVjZXMgbm8gY2hhbmdlLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kQ29sb3JEb2RnZVxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBDb2xvckRvZGdlID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKChhIDw8IDgpIC8gKDI1NSAtIGIpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yRG9kZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0NvbG9yRG9kZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogU2VsZWN0cyB0aGUgZGFya2VyIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9ycy5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZERhcmtlblxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBEYXJrZW4gPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGIgPiBhKSA/IGEgOiBiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXJrZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0Rhcmtlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBTZWxlY3RzIHRoZSBsaWdodGVyIG9mIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9ycy5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpZ2h0ZW5cbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgTGlnaHRlbiA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiAoYiA+IGEpID8gYiA6IGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0ZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpZ2h0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3VidHJhY3QgPSByZXF1aXJlKCcuL1N1YnRyYWN0Jyk7XG5cbi8qKlxuKiBBbiBhbGlhcyBmb3IgYmxlbmRTdWJ0cmFjdCwgaXQgc2ltcGx5IHN1bXMgdGhlIHZhbHVlcyBvZiB0aGUgdHdvIGNvbG9ycyBhbmQgc3VidHJhY3RzIDI1NS5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckJ1cm5cbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgTGluZWFyQnVybiA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiBTdWJ0cmFjdChhLCBiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyQnVybjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyQnVybi5qcyIsInZhciBBZGQgPSByZXF1aXJlKCcuL0FkZCcpO1xuXG4vKipcbiogQW4gYWxpYXMgZm9yIGJsZW5kQWRkLCBpdCBzaW1wbHkgc3VtcyB0aGUgdmFsdWVzIG9mIHRoZSB0d28gY29sb3JzLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kTGluZWFyRG9kZ2VcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgTGluZWFyRG9kZ2UgPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gQWRkKGEsIGIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJEb2RnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvTGluZWFyRG9kZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckRvZGdlLmpzIiwiLyoqXG4qIE11bHRpcGxpZXMgb3Igc2NyZWVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIGJhY2tkcm9wIGNvbG9yLlxuKiBTb3VyY2UgY29sb3JzIG92ZXJsYXkgdGhlIGJhY2tkcm9wIHdoaWxlIHByZXNlcnZpbmcgaXRzIGhpZ2hsaWdodHMgYW5kIHNoYWRvd3MuIFxuKiBUaGUgYmFja2Ryb3AgY29sb3IgaXMgbm90IHJlcGxhY2VkLCBidXQgaXMgbWl4ZWQgd2l0aCB0aGUgc291cmNlIGNvbG9yIHRvIHJlZmxlY3QgdGhlIGxpZ2h0bmVzcyBvciBkYXJrbmVzcyBvZiB0aGUgYmFja2Ryb3AuXG4qXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRPdmVybGF5XG4qIEBzdGF0aWNcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qL1xudmFyIE92ZXJsYXkgPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gKDIgKiBhICogYiAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBhKSAqICgyNTUgLSBiKSAvIDI1NSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL092ZXJsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogUmVmbGVjdCBibGVuZCBtb2RlLiBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4gYWRkaW5nIHNoaW5pbmcgb2JqZWN0cyBvciBsaWdodCB6b25lcyB0byBpbWFnZXMuIFxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kUmVmbGVjdFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBSZWZsZWN0ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIChiID09PSAyNTUpID8gYiA6IE1hdGgubWluKDI1NSwgKGEgKiBhIC8gKDI1NSAtIGIpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1JlZmxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQ29tYmluZXMgdGhlIHNvdXJjZSBhbmQgYmFja2Ryb3AgY29sb3JzIGFuZCByZXR1cm5zIHRoZWlyIHZhbHVlIG1pbnVzIDI1NS5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZFN1YnRyYWN0XG4qIEBzdGF0aWNcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qL1xudmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGEgKyBiIC0gMjU1KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1N1YnRyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yQnVybiA9IHJlcXVpcmUoJy4vQ29sb3JCdXJuJyk7XG52YXIgQ29sb3JEb2RnZSA9IHJlcXVpcmUoJy4vQ29sb3JEb2RnZScpO1xuXG4vKipcbiogVGhpcyBibGVuZCBtb2RlIGNvbWJpbmVzIENvbG9yIERvZGdlIGFuZCBDb2xvciBCdXJuIChyZXNjYWxlZCBzbyB0aGF0IG5ldXRyYWwgY29sb3JzIGJlY29tZSBtaWRkbGUgZ3JheSkuXG4qIERvZGdlIGFwcGxpZXMgd2hlbiB2YWx1ZXMgaW4gdGhlIHRvcCBsYXllciBhcmUgbGlnaHRlciB0aGFuIG1pZGRsZSBncmF5LCBhbmQgYnVybiB0byBkYXJrZXIgdmFsdWVzLlxuKiBUaGUgbWlkZGxlIGdyYXkgaXMgdGhlIG5ldXRyYWwgY29sb3IuIFdoZW4gY29sb3IgaXMgbGlnaHRlciB0aGFuIHRoaXMsIHRoaXMgZWZmZWN0aXZlbHkgbW92ZXMgdGhlIHdoaXRlIHBvaW50IG9mIHRoZSBib3R0b20gXG4qIGxheWVyIGRvd24gYnkgdHdpY2UgdGhlIGRpZmZlcmVuY2U7IHdoZW4gaXQgaXMgZGFya2VyLCB0aGUgYmxhY2sgcG9pbnQgaXMgbW92ZWQgdXAgYnkgdHdpY2UgdGhlIGRpZmZlcmVuY2UuIFRoZSBwZXJjZWl2ZWQgY29udHJhc3QgaW5jcmVhc2VzLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kVml2aWRMaWdodFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBWaXZpZExpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IENvbG9yQnVybihhLCAyICogYikgOiBDb2xvckRvZGdlKGEsICgyICogKGIgLSAxMjgpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpdmlkTGlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1ZpdmlkTGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9ibGVuZG1vZGVzL1ZpdmlkTGlnaHQuanMiLCIvKipcbiogUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGNvbG9yIGNvbXBvbmVudC5cbipcbiogQHBhcmFtIHtpbnRlZ2VyfSBjb2xvciAtIFRoZSBjb2xvciBjaGFubmVsIHRvIGdldCB0aGUgaGV4IHZhbHVlIGZvciwgbXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1LlxuKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIG9mIGxlbmd0aCAyIGNoYXJhY3RlcnMsIGkuZS4gMjU1ID0gZmYsIDEwMCA9IDY0LlxuKi9cbnZhciBDb21wb25lbnRUb0hleCA9IGZ1bmN0aW9uIChjb2xvcilcbntcbiAgICB2YXIgaGV4ID0gY29sb3IudG9TdHJpbmcoMTYpO1xuXG4gICAgcmV0dXJuIChoZXgubGVuZ3RoID09PSAxKSA/ICcwJyArIGhleCA6IGhleDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50VG9IZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9Db21wb25lbnRUb0hleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2l2ZW4gYW4gYWxwaGEgYW5kIDMgY29sb3IgdmFsdWVzIHRoaXMgd2lsbCByZXR1cm4gYW4gaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAqXG4gKiBAbWV0aG9kIGdldENvbG9yMzJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gciAtIFRoZSByZWQgY29sb3IgY29tcG9uZW50IGluIHRoZSByYW5nZSAwIC0gMjU1LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBibHVlIGNvbG9yIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cbiAqIEByZXR1cm4ge2ludGVnZXJ9IEEgbmF0aXZlIGNvbG9yIHZhbHVlIGludGVnZXIgKGZvcm1hdDogMHhSUkdHQkIpLlxuICovXG52YXIgR2V0Q29sb3IzMiA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcbntcbiAgICByZXR1cm4gYWxwaGEgPDwgMjQgfCByZWQgPDwgMTYgfCBncmVlbiA8PCA4IHwgYmx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Q29sb3IzMjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0dldENvbG9yMzIuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0Q29sb3IgPSByZXF1aXJlKCcuL0dldENvbG9yJyk7XG5cbi8qKlxuICogQ29udmVydHMgYW4gSFNWIChodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlKSBjb2xvciB2YWx1ZSB0byBSR0IuXG4gKiBDb252ZXJzaW9uIGZvcm11bGEgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cbiAqIEFzc3VtZXMgSFNWIHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZCByZXR1cm5zIHIsIGcgYW5kIGIgdmFsdWVzIGluIHRoZSBzZXQgWzAsIDI1NV0uXG4gKiBCYXNlZCBvbiBjb2RlIGJ5IE1pY2hhZWwgSmFja3NvbiAoaHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb24pXG4gKlxuICogQG1ldGhvZCBmcm9tSFNWXG4gKiBAcGFyYW0ge251bWJlcn0gaCAtIFRoZSBodWUsIGluIHRoZSByYW5nZSAwIC0gMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gVGhlIHNhdHVyYXRpb24sIGluIHRoZSByYW5nZSAwIC0gMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2IC0gVGhlIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMCAtIDEuXG4gKiBAcmV0dXJuIHtCYXNlQ29sb3J9IFRoaXNcbiAqL1xudmFyIEhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpXG57XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgeyBzID0gMTsgfVxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IDE7IH1cblxuICAgIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gICAgdmFyIGYgPSBoICogNiAtIGk7XG5cbiAgICB2YXIgcCA9IE1hdGguZmxvb3IoKHYgKiAoMSAtIHMpKSAqIDI1NSk7XG4gICAgdmFyIHEgPSBNYXRoLmZsb29yKCh2ICogKDEgLSBmICogcykpICogMjU1KTtcbiAgICB2YXIgdCA9IE1hdGguZmxvb3IoKHYgKiAoMSAtICgxIC0gZikgKiBzKSkgKiAyNTUpO1xuXG4gICAgdiA9IE1hdGguZmxvb3IodiAqPSAyNTUpO1xuXG4gICAgdmFyIG91dHB1dCA9IHsgcjogdiwgZzogdiwgYjogdiwgY29sb3I6IDAgfTtcblxuICAgIHZhciByID0gaSAlIDY7XG5cbiAgICBpZiAociA9PT0gMClcbiAgICB7XG4gICAgICAgIG91dHB1dC5nID0gdDtcbiAgICAgICAgb3V0cHV0LmIgPSBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChyID09PSAxKVxuICAgIHtcbiAgICAgICAgb3V0cHV0LnIgPSBxO1xuICAgICAgICBvdXRwdXQuYiA9IHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHIgPT09IDIpXG4gICAge1xuICAgICAgICBvdXRwdXQuciA9IHA7XG4gICAgICAgIG91dHB1dC5iID0gdDtcbiAgICB9XG4gICAgZWxzZSBpZiAociA9PT0gMylcbiAgICB7XG4gICAgICAgIG91dHB1dC5yID0gcDtcbiAgICAgICAgb3V0cHV0LmcgPSBxO1xuICAgIH1cbiAgICBlbHNlIGlmIChyID09PSA0KVxuICAgIHtcbiAgICAgICAgb3V0cHV0LnIgPSB0O1xuICAgICAgICBvdXRwdXQuZyA9IHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHIgPT09IDUpXG4gICAge1xuICAgICAgICBvdXRwdXQuZyA9IHA7XG4gICAgICAgIG91dHB1dC5iID0gcTtcbiAgICB9XG5cbiAgICBvdXRwdXQuY29sb3IgPSBHZXRDb2xvcihvdXRwdXQuciwgb3V0cHV0LmcsIG91dHB1dC5iKTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhTVlRvUkdCO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSFNWVG9SR0IuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9IU1ZUb1JHQi5qcyIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcblxuLyoqXG4qIENvbnZlcnRzIGEgaGV4IHN0cmluZyBpbnRvIGEgUGhhc2VyIENvbG9yIG9iamVjdC5cbipcbiogVGhlIGhleCBzdHJpbmcgY2FuIHN1cHBsaWVkIGFzIGAnIzAwMzNmZidgIG9yIHRoZSBzaG9ydC1oYW5kIGZvcm1hdCBvZiBgJyMwM2YnYDsgaXQgY2FuIGJlZ2luIHdpdGggYW4gb3B0aW9uYWwgXCIjXCIgb3IgXCIweFwiLCBvciBiZSB1bnByZWZpeGVkLiAgICBcbipcbiogQW4gYWxwaGEgY2hhbm5lbCBpcyBfbm90XyBzdXBwb3J0ZWQuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkNvbG9yLmhleFRvQ29sb3JcbiogQHN0YXRpY1xuKiBAcGFyYW0ge3N0cmluZ30gaGV4IC0gVGhlIGNvbG9yIHN0cmluZyBpbiBhIGhleCBmb3JtYXQuXG4qIEBwYXJhbSB7b2JqZWN0fSBbb3V0XSAtIEFuIG9iamVjdCBpbnRvIHdoaWNoIDMgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQgb3Igc2V0OiByLCBnIGFuZCBiLiBJZiBub3QgcHJvdmlkZWQgYSBuZXcgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgc2V0IGluIHRoZSByLCBnIGFuZCBiIHByb3BlcnRpZXMuXG4qL1xudmFyIEhleFN0cmluZ1RvQ29sb3IgPSBmdW5jdGlvbiAoaGV4KVxue1xuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xuXG4gICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eKD86I3wweCk/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gL14oPzojfDB4KT8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuXG4gICAgaWYgKHJlc3VsdClcbiAgICB7XG4gICAgICAgIHZhciByID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxNik7XG4gICAgICAgIHZhciBnID0gcGFyc2VJbnQocmVzdWx0WzJdLCAxNik7XG4gICAgICAgIHZhciBiID0gcGFyc2VJbnQocmVzdWx0WzNdLCAxNik7XG5cbiAgICAgICAgY29sb3Iuc2V0VG8ociwgZywgYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZXhTdHJpbmdUb0NvbG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSGV4U3RyaW5nVG9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0hleFN0cmluZ1RvQ29sb3IuanMiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9IdWVUb0NvbXBvbmVudC5qcyIsIi8qKlxuKiBDb252ZXJ0cyBhIGh1ZSB0byBhbiBSR0IgY29sb3IuXG4qIEJhc2VkIG9uIGNvZGUgYnkgTWljaGFlbCBKYWNrc29uIChodHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbilcbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5odWVUb0NvbG9yXG4qIEBwYXJhbSB7bnVtYmVyfSBwXG4qIEBwYXJhbSB7bnVtYmVyfSBxXG4qIEBwYXJhbSB7bnVtYmVyfSB0XG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbG9yIGNvbXBvbmVudCB2YWx1ZS5cbiovXG52YXIgSHVlVG9Db21wb25lbnQgPSBmdW5jdGlvbiAocCwgcSwgdClcbntcbiAgICBpZiAodCA8IDApXG4gICAge1xuICAgICAgICB0ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHQgPiAxKVxuICAgIHtcbiAgICAgICAgdCAtPSAxO1xuICAgIH1cblxuICAgIGlmICh0IDwgMSAvIDYpXG4gICAge1xuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG5cbiAgICBpZiAodCA8IDEgLyAyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuXG4gICAgaWYgKHQgPCAyIC8gMylcbiAgICB7XG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbm1vZHVsZS5leHBvcnQgPSBIdWVUb0NvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0h1ZVRvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xudmFyIEludGVnZXJUb1JHQiA9IHJlcXVpcmUoJy4vSW50ZWdlclRvUkdCJyk7XG5cbnZhciBJbnRlZ2VyVG9Db2xvciA9IGZ1bmN0aW9uIChpbnB1dClcbntcbiAgICB2YXIgcmdiID0gSW50ZWdlclRvUkdCKGlucHV0KTtcblxuICAgIHJldHVybiBuZXcgQ29sb3IocmdiLnIsIHJnYi5nLCByZ2IuYiwgcmdiLmEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyVG9Db2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvSW50ZWdlclRvQ29sb3IuanMiLCIvKipcbiogUmV0dXJuIHRoZSBjb21wb25lbnQgcGFydHMgb2YgYSBjb2xvciBhcyBhbiBPYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBhbHBoYSwgcmVkLCBncmVlbiwgYmx1ZS5cbipcbiogQWxwaGEgd2lsbCBvbmx5IGJlIHNldCBpZiBpdCBleGlzdCBpbiB0aGUgZ2l2ZW4gY29sb3IgKDB4QUFSUkdHQkIpXG4qXG4qIEBtZXRob2QgUGhhc2VyLkNvbG9yLmdldFJHQlxuKiBAc3RhdGljXG4qIEBwYXJhbSB7bnVtYmVyfSBjb2xvciAtIENvbG9yIGluIFJHQiAoMHhSUkdHQkIpIG9yIEFSR0IgZm9ybWF0ICgweEFBUlJHR0JCKS5cbiogQHJldHVybiB7b2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOiBhbHBoYSwgcmVkLCBncmVlbiwgYmx1ZSAoYWxzbyByLCBnLCBiIGFuZCBhKS4gQWxwaGEgd2lsbCBvbmx5IGJlIHByZXNlbnQgaWYgYSBjb2xvciB2YWx1ZSA+IDE2Nzc3MjE1IHdhcyBnaXZlbi5cbiovXG52YXIgSW50ZWdlclRvUkdCID0gZnVuY3Rpb24gKGNvbG9yKVxue1xuICAgIGlmIChjb2xvciA+IDE2Nzc3MjE1KVxuICAgIHtcbiAgICAgICAgLy8gIFRoZSBjb2xvciB2YWx1ZSBoYXMgYW4gYWxwaGEgY29tcG9uZW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBjb2xvciA+Pj4gMjQsXG4gICAgICAgICAgICByOiBjb2xvciA+PiAxNiAmIDB4RkYsXG4gICAgICAgICAgICBnOiBjb2xvciA+PiA4ICYgMHhGRixcbiAgICAgICAgICAgIGI6IGNvbG9yICYgMHhGRlxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogMjU1LFxuICAgICAgICAgICAgcjogY29sb3IgPj4gMTYgJiAweEZGLFxuICAgICAgICAgICAgZzogY29sb3IgPj4gOCAmIDB4RkYsXG4gICAgICAgICAgICBiOiBjb2xvciAmIDB4RkZcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXJUb1JHQjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0ludGVnZXJUb1JHQi5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcblxuLyoqXG4qIENvbnZlcnRzIGEgQ1NTICd3ZWInIHN0cmluZyBpbnRvIGEgUGhhc2VyIENvbG9yIG9iamVjdC5cbipcbiogVGhlIHdlYiBzdHJpbmcgY2FuIGJlIGluIHRoZSBmb3JtYXQgYCdyZ2IocixnLGIpJ2Agb3IgYCdyZ2JhKHIsZyxiLGEpJ2Agd2hlcmUgci9nL2IgYXJlIGluIHRoZSByYW5nZSBbMC4uMjU1XSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAuLjFdLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5Db2xvci53ZWJUb0NvbG9yXG4qIEBzdGF0aWNcbiogQHBhcmFtIHtzdHJpbmd9IHdlYiAtIFRoZSBjb2xvciBzdHJpbmcgaW4gQ1NTICd3ZWInIGZvcm1hdC5cbiogQHBhcmFtIHtvYmplY3R9IFtvdXRdIC0gQW4gb2JqZWN0IGludG8gd2hpY2ggNCBwcm9wZXJ0aWVzIHdpbGwgYmUgY3JlYXRlZDogciwgZywgYiBhbmQgYS4gSWYgbm90IHByb3ZpZGVkIGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXG4qIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIHZhbHVlcyBzZXQgaW4gdGhlIHIsIGcsIGIgYW5kIGEgcHJvcGVydGllcy5cbiovXG52YXIgUkdCU3RyaW5nVG9Db2xvciA9IGZ1bmN0aW9uIChyZ2IpXG57XG4gICAgdmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gL15yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xccypcXCkkLy5leGVjKHJnYi50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGlmIChyZXN1bHQpXG4gICAge1xuICAgICAgICB2YXIgciA9IHBhcnNlSW50KHJlc3VsdFsxXSwgMTApO1xuICAgICAgICB2YXIgZyA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTApO1xuICAgICAgICB2YXIgYiA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTApO1xuICAgICAgICB2YXIgYSA9IChyZXN1bHRbNF0gIT09IHVuZGVmaW5lZCkgPyBwYXJzZUZsb2F0KHJlc3VsdFs0XSkgOiAxO1xuXG4gICAgICAgIGNvbG9yLnNldFRvKHIsIGcsIGIsIGEgKiAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUkdCU3RyaW5nVG9Db2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL1JHQlN0cmluZ1RvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9SR0JTdHJpbmdUb0NvbG9yLmpzIiwidmFyIFJHQlN0cmluZ1RvQ29sb3IgPSByZXF1aXJlKCcuL1JHQlN0cmluZ1RvQ29sb3InKTtcbnZhciBIZXhTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9IZXhTdHJpbmdUb0NvbG9yJyk7XG52YXIgSW50ZWdlclRvQ29sb3IgPSByZXF1aXJlKCcuL0ludGVnZXJUb0NvbG9yJyk7XG5cbnZhciBWYWx1ZVRvQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpXG57XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpXG4gICAge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT09ICdyZ2InKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gUkdCU3RyaW5nVG9Db2xvcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gSGV4U3RyaW5nVG9Db2xvcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJylcbiAgICB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyVG9Db2xvcihpbnB1dCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZVRvQ29sb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9WYWx1ZVRvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9WYWx1ZVRvQ29sb3IuanMiLCJ2YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcbnZhciBLZXlDb2RlcyA9IHJlcXVpcmUoJy4va2V5cy9LZXlDb2RlcycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4va2V5cy9LZXknKTtcbnZhciBLZXlDb21ibyA9IHJlcXVpcmUoJy4vY29tYm8vS2V5Q29tYm8nKTtcbnZhciBQcm9jZXNzS2V5Q29tYm8gPSByZXF1aXJlKCcuL2NvbWJvL1Byb2Nlc3NLZXlDb21ibycpO1xudmFyIFByb2Nlc3NLZXlEb3duID0gcmVxdWlyZSgnLi9rZXlzL1Byb2Nlc3NLZXlEb3duJyk7XG52YXIgUHJvY2Vzc0tleVVwID0gcmVxdWlyZSgnLi9rZXlzL1Byb2Nlc3NLZXlVcCcpO1xuXG4vKipcbiogVGhlIEtleWJvYXJkIGNsYXNzIG1vbml0b3JzIGtleWJvYXJkIGlucHV0IGFuZCBkaXNwYXRjaGVzIGtleWJvYXJkIGV2ZW50cy5cbipcbiogX05vdGVfOiBtYW55IGtleWJvYXJkcyBhcmUgdW5hYmxlIHRvIHByb2Nlc3MgY2VydGFpbiBjb21iaW5hdGlvbnMgb2Yga2V5cyBkdWUgdG8gaGFyZHdhcmUgbGltaXRhdGlvbnMga25vd24gYXMgZ2hvc3RpbmcuXG4qIFNlZSBodHRwOi8vd3d3Lmh0bWw1Z2FtZWRldnMuY29tL3RvcGljLzQ4NzYtaW1wb3NzaWJsZS10by11c2UtbW9yZS10aGFuLTIta2V5Ym9hcmQtaW5wdXQtYnV0dG9ucy1hdC10aGUtc2FtZS10aW1lLyBmb3IgbW9yZSBkZXRhaWxzLlxuKlxuKiBBbHNvIHBsZWFzZSBiZSBhd2FyZSB0aGF0IGNlcnRhaW4gYnJvd3NlciBleHRlbnNpb25zIGNhbiBkaXNhYmxlIG9yIG92ZXJyaWRlIFBoYXNlciBrZXlib2FyZCBoYW5kbGluZy5cbiogRm9yIGV4YW1wbGUgdGhlIENocm9tZSBleHRlbnNpb24gdmltaXVtIGlzIGtub3duIHRvIGRpc2FibGUgUGhhc2VyIGZyb20gdXNpbmcgdGhlIEQga2V5LiBBbmQgdGhlcmUgYXJlIG90aGVycy5cbiogU28gcGxlYXNlIGNoZWNrIHlvdXIgZXh0ZW5zaW9ucyBiZWZvcmUgb3BlbmluZyBQaGFzZXIgaXNzdWVzLlxuKlxuKiBAY2xhc3MgUGhhc2VyLktleWJvYXJkXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXG4qL1xudmFyIEtleWJvYXJkTWFuYWdlciA9IGZ1bmN0aW9uIChpbnB1dE1hbmFnZXIpXG57XG4gICAgdGhpcy5tYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnRhcmdldDtcblxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgdGhpcy5rZXlzID0gW107XG5cbiAgICB0aGlzLmNvbWJvcyA9IFtdO1xuXG4gICAgdGhpcy5jYXB0dXJlcyA9IFtdO1xuXG4gICAgLy8gICBTdGFuZGFyZCBGSUZPIHF1ZXVlXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuXG4gICAgdGhpcy5rZXlIYW5kbGVyO1xufTtcblxuS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWJvYXJkTWFuYWdlcjtcblxuS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXG4gICAgKiBUaGUgcmVuZGVyZXIgaXMgYXZhaWxhYmxlIGJ5IG5vdy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5JbnB1dC5LZXlib2FyZE1hbmFnZXIjYm9vdFxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tYW5hZ2VyLmdhbWVDb25maWc7XG5cbiAgICAgICAgdGhpcy5lbmFibGVkID0gY29uZmlnLmlucHV0S2V5Ym9hcmQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gY29uZmlnLmlucHV0S2V5Ym9hcmRFdmVudFRhcmdldDtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhcnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSB0aGlzLmNhcHR1cmVzO1xuXG4gICAgICAgIHZhciBrZXlIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGV2ZW50IGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcXVldWUucHVzaChldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChjYXB0dXJlc1tldmVudC5rZXlDb2RlXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMua2V5SGFuZGxlciA9IGtleUhhbmRsZXI7XG5cbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXlIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIHN0b3BMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgNCBob3RrZXlzIGZvciBVcCwgRG93biwgTGVmdCBhbmQgUmlnaHQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuS2V5Ym9hcmQjY3JlYXRlQ3Vyc29yS2V5c1xuICAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzOiBgdXBgLCBgZG93bmAsIGBsZWZ0YCBhbmQgYHJpZ2h0YCBvZiB7QGxpbmsgUGhhc2VyLktleX0gb2JqZWN0cy5cbiAgICAqL1xuICAgIGNyZWF0ZUN1cnNvcktleXM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRLZXlzKHtcbiAgICAgICAgICAgIHVwOiBLZXlDb2Rlcy5VUCxcbiAgICAgICAgICAgIGRvd246IEtleUNvZGVzLkRPV04sXG4gICAgICAgICAgICBsZWZ0OiBLZXlDb2Rlcy5MRUZULFxuICAgICAgICAgICAgcmlnaHQ6IEtleUNvZGVzLlJJR0hUXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEEgcHJhY3RpY2FsIHdheSB0byBjcmVhdGUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdXNlciBzZWxlY3RlZCBob3RrZXlzLlxuICAgICpcbiAgICAqIEZvciBleGFtcGxlLFxuICAgICpcbiAgICAqICAgICBhZGRLZXlzKCB7ICd1cCc6IFBoYXNlci5LZXlDb2RlLlcsICdkb3duJzogUGhhc2VyLktleUNvZGUuUywgJ2xlZnQnOiBQaGFzZXIuS2V5Q29kZS5BLCAncmlnaHQnOiBQaGFzZXIuS2V5Q29kZS5EIH0gKTtcbiAgICAqXG4gICAgKiB3b3VsZCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyAoYHVwYCwgYGRvd25gLCBgbGVmdGAgYW5kIGByaWdodGApIHJlZmVycmluZyB0byB7QGxpbmsgUGhhc2VyLktleX0gb2JqZWN0LlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI2FkZEtleXNcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBrZXlzIC0gQSBrZXkgbWFwcGluZyBvYmplY3QsIGkuZS4gYHsgJ3VwJzogUGhhc2VyLktleUNvZGUuVywgJ2Rvd24nOiBQaGFzZXIuS2V5Q29kZS5TIH1gIG9yIGB7ICd1cCc6IDUyLCAnZG93bic6IDUzIH1gLlxuICAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBtYXBwZWQgdG8ge0BsaW5rIFBoYXNlci5LZXl9IHZhbHVlcy5cbiAgICAqL1xuICAgIGFkZEtleXM6IGZ1bmN0aW9uIChrZXlzKVxuICAgIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKVxuICAgICAgICB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IHRoaXMuYWRkS2V5KGtleXNba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIElmIHlvdSBuZWVkIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciBhIEtleSB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBQaGFzZXIuS2V5IG9iamVjdCB2aWEgdGhpcyBtZXRob2QuXG4gICAgKiBUaGUgS2V5IG9iamVjdCBjYW4gdGhlbiBiZSBwb2xsZWQsIGhhdmUgZXZlbnRzIGF0dGFjaGVkIHRvIGl0LCBldGMuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuS2V5Ym9hcmQjYWRkS2V5XG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IGtleWNvZGUgLSBUaGUge0BsaW5rIFBoYXNlci5LZXlDb2RlIGtleWNvZGV9IG9mIHRoZSBrZXkuXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuS2V5fSBUaGUgS2V5IG9iamVjdCB3aGljaCB5b3UgY2FuIHN0b3JlIGxvY2FsbHkgYW5kIHJlZmVyZW5jZSBkaXJlY3RseS5cbiAgICAqL1xuICAgIGFkZEtleTogZnVuY3Rpb24gKGtleUNvZGUpXG4gICAge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblxuICAgICAgICBpZiAoIWtleXNba2V5Q29kZV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleXNba2V5Q29kZV0gPSBuZXcgS2V5KGtleUNvZGUpO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlc1trZXlDb2RlXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5c1trZXlDb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGEgS2V5IG9iamVjdCBmcm9tIHRoZSBLZXlib2FyZCBtYW5hZ2VyLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLktleWJvYXJkI3JlbW92ZUtleVxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBrZXljb2RlIC0gVGhlIHtAbGluayBQaGFzZXIuS2V5Q29kZSBrZXljb2RlfSBvZiB0aGUga2V5IHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleUNvZGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5rZXlzW2tleUNvZGVdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmtleXNba2V5Q29kZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkS2V5Q2FwdHVyZTogZnVuY3Rpb24gKGtleUNvZGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNvZGVzKSlcbiAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZXMgPSBbIGtleUNvZGVzIF07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlS2V5Q2FwdHVyZTogZnVuY3Rpb24gKGtleUNvZGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNvZGVzKSlcbiAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZXMgPSBbIGtleUNvZGVzIF07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVzW2tleUNvZGVzW2ldXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbWJvOiBmdW5jdGlvbiAoa2V5cywgY29uZmlnKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXlDb21ibyh0aGlzLCBrZXlzLCBjb25maWcpO1xuICAgIH0sXG5cbiAgICAvLyAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQvS2V5Ym9hcmRFdmVudFxuICAgIC8vICB0eXBlID0gJ2tleWRvd24nLCAna2V5dXAnXG4gICAgLy8gIGtleUNvZGUgPSBpbnRlZ2VyXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIENsZWFycyB0aGUgcXVldWUgYXJyYXksIGFuZCBhbHNvIG1lYW5zIHdlIGRvbid0IHdvcmsgb24gYXJyYXkgZGF0YSB0aGF0IGNvdWxkIHBvdGVudGlhbGx5XG4gICAgICAgIC8vICBiZSBtb2RpZmllZCBkdXJpbmcgdGhlIHByb2Nlc3NpbmcgcGhhc2VcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCwgdGhpcy5xdWV1ZS5sZW5ndGgpO1xuXG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgICAgICB2YXIgc2luZ2xlS2V5O1xuXG4gICAgICAgIC8vICBQcm9jZXNzIHRoZSBldmVudCBxdWV1ZSwgZGlzcGF0Y2hpbmcgYWxsIG9mIHRoZSBldmVudHMgdGhhdCBoYXZlIHN0b3JlZCB1cFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBxdWV1ZVtpXTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuS0VZX0RPV05fRVZFTlQoZXZlbnQpKTtcblxuICAgICAgICAgICAgICAgIHNpbmdsZUtleSA9IEV2ZW50Ll9ET1dOW2V2ZW50LmtleUNvZGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUtleSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBzaW5nbGVLZXkoZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tldmVudC5rZXlDb2RlXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NLZXlEb3duKGtleXNbZXZlbnQua2V5Q29kZV0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LktFWV9VUF9FVkVOVChldmVudCkpO1xuXG4gICAgICAgICAgICAgICAgc2luZ2xlS2V5ID0gRXZlbnQuX1VQW2V2ZW50LmtleUNvZGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUtleSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBzaW5nbGVLZXkoZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tldmVudC5rZXlDb2RlXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NLZXlVcChrZXlzW2V2ZW50LmtleUNvZGVdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2lucHV0L2tleWJvYXJkL0tleWJvYXJkTWFuYWdlci5qcyIsInZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xudmFyIFJlc2V0S2V5Q29tYm8gPSByZXF1aXJlKCcuL1Jlc2V0S2V5Q29tYm8nKTtcbnZhciBQcm9jZXNzS2V5Q29tYm8gPSByZXF1aXJlKCcuL1Byb2Nlc3NLZXlDb21ibycpO1xudmFyIEtleUNvbWJvTWF0Y2hFdmVudCA9IHJlcXVpcmUoJy4vS2V5Q29tYm9NYXRjaEV2ZW50Jyk7XG5cbi8vICBLZXlzIGNhbiBiZSBlaXRoZXI6XG4vL1xuLy8gIEEgc3RyaW5nIChBVEFSSSlcbi8vICBBbiBhcnJheSBvZiBlaXRoZXIgaW50ZWdlcnMgKGtleSBjb2Rlcykgb3Igc3RyaW5ncywgb3IgYSBtaXh0dXJlIG9mIGJvdGhcbi8vICBBbiBhcnJheSBvZiBvYmplY3RzIChzdWNoIGFzIEtleSBvYmplY3RzKSB3aXRoIGEgcHVibGljICdrZXlDb2RlJyBwcm9wZXJ0eVxuXG52YXIgS2V5Q29tYm8gPSBmdW5jdGlvbiAoa2V5Ym9hcmRNYW5hZ2VyLCBrZXlzLCBjb25maWcpXG57XG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7IGNvbmZpZyA9IHt9OyB9XG5cbiAgICAvLyAgQ2FuJ3QgaGF2ZSBhIHplcm8gb3Igc2luZ2xlIGxlbmd0aCBjb21ibyAoc3RyaW5nIG9yIGFycmF5IGJhc2VkKVxuICAgIGlmIChrZXlzLmxlbmd0aCA8IDIpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VyID0ga2V5Ym9hcmRNYW5hZ2VyO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHRoaXMua2V5Q29kZXMgPSBbXTtcblxuICAgIC8vICBpZiAna2V5cycgaXMgYSBzdHJpbmcgd2UgbmVlZCB0byBnZXQgdGhlIGtleWNvZGUgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gaXRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGFyID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAodHlwZW9mIGNoYXIgPT09ICdzdHJpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmtleUNvZGVzLnB1c2goY2hhci50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFyID09PSAnbnVtYmVyJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXIuaGFzT3duUHJvcGVydHkoJ2tleUNvZGUnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5rZXlDb2Rlcy5wdXNoKGNoYXIua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAgVGhlIGN1cnJlbnQga2V5Q29kZSB0aGUgY29tYm8gaXMgd2FpdGluZyBmb3JcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmtleUNvZGVzWzBdO1xuXG4gICAgLy8gIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBrZXkgYmVpbmcgd2FpdGVkIGZvciBpbiB0aGUgJ2tleXMnIHN0cmluZ1xuICAgIHRoaXMuaW5kZXggPSAwO1xuXG4gICAgLy8gIFRoZSBsZW5ndGggb2YgdGhpcyBjb21ibyAoaW4ga2V5Y29kZXMpXG4gICAgdGhpcy5zaXplID0gdGhpcy5rZXlDb2Rlcy5sZW5ndGg7XG5cbiAgICAvLyAgVGhlIHRpbWUgdGhlIHByZXZpb3VzIGtleSBpbiB0aGUgY29tYm8gd2FzIG1hdGNoZWRcbiAgICB0aGlzLnRpbWVMYXN0TWF0Y2hlZCA9IDA7XG5cbiAgICAvLyAgSGFzIHRoaXMgS2V5IENvbWJvIGJlZW4gbWF0Y2hlZCB5ZXQ/XG4gICAgdGhpcy5tYXRjaGVkID0gZmFsc2U7XG5cbiAgICAvLyAgVGhlIHRpbWUgdGhlIGVudGlyZSBjb21ibyB3YXMgbWF0Y2hlZFxuICAgIHRoaXMudGltZU1hdGNoZWQgPSAwO1xuXG4gICAgLy8gIEN1c3RvbSBvcHRpb25zIC4uLlxuXG4gICAgLy8gIElmIHRoZXkgcHJlc3MgdGhlIHdyb25nIGtleSBkbyB3ZSByZXNldCB0aGUgY29tYm8/XG4gICAgdGhpcy5yZXNldE9uV3JvbmdLZXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXNldE9uV3JvbmdLZXknLCB0cnVlKTtcblxuICAgIC8vICBUaGUgbWF4IGRlbGF5IGluIG1zIGJldHdlZW4gZWFjaCBrZXkgcHJlc3MuIEFib3ZlIHRoaXMgdGhlIGNvbWJvIGlzIHJlc2V0LiAwIG1lYW5zIGRpc2FibGVkLlxuICAgIHRoaXMubWF4S2V5RGVsYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdtYXhLZXlEZWxheScsIDApO1xuXG4gICAgLy8gIElmIHByZXZpb3VzbHkgbWF0Y2hlZCBhbmQgdGhleSBwcmVzcyBLZXkgMSBhZ2Fpbiwgd2lsbCBpdCByZXNldD9cbiAgICB0aGlzLnJlc2V0T25NYXRjaCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3Jlc2V0T25NYXRjaCcsIGZhbHNlKTtcblxuICAgIC8vICBJZiB0aGUgY29tYm8gbWF0Y2hlcywgd2lsbCBpdCBkZWxldGUgaXRzZWxmP1xuICAgIHRoaXMuZGVsZXRlT25NYXRjaCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2RlbGV0ZU9uTWF0Y2gnLCBmYWxzZSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9uS2V5RG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoX3RoaXMubWF0Y2hlZCB8fCAhX3RoaXMuZW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBQcm9jZXNzS2V5Q29tYm8oZXZlbnQuZGF0YSwgX3RoaXMpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5tYW5hZ2VyLmV2ZW50cy5kaXNwYXRjaChuZXcgS2V5Q29tYm9NYXRjaEV2ZW50KF90aGlzLCBldmVudCkpO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzZXRPbk1hdGNoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFJlc2V0S2V5Q29tYm8oX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuZGVsZXRlT25NYXRjaClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbktleURvd24gPSBvbktleURvd25IYW5kbGVyO1xuXG4gICAgdGhpcy5tYW5hZ2VyLmV2ZW50cy5vbignS0VZX0RPV05fRVZFTlQnLCBvbktleURvd25IYW5kbGVyKTtcbn07XG5cbktleUNvbWJvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUNvbWJvO1xuXG5LZXlDb21iby5wcm90b3R5cGUgPSB7XG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2V5Q29kZXMgPSBbXTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIuZXZlbnRzLm9mZignS0VZX0RPV04nLCB0aGlzLm9uS2V5RG93bik7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEtleUNvbWJvLnByb3RvdHlwZSwge1xuXG4gICAgcHJvZ3Jlc3M6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIC8vICBIb3cgZmFyIGNvbXBsZXRlIGlzIHRoaXMgY29tYm8/IEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4IC8gdGhpcy5zaXplO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUNvbWJvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm8uanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9rZXlib2FyZC9jb21iby9LZXlDb21iby5qcyIsInZhciBBZHZhbmNlS2V5Q29tYm8gPSByZXF1aXJlKCcuL0FkdmFuY2VLZXlDb21ibycpO1xuXG52YXIgUHJvY2Vzc0tleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcbntcbiAgICBpZiAoY29tYm8ubWF0Y2hlZClcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjb21ib01hdGNoZWQgPSBmYWxzZTtcbiAgICB2YXIga2V5TWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGNvbWJvLmN1cnJlbnQpXG4gICAge1xuICAgICAgICAvLyAgS2V5IHdhcyBjb3JyZWN0XG5cbiAgICAgICAgaWYgKGNvbWJvLmluZGV4ID4gMCAmJiBjb21iby5tYXhLZXlEZWxheSA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBXZSBoYXZlIHRvIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVsYXkgYmV0d2VlblxuICAgICAgICAgICAgLy8gIHRoZSBuZXcga2V5IGFuZCB0aGUgb2xkIG9uZSB3YXMgdG9vIGxvbmcgKGlmIGVuYWJsZWQpXG5cbiAgICAgICAgICAgIHZhciB0aW1lTGltaXQgPSBjb21iby50aW1lTGFzdE1hdGNoZWQgKyBjb21iby5tYXhLZXlEZWxheTtcblxuICAgICAgICAgICAgLy8gIENoZWNrIGlmIHRoZXkgcHJlc3NlZCBpdCBpbiB0aW1lIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGV2ZW50LnRpbWVTdGFtcCA8PSB0aW1lTGltaXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29tYm9NYXRjaGVkID0gQWR2YW5jZUtleUNvbWJvKGV2ZW50LCBjb21ibyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBrZXlNYXRjaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gIFdlIGRvbid0IGNoZWNrIHRoZSB0aW1lIGZvciB0aGUgZmlyc3Qga2V5IHByZXNzZWQsIHNvIGp1c3QgYWR2YW5jZSBpdFxuICAgICAgICAgICAgY29tYm9NYXRjaGVkID0gQWR2YW5jZUtleUNvbWJvKGV2ZW50LCBjb21ibyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWtleU1hdGNoZWQgJiYgY29tYm8ucmVzZXRPbldyb25nS2V5KVxuICAgIHtcbiAgICAgICAgLy8gIFdyb25nIGtleSB3YXMgcHJlc3NlZFxuICAgICAgICBjb21iby5pbmRleCA9IDA7XG4gICAgICAgIGNvbWJvLmN1cnJlbnQgPSBjb21iby5rZXlDb2Rlc1swXTtcbiAgICB9XG5cbiAgICBpZiAoY29tYm9NYXRjaGVkKVxuICAgIHtcbiAgICAgICAgY29tYm8udGltZUxhc3RNYXRjaGVkID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICBjb21iby5tYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgY29tYm8udGltZU1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJvTWF0Y2hlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleUNvbWJvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQvY29tYm8vUHJvY2Vzc0tleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvY29tYm8vUHJvY2Vzc0tleUNvbWJvLmpzIiwiLy8gIEEgZ2VuZXJpYyBLZXkgb2JqZWN0IHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8gdGhlIFByb2Nlc3MgZnVuY3Rpb25zIChhbmQgc28gb24pXG5cbi8vICBrZXljb2RlIG11c3QgYmUgYW4gaW50ZWdlclxuXG52YXIgS2V5ID0gZnVuY3Rpb24gKGtleUNvZGUpXG57XG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGtleUNvZGUgLSBUaGUga2V5Y29kZSBvZiB0aGlzIGtleS5cbiAgICAqL1xuICAgIHRoaXMua2V5Q29kZSA9IGtleUNvZGU7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7S2V5Ym9hcmRFdmVudH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBET00gZXZlbnQuXG4gICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJldmVudERlZmF1bHQgLSBTaG91bGQgdGhpcyBLZXkgcHJldmVudCBldmVudCBwcm9wYWdhdGlvbj9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkIC0gQ2FuIHRoaXMgS2V5IGJlIHByb2Nlc3NlZD9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRG93biAtIFRoZSBcImRvd25cIiBzdGF0ZSBvZiB0aGUga2V5LiBUaGlzIHdpbGwgcmVtYWluIGB0cnVlYCBmb3IgYXMgbG9uZyBhcyB0aGUga2V5Ym9hcmQgdGhpbmtzIHRoaXMga2V5IGlzIGhlbGQgZG93bi5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVXAgLSBUaGUgXCJ1cFwiIHN0YXRlIG9mIHRoZSBrZXkuIFRoaXMgd2lsbCByZW1haW4gYHRydWVgIGZvciBhcyBsb25nIGFzIHRoZSBrZXlib2FyZCB0aGlua3MgdGhpcyBrZXkgaXMgdXAuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy5pc1VwID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbHRLZXkgLSBUaGUgZG93biBzdGF0ZSBvZiB0aGUgQUxUIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuYWx0S2V5ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3RybEtleSAtIFRoZSBkb3duIHN0YXRlIG9mIHRoZSBDVFJMIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuY3RybEtleSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNoaWZ0S2V5IC0gVGhlIGRvd24gc3RhdGUgb2YgdGhlIFNISUZUIGtleSwgaWYgcHJlc3NlZCBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoaXMga2V5LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgbW9kaWZpZXIga2V5LiAwIGZvciBzdGFuZGFyZCAob3IgdW5rbm93biksIDEgZm9yIGxlZnQsIDIgZm9yIHJpZ2h0LCAzIGZvciBudW1wYWQuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy5sb2NhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lRG93biAtIFRoZSB0aW1lc3RhbXAgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHByZXNzZWQgZG93bi4gVGhpcyBpcyBiYXNlZCBvbiBHYW1lLnRpbWUubm93LlxuICAgICovXG4gICAgdGhpcy50aW1lRG93biA9IDA7XG5cbiAgICAvKipcbiAgICAqIElmIHRoZSBrZXkgaXMgZG93biB0aGlzIHZhbHVlIGhvbGRzIHRoZSBkdXJhdGlvbiBvZiB0aGF0IGtleSBwcmVzcyBhbmQgaXMgY29uc3RhbnRseSB1cGRhdGVkLlxuICAgICogSWYgdGhlIGtleSBpcyB1cCBpdCBob2xkcyB0aGUgZHVyYXRpb24gb2YgdGhlIHByZXZpb3VzIGRvd24gc2Vzc2lvbi5cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoaXMga2V5IGhhcyBiZWVuIGhlbGQgZG93biBmb3IuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lVXAgLSBUaGUgdGltZXN0YW1wIHdoZW4gdGhlIGtleSB3YXMgbGFzdCByZWxlYXNlZC4gVGhpcyBpcyBiYXNlZCBvbiBHYW1lLnRpbWUubm93LlxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMudGltZVVwID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJlcGVhdHMgLSBJZiBhIGtleSBpcyBoZWxkIGRvd24gdGhpcyBob2xkcyBkb3duIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSBoYXMgJ3JlcGVhdGVkJy5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLnJlcGVhdHMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBfanVzdERvd24gLSBUcnVlIGlmIHRoZSBrZXkgaGFzIGp1c3QgYmVlbiBwcmVzc2VkIChOT1RFOiByZXF1aXJlcyB0byBiZSByZXNldCwgc2VlIGp1c3REb3duIGdldHRlcilcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2p1c3REb3duID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IF9qdXN0VXAgLSBUcnVlIGlmIHRoZSBrZXkgaGFzIGp1c3QgYmVlbiBwcmVzc2VkIChOT1RFOiByZXF1aXJlcyB0byBiZSByZXNldCwgc2VlIGp1c3REb3duIGdldHRlcilcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2p1c3RVcCA9IGZhbHNlO1xufTtcblxuS2V5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcblxuLy8gIFRha2VzIHR3byBYSFIgT2JqZWN0cyBhbmQgY3JlYXRlcyBhIG5ldyBvYmplY3RcblxuLy8gIFRoZSBuZXcgb2JqZWN0IGlzIGJhc2VkIG9uIGdsb2JhbCBpbml0aWFsbHksIGJ1dCBhbnkgc2V0dGluZyBpblxuLy8gIGxvY2FsIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIHZhbHVlLlxuXG52YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IGZ1bmN0aW9uIChnbG9iYWwsIGxvY2FsKVxue1xuICAgIHZhciBvdXRwdXQgPSAoZ2xvYmFsID09PSB1bmRlZmluZWQpID8gWEhSU2V0dGluZ3MoKSA6IE9iamVjdC5hc3NpZ24oZ2xvYmFsKTtcblxuICAgIGlmIChsb2NhbClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIHNldHRpbmcgaW4gbG9jYWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChsb2NhbFtzZXR0aW5nXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG91dHB1dFtzZXR0aW5nXSA9IGxvY2FsW3NldHRpbmddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhIUlNldHRpbmdzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL01lcmdlWEhSU2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvTWVyZ2VYSFJTZXR0aW5ncy5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xuXG52YXIgSlNPTkZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxue1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XG5cbiAgICBpZiAoIWtleSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIuanNvblxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXVybClcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLmpzb24nO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAnanNvbicsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcbn07XG5cbkpTT05GaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xuSlNPTkZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlNPTkZpbGU7XG5cbkpTT05GaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXG57XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcblxuICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGhpcy54aHJMb2FkZXIucmVzcG9uc2VUZXh0KTtcblxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xuXG4gICAgY2FsbGJhY2sodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05GaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9KU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvSlNPTkZpbGUuanMiLCJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcbnZhciBQYXJzZVhNTCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9QYXJzZVhNTCcpO1xuXG52YXIgWE1MRmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cblxuICAgIGlmICgha2V5KVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci54bWxcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy54bWwnO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAneG1sJywga2V5LCB1cmwsICd0ZXh0JywgeGhyU2V0dGluZ3MpO1xufTtcblxuWE1MRmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcblhNTEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWE1MRmlsZTtcblxuWE1MRmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxue1xuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XG5cbiAgICB0aGlzLmRhdGEgPSBQYXJzZVhNTCh0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQpO1xuXG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MRmlsZTogSW52YWxpZCBYTUwnKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYTUxGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9YTUxGaWxlLmpzIiwidmFyIEZhY3RvcmlhbCA9IHJlcXVpcmUoJy4vRmFjdG9yaWFsJyk7XG5cbnZhciBCZXJuc3RlaW4gPSBmdW5jdGlvbiAobiwgaSlcbntcbiAgICByZXR1cm4gRmFjdG9yaWFsKG4pIC8gRmFjdG9yaWFsKGkpIC8gRmFjdG9yaWFsKG4gLSBpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVybnN0ZWluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9CZXJuc3RlaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL0Jlcm5zdGVpbi5qcyIsInZhciBDYXRtdWxsUm9tID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KVxue1xuICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNSwgdjEgPSAocDMgLSBwMSkgKiAwLjUsIHQyID0gdCAqIHQsIHQzID0gdCAqIHQyO1xuXG4gICAgcmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRtdWxsUm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9DYXRtdWxsUm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEZvcmNlIGEgdmFsdWUgd2l0aGluIHRoZSBib3VuZGFyaWVzIGJ5IGNsYW1waW5nIGl0IHRvIHRoZSByYW5nZSBgbWluYCwgYG1heGAuXG4qXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjY2xhbXBcbiogQHBhcmFtIHtmbG9hdH0gdiAtIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkLlxuKiBAcGFyYW0ge2Zsb2F0fSBtaW4gLSBUaGUgbWluaW11bSBib3VuZHMuXG4qIEBwYXJhbSB7ZmxvYXR9IG1heCAtIFRoZSBtYXhpbXVtIGJvdW5kcy5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCB2YWx1ZS5cbiovXG52YXIgQ2xhbXAgPSBmdW5jdGlvbiAodiwgbWluLCBtYXgpXG57XG4gICAgaWYgKHYgPCBtaW4pXG4gICAge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXggPCB2KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFtcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvQ2xhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmFjdG9yaWFsID0gZnVuY3Rpb24gKHZhbHVlKVxue1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB2YWx1ZTtcblxuICAgIHdoaWxlICgtLXZhbHVlKVxuICAgIHtcbiAgICAgICAgcmVzICo9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcmlhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmFjdG9yaWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpbmVhciA9IGZ1bmN0aW9uIChwMCwgcDEsIHQpXG57XG4gICAgcmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9MaW5lYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRBd2F5RnJvbVplcm8gPSBmdW5jdGlvbiAodmFsdWUpXG57XG4gICAgLy8gXCJPcHBvc2l0ZVwiIG9mIHRydW5jYXRlLlxuICAgIHJldHVybiAodmFsdWUgPiAwKSA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm91bmRBd2F5RnJvbVplcm87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNtb290aFN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXG57XG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XG5cbiAgICByZXR1cm4geCAqIHggKiAoMyAtIDIgKiB4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbW9vdGhlclN0ZXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpXG57XG4gICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XG5cbiAgICByZXR1cm4geCAqIHggKiB4ICogKHggKiAoeCAqIDYgLSAxNSkgKyAxMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aGVyU3RlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvU21vb3RoZXJTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICBhbmdsZSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcblxuICAgIGlmIChhbmdsZSA+PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gYW5nbGUgKyAyICogTWF0aC5QSTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vcm1hbGl6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvTm9ybWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhXcmFwID0gcmVxdWlyZSgnLi4vV3JhcCcpO1xuXG52YXIgV3JhcCA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICByZXR1cm4gTWF0aFdyYXAoYW5nbGUsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvV3JhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcC5qcyIsInZhciBXcmFwID0gcmVxdWlyZSgnLi4vV3JhcCcpO1xuXG52YXIgV3JhcERlZ3JlZXMgPSBmdW5jdGlvbiAoYW5nbGUpXG57XG4gICAgcmV0dXJuIFdyYXAoYW5nbGUsIC0xODAsIDE4MCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBEZWdyZWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9XcmFwRGVncmVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMuanMiLCJ2YXIgTGluZWFyID0gcmVxdWlyZSgnLi4vTGluZWFyJyk7XG5cbnZhciBMaW5lYXJJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXG57XG4gICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgdmFyIGYgPSBtICogaztcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG5cbiAgICBpZiAoayA8IDApXG4gICAge1xuICAgICAgICByZXR1cm4gTGluZWFyKHZbMF0sIHZbMV0sIGYpO1xuICAgIH1cblxuICAgIGlmIChrID4gMSlcbiAgICB7XG4gICAgICAgIHJldHVybiBMaW5lYXIodlttXSwgdlttIC0gMV0sIG0gLSBmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTGluZWFyKHZbaV0sIHZbKGkgKyAxID4gbSkgPyBtIDogaSArIDFdLCBmIC0gaSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhckludGVycG9sYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vTGluZWFySW50ZXJwb2xhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvaW50ZXJwb2xhdGlvbi9MaW5lYXJJbnRlcnBvbGF0aW9uLmpzIiwiLyoqXG4qIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBtYWtlIGEgcG93ZXIgb2YgdHdvIHRleHR1cmUuXG4qIFxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI2lzUG93ZXJPZlR3b1xuKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggdG8gY2hlY2suXG4qIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIGNoZWNrLlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBhIHBvd2VyIG9mIHR3by5cbiovXG52YXIgSXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHJldHVybiAod2lkdGggPiAwICYmICh3aWR0aCAmICh3aWR0aCAtIDEpKSA9PT0gMCAmJiBoZWlnaHQgPiAwICYmIChoZWlnaHQgJiAoaGVpZ2h0IC0gMSkpID09PSAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXNTaXplUG93ZXJPZlR3bztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1NpemVQb3dlck9mVHdvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBgTWF0dGVyLldvcmxkYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyB0aGUgd29ybGQgY29tcG9zaXRlLlxuKiBBIGBNYXR0ZXIuV29ybGRgIGlzIGEgYE1hdHRlci5Db21wb3NpdGVgIGJvZHksIHdoaWNoIGlzIGEgY29sbGVjdGlvbiBvZiBgTWF0dGVyLkJvZHlgLCBgTWF0dGVyLkNvbnN0cmFpbnRgIGFuZCBvdGhlciBgTWF0dGVyLkNvbXBvc2l0ZWAuXG4qIEEgYE1hdHRlci5Xb3JsZGAgaGFzIGEgZmV3IGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRpbmcgYGdyYXZpdHlgIGFuZCBgYm91bmRzYC5cbiogSXQgaXMgaW1wb3J0YW50IHRvIHVzZSB0aGUgZnVuY3Rpb25zIGluIHRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbW9kdWxlIHRvIG1vZGlmeSB0aGUgd29ybGQgY29tcG9zaXRlLCByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgaXRzIHByb3BlcnRpZXMuXG4qIFRoZXJlIGFyZSBhbHNvIGEgZmV3IG1ldGhvZHMgaGVyZSB0aGF0IGFsaWFzIHRob3NlIGluIGBNYXR0ZXIuQ29tcG9zaXRlYCBmb3IgZWFzaWVyIHJlYWRhYmlsaXR5LlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgV29ybGRcbiogQGV4dGVuZHMgQ29tcG9zaXRlXG4qL1xuXG52YXIgV29ybGQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcblxudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vQ29tcG9zaXRlJyk7XG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgd29ybGQgY29tcG9zaXRlLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt3b3JsZH0gQSBuZXcgd29ybGRcbiAgICAgKi9cbiAgICBXb3JsZC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb3NpdGUgPSBDb21wb3NpdGUuY3JlYXRlKCk7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgbGFiZWw6ICdXb3JsZCcsXG4gICAgICAgICAgICBncmF2aXR5OiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLjAwMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvdW5kczogeyBcbiAgICAgICAgICAgICAgICBtaW46IHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHkgfSwgXG4gICAgICAgICAgICAgICAgbWF4OiB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSB9IFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIENvbW1vbi5leHRlbmQoY29tcG9zaXRlLCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdyYXZpdHkgdG8gYXBwbHkgb24gdGhlIHdvcmxkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHlcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBncmF2aXR5IHggY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueFxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBncmF2aXR5IHkgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBncmF2aXR5IHNjYWxlIGZhY3Rvci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnNjYWxlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgd29ybGQgYm91bmRzIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xuICAgICAqIEB0eXBlIGJvdW5kc1xuICAgICAqIEBkZWZhdWx0IHsgbWluOiB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5IH0sIG1heDogeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHkgfSB9XG4gICAgICovXG5cbiAgICAvLyBXb3JsZCBpcyBhIENvbXBvc2l0ZSBib2R5XG4gICAgLy8gc2VlIHNyYy9tb2R1bGUvT3V0cm8uanMgZm9yIHRoZXNlIGFsaWFzZXM6XG4gICAgXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5jbGVhclxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge3dvcmxkfSB3b3JsZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN0YXRpY1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRcbiAgICAgKiBAbWV0aG9kIGFkZENvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7d29ybGR9IHdvcmxkXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge3dvcmxkfSBUaGUgb3JpZ2luYWwgd29ybGQgd2l0aCB0aGUgb2JqZWN0cyBmcm9tIGNvbXBvc2l0ZSBhZGRlZFxuICAgICAqL1xuICAgIFxuICAgICAvKipcbiAgICAgICogQW4gYWxpYXMgZm9yIENvbXBvc2l0ZS5hZGRCb2R5XG4gICAgICAqIEBtZXRob2QgYWRkQm9keVxuICAgICAgKiBAcGFyYW0ge3dvcmxkfSB3b3JsZFxuICAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgICogQHJldHVybiB7d29ybGR9IFRoZSBvcmlnaW5hbCB3b3JsZCB3aXRoIHRoZSBib2R5IGFkZGVkXG4gICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBBbiBhbGlhcyBmb3IgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnRcbiAgICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gICAgICAqIEBwYXJhbSB7d29ybGR9IHdvcmxkXG4gICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAgKiBAcmV0dXJuIHt3b3JsZH0gVGhlIG9yaWdpbmFsIHdvcmxkIHdpdGggdGhlIGNvbnN0cmFpbnQgYWRkZWRcbiAgICAgICovXG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9ib2R5L1dvcmxkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvYm9keS9Xb3JsZC5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Db250YWN0YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gY29udGFjdHMuXG4qXG4qIEBjbGFzcyBDb250YWN0XG4qL1xuXG52YXIgQ29udGFjdCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3Q7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29udGFjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGV4fSB2ZXJ0ZXhcbiAgICAgKiBAcmV0dXJuIHtjb250YWN0fSBBIG5ldyBjb250YWN0XG4gICAgICovXG4gICAgQ29udGFjdC5jcmVhdGUgPSBmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBDb250YWN0LmlkKHZlcnRleCksXG4gICAgICAgICAgICB2ZXJ0ZXg6IHZlcnRleCxcbiAgICAgICAgICAgIG5vcm1hbEltcHVsc2U6IDAsXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZTogMFxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgY29udGFjdCBpZC5cbiAgICAgKiBAbWV0aG9kIGlkXG4gICAgICogQHBhcmFtIHt2ZXJ0ZXh9IHZlcnRleFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVW5pcXVlIGNvbnRhY3RJRFxuICAgICAqL1xuICAgIENvbnRhY3QuaWQgPSBmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgICAgcmV0dXJuIHZlcnRleC5ib2R5LmlkICsgJ18nICsgdmVydGV4LmluZGV4O1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vQ29udGFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUaGUgYE1hdHRlci5QYWlyc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIHBhaXIgc2V0cy5cbipcbiogQGNsYXNzIFBhaXJzXG4qL1xuXG52YXIgUGFpcnMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWlycztcblxudmFyIFBhaXIgPSByZXF1aXJlKCcuL1BhaXInKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIF9wYWlyTWF4SWRsZUxpZmUgPSAxMDAwO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYWlycyBzdHJ1Y3R1cmUuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge3BhaXJzfSBBIG5ldyBwYWlycyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBQYWlycy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICB0YWJsZToge30sXG4gICAgICAgICAgICBsaXN0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZTogW10sXG4gICAgICAgICAgICBjb2xsaXNpb25FbmQ6IFtdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBhaXJzIGdpdmVuIGEgbGlzdCBvZiBjb2xsaXNpb25zLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhaXJzXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb25bXX0gY29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBQYWlycy51cGRhdGUgPSBmdW5jdGlvbihwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBwYWlyc0xpc3QgPSBwYWlycy5saXN0LFxuICAgICAgICAgICAgcGFpcnNUYWJsZSA9IHBhaXJzLnRhYmxlLFxuICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQgPSBwYWlycy5jb2xsaXNpb25TdGFydCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkVuZCA9IHBhaXJzLmNvbGxpc2lvbkVuZCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZSA9IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSxcbiAgICAgICAgICAgIGFjdGl2ZVBhaXJJZHMgPSBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIHBhaXJJZCxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGNsZWFyIGNvbGxpc2lvbiBzdGF0ZSBhcnJheXMsIGJ1dCBtYWludGFpbiBvbGQgcmVmZXJlbmNlXG4gICAgICAgIGNvbGxpc2lvblN0YXJ0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xuICAgICAgICBjb2xsaXNpb25BY3RpdmUubGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5jb2xsaWRlZCkge1xuICAgICAgICAgICAgICAgIHBhaXJJZCA9IFBhaXIuaWQoY29sbGlzaW9uLmJvZHlBLCBjb2xsaXNpb24uYm9keUIpO1xuICAgICAgICAgICAgICAgIGFjdGl2ZVBhaXJJZHMucHVzaChwYWlySWQpO1xuXG4gICAgICAgICAgICAgICAgcGFpciA9IHBhaXJzVGFibGVbcGFpcklkXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocGFpcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGFscmVhZHkgZXhpc3RzIChidXQgbWF5IG9yIG1heSBub3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFpciBleGlzdHMgYW5kIGlzIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGV4aXN0cyBidXQgd2FzIGluYWN0aXZlLCBzbyBhIGNvbGxpc2lvbiBoYXMganVzdCBzdGFydGVkIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25TdGFydC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIFBhaXIudXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWlyIGRpZCBub3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBwYWlyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSBQYWlyLmNyZWF0ZShjb2xsaXNpb24sIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzVGFibGVbcGFpcklkXSA9IHBhaXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgbmV3IHBhaXJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQucHVzaChwYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnNMaXN0LnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBwcmV2aW91c2x5IGFjdGl2ZSBwYWlycyB0aGF0IGFyZSBub3cgaW5hY3RpdmVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlICYmIENvbW1vbi5pbmRleE9mKGFjdGl2ZVBhaXJJZHMsIHBhaXIuaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIFBhaXIuc2V0QWN0aXZlKHBhaXIsIGZhbHNlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkVuZC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgcmVtb3ZlcyBwYWlycyB0aGF0IGhhdmUgYmVlbiBpbmFjdGl2ZSBmb3IgYSBzZXQgYW1vdW50IG9mIHRpbWUuXG4gICAgICogQG1ldGhvZCByZW1vdmVPbGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICovXG4gICAgUGFpcnMucmVtb3ZlT2xkID0gZnVuY3Rpb24ocGFpcnMsIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgcGFpcnNMaXN0ID0gcGFpcnMubGlzdCxcbiAgICAgICAgICAgIHBhaXJzVGFibGUgPSBwYWlycy50YWJsZSxcbiAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZSA9IFtdLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIHBhaXJJbmRleCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBuZXZlciByZW1vdmUgc2xlZXBpbmcgcGFpcnNcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUEuaXNTbGVlcGluZyB8fCBjb2xsaXNpb24uYm9keUIuaXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHBhaXIgaXMgaW5hY3RpdmUgZm9yIHRvbyBsb25nLCBtYXJrIGl0IHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgLSBwYWlyLnRpbWVVcGRhdGVkID4gX3BhaXJNYXhJZGxlTGlmZSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIG1hcmtlZCBwYWlyc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXhlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlySW5kZXggPSBpbmRleGVzVG9SZW1vdmVbaV0gLSBpO1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzTGlzdFtwYWlySW5kZXhdO1xuICAgICAgICAgICAgZGVsZXRlIHBhaXJzVGFibGVbcGFpci5pZF07XG4gICAgICAgICAgICBwYWlyc0xpc3Quc3BsaWNlKHBhaXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBnaXZlbiBwYWlycyBzdHJ1Y3R1cmUuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7cGFpcnN9IHBhaXJzXG4gICAgICogQHJldHVybiB7cGFpcnN9IHBhaXJzXG4gICAgICovXG4gICAgUGFpcnMuY2xlYXIgPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICBwYWlycy50YWJsZSA9IHt9O1xuICAgICAgICBwYWlycy5saXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhaXJzLmNvbGxpc2lvblN0YXJ0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xuICAgICAgICBwYWlycy5jb2xsaXNpb25FbmQubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb2xsaXNpb24vUGFpcnMuanMiLCIvKipcbiogVGhlIGBNYXR0ZXIuUmVzb2x2ZXJgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciByZXNvbHZpbmcgY29sbGlzaW9uIHBhaXJzLlxuKlxuKiBAY2xhc3MgUmVzb2x2ZXJcbiovXG5cbnZhciBSZXNvbHZlciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc29sdmVyO1xuXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoID0gNDtcbiAgICBSZXNvbHZlci5fcmVzdGluZ1RocmVzaFRhbmdlbnQgPSA2O1xuICAgIFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiA9IDAuOTtcbiAgICBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nID0gMC44O1xuICAgIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIgPSA1O1xuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBwYWlycyBmb3IgcG9zaXRpb24gc29sdmluZy5cbiAgICAgKiBAbWV0aG9kIHByZVNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcbiAgICAgKi9cbiAgICBSZXNvbHZlci5wcmVTb2x2ZVBvc2l0aW9uID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgYWN0aXZlQ291bnQ7XG5cbiAgICAgICAgLy8gZmluZCB0b3RhbCBjb250YWN0cyBvbiBlYWNoIGJvZHlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWN0aXZlQ291bnQgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEEudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEIudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgc29sdXRpb24gZm9yIHBhaXIgcG9zaXRpb25zLlxuICAgICAqIEBtZXRob2Qgc29sdmVQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU2NhbGVcbiAgICAgKi9cbiAgICBSZXNvbHZlci5zb2x2ZVBvc2l0aW9uID0gZnVuY3Rpb24ocGFpcnMsIHRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb2xsaXNpb24sXG4gICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgYm9keUJ0b0EsXG4gICAgICAgICAgICBjb250YWN0U2hhcmUsXG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UsXG4gICAgICAgICAgICBjb250YWN0Q291bnQgPSB7fSxcbiAgICAgICAgICAgIHRlbXBBID0gVmVjdG9yLl90ZW1wWzBdLFxuICAgICAgICAgICAgdGVtcEIgPSBWZWN0b3IuX3RlbXBbMV0sXG4gICAgICAgICAgICB0ZW1wQyA9IFZlY3Rvci5fdGVtcFsyXSxcbiAgICAgICAgICAgIHRlbXBEID0gVmVjdG9yLl90ZW1wWzNdO1xuXG4gICAgICAgIC8vIGZpbmQgaW1wdWxzZXMgcmVxdWlyZWQgdG8gcmVzb2x2ZSBwZW5ldHJhdGlvblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24ucGFyZW50QTtcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEI7XG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xuXG4gICAgICAgICAgICAvLyBnZXQgY3VycmVudCBzZXBhcmF0aW9uIGJldHdlZW4gYm9keSBlZGdlcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25cbiAgICAgICAgICAgIGJvZHlCdG9BID0gVmVjdG9yLnN1YihWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uSW1wdWxzZSwgYm9keUIucG9zaXRpb24sIHRlbXBBKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uSW1wdWxzZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnN1Yihib2R5Qi5wb3NpdGlvbiwgY29sbGlzaW9uLnBlbmV0cmF0aW9uLCB0ZW1wQiksIHRlbXBDKSwgdGVtcEQpO1xuXG4gICAgICAgICAgICBwYWlyLnNlcGFyYXRpb24gPSBWZWN0b3IuZG90KG5vcm1hbCwgYm9keUJ0b0EpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IgfHwgcGFpci5zZXBhcmF0aW9uIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgPSAocGFpci5zZXBhcmF0aW9uIC0gcGFpci5zbG9wKSAqIHRpbWVTY2FsZTtcblxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlCLmlzU3RhdGljKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSAqPSAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiAvIGJvZHlBLnRvdGFsQ29udGFjdHM7XG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25JbXB1bHNlLnggKz0gbm9ybWFsLnggKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25JbXB1bHNlLnkgKz0gbm9ybWFsLnkgKiBwb3NpdGlvbkltcHVsc2UgKiBjb250YWN0U2hhcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuIC8gYm9keUIudG90YWxDb250YWN0cztcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueCAtPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueSAtPSBub3JtYWwueSAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwb3NpdGlvbiByZXNvbHV0aW9uLlxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyByZXNldCBjb250YWN0IGNvdW50XG4gICAgICAgICAgICBib2R5LnRvdGFsQ29udGFjdHMgPSAwO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5wb3NpdGlvbkltcHVsc2UueCAhPT0gMCB8fCBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgYm9keS5wb3NpdGlvbkltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLng7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBib2R5LnBvc2l0aW9uSW1wdWxzZS55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGJvZHkgd2l0aG91dCBjaGFuZ2luZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gYm9keS5wb3NpdGlvbkltcHVsc2UueDtcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGJvZHkucG9zaXRpb25JbXB1bHNlLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yLmRvdChib2R5LnBvc2l0aW9uSW1wdWxzZSwgYm9keS52ZWxvY2l0eSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNhY2hlZCBpbXB1bHNlIGlmIHRoZSBib2R5IGhhcyB2ZWxvY2l0eSBhbG9uZyBpdFxuICAgICAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybSB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueCAqPSBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS55ICo9IFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgcGFpcnMgZm9yIHZlbG9jaXR5IHNvbHZpbmcuXG4gICAgICogQG1ldGhvZCBwcmVTb2x2ZVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucHJlU29sdmVWZWxvY2l0eSA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb250YWN0cyxcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICB0YW5nZW50LFxuICAgICAgICAgICAgY29udGFjdCxcbiAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXgsXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlLFxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjdG9yLl90ZW1wWzBdLFxuICAgICAgICAgICAgdGVtcEEgPSBWZWN0b3IuX3RlbXBbMV07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlIHx8IHBhaXIuaXNTZW5zb3IpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cztcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uO1xuICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24ucGFyZW50QTtcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEI7XG4gICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsO1xuICAgICAgICAgICAgdGFuZ2VudCA9IGNvbGxpc2lvbi50YW5nZW50O1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdCA9IGNvbnRhY3RzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnRhY3RWZXJ0ZXggPSBjb250YWN0LnZlcnRleDtcbiAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxJbXB1bHNlICE9PSAwIHx8IHRhbmdlbnRJbXB1bHNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdGFsIGltcHVsc2UgZnJvbSBjb250YWN0XG4gICAgICAgICAgICAgICAgICAgIGltcHVsc2UueCA9IChub3JtYWwueCAqIG5vcm1hbEltcHVsc2UpICsgKHRhbmdlbnQueCAqIHRhbmdlbnRJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gKG5vcm1hbC55ICogbm9ybWFsSW1wdWxzZSkgKyAodGFuZ2VudC55ICogdGFuZ2VudEltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFZlY3Rvci5zdWIoY29udGFjdFZlcnRleCwgYm9keUEucG9zaXRpb24sIHRlbXBBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2UueCAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnkgKz0gaW1wdWxzZS55ICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gVmVjdG9yLmNyb3NzKG9mZnNldCwgaW1wdWxzZSkgKiBib2R5QS5pbnZlcnNlSW5lcnRpYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBWZWN0b3Iuc3ViKGNvbnRhY3RWZXJ0ZXgsIGJvZHlCLnBvc2l0aW9uLCB0ZW1wQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueCAtPSBpbXB1bHNlLnggKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYW5nbGVQcmV2IC09IFZlY3Rvci5jcm9zcyhvZmZzZXQsIGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHNvbHV0aW9uIGZvciBwYWlyIHZlbG9jaXRpZXMuXG4gICAgICogQG1ldGhvZCBzb2x2ZVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxuICAgICAqL1xuICAgIFJlc29sdmVyLnNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycywgdGltZVNjYWxlKSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGVTcXVhcmVkID0gdGltZVNjYWxlICogdGltZVNjYWxlLFxuICAgICAgICAgICAgaW1wdWxzZSA9IFZlY3Rvci5fdGVtcFswXSxcbiAgICAgICAgICAgIHRlbXBBID0gVmVjdG9yLl90ZW1wWzFdLFxuICAgICAgICAgICAgdGVtcEIgPSBWZWN0b3IuX3RlbXBbMl0sXG4gICAgICAgICAgICB0ZW1wQyA9IFZlY3Rvci5fdGVtcFszXSxcbiAgICAgICAgICAgIHRlbXBEID0gVmVjdG9yLl90ZW1wWzRdLFxuICAgICAgICAgICAgdGVtcEUgPSBWZWN0b3IuX3RlbXBbNV07XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEEsXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QixcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsLFxuICAgICAgICAgICAgICAgIHRhbmdlbnQgPSBjb2xsaXNpb24udGFuZ2VudCxcbiAgICAgICAgICAgICAgICBjb250YWN0cyA9IHBhaXIuYWN0aXZlQ29udGFjdHMsXG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gMSAvIGNvbnRhY3RzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgdmVsb2NpdGllc1xuICAgICAgICAgICAgYm9keUEudmVsb2NpdHkueCA9IGJvZHlBLnBvc2l0aW9uLnggLSBib2R5QS5wb3NpdGlvblByZXYueDtcbiAgICAgICAgICAgIGJvZHlBLnZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XG4gICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS54ID0gYm9keUIucG9zaXRpb24ueCAtIGJvZHlCLnBvc2l0aW9uUHJldi54O1xuICAgICAgICAgICAgYm9keUIudmVsb2NpdHkueSA9IGJvZHlCLnBvc2l0aW9uLnkgLSBib2R5Qi5wb3NpdGlvblByZXYueTtcbiAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlBLmFuZ2xlIC0gYm9keUEuYW5nbGVQcmV2O1xuICAgICAgICAgICAgYm9keUIuYW5ndWxhclZlbG9jaXR5ID0gYm9keUIuYW5nbGUgLSBib2R5Qi5hbmdsZVByZXY7XG5cbiAgICAgICAgICAgIC8vIHJlc29sdmUgZWFjaCBjb250YWN0XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRhY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBjb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBID0gVmVjdG9yLnN1Yihjb250YWN0VmVydGV4LCBib2R5QS5wb3NpdGlvbiwgdGVtcEEpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCID0gVmVjdG9yLnN1Yihjb250YWN0VmVydGV4LCBib2R5Qi5wb3NpdGlvbiwgdGVtcEIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eVBvaW50QSA9IFZlY3Rvci5hZGQoYm9keUEudmVsb2NpdHksIFZlY3Rvci5tdWx0KFZlY3Rvci5wZXJwKG9mZnNldEEpLCBib2R5QS5hbmd1bGFyVmVsb2NpdHkpLCB0ZW1wQyksXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCID0gVmVjdG9yLmFkZChib2R5Qi52ZWxvY2l0eSwgVmVjdG9yLm11bHQoVmVjdG9yLnBlcnAob2Zmc2V0QiksIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSksIHRlbXBEKSwgXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKHZlbG9jaXR5UG9pbnRBLCB2ZWxvY2l0eVBvaW50QiwgdGVtcEUpLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxWZWxvY2l0eSA9IFZlY3Rvci5kb3Qobm9ybWFsLCByZWxhdGl2ZVZlbG9jaXR5KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50VmVsb2NpdHkgPSBWZWN0b3IuZG90KHRhbmdlbnQsIHJlbGF0aXZlVmVsb2NpdHkpLFxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50U3BlZWQgPSBNYXRoLmFicyh0YW5nZW50VmVsb2NpdHkpLFxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50VmVsb2NpdHlEaXJlY3Rpb24gPSBDb21tb24uc2lnbih0YW5nZW50VmVsb2NpdHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmF3IGltcHVsc2VzXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEltcHVsc2UgPSAoMSArIHBhaXIucmVzdGl0dXRpb24pICogbm9ybWFsVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEZvcmNlID0gQ29tbW9uLmNsYW1wKHBhaXIuc2VwYXJhdGlvbiArIG5vcm1hbFZlbG9jaXR5LCAwLCAxKSAqIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBjb3Vsb21iIGZyaWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHRhbmdlbnRJbXB1bHNlID0gdGFuZ2VudFZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICBtYXhGcmljdGlvbiA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRTcGVlZCA+IHBhaXIuZnJpY3Rpb24gKiBwYWlyLmZyaWN0aW9uU3RhdGljICogbm9ybWFsRm9yY2UgKiB0aW1lU2NhbGVTcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEZyaWN0aW9uID0gdGFuZ2VudFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IENvbW1vbi5jbGFtcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIuZnJpY3Rpb24gKiB0YW5nZW50VmVsb2NpdHlEaXJlY3Rpb24gKiB0aW1lU2NhbGVTcXVhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSBpbXB1bHNlcyBhY2NvdW50aW5nIGZvciBtYXNzLCBpbmVydGlhIGFuZCBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgb0FjTiA9IFZlY3Rvci5jcm9zcyhvZmZzZXRBLCBub3JtYWwpLFxuICAgICAgICAgICAgICAgICAgICBvQmNOID0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIG5vcm1hbCksXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlID0gY29udGFjdFNoYXJlIC8gKGJvZHlBLmludmVyc2VNYXNzICsgYm9keUIuaW52ZXJzZU1hc3MgKyBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIG9BY04gKiBvQWNOICArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JjTiAqIG9CY04pO1xuXG4gICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSAqPSBzaGFyZTtcbiAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSAqPSBzaGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxWZWxvY2l0eSA8IDAgJiYgbm9ybWFsVmVsb2NpdHkgKiBub3JtYWxWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoICogdGltZVNjYWxlU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWdoIG5vcm1hbCB2ZWxvY2l0eSBzbyBjbGVhciBjYWNoZWQgY29udGFjdCBub3JtYWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlIHJlc3RpbmcgY29sbGlzaW9uIGNvbnN0cmFpbnRzIHVzaW5nIEVyaW4gQ2F0dG8ncyBtZXRob2QgKEdEQzA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBpbXB1bHNlIGNvbnN0cmFpbnQgdGVuZHMgdG8gMFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3Qubm9ybWFsSW1wdWxzZSA9IE1hdGgubWluKGNvbnRhY3Qubm9ybWFsSW1wdWxzZSArIG5vcm1hbEltcHVsc2UsIDApO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlIC0gY29udGFjdE5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGhpZ2ggdmVsb2NpdHkgYW5kIHJlc3RpbmcgY29sbGlzaW9ucyBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRWZWxvY2l0eSAqIHRhbmdlbnRWZWxvY2l0eSA+IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCAqIHRpbWVTY2FsZVNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCB0YW5nZW50IHZlbG9jaXR5IHNvIGNsZWFyIGNhY2hlZCBjb250YWN0IHRhbmdlbnQgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZSByZXN0aW5nIGNvbGxpc2lvbiBjb25zdHJhaW50cyB1c2luZyBFcmluIENhdHRvJ3MgbWV0aG9kIChHREMwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBpbXB1bHNlIHRlbmRzIHRvIC10YW5nZW50U3BlZWQgb3IgK3RhbmdlbnRTcGVlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50SW1wdWxzZSA9IENvbW1vbi5jbGFtcChjb250YWN0LnRhbmdlbnRJbXB1bHNlICsgdGFuZ2VudEltcHVsc2UsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2UgLSBjb250YWN0VGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdG90YWwgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSAobm9ybWFsLnggKiBub3JtYWxJbXB1bHNlKSArICh0YW5nZW50LnggKiB0YW5nZW50SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gKG5vcm1hbC55ICogbm9ybWFsSW1wdWxzZSkgKyAodGFuZ2VudC55ICogdGFuZ2VudEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGltcHVsc2UgZnJvbSBjb250YWN0XG4gICAgICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggKz0gaW1wdWxzZS54ICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2UueSAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gVmVjdG9yLmNyb3NzKG9mZnNldEEsIGltcHVsc2UpICogYm9keUEuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZS54ICogYm9keUIuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2UueSAqIGJvZHlCLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5Qi5hbmdsZVByZXYgLT0gVmVjdG9yLmNyb3NzKG9mZnNldEIsIGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9SZXNvbHZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9SZXNvbHZlci5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5FbmdpbmVgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGVuZ2luZXMuXG4qIEFuIGVuZ2luZSBpcyBhIGNvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIHVwZGF0aW5nIHRoZSBzaW11bGF0aW9uIG9mIHRoZSB3b3JsZC5cbiogU2VlIGBNYXR0ZXIuUnVubmVyYCBmb3IgYW4gb3B0aW9uYWwgZ2FtZSBsb29wIHV0aWxpdHkuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBFbmdpbmVcbiovXG5cbnZhciBFbmdpbmUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmdpbmU7XG5cbnZhciBXb3JsZCA9IHJlcXVpcmUoJy4uL2JvZHkvV29ybGQnKTtcbnZhciBTbGVlcGluZyA9IHJlcXVpcmUoJy4vU2xlZXBpbmcnKTtcbnZhciBSZXNvbHZlciA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SZXNvbHZlcicpO1xudmFyIFJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcbnZhciBQYWlycyA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9QYWlycycpO1xudmFyIE1ldHJpY3MgPSByZXF1aXJlKCcuL01ldHJpY3MnKTtcbnZhciBHcmlkID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0dyaWQnKTtcbnZhciBFdmVudHMgPSByZXF1aXJlKCcuL0V2ZW50cycpO1xudmFyIENvbXBvc2l0ZSA9IHJlcXVpcmUoJy4uL2JvZHkvQ29tcG9zaXRlJyk7XG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGVuZ2luZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgRW5naW5lLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gb3B0aW9ucyBtYXkgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCAoYW5kIG9ubHkpIGFyZ3VtZW50XG4gICAgICAgIG9wdGlvbnMgPSBDb21tb24uaXNFbGVtZW50KGVsZW1lbnQpID8gb3B0aW9ucyA6IGVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQgPSBDb21tb24uaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChlbGVtZW50IHx8IG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignRW5naW5lLmNyZWF0ZTogZW5naW5lLnJlbmRlciBpcyBkZXByZWNhdGVkIChzZWUgZG9jcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uSXRlcmF0aW9uczogNixcbiAgICAgICAgICAgIHZlbG9jaXR5SXRlcmF0aW9uczogNCxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRJdGVyYXRpb25zOiAyLFxuICAgICAgICAgICAgZW5hYmxlU2xlZXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHBsdWdpbjoge30sXG4gICAgICAgICAgICB0aW1pbmc6IHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgICAgdGltZVNjYWxlOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnJvYWRwaGFzZToge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IEdyaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZW5naW5lID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgaWYgKGVsZW1lbnQgfHwgZW5naW5lLnJlbmRlcikge1xuICAgICAgICAgICAgdmFyIHJlbmRlckRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogUmVuZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyID0gQ29tbW9uLmV4dGVuZChyZW5kZXJEZWZhdWx0cywgZW5naW5lLnJlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAZGVwcmVjYXRlZFxuICAgICAgICBpZiAoZW5naW5lLnJlbmRlciAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIgPSBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIuY3JlYXRlKGVuZ2luZS5yZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAgICAgaWYgKGVuZ2luZS5yZW5kZXIpIHtcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5naW5lLndvcmxkID0gb3B0aW9ucy53b3JsZCB8fCBXb3JsZC5jcmVhdGUoZW5naW5lLndvcmxkKTtcbiAgICAgICAgZW5naW5lLnBhaXJzID0gUGFpcnMuY3JlYXRlKCk7XG4gICAgICAgIGVuZ2luZS5icm9hZHBoYXNlID0gZW5naW5lLmJyb2FkcGhhc2UuY29udHJvbGxlci5jcmVhdGUoZW5naW5lLmJyb2FkcGhhc2UpO1xuICAgICAgICBlbmdpbmUubWV0cmljcyA9IGVuZ2luZS5tZXRyaWNzIHx8IHsgZXh0ZW5kZWQ6IGZhbHNlIH07XG5cbiAgICAgICAgLy8gQGlmIERFQlVHXG4gICAgICAgIGVuZ2luZS5tZXRyaWNzID0gTWV0cmljcy5jcmVhdGUoZW5naW5lLm1ldHJpY3MpO1xuICAgICAgICAvLyBAZW5kaWZcblxuICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgc2ltdWxhdGlvbiBmb3J3YXJkIGluIHRpbWUgYnkgYGRlbHRhYCBtcy5cbiAgICAgKiBUaGUgYGNvcnJlY3Rpb25gIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIGNvcnJlY3Rpb24gZmFjdG9yIHRvIGFwcGx5IHRvIHRoZSB1cGRhdGUuXG4gICAgICogVGhpcyBjYW4gaGVscCBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiB0aGUgc2ltdWxhdGlvbiBpbiBjYXNlcyB3aGVyZSBgZGVsdGFgIGlzIGNoYW5naW5nIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgKiBUaGUgdmFsdWUgb2YgYGNvcnJlY3Rpb25gIGlzIGRlZmluZWQgYXMgYGRlbHRhIC8gbGFzdERlbHRhYCwgaS5lLiB0aGUgcGVyY2VudGFnZSBjaGFuZ2Ugb2YgYGRlbHRhYCBvdmVyIHRoZSBsYXN0IHN0ZXAuXG4gICAgICogVGhlcmVmb3JlIHRoZSB2YWx1ZSBpcyBhbHdheXMgYDFgIChubyBjb3JyZWN0aW9uKSB3aGVuIGBkZWx0YWAgY29uc3RhbnQgKG9yIHdoZW4gbm8gY29ycmVjdGlvbiBpcyBkZXNpcmVkLCB3aGljaCBpcyB0aGUgZGVmYXVsdCkuXG4gICAgICogU2VlIHRoZSBwYXBlciBvbiA8YSBocmVmPVwiaHR0cDovL2xvbmVzb2NrLm5ldC9hcnRpY2xlL3ZlcmxldC5odG1sXCI+VGltZSBDb3JyZWN0ZWQgVmVybGV0PC9hPiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVVcGRhdGVgIGFuZCBgYWZ0ZXJVcGRhdGVgIGV2ZW50cy5cbiAgICAgKiBUcmlnZ2VycyBgY29sbGlzaW9uU3RhcnRgLCBgY29sbGlzaW9uQWN0aXZlYCBhbmQgYGNvbGxpc2lvbkVuZGAgZXZlbnRzLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGE9MTYuNjY2XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29ycmVjdGlvbj0xXVxuICAgICAqL1xuICAgIEVuZ2luZS51cGRhdGUgPSBmdW5jdGlvbihlbmdpbmUsIGRlbHRhLCBjb3JyZWN0aW9uKSB7XG4gICAgICAgIGRlbHRhID0gZGVsdGEgfHwgMTAwMCAvIDYwO1xuICAgICAgICBjb3JyZWN0aW9uID0gY29ycmVjdGlvbiB8fCAxO1xuXG4gICAgICAgIHZhciB3b3JsZCA9IGVuZ2luZS53b3JsZCxcbiAgICAgICAgICAgIHRpbWluZyA9IGVuZ2luZS50aW1pbmcsXG4gICAgICAgICAgICBicm9hZHBoYXNlID0gZW5naW5lLmJyb2FkcGhhc2UsXG4gICAgICAgICAgICBicm9hZHBoYXNlUGFpcnMgPSBbXSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IHRpbWVzdGFtcFxuICAgICAgICB0aW1pbmcudGltZXN0YW1wICs9IGRlbHRhICogdGltaW5nLnRpbWVTY2FsZTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gZXZlbnQgb2JqZWN0XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcFxuICAgICAgICB9O1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2JlZm9yZVVwZGF0ZScsIGV2ZW50KTtcblxuICAgICAgICAvLyBnZXQgbGlzdHMgb2YgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMsIG5vIG1hdHRlciB3aGF0IGNvbXBvc2l0ZXMgdGhleSBhcmUgaW5cbiAgICAgICAgdmFyIGFsbEJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMod29ybGQpLFxuICAgICAgICAgICAgYWxsQ29uc3RyYWludHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMod29ybGQpO1xuXG4gICAgICAgIC8vIEBpZiBERUJVR1xuICAgICAgICAvLyByZXNldCBtZXRyaWNzIGxvZ2dpbmdcbiAgICAgICAgTWV0cmljcy5yZXNldChlbmdpbmUubWV0cmljcyk7XG4gICAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAgIC8vIGlmIHNsZWVwaW5nIGVuYWJsZWQsIGNhbGwgdGhlIHNsZWVwaW5nIGNvbnRyb2xsZXJcbiAgICAgICAgaWYgKGVuZ2luZS5lbmFibGVTbGVlcGluZylcbiAgICAgICAgICAgIFNsZWVwaW5nLnVwZGF0ZShhbGxCb2RpZXMsIHRpbWluZy50aW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIGFwcGxpZXMgZ3Jhdml0eSB0byBhbGwgYm9kaWVzXG4gICAgICAgIF9ib2RpZXNBcHBseUdyYXZpdHkoYWxsQm9kaWVzLCB3b3JsZC5ncmF2aXR5KTtcblxuICAgICAgICAvLyB1cGRhdGUgYWxsIGJvZHkgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGJ5IGludGVncmF0aW9uXG4gICAgICAgIF9ib2RpZXNVcGRhdGUoYWxsQm9kaWVzLCBkZWx0YSwgdGltaW5nLnRpbWVTY2FsZSwgY29ycmVjdGlvbiwgd29ybGQuYm91bmRzKTtcblxuICAgICAgICAvLyB1cGRhdGUgYWxsIGNvbnN0cmFpbnRzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUuY29uc3RyYWludEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgQ29uc3RyYWludC5zb2x2ZUFsbChhbGxDb25zdHJhaW50cywgdGltaW5nLnRpbWVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29uc3RyYWludC5wb3N0U29sdmVBbGwoYWxsQm9kaWVzKTtcblxuICAgICAgICAvLyBicm9hZHBoYXNlIHBhc3M6IGZpbmQgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlyc1xuICAgICAgICBpZiAoYnJvYWRwaGFzZS5jb250cm9sbGVyKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdvcmxkIGlzIGRpcnR5LCB3ZSBtdXN0IGZsdXNoIHRoZSB3aG9sZSBncmlkXG4gICAgICAgICAgICBpZiAod29ybGQuaXNNb2RpZmllZClcbiAgICAgICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIuY2xlYXIoYnJvYWRwaGFzZSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JpZCBidWNrZXRzIGJhc2VkIG9uIGN1cnJlbnQgYm9kaWVzXG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIudXBkYXRlKGJyb2FkcGhhc2UsIGFsbEJvZGllcywgZW5naW5lLCB3b3JsZC5pc01vZGlmaWVkKTtcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IGJyb2FkcGhhc2UucGFpcnNMaXN0O1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBpZiBubyBicm9hZHBoYXNlIHNldCwgd2UganVzdCBwYXNzIGFsbCBib2RpZXNcbiAgICAgICAgICAgIGJyb2FkcGhhc2VQYWlycyA9IGFsbEJvZGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBjb21wb3NpdGUgbW9kaWZpZWQgZmxhZ3NcbiAgICAgICAgaWYgKHdvcmxkLmlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCh3b3JsZCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5hcnJvd3BoYXNlIHBhc3M6IGZpbmQgYWN0dWFsIGNvbGxpc2lvbnMsIHRoZW4gY3JlYXRlIG9yIHVwZGF0ZSBjb2xsaXNpb24gcGFpcnNcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBicm9hZHBoYXNlLmRldGVjdG9yKGJyb2FkcGhhc2VQYWlycywgZW5naW5lKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXG4gICAgICAgIHZhciBwYWlycyA9IGVuZ2luZS5wYWlycyxcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWluZy50aW1lc3RhbXA7XG4gICAgICAgIFBhaXJzLnVwZGF0ZShwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKTtcbiAgICAgICAgUGFpcnMucmVtb3ZlT2xkKHBhaXJzLCB0aW1lc3RhbXApO1xuXG4gICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGludm9sdmVkIGluIGNvbGxpc2lvbnNcbiAgICAgICAgaWYgKGVuZ2luZS5lbmFibGVTbGVlcGluZylcbiAgICAgICAgICAgIFNsZWVwaW5nLmFmdGVyQ29sbGlzaW9ucyhwYWlycy5saXN0LCB0aW1pbmcudGltZVNjYWxlKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGNvbGxpc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvblN0YXJ0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25TdGFydCcsIHsgcGFpcnM6IHBhaXJzLmNvbGxpc2lvblN0YXJ0IH0pO1xuXG4gICAgICAgIC8vIGl0ZXJhdGl2ZWx5IHJlc29sdmUgcG9zaXRpb24gYmV0d2VlbiBjb2xsaXNpb25zXG4gICAgICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24ocGFpcnMubGlzdCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUucG9zaXRpb25JdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIFJlc29sdmVyLnNvbHZlUG9zaXRpb24ocGFpcnMubGlzdCwgdGltaW5nLnRpbWVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24oYWxsQm9kaWVzKTtcblxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHZlbG9jaXR5IGJldHdlZW4gY29sbGlzaW9uc1xuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5naW5lLnZlbG9jaXR5SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QsIHRpbWluZy50aW1lU2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjb2xsaXNpb24gZXZlbnRzXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25BY3RpdmUubGVuZ3RoID4gMClcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2NvbGxpc2lvbkFjdGl2ZScsIHsgcGFpcnM6IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSB9KTtcblxuICAgICAgICBpZiAocGFpcnMuY29sbGlzaW9uRW5kLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25FbmQnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25FbmQgfSk7XG5cbiAgICAgICAgLy8gQGlmIERFQlVHXG4gICAgICAgIC8vIHVwZGF0ZSBtZXRyaWNzIGxvZ1xuICAgICAgICBNZXRyaWNzLnVwZGF0ZShlbmdpbmUubWV0cmljcywgZW5naW5lKTtcbiAgICAgICAgLy8gQGVuZGlmXG5cbiAgICAgICAgLy8gY2xlYXIgZm9yY2UgYnVmZmVyc1xuICAgICAgICBfYm9kaWVzQ2xlYXJGb3JjZXMoYWxsQm9kaWVzKTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdhZnRlclVwZGF0ZScsIGV2ZW50KTtcblxuICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHR3byBlbmdpbmVzIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYGVuZ2luZUFgIGJ1dCByZXBsYWNpbmcgdGhlIHdvcmxkIHdpdGggdGhlIG9uZSBmcm9tIGBlbmdpbmVCYC5cbiAgICAgKiBAbWV0aG9kIG1lcmdlXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZUFcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQlxuICAgICAqL1xuICAgIEVuZ2luZS5tZXJnZSA9IGZ1bmN0aW9uKGVuZ2luZUEsIGVuZ2luZUIpIHtcbiAgICAgICAgQ29tbW9uLmV4dGVuZChlbmdpbmVBLCBlbmdpbmVCKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlbmdpbmVCLndvcmxkKSB7XG4gICAgICAgICAgICBlbmdpbmVBLndvcmxkID0gZW5naW5lQi53b3JsZDtcblxuICAgICAgICAgICAgRW5naW5lLmNsZWFyKGVuZ2luZUEpO1xuXG4gICAgICAgICAgICB2YXIgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhlbmdpbmVBLndvcmxkKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJvZHkuaWQgPSBDb21tb24ubmV4dElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBlbmdpbmUgaW5jbHVkaW5nIHRoZSB3b3JsZCwgcGFpcnMgYW5kIGJyb2FkcGhhc2UuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBFbmdpbmUuY2xlYXIgPSBmdW5jdGlvbihlbmdpbmUpIHtcbiAgICAgICAgdmFyIHdvcmxkID0gZW5naW5lLndvcmxkO1xuICAgICAgICBcbiAgICAgICAgUGFpcnMuY2xlYXIoZW5naW5lLnBhaXJzKTtcblxuICAgICAgICB2YXIgYnJvYWRwaGFzZSA9IGVuZ2luZS5icm9hZHBoYXNlO1xuICAgICAgICBpZiAoYnJvYWRwaGFzZS5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCk7XG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIuY2xlYXIoYnJvYWRwaGFzZSk7XG4gICAgICAgICAgICBicm9hZHBoYXNlLmNvbnRyb2xsZXIudXBkYXRlKGJyb2FkcGhhc2UsIGJvZGllcywgZW5naW5lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBaZXJvZXMgdGhlIGBib2R5LmZvcmNlYCBhbmQgYGJvZHkudG9ycXVlYCBmb3JjZSBidWZmZXJzLlxuICAgICAqIEBtZXRob2QgYm9kaWVzQ2xlYXJGb3JjZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICB2YXIgX2JvZGllc0NsZWFyRm9yY2VzID0gZnVuY3Rpb24oYm9kaWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgZm9yY2UgYnVmZmVyc1xuICAgICAgICAgICAgYm9keS5mb3JjZS54ID0gMDtcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueSA9IDA7XG4gICAgICAgICAgICBib2R5LnRvcnF1ZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHlzIGEgbWFzcyBkZXBlbmRhbnQgZm9yY2UgdG8gYWxsIGdpdmVuIGJvZGllcy5cbiAgICAgKiBAbWV0aG9kIGJvZGllc0FwcGx5R3Jhdml0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBncmF2aXR5XG4gICAgICovXG4gICAgdmFyIF9ib2RpZXNBcHBseUdyYXZpdHkgPSBmdW5jdGlvbihib2RpZXMsIGdyYXZpdHkpIHtcbiAgICAgICAgdmFyIGdyYXZpdHlTY2FsZSA9IHR5cGVvZiBncmF2aXR5LnNjYWxlICE9PSAndW5kZWZpbmVkJyA/IGdyYXZpdHkuc2NhbGUgOiAwLjAwMTtcblxuICAgICAgICBpZiAoKGdyYXZpdHkueCA9PT0gMCAmJiBncmF2aXR5LnkgPT09IDApIHx8IGdyYXZpdHlTY2FsZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LmlzU3RhdGljIHx8IGJvZHkuaXNTbGVlcGluZylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgZ3Jhdml0eVxuICAgICAgICAgICAgYm9keS5mb3JjZS55ICs9IGJvZHkubWFzcyAqIGdyYXZpdHkueSAqIGdyYXZpdHlTY2FsZTtcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueCArPSBib2R5Lm1hc3MgKiBncmF2aXR5LnggKiBncmF2aXR5U2NhbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbHlzIGBCb2R5LnVwZGF0ZWAgdG8gYWxsIGdpdmVuIGBib2RpZXNgLlxuICAgICAqIEBtZXRob2QgdXBkYXRlQWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSBcbiAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIHVwZGF0ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvcnJlY3Rpb24gXG4gICAgICogVGhlIFZlcmxldCBjb3JyZWN0aW9uIGZhY3RvciAoZGVsdGFUaW1lIC8gbGFzdERlbHRhVGltZSlcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gd29ybGRCb3VuZHNcbiAgICAgKi9cbiAgICB2YXIgX2JvZGllc1VwZGF0ZSA9IGZ1bmN0aW9uKGJvZGllcywgZGVsdGFUaW1lLCB0aW1lU2NhbGUsIGNvcnJlY3Rpb24sIHdvcmxkQm91bmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgYm9keS5pc1NsZWVwaW5nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBCb2R5LnVwZGF0ZShib2R5LCBkZWx0YVRpbWUsIHRpbWVTY2FsZSwgY29ycmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgZm9yIGBSdW5uZXIucnVuYCwgc2VlIGBNYXR0ZXIuUnVubmVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQganVzdCBiZWZvcmUgYW4gdXBkYXRlXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSBhbmQgYWxsIGNvbGxpc2lvbiBldmVudHNcbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB1cGRhdGUsIHByb3ZpZGVzIGEgbGlzdCBvZiBhbGwgcGFpcnMgdGhhdCBoYXZlIHN0YXJ0ZWQgdG8gY29sbGlkZSBpbiB0aGUgY3VycmVudCB0aWNrIChpZiBhbnkpXG4gICAgKlxuICAgICogQGV2ZW50IGNvbGxpc2lvblN0YXJ0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQucGFpcnMgTGlzdCBvZiBhZmZlY3RlZCBwYWlyc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGFyZSBjb2xsaWRpbmcgaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxuICAgICpcbiAgICAqIEBldmVudCBjb2xsaXNpb25BY3RpdmVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdXBkYXRlLCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhaXJzIHRoYXQgaGF2ZSBlbmRlZCBjb2xsaXNpb24gaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxuICAgICpcbiAgICAqIEBldmVudCBjb2xsaXNpb25FbmRcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcG9zaXRpb24gaXRlcmF0aW9ucyB0byBwZXJmb3JtIGVhY2ggdXBkYXRlLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHF1YWxpdHkgdGhlIHNpbXVsYXRpb24gd2lsbCBiZSBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvbkl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdmVsb2NpdHkgaXRlcmF0aW9ucyB0byBwZXJmb3JtIGVhY2ggdXBkYXRlLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgaGlnaGVyIHF1YWxpdHkgdGhlIHNpbXVsYXRpb24gd2lsbCBiZSBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eUl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgY29uc3RyYWludCBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAyYCBpcyB1c3VhbGx5IHZlcnkgYWRlcXVhdGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludEl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBhbGxvdyBzbGVlcGluZyB2aWEgdGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZS5cbiAgICAgKiBTbGVlcGluZyBjYW4gaW1wcm92ZSBzdGFiaWxpdHkgYW5kIHBlcmZvcm1hbmNlLCBidXQgb2Z0ZW4gYXQgdGhlIGV4cGVuc2Ugb2YgYWNjdXJhY3kuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlU2xlZXBpbmdcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgcHJvcGVydGllcyByZWdhcmRpbmcgdGhlIHRpbWluZyBzeXN0ZW1zIG9mIHRoZSBlbmdpbmUuIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbWluZ1xuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgZ2xvYmFsIHNjYWxpbmcgZmFjdG9yIG9mIHRpbWUgZm9yIGFsbCBib2RpZXMuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgZnJlZXplcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBBIHZhbHVlIG9mIGAwLjFgIGdpdmVzIGEgc2xvdy1tb3Rpb24gZWZmZWN0LlxuICAgICAqIEEgdmFsdWUgb2YgYDEuMmAgZ2l2ZXMgYSBzcGVlZC11cCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nLnRpbWVTY2FsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIGN1cnJlbnQgc2ltdWxhdGlvbi10aW1lIGluIG1pbGxpc2Vjb25kcyBzdGFydGluZyBmcm9tIGAwYC4gXG4gICAgICogSXQgaXMgaW5jcmVtZW50ZWQgb24gZXZlcnkgYEVuZ2luZS51cGRhdGVgIGJ5IHRoZSBnaXZlbiBgZGVsdGFgIGFyZ3VtZW50LiBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZXN0YW1wXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBgUmVuZGVyYCBjb250cm9sbGVyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGBNYXR0ZXIuUmVuZGVyYCBpbnN0YW5jZSBjcmVhdGVkIGJ5IGBFbmdpbmUuY3JlYXRlYC5cbiAgICAgKiBPbmUgbWF5IGFsc28gZGV2ZWxvcCBhIGN1c3RvbSByZW5kZXJlciBtb2R1bGUgYmFzZWQgb24gYE1hdHRlci5SZW5kZXJgIGFuZCBwYXNzIGFuIGluc3RhbmNlIG9mIGl0IHRvIGBFbmdpbmUuY3JlYXRlYCB2aWEgYG9wdGlvbnMucmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEEgbWluaW1hbCBjdXN0b20gcmVuZGVyZXIgb2JqZWN0IG11c3QgZGVmaW5lIGF0IGxlYXN0IHRocmVlIGZ1bmN0aW9uczogYGNyZWF0ZWAsIGBjbGVhcmAgYW5kIGB3b3JsZGAgKHNlZSBgTWF0dGVyLlJlbmRlcmApLlxuICAgICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gaW5zdGVhZCBwYXNzIHRoZSBfbW9kdWxlXyByZWZlcmVuY2UgdmlhIGBvcHRpb25zLnJlbmRlci5jb250cm9sbGVyYCBhbmQgYEVuZ2luZS5jcmVhdGVgIHdpbGwgaW5zdGFudGlhdGUgb25lIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyXG4gICAgICogQHR5cGUgcmVuZGVyXG4gICAgICogQGRlcHJlY2F0ZWQgc2VlIERlbW8uanMgZm9yIGFuIGV4YW1wbGUgb2YgY3JlYXRpbmcgYSByZW5kZXJlclxuICAgICAqIEBkZWZhdWx0IGEgTWF0dGVyLlJlbmRlciBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBicm9hZHBoYXNlIGNvbnRyb2xsZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgYE1hdHRlci5HcmlkYCBpbnN0YW5jZSBjcmVhdGVkIGJ5IGBFbmdpbmUuY3JlYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBicm9hZHBoYXNlXG4gICAgICogQHR5cGUgZ3JpZFxuICAgICAqIEBkZWZhdWx0IGEgTWF0dGVyLkdyaWQgaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFdvcmxkYCBjb21wb3NpdGUgb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIGFsbCBzaW11bGF0ZWQgYm9kaWVzIGFuZCBjb25zdHJhaW50cy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHdvcmxkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuV29ybGQgaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9FbmdpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL0VuZ2luZS5qcyIsIi8vIEBpZiBERUJVR1xuLyoqXG4qIF9JbnRlcm5hbCBDbGFzc18sIG5vdCBnZW5lcmFsbHkgdXNlZCBvdXRzaWRlIG9mIHRoZSBlbmdpbmUncyBpbnRlcm5hbHMuXG4qXG4qL1xuXG52YXIgTWV0cmljcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1ldHJpY3M7XG5cbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWV0cmljcy5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7bWV0cmljc30gQSBuZXcgbWV0cmljc1xuICAgICAqL1xuICAgIE1ldHJpY3MuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBleHRlbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBuYXJyb3dEZXRlY3Rpb25zOiAwLFxuICAgICAgICAgICAgbmFycm93cGhhc2VUZXN0czogMCxcbiAgICAgICAgICAgIG5hcnJvd1JldXNlOiAwLFxuICAgICAgICAgICAgbmFycm93UmV1c2VDb3VudDogMCxcbiAgICAgICAgICAgIG1pZHBoYXNlVGVzdHM6IDAsXG4gICAgICAgICAgICBicm9hZHBoYXNlVGVzdHM6IDAsXG4gICAgICAgICAgICBuYXJyb3dFZmY6IDAuMDAwMSxcbiAgICAgICAgICAgIG1pZEVmZjogMC4wMDAxLFxuICAgICAgICAgICAgYnJvYWRFZmY6IDAuMDAwMSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnM6IDAsXG4gICAgICAgICAgICBidWNrZXRzOiAwLFxuICAgICAgICAgICAgYm9kaWVzOiAwLFxuICAgICAgICAgICAgcGFpcnM6IDBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgZmFsc2UsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgbWV0cmljcy5cbiAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge21ldHJpY3N9IG1ldHJpY3NcbiAgICAgKi9cbiAgICBNZXRyaWNzLnJlc2V0ID0gZnVuY3Rpb24obWV0cmljcykge1xuICAgICAgICBpZiAobWV0cmljcy5leHRlbmRlZCkge1xuICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zID0gMDtcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyA9IDA7XG4gICAgICAgICAgICBtZXRyaWNzLm5hcnJvd1JldXNlID0gMDtcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93UmV1c2VDb3VudCA9IDA7XG4gICAgICAgICAgICBtZXRyaWNzLm1pZHBoYXNlVGVzdHMgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5icm9hZHBoYXNlVGVzdHMgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dFZmYgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5taWRFZmYgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5icm9hZEVmZiA9IDA7XG4gICAgICAgICAgICBtZXRyaWNzLmNvbGxpc2lvbnMgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5idWNrZXRzID0gMDtcbiAgICAgICAgICAgIG1ldHJpY3MucGFpcnMgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5ib2RpZXMgPSAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbWV0cmljcy5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHttZXRyaWNzfSBtZXRyaWNzXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqL1xuICAgIE1ldHJpY3MudXBkYXRlID0gZnVuY3Rpb24obWV0cmljcywgZW5naW5lKSB7XG4gICAgICAgIGlmIChtZXRyaWNzLmV4dGVuZGVkKSB7XG4gICAgICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCk7XG5cbiAgICAgICAgICAgIG1ldHJpY3MuY29sbGlzaW9ucyA9IG1ldHJpY3MubmFycm93RGV0ZWN0aW9ucztcbiAgICAgICAgICAgIG1ldHJpY3MucGFpcnMgPSBlbmdpbmUucGFpcnMubGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLmJvZGllcyA9IGJvZGllcy5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLm1pZEVmZiA9IChtZXRyaWNzLm5hcnJvd0RldGVjdGlvbnMgLyAobWV0cmljcy5taWRwaGFzZVRlc3RzIHx8IDEpKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgbWV0cmljcy5uYXJyb3dFZmYgPSAobWV0cmljcy5uYXJyb3dEZXRlY3Rpb25zIC8gKG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyB8fCAxKSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIG1ldHJpY3MuYnJvYWRFZmYgPSAoMSAtIChtZXRyaWNzLmJyb2FkcGhhc2VUZXN0cyAvIChib2RpZXMubGVuZ3RoIHx8IDEpKSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIG1ldHJpY3MubmFycm93UmV1c2UgPSAobWV0cmljcy5uYXJyb3dSZXVzZUNvdW50IC8gKG1ldHJpY3MubmFycm93cGhhc2VUZXN0cyB8fCAxKSkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgIC8vdmFyIGJyb2FkcGhhc2UgPSBlbmdpbmUuYnJvYWRwaGFzZVtlbmdpbmUuYnJvYWRwaGFzZS5jdXJyZW50XTtcbiAgICAgICAgICAgIC8vaWYgKGJyb2FkcGhhc2UuaW5zdGFuY2UpXG4gICAgICAgICAgICAvLyAgICBtZXRyaWNzLmJ1Y2tldHMgPSBDb21tb24ua2V5cyhicm9hZHBoYXNlLmluc3RhbmNlLmJ1Y2tldHMpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG4vLyBAZW5kaWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWV0cmljcy5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWV0cmljcy5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5QbHVnaW5gIG1vZHVsZSBjb250YWlucyBmdW5jdGlvbnMgZm9yIHJlZ2lzdGVyaW5nIGFuZCBpbnN0YWxsaW5nIHBsdWdpbnMgb24gbW9kdWxlcy5cbipcbiogQGNsYXNzIFBsdWdpblxuKi9cblxudmFyIFBsdWdpbiA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbjtcblxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIFBsdWdpbi5fcmVnaXN0cnkgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHBsdWdpbiBvYmplY3Qgc28gaXQgY2FuIGJlIHJlc29sdmVkIGxhdGVyIGJ5IG5hbWUuXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbiB0byByZWdpc3Rlci5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwbHVnaW4uXG4gICAgICovXG4gICAgUGx1Z2luLnJlZ2lzdGVyID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIGlmICghUGx1Z2luLmlzUGx1Z2luKHBsdWdpbikpIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdkb2VzIG5vdCBpbXBsZW1lbnQgYWxsIHJlcXVpcmVkIGZpZWxkcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbHVnaW4ubmFtZSBpbiBQbHVnaW4uX3JlZ2lzdHJ5KSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZCA9IFBsdWdpbi5fcmVnaXN0cnlbcGx1Z2luLm5hbWVdLFxuICAgICAgICAgICAgICAgIHBsdWdpblZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHBsdWdpbi52ZXJzaW9uKS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHJlZ2lzdGVyZWQudmVyc2lvbikubnVtYmVyO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luVmVyc2lvbiA+IHJlZ2lzdGVyZWRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocmVnaXN0ZXJlZCksICd3YXMgdXBncmFkZWQgdG8nLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpblZlcnNpb24gPCByZWdpc3RlcmVkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHJlZ2lzdGVyZWQpLCAnY2FuIG5vdCBiZSBkb3duZ3JhZGVkIHRvJywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gIT09IHJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnJlZ2lzdGVyOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvIGRpZmZlcmVudCBwbHVnaW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGEgZGVwZW5kZW5jeSB0byBhIHBsdWdpbiBvYmplY3QgZnJvbSB0aGUgcmVnaXN0cnkgaWYgaXQgZXhpc3RzLiBcbiAgICAgKiBUaGUgYGRlcGVuZGVuY3lgIG1heSBjb250YWluIGEgdmVyc2lvbiwgYnV0IG9ubHkgdGhlIG5hbWUgbWF0dGVycyB3aGVuIHJlc29sdmluZy5cbiAgICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gZGVwZW5kZW5jeSB7c3RyaW5nfSBUaGUgZGVwZW5kZW5jeS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwbHVnaW4gaWYgcmVzb2x2ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBQbHVnaW4ucmVzb2x2ZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5fcmVnaXN0cnlbUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KS5uYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBwcmludGVkIHBsdWdpbiBuYW1lIGFuZCB2ZXJzaW9uLlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBQcmV0dHkgcHJpbnRlZCBwbHVnaW4gbmFtZSBhbmQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBQbHVnaW4udG9TdHJpbmcgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gcGx1Z2luIDogKHBsdWdpbi5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICdAJyArIChwbHVnaW4udmVyc2lvbiB8fCBwbHVnaW4ucmFuZ2UgfHwgJzAuMC4wJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWVldHMgdGhlIG1pbmltdW0gc3RhbmRhcmQgdG8gYmUgY29uc2lkZXJlZCBhIHBsdWdpbi5cbiAgICAgKiBUaGlzIG1lYW5zIGl0IG11c3QgZGVmaW5lIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAtIGBuYW1lYFxuICAgICAqIC0gYHZlcnNpb25gXG4gICAgICogLSBgaW5zdGFsbGBcbiAgICAgKiBAbWV0aG9kIGlzUGx1Z2luXG4gICAgICogQHBhcmFtIG9iaiB7fSBUaGUgb2JqIHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgY2FuIGJlIGNvbnNpZGVyZWQgYSBwbHVnaW4gb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLmlzUGx1Z2luID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLm5hbWUgJiYgb2JqLnZlcnNpb24gJiYgb2JqLmluc3RhbGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYC5cbiAgICAgKiBAbWV0aG9kIGlzVXNlZFxuICAgICAqIEBwYXJhbSBtb2R1bGUge30gVGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgcGx1Z2luIG5hbWUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLmlzVXNlZCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnVzZWQuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgcGx1Z2luLmZvcmAgaXMgYXBwbGljYWJsZSB0byBgbW9kdWxlYCBieSBjb21wYXJpbmcgYWdhaW5zdCBgbW9kdWxlLm5hbWVgIGFuZCBgbW9kdWxlLnZlcnNpb25gLlxuICAgICAqIElmIGBwbHVnaW4uZm9yYCBpcyBub3Qgc3BlY2lmaWVkIHRoZW4gaXQgaXMgYXNzdW1lZCB0byBiZSBhcHBsaWNhYmxlLlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgcGx1Z2luLmZvcmAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXG4gICAgICogQG1ldGhvZCBpc0ZvclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbi5cbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGBwbHVnaW4uZm9yYCBpcyBhcHBsaWNhYmxlIHRvIGBtb2R1bGVgLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBQbHVnaW4uaXNGb3IgPSBmdW5jdGlvbihwbHVnaW4sIG1vZHVsZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGx1Z2luLmZvciAmJiBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKHBsdWdpbi5mb3IpO1xuICAgICAgICByZXR1cm4gIXBsdWdpbi5mb3IgfHwgKG1vZHVsZS5uYW1lID09PSBwYXJzZWQubmFtZSAmJiBQbHVnaW4udmVyc2lvblNhdGlzZmllcyhtb2R1bGUudmVyc2lvbiwgcGFyc2VkLnJhbmdlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGxzIHRoZSBwbHVnaW5zIGJ5IGNhbGxpbmcgYHBsdWdpbi5pbnN0YWxsYCBvbiBlYWNoIHBsdWdpbiBzcGVjaWZpZWQgaW4gYHBsdWdpbnNgIGlmIHBhc3NlZCwgb3RoZXJ3aXNlIGBtb2R1bGUudXNlc2AuXG4gICAgICogRm9yIGluc3RhbGxpbmcgcGx1Z2lucyBvbiBgTWF0dGVyYCBzZWUgdGhlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGBNYXR0ZXIudXNlYC5cbiAgICAgKiBQbHVnaW5zIG1heSBiZSBzcGVjaWZpZWQgZWl0aGVyIGJ5IHRoZWlyIG5hbWUgb3IgYSByZWZlcmVuY2UgdG8gdGhlIHBsdWdpbiBvYmplY3QuXG4gICAgICogUGx1Z2lucyB0aGVtc2VsdmVzIG1heSBzcGVjaWZ5IGZ1cnRoZXIgZGVwZW5kZW5jaWVzLCBidXQgZWFjaCBwbHVnaW4gaXMgaW5zdGFsbGVkIG9ubHkgb25jZS5cbiAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnQsIGEgdG9wb2xvZ2ljYWwgc29ydCBpcyBwZXJmb3JtZWQgdG8gZmluZCB0aGUgYmVzdCByZXN1bHRpbmcgb3JkZXIgb2YgaW5zdGFsbGF0aW9uLlxuICAgICAqIFRoaXMgc29ydGluZyBhdHRlbXB0cyB0byBzYXRpc2Z5IGV2ZXJ5IGRlcGVuZGVuY3kncyByZXF1ZXN0ZWQgb3JkZXJpbmcsIGJ1dCBtYXkgbm90IGJlIGV4YWN0IGluIGFsbCBjYXNlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGxvZ3MgdGhlIHJlc3VsdGluZyBzdGF0dXMgb2YgZWFjaCBkZXBlbmRlbmN5IGluIHRoZSBjb25zb2xlLCBhbG9uZyB3aXRoIGFueSB3YXJuaW5ncy5cbiAgICAgKiAtIEEgZ3JlZW4gdGljayDinIUgaW5kaWNhdGVzIGEgZGVwZW5kZW5jeSB3YXMgcmVzb2x2ZWQgYW5kIGluc3RhbGxlZC5cbiAgICAgKiAtIEFuIG9yYW5nZSBkaWFtb25kIPCflLYgaW5kaWNhdGVzIGEgZGVwZW5kZW5jeSB3YXMgcmVzb2x2ZWQgYnV0IGEgd2FybmluZyB3YXMgdGhyb3duIGZvciBpdCBvciBvbmUgaWYgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgKiAtIEEgcmVkIGNyb3NzIOKdjCBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IGNvdWxkIG5vdCBiZSByZXNvbHZlZC5cbiAgICAgKiBBdm9pZCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgbW9kdWxlIHVubGVzcyB5b3UgaW50ZW5kIHRvIG1hbnVhbGx5IGNvbnRyb2wgaW5zdGFsbGF0aW9uIG9yZGVyLlxuICAgICAqIEBtZXRob2QgdXNlXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlIGluc3RhbGwgcGx1Z2lucyBvbi5cbiAgICAgKiBAcGFyYW0gW3BsdWdpbnM9bW9kdWxlLnVzZXNdIHt9IFRoZSBwbHVnaW5zIHRvIGluc3RhbGwgb24gbW9kdWxlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gYG1vZHVsZS51c2VzYCkuXG4gICAgICovXG4gICAgUGx1Z2luLnVzZSA9IGZ1bmN0aW9uKG1vZHVsZSwgcGx1Z2lucykge1xuICAgICAgICBtb2R1bGUudXNlcyA9IChtb2R1bGUudXNlcyB8fCBbXSkuY29uY2F0KHBsdWdpbnMgfHwgW10pO1xuXG4gICAgICAgIGlmIChtb2R1bGUudXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udXNlOicsIFBsdWdpbi50b1N0cmluZyhtb2R1bGUpLCAnZG9lcyBub3Qgc3BlY2lmeSBhbnkgZGVwZW5kZW5jaWVzIHRvIGluc3RhbGwuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gUGx1Z2luLmRlcGVuZGVuY2llcyhtb2R1bGUpLFxuICAgICAgICAgICAgc29ydGVkRGVwZW5kZW5jaWVzID0gQ29tbW9uLnRvcG9sb2dpY2FsU29ydChkZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICAgc3RhdHVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChzb3J0ZWREZXBlbmRlbmNpZXNbaV0gPT09IG1vZHVsZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBQbHVnaW4ucmVzb2x2ZShzb3J0ZWREZXBlbmRlbmNpZXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5wdXNoKCfinYwgJyArIHNvcnRlZERlcGVuZGVuY2llc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChQbHVnaW4uaXNVc2VkKG1vZHVsZSwgcGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghUGx1Z2luLmlzRm9yKHBsdWdpbiwgbW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udXNlOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnaXMgZm9yJywgcGx1Z2luLmZvciwgJ2J1dCBpbnN0YWxsZWQgb24nLCBQbHVnaW4udG9TdHJpbmcobW9kdWxlKSArICcuJyk7XG4gICAgICAgICAgICAgICAgcGx1Z2luLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChtb2R1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2RvZXMgbm90IHNwZWNpZnkgYW4gaW5zdGFsbCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICBwbHVnaW4uX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4uX3dhcm5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5wdXNoKCfwn5S2ICcgKyBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5fd2FybmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn4pyFICcgKyBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZHVsZS51c2VkLnB1c2gocGx1Z2luLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBDb21tb24uaW5mbyhzdGF0dXMuam9pbignICAnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmluZHMgYWxsIG9mIGEgbW9kdWxlJ3MgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm5zIGEgZmxhdCBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAqL1xuICAgIFBsdWdpbi5kZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUsIHRyYWNrZWQpIHtcbiAgICAgICAgdmFyIHBhcnNlZEJhc2UgPSBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKG1vZHVsZSksXG4gICAgICAgICAgICBuYW1lID0gcGFyc2VkQmFzZS5uYW1lO1xuXG4gICAgICAgIHRyYWNrZWQgPSB0cmFja2VkIHx8IHt9O1xuXG4gICAgICAgIGlmIChuYW1lIGluIHRyYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZSA9IFBsdWdpbi5yZXNvbHZlKG1vZHVsZSkgfHwgbW9kdWxlO1xuXG4gICAgICAgIHRyYWNrZWRbbmFtZV0gPSBDb21tb24ubWFwKG1vZHVsZS51c2VzIHx8IFtdLCBmdW5jdGlvbihkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICBpZiAoUGx1Z2luLmlzUGx1Z2luKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgUGx1Z2luLnJlZ2lzdGVyKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KSxcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IFBsdWdpbi5yZXNvbHZlKGRlcGVuZGVuY3kpO1xuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgJiYgIVBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzKHJlc29sdmVkLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ1BsdWdpbi5kZXBlbmRlbmNpZXM6JywgUGx1Z2luLnRvU3RyaW5nKHJlc29sdmVkKSwgJ2RvZXMgbm90IHNhdGlzZnknLFxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkKSwgJ3VzZWQgYnknLCBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSkgKyAnLidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQuX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW9kdWxlLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ1BsdWdpbi5kZXBlbmRlbmNpZXM6JywgUGx1Z2luLnRvU3RyaW5nKGRlcGVuZGVuY3kpLCAndXNlZCBieScsXG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b1N0cmluZyhwYXJzZWRCYXNlKSwgJ2NvdWxkIG5vdCBiZSByZXNvbHZlZC4nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5uYW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrZWRbbmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFBsdWdpbi5kZXBlbmRlbmNpZXModHJhY2tlZFtuYW1lXVtpXSwgdHJhY2tlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhY2tlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgZGVwZW5kZW5jeSBzdHJpbmcgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICAgKiBUaGUgYGRlcGVuZGVuY3lgIGlzIGEgc3RyaW5nIG9mIHRoZSBmb3JtYXQgYCdtb2R1bGUtbmFtZSdgIG9yIGAnbW9kdWxlLW5hbWVAdmVyc2lvbidgLlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGhhbmRsZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgYWxyZWFkeSByZXNvbHZlZCAoZS5nLiBhIG1vZHVsZSBvYmplY3QpLlxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jeVBhcnNlXG4gICAgICogQHBhcmFtIGRlcGVuZGVuY3kge3N0cmluZ30gVGhlIGRlcGVuZGVuY3kgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZGVwZW5kZW5jeSBwYXJzZWQgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzU3RyaW5nKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IC9eW1xcdy1dKyhAKFxcKnxbXFxefl0/XFxkK1xcLlxcZCtcXC5cXGQrKC1bMC05QS1aYS16LV0rKT8pKT8kLztcblxuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLmRlcGVuZGVuY3lQYXJzZTonLCBkZXBlbmRlbmN5LCAnaXMgbm90IGEgdmFsaWQgZGVwZW5kZW5jeSBzdHJpbmcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzBdLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBkZXBlbmRlbmN5LnNwbGl0KCdAJylbMV0gfHwgJyonXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kubmFtZSxcbiAgICAgICAgICAgIHJhbmdlOiBkZXBlbmRlbmN5LnJhbmdlIHx8IGRlcGVuZGVuY3kudmVyc2lvblxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLiAgXG4gICAgICogVmVyc2lvbnMgYXJlIHN0cmljdGx5IG9mIHRoZSBmb3JtYXQgYHgueS56YCAoYXMgaW4gW3NlbXZlcl0oaHR0cDovL3NlbXZlci5vcmcvKSkuXG4gICAgICogVmVyc2lvbnMgbWF5IG9wdGlvbmFsbHkgaGF2ZSBhIHByZXJlbGVhc2UgdGFnIGluIHRoZSBmb3JtYXQgYHgueS56LWFscGhhYC5cbiAgICAgKiBSYW5nZXMgYXJlIGEgc3RyaWN0IHN1YnNldCBvZiBbbnBtIHJhbmdlc10oaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3NlbXZlciNhZHZhbmNlZC1yYW5nZS1zeW50YXgpLlxuICAgICAqIE9ubHkgdGhlIGZvbGxvd2luZyByYW5nZSB0eXBlcyBhcmUgc3VwcG9ydGVkOlxuICAgICAqIC0gVGlsZGUgcmFuZ2VzIGUuZy4gYH4xLjIuM2BcbiAgICAgKiAtIENhcmV0IHJhbmdlcyBlLmcuIGBeMS4yLjNgXG4gICAgICogLSBFeGFjdCB2ZXJzaW9uIGUuZy4gYDEuMi4zYFxuICAgICAqIC0gQW55IHZlcnNpb24gYCpgXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uUGFyc2VcbiAgICAgKiBAcGFyYW0gcmFuZ2Uge3N0cmluZ30gVGhlIHZlcnNpb24gc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHZlcnNpb24gcmFuZ2UgcGFyc2VkIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgUGx1Z2luLnZlcnNpb25QYXJzZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gL15cXCp8W1xcXn5dP1xcZCtcXC5cXGQrXFwuXFxkKygtWzAtOUEtWmEtei1dKyk/JC87XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QocmFuZ2UpKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnZlcnNpb25QYXJzZTonLCByYW5nZSwgJ2lzIG5vdCBhIHZhbGlkIHZlcnNpb24gb3IgcmFuZ2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSByYW5nZS5zcGxpdCgnLScpO1xuICAgICAgICByYW5nZSA9IGlkZW50aWZpZXJzWzBdO1xuXG4gICAgICAgIHZhciBpc1JhbmdlID0gaXNOYU4oTnVtYmVyKHJhbmdlWzBdKSksXG4gICAgICAgICAgICB2ZXJzaW9uID0gaXNSYW5nZSA/IHJhbmdlLnN1YnN0cigxKSA6IHJhbmdlLFxuICAgICAgICAgICAgcGFydHMgPSBDb21tb24ubWFwKHZlcnNpb24uc3BsaXQoJy4nKSwgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIocGFydCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNSYW5nZTogaXNSYW5nZSxcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBvcGVyYXRvcjogaXNSYW5nZSA/IHJhbmdlWzBdIDogJycsXG4gICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICBwcmVyZWxlYXNlOiBpZGVudGlmaWVyc1sxXSxcbiAgICAgICAgICAgIG51bWJlcjogcGFydHNbMF0gKiAxZTggKyBwYXJ0c1sxXSAqIDFlNCArIHBhcnRzWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGB2ZXJzaW9uYCBzYXRpc2ZpZXMgdGhlIGdpdmVuIGByYW5nZWAuXG4gICAgICogU2VlIGRvY3VtZW50YXRpb24gZm9yIGBQbHVnaW4udmVyc2lvblBhcnNlYCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZm9ybWF0LlxuICAgICAqIElmIGEgdmVyc2lvbiBvciByYW5nZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGFueSB2ZXJzaW9uIChgKmApIGlzIGFzc3VtZWQgdG8gc2F0aXNmeS5cbiAgICAgKiBAbWV0aG9kIHZlcnNpb25TYXRpc2ZpZXNcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHJhbmdlIHtzdHJpbmd9IFRoZSByYW5nZSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGB2ZXJzaW9uYCBzYXRpc2ZpZXMgYHJhbmdlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLnZlcnNpb25TYXRpc2ZpZXMgPSBmdW5jdGlvbih2ZXJzaW9uLCByYW5nZSkge1xuICAgICAgICByYW5nZSA9IHJhbmdlIHx8ICcqJztcblxuICAgICAgICB2YXIgcmFuZ2VQYXJzZWQgPSBQbHVnaW4udmVyc2lvblBhcnNlKHJhbmdlKSxcbiAgICAgICAgICAgIHJhbmdlUGFydHMgPSByYW5nZVBhcnNlZC5wYXJ0cyxcbiAgICAgICAgICAgIHZlcnNpb25QYXJzZWQgPSBQbHVnaW4udmVyc2lvblBhcnNlKHZlcnNpb24pLFxuICAgICAgICAgICAgdmVyc2lvblBhcnRzID0gdmVyc2lvblBhcnNlZC5wYXJ0cztcblxuICAgICAgICBpZiAocmFuZ2VQYXJzZWQuaXNSYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlUGFyc2VkLm9wZXJhdG9yID09PSAnKicgfHwgdmVyc2lvbiA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZVBhcnNlZC5vcGVyYXRvciA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25QYXJ0c1swXSA9PT0gcmFuZ2VQYXJ0c1swXSAmJiB2ZXJzaW9uUGFydHNbMV0gPT09IHJhbmdlUGFydHNbMV0gJiYgdmVyc2lvblBhcnRzWzJdID49IHJhbmdlUGFydHNbMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZVBhcnNlZC5vcGVyYXRvciA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUGFydHNbMF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uUGFydHNbMF0gPT09IHJhbmdlUGFydHNbMF0gJiYgdmVyc2lvblBhcnNlZC5udW1iZXIgPj0gcmFuZ2VQYXJzZWQubnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVBhcnRzWzFdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblBhcnRzWzFdID09PSByYW5nZVBhcnRzWzFdICYmIHZlcnNpb25QYXJ0c1syXSA+PSByYW5nZVBhcnRzWzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uUGFydHNbMl0gPT09IHJhbmdlUGFydHNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVyc2lvbiA9PT0gcmFuZ2UgfHwgdmVyc2lvbiA9PT0gJyonO1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb3JlL1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvUGx1Z2luLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXG4gICAgaXNTaW1wbGU6IHBvbHlnb25Jc1NpbXBsZSxcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5mdW5jdGlvbiBsaW5lSW50KGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKXtcblx0dmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGRhID0gcTJbMF0gLSBxMVswXTtcblx0dmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuXHQvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcblx0aWYoKGRhKmR5IC0gZGIqZHgpID09PSAwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XG5cdHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcblxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59XG5cbmZ1bmN0aW9uIGlzTGVmdChhLGIsYyl7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLGIsYykgPiAwO1xufVxuXG5mdW5jdGlvbiBpc0xlZnRPbihhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xufVxuXG5mdW5jdGlvbiBpc1JpZ2h0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XG59XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxZGlzdChhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSl7XG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNsZWFyKHBvbHlnb24pe1xuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFwcGVuZChwb2x5Z29uLCBwb2x5LCBmcm9tLCB0byl7XG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIE4gPSBwb2x5Z29uLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHBvbHlnb24ucG9wKCkpO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG5cdFx0cG9seWdvbltpXSA9IHRtcFtpXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpe1xuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XG59XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUocG9seWdvbiwgYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgYSk7XG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xuICAgICAgICAgICAgbDJbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpO1xuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Db3B5KHBvbHlnb24sIGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgW107XG4gICAgcG9seWdvbkNsZWFyKHApO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8cG9seWdvbi5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gW107XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5Z29uLCBpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25DYW5TZWUocG9seWdvbiwgaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wMSA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqLCB0bXBQb2x5KSk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkRlY29tcChwb2x5Z29uKXtcbiAgICB2YXIgZWRnZXMgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbik7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMCl7XG4gICAgICAgIHJldHVybiBwb2x5Z29uU2xpY2UocG9seWdvbiwgZWRnZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbcG9seWdvbl07XG4gICAgfVxufVxuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PT0gMCl7XG5cdFx0cmV0dXJuIFtwb2x5Z29uXTtcbiAgICB9XG4gICAgaWYoY3V0RWRnZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlcy5sZW5ndGggJiYgY3V0RWRnZXNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlc1swXS5sZW5ndGg9PT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHlnb25TbGljZShwb2x5LCBjdXRFZGdlKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcbiAgICAgICAgICAgICAgICAgICAgcG9seXMuc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzBdLHJlc3VsdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5cztcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFdhcyBnaXZlbiBvbmUgZWRnZVxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xuICAgICAgICB2YXIgaSA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzBdKTtcbiAgICAgICAgdmFyIGogPSBwb2x5Z29uLmluZGV4T2YoY3V0RWRnZVsxXSk7XG5cbiAgICAgICAgaWYoaSAhPT0gLTEgJiYgaiAhPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFtwb2x5Z29uQ29weShwb2x5Z29uLCBpLGopLFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQ29weShwb2x5Z29uLCBqLGkpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNTaW1wbGUocG9seWdvbil7XG4gICAgdmFyIHBhdGggPSBwb2x5Z29uLCBpO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFtpXSwgcGF0aFtpKzFdLCBwYXRoW2pdLCBwYXRoW2orMV0gKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIHNlZ21lbnQgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHBvaW50IHRvIGFsbCBvdGhlcnNcbiAgICBmb3IoaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKXtcblx0ZGVsdGEgPSBkZWx0YSB8fCAwO1xuXHR2YXIgYTEgPSBwMlsxXSAtIHAxWzFdO1xuXHR2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuXHR2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG5cdHZhciBhMiA9IHEyWzFdIC0gcTFbMV07XG5cdHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG5cdHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcblx0dmFyIGRldCA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuXHRpZighc2NhbGFyX2VxKGRldCwwLGRlbHRhKSl7XG5cdFx0cmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbMCwwXTtcbiAgICB9XG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUXVpY2tEZWNvbXAocG9seWdvbiwgcmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT09XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9W10sIHVwcGVyUG9seT1bXTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHBvbHlnb24sXG4gICAgICAgIHYgPSBwb2x5Z29uO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKXtcblx0XHRyZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5LCBpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwKSkgeyAvLyBtYWtlIHN1cmUgaXQncyBpbnNpZGUgdGhlIHBvbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09PSAodXBwZXJJbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcIik7XG4gICAgICAgICAgICAgICAgcFswXSA9IChsb3dlckludFswXSArIHVwcGVySW50WzBdKSAvIDI7XG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxsb3dlckluZGV4LHBvbHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksaSxwb2x5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LDAsdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5Lmxlbmd0aCA8IHVwcGVyUG9seS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xuICAgIHZhciBudW0gPSAwO1xuICAgIGZvcih2YXIgaT1wb2x5Z29uLmxlbmd0aC0xOyBwb2x5Z29uLmxlbmd0aD4zICYmIGk+PTA7IC0taSl7XG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSVwb2x5Z29uLmxlbmd0aCwxKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDwgcHJlY2lzaW9uO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9wb2x5LWRlY29tcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDcmVhdGVUZXh0dXJlMkRJbWFnZSA9IGZ1bmN0aW9uIChnbCwgcGl4ZWxzLCBmaWx0ZXIsIG1pcExldmVscylcbntcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBtaXBMZXZlbHMgPSBtaXBMZXZlbHMgfHwgMDtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyKTtcbiAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICBtaXBMZXZlbHMsXG4gICAgICAgIGdsLlJHQkEsXG4gICAgICAgIGdsLlJHQkEsXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHBpeGVsc1xuICAgICk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVRleHR1cmUyREltYWdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnREaXNwYXRjaGVyJyk7XG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSByZXF1aXJlKCcuL3N5c3RlbXMvR2FtZU9iamVjdEZhY3RvcnknKTtcbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9HYW1lT2JqZWN0Q3JlYXRvcicpO1xudmFyIFN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9TdGF0ZU1hbmFnZXInKTtcbnZhciBMb2FkZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvTG9hZGVyJyk7XG52YXIgVXBkYXRlTWFuYWdlciA9IHJlcXVpcmUoJy4vc3lzdGVtcy9VcGRhdGVNYW5hZ2VyJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cycpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9TZXR0aW5ncycpO1xudmFyIFJUcmVlID0gcmVxdWlyZSgnLi4vc3RydWN0cy9SVHJlZScpO1xudmFyIENhbWVyYU1hbmFnZXIgPSByZXF1aXJlKCcuL3N5c3RlbXMvQ2FtZXJhTWFuYWdlcicpO1xudmFyIFN0YWJsZVNvcnQgPSByZXF1aXJlKCcuLi91dGlscy9hcnJheS9TdGFibGVTb3J0Jyk7XG5cbnZhciBTeXN0ZW1zID0gZnVuY3Rpb24gKHN0YXRlLCBjb25maWcpXG57XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgdGhpcy5nYW1lID0gbnVsbDtcblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IFNldHRpbmdzLmNyZWF0ZShjb25maWcpO1xuXG4gICAgdGhpcy54ID0gdGhpcy5zZXR0aW5ncy54O1xuICAgIHRoaXMueSA9IHRoaXMuc2V0dGluZ3MueTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5zZXR0aW5ncy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuc2V0dGluZ3MuaGVpZ2h0O1xuXG4gICAgdGhpcy5tYXNrID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcztcbiAgICB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyAgQ09SRSBTWVNURU1TIC8gUFJPUEVSVElFU1xuXG4gICAgdGhpcy5jYWNoZTtcbiAgICB0aGlzLnRleHR1cmVzO1xuXG4gICAgLy8gIFJlZmVyZW5jZSB0byBTdGF0ZSBzcGVjaWZpYyBtYW5hZ2VycyAoRmFjdG9yeSwgVHdlZW5zLCBMb2FkZXIsIFBoeXNpY3MsIGV0YylcbiAgICB0aGlzLmFkZDtcbiAgICB0aGlzLm1ha2U7XG4gICAgdGhpcy5sb2FkO1xuICAgIHRoaXMuZXZlbnRzO1xuICAgIHRoaXMudXBkYXRlcztcbiAgICB0aGlzLnRyZWU7XG4gICAgdGhpcy5zdGF0ZU1hbmFnZXI7XG5cbiAgICAvLyAgU3RhdGUgcHJvcGVydGllc1xuICAgIHRoaXMuY2FtZXJhcztcbiAgICB0aGlzLmNoaWxkcmVuO1xuICAgIHRoaXMuY29sb3I7XG4gICAgdGhpcy5kYXRhO1xuICAgIC8vIHRoaXMuZmJvO1xuICAgIHRoaXMudGltZTtcbiAgICB0aGlzLnRyYW5zZm9ybTtcbn07XG5cblN5c3RlbXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3lzdGVtcztcblxuU3lzdGVtcy5wcm90b3R5cGUgPSB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoZ2FtZSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdGF0ZS5TeXN0ZW1zLmluaXQnKTtcblxuICAgICAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgICAgIFNldHRpbmdzLmluaXQodGhpcy5zZXR0aW5ncywgdGhpcy5nYW1lLmNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc2V0dGluZ3Mud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5zZXR0aW5ncy5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuZ2FtZS5jYWNoZTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRoaXMuZ2FtZS50ZXh0dXJlcztcblxuICAgICAgICAvLyAgU3RhdGUgc3BlY2lmaWMgbWFuYWdlcnMgKEZhY3RvcnksIFR3ZWVucywgTG9hZGVyLCBQaHlzaWNzLCBldGMpXG5cbiAgICAgICAgdGhpcy50cmVlID0gUlRyZWUoMTYpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5hZGQgPSBuZXcgR2FtZU9iamVjdEZhY3RvcnkodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMubWFrZSA9IG5ldyBHYW1lT2JqZWN0Q3JlYXRvcih0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGVzID0gbmV3IFVwZGF0ZU1hbmFnZXIodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMubG9hZCA9IG5ldyBMb2FkZXIodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFN0YXRlTWFuYWdlcih0aGlzLnN0YXRlLCBnYW1lKTtcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gbmV3IENhbWVyYU1hbmFnZXIodGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgLy8gIFN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXMgKHRyYW5zZm9ybSwgZGF0YSwgY2hpbGRyZW4sIGV0YylcblxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IENvbXBvbmVudC5DaGlsZHJlbih0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBDb21wb25lbnQuQ29sb3IodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBDb21wb25lbnQuRGF0YSh0aGlzLnN0YXRlKTtcblxuICAgICAgICB0aGlzLmluamVjdCgpO1xuICAgIH0sXG5cbiAgICBpbmplY3Q6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAgRGVmYXVsdHMgcHJvcGVydGllcyBpbmplY3RlZCBpbnRvIHRoZSBTdGF0ZVxuXG4gICAgICAgIHRoaXMuc3RhdGUuZ2FtZSA9IHRoaXMuZ2FtZTtcblxuICAgICAgICB0aGlzLnN0YXRlLmV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgICAgICB0aGlzLnN0YXRlLmFkZCA9IHRoaXMuYWRkO1xuICAgICAgICB0aGlzLnN0YXRlLmxvYWQgPSB0aGlzLmxvYWQ7XG4gICAgICAgIHRoaXMuc3RhdGUuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB0aGlzLnN0YXRlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgdGhpcy5zdGF0ZS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLnN0YXRlLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyO1xuICAgICAgICB0aGlzLnN0YXRlLmNhbWVyYXMgPSB0aGlzLmNhbWVyYXM7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5jYWNoZSA9IHRoaXMuZ2FtZS5jYWNoZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dCA9IHRoaXMuZ2FtZS5pbnB1dDtcbiAgICAgICAgdGhpcy5zdGF0ZS50ZXh0dXJlcyA9IHRoaXMuZ2FtZS50ZXh0dXJlcztcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0Q2hpbGRyZW5GbGFnID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vICBDYWxsZWQganVzdCBvbmNlIHBlciBmcmFtZSwgcmVnYXJkbGVzcyBvZiBzcGVlZFxuICAgIGJlZ2luOiBmdW5jdGlvbiAodGltZXN0YW1wLCBmcmFtZURlbHRhKVxuICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlLnNvcnRDaGlsZHJlbkZsYWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIFNvcnQgdGhlIGN1cnJlbnQgc3RhdGUgY2hpbGRyZW4gKi9cbiAgICAgICAgICAgIFN0YWJsZVNvcnQuaW5wbGFjZShzdGF0ZS5jaGlsZHJlbi5saXN0LCBmdW5jdGlvbiAoY2hpbGRBLCBjaGlsZEIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRBLl96IC0gY2hpbGRCLl96O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0Q2hpbGRyZW5GbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFBvdGVudGlhbGx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUgKG9uIHN1cGVyLWZhc3Qgc3lzdGVtcylcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICh0aW1lc3RlcCwgcGh5c2ljc1N0ZXApXG4gICAge1xuICAgICAgICB0aGlzLmNhbWVyYXMudXBkYXRlKHRpbWVzdGVwKTtcblxuICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZS5jYWxsKHRoaXMuc3RhdGUsIHRpbWVzdGVwLCBwaHlzaWNzU3RlcCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKGludGVycG9sYXRpb24sIHJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnZpc2libGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FtZXJhcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMuY2hpbGRyZW4sIGludGVycG9sYXRpb24pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1N5c3RlbXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9TeXN0ZW1zLmpzIiwiLy8gQSBTZXQgaXMgYSBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cblxudmFyIFNldCA9IGZ1bmN0aW9uIChlbGVtZW50cylcbntcbiAgICB0aGlzLmVudHJpZXMgPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cblNldC5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5W3Byb3BlcnR5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5lbnRyaWVzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkdW1wOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5ncm91cCgnU2V0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9LFxuXG5cbiAgICAvLyAgRm9yIHdoZW4geW91IGtub3cgdGhpcyBTZXQgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdGhlIGl0ZXJhdGlvblxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5lbnRyaWVzLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodGVtcFtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBGb3Igd2hlbiB5b3UgYWJzb2x1dGVseSBrbm93IHRoaXMgU2V0IHdvbid0IGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgaXRlcmF0aW9uXG4gICAgaXRlcmF0ZTogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh0aGlzLmVudHJpZXNbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjb250YWluczogZnVuY3Rpb24gKHZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVudHJpZXMuaW5kZXhPZih2YWx1ZSkgPiAtMSk7XG4gICAgfSxcblxuICAgIHVuaW9uOiBmdW5jdGlvbiAoc2V0KVxuICAgIHtcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICBzZXQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoc2V0KVxuICAgIHtcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICB0aGlzLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzZXQuY29udGFpbnModmFsdWUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH0sXG5cbiAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoc2V0KVxuICAgIHtcbiAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICB0aGlzLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2V0LmNvbnRhaW5zKHZhbHVlKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICB9XG5cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNldC5wcm90b3R5cGUsIHtcblxuICAgIHNpemU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RydWN0cy9TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xudmFyIFNldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWCcpO1xudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcblxudmFyIEluQm90dG9tQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCBHZXRDZW50ZXJYKGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbkJvdHRvbUNlbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0luQm90dG9tQ2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21DZW50ZXIuanMiLCJ2YXIgR2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRMZWZ0Jyk7XG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcblxudmFyIEluQm90dG9tTGVmdCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldExlZnQoZ2FtZU9iamVjdCwgR2V0TGVmdChjb250YWluZXIpIC0gb2Zmc2V0WCk7XG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldEJvdHRvbShjb250YWluZXIpICsgb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5Cb3R0b21MZWZ0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vSW5Cb3R0b21MZWZ0LmpzIiwidmFyIEdldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFJpZ2h0Jyk7XG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XG52YXIgU2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldEJvdHRvbScpO1xuXG52YXIgSW5Cb3R0b21SaWdodCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldFJpZ2h0KGdhbWVPYmplY3QsIEdldFJpZ2h0KGNvbnRhaW5lcikgKyBvZmZzZXRYKTtcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKGNvbnRhaW5lcikgKyBvZmZzZXRZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbkJvdHRvbVJpZ2h0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vSW5Cb3R0b21SaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luQm90dG9tUmlnaHQuanMiLCJ2YXIgR2V0Q2VudGVyWCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJYJyk7XG52YXIgR2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRDZW50ZXJZJyk7XG52YXIgQ2VudGVyT24gPSByZXF1aXJlKCcuLi9ib3VuZHMvQ2VudGVyT24nKTtcblxudmFyIEluQ2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgQ2VudGVyT24oZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChjb250YWluZXIpICsgb2Zmc2V0WCwgR2V0Q2VudGVyWShjb250YWluZXIpICsgb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5DZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JbkNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xuXG52YXIgSW5MZWZ0Q2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRMZWZ0KGNvbnRhaW5lcikgLSBvZmZzZXRYKTtcbiAgICBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIEdldENlbnRlclkoY29udGFpbmVyKSArIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluTGVmdENlbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0luTGVmdENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luTGVmdENlbnRlci5qcyIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xudmFyIEdldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWScpO1xudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XG52YXIgU2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRDZW50ZXJZJyk7XG5cbnZhciBJblJpZ2h0Q2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIGNvbnRhaW5lciwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0UmlnaHQoY29udGFpbmVyKSArIG9mZnNldFgpO1xuICAgIFNldENlbnRlclkoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWShjb250YWluZXIpICsgb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5SaWdodENlbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0luUmlnaHRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9JblJpZ2h0Q2VudGVyLmpzIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XG5cbnZhciBJblRvcENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBjb250YWluZXIsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldENlbnRlclgoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChjb250YWluZXIpICsgb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChjb250YWluZXIpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BDZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9JblRvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luVG9wQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XG5cbnZhciBJblRvcExlZnQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQoY29udGFpbmVyKSAtIG9mZnNldFgpO1xuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRUb3AoY29udGFpbmVyKSAtIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluVG9wTGVmdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0luVG9wTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL0luVG9wTGVmdC5qcyIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xudmFyIFNldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRUb3AnKTtcblxudmFyIEluVG9wUmlnaHQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChjb250YWluZXIpICsgb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChjb250YWluZXIpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5Ub3BSaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0luVG9wUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9JblRvcFJpZ2h0LmpzIiwidmFyIENPTlNUID0ge1xuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1sZWZ0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cbiAgICAqIEBjb25zdGFudFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICBUT1BfTEVGVDogMCxcblxuICAgIC8qKlxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSB0b3AtY2VudGVyIGFsaWdubWVudCBvciBwb3NpdGlvbi5cbiAgICAqIEBjb25zdGFudFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICBUT1BfQ0VOVEVSOiAxLFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHRvcC1yaWdodCBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgVE9QX1JJR0hUOiAyLFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGxlZnQtdG9wIGFsaWdubWVudCBvciBwb3NpdGlvbi5cbiAgICAqIEBjb25zdGFudFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICBMRUZUX1RPUDogMyxcblxuICAgIC8qKlxuICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgYSBsZWZ0LWNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgTEVGVF9DRU5URVI6IDQsXG5cbiAgICAvKipcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgbGVmdC1ib3R0b20gYWxpZ25tZW50IG9yIHBvc2l0aW9uLlxuICAgICogQGNvbnN0YW50XG4gICAgKiBAdHlwZSB7aW50ZWdlcn1cbiAgICAqL1xuICAgIExFRlRfQk9UVE9NOiA1LFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgQ0VOVEVSOiA2LFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHJpZ2h0LXRvcCBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgUklHSFRfVE9QOiA3LFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHJpZ2h0LWNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgUklHSFRfQ0VOVEVSOiA4LFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIHJpZ2h0LWJvdHRvbSBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgUklHSFRfQk9UVE9NOiA5LFxuXG4gICAgLyoqXG4gICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBhIGJvdHRvbS1sZWZ0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cbiAgICAqIEBjb25zdGFudFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICBCT1RUT01fTEVGVDogMTAsXG5cbiAgICAvKipcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLWNlbnRlciBhbGlnbm1lbnQgb3IgcG9zaXRpb24uXG4gICAgKiBAY29uc3RhbnRcbiAgICAqIEB0eXBlIHtpbnRlZ2VyfVxuICAgICovXG4gICAgQk9UVE9NX0NFTlRFUjogMTEsXG5cbiAgICAvKipcbiAgICAqIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGEgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBvciBwb3NpdGlvbi5cbiAgICAqIEBjb25zdGFudFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICBCT1RUT01fUklHSFQ6IDEyXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBDcmVhdGUgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBvZiBudW1iZXJzICh1c3VhbGx5IGludGVnZXJzKSwgYmV0d2VlbiwgYW5kIGluY2x1c2l2ZSBvZixcbiogdGhlIGdpdmVuIGBzdGFydGAgYW5kIGBlbmRgIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGU6XG4qXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgyLCA0KTsgLy8gYXJyYXkgPSBbMiwgMywgNF1gXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSgwLCA5KTsgLy8gYXJyYXkgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1gXG4qIFxuKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYG51bWJlckFycmF5U3RlcChzdGFydCwgZW5kLCAxKWAuXG4qIFxuKiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIHByZWZpeCBhbmQgLyBvciBzdWZmaXggc3RyaW5nLiBJZiBnaXZlbiB0aGUgYXJyYXkgd2lsbCBjb250YWluXG4qIHN0cmluZ3MsIG5vdCBpbnRlZ2Vycy4gRm9yIGV4YW1wbGU6XG4qIFxuKiBgdmFyIGFycmF5ID0gbnVtYmVyQXJyYXkoMSwgNCwgJ0xldmVsICcpOyAvLyBhcnJheSA9IFtcIkxldmVsIDFcIiwgXCJMZXZlbCAyXCIsIFwiTGV2ZWwgM1wiLCBcIkxldmVsIDRcIl1gXG4qIGB2YXIgYXJyYXkgPSBudW1iZXJBcnJheSg1LCA3LCAnSEQtJywgJy5wbmcnKTsgLy8gYXJyYXkgPSBbXCJIRC01LnBuZ1wiLCBcIkhELTYucG5nXCIsIFwiSEQtNy5wbmdcIl1gXG4qXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMjbnVtYmVyQXJyYXlcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGFycmF5IHN0YXJ0cyB3aXRoLlxuKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gVGhlIG1heGltdW0gdmFsdWUgdGhlIGFycmF5IGNvbnRhaW5zLlxuKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gLSBPcHRpb25hbCBwcmVmaXggdG8gcGxhY2UgYmVmb3JlIHRoZSBudW1iZXIuIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gc3RyaW5ncywgbm90IGludGVnZXJzLlxuKiBAcGFyYW0ge3N0cmluZ30gW3N1ZmZpeF0gLSBPcHRpb25hbCBzdWZmaXggdG8gcGxhY2UgYWZ0ZXIgdGhlIG51bWJlci4gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgY29udGFpbiBzdHJpbmdzLCBub3QgaW50ZWdlcnMuXG4qIEByZXR1cm4ge251bWJlcltdfHN0cmluZ1tdfSBUaGUgYXJyYXkgb2YgbnVtYmVyIHZhbHVlcywgb3Igc3RyaW5ncyBpZiBhIHByZWZpeCBvciBzdWZmaXggd2FzIHByb3ZpZGVkLlxuKi9cbnZhciBOdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmVmaXgsIHN1ZmZpeClcbntcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspXG4gICAge1xuICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGtleSA9IChwcmVmaXgpID8gcHJlZml4ICsgaS50b1N0cmluZygpIDogaS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoc3VmZml4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleS5jb25jYXQoc3VmZml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9OdW1iZXJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGlzIGlzIGZyb20gdGhlIHF1aWNrc2VsZWN0IG5wbSBwYWNrYWdlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9xdWlja3NlbGVjdFxuLy8gIENvZGVkIGJ5IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9+bW91cm5lciAoVmxhZGltaXIgQWdhZm9ua2luKVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZCVFMiU4MCU5M1JpdmVzdF9hbGdvcml0aG1cblxuLy8gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06XG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xuLy8gVGhlIGstdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIChrIC0gbGVmdCArIDEpdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XVxuXG52YXIgUXVpY2tTZWxlY3QgPSBmdW5jdGlvbiAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSlcbntcbiAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcbiAgICBjb21wYXJlID0gY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpXG4gICAge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcblxuICAgICAgICAgICAgUXVpY2tTZWxlY3QoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaSA8IGopXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcblxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZWZ0ID0gaiArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoayA8PSBqKVxuICAgICAgICB7XG4gICAgICAgICAgICByaWdodCA9IGogLSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3dhcCAoYXJyLCBpLCBqKVxue1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUgKGEsIGIpXG57XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1aWNrU2VsZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUXVpY2tTZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2h1ZmZsZSA9IHJlcXVpcmUoJy4vU2h1ZmZsZScpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XG5cbnZhciBCdWlsZENodW5rID0gZnVuY3Rpb24gKGEsIGIsIHF0eSlcbntcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmb3IgKHZhciBhSW5kZXggPSAwOyBhSW5kZXggPCBhLmxlbmd0aDsgYUluZGV4KyspXG4gICAge1xuICAgICAgICBmb3IgKHZhciBiSW5kZXggPSAwOyBiSW5kZXggPCBiLmxlbmd0aDsgYkluZGV4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXR5OyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBhOiBhW2FJbmRleF0sIGI6IGJbYkluZGV4XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vLyAgb3B0aW9ucyA9IHJlcGVhdCwgcmFuZG9tLCByYW5kb21CLCB5b3lvLCBtYXgsIHF0eVxuXG4vLyAgUmFuZ2UgKFthLGIsY10sIFsxLDIsM10pID1cbi8vICBhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBjMSwgYzIsIGMzXG5cbi8vICBSYW5nZSAoW2EsYl0sIFsxLDIsM10sIHF0eSA9IDMpID1cbi8vICBhMSwgYTEsIGExLCBhMiwgYTIsIGEyLCBhMywgYTMsIGEzLCBiMSwgYjEsIGIxLCBiMiwgYjIsIGIyLCBiMywgYjMsIGIzXG5cbi8vICBSYW5nZSAoW2EsYixjXSwgWzEsMiwzXSwgcmVwZWF0IHgxKSA9XG4vLyAgYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjMywgYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjM1xuXG4vLyAgUmFuZ2UgKFthLGJdLCBbMSwyXSwgcmVwZWF0IC0xID0gZW5kbGVzcywgbWF4ID0gMTQpID1cbi8vICBNYXliZSBpZiBtYXggaXMgc2V0IHRoZW4gcmVwZWF0IGdvZXMgdG8gLTEgYXV0b21hdGljYWxseT9cbi8vICBhMSwgYTIsIGIxLCBiMiwgYTEsIGEyLCBiMSwgYjIsIGExLCBhMiwgYjEsIGIyLCBhMSwgYTIgKGNhcHBlZCBhdCAxNCBlbGVtZW50cylcblxuLy8gIFJhbmdlIChbYV0sIFsxLDIsMyw0LDVdLCByYW5kb20gPSB0cnVlKSA9XG4vLyAgYTQsIGExLCBhNSwgYTIsIGEzXG5cbi8vICBSYW5nZSAoW2EsIGJdLCBbMSwyLDNdLCByYW5kb20gPSB0cnVlKSA9XG4vLyAgYjMsIGEyLCBhMSwgYjEsIGEzLCBiMlxuXG4vLyAgUmFuZ2UgKFthLCBiLCBjXSwgWzEsMiwzXSwgcmFuZG9tQiA9IHRydWUpID1cbi8vICBhMywgYTEsIGEyLCBiMiwgYjMsIGIxLCBjMSwgYzMsIGMyXG5cbi8vICBSYW5nZSAoW2FdLCBbMSwyLDMsNCw1XSwgeW95byA9IHRydWUpID1cbi8vICBhMSwgYTIsIGEzLCBhNCwgYTUsIGE1LCBhNCwgYTMsIGEyLCBhMVxuXG4vLyAgUmFuZ2UgKFthLCBiXSwgWzEsMiwzXSwgeW95byA9IHRydWUpID1cbi8vICBhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBiMywgYjIsIGIxLCBhMywgYTIsIGExXG5cbnZhciBSYW5nZSA9IGZ1bmN0aW9uIChhLCBiLCBvcHRpb25zKVxue1xuICAgIHZhciBtYXggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnbWF4JywgMCk7XG4gICAgdmFyIHF0eSA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdxdHknLCAxKTtcbiAgICB2YXIgcmFuZG9tID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3JhbmRvbScsIGZhbHNlKTtcbiAgICB2YXIgcmFuZG9tQiA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdyYW5kb21CJywgZmFsc2UpO1xuICAgIHZhciByZXBlYXQgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAncmVwZWF0JywgMCk7XG4gICAgdmFyIHlveW8gPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAneW95bycsIGZhbHNlKTtcblxuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIGlmIChyYW5kb21CKVxuICAgIHtcbiAgICAgICAgU2h1ZmZsZShiKTtcbiAgICB9XG5cbiAgICAvLyAgRW5kbGVzcyByZXBlYXQsIHNvIGxpbWl0IGJ5IG1heFxuICAgIGlmIChyZXBlYXQgPT09IC0xKVxuICAgIHtcbiAgICAgICAgaWYgKG1heCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVwZWF0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBXb3JrIG91dCBob3cgbWFueSByZXBlYXRzIHdlIG5lZWRcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IChhLmxlbmd0aCAqIGIubGVuZ3RoKSAqIHF0eTtcblxuICAgICAgICAgICAgaWYgKHlveW8pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG90YWwgKj0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwZWF0ID0gTWF0aC5jZWlsKG1heCAvIHRvdGFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlcGVhdDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNodW5rID0gQnVpbGRDaHVuayhhLCBiLCBxdHkpO1xuXG4gICAgICAgIGlmIChyYW5kb20pXG4gICAgICAgIHtcbiAgICAgICAgICAgIFNodWZmbGUoY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChjaHVuayk7XG5cbiAgICAgICAgaWYgKHlveW8pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNodW5rLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4KVxuICAgIHtcbiAgICAgICAgb3V0LnNwbGljZShtYXgpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUmFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hcnJheS9SYW5nZS5qcyIsIi8qKlxuKiBNb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGFycmF5IHRvIHRoZSBlbmQsIHNoaWZ0aW5nIGFsbCBpdGVtcyBpbiB0aGUgcHJvY2Vzcy5cbiogVGhlIFwicm90YXRpb25cIiBoYXBwZW5zIHRvIHRoZSBsZWZ0LlxuKlxuKiBAbWV0aG9kIFBoYXNlci5BcnJheVV0aWxzLnJvdGF0ZVxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4qIEByZXR1cm4ge2FueX0gVGhlIHNoaWZ0ZWQgdmFsdWUuXG4qL1xudmFyIFJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoYXJyYXksIHRvdGFsKVxue1xuICAgIGlmICh0b3RhbCA9PT0gdW5kZWZpbmVkKSB7IHRvdGFsID0gMTsgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgZWxlbWVudCA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUxlZnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9Sb3RhdGVMZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIE1vdmVzIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIHRoZSBzdGFydCwgc2hpZnRpbmcgYWxsIGl0ZW1zIGluIHRoZSBwcm9jZXNzLlxuKiBUaGUgXCJyb3RhdGlvblwiIGhhcHBlbnMgdG8gdGhlIHJpZ2h0LlxuKlxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaGlmdC9yb3RhdGUuIFRoZSBhcnJheSBpcyBtb2RpZmllZC5cbiogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWw9MV0gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHNoaWZ0IHRoZSBhcnJheS4gT25seSB0aGUgbW9zdCByZWNlbnRseSBzaGlmdGVkIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4qIEByZXR1cm4ge2FueX0gVGhlIHNoaWZ0ZWQgdmFsdWUuXG4qL1xudmFyIFJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKGFycmF5LCB0b3RhbClcbntcbiAgICBpZiAodG90YWwgPT09IHVuZGVmaW5lZCkgeyB0b3RhbCA9IDE7IH1cblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG4gICAgICAgIGVsZW1lbnQgPSBhcnJheS5wb3AoKTtcbiAgICAgICAgYXJyYXkudW5zaGlmdChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlUmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9Sb3RhdGVSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBBIHN0YW5kYXJkIEZpc2hlci1ZYXRlcyBBcnJheSBzaHVmZmxlIGltcGxlbWVudGF0aW9uIHdoaWNoIG1vZGlmaWVzIHRoZSBhcnJheSBpbiBwbGFjZS5cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge2FueVtdfSBhcnJheSAtIFRoZSBhcnJheSB0byBzaHVmZmxlLlxuKiBAcmV0dXJuIHthbnlbXX0gVGhlIG9yaWdpbmFsIGFycmF5LCBub3cgc2h1ZmZsZWQuXG4qL1xudmFyIFNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpXG57XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXG4gICAge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaHVmZmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvU2h1ZmZsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBSZW1vdmVzIGEgc2luZ2xlIGl0ZW0gZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyBpdFxuLy8gIHdpdGhvdXQgY3JlYXRpbmcgZ2MgKGxpa2UgdGhlIG5hdGl2ZSBzcGxpY2UgZG9lcylcbi8vICBCYXNlZCBvbiBjb2RlIGJ5IE1pa2UgUmVpbnN0ZWluXG5cbnZhciBTcGxpY2VPbmUgPSBmdW5jdGlvbiAoYXJyYXksIGluZGV4KVxue1xuICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgaXRlbSA9IGFycmF5W2luZGV4XTtcblxuICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgfVxuXG4gICAgYXJyYXkubGVuZ3RoID0gbGVuO1xuXG4gICAgcmV0dXJuIGl0ZW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwbGljZU9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L1NwbGljZU9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi9TZXRDZW50ZXJYJyk7XG52YXIgU2V0Q2VudGVyWSA9IHJlcXVpcmUoJy4vU2V0Q2VudGVyWScpO1xuXG4vKipcbiogVGhlIGNlbnRlciB4IGNvb3JkaW5hdGUgb2YgdGhlIEdhbWUgT2JqZWN0LlxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGAoeCAtIG9mZnNldFgpICsgKHdpZHRoIC8gMilgLlxuKlxuKiBAcHJvcGVydHkge251bWJlcn0gY2VudGVyWFxuKi9cblxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHgsIHkpXG57XG4gICAgU2V0Q2VudGVyWChnYW1lT2JqZWN0LCB4KTtcblxuICAgIHJldHVybiBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIHkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9DZW50ZXJPbi5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2JvdW5kcy9DZW50ZXJPbi5qcyIsIi8qKlxuKiBUaGlzIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkuaXNQbGFpbk9iamVjdC5cbiogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdob3NlIGludGVybmFsIGNsYXNzIHByb3BlcnR5IGlzIFtvYmplY3QgT2JqZWN0XS5cbiogQG1ldGhvZCBQaGFzZXIuVXRpbHMuaXNQbGFpbk9iamVjdFxuKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCBpcyBwbGFpbiwgb3RoZXJ3aXNlIGZhbHNlLlxuKi9cbnZhciBJc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKG9iailcbntcbiAgICAvLyBOb3QgcGxhaW4gb2JqZWN0czpcbiAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgLy8gLSBET00gbm9kZXNcbiAgICAvLyAtIHdpbmRvd1xuICAgIGlmICh0eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgb2JqID09PSBvYmoud2luZG93KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPDIwXG4gICAgLy8gVGhlIHRyeS9jYXRjaCBzdXBwcmVzc2VzIGV4Y2VwdGlvbnMgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhY2Nlc3NcbiAgICAvLyB0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IG9mIGNlcnRhaW4gaG9zdCBvYmplY3RzLCBpZS4gfHdpbmRvdy5sb2NhdGlvbnxcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04MTQ2MjJcbiAgICB0cnkge1xuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICEoe30pLmhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9vYmplY3QvSXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDb25maWcgPSByZXF1aXJlKCcuL0NvbmZpZycpO1xudmFyIERlYnVnSGVhZGVyID0gcmVxdWlyZSgnLi9EZWJ1Z0hlYWRlcicpO1xudmFyIERldmljZSA9IHJlcXVpcmUoJy4uL2RldmljZScpO1xuXG52YXIgQWRkVG9ET00gPSByZXF1aXJlKCcuLi9kb20vQWRkVG9ET00nKTtcbnZhciBET01Db250ZW50TG9hZGVkID0gcmVxdWlyZSgnLi4vZG9tL0RPTUNvbnRlbnRMb2FkZWQnKTtcblxudmFyIE1haW5Mb29wID0gcmVxdWlyZSgnLi9NYWluTG9vcCcpO1xudmFyIENyZWF0ZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9DcmVhdGVSZW5kZXJlcicpO1xudmFyIEdsb2JhbElucHV0TWFuYWdlciA9IHJlcXVpcmUoJy4uL2lucHV0L0dsb2JhbElucHV0TWFuYWdlcicpO1xudmFyIEdsb2JhbFN0YXRlTWFuYWdlciA9IHJlcXVpcmUoJy4uL3N0YXRlL0dsb2JhbFN0YXRlTWFuYWdlcicpO1xudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vQW5pbWF0aW9uTWFuYWdlcicpO1xudmFyIFRleHR1cmVNYW5hZ2VyID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXInKTtcbnZhciBEYXRhID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9EYXRhJyk7XG52YXIgQ2FjaGUgPSByZXF1aXJlKCcuLi9jYWNoZS9DYWNoZScpO1xuXG52YXIgR2FtZSA9IGZ1bmN0aW9uIChjb25maWcpXG57XG4gICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKGNvbmZpZyk7XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuaXNCb290ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5BbmltYXRpb25NYW5hZ2VyfSBhbmltcyAtIFJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIEFuaW1hdGlvbiBNYW5hZ2VyLlxuICAgICovXG4gICAgdGhpcy5hbmltcyA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5UZXh0dXJlTWFuYWdlcn0gdGV4dHVyZXMgLSBSZWZlcmVuY2UgdG8gdGhlIFBoYXNlciBUZXh0dXJlIE1hbmFnZXIuXG4gICAgKi9cbiAgICB0aGlzLnRleHR1cmVzID0gbmV3IFRleHR1cmVNYW5hZ2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5DYWNoZX0gY2FjaGUgLSBSZWZlcmVuY2UgdG8gdGhlIGFzc2V0cyBjYWNoZS5cbiAgICAqL1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuRGF0YX0gcmVnaXN0cnkgLSBHYW1lIHdpZGUgZGF0YSBzdG9yZS5cbiAgICAqL1xuICAgIHRoaXMucmVnaXN0cnkgPSBuZXcgRGF0YSh0aGlzKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuSW5wdXR9IGlucHV0IC0gUmVmZXJlbmNlIHRvIHRoZSBpbnB1dCBtYW5hZ2VyXG4gICAgKi9cbiAgICB0aGlzLmlucHV0ID0gbmV3IEdsb2JhbElucHV0TWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdsb2JhbFN0YXRlTWFuYWdlcn0gc3RhdGUgLSBUaGUgU3RhdGVNYW5hZ2VyLiBQaGFzZXIgaW5zdGFuY2Ugc3BlY2lmaWMuXG4gICAgKi9cbiAgICB0aGlzLnN0YXRlID0gbmV3IEdsb2JhbFN0YXRlTWFuYWdlcih0aGlzLCB0aGlzLmNvbmZpZy5zdGF0ZUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkRldmljZX0gZGV2aWNlIC0gQ29udGFpbnMgZGV2aWNlIGluZm9ybWF0aW9uIGFuZCBjYXBhYmlsaXRpZXMgKHNpbmdsZXRvbilcbiAgICAqL1xuICAgIHRoaXMuZGV2aWNlID0gRGV2aWNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5NYWluTG9vcH0gbWFpbmxvb3AgLSBNYWluIExvb3AgaGFuZGxlci5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICAgIHRoaXMubWFpbmxvb3AgPSBuZXcgTWFpbkxvb3AodGhpcywgdGhpcy5jb25maWcuZnBzKTtcblxuICAgIC8vICBXYWl0IGZvciB0aGUgRE9NIFJlYWR5IGV2ZW50LCB0aGVuIGNhbGwgYm9vdC5cbiAgICBET01Db250ZW50TG9hZGVkKHRoaXMuYm9vdC5iaW5kKHRoaXMpKTtcblxuICAgIC8vICBGb3IgZGVidWdnaW5nIG9ubHlcbiAgICB3aW5kb3cuZ2FtZSA9IHRoaXM7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdhbWU7XG5cbkdhbWUucHJvdG90eXBlID0ge1xuXG4gICAgYm9vdDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY29uZmlnLnByZUJvb3QoKTtcblxuICAgICAgICBEZWJ1Z0hlYWRlcih0aGlzKTtcblxuICAgICAgICBDcmVhdGVSZW5kZXJlcih0aGlzKTtcblxuICAgICAgICBBZGRUb0RPTSh0aGlzLmNhbnZhcywgdGhpcy5jb25maWcucGFyZW50KTtcblxuICAgICAgICB0aGlzLnN0YXRlLmJvb3QoKTtcblxuICAgICAgICB0aGlzLmlucHV0LmJvb3QoKTtcblxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jb25maWcucG9zdEJvb3QoKTtcblxuICAgICAgICB0aGlzLm1haW5sb29wLnN0YXJ0KCk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0dhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0dhbWUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEFkZEV2ZW50TGlzdGVuZXI6IHJlcXVpcmUoJy4vQWRkRXZlbnRMaXN0ZW5lcicpLFxuICAgIEFkZFRvRE9NOiByZXF1aXJlKCcuL0FkZFRvRE9NJyksXG4gICAgQ2FudmFzSW50ZXJwb2xhdGlvbjogcmVxdWlyZSgnLi9DYW52YXNJbnRlcnBvbGF0aW9uJyksXG4gICAgQ2FudmFzUG9vbDogcmVxdWlyZSgnLi9DYW52YXNQb29sJyksXG4gICAgRE9NQ29udGVudExvYWRlZDogcmVxdWlyZSgnLi9ET01Db250ZW50TG9hZGVkJyksXG4gICAgUGFyc2VYTUw6IHJlcXVpcmUoJy4vUGFyc2VYTUwnKSxcbiAgICBSZW1vdmVFdmVudExpc3RlbmVyOiByZXF1aXJlKCcuL1JlbW92ZUV2ZW50TGlzdGVuZXInKSxcbiAgICBSZW1vdmVGcm9tRE9NOiByZXF1aXJlKCcuL1JlbW92ZUZyb21ET00nKSxcbiAgICBSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXG4gICAgVG91Y2hBY3Rpb246IHJlcXVpcmUoJy4vVG91Y2hBY3Rpb24nKSxcbiAgICBVc2VyU2VsZWN0OiByZXF1aXJlKCcuL1VzZXJTZWxlY3QnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9tL2luZGV4LmpzIiwiLy8gIFJlcXVpcmVkLCBidXQgZG9uJ3QgbmVlZCBQaGFzZXIgbGV2ZWwgZXhwb3J0c1xuLy8gIChtYXliZSB0aGVzZSBzaG91bGQgYmUgUGhhc2VyIGV4cG9ydCBsZXZlbD8pXG5cbnJlcXVpcmUoJy4vYmxpdHRlci9CbGl0dGVyRmFjdG9yeScpO1xucmVxdWlyZSgnLi9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeScpO1xucmVxdWlyZSgnLi9pbWFnZS9JbWFnZUZhY3RvcnknKTtcbnJlcXVpcmUoJy4vc3ByaXRlL1Nwcml0ZUZhY3RvcnknKTtcbnJlcXVpcmUoJy4vYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnknKTtcbnJlcXVpcmUoJy4vYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeScpO1xucmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljc0ZhY3RvcnknKTtcbnJlcXVpcmUoJy4vdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnknKTtcbnJlcXVpcmUoJy4vbGF5ZXIvTGF5ZXJGYWN0b3J5Jyk7XG5yZXF1aXJlKCcuL3pvbmUvWm9uZUZhY3RvcnknKTtcblxuLy8gIFBoYXNlci5HYW1lT2JqZWN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEZhY3Rvcnk6IHJlcXVpcmUoJy4vRmFjdG9yeUNvbnRhaW5lcicpLFxuXG4gICAgQml0bWFwVGV4dDogcmVxdWlyZSgnLi9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0JyksXG4gICAgQmxpdHRlcjogcmVxdWlyZSgnLi9ibGl0dGVyL0JsaXR0ZXInKSxcbiAgICBDb250YWluZXI6IHJlcXVpcmUoJy4vY29udGFpbmVyL0NvbnRhaW5lcicpLFxuICAgIER5bmFtaWNCaXRtYXBUZXh0OiByZXF1aXJlKCcuL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dCcpLFxuICAgIEdyYXBoaWNzOiByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzLmpzJyksXG4gICAgSW1hZ2U6IHJlcXVpcmUoJy4vaW1hZ2UvSW1hZ2UnKSxcbiAgICBMYXllcjogcmVxdWlyZSgnLi9sYXllci9MYXllcicpLFxuICAgIFNwcml0ZTogcmVxdWlyZSgnLi9zcHJpdGUvU3ByaXRlJyksXG4gICAgVGV4dDogcmVxdWlyZSgnLi90ZXh0L3N0YXRpYy9UZXh0JyksXG4gICAgWm9uZTogcmVxdWlyZSgnLi96b25lL1pvbmUnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9pbmRleC5qcyIsIi8vICBQaGFzZXIuR2VvbVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcbiAgICBDaXJjbGU6IHJlcXVpcmUoJy4vY2lyY2xlJyksXG4gICAgRWxsaXBzZTogcmVxdWlyZSgnLi9lbGxpcHNlJyksXG4gICAgSGVybWl0ZTogcmVxdWlyZSgnLi9oZXJtaXRlJyksXG4gICAgSW50ZXJzZWN0czogcmVxdWlyZSgnLi9pbnRlcnNlY3RzJyksXG4gICAgTGluZTogcmVxdWlyZSgnLi9saW5lJyksXG4gICAgUG9pbnQ6IHJlcXVpcmUoJy4vcG9pbnQnKSxcbiAgICBQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKSxcbiAgICBSZWN0YW5nbGU6IHJlcXVpcmUoJy4vcmVjdGFuZ2xlJyksXG4gICAgVHJpYW5nbGU6IHJlcXVpcmUoJy4vdHJpYW5nbGUnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW5kZXguanMiLCIvLyAgUGhhc2VyLkdyYXBoaWNzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQmxlbmRNb2RlczogcmVxdWlyZSgnLi9ibGVuZG1vZGVzJyksXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vY29sb3InKVxuICBcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2luZGV4LmpzIiwiLy8gIFBoYXNlci5JbnB1dFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEtleWJvYXJkOiByZXF1aXJlKCcuL2tleWJvYXJkJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQvaW5kZXguanMiLCIvLyAgUGhhc2VyLlBoeXNpY3NcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUG9seURlY29tcDogcmVxdWlyZSgnLi9wb2x5LWRlY29tcC8nKSxcbiAgICBNYXR0ZXJKUzogcmVxdWlyZSgnLi9tYXR0ZXItanMvbW9kdWxlL21haW4nKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL2luZGV4LmpzIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcG9seWZpbGxzL2luZGV4LmpzIiwicmVxdWlyZSgnLi9BcnJheS5mb3JFYWNoJyk7XG5yZXF1aXJlKCcuL0FycmF5LmlzQXJyYXknKTtcbnJlcXVpcmUoJy4vQXVkaW9Db250ZXh0TW9ua2V5UGF0Y2gnKTtcbnJlcXVpcmUoJy4vY29uc29sZScpO1xucmVxdWlyZSgnLi9GdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL01hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vcGVyZm9ybWFuY2Uubm93Jyk7XG5yZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xucmVxdWlyZSgnLi9VaW50MzJBcnJheScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5Tb3VuZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIER5bmFtaWM6IHJlcXVpcmUoJy4vZHluYW1pYycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zb3VuZC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2luZGV4LmpzIiwiLy8gIFBoYXNlci5VdGlscy5BbGlnblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluQm90dG9tQ2VudGVyOiByZXF1aXJlKCcuL0luQm90dG9tQ2VudGVyJyksXG4gICAgSW5Cb3R0b21MZWZ0OiByZXF1aXJlKCcuL0luQm90dG9tTGVmdCcpLFxuICAgIEluQm90dG9tUmlnaHQ6IHJlcXVpcmUoJy4vSW5Cb3R0b21SaWdodCcpLFxuICAgIEluQ2VudGVyOiByZXF1aXJlKCcuL0luQ2VudGVyJyksXG4gICAgSW5MZWZ0Q2VudGVyOiByZXF1aXJlKCcuL0luTGVmdENlbnRlcicpLFxuICAgIEluUmlnaHRDZW50ZXI6IHJlcXVpcmUoJy4vSW5SaWdodENlbnRlcicpLFxuICAgIEluVG9wQ2VudGVyOiByZXF1aXJlKCcuL0luVG9wQ2VudGVyJyksXG4gICAgSW5Ub3BMZWZ0OiByZXF1aXJlKCcuL0luVG9wTGVmdCcpLFxuICAgIEluVG9wUmlnaHQ6IHJlcXVpcmUoJy4vSW5Ub3BSaWdodCcpLFxuICAgIFRvQm90dG9tQ2VudGVyOiByZXF1aXJlKCcuL1RvQm90dG9tQ2VudGVyJyksXG4gICAgVG9Cb3R0b21MZWZ0OiByZXF1aXJlKCcuL1RvQm90dG9tTGVmdCcpLFxuICAgIFRvQm90dG9tUmlnaHQ6IHJlcXVpcmUoJy4vVG9Cb3R0b21SaWdodCcpLFxuICAgIFRvTGVmdEJvdHRvbTogcmVxdWlyZSgnLi9Ub0xlZnRCb3R0b20nKSxcbiAgICBUb0xlZnRDZW50ZXI6IHJlcXVpcmUoJy4vVG9MZWZ0Q2VudGVyJyksXG4gICAgVG9MZWZ0VG9wOiByZXF1aXJlKCcuL1RvTGVmdFRvcCcpLFxuICAgIFRvUmlnaHRCb3R0b206IHJlcXVpcmUoJy4vVG9SaWdodEJvdHRvbScpLFxuICAgIFRvUmlnaHRDZW50ZXI6IHJlcXVpcmUoJy4vVG9SaWdodENlbnRlcicpLFxuICAgIFRvUmlnaHRUb3A6IHJlcXVpcmUoJy4vVG9SaWdodFRvcCcpLFxuICAgIFRvVG9wQ2VudGVyOiByZXF1aXJlKCcuL1RvVG9wQ2VudGVyJyksXG4gICAgVG9Ub3BMZWZ0OiByZXF1aXJlKCcuL1RvVG9wTGVmdCcpLFxuICAgIFRvVG9wUmlnaHQ6IHJlcXVpcmUoJy4vVG9Ub3BSaWdodCcpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBGaW5kQ2xvc2VzdEluU29ydGVkOiByZXF1aXJlKCcuL0ZpbmRDbG9zZXN0SW5Tb3J0ZWQnKSxcbiAgICBHZXRSYW5kb21FbGVtZW50OiByZXF1aXJlKCcuL0dldFJhbmRvbUVsZW1lbnQnKSxcbiAgICBOdW1iZXJBcnJheTogcmVxdWlyZSgnLi9OdW1iZXJBcnJheScpLFxuICAgIE51bWJlckFycmF5U3RlcDogcmVxdWlyZSgnLi9OdW1iZXJBcnJheVN0ZXAnKSxcbiAgICBRdWlja1NlbGVjdDogcmVxdWlyZSgnLi9RdWlja1NlbGVjdCcpLFxuICAgIFJhbmdlOiByZXF1aXJlKCcuL1JhbmdlJyksXG4gICAgUmVtb3ZlUmFuZG9tRWxlbWVudDogcmVxdWlyZSgnLi9SZW1vdmVSYW5kb21FbGVtZW50JyksXG4gICAgUm90YXRlTGVmdDogcmVxdWlyZSgnLi9Sb3RhdGVMZWZ0JyksXG4gICAgUm90YXRlUmlnaHQ6IHJlcXVpcmUoJy4vUm90YXRlUmlnaHQnKSxcbiAgICBTaHVmZmxlOiByZXF1aXJlKCcuL1NodWZmbGUnKSxcbiAgICBTcGxpY2VPbmU6IHJlcXVpcmUoJy4vU3BsaWNlT25lJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvaW5kZXguanMiLCIvLyAgUGhhc2VyLlV0aWxzLkJvdW5kc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIENlbnRlck9uOiByZXF1aXJlKCcuL0NlbnRlck9uJyksXG4gICAgR2V0Qm90dG9tOiByZXF1aXJlKCcuL0dldEJvdHRvbScpLFxuICAgIEdldENlbnRlclg6IHJlcXVpcmUoJy4vR2V0Q2VudGVyWCcpLFxuICAgIEdldENlbnRlclk6IHJlcXVpcmUoJy4vR2V0Q2VudGVyWScpLFxuICAgIEdldExlZnQ6IHJlcXVpcmUoJy4vR2V0TGVmdCcpLFxuICAgIEdldE9mZnNldFg6IHJlcXVpcmUoJy4vR2V0T2Zmc2V0WCcpLFxuICAgIEdldE9mZnNldFk6IHJlcXVpcmUoJy4vR2V0T2Zmc2V0WScpLFxuICAgIEdldFJpZ2h0OiByZXF1aXJlKCcuL0dldFJpZ2h0JyksXG4gICAgR2V0VG9wOiByZXF1aXJlKCcuL0dldFRvcCcpLFxuICAgIFNldEJvdHRvbTogcmVxdWlyZSgnLi9TZXRCb3R0b20nKSxcbiAgICBTZXRDZW50ZXJYOiByZXF1aXJlKCcuL1NldENlbnRlclgnKSxcbiAgICBTZXRDZW50ZXJZOiByZXF1aXJlKCcuL1NldENlbnRlclknKSxcbiAgICBTZXRMZWZ0OiByZXF1aXJlKCcuL1NldExlZnQnKSxcbiAgICBTZXRSaWdodDogcmVxdWlyZSgnLi9TZXRSaWdodCcpLFxuICAgIFNldFRvcDogcmVxdWlyZSgnLi9TZXRUb3AnKVxuICAgIFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2JvdW5kcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2JvdW5kcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgRXh0ZW5kOiByZXF1aXJlKCcuL0V4dGVuZCcpLFxuICAgIElzUGxhaW5PYmplY3Q6IHJlcXVpcmUoJy4vSXNQbGFpbk9iamVjdCcpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9vYmplY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9vYmplY3QvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIFBhZDogcmVxdWlyZSgnLi9QYWQnKSxcbiAgICBSZXZlcnNlOiByZXF1aXJlKCcuL1JldmVyc2UnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvc3RyaW5nL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvc3RyaW5nL2luZGV4LmpzIiwidmFyIEFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0uYW5nbGUgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvQW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FsbCA9IGZ1bmN0aW9uIChpdGVtcywgY2FsbGJhY2ssIHRoaXNBcmcpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL0NhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi91dGlscy9hbGlnbi9jb25zdCcpO1xudmFyIEFsaWduSW4gPSByZXF1aXJlKCcuLi91dGlscy9hbGlnbi9BbGlnbkluJyk7XG52YXIgWm9uZSA9IHJlcXVpcmUoJy4uL2dhbWVvYmplY3RzL3pvbmUvWm9uZScpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XG5cbnZhciB0ZW1wWm9uZSA9IG5ldyBab25lKHt9LCAwLCAwLCAxLCAxKTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGl0ZXJhdGVzIHRocm91Z2ggYWxsIGNoaWxkcmVuIGluIHRoZSBHcm91cCAocmVnYXJkbGVzcyBpZiB0aGV5IGFyZSB2aXNpYmxlIG9yIGV4aXN0KVxuKiBhbmQgdGhlbiBjaGFuZ2VzIHRoZWlyIHBvc2l0aW9uIHNvIHRoZXkgYXJlIGFycmFuZ2VkIGluIGEgR3JpZCBmb3JtYXRpb24uIENoaWxkcmVuIG11c3QgaGF2ZVxuKiB0aGUgYGFsaWduVG9gIG1ldGhvZCBpbiBvcmRlciB0byBiZSBwb3NpdGlvbmVkIGJ5IHRoaXMgY2FsbC4gQWxsIGRlZmF1bHQgUGhhc2VyIEdhbWUgT2JqZWN0cyBoYXZlXG4qIHRoaXMuXG4qXG4qIFRoZSBncmlkIGRpbWVuc2lvbnMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGZvdXIgYXJndW1lbnRzLiBUaGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgYXJndW1lbnRzXG4qIHJlbGF0ZSB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZ3JpZCByZXNwZWN0aXZlbHkuXG4qXG4qIEZvciBleGFtcGxlIGlmIHRoZSBHcm91cCBoYWQgMTAwIGNoaWxkcmVuIGluIGl0OlxuKlxuKiBgR3JvdXAuYWxpZ24oMTAsIDEwLCAzMiwgMzIpYFxuKlxuKiBUaGlzIHdpbGwgYWxpZ24gYWxsIG9mIHRoZSBjaGlsZHJlbiBpbnRvIGEgZ3JpZCBmb3JtYXRpb24gb2YgMTB4MTAsIHVzaW5nIDMyIHBpeGVscyBwZXJcbiogZ3JpZCBjZWxsLiBJZiB5b3Ugd2FudCBhIHdpZGVyIGdyaWQsIHlvdSBjb3VsZCBkbzpcbiogXG4qIGBHcm91cC5hbGlnbigyNSwgNCwgMzIsIDMyKWBcbipcbiogVGhpcyB3aWxsIGFsaWduIHRoZSBjaGlsZHJlbiBpbnRvIGEgZ3JpZCBvZiAyNXg0LCBhZ2FpbiB1c2luZyAzMiBwaXhlbHMgcGVyIGdyaWQgY2VsbC5cbipcbiogWW91IGNhbiBjaG9vc2UgdG8gc2V0IF9laXRoZXJfIHRoZSBgd2lkdGhgIG9yIGBoZWlnaHRgIHZhbHVlIHRvIC0xLiBEb2luZyBzbyB0ZWxscyB0aGUgbWV0aG9kXG4qIHRvIGtlZXAgb24gYWxpZ25pbmcgY2hpbGRyZW4gdW50aWwgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIGxlZnQuIEZvciBleGFtcGxlIGlmIHRoaXMgR3JvdXAgaGFkXG4qIDQ4IGNoaWxkcmVuIGluIGl0LCB0aGUgZm9sbG93aW5nOlxuKlxuKiBgR3JvdXAuYWxpZ24oLTEsIDgsIDMyLCAzMilgXG4qXG4qIC4uLiB3aWxsIGFsaWduIHRoZSBjaGlsZHJlbiBzbyB0aGF0IHRoZXJlIGFyZSA4IGNoaWxkcmVuIHZlcnRpY2FsbHkgKHRoZSBzZWNvbmQgYXJndW1lbnQpLCBcbiogYW5kIGVhY2ggcm93IHdpbGwgY29udGFpbiA2IHNwcml0ZXMsIGV4Y2VwdCB0aGUgbGFzdCBvbmUsIHdoaWNoIHdpbGwgY29udGFpbiA1ICh0b3RhbGluZyA0OClcbipcbiogWW91IGNhbiBhbHNvIGRvOlxuKiBcbiogYEdyb3VwLmFsaWduKDEwLCAtMSwgMzIsIDMyKWBcbipcbiogSW4gdGhpcyBjYXNlIGl0IHdpbGwgY3JlYXRlIGEgZ3JpZCAxMCB3aWRlLCBhbmQgYXMgdGFsbCBhcyBpdCBuZWVkcyB0byBiZSBpbiBvcmRlciB0byBmaXRcbiogYWxsIG9mIHRoZSBjaGlsZHJlbiBpbi5cbipcbiogVGhlIGBwb3NpdGlvbmAgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZXJlIGluIGVhY2ggZ3JpZCBjZWxsIHRoZSBjaGlsZCBpcyBwb3NpdGlvbmVkLlxuKiBUaGlzIGlzIGEgY29uc3RhbnQgYW5kIGNhbiBiZSBvbmUgb2YgYFBoYXNlci5UT1BfTEVGVGAgKGRlZmF1bHQpLCBgUGhhc2VyLlRPUF9DRU5URVJgLCBcbiogYFBoYXNlci5UT1BfUklHSFRgLCBgUGhhc2VyLkxFRlRfQ0VOVEVSYCwgYFBoYXNlci5DRU5URVJgLCBgUGhhc2VyLlJJR0hUX0NFTlRFUmAsIFxuKiBgUGhhc2VyLkJPVFRPTV9MRUZUYCwgYFBoYXNlci5CT1RUT01fQ0VOVEVSYCBvciBgUGhhc2VyLkJPVFRPTV9SSUdIVGAuXG4qXG4qIFRoZSBmaW5hbCBhcmd1bWVudDsgYG9mZnNldGAgbGV0cyB5b3Ugc3RhcnQgdGhlIGFsaWdubWVudCBmcm9tIGEgc3BlY2lmaWMgY2hpbGQgaW5kZXguXG4qXG4qIEBtZXRob2QgUGhhc2VyLkdyb3VwI2FsaWduXG4qIEBwYXJhbSB7aW50ZWdlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGdyaWQgaW4gaXRlbXMgKG5vdCBwaXhlbHMpLiBTZXQgdG8gLTEgZm9yIGEgZHluYW1pYyB3aWR0aC4gSWYgLTEgdGhlbiB5b3UgbXVzdCBzZXQgYW4gZXhwbGljaXQgaGVpZ2h0IHZhbHVlLlxuKiBAcGFyYW0ge2ludGVnZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGdyaWQgaW4gaXRlbXMgKG5vdCBwaXhlbHMpLiBTZXQgdG8gLTEgZm9yIGEgZHluYW1pYyBoZWlnaHQuIElmIC0xIHRoZW4geW91IG11c3Qgc2V0IGFuIGV4cGxpY2l0IHdpZHRoIHZhbHVlLlxuKiBAcGFyYW0ge2ludGVnZXJ9IGNlbGxXaWR0aCAtIFRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgY2VsbCwgaW4gcGl4ZWxzLlxuKiBAcGFyYW0ge2ludGVnZXJ9IGNlbGxIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIGVhY2ggZ3JpZCBjZWxsLCBpbiBwaXhlbHMuXG4qIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSAtIFRoZSBwb3NpdGlvbiBjb25zdGFudC4gT25lIG9mIGBQaGFzZXIuVE9QX0xFRlRgIChkZWZhdWx0KSwgYFBoYXNlci5UT1BfQ0VOVEVSYCwgYFBoYXNlci5UT1BfUklHSFRgLCBgUGhhc2VyLkxFRlRfQ0VOVEVSYCwgYFBoYXNlci5DRU5URVJgLCBgUGhhc2VyLlJJR0hUX0NFTlRFUmAsIGBQaGFzZXIuQk9UVE9NX0xFRlRgLCBgUGhhc2VyLkJPVFRPTV9DRU5URVJgIG9yIGBQaGFzZXIuQk9UVE9NX1JJR0hUYC5cbiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgR3JvdXAgY2hpbGRyZW4gd2VyZSBhbGlnbmVkLCBvdGhlcndpc2UgZmFsc2UuXG4qL1xudmFyIEdyaWRBbGlnbiA9IGZ1bmN0aW9uIChpdGVtcywgb3B0aW9ucylcbntcbiAgICB2YXIgd2lkdGggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnd2lkdGgnLCAtMSk7XG4gICAgdmFyIGhlaWdodCA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdoZWlnaHQnLCAtMSk7XG4gICAgdmFyIGNlbGxXaWR0aCA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdjZWxsV2lkdGgnLCAxKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdjZWxsSGVpZ2h0JywgY2VsbFdpZHRoKTtcbiAgICB2YXIgcG9zaXRpb24gPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAncG9zaXRpb24nLCBDT05TVC5UT1BfTEVGVCk7XG4gICAgdmFyIHggPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAneCcsIDApO1xuICAgIHZhciB5ID0gR2V0T2JqZWN0VmFsdWUob3B0aW9ucywgJ3knLCAwKTtcbiAgICAvLyB2YXIgY2VudGVyWCA9IEdldE9iamVjdFZhbHVlKG9wdGlvbnMsICdjZW50ZXJYJywgbnVsbCk7XG4gICAgLy8gdmFyIGNlbnRlclkgPSBHZXRPYmplY3RWYWx1ZShvcHRpb25zLCAnY2VudGVyWScsIG51bGwpO1xuXG4gICAgdmFyIGN4ID0gMDtcbiAgICB2YXIgY3kgPSAwO1xuICAgIHZhciB3ID0gKHdpZHRoICogY2VsbFdpZHRoKTtcbiAgICB2YXIgaCA9IChoZWlnaHQgKiBjZWxsSGVpZ2h0KTtcblxuICAgIC8vICBJZiB0aGUgR3JpZCBpcyBjZW50ZXJlZCBvbiBhIHBvc2l0aW9uIHRoZW4gd2UgbmVlZCB0byBjYWxjdWxhdGUgaXQgbm93XG4gICAgLy8gaWYgKGNlbnRlclggIT09IG51bGwgJiYgY2VudGVyWSAhPT0gbnVsbClcbiAgICAvLyB7XG4gICAgICAgIC8vIFxuICAgIC8vIH1cblxuICAgIHRlbXBab25lLnNldFBvc2l0aW9uKHgsIHkpO1xuICAgIHRlbXBab25lLnNldFNpemUoY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBBbGlnbkluKGl0ZW1zW2ldLCB0ZW1wWm9uZSwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh3aWR0aCA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBXZSBrZWVwIGxheWluZyB0aGVtIG91dCBob3Jpem9udGFsbHkgdW50aWwgd2UndmUgZG9uZSB0aGVtIGFsbFxuICAgICAgICAgICAgY3kgKz0gY2VsbEhlaWdodDtcbiAgICAgICAgICAgIHRlbXBab25lLnkgKz0gY2VsbEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGN5ID09PSBoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN5ID0gMDtcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS54ICs9IGNlbGxXaWR0aDtcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWlnaHQgPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgV2Uga2VlcCBsYXlpbmcgdGhlbSBvdXQgdmVydGljYWxseSB1bnRpbCB3ZSd2ZSBkb25lIHRoZW0gYWxsXG4gICAgICAgICAgICBjeCArPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICB0ZW1wWm9uZS54ICs9IGNlbGxXaWR0aDtcblxuICAgICAgICAgICAgaWYgKGN4ID09PSB3KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN4ID0gMDtcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS54ID0geDtcbiAgICAgICAgICAgICAgICB0ZW1wWm9uZS55ICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgV2Uga2VlcCBsYXlpbmcgdGhlbSBvdXQgdW50aWwgd2UgaGl0IHRoZSBjb2x1bW4gbGltaXRcbiAgICAgICAgICAgIGN4ICs9IGNlbGxXaWR0aDtcbiAgICAgICAgICAgIHRlbXBab25lLnggKz0gY2VsbFdpZHRoO1xuXG4gICAgICAgICAgICBpZiAoY3ggPT09IHcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3ggPSAwO1xuICAgICAgICAgICAgICAgIGN5ICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueCA9IHg7XG4gICAgICAgICAgICAgICAgdGVtcFpvbmUueSArPSBjZWxsSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGN5ID09PSBoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIFdlJ3ZlIGhpdCB0aGUgY29sdW1uIGxpbWl0LCBzbyByZXR1cm4sIGV2ZW4gaWYgdGhlcmUgYXJlIGl0ZW1zIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkQWxpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL0dyaWRBbGlnbi5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvR3JpZEFsaWduLmpzIiwidmFyIEluY0FscGhhID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0uYWxwaGEgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmNBbHBoYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvSW5jQWxwaGEuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSW5jWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnggKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmNYO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9JbmNYLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEluY1hZID0gZnVuY3Rpb24gKGl0ZW1zLCB4LCB5KVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS54ICs9IHg7XG4gICAgICAgIGl0ZW1zW2ldLnkgKz0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluY1hZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9JbmNYWS5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJbmNZID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0ueSArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluY1k7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL0luY1kuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGxhY2VPbkNpcmNsZSA9IGZ1bmN0aW9uIChpdGVtcywgY2lyY2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSlcbntcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0QW5nbGUgPSAwOyB9XG4gICAgaWYgKGVuZEFuZ2xlID09PSB1bmRlZmluZWQpIHsgZW5kQW5nbGUgPSA2LjI4OyB9XG5cbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHZhciBhbmdsZVN0ZXAgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGl0ZW1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS54ID0gY2lyY2xlLnggKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgICAgIGl0ZW1zW2ldLnkgPSBjaXJjbGUueSArIChjaXJjbGUucmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcblxuICAgICAgICBhbmdsZSArPSBhbmdsZVN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uQ2lyY2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9QbGFjZU9uQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4uL2dlb20vbGluZS9HZXRQb2ludHNPbkxpbmUnKTtcblxudmFyIFBsYWNlT25MaW5lID0gZnVuY3Rpb24gKGl0ZW1zLCBsaW5lKVxue1xuICAgIHZhciBwb2ludHMgPSBHZXRQb2ludHNPbkxpbmUobGluZSk7XG4gICAgdmFyIHN0ZXAgPSBwb2ludHMubGVuZ3RoIC8gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBwID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbTWF0aC5mbG9vcihwKV07XG5cbiAgICAgICAgaXRlbS54ID0gcG9pbnRbMF07XG4gICAgICAgIGl0ZW0ueSA9IHBvaW50WzFdO1xuXG4gICAgICAgIHAgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYWNlT25MaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9QbGFjZU9uTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvUGxhY2VPbkxpbmUuanMiLCJ2YXIgTWFyY2hpbmdBbnRzID0gcmVxdWlyZSgnLi4vZ2VvbS9yZWN0YW5nbGUvTWFyY2hpbmdBbnRzJyk7XG52YXIgUm90YXRlTGVmdCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycmF5L1JvdGF0ZUxlZnQnKTtcbnZhciBSb3RhdGVSaWdodCA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycmF5L1JvdGF0ZVJpZ2h0Jyk7XG5cbi8vICBQbGFjZSB0aGUgaXRlbXMgaW4gdGhlIGFycmF5IGFyb3VuZCB0aGUgcGVyaW1ldGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGUuXG5cbi8vICBQbGFjZW1lbnQgc3RhcnRzIGZyb20gdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGUsIGFuZCBwcm9jZWVkcyBpbiBhXG4vLyAgY2xvY2t3aXNlIGRpcmVjdGlvbi4gSWYgdGhlIHNoaWZ0IHBhcmFtZXRlciBpcyBnaXZlbiB5b3UgY2FuIG9mZnNldCB3aGVyZVxuLy8gIHBsYWNlbWVudCBiZWdpbnMuXG5cbnZhciBQbGFjZU9uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCByZWN0LCBzaGlmdClcbntcbiAgICBpZiAoc2hpZnQgPT09IHVuZGVmaW5lZCkgeyBzaGlmdCA9IDA7IH1cblxuICAgIHZhciBwb2ludHMgPSBNYXJjaGluZ0FudHMocmVjdCwgZmFsc2UsIGl0ZW1zLmxlbmd0aCk7XG5cbiAgICBpZiAoc2hpZnQgPiAwKVxuICAgIHtcbiAgICAgICAgUm90YXRlTGVmdChwb2ludHMsIHNoaWZ0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2hpZnQgPCAwKVxuICAgIHtcbiAgICAgICAgUm90YXRlUmlnaHQocG9pbnRzLCBNYXRoLmFicyhzaGlmdCkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS54ID0gcG9pbnRzW2ldLng7XG4gICAgICAgIGl0ZW1zW2ldLnkgPSBwb2ludHNbaV0ueTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYWNlT25SZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1BsYWNlT25SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hY3Rpb25zL1BsYWNlT25SZWN0YW5nbGUuanMiLCJ2YXIgR2V0UG9pbnRzT25MaW5lID0gcmVxdWlyZSgnLi4vZ2VvbS9saW5lL0dldFBvaW50c09uTGluZScpO1xuXG52YXIgUGxhY2VPblRyaWFuZ2xlID0gZnVuY3Rpb24gKGl0ZW1zLCB0cmlhbmdsZSwgc3RlcFJhdGUpXG57XG4gICAgdmFyIHAxID0gR2V0UG9pbnRzT25MaW5lKHsgeDE6IHRyaWFuZ2xlLngxLCB5MTogdHJpYW5nbGUueTEsIHgyOiB0cmlhbmdsZS54MiwgeTI6IHRyaWFuZ2xlLnkyIH0sIHN0ZXBSYXRlKTtcbiAgICB2YXIgcDIgPSBHZXRQb2ludHNPbkxpbmUoeyB4MTogdHJpYW5nbGUueDIsIHkxOiB0cmlhbmdsZS55MiwgeDI6IHRyaWFuZ2xlLngzLCB5MjogdHJpYW5nbGUueTMgfSwgc3RlcFJhdGUpO1xuICAgIHZhciBwMyA9IEdldFBvaW50c09uTGluZSh7IHgxOiB0cmlhbmdsZS54MywgeTE6IHRyaWFuZ2xlLnkzLCB4MjogdHJpYW5nbGUueDEsIHkyOiB0cmlhbmdsZS55MSB9LCBzdGVwUmF0ZSk7XG5cbiAgICAvLyAgUmVtb3ZlIG92ZXJsYXBzXG4gICAgcDEucG9wKCk7XG4gICAgcDIucG9wKCk7XG4gICAgcDMucG9wKCk7XG5cbiAgICBwMSA9IHAxLmNvbmNhdChwMiwgcDMpO1xuXG4gICAgdmFyIHN0ZXAgPSBwMS5sZW5ndGggLyBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIHAgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBwb2ludCA9IHAxW01hdGguZmxvb3IocCldO1xuXG4gICAgICAgIGl0ZW0ueCA9IHBvaW50WzBdO1xuICAgICAgICBpdGVtLnkgPSBwb2ludFsxXTtcblxuICAgICAgICBwICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFjZU9uVHJpYW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1BsYWNlT25UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvUGxhY2VPblRyaWFuZ2xlLmpzIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vY2lyY2xlL1JhbmRvbScpO1xuXG52YXIgUmFuZG9tQ2lyY2xlID0gZnVuY3Rpb24gKGl0ZW1zLCBjaXJjbGUpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIFJhbmRvbShjaXJjbGUsIGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUNpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvUmFuZG9tQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYWN0aW9ucy9SYW5kb21DaXJjbGUuanMiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9lbGxpcHNlL1JhbmRvbScpO1xuXG52YXIgUmFuZG9tRWxsaXBzZSA9IGZ1bmN0aW9uIChpdGVtcywgZWxsaXBzZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgUmFuZG9tKGVsbGlwc2UsIGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUVsbGlwc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1JhbmRvbUVsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hY3Rpb25zL1JhbmRvbUVsbGlwc2UuanMiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9saW5lL1JhbmRvbScpO1xuXG52YXIgUmFuZG9tTGluZSA9IGZ1bmN0aW9uIChpdGVtcywgbGluZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgUmFuZG9tKGxpbmUsIGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUxpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1JhbmRvbUxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hY3Rpb25zL1JhbmRvbUxpbmUuanMiLCJ2YXIgUmFuZG9tID0gcmVxdWlyZSgnLi4vZ2VvbS9yZWN0YW5nbGUvUmFuZG9tJyk7XG5cbnZhciBSYW5kb21SZWN0YW5nbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHJlY3QpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIFJhbmRvbShyZWN0LCBpdGVtc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21SZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1JhbmRvbVJlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvUmFuZG9tUmVjdGFuZ2xlLmpzIiwidmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4uL2dlb20vdHJpYW5nbGUvUmFuZG9tJyk7XG5cbnZhciBSYW5kb21UcmlhbmdsZSA9IGZ1bmN0aW9uIChpdGVtcywgdHJpYW5nbGUpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIFJhbmRvbSh0cmlhbmdsZSwgaXRlbXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tVHJpYW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1JhbmRvbVRyaWFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYWN0aW9ucy9SYW5kb21UcmlhbmdsZS5qcyIsInZhciBSb3RhdGUgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxue1xuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS5yb3RhdGlvbiArPSB2YWx1ZSArIChpICogc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1JvdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3RhdGVBcm91bmREaXN0YW5jZSA9IHJlcXVpcmUoJy4uL21hdGgvUm90YXRlQXJvdW5kRGlzdGFuY2UnKTtcbnZhciBEaXN0YW5jZUJldHdlZW4gPSByZXF1aXJlKCcuLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlQmV0d2VlbicpO1xuXG4vLyAgcG9pbnQgPSBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXG5cbnZhciBSb3RhdGVBcm91bmQgPSBmdW5jdGlvbiAoaXRlbXMsIHBvaW50LCBhbmdsZSlcbntcbiAgICB2YXIgeCA9IHBvaW50Lng7XG4gICAgdmFyIHkgPSBwb2ludC55O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgUm90YXRlQXJvdW5kRGlzdGFuY2UoaXRlbSwgeCwgeSwgYW5nbGUsIE1hdGgubWF4KDEsIERpc3RhbmNlQmV0d2VlbihpdGVtLngsIGl0ZW0ueSwgeCwgeSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvUm90YXRlQXJvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYWN0aW9ucy9Sb3RhdGVBcm91bmQuanMiLCJ2YXIgTWF0aFJvdGF0ZUFyb3VuZERpc3RhbmNlID0gcmVxdWlyZSgnLi4vbWF0aC9Sb3RhdGVBcm91bmREaXN0YW5jZScpO1xuXG4vLyAgcG9pbnQgPSBhbnkgb2JqZWN0IHdpdGggcHVibGljIHgveSBwcm9wZXJ0aWVzXG4vLyAgYW5nbGUgPSByYWRpYW5zXG4vLyAgZGlzdGFuY2UgPSBweFxuXG52YXIgUm90YXRlQXJvdW5kRGlzdGFuY2UgPSBmdW5jdGlvbiAoaXRlbXMsIHBvaW50LCBhbmdsZSwgZGlzdGFuY2UpXG57XG4gICAgdmFyIHggPSBwb2ludC54O1xuICAgIHZhciB5ID0gcG9pbnQueTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBNYXRoUm90YXRlQXJvdW5kRGlzdGFuY2UoaXRlbXNbaV0sIHgsIHksIGFuZ2xlLCBkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmREaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvUm90YXRlQXJvdW5kRGlzdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hY3Rpb25zL1JvdGF0ZUFyb3VuZERpc3RhbmNlLmpzIiwidmFyIFNjYWxlWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWCArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlWDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2NhbGVYLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNjYWxlWFkgPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHkpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWCArPSB4O1xuICAgICAgICBpdGVtc1tpXS5zY2FsZVkgKz0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlWFk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1NjYWxlWFkuanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVZID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSlcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0uc2NhbGVZICs9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGVZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9TY2FsZVkuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0QWxwaGEgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxue1xuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS5hbHBoYSA9IHZhbHVlICsgKGkgKiBzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldEFscGhhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9TZXRBbHBoYS5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRPcmlnaW4gPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHkpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnNldE9yaWdpbih4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldE9yaWdpbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0T3JpZ2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFJvdGF0aW9uID0gZnVuY3Rpb24gKGl0ZW1zLCB2YWx1ZSwgc3RlcClcbntcbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXAgPSAwOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0ucm90YXRpb24gPSB2YWx1ZSArIChpICogc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRSb3RhdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0Um90YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0U2NhbGUgPSBmdW5jdGlvbiAoaXRlbXMsIHgsIHksIHN0ZXBYLCBzdGVwWSlcbntcbiAgICBpZiAoc3RlcFggPT09IHVuZGVmaW5lZCkgeyBzdGVwWCA9IDA7IH1cbiAgICBpZiAoc3RlcFkgPT09IHVuZGVmaW5lZCkgeyBzdGVwWSA9IDA7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS5zZXRTY2FsZShcbiAgICAgICAgICAgIHggKyAoaSAqIHN0ZXBYKSxcbiAgICAgICAgICAgIHkgKyAoaSAqIHN0ZXBZKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0U2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1NldFNjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNjYWxlWCA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXG57XG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWCA9IHZhbHVlICsgKGkgKiBzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNjYWxlWDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0U2NhbGVYLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFNjYWxlWSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXG57XG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnNjYWxlWSA9IHZhbHVlICsgKGkgKiBzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldFNjYWxlWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0U2NhbGVZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFZpc2libGUgPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS52aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRWaXNpYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9TZXRWaXNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldFggPSBmdW5jdGlvbiAoaXRlbXMsIHZhbHVlLCBzdGVwKVxue1xuICAgIGlmIChzdGVwID09PSB1bmRlZmluZWQpIHsgc3RlcCA9IDA7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpdGVtc1tpXS54ID0gdmFsdWUgKyAoaSAqIHN0ZXApO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0WDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXRYWSA9IGZ1bmN0aW9uIChpdGVtcywgeCwgeSwgc3RlcFgsIHN0ZXBZKVxue1xuICAgIGlmIChzdGVwWCA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBYID0gMDsgfVxuICAgIGlmIChzdGVwWSA9PT0gdW5kZWZpbmVkKSB7IHN0ZXBZID0gMDsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnggPSB4ICsgKGkgKiBzdGVwWCk7XG4gICAgICAgIGl0ZW1zW2ldLnkgPSB5ICsgKGkgKiBzdGVwWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRYWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU2V0WFkuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2V0WSA9IGZ1bmN0aW9uIChpdGVtcywgdmFsdWUsIHN0ZXApXG57XG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMDsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGl0ZW1zW2ldLnkgPSB2YWx1ZSArIChpICogc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9TZXRZLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hdGhTbW9vdGhTdGVwID0gcmVxdWlyZSgnLi4vbWF0aC9TbW9vdGhTdGVwJyk7XG5cbnZhciBTbW9vdGhTdGVwID0gZnVuY3Rpb24gKGl0ZW1zLCBwcm9wZXJ0eSwgbWluLCBtYXgsIGluYylcbntcbiAgICBpZiAoaW5jID09PSB1bmRlZmluZWQpIHsgaW5jID0gZmFsc2U7IH1cblxuICAgIHZhciBzdGVwID0gTWF0aC5hYnMobWF4IC0gbWluKSAvIGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaTtcblxuICAgIGlmIChpbmMpXG4gICAge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW1zW2ldW3Byb3BlcnR5XSArPSBNYXRoU21vb3RoU3RlcChpICogc3RlcCwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldID0gTWF0aFNtb290aFN0ZXAoaSAqIHN0ZXAsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU21vb3RoU3RlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvU21vb3RoU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvU21vb3RoU3RlcC5qcyIsInZhciBNYXRoU21vb3RoZXJTdGVwID0gcmVxdWlyZSgnLi4vbWF0aC9TbW9vdGhlclN0ZXAnKTtcblxudmFyIFNtb290aGVyU3RlcCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXG57XG4gICAgaWYgKGluYyA9PT0gdW5kZWZpbmVkKSB7IGluYyA9IGZhbHNlOyB9XG5cbiAgICB2YXIgc3RlcCA9IE1hdGguYWJzKG1heCAtIG1pbikgLyBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoaW5jKVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gKz0gTWF0aFNtb290aGVyU3RlcChpICogc3RlcCwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbXNbaV1bcHJvcGVydHldID0gTWF0aFNtb290aGVyU3RlcChpICogc3RlcCwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbW9vdGhlclN0ZXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hY3Rpb25zL1Ntb290aGVyU3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMvU21vb3RoZXJTdGVwLmpzIiwidmFyIFNwcmVhZCA9IGZ1bmN0aW9uIChpdGVtcywgcHJvcGVydHksIG1pbiwgbWF4LCBpbmMpXG57XG4gICAgaWYgKGluYyA9PT0gdW5kZWZpbmVkKSB7IGluYyA9IGZhbHNlOyB9XG5cbiAgICB2YXIgc3RlcCA9IE1hdGguYWJzKG1heCAtIG1pbikgLyBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoaW5jKVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gKz0gaSAqIHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtc1tpXVtwcm9wZXJ0eV0gPSBpICogc3RlcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByZWFkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYWN0aW9ucy9TcHJlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVG9nZ2xlVmlzaWJsZSA9IGZ1bmN0aW9uIChpdGVtcylcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaXRlbXNbaV0udmlzaWJsZSA9ICFpdGVtc1tpXS52aXNpYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9nZ2xlVmlzaWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2FjdGlvbnMvVG9nZ2xlVmlzaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBNYXAgPSByZXF1aXJlKCcuLi9zdHJ1Y3RzL01hcCcpO1xuXG4vKipcbiogQW5pbWF0aW9ucyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIEFuaW1hdGlvbk1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgYW5pbWF0aW9ucyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBkYXRhIHRvIEdhbWUgT2JqZWN0cy5cbipcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgQW5pbWF0aW9uTWFuYWdlci5cbipcbiogQWNjZXNzIGl0IHZpYSBgc3RhdGUuYW5pbXNgLlxuKlxuKiBAY2xhc3MgUGhhc2VyLkFuaW1hdGlvbk1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qL1xudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSlcbntcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgdGhpcy5hbmltcyA9IG5ldyBNYXAoKTtcbn07XG5cbkFuaW1hdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5pbWF0aW9uTWFuYWdlcjtcblxuQW5pbWF0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvLyAgYWRkIGZyYW1lIG5hbWUgYmFzZWQgYW5pbWF0aW9uXG4gICAgLy8gIGFkZCBmcmFtZSBpbmRleCBiYXNlZCBhbmltYXRpb25cbiAgICAvLyAgYWRkIGJvbmUgYmFzZWQgYW5pbWF0aW9uXG4gICAgLy8gIGFkZCBhbmltYXRpb24gZnJvbSBqc29uIGRhdGFcblxuICAgIGFkZDogZnVuY3Rpb24gKGtleSwgZnJhbWVzLCBsb29wKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbXMuaGFzKGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuaW1hdGlvbiB3aXRoIGtleScsIGtleSwgJ2FscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1zLmdldChrZXkpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25NYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYW5pbWF0aW9uL0FuaW1hdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0aW9uTWFuYWdlci5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBNQVRIID0gcmVxdWlyZSgnLi4vbWF0aCcpO1xudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBOT09QID0gcmVxdWlyZSgnLi4vdXRpbHMvTk9PUCcpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XG52YXIgVmFsdWVUb0NvbG9yID0gcmVxdWlyZSgnLi4vZ3JhcGhpY3MvY29sb3IvVmFsdWVUb0NvbG9yJyk7XG5cbnZhciBkZWZhdWx0QmFubmVyQ29sb3IgPSBbXG4gICAgJyNmZjAwMDAnLFxuICAgICcjZmZmZjAwJyxcbiAgICAnIzAwZmYwMCcsXG4gICAgJyMwMGZmZmYnLFxuICAgICcjMDAwMDAwJ1xuXTtcblxudmFyIGRlZmF1bHRCYW5uZXJUZXh0Q29sb3IgPSAnI2ZmZmZmZic7XG5cbnZhciBDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKVxue1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkgeyBjb25maWcgPSB7fTsgfVxuXG4gICAgdGhpcy53aWR0aCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dpZHRoJywgMTAyNCk7XG4gICAgdGhpcy5oZWlnaHQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdoZWlnaHQnLCA3NjgpO1xuICAgIHRoaXMuem9vbSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3pvb20nLCAxKTtcblxuICAgIHRoaXMucmVzb2x1dGlvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3Jlc29sdXRpb24nLCAxKTtcblxuICAgIHRoaXMucmVuZGVyVHlwZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3R5cGUnLCBDT05TVC5BVVRPKTtcblxuICAgIHRoaXMucGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAncGFyZW50JywgbnVsbCk7XG4gICAgdGhpcy5jYW52YXMgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjYW52YXMnLCBudWxsKTtcbiAgICB0aGlzLmNhbnZhc1N0eWxlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FudmFzU3R5bGUnLCBudWxsKTtcblxuICAgIHRoaXMuc3RhdGVDb25maWcgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdzdGF0ZScsIG51bGwpO1xuXG4gICAgdGhpcy5zZWVkID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc2VlZCcsIFsgKERhdGUubm93KCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpIF0pO1xuXG4gICAgTUFUSC5STkQuaW5pdCh0aGlzLnNlZWQpO1xuXG4gICAgdGhpcy5nYW1lVGl0bGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0aXRsZScsICcnKTtcbiAgICB0aGlzLmdhbWVVUkwgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd1cmwnLCAnaHR0cDovL3BoYXNlci5pbycpO1xuICAgIHRoaXMuZ2FtZVZlcnNpb24gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd2ZXJzaW9uJywgJycpO1xuXG4gICAgLy8gIElucHV0XG4gICAgdGhpcy5pbnB1dEtleWJvYXJkID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnaW5wdXQua2V5Ym9hcmQnLCB0cnVlKTtcbiAgICB0aGlzLmlucHV0S2V5Ym9hcmRFdmVudFRhcmdldCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2lucHV0LmtleWJvYXJkLnRhcmdldCcsIHdpbmRvdyk7XG5cbiAgICAvLyAgSWYgeW91IGRvOiB7IGJhbm5lcjogZmFsc2UgfSBpdCB3b24ndCBkaXNwbGF5IGFueSBiYW5uZXIgYXQgYWxsXG4gICAgdGhpcy5oaWRlQmFubmVyID0gKEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lcicsIG51bGwpID09PSBmYWxzZSk7XG5cbiAgICB0aGlzLmhpZGVQaGFzZXIgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIuaGlkZVBoYXNlcicsIGZhbHNlKTtcbiAgICB0aGlzLmJhbm5lclRleHRDb2xvciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Jhbm5lci50ZXh0JywgZGVmYXVsdEJhbm5lclRleHRDb2xvcik7XG4gICAgdGhpcy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYW5uZXIuYmFja2dyb3VuZCcsIGRlZmF1bHRCYW5uZXJDb2xvcik7XG4gICBcbiAgICB0aGlzLmZwcyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZwcycsIDYwKTtcbiAgICB0aGlzLmZvcmNlU2V0VGltZU91dCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZvcmNlU2V0VGltZU91dCcsIGZhbHNlKTtcblxuICAgIHRoaXMucGl4ZWxBcnQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdwaXhlbEFydCcsIGZhbHNlKTtcbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndHJhbnNwYXJlbnQnLCBmYWxzZSk7XG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2NsZWFyQmVmb3JlUmVuZGVyJywgdHJ1ZSk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBWYWx1ZVRvQ29sb3IoR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYmFja2dyb3VuZENvbG9yJywgMCkpO1xuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gVmFsdWVUb0NvbG9yKEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3ByZXNlcnZlRHJhd2luZ0J1ZmZlcicsIGZhbHNlKSk7XG5cbiAgICAvLyAgQ2FsbGJhY2tzXG4gICAgdGhpcy5wcmVCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnByZUJvb3QnLCBOT09QKTtcbiAgICB0aGlzLnBvc3RCb290ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnY2FsbGJhY2tzLnBvc3RCb290JywgTk9PUCk7XG5cbiAgICAvLyAgRGVmYXVsdCAvIE1pc3NpbmcgSW1hZ2VzXG4gICAgdmFyIHBuZ1ByZWZpeCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWcnO1xuXG4gICAgdGhpcy5kZWZhdWx0SW1hZ2UgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdpbWFnZXMuZGVmYXVsdCcsIHBuZ1ByZWZpeCArICdBUU1BQUFCSnRPaTNBQUFBQTFCTVZFWC8vLytueEJ2SUFBQUFBWFJTVGxNQVFPYllaZ0FBQUJWSlJFRlVlRjdOd0lFQUFBQUFnS0Q5cWRlb2NBTUFvQUFCbTNEa2NBQUFBQUJKUlU1RXJrSmdnZz09Jyk7XG4gICAgdGhpcy5taXNzaW5nSW1hZ2UgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdpbWFnZXMubWlzc2luZycsIHBuZ1ByZWZpeCArICdDQUlBQUFEOEdPMmpBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUo5SlJFRlVlTnEwMXNzT3d5QU1SRkc0NnYvL010MUVTbWdoK0RGbUUyR1BPQkFSS2IyTlZqbysxN1BYTEQ4YTErcGw1K0Erd1NnRnlneW1XWUhCYjBGdHNLaEpEZFpsbmNHMkl6SjRheW9NRHYyMHdUbVNNekNsRWdiV1lOVEFrUTBaK09KK0EvZVduQWFSOStveENGNE9zMEg4aHRzTVVwK3B3Y2dCQmlNTm5Bd0Y4R3FJZ0wyaEF6YUdGRmdaYXVEUEtBQm1vd1o0R0wzNjkvMHJ3QUNwMnlBL3R0bXZzUUFBQUFCSlJVNUVya0pnZ2c9PScpO1xufTtcblxuQ29uZmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmZpZztcblxubW9kdWxlLmV4cG9ydHMgPSBDb25maWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ib290L0NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvQ29uZmlnLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBDYW52YXNQb29sID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc1Bvb2wnKTtcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2RldmljZS9GZWF0dXJlcycpO1xudmFyIENhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyk7XG52YXIgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXInKTtcbnZhciBDYW52YXNJbnRlcnBvbGF0aW9uID0gcmVxdWlyZSgnLi4vZG9tL0NhbnZhc0ludGVycG9sYXRpb24nKTtcblxuLyoqXG4qIENoZWNrcyBpZiB0aGUgZGV2aWNlIGlzIGNhcGFibGUgb2YgdXNpbmcgdGhlIHJlcXVlc3RlZCByZW5kZXJlciBhbmQgc2V0cyBpdCB1cCBvciBhbiBhbHRlcm5hdGl2ZSBpZiBub3QuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkdhbWUjc2V0VXBSZW5kZXJlclxuKiBAcHJvdGVjdGVkXG4qL1xudmFyIENyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKGdhbWUpXG57XG4gICAgdmFyIGNvbmZpZyA9IGdhbWUuY29uZmlnO1xuXG4gICAgLy8gIEdhbWUgZWl0aGVyIHJlcXVlc3RlZCBDYW52YXMsXG4gICAgLy8gIG9yIHJlcXVlc3RlZCBBVVRPIG9yIFdFQkdMIGJ1dCB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgaXQsIHNvIGZhbGwgYmFjayB0byBDYW52YXNcbiAgICBpZiAoY29uZmlnLnJlbmRlclR5cGUgPT09IENPTlNULkNBTlZBUyB8fCAoY29uZmlnLnJlbmRlclR5cGUgIT09IENPTlNULkNBTlZBUyAmJiAhRmVhdHVyZXMud2ViR0wpKVxuICAgIHtcbiAgICAgICAgaWYgKEZlYXR1cmVzLmNhbnZhcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFRoZXkgcmVxdWVzdGVkIENhbnZhcyBhbmQgdGhlaXIgYnJvd3NlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgY29uZmlnLnJlbmRlclR5cGUgPSBDT05TVC5DQU5WQVM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgQ2FudmFzIG9yIFdlYkdMIGNvbnRleHQsIGFib3J0aW5nLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vICBHYW1lIHJlcXVlc3RlZCBXZWJHTCBhbmQgYnJvd3NlciBzYXlzIGl0IHN1cHBvcnRzIGl0XG4gICAgICAgIGNvbmZpZy5yZW5kZXJUeXBlID0gQ09OU1QuV0VCR0w7XG4gICAgfVxuXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgaXRzIG93biBjYW52YXMgZWxlbWVudCB0byB1c2U/XG4gICAgaWYgKGNvbmZpZy5jYW52YXMpXG4gICAge1xuICAgICAgICBnYW1lLmNhbnZhcyA9IGNvbmZpZy5jYW52YXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdhbWUuY2FudmFzID0gQ2FudmFzUG9vbC5jcmVhdGUoZ2FtZSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0LCBjb25maWcucmVuZGVyVHlwZSk7XG4gICAgfVxuXG4gICAgLy8gIERvZXMgdGhlIGdhbWUgY29uZmlnIHByb3ZpZGUgc29tZSBjYW52YXMgY3NzIHN0eWxlcyB0byB1c2U/XG4gICAgaWYgKGNvbmZpZy5jYW52YXNTdHlsZSlcbiAgICB7XG4gICAgICAgIGdhbWUuY2FudmFzLnN0eWxlID0gY29uZmlnLmNhbnZhc1N0eWxlO1xuICAgIH1cblxuICAgIC8vICBQaXhlbCBBcnQgbW9kZT9cbiAgICBpZiAoY29uZmlnLnBpeGVsQXJ0KVxuICAgIHtcbiAgICAgICAgQ2FudmFzSW50ZXJwb2xhdGlvbi5zZXRDcmlzcChnYW1lLmNhbnZhcyk7XG4gICAgfVxuXG4gICAgLy8gIFpvb21lZD9cbiAgICBpZiAoY29uZmlnLnpvb20gIT09IDEpXG4gICAge1xuICAgICAgICBnYW1lLmNhbnZhcy5zdHlsZS53aWR0aCA9IChjb25maWcud2lkdGggKiBjb25maWcuem9vbSkudG9TdHJpbmcoKSArICdweCc7XG4gICAgICAgIGdhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9IChjb25maWcuaGVpZ2h0ICogY29uZmlnLnpvb20pLnRvU3RyaW5nKCkgKyAncHgnO1xuICAgIH1cblxuICAgIC8vICBDcmVhdGUgdGhlIHJlbmRlcmVyXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5XRUJHTClcbiAgICB7XG4gICAgICAgIGdhbWUucmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcihnYW1lKTtcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2FtZS5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcihnYW1lKTtcbiAgICAgICAgZ2FtZS5jb250ZXh0ID0gZ2FtZS5yZW5kZXJlci5nYW1lQ29udGV4dDtcblxuICAgICAgICAvLyAgZGVidWdcbiAgICAgICAgZ2FtZS5jYW52YXMuaWQgPSAnZ2FtZSc7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGVSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvQ3JlYXRlUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0NyZWF0ZVJlbmRlcmVyLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBDSEVDS1NVTSA9IHJlcXVpcmUoJy4uL2NoZWNrc3VtJyk7XG5cbnZhciBEZWJ1Z0hlYWRlciA9IGZ1bmN0aW9uIChnYW1lKVxue1xuICAgIHZhciBjb25maWcgPSBnYW1lLmNvbmZpZztcblxuICAgIGlmIChjb25maWcuaGlkZUJhbm5lcilcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVHlwZSA9IChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuQ0FOVkFTKSA/ICdDYW52YXMnIDogJ1dlYkdMJztcblxuICAgIHZhciBpZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFpZSlcbiAgICB7XG4gICAgICAgIHZhciBjID0gJyc7XG4gICAgICAgIHZhciBhcmdzID0gW2NdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5iYW5uZXJCYWNrZ3JvdW5kQ29sb3IpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGFzdENvbG9yO1xuXG4gICAgICAgICAgICBjb25maWcuYmFubmVyQmFja2dyb3VuZENvbG9yLmZvckVhY2goZnVuY3Rpb24oY29sb3IpIHtcblxuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnJWMgJyk7XG5cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2JhY2tncm91bmQ6ICcgKyBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICBsYXN0Q29sb3IgPSBjb2xvcjtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vICBpbmplY3QgdGhlIHRleHQgY29sb3JcbiAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9ICdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgbGFzdENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgYyA9IGMuY29uY2F0KCclYyAnKTtcblxuICAgICAgICAgICAgYXJncy5wdXNoKCdjb2xvcjogJyArIGNvbmZpZy5iYW5uZXJUZXh0Q29sb3IgKyAnOyBiYWNrZ3JvdW5kOiAnICsgY29uZmlnLmJhbm5lckJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgVVJMIGxpbmsgYmFja2dyb3VuZCBjb2xvciAoYWx3YXlzIHdoaXRlKVxuICAgICAgICBhcmdzLnB1c2goJ2JhY2tncm91bmQ6ICNmZmYnKTtcblxuICAgICAgICBpZiAoY29uZmlnLmdhbWVUaXRsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgYyA9IGMuY29uY2F0KGNvbmZpZy5nYW1lVGl0bGUpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmdhbWVWZXJzaW9uKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGMgPSBjLmNvbmNhdCgnIHYnICsgY29uZmlnLmdhbWVWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjID0gYy5jb25jYXQoJyAvICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb25maWcuaGlkZVBoYXNlcilcbiAgICAgICAge1xuICAgICAgICAgICAgYyA9IGMuY29uY2F0KCdQaGFzZXIgdicgKyBDT05TVC5WRVJTSU9OICsgJyAoJyArIHJlbmRlclR5cGUgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9IGMuY29uY2F0KCcgJWMgJyArIGNvbmZpZy5nYW1lVVJMKTtcblxuICAgICAgICAvLyAgSW5qZWN0IHRoZSBuZXcgc3RyaW5nIGJhY2sgaW50byB0aGUgYXJncyBhcnJheVxuICAgICAgICBhcmdzWzBdID0gYztcblxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93Wydjb25zb2xlJ10pXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZygnUGhhc2VyIHYnICsgQ09OU1QuVkVSU0lPTiArICcgLyBodHRwOi8vcGhhc2VyLmlvJyk7XG4gICAgfVxuXG4gICAgLy8gS2VlcCB0aGlzIGR1cmluZyBkZXYgYnVpbGQgb25seVxuICAgIGNvbnNvbGUubG9nKENIRUNLU1VNLmJ1aWxkKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z0hlYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2Jvb3QvRGVidWdIZWFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ib290L0RlYnVnSGVhZGVyLmpzIiwidmFyIFJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4uL2RvbS9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuLy8gTXkgdGhhbmtzIHRvIElzYWFjIFN1a2luIGZvciBjcmVhdGluZyBNYWluTG9vcC5qcywgb24gd2hpY2ggbG90cyBvZiB0aGlzIGlzIGJhc2VkLlxuXG52YXIgTWFpbkxvb3AgPSBmdW5jdGlvbiAoZ2FtZSwgZnJhbWVyYXRlKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlJlcXVlc3RBbmltYXRpb25GcmFtZX0gcmFmIC0gQXV0b21hdGljYWxseSBoYW5kbGVzIHRoZSBjb3JlIGdhbWUgbG9vcCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG9yIHNldFRpbWVvdXRcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICAgIHRoaXMucmFmID0gbmV3IFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0ZXAgLSBUaGUgYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gc2ltdWxhdGUgZWFjaCB0aW1lIHVwZGF0ZSgpIHJ1bnMuXG4gICAgKi9cbiAgICB0aGlzLnRpbWVzdGVwID0gMTAwMCAvIGZyYW1lcmF0ZTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBoeXNpY3NTdGVwIC0gMSAvIGZyYW1lcmF0ZS5cbiAgICAqL1xuICAgIHRoaXMucGh5c2ljc1N0ZXAgPSAxIC8gZnJhbWVyYXRlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJhbWVEZWx0YSAtIFRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiBpbi1hcHAgdGltZSB0aGF0IGhhc24ndCBiZWVuIHNpbXVsYXRlZCB5ZXQuXG4gICAgKi9cbiAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xuXG4gICAgdGhpcy5kaXNjYXJkZWRUaW1lID0gMDtcblxuICAgIC8qKlxuICAgICogVGhlIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgb2YgdGhlIGxhc3QgdGltZSB0aGUgbWFpbiBsb29wIHdhcyBydW4uXG4gICAgKiBVc2VkIHRvIGNvbXB1dGUgdGhlIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIGZyYW1lcy5cbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0RnJhbWVUaW1lTXNcbiAgICAqL1xuICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZwcyAtIEFuIGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIG9mIHRoZSBmcmFtZXMgcGVyIHNlY29uZC5cbiAgICAqL1xuICAgIHRoaXMuZnBzID0gNjA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0RnBzVXBkYXRlIC0gVGhlIHRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzKSBvZiB0aGUgbGFzdCB0aW1lIHRoZSBgZnBzYCBtb3ZpbmcgYXZlcmFnZSB3YXMgdXBkYXRlZC5cbiAgICAqL1xuICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmFtZXNUaGlzU2Vjb25kIC0gVGhlIG51bWJlciBvZiBmcmFtZXMgZGVsaXZlcmVkIGluIHRoZSBjdXJyZW50IHNlY29uZC5cbiAgICAqL1xuICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1VcGRhdGVTdGVwcyAtIFRoZSBudW1iZXIgb2YgdGltZXMgdXBkYXRlKCkgaXMgY2FsbGVkIGluIGEgZ2l2ZW4gZnJhbWUuXG4gICAgKi9cbiAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcblxuICAgIC8qKlxuICAgICogVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgbXVzdCBwYXNzIHNpbmNlIHRoZSBsYXN0IGZyYW1lIHdhcyBleGVjdXRlZFxuICAgICogYmVmb3JlIGFub3RoZXIgZnJhbWUgY2FuIGJlIGV4ZWN1dGVkLlxuICAgICogVGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2UgY2FwcyB0aGUgRlBTICh0aGUgZGVmYXVsdCBvZiB6ZXJvIG1lYW5zIHRoZXJlIGlzIG5vIGNhcClcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5GcmFtZURlbGF5XG4gICAgKi9cbiAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJ1bm5pbmcgLSBXaGV0aGVyIHRoZSBtYWluIGxvb3AgaXMgcnVubmluZy5cbiAgICAqL1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIGBNYWluTG9vcC5zdGFydCgpYCBoYXMgYmVlbiBjYWxsZWQgYW5kIHRoZSBtb3N0IHJlY2VudCB0aW1lIGl0XG4gICAgICogd2FzIGNhbGxlZCBoYXMgbm90IGJlZW4gZm9sbG93ZWQgYnkgYSBjYWxsIHRvIGBNYWluTG9vcC5zdG9wKClgLiBUaGlzIGlzXG4gICAgICogZGlmZmVyZW50IHRoYW4gYHJ1bm5pbmdgIGJlY2F1c2UgdGhlcmUgaXMgYSBkZWxheSBvZiBhIGZldyBtaWxsaXNlY29uZHNcbiAgICAgKiBhZnRlciBgTWFpbkxvb3Auc3RhcnQoKWAgaXMgY2FsbGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gaXMgY29uc2lkZXJlZFxuICAgICAqIFwicnVubmluZy5cIiBUaGlzIGRlbGF5IGlzIGR1ZSB0byB3YWl0aW5nIGZvciB0aGUgbmV4dCBmcmFtZS5cbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RhcnRlZFxuICAgICovXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaW11bGF0aW9uIGhhcyBmYWxsZW4gdG9vIGZhciBiZWhpbmQgcmVhbCB0aW1lLlxuICAgICAqIFNwZWNpZmljYWxseSwgYHBhbmljYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWAgaWYgdG9vIG1hbnkgdXBkYXRlcyBvY2N1ciBpblxuICAgICAqIG9uZSBmcmFtZS4gVGhpcyBpcyBvbmx5IHJlbGV2YW50IGluc2lkZSBvZiBhbmltYXRlKCksIGJ1dCBhIHJlZmVyZW5jZSBpc1xuICAgICAqIGhlbGQgZXh0ZXJuYWxseSBzbyB0aGF0IHRoaXMgdmFyaWFibGUgaXMgbm90IG1hcmtlZCBmb3IgZ2FyYmFnZVxuICAgICAqIGNvbGxlY3Rpb24gZXZlcnkgdGltZSB0aGUgbWFpbiBsb29wIHJ1bnMuXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhbmljIC0gV2hldGhlciB0aGUgc2ltdWxhdGlvbiBoYXMgZmFsbGVuIHRvbyBmYXIgYmVoaW5kIHJlYWwgdGltZS5cbiAgICAqL1xuICAgIHRoaXMucGFuaWMgPSBmYWxzZTtcbn07XG5cbk1haW5Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1haW5Mb29wO1xuXG5NYWluTG9vcC5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRNYXhGUFM6IGZ1bmN0aW9uIChmcHMpXG4gICAge1xuICAgICAgICBpZiAoZnBzID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAgLyBmcHM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWF4RlBTOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLm1pbkZyYW1lRGVsYXk7XG4gICAgfSxcblxuICAgIHJlc2V0RnJhbWVEZWx0YTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBvbGRGcmFtZURlbHRhID0gdGhpcy5mcmFtZURlbHRhO1xuXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIG9sZEZyYW1lRGVsdGE7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZU1zID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuZnJhbWVzVGhpc1NlY29uZCA9IDA7XG5cbiAgICAgICAgdGhpcy5yYWYuc3RhcnQodGhpcy5zdGVwLmJpbmQodGhpcyksIHRoaXMuZ2FtZS5jb25maWcuZm9yY2VTZXRUaW1lT3V0KTtcbiAgICB9LFxuXG4gICAgLy8gIHRpbWVzdGFtcCA9IERPTUhpZ2hSZXNUaW1lU3RhbXBcbiAgICAvLyBhY3RpdmUgPSBhcnJheSBjb250YWluaW5nOiAoeyBpbmRleDogaSwgc3RhdGU6IHN0YXRlIH0pXG5cbiAgICBzdGVwOiBmdW5jdGlvbiAodGltZXN0YW1wKVxuICAgIHtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuZ2FtZS5zdGF0ZS5hY3RpdmU7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2FtZS5yZW5kZXJlcjtcblxuICAgICAgICB2YXIgbGVuID0gYWN0aXZlLmxlbmd0aDtcblxuICAgICAgICAvLyBUaHJvdHRsZSB0aGUgZnJhbWUgcmF0ZSAoaWYgbWluRnJhbWVEZWxheSBpcyBzZXQgdG8gYSBub24temVybyB2YWx1ZSBieVxuICAgICAgICAvLyBgTWFpbkxvb3Auc2V0TWF4QWxsb3dlZEZQUygpYCkuXG4gICAgICAgIGlmIChsZW4gPT09IDAgfHwgdGltZXN0YW1wIDwgdGhpcy5sYXN0RnJhbWVUaW1lTXMgKyB0aGlzLm1pbkZyYW1lRGVsYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZyYW1lRGVsdGEgaXMgdGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIGluLWFwcCB0aW1lIHRoYXQgaGFzbid0IGJlZW5cbiAgICAgICAgLy8gc2ltdWxhdGVkIHlldC4gQWRkIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lLiBXZSBuZWVkIHRvIHRyYWNrIHRvdGFsXG4gICAgICAgIC8vIG5vdC15ZXQtc2ltdWxhdGVkIHRpbWUgKGFzIG9wcG9zZWQgdG8ganVzdCB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZVxuICAgICAgICAvLyBsYXN0IGZyYW1lKSBiZWNhdXNlIG5vdCBhbGwgYWN0dWFsbHkgZWxhcHNlZCB0aW1lIGlzIGd1YXJhbnRlZWQgdG8gYmVcbiAgICAgICAgLy8gc2ltdWxhdGVkIGVhY2ggZnJhbWUuIFNlZSB0aGUgY29tbWVudHMgYmVsb3cgZm9yIGRldGFpbHMuXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWVNcztcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lTXMgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgLy8gIEdsb2JhbCBNYW5hZ2VycyAoVGltZSwgSW5wdXQsIGV0YylcblxuICAgICAgICB0aGlzLmdhbWUuaW5wdXQudXBkYXRlKHRpbWVzdGFtcCwgdGhpcy5mcmFtZURlbHRhKTtcblxuICAgICAgICAvLyAgUnVuIGFueSB1cGRhdGVzIHRoYXQgYXJlIG5vdCBkZXBlbmRlbnQgb24gdGltZSBpbiB0aGUgc2ltdWxhdGlvbi5cbiAgICAgICAgLy8gIEhlcmUgd2UnbGwgbmVlZCB0byBydW4gdGhpbmdzIGxpa2UgdHdlZW4udXBkYXRlLCBpbnB1dC51cGRhdGUsIGV0Yy5cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmVbaV0uc3RhdGUuc3lzLmJlZ2luKHRpbWVzdGFtcCwgdGhpcy5mcmFtZURlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZXN0aW1hdGUgb2YgdGhlIGZyYW1lIHJhdGUsIGBmcHNgLiBFdmVyeSBzZWNvbmQsIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgZnJhbWVzIHRoYXQgb2NjdXJyZWQgaW4gdGhhdCBzZWNvbmQgYXJlIGluY2x1ZGVkIGluIGFuIGV4cG9uZW50aWFsXG4gICAgICAgIC8vIG1vdmluZyBhdmVyYWdlIG9mIGFsbCBmcmFtZXMgcGVyIHNlY29uZCwgd2l0aCBhbiBhbHBoYSBvZiAwLjI1LiBUaGlzXG4gICAgICAgIC8vIG1lYW5zIHRoYXQgbW9yZSByZWNlbnQgc2Vjb25kcyBhZmZlY3QgdGhlIGVzdGltYXRlZCBmcmFtZSByYXRlIG1vcmUgdGhhblxuICAgICAgICAvLyBvbGRlciBzZWNvbmRzLlxuICAgICAgICBpZiAodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgMTAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGV4cG9uZW50aWFsIG1vdmluZyBhdmVyYWdlIHdpdGggYW4gYWxwaGEgb2YgMC4yNS5cbiAgICAgICAgICAgIC8vIFVzaW5nIGNvbnN0YW50cyBpbmxpbmUgaXMgb2theSBoZXJlLlxuICAgICAgICAgICAgdGhpcy5mcHMgPSAwLjI1ICogdGhpcy5mcmFtZXNUaGlzU2Vjb25kICsgMC43NSAqIHRoaXMuZnBzO1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB0aGlzLmZyYW1lc1RoaXNTZWNvbmQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZXNUaGlzU2Vjb25kKys7XG5cbiAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnRpbWVzdGVwKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWN0aXZlW2ldLnN0YXRlLnN5cy51cGRhdGUodGhpcy50aW1lc3RlcCwgdGhpcy5waHlzaWNzU3RlcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZnJhbWVEZWx0YSAtPSB0aGlzLnRpbWVzdGVwO1xuXG4gICAgICAgICAgICBpZiAoKyt0aGlzLm51bVVwZGF0ZVN0ZXBzID49IDI0MClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBSZW5kZXJcblxuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbiA9IHRoaXMuZnJhbWVEZWx0YSAvIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgICAgcmVuZGVyZXIucHJlUmVuZGVyKCk7XG5cbiAgICAgICAgLy8gIFRoaXMgdXNlcyBhY3RpdmUubGVuZ3RoLCBpbiBjYXNlIHN0YXRlLnVwZGF0ZSByZW1vdmVkIHRoZSBzdGF0ZSBmcm9tIHRoZSBhY3RpdmUgbGlzdFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmVbaV0uc3RhdGUuc3lzLnJlbmRlcihpbnRlcnBvbGF0aW9uLCByZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5wb3N0UmVuZGVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFuaWMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcGF0dGVybiBpbnRyb2R1Y2VzIG5vbi1kZXRlcm1pbmlzdGljIGJlaGF2aW9yLCBidXQgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAvLyBpdCdzIGJldHRlciB0aGFuIHRoZSBhbHRlcm5hdGl2ZSAodGhlIGFwcGxpY2F0aW9uIHdvdWxkIGxvb2sgbGlrZSBpdFxuICAgICAgICAgICAgLy8gd2FzIHJ1bm5pbmcgdmVyeSBxdWlja2x5IHVudGlsIHRoZSBzaW11bGF0aW9uIGNhdWdodCB1cCB0byByZWFsXG4gICAgICAgICAgICAvLyB0aW1lKS5cbiAgICAgICAgICAgIHRoaXMuZGlzY2FyZGVkVGltZSA9IE1hdGgucm91bmQodGhpcy5yZXNldEZyYW1lRGVsdGEoKSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCB0YWIgcHJvYmFibHkgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhbmljID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5Mb29wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vYm9vdC9NYWluTG9vcC5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2Jvb3QvTWFpbkxvb3AuanMiLCJ2YXIgQ2FjaGVFbnRyeSA9IHJlcXVpcmUoJy4vQ2FjaGVFbnRyeScpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xuXG52YXIgQmFzZUNhY2hlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmVudHJpZXMgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcbn07XG5cbkJhc2VDYWNoZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlQ2FjaGU7XG5cbkJhc2VDYWNoZS5wcm90b3R5cGUgPSB7XG5cbiAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXG4gICAge1xuICAgICAgICB0aGlzLmVudHJpZXMuc2V0KGtleSwgZGF0YSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50cy5DQUNIRV9BRERfRVZFTlQodGhpcywga2V5LCBkYXRhKSk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuaGFzKGtleSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuZ2V0KGtleSk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKGVudHJ5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKG5ldyBFdmVudHMuQ0FDSEVfUkVNT1ZFX0VWRU5UKHRoaXMsIGtleSwgZW50cnkuZGF0YSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmVudHJpZXMuY2xlYXIoKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZUNhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FjaGUvQmFzZUNhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2FjaGUvQmFzZUNhY2hlLmpzIiwidmFyIEJhc2VDYWNoZSA9IHJlcXVpcmUoJy4vQmFzZUNhY2hlJyk7XG5cbnZhciBDYWNoZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5zb3VuZCA9IG5ldyBCYXNlQ2FjaGUoKTtcbiAgICB0aGlzLnZpZGVvID0gbmV3IEJhc2VDYWNoZSgpO1xuICAgIHRoaXMudGV4dCA9IG5ldyBCYXNlQ2FjaGUoKTtcbiAgICB0aGlzLmpzb24gPSBuZXcgQmFzZUNhY2hlKCk7XG4gICAgdGhpcy54bWwgPSBuZXcgQmFzZUNhY2hlKCk7XG4gICAgdGhpcy5waHlzaWNzID0gbmV3IEJhc2VDYWNoZSgpO1xuICAgIHRoaXMudGlsZW1hcCA9IG5ldyBCYXNlQ2FjaGUoKTtcbiAgICB0aGlzLmJpbmFyeSA9IG5ldyBCYXNlQ2FjaGUoKTtcbiAgICB0aGlzLmJpdG1hcEZvbnQgPSBuZXcgQmFzZUNhY2hlKCk7XG4gICAgdGhpcy5zaGFkZXIgPSBuZXcgQmFzZUNhY2hlKCk7XG5cbiAgICB0aGlzLmN1c3RvbSA9IHt9O1xufTtcblxuQ2FjaGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FjaGU7XG5cbkNhY2hlLnByb3RvdHlwZSA9IHtcblxuICAgIC8vICBBZGQgeW91ciBvd24gY3VzdG9tIENhY2hlIGVudHJ5LCBhdmFpbGFibGUgdW5kZXIgQ2FjaGUuY3VzdG9tLmtleVxuICAgIGFkZEN1c3RvbTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5jdXN0b20uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21ba2V5XSA9IG5ldyBCYXNlQ2FjaGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jYWNoZS9DYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhY2hlL0NhY2hlLmpzIiwidmFyIENhY2hlRW50cnkgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGRhdGEpXG57XG4gICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG59O1xuXG5DYWNoZUVudHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhY2hlRW50cnk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVFbnRyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhY2hlL0NhY2hlRW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcblxudmFyIENhY2hlQWRkRXZlbnQgPSBmdW5jdGlvbiAoY2FjaGUsIGtleSwgZGF0YSlcbntcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcblxuICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xufTtcblxuQ2FjaGVBZGRFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG5DYWNoZUFkZEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhY2hlQWRkRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVBZGRFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhY2hlL2V2ZW50cy9DYWNoZUFkZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2FjaGUvZXZlbnRzL0NhY2hlQWRkRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcblxudmFyIENhY2hlUmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoY2FjaGUsIGtleSwgZGF0YSlcbntcbiAgICBFdmVudC5jYWxsKHRoaXMsICdDQUNIRV9BRERfRVZFTlQnKTtcblxuICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xufTtcblxuQ2FjaGVSZW1vdmVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG5DYWNoZVJlbW92ZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhY2hlUmVtb3ZlRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVSZW1vdmVFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NhY2hlL2V2ZW50cy9DYWNoZVJlbW92ZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2FjaGUvZXZlbnRzL0NhY2hlUmVtb3ZlRXZlbnQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIENBQ0hFX0FERF9FVkVOVDogcmVxdWlyZSgnLi9DYWNoZUFkZEV2ZW50JyksXG4gICAgQ0FDSEVfUkVNT1ZFX0VWRU5UOiByZXF1aXJlKCcuL0NhY2hlUmVtb3ZlRXZlbnQnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FjaGUvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY2FjaGUvZXZlbnRzL2luZGV4LmpzIiwidmFyIFRyYW5zZm9ybU1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvVHJhbnNmb3JtTWF0cml4Jyk7XG5cbnZhciBDYW1lcmEgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5zY3JvbGxYID0gMC4wO1xuICAgIHRoaXMuc2Nyb2xsWSA9IDAuMDtcbiAgICB0aGlzLnpvb20gPSAxLjA7XG4gICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAvLyBzaGFrZVxuICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwLjA7XG4gICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSAwLjA7XG4gICAgdGhpcy5fc2hha2VPZmZzZXRYID0gMC4wO1xuICAgIHRoaXMuX3NoYWtlT2Zmc2V0WSA9IDAuMDtcblxuICAgIC8vIGZhZGVcbiAgICB0aGlzLl9mYWRlRHVyYXRpb24gPSAwLjA7XG4gICAgdGhpcy5fZmFkZVJlZCA9IDAuMDtcbiAgICB0aGlzLl9mYWRlR3JlZW4gPSAwLjA7XG4gICAgdGhpcy5fZmFkZUJsdWUgPSAwLjA7XG4gICAgdGhpcy5fZmFkZUFscGhhID0gMC4wO1xuXG4gICAgLy8gZmxhc2hcbiAgICB0aGlzLl9mbGFzaER1cmF0aW9uID0gMC4wO1xuICAgIHRoaXMuX2ZsYXNoUmVkID0gMS4wO1xuICAgIHRoaXMuX2ZsYXNoR3JlZW4gPSAxLjA7XG4gICAgdGhpcy5fZmxhc2hCbHVlID0gMS4wO1xuICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAwLjA7XG5cbiAgICAvLyBvcmlnaW5cbiAgICB0aGlzLl9mb2xsb3cgPSBudWxsO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYTtcblxuQ2FtZXJhLnByb3RvdHlwZSA9IHtcblxuICAgIHNldFZpZXdwb3J0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSxcblxuICAgIHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9LFxuXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZmxhc2hBbHBoYSA+IDAuMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZmxhc2hBbHBoYSAtPSBkZWx0YSAvIHRoaXMuX2ZsYXNoRHVyYXRpb247XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFzaEFscGhhIDwgMC4wKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsYXNoQWxwaGEgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmFkZUFscGhhID4gMC4wICYmIHRoaXMuX2ZhZGVBbHBoYSA8IDEuMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZmFkZUFscGhhICs9IGRlbHRhIC8gdGhpcy5fZmFkZUR1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmFkZUFscGhhID49IDEuMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWRlQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hha2VEdXJhdGlvbiA+IDAuMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGludGVuc2l0eSA9IHRoaXMuX3NoYWtlSW50ZW5zaXR5O1xuXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uIC09IGRlbHRhO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hha2VEdXJhdGlvbiA8PSAwLjApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRYID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU9mZnNldFggPSAoTWF0aC5yYW5kb20oKSAqIGludGVuc2l0eSAqIHRoaXMud2lkdGggKiAyIC0gaW50ZW5zaXR5ICogdGhpcy53aWR0aCkgKiB0aGlzLnpvb207XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VPZmZzZXRZID0gKE1hdGgucmFuZG9tKCkgKiBpbnRlbnNpdHkgKiB0aGlzLmhlaWdodCAqIDIgLSBpbnRlbnNpdHkgKiB0aGlzLmhlaWdodCkgKiB0aGlzLnpvb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhcnRGb2xsb3c6IGZ1bmN0aW9uIChnYW1lT2JqZWN0T3JQb2ludClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9mb2xsb3cgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEZvbGxvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZm9sbG93ID0gZ2FtZU9iamVjdE9yUG9pbnQ7XG4gICAgfSxcblxuICAgIHN0b3BGb2xsb3c6IGZ1bmN0aW9uICgpIFxuICAgIHtcbiAgICAgICAgLyogZG8gdW5mb2xsb3cgd29yayBoZXJlICovXG4gICAgICAgIHRoaXMuX2ZvbGxvdyA9IG51bGw7XG4gICAgfSxcblxuICAgIGZsYXNoOiBmdW5jdGlvbiAoZHVyYXRpb24sIHJlZCwgZ3JlZW4sIGJsdWUsIGZvcmNlKVxuICAgIHtcbiAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzLl9mbGFzaEFscGhhID4gMC4wKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVkID09PSB1bmRlZmluZWQpIHsgcmVkID0gMS4wOyB9XG4gICAgICAgIGlmIChncmVlbiA9PT0gdW5kZWZpbmVkKSB7IGdyZWVuID0gMS4wOyB9XG4gICAgICAgIGlmIChibHVlID09PSB1bmRlZmluZWQpIHsgYmx1ZSA9IDEuMDsgfVxuXG4gICAgICAgIHRoaXMuX2ZsYXNoUmVkID0gcmVkO1xuICAgICAgICB0aGlzLl9mbGFzaEdyZWVuID0gZ3JlZW47XG4gICAgICAgIHRoaXMuX2ZsYXNoQmx1ZSA9IGJsdWU7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZsYXNoRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZmxhc2hBbHBoYSA9IDEuMDtcbiAgICB9LFxuXG4gICAgZmFkZTogZnVuY3Rpb24gKGR1cmF0aW9uLCByZWQsIGdyZWVuLCBibHVlLCBmb3JjZSlcbiAgICB7XG4gICAgICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZCkgeyByZWQgPSAwLjA7IH1cbiAgICAgICAgaWYgKGdyZWVuID09PSB1bmRlZmluZWQpIHsgZ3JlZW4gPSAwLjA7IH1cbiAgICAgICAgaWYgKGJsdWUgPT09IHVuZGVmaW5lZCkgeyBibHVlID0gMC4wOyB9XG5cbiAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzLl9mYWRlQWxwaGEgPiAwLjApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZhZGVSZWQgPSByZWQ7XG4gICAgICAgIHRoaXMuX2ZhZGVHcmVlbiA9IGdyZWVuO1xuICAgICAgICB0aGlzLl9mYWRlQmx1ZSA9IGJsdWU7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZhZGVEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9mYWRlQWxwaGEgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIH0sXG5cbiAgICBzaGFrZTogZnVuY3Rpb24gKGR1cmF0aW9uLCBpbnRlbnNpdHksIGZvcmNlKVxuICAgIHtcbiAgICAgICAgaWYgKGludGVuc2l0eSA9PT0gdW5kZWZpbmVkKSB7IGludGVuc2l0eSA9IDAuMDU7IH1cblxuICAgICAgICBpZiAoIWZvcmNlICYmICh0aGlzLl9zaGFrZU9mZnNldFggIT09IDAuMCB8fCB0aGlzLl9zaGFrZU9mZnNldFkgIT09IDAuMCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fc2hha2VJbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG4gICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WCA9IDA7XG4gICAgICAgIHRoaXMuX3NoYWtlT2Zmc2V0WSA9IDA7XG4gICAgfSxcblxuICAgIHByZVJlbmRlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLnpvb207XG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgICAgdmFyIG9yaWdpblggPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciBvcmlnaW5ZID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGZvbGxvdyA9IHRoaXMuX2ZvbGxvdztcblxuICAgICAgICBpZiAoZm9sbG93ICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9yaWdpblggPSBmb2xsb3cueDtcbiAgICAgICAgICAgIG9yaWdpblkgPSBmb2xsb3cueTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxYID0gb3JpZ2luWCAtIHdpZHRoICogMC41O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxZID0gb3JpZ2luWSAtIGhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeC5sb2FkSWRlbnRpdHkoKTtcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZSh0aGlzLnggKyBvcmlnaW5YLCB0aGlzLnkgKyBvcmlnaW5ZKTtcbiAgICAgICAgbWF0cml4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgbWF0cml4LnNjYWxlKHpvb20sIHpvb20pO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1vcmlnaW5YLCAtb3JpZ2luWSk7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodGhpcy5fc2hha2VPZmZzZXRYLCB0aGlzLl9zaGFrZU9mZnNldFkpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY2FtZXJhL0NhbWVyYS5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NhbWVyYS9DYW1lcmEuanMiLCJ2YXIgQ0hFQ0tTVU0gPSB7XG5idWlsZDogJzdjYTIxOGQwLTE4ZDgtMTFlNy1hZGFhLTZkNGFlNTdhOTBhYydcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENIRUNLU1VNO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NoZWNrc3VtLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsYW1wID0gcmVxdWlyZSgnLi4vbWF0aC9DbGFtcCcpO1xuXG4vLyAgQWxwaGEgQ29tcG9uZW50XG5cbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xudmFyIF9GTEFHID0gMjsgLy8gMDAxMFxuXG52YXIgQWxwaGEgPSB7XG5cbiAgICBfYWxwaGE6IDEsXG5cbiAgICBhbHBoYToge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IENsYW1wKHZhbHVlLCAwLCAxKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbHBoYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQWxwaGEuanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0FscGhhLmpzIiwidmFyIEJsZW5kTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9CbGVuZE1vZGVzJyk7XG5cbi8vICBCbGVuZE1vZGUgQ29tcG9uZW50XG5cbnZhciBCbGVuZE1vZGUgPSB7XG5cbiAgICBfYmxlbmRNb2RlOiBCbGVuZE1vZGVzLk5PUk1BTCxcblxuICAgIGJsZW5kTW9kZToge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kTW9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUgfCAwO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxNilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJsZW5kTW9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQmxlbmRNb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9CbGVuZE1vZGUuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogVGhlIENoaWxkcmVuIENvbXBvbmVudCBmZWF0dXJlcyBxdWljayBhY2Nlc3MgdG8gR3JvdXAgc29ydGluZyByZWxhdGVkIG1ldGhvZHMuXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBDaGlsZHJlbiA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxue1xuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XG5cbiAgICAvLyAgVGhlIG9iamVjdHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBjb2xsZWN0aW9uLlxuICAgIC8vICBUaGUgZXF1aXZhbGVudCBvZiB0aGUgb2xkIGBTcHJpdGUuY2hpbGRyZW5gIGFycmF5LlxuICAgIHRoaXMubGlzdCA9IFtdO1xuXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG59O1xuXG5DaGlsZHJlbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZHJlbjtcblxuQ2hpbGRyZW4ucHJvdG90eXBlID0ge1xuXG4gICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXMuZ2FtZU9iamVjdDtcblxuICAgICAgICB0aGlzLmxpc3QucHVzaChjaGlsZCk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICBhZGRBdDogZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcbiAgICB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxuXG4gICAgICAgIGlmICh0aGlzLmxpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5saXN0Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuXG4gICAgfSxcblxuICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbiAoY2hpbGRyZW4pXG4gICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH0sXG5cbiAgICBnZXRBdDogZnVuY3Rpb24gKGluZGV4KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpbmRleF07XG4gICAgfSxcblxuICAgIGdldEluZGV4OiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICAvLyAgUmV0dXJuIC0xIGlmIGdpdmVuIGNoaWxkIGlzbid0IGEgY2hpbGQgb2YgdGhpcyBwYXJlbnRcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5pbmRleE9mKGNoaWxkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHNldCBiYXNlZCBvbiB0aGUgcHJvcGVydHkgc3RyaWN0bHkgZXF1YWxpbmcgdGhlIHZhbHVlIGdpdmVuLlxuICAgICogUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5BcnJheVNldCNnZXRCeUtleVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGNoZWNrIGFnYWluc3QgdGhlIHZhbHVlLlxuICAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBzdHJpY3RseSBlcXVhbHMuXG4gICAgKiBAcmV0dXJuIHthbnl9IFRoZSBpdGVtIHRoYXQgd2FzIGZvdW5kLCBvciBudWxsIGlmIG5vdGhpbmcgbWF0Y2hlZC5cbiAgICAqL1xuICAgIGdldEJ5S2V5OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV1bcHJvcGVydHldID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogU2VhcmNoZXMgdGhlIEdyb3VwIGZvciB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjaGlsZCB3aXRoIHRoZSBgbmFtZWBcbiAgICAqIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBnaXZlbiBhcmd1bWVudC4gU2hvdWxkIG1vcmUgdGhhbiBvbmUgY2hpbGQgaGF2ZVxuICAgICogdGhlIHNhbWUgbmFtZSBvbmx5IHRoZSBmaXJzdCBpbnN0YW5jZSBpcyByZXR1cm5lZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNnZXRCeU5hbWVcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGZpcnN0IGNoaWxkIHdpdGggYSBtYXRjaGluZyBuYW1lLCBvciBudWxsIGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAgICAqL1xuICAgIGdldEJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCeUtleSgnbmFtZScsIG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gY2hpbGQgZnJvbSB0aGUgZ3JvdXAuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0UmFuZG9tXG4gICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydEluZGV4PTBdIC0gT2Zmc2V0IGZyb20gdGhlIGZyb250IG9mIHRoZSBncm91cCAobG93ZXN0IGNoaWxkKS5cbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD0odG8gdG9wKV0gLSBSZXN0cmljdGlvbiBvbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB5b3Ugd2FudCB0byByYW5kb21seSBzZWxlY3QgZnJvbS5cbiAgICAqIEByZXR1cm4ge2FueX0gQSByYW5kb20gY2hpbGQgb2YgdGhpcyBHcm91cC5cbiAgICAqL1xuICAgIGdldFJhbmRvbTogZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIGxlbmd0aClcbiAgICB7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQpIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IHRoaXMubGlzdC5sZW5ndGg7IH1cblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwIHx8IGxlbmd0aCA+IHRoaXMubGlzdC5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnRJbmRleCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtyYW5kb21JbmRleF07XG4gICAgfSxcblxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcbiAgICB7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQpIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmxpc3RbaV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFtwcm9wZXJ0eV0gPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYWxsIGNoaWxkcmVuIGluIHRoaXMgR3JvdXAuXG4gICAgKlxuICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBtYXRjaGluZyBjcml0ZXJpYSB1c2luZyB0aGUgYHByb3BlcnR5YCBhbmQgYHZhbHVlYCBhcmd1bWVudHMuXG4gICAgKlxuICAgICogRm9yIGV4YW1wbGU6IGBnZXRBbGwoJ2V4aXN0cycsIHRydWUpYCB3b3VsZCByZXR1cm4gb25seSBjaGlsZHJlbiB0aGF0IGhhdmUgdGhlaXIgZXhpc3RzIHByb3BlcnR5IHNldC5cbiAgICAqXG4gICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3BlY2lmeSBhIHN0YXJ0IGFuZCBlbmQgaW5kZXguIEZvciBleGFtcGxlIGlmIHRoaXMgR3JvdXAgaGFkIDEwMCBjaGlsZHJlbixcbiAgICAqIGFuZCB5b3Ugc2V0IGBzdGFydEluZGV4YCB0byAwIGFuZCBgZW5kSW5kZXhgIHRvIDUwLCBpdCB3b3VsZCByZXR1cm4gbWF0Y2hlcyBmcm9tIG9ubHlcbiAgICAqIHRoZSBmaXJzdCA1MCBjaGlsZHJlbiBpbiB0aGUgR3JvdXAuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjZ2V0QWxsXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEFuIG9wdGlvbmFsIHByb3BlcnR5IHRvIHRlc3QgYWdhaW5zdCB0aGUgdmFsdWUgYXJndW1lbnQuXG4gICAgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXSAtIElmIHByb3BlcnR5IGlzIHNldCB0aGVuIENoaWxkLnByb3BlcnR5IG11c3Qgc3RyaWN0bHkgZXF1YWwgdGhpcyB2YWx1ZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cy5cbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0SW5kZXg9MF0gLSBUaGUgZmlyc3QgY2hpbGQgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBmcm9tLlxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kSW5kZXhdIC0gVGhlIGxhc3QgY2hpbGQgaW5kZXggdG8gc2VhcmNoIHVwIHVudGlsLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBleGlzdGluZyBjaGlsZCBvZiB0aGlzIEdyb3VwLlxuICAgICovXG4gICAgZ2V0QWxsOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBzdGFydEluZGV4LCBlbmRJbmRleClcbiAgICB7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQpIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgZW5kSW5kZXggPSB0aGlzLmxpc3QubGVuZ3RoOyB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydHkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW3Byb3BlcnR5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIHN3YXA6IGZ1bmN0aW9uIChjaGlsZDEsIGNoaWxkMilcbiAgICB7XG4gICAgICAgIGlmIChjaGlsZDEgPT09IGNoaWxkMilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQxKTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQyKTtcblxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgc2FtZSBwYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdFtpbmRleDFdID0gY2hpbGQyO1xuICAgICAgICB0aGlzLmxpc3RbaW5kZXgyXSA9IGNoaWxkMTtcbiAgICB9LFxuXG4gICAgLy8gICB3YXMgc2V0SW5kZXhcbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGlzdC5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4ubW92ZVRvOiBUaGUgc3VwcGxpZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFJlbW92ZVxuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XG5cbiAgICAgICAgLy8gIEFkZCBpbiBuZXcgbG9jYXRpb25cbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxpc3QuaW5kZXhPZihjaGlsZCk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICByZW1vdmVBdDogZnVuY3Rpb24gKGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5saXN0W2luZGV4XTtcblxuICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICByZW1vdmVCZXR3ZWVuOiBmdW5jdGlvbiAoYmVnaW5JbmRleCwgZW5kSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAoYmVnaW5JbmRleCA9PT0gdW5kZWZpbmVkKSB7IGJlZ2luSW5kZXggPSAwOyB9XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5saXN0Lmxlbmd0aDsgfVxuXG4gICAgICAgIHZhciByYW5nZSA9IGVuZEluZGV4IC0gYmVnaW5JbmRleDtcblxuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZEluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMubGlzdC5zcGxpY2UoYmVnaW5JbmRleCwgcmFuZ2UpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMubGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGRyZW4ucmVtb3ZlQmV0d2VlbjogUmFuZ2UgRXJyb3IsIG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGFsbCB0aGUgaXRlbXMuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjcmVtb3ZlQWxsXG4gICAgKi9cbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5saXN0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBnaXZlbiBjaGlsZCBpcyBhIGNoaWxkIG9mIHRoaXMgb2JqZWN0LCBhdCBhbnkgZGVwdGggKHJlY3Vyc2l2ZWx5IHNjYW5zIHVwIHRoZSB0cmVlKVxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKGNoaWxkLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBCcmluZ3MgdGhlIGdpdmVuIGNoaWxkIHRvIHRoZSB0b3Agb2YgdGhpcyBncm91cCBzbyBpdCByZW5kZXJzIGFib3ZlIGFsbCBvdGhlciBjaGlsZHJlbi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNicmluZ1RvVG9wXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gYnJpbmcgdG8gdGhlIHRvcCBvZiB0aGlzIGdyb3VwLlxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXG4gICAgKi9cbiAgICBicmluZ1RvVG9wOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzICYmIHRoaXMuZ2V0SW5kZXgoY2hpbGQpIDwgdGhpcy5saXN0Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNlbmRzIHRoZSBnaXZlbiBjaGlsZCB0byB0aGUgYm90dG9tIG9mIHRoaXMgZ3JvdXAgc28gaXQgcmVuZGVycyBiZWxvdyBhbGwgb3RoZXIgY2hpbGRyZW4uXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjc2VuZFRvQmFja1xuICAgICogQHBhcmFtIHthbnl9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIHNlbmQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGdyb3VwLlxuICAgICogQHJldHVybiB7YW55fSBUaGUgY2hpbGQgdGhhdCB3YXMgbW92ZWQuXG4gICAgKi9cbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzICYmIHRoaXMuZ2V0SW5kZXgoY2hpbGQpID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGRBdChjaGlsZCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIHVwIG9uZSBwbGFjZSBpbiB0aGlzIGdyb3VwIHVubGVzcyBpdCdzIGFscmVhZHkgYXQgdGhlIHRvcC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlVXBcbiAgICAqIEBwYXJhbSB7YW55fSBjaGlsZCAtIFRoZSBjaGlsZCB0byBtb3ZlIHVwIGluIHRoZSBncm91cC5cbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxuICAgICovXG4gICAgbW92ZVVwOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0SW5kZXgoY2hpbGQpO1xuXG4gICAgICAgIGlmIChhICE9PSAtMSAmJiBhIDwgdGhpcy5saXN0Lmxlbmd0aCAtIDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXRBdChhICsgMSk7XG5cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChjaGlsZCwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIGdpdmVuIGNoaWxkIGRvd24gb25lIHBsYWNlIGluIHRoaXMgZ3JvdXAgdW5sZXNzIGl0J3MgYWxyZWFkeSBhdCB0aGUgYm90dG9tLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdyb3VwI21vdmVEb3duXG4gICAgKiBAcGFyYW0ge2FueX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gbW92ZSBkb3duIGluIHRoZSBncm91cC5cbiAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNoaWxkIHRoYXQgd2FzIG1vdmVkLlxuICAgICovXG4gICAgbW92ZURvd246IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRJbmRleChjaGlsZCk7XG5cbiAgICAgICAgaWYgKGEgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0QXQoYSAtIDEpO1xuXG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXAoY2hpbGQsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldmVyc2VzIGFsbCBjaGlsZHJlbiBpbiB0aGlzIGdyb3VwLlxuICAgICpcbiAgICAqIFRoaXMgb3BlcmF0aW9uIGFwcGxpZXMgb25seSB0byBpbW1lZGlhdGUgY2hpbGRyZW4gYW5kIGRvZXMgbm90IHByb3BhZ2F0ZSB0byBzdWJncm91cHMuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR3JvdXAjcmV2ZXJzZVxuICAgICovXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubGlzdC5yZXZlcnNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNodWZmbGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMubGlzdFtpXTtcbiAgICAgICAgICAgIHRoaXMubGlzdFtpXSA9IHRoaXMubGlzdFtqXTtcbiAgICAgICAgICAgIHRoaXMubGlzdFtqXSA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXBsYWNlcyBhIGNoaWxkIG9mIHRoaXMgR3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmV3Q2hpbGQuIFRoZSBuZXdDaGlsZCBjYW5ub3QgYmUgYSBtZW1iZXIgb2YgdGhpcyBHcm91cC5cbiAgICAqXG4gICAgKiBJZiBgR3JvdXAuZW5hYmxlQm9keWAgaXMgc2V0LCB0aGVuIGEgcGh5c2ljcyBib2R5IHdpbGwgYmUgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBzbyBsb25nIGFzIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICpcbiAgICAqIElmIGBHcm91cC5pbnB1dEVuYWJsZUNoaWxkcmVuYCBpcyBzZXQsIHRoZW4gYW4gSW5wdXQgSGFuZGxlciB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIG9iamVjdCwgc28gbG9uZyBhcyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNyZXBsYWNlXG4gICAgKiBAcGFyYW0ge2FueX0gb2xkQ2hpbGQgLSBUaGUgY2hpbGQgaW4gdGhpcyBncm91cCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgKiBAcGFyYW0ge2FueX0gbmV3Q2hpbGQgLSBUaGUgY2hpbGQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGlzIGdyb3VwLlxuICAgICogQHJldHVybiB7YW55fSBSZXR1cm5zIHRoZSBvbGRDaGlsZCB0aGF0IHdhcyByZXBsYWNlZCB3aXRoaW4gdGhpcyBncm91cC5cbiAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbmV3Q2hpbGQpXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KG9sZENoaWxkKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQucGFyZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudC5yZW1vdmUobmV3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShvbGRDaGlsZCk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXQobmV3Q2hpbGQsIGluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIG9sZENoaWxkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vICBTd2FwcyBhIGNoaWxkIGZyb20gYW5vdGhlciBwYXJlbnQsIHdpdGggb25lIGZyb20gdGhpcyBwYXJlbnQuXG4gICAgLy8gIGNoaWxkMSA9IHRoZSBjaGlsZCBvZiBUSElTIHBhcmVudFxuICAgIC8vICBjaGlsZDIgPSB0aGUgY2hpbGQgb2YgdGhlIE9USEVSIHBhcmVudFxuICAgIGV4Y2hhbmdlOiBmdW5jdGlvbiAoY2hpbGQxLCBjaGlsZDIpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQxID09PSBjaGlsZDIgfHwgY2hpbGQxLnBhcmVudCA9PT0gY2hpbGQyLnBhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudENoaWxkcmVuID0gY2hpbGQyLnBhcmVudC5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRJbmRleChjaGlsZDEpO1xuICAgICAgICB2YXIgaW5kZXgyID0gcGFyZW50Q2hpbGRyZW4uZ2V0SW5kZXgoY2hpbGQyKTtcblxuICAgICAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLnN3YXA6IFN1cHBsaWVkIG9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiBwYXJlbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZDEpO1xuXG4gICAgICAgIHBhcmVudENoaWxkcmVuLnJlbW92ZShjaGlsZDIpO1xuXG4gICAgICAgIHRoaXMuYWRkQXQoY2hpbGQyLCBpbmRleDEpO1xuXG4gICAgICAgIHBhcmVudENoaWxkcmVuLmFkZEF0KGNoaWxkMSwgaW5kZXgyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBDaGVja3MgZm9yIHRoZSBpdGVtIHdpdGhpbiB0aGlzIGxpc3QuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjZXhpc3RzXG4gICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbGlzdCBpbmRleCBmb3IuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBsaXN0LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgKi9cbiAgICBleGlzdHM6IGZ1bmN0aW9uIChjaGlsZClcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5saXN0LmluZGV4T2YoY2hpbGQpID4gLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBrZXlgIHRvIHRoZSBnaXZlbiB2YWx1ZSBvbiBhbGwgbWVtYmVycyBvZiB0aGlzIGxpc3QuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuQXJyYXlTZXQjc2V0QWxsXG4gICAgKiBAcGFyYW0ge2FueX0ga2V5IC0gVGhlIHByb3BlcnR5IG9mIHRoZSBpdGVtIHRvIHNldC5cbiAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvLlxuICAgICovXG4gICAgc2V0QWxsOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0W2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtpXVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBQYXNzZXMgYWxsIGNoaWxkcmVuIHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGVhY2hcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3VtZW50c10gLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgYWZ0ZXIgdGhlIGNoaWxkLlxuICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKVxuICAgIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbIG51bGwgXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhcmdzWzBdID0gdGhpcy5saXN0W2ldO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBNb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIEdyb3VwIHRvIHRoZSBHcm91cCBnaXZlbi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5Hcm91cCNtb3ZlQWxsXG4gICAgKiBAcGFyYW0ge1BoYXNlci5Hcm91cH0gZ3JvdXAgLSBUaGUgbmV3IEdyb3VwIHRvIHdoaWNoIHRoZSBjaGlsZHJlbiB3aWxsIGJlIG1vdmVkIHRvLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSAtIElmIHRydWUgdGhlIGNoaWxkcmVuIHdpbGwgbm90IGRpc3BhdGNoIHRoZSBgb25BZGRlZFRvR3JvdXBgIGV2ZW50IGZvciB0aGUgbmV3IEdyb3VwLlxuICAgICogQHJldHVybiB7UGhhc2VyLkdyb3VwfSBUaGUgR3JvdXAgdG8gd2hpY2ggYWxsIHRoZSBjaGlsZHJlbiB3ZXJlIG1vdmVkLlxuICAgICovXG4gICAgcmVwYXJlbnQ6IGZ1bmN0aW9uIChuZXdQYXJlbnQpXG4gICAge1xuICAgICAgICBpZiAobmV3UGFyZW50ICE9PSB0aGlzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnJlbW92ZSh0aGlzLmxpc3RbaV0pO1xuXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmFkZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UGFyZW50O1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hpbGRyZW4ucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlc2V0cyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydC5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjZmlyc3RcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaXJzdFxuICAgICovXG4gICAgbGVuZ3RoOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQuXG4gICAgKlxuICAgICogQG5hbWUgUGhhc2VyLkFycmF5U2V0I2ZpcnN0XG4gICAgKiBAcHJvcGVydHkge2FueX0gZmlyc3RcbiAgICAqL1xuICAgIGZpcnN0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIGFuZCByZXNldHMgdGhlIGN1cnNvciB0byB0aGUgZW5kLlxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNsYXN0XG4gICAgKiBAcHJvcGVydHkge2FueX0gbGFzdFxuICAgICovXG4gICAgbGFzdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGlzdC5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgbmV4dCBpdGVtIChiYXNlZCBvbiB0aGUgY3Vyc29yKSBhbmQgYWR2YW5jZXMgdGhlIGN1cnNvci5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuQXJyYXlTZXQjbmV4dFxuICAgICogQHByb3BlcnR5IHthbnl9IG5leHRcbiAgICAqL1xuICAgIG5leHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPCB0aGlzLmxpc3QubGVuZ3RoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5wb3NpdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHByZXZpb3VzIGl0ZW0gKGJhc2VkIG9uIHRoZSBjdXJzb3IpIGFuZCByZXRyZWF0cyB0aGUgY3Vyc29yLlxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5BcnJheVNldCNwcmV2aW91c1xuICAgICogQHByb3BlcnR5IHthbnl9IHByZXZpb3VzXG4gICAgKi9cbiAgICBwcmV2aW91czoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi0tO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFt0aGlzLnBvc2l0aW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGlsZHJlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvQ2hpbGRyZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogVGhlIENvbG9yIENvbXBvbmVudCBhbGxvd3MgeW91IHRvIGNvbnRyb2wgdGhlIGFscGhhLCBibGVuZCBtb2RlLCB0aW50IGFuZCBiYWNrZ3JvdW5kIGNvbG9yXG4qIG9mIGEgR2FtZSBPYmplY3QuXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxue1xuICAgIHRoaXMuZ2FtZU9iamVjdCA9IGdhbWVPYmplY3Q7XG5cbiAgICB0aGlzLnN0YXRlID0gZ2FtZU9iamVjdC5zdGF0ZTtcblxuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLl9hbHBoYSA9IDE7XG4gICAgdGhpcy5fd29ybGRBbHBoYSA9IDE7XG5cbiAgICB0aGlzLl9ibGVuZE1vZGUgPSAwO1xuXG4gICAgdGhpcy5fdGludCA9IHsgdG9wTGVmdDogMHhmZmZmZmYsIHRvcFJpZ2h0OiAweGZmZmZmZiwgYm90dG9tTGVmdDogMHhmZmZmZmYsIGJvdHRvbVJpZ2h0OiAweGZmZmZmZiB9O1xuICAgIHRoaXMuX2dsVGludCA9IHsgdG9wTGVmdDogMTY3NzcyMTUsIHRvcFJpZ2h0OiAxNjc3NzIxNSwgYm90dG9tTGVmdDogMTY3NzcyMTUsIGJvdHRvbVJpZ2h0OiAxNjc3NzIxNSB9O1xuICAgIHRoaXMuX2hhc1RpbnQgPSBmYWxzZTtcblxuICAgIC8vICBCZXR3ZWVuIDAgYW5kIDI1NVxuICAgIHRoaXMuX3IgPSAwO1xuICAgIHRoaXMuX2cgPSAwO1xuICAgIHRoaXMuX2IgPSAwO1xuXG4gICAgLy8gIEJldHdlZW4gMCBhbmQgMVxuICAgIHRoaXMuX2EgPSAxO1xuXG4gICAgLy8gIFN0cmluZyB2ZXJzaW9uIG9mIFJHQkFcbiAgICB0aGlzLl9yZ2JhID0gJyc7XG5cbiAgICAvLyAgMzItYml0IHZlcnNpb24gb2YgQVJHQlxuICAgIHRoaXMuX2dsQmcgPSAwO1xuXG4gICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IGZhbHNlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sb3I7XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblxuICAgIHNldEJhY2tncm91bmQ6IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSlcbiAgICB7XG4gICAgICAgIGlmIChyZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGFzQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZ2xCZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3IgPSByZWQ7XG4gICAgICAgICAgICB0aGlzLl9nID0gKGdyZWVuKSA/IGdyZWVuIDogMDtcbiAgICAgICAgICAgIHRoaXMuX2IgPSAoYmx1ZSkgPyBibHVlIDogMDtcbiAgICAgICAgICAgIHRoaXMuX2EgPSAoYWxwaGEpID8gYWxwaGEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSxcblxuICAgIGNsZWFyVGludDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0VGludCgweGZmZmZmZik7XG5cbiAgICAgICAgdGhpcy5faGFzVGludCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBzZXRUaW50OiBmdW5jdGlvbiAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICAgIHtcbiAgICAgICAgaWYgKHRvcFJpZ2h0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gdG9wTGVmdDtcbiAgICAgICAgICAgIGJvdHRvbUxlZnQgPSB0b3BMZWZ0O1xuICAgICAgICAgICAgYm90dG9tUmlnaHQgPSB0b3BMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aW50VG9wTGVmdCA9IHRvcExlZnQ7XG4gICAgICAgIHRoaXMudGludFRvcFJpZ2h0ID0gdG9wUmlnaHQ7XG4gICAgICAgIHRoaXMudGludEJvdHRvbUxlZnQgPSBib3R0b21MZWZ0O1xuICAgICAgICB0aGlzLnRpbnRCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xuXG4gICAgICAgIHRoaXMuX2hhc1RpbnQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyAgQ2FsbGVkIGJ5IHRoZSBEaXJ0eSBNYW5hZ2VyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5faGFzQmFja2dyb3VuZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcmdiYSA9ICdyZ2JhKCcgKyB0aGlzLl9yICsgJywnICsgdGhpcy5fZyArICcsJyArIHRoaXMuX2IgKyAnLCcgKyB0aGlzLl9hICsgJyknO1xuICAgICAgICAgICAgdGhpcy5fZ2xCZyA9IHRoaXMuZ2V0Q29sb3IzMih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBUaW50IG11bHRzP1xuXG4gICAgfSxcblxuICAgIGdldENvbG9yOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICByZXR1cm4gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgIH0sXG5cbiAgICBnZXRDb2xvcjMyOiBmdW5jdGlvbiAociwgZywgYiwgYSlcbiAgICB7XG4gICAgICAgIGEgKj0gMjU1O1xuXG4gICAgICAgIHJldHVybiAoKGEgPDwgMjQpIHwgKGIgPDwgMTYpIHwgKGcgPDwgOCkgfCByKSA+Pj4gMDtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl90aW50ID0gW107XG4gICAgfVxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIGRpcnR5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zeXMudXBkYXRlcy5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0aW50VG9wTGVmdDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BMZWZ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aW50LnRvcExlZnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dsVGludC50b3BMZWZ0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRpbnRUb3BSaWdodDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludC50b3BSaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGludC50b3BSaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LnRvcFJpZ2h0ID0gdGhpcy5nZXRDb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRpbnRCb3R0b21MZWZ0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbUxlZnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbnQuYm90dG9tTGVmdCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZ2xUaW50LmJvdHRvbUxlZnQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGludEJvdHRvbVJpZ2h0OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW50LmJvdHRvbVJpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aW50LmJvdHRvbVJpZ2h0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9nbFRpbnQuYm90dG9tUmlnaHQgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGludDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGludDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRUaW50KHZhbHVlLCB2YWx1ZSwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFscGhhOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hbHBoYSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYmxlbmRNb2RlOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYmxlbmRNb2RlICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTYpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICB3b3JsZEFscGhhOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWVPYmplY3QucGFyZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmxkQWxwaGEgPSB0aGlzLl9hbHBoYSAqIHRoaXMuZ2FtZU9iamVjdC5wYXJlbnQuY29sb3Iud29ybGRBbHBoYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkQWxwaGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkQWxwaGEgPSB0aGlzLl9hbHBoYSAqIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYmFja2dyb3VuZEFscGhhOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2EpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmVkOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fciA9IHZhbHVlIHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdyZWVuOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2cpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZyA9IHZhbHVlIHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGJsdWU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iID0gdmFsdWUgfCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tncm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9Db2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbGlwID0ge1xuXG4gICAgZmxpcFg6IGZhbHNlLFxuICAgIGZsaXBZOiBmYWxzZSxcblxuICAgIHNldEZsaXBYOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICB0aGlzLmZsaXBYID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEZsaXBZOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICB0aGlzLmZsaXBYID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEZsaXA6IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgdGhpcy5mbGlwWCA9IHg7XG4gICAgICAgIHRoaXMuZmxpcFkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXNldEZsaXA6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmxpcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvRmxpcC5qc1xuLy8gbW9kdWxlIGlkID0gMjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRCb3VuZHMgPSB7XG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIChvdXRwdXQpXG4gICAge1xuICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHsgb3V0cHV0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07IH1cblxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgICAgICAgdmFyIHcgPSB0aGlzLmRpc3BsYXlXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmRpc3BsYXlIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnJvdGF0aW9uO1xuXG4gICAgICAgIHZhciB3Y3QgPSB3ICogTWF0aC5jb3Mocik7XG4gICAgICAgIHZhciBoY3QgPSBoICogTWF0aC5jb3Mocik7XG5cbiAgICAgICAgdmFyIHdzdCA9IHcgKiBNYXRoLnNpbihyKTtcbiAgICAgICAgdmFyIGhzdCA9IGggKiBNYXRoLnNpbihyKTtcblxuICAgICAgICB2YXIgeE1pbiA9IHg7XG4gICAgICAgIHZhciB4TWF4ID0geDtcbiAgICAgICAgdmFyIHlNaW4gPSB5O1xuICAgICAgICB2YXIgeU1heCA9IHk7XG5cbiAgICAgICAgaWYgKHIgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAociA8IDEuNTcwNzk2MzI2Nzk0ODk2NilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAwIDwgdGhldGEgPCA5MFxuICAgICAgICAgICAgICAgIHlNYXggPSB5ICsgaGN0ICsgd3N0O1xuICAgICAgICAgICAgICAgIHhNaW4gPSB4IC0gaHN0O1xuICAgICAgICAgICAgICAgIHhNYXggPSB4ICsgd2N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIDkwIDw9IHRoZXRhIDw9IDE4MFxuICAgICAgICAgICAgICAgIHlNaW4gPSB5ICsgaGN0O1xuICAgICAgICAgICAgICAgIHlNYXggPSB5ICsgd3N0O1xuICAgICAgICAgICAgICAgIHhNaW4gPSB4IC0gaHN0ICsgd2N0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHIgPiAtMS41NzA3OTYzMjY3OTQ4OTY2KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAtOTAgPCB0aGV0YSA8PSAwXG4gICAgICAgICAgICB5TWluID0geSArIHdzdDtcbiAgICAgICAgICAgIHlNYXggPSB5ICsgaGN0O1xuICAgICAgICAgICAgeE1heCA9IHggKyB3Y3QgLSBoc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAtMTgwIDw9IHRoZXRhIDw9IC05MFxuICAgICAgICAgICAgeU1pbiA9IHkgKyB3c3QgKyBoY3Q7XG4gICAgICAgICAgICB4TWluID0geCArIHdjdDtcbiAgICAgICAgICAgIHhNYXggPSB4IC0gaHN0O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnggPSB4TWluO1xuICAgICAgICBvdXRwdXQueSA9IHlNaW47XG4gICAgICAgIG91dHB1dC53aWR0aCA9IHhNYXggLSB4TWluO1xuICAgICAgICBvdXRwdXQuaGVpZ2h0ID0geU1heCAtIHlNaW47XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldEJvdW5kcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvR2V0Qm91bmRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIE9yaWdpbiBDb21wb25lbnRcbi8vICBWYWx1ZXMgYXJlIG5vcm1hbGl6ZWQsIGdpdmVuIGluIHRoZSByYW5nZSAwIHRvIDEuXG4vLyAgRGlzcGxheSB2YWx1ZXMgY29udGFpbiB0aGUgY2FsY3VsYXRlZCBwaXhlbCB2YWx1ZXMuXG5cbnZhciBPcmlnaW4gPSB7XG5cbiAgICBvcmlnaW5YOiAwLjUsXG4gICAgb3JpZ2luWTogMC41LFxuXG4gICAgLy8gIFJFQUQgT05MWVxuICAgIGRpc3BsYXlPcmlnaW5YOiAwLFxuICAgIGRpc3BsYXlPcmlnaW5ZOiAwLFxuXG4gICAgc2V0T3JpZ2luOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDAuNTsgfVxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy5vcmlnaW5YID0geDtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVPcmlnaW4oKTtcbiAgICB9LFxuXG4gICAgc2V0RGlzcGxheU9yaWdpbjogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLmRpc3BsYXlPcmlnaW5YID0geDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWSA9IHk7XG5cbiAgICAgICAgdGhpcy5vcmlnaW5YID0gdGhpcy53aWR0aCAvIHg7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuaGVpZ2h0IC8geTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdXBkYXRlT3JpZ2luOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5T3JpZ2luWCA9IE1hdGgucm91bmQodGhpcy5vcmlnaW5YICogdGhpcy53aWR0aCk7XG4gICAgICAgIHRoaXMuZGlzcGxheU9yaWdpblkgPSBNYXRoLnJvdW5kKHRoaXMub3JpZ2luWSAqIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3JpZ2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9PcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBUaGlzIGlzIGEgV2ViR0wgT05MWSBjb21wb25lbnQgKi9cbnZhciBSZW5kZXJQYXNzID0ge1xuICAgIG91dHB1dFN0YWdlOiB7XG4gICAgICAgIHJlbmRlclRhcmdldDogbnVsbCxcbiAgICAgICAgZW5hYmxlRGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgZW5hYmxlU3RlbmNpbFRlc3Q6IGZhbHNlLFxuICAgICAgICBlbmFibGVCbGVuZGluZzogZmFsc2UsXG5cbiAgICAgICAgLyogQmxlbmQgU3RhdGUgKi9cbiAgICAgICAgYmxlbmRMb2dpY09wOiAwLFxuICAgICAgICBibGVuZFNyY1JnYjogMCxcbiAgICAgICAgYmxlbmREc3RSZ2I6IDAsXG4gICAgICAgIGJsZW5kU3JjQWxwaGE6IDAsXG4gICAgICAgIGJsZW5kRHN0QWxwaGE6IDAsXG4gICAgICAgIGJsZW5kRXFSZ2I6IDAsXG4gICAgICAgIGJsZW5kRXFBbHBoYTogMCxcbiAgICAgICAgYmxlbmRSZWQ6IDAsXG4gICAgICAgIGJsZW5kR3JlZW46IDAsXG4gICAgICAgIGJsZW5kQmx1ZTogMCxcbiAgICAgICAgYmxlbmRBbHBoYTogMCxcblxuICAgICAgICAvKiBEZXB0aC1TdGVuY2lsIFN0YXRlICovXG4gICAgICAgIGRlcHRoRnVuYzogMCxcbiAgICAgICAgZGVwdGhNYXNrOiAwLFxuICAgICAgICBzdGVuY2lsRnVuYzogMCxcbiAgICAgICAgc3RlbmNpbEZhaWw6IDAsXG4gICAgICAgIHN0ZW5jaWxaRmFpbDogMCxcbiAgICAgICAgc3RlbmNpbFpQYXNzOiAwXG4gICAgfSxcblxuICAgIHJlbmRlclBhc3M6IHtcbiAgICAgICAgc2hhZGVyUGlwZWxpbmU6IG51bGwsXG4gICAgICAgIHRleHR1cmVzOiBbXSxcbiAgICAgICAgdG9wb2xvZ3k6IDBcbiAgICB9LFxuXG4gICAgLyogTmVlZGVkIGZvciBnZXR0aW5nIGNvbnN0YW50IHZhbHVlc1xuICAgICAqIEZvcm0gdGhlIFdlYkdMIGNvbnRleHQuXG4gICAgICovXG4gICAgcmVuZGVyaW5nQ29udGV4dDogbnVsbCxcbiAgICBcbiAgICAvKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuICAgIGluaXRSZW5kZXJQYXNzQ29tcG9uZW50OiBmdW5jdGlvbiAoKSBcbiAgICB7XG4gICAgICAgIHZhciByZW5kZXJpbmdDb250ZXh0ID0gdGhpcy5zdGF0ZS5nYW1lLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIGlmIChyZW5kZXJpbmdDb250ZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgocmVuZGVyaW5nQ29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkgfHwgKHJlbmRlcmluZ0NvbnRleHQgIT09IG51bGwgJiYgcmVuZGVyaW5nQ29udGV4dC5yYXdnbCAhPT0gdW5kZWZpbmVkKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nQ29udGV4dCA9IHJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnNldERlZmF1bHREZXB0aFN0ZW5jaWxTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXROb0JsZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0UmVuZGVyVGFyZ2V0OiBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0KSBcbiAgICB7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhZ2UucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0RGVmYXVsdERlcHRoU3RlbmNpbFN0YXRlOiBmdW5jdGlvbiAoKSBcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyaW5nQ29udGV4dDtcbiAgICAgICAgdmFyIG91dHB1dFN0YWdlID0gdGhpcy5vdXRwdXRTdGFnZTtcblxuICAgICAgICBvdXRwdXRTdGFnZS5kZXB0aEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgb3V0cHV0U3RhZ2Uuc3RlbmNpbEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgb3V0cHV0U3RhZ2UuZGVwdGhNYXNrID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0U3RhZ2UuZGVwdGhGdW5jID0gZ2wuTEVTUztcbiAgICAgICAgb3V0cHV0U3RhZ2Uuc3RlbmNpbEZ1bmMgPSBnbC5ORVZFUjtcbiAgICAgICAgb3V0cHV0U3RhZ2Uuc3RlbmNpbFpGYWlsID0gZ2wuS0VFUDtcbiAgICAgICAgb3V0cHV0U3RhZ2Uuc3RlbmNpbFpQYXNzID0gZ2wuS0VFUDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRCbGVuZENvbG9yOiBmdW5jdGlvbiAociwgZywgYiwgYSkgXG4gICAge1xuICAgICAgICB2YXIgb3V0cHV0U3RhZ2UgPSB0aGlzLm91dHB1dFN0YWdlO1xuXG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kUmVkID0gcjtcbiAgICAgICAgb3V0cHV0U3RhZ2UuYmxlbmRHcmVlbiA9IGc7XG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kQmx1ZSA9IGI7XG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kQWxwaGEgPSBhO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRCbGVuZEZ1bmM6IGZ1bmN0aW9uIChzcmMsIGRzdCwgZXEpIFxuICAgIHtcbiAgICAgICAgdmFyIG91dHB1dFN0YWdlID0gdGhpcy5vdXRwdXRTdGFnZTtcbiAgICAgICAgXG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kU3JjUmdiID0gb3V0cHV0U3RhZ2UuYmxlbmRTcmNBbHBoYSA9IHNyYztcbiAgICAgICAgb3V0cHV0U3RhZ2UuYmxlbmREc3RSZ2IgPSBvdXRwdXRTdGFnZS5ibGVuZERzdEFscGhhID0gZHN0O1xuICAgICAgICBvdXRwdXRTdGFnZS5ibGVuZEVxUmdiID0gb3V0cHV0U3RhZ2UuYmxlbmRFcUFscGhhID0gZXE7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0QmxlbmRGdW5jU2VwYXJhdGU6IGZ1bmN0aW9uIChzcmNSZ2IsIHNyY0FscGhhLCBkc3RSZ2IsIGRzdEFscGhhLCBlcVJnYiwgZXFBbHBoYSkgXG4gICAge1xuICAgICAgICB2YXIgb3V0cHV0U3RhZ2UgPSB0aGlzLm91dHB1dFN0YWdlO1xuICAgICAgICBcbiAgICAgICAgb3V0cHV0U3RhZ2UuYmxlbmRTcmNSZ2IgPSBzcmNSZ2I7XG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kU3JjQWxwaGEgPSBzcmNBbHBoYTtcbiAgICAgICAgb3V0cHV0U3RhZ2UuYmxlbmREc3RSZ2IgPSBkc3RSZ2I7XG4gICAgICAgIG91dHB1dFN0YWdlLmJsZW5kRHN0QWxwaGEgPSBkc3RBbHBoYTtcbiAgICAgICAgb3V0cHV0U3RhZ2UuYmxlbmRFcVJnYiA9IGVxUmdiO1xuICAgICAgICBvdXRwdXRTdGFnZS5ibGVuZEVxQWxwaGEgPSBlcUFscGhhO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldERlZmF1bHRCbGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmluZ0NvbnRleHQ7XG5cbiAgICAgICAgdGhpcy5zZXRCbGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5BREQpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldE5vQmxlbmRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJpbmdDb250ZXh0O1xuXG4gICAgICAgIHRoaXMuc2V0QmxlbmRGdW5jKGdsLk9ORSwgZ2wuWkVSTywgZ2wuQUREKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlOiBmdW5jdGlvbiAodGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQYXNzLnRleHR1cmVzW3RleHR1cmVVbml0XSA9IHRleHR1cmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRUb3BvbG9neTogZnVuY3Rpb24gKHRvcG9sb2d5KSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGFzcy50b3BvbG9neSA9IHRvcG9sb2d5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2hhZGVyUGlwZWxpbmU6IGZ1bmN0aW9uIChzaGFkZXJQaXBlbGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlclBhc3Muc2hhZGVyUGlwZWxpbmUgPSBzaGFkZXJQaXBlbGluZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qIENhbGwgdGhpcyBvbiByZW5kZXIgcGFzcyAqL1xuICAgIGRpc3BhdGNoUmVuZGVyUGFzc1N0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyaW5nQ29udGV4dDtcbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIG91dHB1dFN0YWdlID0gdGhpcy5vdXRwdXRTdGFnZTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBpZiAodGV4dHVyZXNbaW5kZXhdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlc1tpbmRleF0udGV4dHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0cHV0U3RhZ2UuZW5hYmxlQmxlbmRpbmcpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShvdXRwdXRTdGFnZS5ibGVuZFNyY1JHQiwgb3V0cHV0U3RhZ2UuYmxlbmREc3RSR0IsIG91dHB1dFN0YWdlLmJsZW5kU3JjQWxwaGEsIG91dHB1dFN0YWdlLmJsZW5kRHN0QWxwaGEpO1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKG91dHB1dFN0YWdlLmJsZW5kRXFSZ2IsIG91dHB1dFN0YWdlLmJsZW5kRXFBbHBoYSk7XG4gICAgICAgICAgICBnbC5ibGVuZENvbG9yKG91dHB1dFN0YWdlLmJsZW5kUmVkLCBvdXRwdXRTdGFnZS5ibGVuZEdyZWVuLCBvdXRwdXRTdGFnZS5ibGVuZEJsdWUsIG91dHB1dFN0YWdlLmJsZW5kQWxwaGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXRTdGFnZS5lbmFibGVEZXB0aFRlc3QpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmRlcHRoRnVuYyhvdXRwdXRTdGFnZS5kZXB0aEZ1bmMpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKG91dHB1dFN0YWdlLmRlcHRoTWFzayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dFN0YWdlLmVuYWJsZVN0ZW5jaWxUZXN0KSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKHRoaXMuc3RlbmNpbEZ1bmMsIDAsIDEpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKHRoaXMuc3RlbmNpbEZhaWwsIHRoaXMuc3RlbmNpbFpGYWlsLCB0aGlzLnN0ZW5jaWxaUGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclBhc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1JlbmRlclBhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcblxuLy8gIFNjYWxlTW9kZSBDb21wb25lbnRcblxudmFyIFNjYWxlTW9kZSA9IHtcblxuICAgIF9zY2FsZU1vZGU6IFNjYWxlTW9kZXMuREVGQVVMVCxcblxuICAgIHNjYWxlTW9kZToge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlTW9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBTY2FsZU1vZGVzLkxJTkVBUiB8fCB2YWx1ZSA9PT0gU2NhbGVNb2Rlcy5ORUFSRVNUKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjYWxlTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGVNb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9TY2FsZU1vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL1NjYWxlTW9kZS5qcyIsInZhciBTaXplID0ge1xuXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuXG4gICAgZGlzcGxheVdpZHRoOiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVggKiB0aGlzLmZyYW1lLnJlYWxXaWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSB2YWx1ZSAvIHRoaXMuZnJhbWUucmVhbFdpZHRoO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGlzcGxheUhlaWdodDoge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVZICogdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHZhbHVlIC8gdGhpcy5mcmFtZS5yZWFsSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgc2V0U2l6ZVRvRnJhbWU6IGZ1bmN0aW9uIChmcmFtZSlcbiAgICB7XG4gICAgICAgIGlmIChmcmFtZSA9PT0gdW5kZWZpbmVkKSB7IGZyYW1lID0gdGhpcy5mcmFtZTsgfVxuXG4gICAgICAgIHRoaXMud2lkdGggPSBmcmFtZS5yZWFsV2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUucmVhbEhlaWdodDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9TaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFRleHR1cmUgQ29tcG9uZW50XG5cbi8vICBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFza1xudmFyIF9GTEFHID0gODsgLy8gMTAwMFxuXG52YXIgVGV4dHVyZSA9IHtcblxuICAgIHRleHR1cmU6IG51bGwsXG4gICAgZnJhbWU6IG51bGwsXG5cbiAgICBzZXRUZXh0dXJlOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuc3RhdGUuc3lzLnRleHR1cmVzLmdldChrZXkpO1xuXG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLnRleHR1cmUuZ2V0KGZyYW1lKTtcblxuICAgICAgICBpZiAoIXRoaXMuZnJhbWUuY3V0V2lkdGggfHwgIXRoaXMuZnJhbWUuY3V0SGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZsYWdzICY9IH5fRkxBRztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XG5cbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdvcmlnaW5YJykpXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgLy8gIERlZmF1bHQgb3JpZ2luIHRvIHRoZSBjZW50ZXJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdyA9IE1hdGguZmxvb3IodGhpcy5mcmFtZS5yZWFsV2lkdGggLyAyKTtcbiAgICAgICAgICAgIC8vICAgICB2YXIgaCA9IE1hdGguZmxvb3IodGhpcy5mcmFtZS5yZWFsSGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIC8vICAgICB0aGlzLnNldE9yaWdpbih3LCBoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vY29tcG9uZW50cy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi9tYXRoL2NvbnN0Jyk7XG52YXIgV3JhcEFuZ2xlID0gcmVxdWlyZSgnLi4vbWF0aC9hbmdsZS9XcmFwJyk7XG52YXIgV3JhcEFuZ2xlRGVncmVlcyA9IHJlcXVpcmUoJy4uL21hdGgvYW5nbGUvV3JhcERlZ3JlZXMnKTtcblxuLy8gIGdsb2JhbCBiaXRtYXNrIGZsYWcgZm9yIEdhbWVPYmplY3QucmVuZGVyTWFzayAodXNlZCBieSBTY2FsZSlcbnZhciBfRkxBRyA9IDQ7IC8vIDAxMDBcblxuLy8gIFRyYW5zZm9ybSBDb21wb25lbnRcblxudmFyIFRyYW5zZm9ybSA9IHtcblxuICAgIC8vICBcInByaXZhdGVcIiBwcm9wZXJ0aWVzXG4gICAgX3NjYWxlWDogMSxcbiAgICBfc2NhbGVZOiAxLFxuICAgIF9yb3RhdGlvbjogMCxcbiAgICBfejogMCxcblxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRDaGlsZHJlbkZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlWDoge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZVggPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyAmPSB+X0ZMQUc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHNjYWxlWToge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZVkgPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyAmPSB+X0ZMQUc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGbGFncyB8PSBfRkxBRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFuZ2xlOiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gV3JhcEFuZ2xlRGVncmVlcyh0aGlzLl9yb3RhdGlvbiAqIE1BVEhfQ09OU1QuUkFEX1RPX0RFRyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICB2YWx1ZSBpcyBpbiBkZWdyZWVzXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gV3JhcEFuZ2xlRGVncmVlcyh2YWx1ZSkgKiBNQVRIX0NPTlNULkRFR19UT19SQUQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcm90YXRpb246IHtcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIHZhbHVlIGlzIGluIHJhZGlhbnNcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gV3JhcEFuZ2xlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHggPSAwOyB9XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKHJhZGlhbnMpXG4gICAge1xuICAgICAgICBpZiAocmFkaWFucyA9PT0gdW5kZWZpbmVkKSB7IHJhZGlhbnMgPSAwOyB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJhZGlhbnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDE7IH1cbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0geDsgfVxuXG4gICAgICAgIHRoaXMuc2NhbGVYID0geDtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9jb21wb25lbnRzL1RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvVHJhbnNmb3JtLmpzIiwiXG4vLyAgVmlzaWJsZSBDb21wb25lbnRcblxuLy8gIGJpdG1hc2sgZmxhZyBmb3IgR2FtZU9iamVjdC5yZW5kZXJNYXNrXG52YXIgX0ZMQUcgPSAxOyAvLyAwMDAxXG5cbnZhciBWaXNpYmxlID0ge1xuXG4gICAgX3Zpc2libGU6IHRydWUsXG5cbiAgICB2aXNpYmxlOiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgfD0gX0ZMQUc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmxhZ3MgJj0gfl9GTEFHO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlzaWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2NvbXBvbmVudHMvVmlzaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XG5cbnZhciBBdWRpbyA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdWRpb0RhdGEgLSBBcmUgQXVkaW8gdGFncyBhdmFpbGFibGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgYXVkaW9EYXRhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3ZWJBdWRpbyAtIElzIHRoZSBXZWJBdWRpbyBBUEkgYXZhaWxhYmxlP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdlYkF1ZGlvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvZ2cgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBvZ2cgZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgb2dnOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBvcHVzIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb3B1cyBmaWxlcz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBvcHVzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtcDMgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBtcDMgZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbXAzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB3YXYgLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3YXYgZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgd2F2OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQ2FuIHRoaXMgZGV2aWNlIHBsYXkgbTRhIGZpbGVzP1xuICAgICogQHByb3BlcnR5IHtib29sZWFufSBtNGEgLSBUcnVlIGlmIHRoaXMgZGV2aWNlIGNhbiBwbGF5IG00YSBmaWxlcy5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBtNGE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm0gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSB3ZWJtIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHdlYm06IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRvbGJ5IC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgRUMtMyBEb2xieSBEaWdpdGFsIFBsdXMgZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgZG9sYnk6IGZhbHNlXG5cbn07XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICBBdWRpby5hdWRpb0RhdGEgPSAhISh3aW5kb3dbJ0F1ZGlvJ10pO1xuICAgIEF1ZGlvLndlYkF1ZGlvID0gISEod2luZG93WydBdWRpb0NvbnRleHQnXSB8fCB3aW5kb3dbJ3dlYmtpdEF1ZGlvQ29udGV4dCddKTtcblxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuXG4gICAgdmFyIHJlc3VsdCA9ICEhYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBdWRpby5vZ2cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cIm9wdXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykgfHwgYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9vcHVzOycpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ub3B1cyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBdWRpby5tcDMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgTWltZXR5cGVzIGFjY2VwdGVkOlxuICAgICAgICAgICAgLy8gIGRldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9NZWRpYV9mb3JtYXRzX3N1cHBvcnRlZF9ieV90aGVfYXVkaW9fYW5kX3ZpZGVvX2VsZW1lbnRzXG4gICAgICAgICAgICAvLyAgYml0Lmx5L2lwaG9uZW9zY29kZWNzXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ud2F2ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBdWRpby5tNGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXVkaW8ud2VibSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDtjb2RlY3M9XCJlYy0zXCInKSAhPT0gJycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKEJyb3dzZXIuZWRnZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEF1ZGlvLmRvbGJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5zYWZhcmlWZXJzaW9uID49IDkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKC9NYWMgT1MgWCAoXFxkKylfKFxcZCspLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlub3IgPSBwYXJzZUludChSZWdFeHAuJDIsIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYWpvciA9PT0gMTAgJiYgbWlub3IgPj0gMTEpIHx8IG1ham9yID4gMTApXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXVkaW8uZG9sYnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKVxuICAgIHtcbiAgICAgICAgLy8gIE5vdGhpbmcgdG8gZG8gaGVyZVxuICAgIH1cblxuICAgIHJldHVybiBBdWRpbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvQXVkaW8uanNcbi8vIG1vZHVsZSBpZCA9IDI4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvQXVkaW8uanMiLCJ2YXIgT1MgPSByZXF1aXJlKCcuL09TJyk7XG52YXIgQnJvd3NlciA9IHJlcXVpcmUoJy4vQnJvd3NlcicpO1xuXG52YXIgRnVsbHNjcmVlbiA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdmFpbGFibGUgLSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgdGhlIEZ1bGwgU2NyZWVuIEFQST9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBhdmFpbGFibGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gcmVxdWVzdCAtIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBGdWxsIFNjcmVlbiBBUEkgdGhpcyBob2xkcyB0aGUgY2FsbCB5b3UgbmVlZCB0byB1c2UgdG8gYWN0aXZhdGUgaXQuXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgcmVxdWVzdDogJycsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYW5jZWwgLSBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgRnVsbCBTY3JlZW4gQVBJIHRoaXMgaG9sZHMgdGhlIGNhbGwgeW91IG5lZWQgdG8gdXNlIHRvIGNhbmNlbCBpdC5cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBjYW5jZWw6ICcnLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGtleWJvYXJkIC0gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFjY2VzcyB0byB0aGUgS2V5Ym9hcmQgZHVyaW5nIEZ1bGwgU2NyZWVuIG1vZGU/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAga2V5Ym9hcmQ6IGZhbHNlXG5cbn07XG5cbi8qKlxuKiBDaGVja3MgZm9yIHN1cHBvcnQgb2YgdGhlIEZ1bGwgU2NyZWVuIEFQSS5cbiovXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgdmFyIGZzID0gW1xuICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAncmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLFxuICAgICAgICAnbXNSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgICAgICdtc1JlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21velJlcXVlc3RGdWxsc2NyZWVuJ1xuICAgIF07XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChlbGVtZW50W2ZzW2ldXSlcbiAgICAgICAge1xuICAgICAgICAgICAgRnVsbHNjcmVlbi5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgRnVsbHNjcmVlbi5yZXF1ZXN0ID0gZnNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZnMgPSBbXG4gICAgICAgICdjYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgJ2V4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuICAgICAgICAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnbXNDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgICAgICdtb3pFeGl0RnVsbHNjcmVlbidcbiAgICBdO1xuXG4gICAgaWYgKEZ1bGxzY3JlZW4uYXZhaWxhYmxlKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtjZnNbaV1dKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEZ1bGxzY3JlZW4uY2FuY2VsID0gY2ZzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gIEtleWJvYXJkIElucHV0P1xuICAgIGlmICh3aW5kb3dbJ0VsZW1lbnQnXSAmJiBFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKVxuICAgIHtcbiAgICAgICAgRnVsbHNjcmVlbi5rZXlib2FyZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZ1bGxzY3JlZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0Z1bGxzY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvRnVsbHNjcmVlbi5qcyIsInZhciBPUyA9IHJlcXVpcmUoJy4vT1MnKTtcbnZhciBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJyk7XG5cbnZhciBJbnB1dCA9IHtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB0b3VjaCAtIElzIHRvdWNoIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0b3VjaDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbXNwb2ludGVyIC0gSXMgbXNwb2ludGVyIGF2YWlsYWJsZT9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBtc3BvaW50ZXI6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgez9zdHJpbmd9IHdoZWVsVHlwZSAtIFRoZSBuZXdlc3QgdHlwZSBvZiBXaGVlbC9TY3JvbGwgZXZlbnQgc3VwcG9ydGVkOiAnd2hlZWwnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCdcbiAgICAqIEBkZWZhdWx0XG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgICB3aGVlbEV2ZW50OiBudWxsXG4gICAgXG59O1xuXG5mdW5jdGlvbiBpbml0ICgpXG57XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCAod2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID49IDEpKVxuICAgIHtcbiAgICAgICAgSW5wdXQudG91Y2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgfHwgd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZClcbiAgICB7XG4gICAgICAgIElucHV0Lm1zcG9pbnRlciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFPUy5jb2Nvb25KUylcbiAgICB7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbiAgICAgICAgaWYgKCdvbndoZWVsJyBpbiB3aW5kb3cgfHwgKEJyb3dzZXIuaWUgJiYgJ1doZWVsRXZlbnQnIGluIHdpbmRvdykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERPTTMgV2hlZWwgRXZlbnQ6IEZGIDE3KywgSUUgOSssIENocm9tZSAzMSssIFNhZmFyaSA3K1xuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICd3aGVlbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ29ubW91c2V3aGVlbCcgaW4gd2luZG93KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBOb24tRkYgbGVnYWN5OiBJRSA2LTksIENocm9tZSAxLTMxLCBTYWZhcmkgNS03LlxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICdtb3VzZXdoZWVsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCcm93c2VyLmZpcmVmb3ggJiYgJ01vdXNlU2Nyb2xsRXZlbnQnIGluIHdpbmRvdylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gRkYgcHJpb3IgdG8gMTcuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHNjcnViYmVkLlxuICAgICAgICAgICAgSW5wdXQud2hlZWxFdmVudCA9ICdET01Nb3VzZVNjcm9sbCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW5wdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZGV2aWNlL0lucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZGV2aWNlL0lucHV0LmpzIiwidmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcblxudmFyIFZpZGVvID0ge1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG9nZ1ZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgb2dnIHZpZGVvIGZpbGVzP1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIG9nZ1ZpZGVvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBoMjY0VmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBoMjY0IG1wNCB2aWRlbyBmaWxlcz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICBoMjY0VmlkZW86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1wNFZpZGVvIC0gQ2FuIHRoaXMgZGV2aWNlIHBsYXkgaDI2NCBtcDQgdmlkZW8gZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgbXA0VmlkZW86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlYm1WaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IHdlYm0gdmlkZW8gZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgd2VibVZpZGVvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB2cDlWaWRlbyAtIENhbiB0aGlzIGRldmljZSBwbGF5IHZwOSB2aWRlbyBmaWxlcz9cbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB2cDlWaWRlbzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGxzVmlkZW8gLSBDYW4gdGhpcyBkZXZpY2UgcGxheSBobHMgdmlkZW8gZmlsZXM/XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgaGxzVmlkZW86IGZhbHNlXG5cbn07XG5cbmZ1bmN0aW9uIGluaXQgKClcbntcbiAgICB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2YXIgcmVzdWx0ID0gISF2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGU7XG5cbiAgICB0cnlcbiAgICB7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuY2FuUGxheVR5cGUoJ3ZpZGVvL29nZzsgY29kZWNzPVwidGhlb3JhXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFZpZGVvLm9nZ1ZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5jYW5QbGF5VHlwZSgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IFF1aWNrVGltZSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgLiBnaXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzU0NlxuICAgICAgICAgICAgICAgIFZpZGVvLmgyNjRWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgVmlkZW8ubXA0VmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDgsIHZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBWaWRlby53ZWJtVmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDlcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgVmlkZW8udnA5VmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LmNhblBsYXlUeXBlKCdhcHBsaWNhdGlvbi94LW1wZWdVUkw7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKS5yZXBsYWNlKC9ebm8kLywgJycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFZpZGVvLmhsc1ZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIC8vICBOb3RoaW5nIHRvIGRvXG4gICAgfVxuXG4gICAgcmV0dXJuIFZpZGVvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RldmljZS9WaWRlby5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RldmljZS9WaWRlby5qcyIsIi8vICBUaGlzIHNpbmdsZXRvbiBpcyBpbnN0YW50aWF0ZWQgYXMgc29vbiBhcyBQaGFzZXIgbG9hZHMsXG4vLyAgYmVmb3JlIGEgUGhhc2VyLkdhbWUgaW5zdGFuY2UgaGFzIGV2ZW4gYmVlbiBjcmVhdGVkLlxuLy8gIFdoaWNoIG1lYW5zIGFsbCBpbnN0YW5jZXMgb2YgUGhhc2VyIEdhbWVzIGNhbiBzaGFyZSBpdCxcbi8vICB3aXRob3V0IGhhdmluZyB0byByZS1wb2xsIHRoZSBkZXZpY2UgYWxsIG92ZXIgYWdhaW5cblxudmFyIE9TID0gcmVxdWlyZSgnLi9PUycpO1xudmFyIEJyb3dzZXIgPSByZXF1aXJlKCcuL0Jyb3dzZXInKTtcbnZhciBGZWF0dXJlcyA9IHJlcXVpcmUoJy4vRmVhdHVyZXMnKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vSW5wdXQnKTtcbnZhciBBdWRpbyA9IHJlcXVpcmUoJy4vQXVkaW8nKTtcbnZhciBWaWRlbyA9IHJlcXVpcmUoJy4vVmlkZW8nKTtcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9GdWxsc2NyZWVuJyk7XG52YXIgQ2FudmFzRmVhdHVyZXMgPSByZXF1aXJlKCcuL0NhbnZhc0ZlYXR1cmVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgT1M6IE9TLFxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXG4gICAgRmVhdHVyZXM6IEZlYXR1cmVzLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBBdWRpbzogQXVkaW8sXG4gICAgVmlkZW86IFZpZGVvLFxuICAgIEZ1bGxzY3JlZW46IEZ1bGxzY3JlZW4sXG4gICAgQ2FudmFzRmVhdHVyZXM6IENhbnZhc0ZlYXR1cmVzXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kZXZpY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kZXZpY2UvaW5kZXguanMiLCJ2YXIgQWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbntcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkRXZlbnRMaXN0ZW5lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9BZGRFdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgbGlzdGVuZXIpXG57XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9SZW1vdmVFdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlbW92ZUZyb21ET00gPSBmdW5jdGlvbiAoZWxlbWVudClcbntcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKVxuICAgIHtcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRnJvbURPTTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2RvbS9SZW1vdmVGcm9tRE9NLmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFNldHMgdGhlIHRvdWNoLWFjdGlvbiBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHN0eWxlLiBDYW4gYmUgdXNlZCB0byBkaXNhYmxlIGRlZmF1bHQgYnJvd3NlciB0b3VjaCBhY3Rpb25zLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuVG91Y2hBY3Rpb25cbiogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0byBzZXQgdGhlIHRvdWNoIGFjdGlvbiBvbi5cbiogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBUaGUgdG91Y2ggYWN0aW9uIHRvIHNldC4gRGVmYXVsdHMgdG8gJ25vbmUnLlxuKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHNvdXJjZSBjYW52YXMuXG4qL1xudmFyIFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gKGNhbnZhcywgdmFsdWUpXG57XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHsgdmFsdWUgPSAnbm9uZSc7IH1cblxuICAgIGNhbnZhcy5zdHlsZVsnbXNUb3VjaEFjdGlvbiddID0gdmFsdWU7XG4gICAgY2FudmFzLnN0eWxlWydtcy10b3VjaC1hY3Rpb24nXSA9IHZhbHVlO1xuICAgIGNhbnZhcy5zdHlsZVsndG91Y2gtYWN0aW9uJ10gPSB2YWx1ZTtcblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvdWNoQWN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZG9tL1RvdWNoQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFNldHMgdGhlIHVzZXItc2VsZWN0IHByb3BlcnR5IG9uIHRoZSBjYW52YXMgc3R5bGUuIENhbiBiZSB1c2VkIHRvIGRpc2FibGUgZGVmYXVsdCBicm93c2VyIHNlbGVjdGlvbiBhY3Rpb25zLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5DYW52YXMuc2V0VXNlclNlbGVjdFxuKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIHRvIHNldCB0aGUgdG91Y2ggYWN0aW9uIG9uLlxuKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIFRoZSB0b3VjaCBhY3Rpb24gdG8gc2V0LiBEZWZhdWx0cyB0byAnbm9uZScuXG4qIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgc291cmNlIGNhbnZhcy5cbiovXG52YXIgVXNlclNlbGVjdCA9IGZ1bmN0aW9uIChjYW52YXMsIHZhbHVlKVxue1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHZhbHVlID0gJ25vbmUnOyB9XG5cbiAgICB2YXIgdmVuZG9ycyA9IFtcbiAgICAgICAgJy13ZWJraXQtJyxcbiAgICAgICAgJy1raHRtbC0nLFxuICAgICAgICAnLW1vei0nLFxuICAgICAgICAnLW1zLScsXG4gICAgICAgICcnXG4gICAgXTtcblxuICAgIHZlbmRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmVuZG9yKVxuICAgIHtcbiAgICAgICAgY2FudmFzLnN0eWxlW3ZlbmRvciArICd1c2VyLXNlbGVjdCddID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBjYW52YXMuc3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gdmFsdWU7XG4gICAgY2FudmFzLnN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsIDAsIDAsIDApJztcblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJTZWxlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9kb20vVXNlclNlbGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9FdmVudExpc3RlbmVyJyk7XG5cbnZhciBFdmVudEJpbmRpbmcgPSBmdW5jdGlvbiAoZGlzcGF0Y2hlciwgdHlwZSlcbntcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcbiAgICB0aGlzLmFjdGl2ZSA9IFtdO1xufTtcblxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50QmluZGluZztcblxuRXZlbnRCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgIHRvdGFsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgIT09IENPTlNULkxJU1RFTkVSX1JFTU9WSU5HKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiAoY2FsbGJhY2spXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0KGNhbGxiYWNrKSk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSlcbiAgICB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcblxuICAgICAgICBpZiAoIWxpc3RlbmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhlIGxpc3RlbmVyIGRvZXNuJ3QgZXhpc3QsIHNvIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgIGxpc3RlbmVyID0gRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsIGNhbGxiYWNrLCBwcmlvcml0eSwgb25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgTGlzdGVuZXIgYWxyZWFkeSBleGlzdHMsIGFib3J0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgVGhlIERpc3BhdGNoZXIgaXNuJ3QgZG9pbmcgYW55dGhpbmcsIHNvIHdlIGRvbid0IG5lZWQgYSBwZW5kaW5nIHN0YXRlXG4gICAgICAgICAgICBsaXN0ZW5lci5zdGF0ZSA9IENPTlNULkxJU1RFTkVSX0FDVElWRTtcblxuICAgICAgICAgICAgdGhpcy5hY3RpdmUucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvcnQodGhpcy5zb3J0SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEFkZCBpdCB0byB0aGUgbGlzdCwgYnV0IGtlZXAgdGhlIHN0YXRlIGFzIHBlbmRpbmcuXG4gICAgICAgICAgICAvLyAgVGhlIGNhbGwgdG8gJ3RpZHknIHdpbGwgc29ydCBpdCBvdXQgYXQgdGhlIGVuZCBvZiB0aGUgZGlzcGF0Y2guXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzb3J0SGFuZGxlcjogZnVuY3Rpb24gKGxpc3RlbmVyQSwgbGlzdGVuZXJCKVxuICAgIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA8IGxpc3RlbmVyQS5wcmlvcml0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RlbmVyQi5wcmlvcml0eSA+IGxpc3RlbmVyQS5wcmlvcml0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGUgRGlzcGF0Y2hlciBpc24ndCBkb2luZyBhbnl0aGluZywgc28gd2UgY2FuIHJlbW92ZSByaWdodCBhd2F5XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIFRoZSBEaXNwYXRjaGVyIGlzIHdvcmtpbmcsIHNvIHdlIGZsYWcgdGhlIGxpc3RlbmVyIGZvciByZW1vdmFsIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0KGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnN0YXRlID0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0lETEUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IEZhaWxlZCB0byBleGVjdXRlIFxcJ0V2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaFxcJyBvbiBcXCcnICsgdGhpcy50eXBlICsgJ1xcJzogVGhlIGV2ZW50IGlzIGFscmVhZHkgYmVpbmcgZGlzcGF0Y2hlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGlzIHdhcyBhIHZhbGlkIGRpc3BhdGNoIGNhbGwsIHdlIGp1c3QgaGFkIG5vdGhpbmcgdG8gZG8gLi4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gQ09OU1QuRElTUEFUQ0hFUl9ESVNQQVRDSElORztcblxuICAgICAgICB2YXIgbGlzdGVuZXI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSB0aGlzLmFjdGl2ZVtpXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnN0YXRlICE9PSBDT05TVC5MSVNURU5FUl9BQ1RJVkUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcy5kaXNwYXRjaGVyLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vICBIYXMgdGhlIGNhbGxiYWNrIGNoYW5nZWQgdGhlIHN0YXRlIG9mIHRoaXMgYmluZGluZz9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDT05TVC5ESVNQQVRDSEVSX0RJU1BBVENISU5HKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBZdXAhIExldCdzIGJyZWFrIG91dFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgV2FzIGl0IGEgJ29uY2UnIGxpc3RlbmVyP1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc3RhdGUgPSBDT05TVC5MSVNURU5FUl9SRU1PVklORztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIEhhcyB0aGUgZXZlbnQgYmVlbiBoYWx0ZWQgYnkgdGhlIGNhbGxiYWNrP1xuICAgICAgICAgICAgaWYgKCFldmVudC5fcHJvcGFnYXRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBCcmVhayBvdXQsIGEgbGlzdGVuZXIgaGFzIGNhbGxlZCBFdmVudC5zdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBEaXNwYXRjaCBvdmVyLCBvciBhYm9ydGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDT05TVC5ESVNQQVRDSEVSX1JFTU9WSU5HKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICAvLyAgQWxsIGRvbmUsIHRpZHkgdGhlIGxpc3QgaW4gY2FzZSB0aGVyZSB3ZXJlIGFueSBwZW5kaW5nIGV2ZW50cyBhZGRlZFxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9ERVNUUk9ZRUQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5kZWxldGUodGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBBbGwgZG9uZSwganVzdCBwdXJnZSB0aGUgbGlzdFxuICAgICAgICAgICAgdGhpcy50aWR5KCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDT05TVC5ESVNQQVRDSEVSX0lETEU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgIC8vICBJZiB0aGlzIGlzIGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIHRoZW4gZG9uJ3QgcmVtb3ZlICdwZW5kaW5nJyBsaXN0ZW5lcnNcbiAgICAvLyAgKGkuZS4gb25lcyB0aGF0IHdlcmUgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaCksIG9ubHkgYWN0aXZlIG9uZXNcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ09OU1QuRElTUEFUQ0hFUl9JRExFKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSAhPT0gQ09OU1QuTElTVEVORVJfUEVORElORylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfSURMRTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0aWR5OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gIE5vdGhpbmcgdG8gZG8gLi4uXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhZGRlZCA9IDA7XG5cbiAgICAgICAgdmFyIGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGRvXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVtpXS5zdGF0ZSA9PT0gQ09OU1QuTElTVEVORVJfUkVNT1ZJTkcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX1BFTkRJTkcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IENPTlNULkxJU1RFTkVSX0FDVElWRTtcbiAgICAgICAgICAgICAgICBhZGRlZCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPj0gMCk7XG5cbiAgICAgICAgaWYgKGFkZGVkID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUuc29ydCh0aGlzLnNvcnRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTlNULkRJU1BBVENIRVJfREVTVFJPWUVEO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEJpbmRpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnRCaW5kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXZlbnRzL0V2ZW50QmluZGluZy5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2ssIHByaW9yaXR5LCBvbmNlKVxue1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICBvbmNlOiBvbmNlLFxuICAgICAgICBzdGF0ZTogQ09OU1QuTElTVEVORVJfUEVORElOR1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ldmVudHMvRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2V2ZW50cy9FdmVudExpc3RlbmVyLmpzIiwiZnVuY3Rpb24gZ2V0VmFsdWUgKG5vZGUsIGF0dHJpYnV0ZSlcbntcbiAgICByZXR1cm4gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSwgMTApO1xufVxuXG52YXIgUGFyc2VYTUxCaXRtYXBGb250ID0gZnVuY3Rpb24gKHhtbCwgeFNwYWNpbmcsIHlTcGFjaW5nLCBmcmFtZSlcbntcbiAgICBpZiAoeFNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyB4U3BhY2luZyA9IDA7IH1cbiAgICBpZiAoeVNwYWNpbmcgPT09IHVuZGVmaW5lZCkgeyB5U3BhY2luZyA9IDA7IH1cblxuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyIGluZm8gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2luZm8nKVswXTtcbiAgICB2YXIgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcblxuICAgIGRhdGEuZm9udCA9IGluZm8uZ2V0QXR0cmlidXRlKCdmYWNlJyk7XG4gICAgZGF0YS5zaXplID0gZ2V0VmFsdWUoaW5mbywgJ3NpemUnKTtcbiAgICBkYXRhLmxpbmVIZWlnaHQgPSBnZXRWYWx1ZShjb21tb24sICdsaW5lSGVpZ2h0JykgKyB5U3BhY2luZztcbiAgICBkYXRhLmNoYXJzID0ge307XG5cbiAgICB2YXIgbGV0dGVycyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpO1xuXG4gICAgdmFyIHggPSAoZnJhbWUpID8gZnJhbWUueCA6IDA7XG4gICAgdmFyIHkgPSAoZnJhbWUpID8gZnJhbWUueSA6IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgbm9kZSA9IGxldHRlcnNbaV07XG5cbiAgICAgICAgdmFyIGNoYXJDb2RlID0gZ2V0VmFsdWUobm9kZSwgJ2lkJyk7XG4gICAgICAgIHZhciBndyA9IGdldFZhbHVlKG5vZGUsICd3aWR0aCcpO1xuICAgICAgICB2YXIgZ2ggPSBnZXRWYWx1ZShub2RlLCAnaGVpZ2h0Jyk7XG5cbiAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPVxuICAgICAgICB7XG4gICAgICAgICAgICB4OiB4ICsgZ2V0VmFsdWUobm9kZSwgJ3gnKSxcbiAgICAgICAgICAgIHk6IHkgKyBnZXRWYWx1ZShub2RlLCAneScpLFxuICAgICAgICAgICAgd2lkdGg6IGd3LFxuICAgICAgICAgICAgaGVpZ2h0OiBnaCxcbiAgICAgICAgICAgIGNlbnRlclg6IE1hdGguZmxvb3IoZ3cgLyAyKSxcbiAgICAgICAgICAgIGNlbnRlclk6IE1hdGguZmxvb3IoZ2ggLyAyKSxcbiAgICAgICAgICAgIHhPZmZzZXQ6IGdldFZhbHVlKG5vZGUsICd4b2Zmc2V0JyksXG4gICAgICAgICAgICB5T2Zmc2V0OiBnZXRWYWx1ZShub2RlLCAneW9mZnNldCcpLFxuICAgICAgICAgICAgeEFkdmFuY2U6IGdldFZhbHVlKG5vZGUsICd4YWR2YW5jZScpICsgeFNwYWNpbmcsXG4gICAgICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBrZXJuaW5ncyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgna2VybmluZycpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtlcm5pbmdzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGtlcm4gPSBrZXJuaW5nc1tpXTtcblxuICAgICAgICB2YXIgZmlyc3QgPSBnZXRWYWx1ZShrZXJuLCAnZmlyc3QnKTtcbiAgICAgICAgdmFyIHNlY29uZCA9IGdldFZhbHVlKGtlcm4sICdzZWNvbmQnKTtcbiAgICAgICAgdmFyIGFtb3VudCA9IGdldFZhbHVlKGtlcm4sICdhbW91bnQnKTtcblxuICAgICAgICBkYXRhLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlWE1MQml0bWFwRm9udDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvUGFyc2VYTUxCaXRtYXBGb250LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIER5bmFtaWNCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzIHx8IHRleHRMZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBzcmMuZnJhbWU7XG5cbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcblxuICAgIHZhciBjYW1lcmFTY3JvbGxYID0gY2FtZXJhLnNjcm9sbFg7XG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcblxuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcbiAgICB2YXIgbGluZUhlaWdodCA9IHNyYy5mb250RGF0YS5saW5lSGVpZ2h0O1xuXG4gICAgdmFyIHhBZHZhbmNlID0gMDtcbiAgICB2YXIgeUFkdmFuY2UgPSAwO1xuXG4gICAgdmFyIGluZGV4Q291bnQgPSAwO1xuICAgIHZhciBjaGFyQ29kZSA9IDA7XG5cbiAgICB2YXIgZ2x5cGggPSBudWxsO1xuICAgIHZhciBnbHlwaFggPSAwO1xuICAgIHZhciBnbHlwaFkgPSAwO1xuICAgIHZhciBnbHlwaFcgPSAwO1xuICAgIHZhciBnbHlwaEggPSAwO1xuXG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcblxuICAgIHZhciBsYXN0R2x5cGggPSBudWxsO1xuICAgIHZhciBsYXN0Q2hhckNvZGUgPSAwO1xuXG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmN1cnJlbnRDb250ZXh0O1xuICAgIHZhciBpbWFnZSA9IHNyYy5mcmFtZS5zb3VyY2UuaW1hZ2U7XG5cbiAgICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlRnJhbWUuY3V0WDtcbiAgICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlRnJhbWUuY3V0WTtcblxuICAgIHZhciByb3RhdGlvbiA9IDA7XG4gICAgdmFyIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcblxuICAgIC8vICBCbGVuZCBNb2RlXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgIT09IHNyYy5ibGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbc3JjLmJsZW5kTW9kZV07XG4gICAgfVxuXG4gICAgLy8gIEFscGhhXG4gICAgaWYgKHJlbmRlcmVyLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEFscGhhID0gc3JjLmFscGhhO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XG4gICAgfVxuXG4gICAgLy8gIFNtb290aGluZ1xuICAgIGlmIChyZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHNyYy5zY2FsZU1vZGU7XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54LCBzcmMueSk7XG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxuICAgIHtcbiAgICAgICAgLy8gIFJlc2V0IHRoZSBzY2FsZSAoaW4gY2FzZSB0aGUgY2FsbGJhY2sgY2hhbmdlZCBpdClcbiAgICAgICAgc2NhbGUgPSAoc3JjLmZvbnRTaXplIC8gc3JjLmZvbnREYXRhLnNpemUpO1xuICAgICAgICByb3RhdGlvbiA9IDA7XG5cbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XG5cbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcblxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcbiAgICAgICAgeSA9IGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZTtcblxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNwbGF5Q2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBkaXNwbGF5Q2FsbGJhY2soeyBpbmRleDogaW5kZXgsIGNoYXJDb2RlOiBjaGFyQ29kZSwgeDogeCwgeTogeSwgc2NhbGU6IHNjYWxlLCByb3RhdGlvbjogMCB9KTtcblxuICAgICAgICAgICAgeCA9IG91dHB1dC54O1xuICAgICAgICAgICAgeSA9IG91dHB1dC55O1xuICAgICAgICAgICAgc2NhbGUgPSBvdXRwdXQuc2NhbGU7XG4gICAgICAgICAgICByb3RhdGlvbiA9IG91dHB1dC5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHggKj0gc2NhbGU7XG4gICAgICAgIHkgKj0gc2NhbGU7XG5cbiAgICAgICAgeCAtPSBjYW1lcmFTY3JvbGxYO1xuICAgICAgICB5IC09IGNhbWVyYVNjcm9sbFk7XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4gICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDI1NSwwLDAuMiknO1xuICAgICAgICAvLyBjdHguZmlsbFJlY3QoMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGdseXBoWCwgZ2x5cGhZLCBnbHlwaFcsIGdseXBoSCwgMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIFxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dENhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJpdG1hcFRleHQgPSByZXF1aXJlKCcuL0R5bmFtaWNCaXRtYXBUZXh0Jyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIER5bmFtaWNCaXRtYXBUZXh0RmFjdG9yeSA9IHtcblxuICAgIEtFWTogJ2R5bmFtaWNCaXRtYXBUZXh0JyxcblxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRyZW4uYWRkKG5ldyBCaXRtYXBUZXh0KHRoaXMuc3RhdGUsIHgsIHksIGZvbnQsIHRleHQsIHNpemUsIGFsaWduKSk7XG4gICAgfSxcblxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQml0bWFwVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbik7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvZHluYW1pYy9EeW5hbWljQml0bWFwVGV4dEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRGYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vRHluYW1pY0JpdG1hcFRleHRDYW52YXNSZW5kZXJlcicpLFxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0R5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlcicpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRSZW5kZXIuanMiLCJ2YXIgVHJhbnNmb3JtTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29tcG9uZW50cy9UcmFuc2Zvcm1NYXRyaXgnKTtcbnZhciB0ZW1wTWF0cml4ID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xudmFyIHRlbXBNYXRyaXhDaGFyID0gbmV3IFRyYW5zZm9ybU1hdHJpeCgpO1xuXG52YXIgRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGxheUNhbGxiYWNrID0gc3JjLmRpc3BsYXlDYWxsYmFjaztcbiAgICB2YXIgdGV4dHVyZUZyYW1lID0gc3JjLmZyYW1lO1xuICAgIHZhciBjYW1lcmFTY3JvbGxYID0gY2FtZXJhLnNjcm9sbFg7XG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIGNoYXJzID0gc3JjLmZvbnREYXRhLmNoYXJzO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gc3JjLmZvbnREYXRhLmxpbmVIZWlnaHQ7XG4gICAgdmFyIGJsaXR0ZXJCYXRjaCA9IHJlbmRlcmVyLmJsaXR0ZXJCYXRjaDtcbiAgICB2YXIgYWxwaGEgPSBzcmMuYWxwaGE7XG4gICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBibGl0dGVyQmF0Y2gudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICB2YXIgdmVydGV4QnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XG4gICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XG4gICAgdmFyIHNyY1ggPSBzcmMueDsgXG4gICAgdmFyIHNyY1kgPSBzcmMueTtcbiAgICB2YXIgdGV4dHVyZURhdGEgPSBzcmMudGV4dHVyZS5zb3VyY2VbdGV4dHVyZUZyYW1lLnNvdXJjZUluZGV4XTtcbiAgICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlRnJhbWUuY3V0WDtcbiAgICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlRnJhbWUuY3V0WTtcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gdGV4dHVyZURhdGEud2lkdGg7XG4gICAgdmFyIHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlRGF0YS5oZWlnaHQ7XG4gICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlRGF0YS5nbFRleHR1cmU7XG4gICAgdmFyIHhBZHZhbmNlID0gMDtcbiAgICB2YXIgeUFkdmFuY2UgPSAwO1xuICAgIHZhciBpbmRleENvdW50ID0gMDtcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xuICAgIHZhciBnbHlwaCA9IG51bGw7XG4gICAgdmFyIGdseXBoWCA9IDA7XG4gICAgdmFyIGdseXBoWSA9IDA7XG4gICAgdmFyIGdseXBoVyA9IDA7XG4gICAgdmFyIGdseXBoSCA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgeHcgPSAwO1xuICAgIHZhciB5aCA9IDA7XG4gICAgdmFyIHR4ID0gMDtcbiAgICB2YXIgdHkgPSAwO1xuICAgIHZhciB0eHcgPSAwO1xuICAgIHZhciB0eWggPSAwO1xuICAgIHZhciB1bWluID0gMDtcbiAgICB2YXIgdW1heCA9IDA7XG4gICAgdmFyIHZtaW4gPSAwO1xuICAgIHZhciB2bWF4ID0gMDtcbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcbiAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xuICAgIHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4Lm1hdHJpeDtcbiAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XG4gICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XG4gICAgdmFyIHNjYWxlID0gKHNyYy5mb250U2l6ZSAvIHNyYy5mb250RGF0YS5zaXplKTtcbiAgICB2YXIgdXRhLCB1dGIsIHV0YywgdXRkLCB1dGUsIHV0ZjtcbiAgICB2YXIgdGVtcE1hdHJpeENoYXJNYXRyaXggPSB0ZW1wTWF0cml4Q2hhci5tYXRyaXg7XG5cbiAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyhcbiAgICAgICAgc3JjLnggLSBjYW1lcmFTY3JvbGxYLCBzcmMueSAtIGNhbWVyYVNjcm9sbFksIFxuICAgICAgICAtc3JjLnJvdGF0aW9uLCBcbiAgICAgICAgc3JjLnNjYWxlWCwgc3JjLnNjYWxlWVxuICAgICk7XG5cbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XG4gICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XG4gICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcblxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcbiAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcbiAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xuXG4gICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XG4gICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcbiAgICB7XG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcbiAgICAgICAge1xuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XG4gICAgICAgICAgICB5QWR2YW5jZSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XG4gICAgICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xuICAgICAgICBnbHlwaEggPSBnbHlwaC5oZWlnaHQ7XG4gICAgICAgIHggPSAoaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZSkgKiBzY2FsZTtcbiAgICAgICAgeSA9IChnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2UpICogc2NhbGU7XG5cbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzcGxheUNhbGxiYWNrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZGlzcGxheUNhbGxiYWNrKHsgaW5kZXg6IGluZGV4LCBjaGFyQ29kZTogY2hhckNvZGUsIHg6IHgsIHk6IHksIHNjYWxlOiBzY2FsZSwgcm90YXRpb246IDAgfSk7XG5cbiAgICAgICAgICAgIHggPSBvdXRwdXQueDtcbiAgICAgICAgICAgIHkgPSBvdXRwdXQueTtcbiAgICAgICAgICAgIHNjYWxlID0gb3V0cHV0LnNjYWxlO1xuICAgICAgICAgICAgcm90YXRpb24gPSBvdXRwdXQucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wTWF0cml4Q2hhci5hcHBseUlUUlMoXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgLXJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGUsIHNjYWxlXG4gICAgICAgICk7XG5cbiAgICAgICAgdXRhID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbMF07XG4gICAgICAgIHV0YiA9IHRlbXBNYXRyaXhDaGFyTWF0cml4WzFdO1xuICAgICAgICB1dGMgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFsyXTtcbiAgICAgICAgdXRkID0gdGVtcE1hdHJpeENoYXJNYXRyaXhbM107XG4gICAgICAgIHV0ZSA9IHRlbXBNYXRyaXhDaGFyTWF0cml4WzRdO1xuICAgICAgICB1dGYgPSB0ZW1wTWF0cml4Q2hhck1hdHJpeFs1XTtcblxuICAgICAgICBzcmEgPSB1dGEgKiBtdmEgKyB1dGIgKiBtdmM7XG4gICAgICAgIHNyYiA9IHV0YSAqIG12YiArIHV0YiAqIG12ZDtcbiAgICAgICAgc3JjID0gdXRjICogbXZhICsgdXRkICogbXZjO1xuICAgICAgICBzcmQgPSB1dGMgKiBtdmIgKyB1dGQgKiBtdmQ7XG4gICAgICAgIHNyZSA9IHV0ZSAqIG12YSArIHV0ZiAqIG12YyArIG12ZTtcbiAgICAgICAgc3JmID0gdXRlICogbXZiICsgdXRmICogbXZkICsgbXZmO1xuXG4gICAgICAgIHh3ID0gZ2x5cGhXO1xuICAgICAgICB5aCA9IGdseXBoSDtcbiAgICAgICAgdHgwID0gc3JlO1xuICAgICAgICB0eTAgPSBzcmY7XG4gICAgICAgIHR4MSA9IHloICogc3JjICsgc3JlO1xuICAgICAgICB0eTEgPSB5aCAqIHNyZCArIHNyZjtcbiAgICAgICAgdHgyID0geHcgKiBzcmEgKyB5aCAqIHNyYyArIHNyZTtcbiAgICAgICAgdHkyID0geHcgKiBzcmIgKyB5aCAqIHNyZCArIHNyZjtcbiAgICAgICAgdHgzID0geHcgKiBzcmEgKyBzcmU7XG4gICAgICAgIHR5MyA9IHh3ICogc3JiICsgc3JmO1xuICAgICAgICB1bWluID0gZ2x5cGhYIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgICB1bWF4ID0gKGdseXBoWCArIGdseXBoVykgLyB0ZXh0dXJlV2lkdGg7XG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xuICAgICAgICB2bWF4ID0gKGdseXBoWSArIGdseXBoSCkgLyB0ZXh0dXJlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ID49IGJsaXR0ZXJCYXRjaC5tYXhQYXJ0aWNsZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJsaXR0ZXJCYXRjaC5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmF0Y2goYmxpdHRlckJhdGNoLCB0ZXh0dXJlKTtcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyMCk7XG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljQml0bWFwVGV4dFdlYkdMUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L2R5bmFtaWMvRHluYW1pY0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9keW5hbWljL0R5bmFtaWNCaXRtYXBUZXh0V2ViR0xSZW5kZXJlci5qcyIsInZhciBCaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICB2YXIgdGV4dCA9IHNyYy50ZXh0O1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzIHx8IHRleHRMZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciB0ZXh0dXJlRnJhbWUgPSBzcmMuZnJhbWU7XG5cbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XG5cbiAgICB2YXIgY2hhcnMgPSBzcmMuZm9udERhdGEuY2hhcnM7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBzcmMuZm9udERhdGEubGluZUhlaWdodDtcblxuICAgIHZhciB4QWR2YW5jZSA9IDA7XG4gICAgdmFyIHlBZHZhbmNlID0gMDtcblxuICAgIHZhciBpbmRleENvdW50ID0gMDtcbiAgICB2YXIgY2hhckNvZGUgPSAwO1xuXG4gICAgdmFyIGdseXBoID0gbnVsbDtcbiAgICB2YXIgZ2x5cGhYID0gMDtcbiAgICB2YXIgZ2x5cGhZID0gMDtcbiAgICB2YXIgZ2x5cGhXID0gMDtcbiAgICB2YXIgZ2x5cGhIID0gMDtcblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG5cbiAgICB2YXIgbGFzdEdseXBoID0gbnVsbDtcbiAgICB2YXIgbGFzdENoYXJDb2RlID0gMDtcblxuICAgIHZhciBjdHggPSByZW5kZXJlci5jdXJyZW50Q29udGV4dDtcbiAgICB2YXIgaW1hZ2UgPSBzcmMuZnJhbWUuc291cmNlLmltYWdlO1xuXG4gICAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUZyYW1lLmN1dFg7XG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XG5cbiAgICB2YXIgcm90YXRpb24gPSAwO1xuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XG5cbiAgICAvLyAgQmxlbmQgTW9kZVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xuICAgIH1cblxuICAgIC8vICBBbHBoYVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xuICAgIH1cblxuICAgIC8vICBTbW9vdGhpbmdcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShzcmMueCAtIGNhbWVyYVNjcm9sbFgsIHNyYy55IC0gY2FtZXJhU2Nyb2xsWSk7XG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0TGVuZ3RoOyArK2luZGV4KVxuICAgIHtcbiAgICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gMTApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHhBZHZhbmNlID0gMDtcbiAgICAgICAgICAgIGluZGV4Q291bnQgPSAwO1xuICAgICAgICAgICAgeUFkdmFuY2UgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGxhc3RHbHlwaCA9IG51bGw7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoID0gY2hhcnNbY2hhckNvZGVdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XG5cbiAgICAgICAgZ2x5cGhXID0gZ2x5cGgud2lkdGg7XG4gICAgICAgIGdseXBoSCA9IGdseXBoLmhlaWdodDtcblxuICAgICAgICB4ID0gaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZTtcbiAgICAgICAgeSA9IGdseXBoLnlPZmZzZXQgKyB5QWR2YW5jZTtcblxuICAgICAgICBpZiAobGFzdEdseXBoICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIga2VybmluZ09mZnNldCA9IGdseXBoLmtlcm5pbmdbbGFzdENoYXJDb2RlXTtcbiAgICAgICAgICAgIHggKz0gKGtlcm5pbmdPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBrZXJuaW5nT2Zmc2V0IDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHggKj0gc2NhbGU7XG4gICAgICAgIHkgKj0gc2NhbGU7XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGdseXBoWCwgZ2x5cGhZLCBnbHlwaFcsIGdseXBoSCwgMCwgMCwgZ2x5cGhXLCBnbHlwaEgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBcbiAgICAgICAgeEFkdmFuY2UgKz0gZ2x5cGgueEFkdmFuY2U7XG4gICAgICAgIGluZGV4Q291bnQgKz0gMTtcbiAgICAgICAgbGFzdEdseXBoID0gZ2x5cGg7XG4gICAgICAgIGxhc3RDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHRDYW52YXNSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaXRtYXBUZXh0ID0gcmVxdWlyZSgnLi9CaXRtYXBUZXh0Jyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIEJpdG1hcFRleHRGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnYml0bWFwVGV4dCcsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbilcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkcmVuLmFkZChuZXcgQml0bWFwVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCBmb250LCB0ZXh0LCBzaXplLCBhbGlnbikpO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEJpdG1hcFRleHQodGhpcy5zdGF0ZSwgeCwgeSwgZm9udCwgdGV4dCwgc2l6ZSwgYWxpZ24pO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKEJpdG1hcFRleHRGYWN0b3J5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dEZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9CaXRtYXBUZXh0Q2FudmFzUmVuZGVyZXInKSxcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9CaXRtYXBUZXh0V2ViR0xSZW5kZXJlcicpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9iaXRtYXB0ZXh0L3N0YXRpYy9CaXRtYXBUZXh0UmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFJlbmRlci5qcyIsInZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xudmFyIHRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XG5cbnZhciBCaXRtYXBUZXh0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmVGcmFtZSA9IHNyYy5mcmFtZTtcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XG4gICAgdmFyIHRleHQgPSBzcmMudGV4dDtcbiAgICB2YXIgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIHZhciBjaGFycyA9IHNyYy5mb250RGF0YS5jaGFycztcbiAgICB2YXIgbGluZUhlaWdodCA9IHNyYy5mb250RGF0YS5saW5lSGVpZ2h0O1xuICAgIHZhciBibGl0dGVyQmF0Y2ggPSByZW5kZXJlci5ibGl0dGVyQmF0Y2g7XG4gICAgdmFyIGFscGhhID0gc3JjLmFscGhhO1xuICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gYmxpdHRlckJhdGNoLnZlcnRleERhdGFCdWZmZXI7XG4gICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSAwO1xuICAgIHZhciBzcmNYID0gc3JjLng7IFxuICAgIHZhciBzcmNZID0gc3JjLnk7XG4gICAgdmFyIHRleHR1cmVEYXRhID0gc3JjLnRleHR1cmUuc291cmNlW3RleHR1cmVGcmFtZS5zb3VyY2VJbmRleF07XG4gICAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUZyYW1lLmN1dFg7XG4gICAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUZyYW1lLmN1dFk7XG4gICAgdmFyIHRleHR1cmVXaWR0aCA9IHRleHR1cmVEYXRhLndpZHRoO1xuICAgIHZhciB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZURhdGEuaGVpZ2h0O1xuICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZURhdGEuZ2xUZXh0dXJlO1xuICAgIHZhciB4QWR2YW5jZSA9IDA7XG4gICAgdmFyIHlBZHZhbmNlID0gMDtcbiAgICB2YXIgaW5kZXhDb3VudCA9IDA7XG4gICAgdmFyIGNoYXJDb2RlID0gMDtcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xuICAgIHZhciBnbHlwaFggPSAwO1xuICAgIHZhciBnbHlwaFkgPSAwO1xuICAgIHZhciBnbHlwaFcgPSAwO1xuICAgIHZhciBnbHlwaEggPSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHh3ID0gMDtcbiAgICB2YXIgeWggPSAwO1xuICAgIHZhciB0eCA9IDA7XG4gICAgdmFyIHR5ID0gMDtcbiAgICB2YXIgdHh3ID0gMDtcbiAgICB2YXIgdHloID0gMDtcbiAgICB2YXIgdW1pbiA9IDA7XG4gICAgdmFyIHVtYXggPSAwO1xuICAgIHZhciB2bWluID0gMDtcbiAgICB2YXIgdm1heCA9IDA7XG4gICAgdmFyIGxhc3RHbHlwaCA9IG51bGw7XG4gICAgdmFyIGxhc3RDaGFyQ29kZSA9IDA7XG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcbiAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XG4gICAgdmFyIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmYsIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTIsIHR4MywgdHkzO1xuICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xuICAgIHZhciBzY2FsZSA9IChzcmMuZm9udFNpemUgLyBzcmMuZm9udERhdGEuc2l6ZSk7XG5cbiAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyhcbiAgICAgICAgc3JjLnggLSBjYW1lcmFTY3JvbGxYLCBzcmMueSAtIGNhbWVyYVNjcm9sbFksIFxuICAgICAgICAtc3JjLnJvdGF0aW9uLCBcbiAgICAgICAgc3JjLnNjYWxlWCwgc3JjLnNjYWxlWVxuICAgICk7XG5cbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XG4gICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XG4gICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcblxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcbiAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcbiAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xuXG4gICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XG4gICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGV4dExlbmd0aDsgKytpbmRleClcbiAgICB7XG4gICAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMClcbiAgICAgICAge1xuICAgICAgICAgICAgeEFkdmFuY2UgPSAwO1xuICAgICAgICAgICAgaW5kZXhDb3VudCA9IDA7XG4gICAgICAgICAgICB5QWR2YW5jZSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGFzdEdseXBoID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGggPSBjaGFyc1tjaGFyQ29kZV07XG4gICAgICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhYID0gdGV4dHVyZVggKyBnbHlwaC54O1xuICAgICAgICBnbHlwaFkgPSB0ZXh0dXJlWSArIGdseXBoLnk7XG4gICAgICAgIGdseXBoVyA9IGdseXBoLndpZHRoO1xuICAgICAgICBnbHlwaEggPSBnbHlwaC5oZWlnaHQ7XG4gICAgICAgIHggPSAoaW5kZXhDb3VudCArIGdseXBoLnhPZmZzZXQgKyB4QWR2YW5jZSkgKiBzY2FsZTtcbiAgICAgICAgeSA9IChnbHlwaC55T2Zmc2V0ICsgeUFkdmFuY2UpICogc2NhbGU7XG5cbiAgICAgICAgaWYgKGxhc3RHbHlwaCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGtlcm5pbmdPZmZzZXQgPSBnbHlwaC5rZXJuaW5nW2xhc3RDaGFyQ29kZV07XG4gICAgICAgICAgICB4ICs9IChrZXJuaW5nT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8ga2VybmluZ09mZnNldCA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4dyA9IHggKyBnbHlwaFcgKiBzY2FsZTtcbiAgICAgICAgeWggPSB5ICsgZ2x5cGhIICogc2NhbGU7XG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcbiAgICAgICAgdHgxID0geCAqIG12YSArIHloICogbXZjICsgbXZlO1xuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XG4gICAgICAgIHR5MiA9IHh3ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xuICAgICAgICB1bWluID0gZ2x5cGhYIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgICB1bWF4ID0gKGdseXBoWCArIGdseXBoVykgLyB0ZXh0dXJlV2lkdGg7XG4gICAgICAgIHZtaW4gPSBnbHlwaFkgLyB0ZXh0dXJlSGVpZ2h0O1xuICAgICAgICB2bWF4ID0gKGdseXBoWSArIGdseXBoSCkgLyB0ZXh0dXJlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChibGl0dGVyQmF0Y2guZWxlbWVudENvdW50ID49IGJsaXR0ZXJCYXRjaC5tYXhQYXJ0aWNsZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJsaXR0ZXJCYXRjaC5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0QmF0Y2goYmxpdHRlckJhdGNoLCB0ZXh0dXJlKTtcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyMCk7XG4gICAgICAgIGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgKz0gNjtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1pbjtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHVtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB2bWF4O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1bWF4O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdm1heDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdW1heDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHZtaW47XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB4QWR2YW5jZSArPSBnbHlwaC54QWR2YW5jZTtcbiAgICAgICAgaW5kZXhDb3VudCArPSAxO1xuICAgICAgICBsYXN0R2x5cGggPSBnbHlwaDtcbiAgICAgICAgbGFzdENoYXJDb2RlID0gY2hhckNvZGU7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0V2ViR0xSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JpdG1hcHRleHQvc3RhdGljL0JpdG1hcFRleHRXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9zdGF0aWMvQml0bWFwVGV4dFdlYkdMUmVuZGVyZXIuanMiLCJcbnZhciBCbGl0dGVyQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXN0ID0gc3JjLmdldFJlbmRlckxpc3QoKTtcblxuICAgIHJlbmRlcmVyLnNldEJsZW5kTW9kZShzcmMuYmxlbmRNb2RlKTtcblxuICAgIHZhciBjYSA9IHJlbmRlcmVyLmN1cnJlbnRBbHBoYTtcblxuICAgIC8vICBSZW5kZXIgYm9ic1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBib2IgPSBsaXN0W2ldO1xuXG4gICAgICAgIGlmIChjYSAhPT0gYm9iLmFscGhhKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYSA9IHJlbmRlcmVyLnNldEFscGhhKGJvYi5hbHBoYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5ibGl0SW1hZ2UoYm9iLngsIGJvYi55LCBib2IuZnJhbWUsIGNhbWVyYSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbGl0dGVyQ2FudmFzUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIEJsaXR0ZXIgPSByZXF1aXJlKCcuL0JsaXR0ZXInKTtcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xuXG52YXIgQmxpdHRlckZhY3RvcnkgPSB7XG5cbiAgICBLRVk6ICdibGl0dGVyJyxcblxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUsIHBhcmVudClcbiAgICB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgeyBwYXJlbnQgPSB0aGlzLnN0YXRlOyB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IEJsaXR0ZXIodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSkpO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwga2V5LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQmxpdHRlcih0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihCbGl0dGVyRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JsaXR0ZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyRmFjdG9yeS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVuZGVyQ2FudmFzOiByZXF1aXJlKCcuL0JsaXR0ZXJDYW52YXNSZW5kZXJlcicpLFxuICAgIHJlbmRlcldlYkdMOiByZXF1aXJlKCcuL0JsaXR0ZXJXZWJHTFJlbmRlcmVyJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlclJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2JsaXR0ZXIvQmxpdHRlclJlbmRlci5qcyIsInZhciBCbGl0dGVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3QgPSBzcmMuZ2V0UmVuZGVyTGlzdCgpO1xuICAgIHZhciBibGl0dGVyQmF0Y2ggPSByZW5kZXJlci5ibGl0dGVyQmF0Y2g7XG4gICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xuICAgIHZhciBhID0gY2FtZXJhTWF0cml4WzBdO1xuICAgIHZhciBiID0gY2FtZXJhTWF0cml4WzFdO1xuICAgIHZhciBjID0gY2FtZXJhTWF0cml4WzJdO1xuICAgIHZhciBkID0gY2FtZXJhTWF0cml4WzNdO1xuICAgIHZhciBlID0gY2FtZXJhTWF0cml4WzRdO1xuICAgIHZhciBmID0gY2FtZXJhTWF0cml4WzVdO1xuICAgIHZhciBjYW1lcmFTY3JvbGxYID0gY2FtZXJhLnNjcm9sbFg7XG4gICAgdmFyIGNhbWVyYVNjcm9sbFkgPSBjYW1lcmEuc2Nyb2xsWTtcblxuICAgIC8vICBSZW5kZXIgYm9ic1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBib2IgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgZnJhbWUgPSBib2IuZnJhbWU7XG4gICAgICAgIHZhciBhbHBoYSA9IGJvYi5hbHBoYTtcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBibGl0dGVyQmF0Y2gudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHV2cyA9IGZyYW1lLnV2cztcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiAoYm9iLmZsaXBYID8gLTEgOiAxKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodCAqIChib2IuZmxpcFkgPyAtMSA6IDEpO1xuICAgICAgICB2YXIgeCA9IGJvYi54ICsgZnJhbWUueCAtIGNhbWVyYVNjcm9sbFggKyAoKGZyYW1lLndpZHRoKSAqIChib2IuZmxpcFggPyAxIDogMC4wKSk7XG4gICAgICAgIHZhciB5ID0gYm9iLnkgKyBmcmFtZS55IC0gY2FtZXJhU2Nyb2xsWSArICgoZnJhbWUuaGVpZ2h0KSAqIChib2IuZmxpcFkgPyAxIDogMC4wKSk7XG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcbiAgICAgICAgdmFyIHR4ID0geCAqIGEgKyB5ICogYyArIGU7XG4gICAgICAgIHZhciB0eSA9IHggKiBiICsgeSAqIGQgKyBmO1xuICAgICAgICB2YXIgdHh3ID0geHcgKiBhICsgeWggKiBjICsgZTtcbiAgICAgICAgdmFyIHR5aCA9IHh3ICogYiArIHloICogZCArIGY7XG5cbiAgICAgICAgaWYgKGJsaXR0ZXJCYXRjaC5lbGVtZW50Q291bnQgPj0gYmxpdHRlckJhdGNoLm1heFBhcnRpY2xlcylcbiAgICAgICAge1xuICAgICAgICAgICAgYmxpdHRlckJhdGNoLmZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5zZXRCYXRjaChibGl0dGVyQmF0Y2gsIGZyYW1lLnRleHR1cmUuc291cmNlW2ZyYW1lLnNvdXJjZUluZGV4XS5nbFRleHR1cmUpO1xuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDIwKTtcbiAgICAgICAgYmxpdHRlckJhdGNoLmVsZW1lbnRDb3VudCArPSA2O1xuICAgICAgICB4ICs9IGZyYW1lLng7XG4gICAgICAgIHkgKz0gZnJhbWUueTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHg7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHR5aDtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MTtcbiAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eHc7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB0eWg7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHh3O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gdHk7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDM7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTM7XG4gICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJsaXR0ZXJXZWJHTFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvYmxpdHRlci9CbGl0dGVyV2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb2IgPSBmdW5jdGlvbiAoYmxpdHRlciwgeCwgeSwgZnJhbWUsIHZpc2libGUpXG57XG4gICAgdGhpcy5wYXJlbnQgPSBibGl0dGVyO1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcblxuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuX2FscGhhID0gMTtcblxuICAgIHRoaXMuZmxpcFggLSBmYWxzZTtcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG5cbn07XG5cbkJvYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2I7XG5cbkJvYi5wcm90b3R5cGUgPSB7XG5cbiAgICByZXNldEZsaXA6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICB9LFxuXG5cbiAgICByZXNldDogZnVuY3Rpb24gKHgsIHksIGZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvYi5wcm90b3R5cGUsIHtcblxuICAgIHZpc2libGU6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGFscGhhOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb2I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ibGl0dGVyL0JvYi5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIENvbnRhaW5lckNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgUmVuZGVyIGNoaWxkcmVuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuY2hpbGRyZW4ubGlzdC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHNyYy5jaGlsZHJlbi5saXN0W2ldO1xuXG4gICAgICAgIGNoaWxkLnJlbmRlckNhbnZhcyhyZW5kZXJlciwgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyQ2FudmFzUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBDb250YWluZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lcicpO1xudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XG5cbnZhciBDb250YWluZXJGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnY29udGFpbmVyJyxcblxuICAgIGFkZDogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcbiAgICB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgeyBwYXJlbnQgPSB0aGlzLnN0YXRlOyB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IENvbnRhaW5lcih0aGlzLnN0YXRlLCBwYXJlbnQsIHgsIHkpKTtcbiAgICB9LFxuXG4gICAgbWFrZTogZnVuY3Rpb24gKHBhcmVudCwgeCwgeSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKHRoaXMuc3RhdGUsIHBhcmVudCwgeCwgeSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoQ29udGFpbmVyRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJGYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vQ29udGFpbmVyQ2FudmFzUmVuZGVyZXInKSxcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9Db250YWluZXJXZWJHTFJlbmRlcmVyJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9jb250YWluZXIvQ29udGFpbmVyUmVuZGVyLmpzIiwiXG52YXIgQ29udGFpbmVyV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gIFJlbmRlciBjaGlsZHJlblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjLmNoaWxkcmVuLmxpc3QubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSBzcmMuY2hpbGRyZW4ubGlzdFtpXTtcblxuICAgICAgICBjaGlsZC5yZW5kZXJXZWJHTChyZW5kZXJlciwgY2hpbGQsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyV2ViR0xSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2NvbnRhaW5lci9Db250YWluZXJXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xudmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG5cbnZhciBHcmFwaGljc0NhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XG4gICAgdmFyIHNyY1ggPSBzcmMueDtcbiAgICB2YXIgc3JjWSA9IHNyYy55O1xuICAgIHZhciBzcmNTY2FsZVggPSBzcmMuc2NhbGVYO1xuICAgIHZhciBzcmNTY2FsZVkgPSBzcmMuc2NhbGVZO1xuICAgIHZhciBzcmNSb3RhdGlvbiA9IHNyYy5yb3RhdGlvbjtcbiAgICB2YXIgY29tbWFuZEJ1ZmZlciA9IHNyYy5jb21tYW5kQnVmZmVyO1xuICAgIHZhciBjdHggPSByZW5kZXJlci5jdXJyZW50Q29udGV4dDtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGxpbmVBbHBoYSA9IDEuMDtcbiAgICB2YXIgZmlsbEFscGhhID0gMS4wO1xuICAgIHZhciBsaW5lQ29sb3IgPSAwO1xuICAgIHZhciBmaWxsQ29sb3IgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAxLjA7XG4gICAgdmFyIHJlZCA9IDA7XG4gICAgdmFyIGdyZWVuID0gMDtcbiAgICB2YXIgYmx1ZSA9IDA7XG5cbiAgICAvLyAgQmxlbmQgTW9kZVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xuICAgIH1cblxuICAgIC8vICBBbHBoYVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xuICAgIH1cblxuICAgIC8vICBTbW9vdGhpbmdcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShzcmNYIC0gY2FtZXJhU2Nyb2xsWCwgc3JjWSAtIGNhbWVyYVNjcm9sbFkpO1xuICAgIGN0eC5yb3RhdGUoc3JjUm90YXRpb24pO1xuICAgIGN0eC5zY2FsZShzcmNTY2FsZVgsIHNyY1NjYWxlWSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBzcmMuYWxwaGE7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGNvbW1hbmRCdWZmZXIubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBjb21tYW5kSUQgPSBjb21tYW5kQnVmZmVyW2luZGV4XTtcblxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmRJRClcbiAgICAgICAge1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5BUkM6XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgNV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyA2XVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX1NUWUxFOlxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBsaW5lQ29sb3IgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgbGluZUFscGhhID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICAgICAgICAgIHJlZCA9ICgobGluZUNvbG9yICYgMHhGRjAwMDApID4+PiAxNik7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSAoKGxpbmVDb2xvciAmIDB4RkYwMCkgPj4+IDgpO1xuICAgICAgICAgICAgICAgIGJsdWUgPSAobGluZUNvbG9yICYgMHhGRik7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcsJyArIGxpbmVBbHBoYSArICcpJztcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9TVFlMRTpcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgZmlsbEFscGhhID0gY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIHJlZCA9ICgoZmlsbENvbG9yICYgMHhGRjAwMDApID4+PiAxNik7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSAoKGZpbGxDb2xvciAmIDB4RkYwMCkgPj4+IDgpO1xuICAgICAgICAgICAgICAgIGJsdWUgPSAoZmlsbENvbG9yICYgMHhGRik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByZWQgKyAnLCcgKyBncmVlbiArICcsJyArIGJsdWUgKyAnLCcgKyBmaWxsQWxwaGEgKyAnKSc7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5CRUdJTl9QQVRIOlxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1BBVEg6XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVFJPS0VfUEFUSDpcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuRklMTF9SRUNUOlxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfVFJJQU5HTEU6XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDNdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNF0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDVdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgNl0pO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl0pO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RST0tFX1RSSUFOR0xFOlxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAzXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDRdKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyA1XSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDZdKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9UTzpcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5NT1ZFX1RPOlxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDJdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkxJTkVfRlhfVE86XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltpbmRleCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9GWF9UTzpcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2luZGV4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbaW5kZXggKyAyXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaGFzZXI6IEludmFsaWQgR3JhcGhpY3MgQ29tbWFuZCBJRCAnICsgY29tbWFuZElEKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzQ2FudmFzUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc0NhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NDYW52YXNSZW5kZXJlci5qcyIsInZhciBHcmFwaGljcyA9IHJlcXVpcmUoJy4vR3JhcGhpY3MnKTtcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xuXG52YXIgR3JhcGhpY3NGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnZ3JhcGhpY3MnLFxuXG4gICAgYWRkOiBmdW5jdGlvbiAob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkcmVuLmFkZChuZXcgR3JhcGhpY3ModGhpcy5zdGF0ZSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3ModGhpcy5zdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoR3JhcGhpY3NGYWN0b3J5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL2dyYXBoaWNzL0dyYXBoaWNzRmFjdG9yeS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVuZGVyQ2FudmFzOiByZXF1aXJlKCcuL0dyYXBoaWNzQ2FudmFzUmVuZGVyZXInKSxcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9HcmFwaGljc1dlYkdMUmVuZGVyZXInKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9ncmFwaGljcy9HcmFwaGljc1JlbmRlci5qcyIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xudmFyIHBhdGhBcnJheSA9IFtdO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgdGVtcE1hdHJpeCA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcblxudmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCByZ2IsIGFscGhhKVxue1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5yZ2IgPSByZ2I7XG4gICAgdGhpcy5hbHBoYSA9IGFscGhhO1xufTtcblxudmFyIFBhdGggPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIHJnYiwgYWxwaGEpXG57XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLnBvaW50c0xlbmd0aCA9IDE7XG4gICAgdGhpcy5wb2ludHNbMF0gPSBuZXcgUG9pbnQoeCwgeSwgd2lkdGgsIHJnYiwgYWxwaGEpO1xufTtcblxudmFyIEdyYXBoaWNzV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlQmF0Y2ggPSByZW5kZXJlci5zaGFwZUJhdGNoO1xuICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gc2hhcGVCYXRjaC52ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcbiAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcbiAgICB2YXIgdmVydGV4T2Zmc2V0ID0gMDtcbiAgICB2YXIgY2FtZXJhU2Nyb2xsWCA9IGNhbWVyYS5zY3JvbGxYO1xuICAgIHZhciBjYW1lcmFTY3JvbGxZID0gY2FtZXJhLnNjcm9sbFk7XG4gICAgY29uc3Qgc3JjWCA9IHNyYy54IC0gY2FtZXJhU2Nyb2xsWDtcbiAgICBjb25zdCBzcmNZID0gc3JjLnkgLSBjYW1lcmFTY3JvbGxZO1xuICAgIGNvbnN0IHNyY1NjYWxlWCA9IHNyYy5zY2FsZVg7XG4gICAgY29uc3Qgc3JjU2NhbGVZID0gc3JjLnNjYWxlWTtcbiAgICBjb25zdCBzcmNSb3RhdGlvbiA9IC1zcmMucm90YXRpb247XG4gICAgdmFyIGNvbW1hbmRCdWZmZXIgPSBzcmMuY29tbWFuZEJ1ZmZlcjtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGxpbmVBbHBoYSA9IDEuMDtcbiAgICB2YXIgZmlsbEFscGhhID0gMS4wO1xuICAgIHZhciBsaW5lQ29sb3IgPSAwO1xuICAgIHZhciBmaWxsQ29sb3IgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAxLjA7XG4gICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xuICAgIHZhciBsYXN0UGF0aCA9IG51bGw7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgdmFyIGl0ZXJTdGVwID0gMC4wMTtcbiAgICB2YXIgdHggPSAwO1xuICAgIHZhciB0eSA9IDA7XG4gICAgdmFyIHRhID0gMDtcbiAgICB2YXIgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZTtcbiAgICB2YXIgd2lkdGgsIGhlaWdodCwgdHh3LCB0eWg7XG4gICAgdmFyIHZlcnRleENvdW50ID0gc2hhcGVCYXRjaC52ZXJ0ZXhDb3VudDtcbiAgICB2YXIgcG9seWdvbiA9IFtdO1xuICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyO1xuICAgIHZhciB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyO1xuICAgIHZhciB2MCwgdjEsIHYyO1xuICAgIHZhciBwb2x5Z29uSW5kZXg7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhMZW5ndGg7XG4gICAgdmFyIHBvaW50O1xuICAgIHZhciBtYXhWZXJ0aWNlcyA9IHNoYXBlQmF0Y2gubWF4VmVydGljZXM7XG4gICAgdmFyIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk7XG4gICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcbiAgICB2YXIgc3JhLCBzcmIsIHNyYywgc3JkLCBzcmUsIHNyZiwgY21hLCBjbWIsIGNtYywgY21kLCBjbWUsIGNtZjtcbiAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZjtcblxuICAgIHRlbXBNYXRyaXguYXBwbHlJVFJTKHNyY1gsIHNyY1ksIHNyY1JvdGF0aW9uLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSk7XG5cbiAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xuICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XG4gICAgc3JjID0gdGVtcE1hdHJpeE1hdHJpeFsyXTtcbiAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xuICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XG4gICAgc3JmID0gdGVtcE1hdHJpeE1hdHJpeFs1XTtcblxuICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcbiAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XG4gICAgY21jID0gY2FtZXJhTWF0cml4WzJdO1xuICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcbiAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XG4gICAgY21mID0gY2FtZXJhTWF0cml4WzVdO1xuXG4gICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xuICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcbiAgICBtdmMgPSBzcmMgKiBjbWEgKyBzcmQgKiBjbWM7XG4gICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xuICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcbiAgICBtdmYgPSBzcmUgKiBjbWIgKyBzcmYgKiBjbWQgKyBjbWY7XG5cbiAgICByZW5kZXJlci5zZXRCYXRjaChzaGFwZUJhdGNoLCBudWxsKTtcblxuICAgIGZvciAodmFyIGNtZEluZGV4ID0gMCwgY21kTGVuZ3RoID0gY29tbWFuZEJ1ZmZlci5sZW5ndGg7IGNtZEluZGV4IDwgY21kTGVuZ3RoOyArK2NtZEluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXhdO1xuXG4gICAgICAgIHN3aXRjaChjbWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQVJDOlxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgeCA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICB5ID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdO1xuICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UgPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbiA8IDEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YSA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICogaXRlcmF0aW9uICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgdHggPSB4ICsgY29zKHRhKSAqIHJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgdHkgPSB5ICsgc2luKHRhKSAqIHJhZGl1cztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKHR4LCB0eSwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aC5wb2ludHMucHVzaChuZXcgUG9pbnQodHgsIHR5LCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb24gKz0gaXRlclN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTElORV9TVFlMRTpcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgbGluZUNvbG9yID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGxpbmVBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAzXTtcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfU1RZTEU6XG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIGZpbGxBbHBoYSA9IGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkJFR0lOX1BBVEg6XG4gICAgICAgICAgICAgICAgcGF0aEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuQ0xPU0VfUEFUSDpcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGggIT09IG51bGwgJiYgbGFzdFBhdGgucG9pbnRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IGxhc3RQYXRoLnBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RQb2ludCA9IGxhc3RQYXRoLnBvaW50c1tsYXN0UGF0aC5wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKGZpcnN0UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKGxhc3RQb2ludC54LCBsYXN0UG9pbnQueSwgbGFzdFBvaW50LndpZHRoLCBsYXN0UG9pbnQucmdiLCBsYXN0UG9pbnQuYWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfUEFUSDpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwYXRoQXJyYXlJbmRleCA9IDAsIHBhdGhBcnJheUxlbmd0aCA9IHBhdGhBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheUluZGV4IDwgcGF0aEFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICArK3BhdGhBcnJheUluZGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsUGF0aChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5W3BhdGhBcnJheUluZGV4XS5wb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RST0tFX1BBVEg6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aEFycmF5SW5kZXggPSAwLCBwYXRoQXJyYXlMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXlJbmRleCA8IHBhdGhBcnJheUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgKytwYXRoQXJyYXlJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aEFycmF5W3BhdGhBcnJheUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRTdHJva2VQYXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVjdGFuZ2xlIHByb3BlcnRpZXMgKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPT09IHRoaXMuX2xhc3RQYXRoXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GSUxMX1JFQ1Q6XG4gICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgUHJvcGVydGllcyAqL1xuICAgICAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovIFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA0XSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmaWxsQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgIC8qIFRyYW5zZm9ybSAqL1xuICAgICAgICAgICAgICAgICAgICBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkZJTExfVFJJQU5HTEU6XG4gICAgICAgICAgICAgICAgc2hhcGVCYXRjaC5hZGRGaWxsVHJpYW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovIFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV0gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgLyogVHJhbnNmb3JtICovXG4gICAgICAgICAgICAgICAgICAgIG12YSwgbXZiLCBtdmMsIG12ZCwgbXZlLCBtdmZcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RST0tFX1RSSUFOR0xFOlxuICAgICAgICAgICAgICAgIHNoYXBlQmF0Y2guYWRkU3Ryb2tlVHJpYW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IFByb3BlcnRpZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovIFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMV0gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV0gLSBjYW1lcmFTY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNl0gLSBjYW1lcmFTY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgbGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAvKiBUcmFuc2Zvcm0gKi9cbiAgICAgICAgICAgICAgICAgICAgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gNjtcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLkxJTkVfVE86XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXRoICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBhdGgucG9pbnRzLnB1c2gobmV3IFBvaW50KGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gbmV3IFBhdGgoY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuTU9WRV9UTzpcbiAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgbGluZUFscGhhKTtcbiAgICAgICAgICAgICAgICBwYXRoQXJyYXkucHVzaChsYXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgY21kSW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5MSU5FX0ZYX1RPOlxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGF0aCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXRoLnBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAxXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgMl0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDVdXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBQYXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyAyXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgM10sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbWRJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLk1PVkVfRlhfVE86XG4gICAgICAgICAgICAgICAgbGFzdFBhdGggPSBuZXcgUGF0aChcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDFdLCBcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDJdLCBcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZEJ1ZmZlcltjbWRJbmRleCArIDNdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kQnVmZmVyW2NtZEluZGV4ICsgNF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRCdWZmZXJbY21kSW5kZXggKyA1XVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGF0aEFycmF5LnB1c2gobGFzdFBhdGgpO1xuICAgICAgICAgICAgICAgIGNtZEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGhhc2VyOiBJbnZhbGlkIEdyYXBoaWNzIENvbW1hbmQgSUQgJyArIGNtZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NXZWJHTFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvZ3JhcGhpY3MvR3JhcGhpY3NXZWJHTFJlbmRlcmVyLmpzIiwiXG52YXIgSW1hZ2VDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgPT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZW5kZXJlci5kcmF3SW1hZ2Uoc3JjLCBjYW1lcmEpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VDYW52YXNSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBJbWFnZSA9IHJlcXVpcmUoJy4vSW1hZ2UnKTtcbnZhciBGYWN0b3J5Q29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvRmFjdG9yeUNvbnRhaW5lcicpO1xuXG52YXIgSW1hZ2VGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnaW1hZ2UnLFxuXG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgYEltYWdlYCBvYmplY3QuXG4gICAgKlxuICAgICogQW4gSW1hZ2UgaXMgYSBsaWdodC13ZWlnaHQgb2JqZWN0IHlvdSBjYW4gdXNlIHRvIGRpc3BsYXkgYW55dGhpbmcgdGhhdCBkb2Vzbid0IG5lZWQgcGh5c2ljcyBvciBhbmltYXRpb24uXG4gICAgKlxuICAgICogSXQgY2FuIHN0aWxsIHJvdGF0ZSwgc2NhbGUsIGNyb3AgYW5kIHJlY2VpdmUgaW5wdXQgZXZlbnRzLlxuICAgICogVGhpcyBtYWtlcyBpdCBwZXJmZWN0IGZvciBsb2dvcywgYmFja2dyb3VuZHMsIHNpbXBsZSBidXR0b25zIGFuZCBvdGhlciBub24tU3ByaXRlIGdyYXBoaWNzLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNpbWFnZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgSW1hZ2UuIFRoZSBjb29yZGluYXRlIGlzIHJlbGF0aXZlIHRvIGFueSBwYXJlbnQgY29udGFpbmVyIHRoaXMgSW1hZ2UgbWF5IGJlIGluLlxuICAgICogQHBhcmFtIHtzdHJpbmd8UGhhc2VyLlJlbmRlclRleHR1cmV8UGhhc2VyLkJpdG1hcERhdGF8UGhhc2VyLlZpZGVvfFBJWEkuVGV4dHVyZX0gW2tleV0gLSBUaGUgaW1hZ2UgdXNlZCBhcyBhIHRleHR1cmUgYnkgdGhpcyBkaXNwbGF5IG9iamVjdCBkdXJpbmcgcmVuZGVyaW5nLiBJZiBhIHN0cmluZyBQaGFzZXIgd2lsbCBnZXQgZm9yIGFuIGVudHJ5IGluIHRoZSBJbWFnZSBDYWNoZS4gT3IgaXQgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGEgUmVuZGVyVGV4dHVyZSwgQml0bWFwRGF0YSwgVmlkZW8gb3IgUElYSS5UZXh0dXJlLlxuICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbZnJhbWVdIC0gSWYgYSBUZXh0dXJlIEF0bGFzIG9yIFNwcml0ZSBTaGVldCBpcyB1c2VkIHRoaXMgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSBmcmFtZSB0byBiZSB1c2VkLiBVc2UgZWl0aGVyIGFuIGludGVnZXIgZm9yIGEgRnJhbWUgSUQgb3IgYSBzdHJpbmcgZm9yIGEgZnJhbWUgbmFtZS5cbiAgICAqIEBwYXJhbSB7UGhhc2VyLkdyb3VwfSBbZ3JvdXBdIC0gT3B0aW9uYWwgR3JvdXAgdG8gYWRkIHRoZSBvYmplY3QgdG8uIElmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgV29ybGQgZ3JvdXAuXG4gICAgKiBAcmV0dXJuIHtQaGFzZXIuSW1hZ2V9IFRoZSBuZXdseSBjcmVhdGVkIEltYWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUsIHBhcmVudClcbiAgICB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgeyBwYXJlbnQgPSB0aGlzLnN0YXRlOyB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5hZGQobmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpKTtcbiAgICB9LFxuXG4gICAgbWFrZTogZnVuY3Rpb24gKHgsIHksIGtleSwgZnJhbWUpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEltYWdlKHRoaXMuc3RhdGUsIHgsIHksIGtleSwgZnJhbWUpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKEltYWdlRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9pbWFnZS9JbWFnZUZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9JbWFnZUNhbnZhc1JlbmRlcmVyJyksXG4gICAgcmVuZGVyV2ViR0w6IHJlcXVpcmUoJy4vSW1hZ2VXZWJHTFJlbmRlcmVyJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL2ltYWdlL0ltYWdlUmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VSZW5kZXIuanMiLCJ2YXIgSW1hZ2VXZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzcmMsIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyTWFzayAhPT0gdGhpcy5yZW5kZXJGbGFncylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlKHNyYywgY2FtZXJhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VXZWJHTFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvaW1hZ2UvSW1hZ2VXZWJHTFJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XG5cbnZhciBMYXllckZhY3RvcnkgPSB7XG5cbiAgICBLRVk6ICdsYXllcicsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZHJlbilcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXIodGhpcy5zdGF0ZSwgY2hpbGRyZW4pO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoY2hpbGRyZW4pXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyKHRoaXMuc3RhdGUsIGNoaWxkcmVuKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3RlcihMYXllckZhY3RvcnkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXJGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvbGF5ZXIvTGF5ZXJGYWN0b3J5LmpzIiwiXG52YXIgU3ByaXRlQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrID09PSB0aGlzLnJlbmRlckZsYWdzKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhd0ltYWdlKHNyYywgY2FtZXJhKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUNhbnZhc1JlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZUNhbnZhc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vU3ByaXRlJyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIFNwcml0ZUZhY3RvcnkgPSB7XG5cbiAgICBLRVk6ICdzcHJpdGUnLFxuXG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgU3ByaXRlIHdpdGggc3BlY2lmaWMgcG9zaXRpb24gYW5kIHNwcml0ZSBzaGVldCBrZXkuXG4gICAgKlxuICAgICogQXQgaXRzIG1vc3QgYmFzaWMgYSBTcHJpdGUgY29uc2lzdHMgb2YgYSBzZXQgb2YgY29vcmRpbmF0ZXMgYW5kIGEgdGV4dHVyZSB0aGF0IGlzIHVzZWQgd2hlbiByZW5kZXJlZC5cbiAgICAqIFRoZXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhbGxvd2luZyBmb3IgcGh5c2ljcyBtb3Rpb24gKHZpYSBTcHJpdGUuYm9keSksIGlucHV0IGhhbmRsaW5nICh2aWEgU3ByaXRlLmlucHV0KSxcbiAgICAqIGV2ZW50cyAodmlhIFNwcml0ZS5ldmVudHMpLCBhbmltYXRpb24gKHZpYSBTcHJpdGUuYW5pbWF0aW9ucyksIGNhbWVyYSBjdWxsaW5nIGFuZCBtb3JlLiBQbGVhc2Ugc2VlIHRoZSBFeGFtcGxlcyBmb3IgdXNlIGNhc2VzLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeSNzcHJpdGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHNwcml0ZS4gVGhlIGNvb3JkaW5hdGUgaXMgcmVsYXRpdmUgdG8gYW55IHBhcmVudCBjb250YWluZXIgdGhpcyBzcHJpdGUgbWF5IGJlIGluLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3ByaXRlLiBUaGUgY29vcmRpbmF0ZSBpcyByZWxhdGl2ZSB0byBhbnkgcGFyZW50IGNvbnRhaW5lciB0aGlzIHNwcml0ZSBtYXkgYmUgaW4uXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xQaGFzZXIuUmVuZGVyVGV4dHVyZXxQaGFzZXIuQml0bWFwRGF0YXxQaGFzZXIuVmlkZW98UElYSS5UZXh0dXJlfSBba2V5XSAtIFRoZSBpbWFnZSB1c2VkIGFzIGEgdGV4dHVyZSBieSB0aGlzIGRpc3BsYXkgb2JqZWN0IGR1cmluZyByZW5kZXJpbmcuIElmIGEgc3RyaW5nIFBoYXNlciB3aWxsIGdldCBmb3IgYW4gZW50cnkgaW4gdGhlIEltYWdlIENhY2hlLiBPciBpdCBjYW4gYmUgYW4gaW5zdGFuY2Ugb2YgYSBSZW5kZXJUZXh0dXJlLCBCaXRtYXBEYXRhLCBWaWRlbyBvciBQSVhJLlRleHR1cmUuXG4gICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtmcmFtZV0gLSBJZiBhIFRleHR1cmUgQXRsYXMgb3IgU3ByaXRlIFNoZWV0IGlzIHVzZWQgdGhpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGZyYW1lIHRvIGJlIHVzZWQuIFVzZSBlaXRoZXIgYW4gaW50ZWdlciBmb3IgYSBGcmFtZSBJRCBvciBhIHN0cmluZyBmb3IgYSBmcmFtZSBuYW1lLlxuICAgICogQHBhcmFtIHtQaGFzZXIuR3JvdXB9IFtncm91cF0gLSBPcHRpb25hbCBHcm91cCB0byBhZGQgdGhlIG9iamVjdCB0by4gSWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBXb3JsZCBncm91cC5cbiAgICAqIEByZXR1cm4ge1BoYXNlci5TcHJpdGV9IFRoZSBuZXdseSBjcmVhdGVkIFNwcml0ZSBvYmplY3QuXG4gICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lLCBncm91cClcbiAgICB7XG4gICAgICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkKSB7IGdyb3VwID0gdGhpcy5zdGF0ZTsgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbWFnZUZhY3RvcnkuYWRkJywga2V5LCB4LCB5LCBmcmFtZSwgZ3JvdXApO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50byBTdGF0ZScsIHRoaXMuc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBncm91cC5jaGlsZHJlbi5hZGQobmV3IFNwcml0ZSh0aGlzLnN0YXRlLCB4LCB5LCBrZXksIGZyYW1lKSk7XG4gICAgfSxcblxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCBrZXksIGZyYW1lKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0ltYWdlRmFjdG9yeS5tYWtlJywga2V5LCB4LCB5LCBmcmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUodGhpcy5zdGF0ZSwgeCwgeSwga2V5LCBmcmFtZSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY3RvcnlDb250YWluZXIucmVnaXN0ZXIoU3ByaXRlRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVGYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICByZW5kZXJDYW52YXM6IHJlcXVpcmUoJy4vU3ByaXRlQ2FudmFzUmVuZGVyZXInKSxcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9TcHJpdGVXZWJHTFJlbmRlcmVyJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3Nwcml0ZS9TcHJpdGVSZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy9zcHJpdGUvU3ByaXRlUmVuZGVyLmpzIiwidmFyIFNwcml0ZVdlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW5kZXJlci5zcHJpdGVCYXRjaC5hZGRTcHJpdGUoc3JjLCBjYW1lcmEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVXZWJHTFJlbmRlcmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvc3ByaXRlL1Nwcml0ZVdlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBHZXRUZXh0U2l6ZSA9IGZ1bmN0aW9uICh0ZXh0LCBzaXplLCBsaW5lcylcbntcbiAgICB2YXIgY2FudmFzID0gdGV4dC5jYW52YXM7XG4gICAgdmFyIGNvbnRleHQgPSB0ZXh0LmNvbnRleHQ7XG4gICAgdmFyIHN0eWxlID0gdGV4dC5zdHlsZTtcblxuICAgIHZhciBsaW5lV2lkdGhzID0gW107XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIGRyYXduTGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgXG4gICAgaWYgKHN0eWxlLm1heExpbmVzID4gMCAmJiBzdHlsZS5tYXhMaW5lcyA8IGxpbmVzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIGRyYXduTGluZXMgPSBzdHlsZS5tYXhMaW5lcztcbiAgICB9XG5cbiAgICBzdHlsZS5zeW5jRm9udChjYW52YXMsIGNvbnRleHQpO1xuXG4gICAgLy8gIFRleHQgV2lkdGhcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhd25MaW5lczsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyArIHRleHQucGFkZGluZy54O1xuXG4gICAgICAgIGxpbmVXaWR0aCArPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aDtcblxuICAgICAgICAvLyBBZGp1c3QgZm9yIHdyYXBwZWQgdGV4dFxuICAgICAgICBpZiAoc3R5bGUud29yZFdyYXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCAtPSBjb250ZXh0Lm1lYXN1cmVUZXh0KCcgJykud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lV2lkdGhzW2ldID0gTWF0aC5jZWlsKGxpbmVXaWR0aCk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gIFRleHQgSGVpZ2h0XG5cbiAgICB2YXIgbGluZUhlaWdodCA9IHNpemUuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3MgKyB0ZXh0LnBhZGRpbmcueTtcbiAgICB2YXIgaGVpZ2h0ID0gbGluZUhlaWdodCAqIGRyYXduTGluZXM7XG4gICAgdmFyIGxpbmVTcGFjaW5nID0gdGV4dC5fbGluZVNwYWNpbmcgfHwgMDtcblxuICAgIGlmIChsaW5lU3BhY2luZyA8IDAgJiYgTWF0aC5hYnMobGluZVNwYWNpbmcpID4gbGluZUhlaWdodClcbiAgICB7XG4gICAgICAgIGxpbmVTcGFjaW5nID0gLWxpbmVIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gLy8gIEFkanVzdCBmb3IgbGluZSBzcGFjaW5nXG4gICAgaWYgKGxpbmVTcGFjaW5nICE9PSAwKVxuICAgIHtcbiAgICAgICAgaGVpZ2h0ICs9IChsaW5lU3BhY2luZyA+IDApID8gbGluZVNwYWNpbmcgKiBsaW5lcy5sZW5ndGggOiBsaW5lU3BhY2luZyAqIChsaW5lcy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB3aWR0aDogbWF4TGluZVdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgbGluZXM6IGRyYXduTGluZXMsIGxpbmVXaWR0aHM6IGxpbmVXaWR0aHMsIGxpbmVTcGFjaW5nOiBsaW5lU3BhY2luZywgbGluZUhlaWdodDogbGluZUhlaWdodCB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRUZXh0U2l6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3RleHQvR2V0VGV4dFNpemUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uLy4uL2RvbS9DYW52YXNQb29sJyk7XG5cbi8qKlxuKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udCBzdHlsZS5cbipcbiogQG1ldGhvZCBQaGFzZXIuR2FtZU9iamVjdC5UZXh0I2RldGVybWluZUZvbnRQcm9wZXJ0aWVzXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7b2JqZWN0fSB0ZXh0U3R5bGVcbiovXG52YXIgTWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCB0ZXN0U3RyaW5nKVxue1xuICAgIGlmICh0ZXN0U3RyaW5nID09PSB1bmRlZmluZWQpIHsgdGVzdFN0cmluZyA9ICd8TcOJcSc7IH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHRoZSB0ZXh0IGlzIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHZhciBjYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZSh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB0aGUgdGV4dCBpcyByZW5kZXJlZCB0by5cbiAgICAgKi9cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgdGV4dFN0eWxlLnN5bmNGb250KGNhbnZhcywgY29udGV4dCk7XG5cbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dCh0ZXN0U3RyaW5nKS53aWR0aCk7XG4gICAgdmFyIGJhc2VsaW5lID0gd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcblxuICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgKiAxLjQgfCAwO1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmMDAnO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjb250ZXh0LmZvbnQgPSB0ZXh0U3R5bGUuZm9udDtcblxuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAnO1xuICAgIGNvbnRleHQuZmlsbFRleHQodGVzdFN0cmluZywgMCwgYmFzZWxpbmUpO1xuXG4gICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgYXNjZW50OiAwLFxuICAgICAgICBkZXNjZW50OiAwLFxuICAgICAgICBmb250U2l6ZTogMFxuICAgIH07XG5cbiAgICBpZiAoIWNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpKVxuICAgIHtcbiAgICAgICAgb3V0cHV0LmFzY2VudCA9IGJhc2VsaW5lO1xuICAgICAgICBvdXRwdXQuZGVzY2VudCA9IGJhc2VsaW5lICsgNjtcbiAgICAgICAgb3V0cHV0LmZvbnRTaXplID0gb3V0cHV0LmFzY2VudCArIG91dHB1dC5kZXNjZW50O1xuXG4gICAgICAgIENhbnZhc1Bvb2wucmVtb3ZlKGNhbnZhcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICB2YXIgbGluZSA9IHdpZHRoICogNDtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgc3RvcCA9IGZhbHNlO1xuXG4gICAgLy8gYXNjZW50LiBzY2FuIGZyb20gdG9wIHRvIGJvdHRvbSB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxuICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgaSsrKVxuICAgIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdG9wKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmFzY2VudCA9IGJhc2VsaW5lIC0gaTtcblxuICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XG4gICAgc3RvcCA9IGZhbHNlO1xuXG4gICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgaS0tKVxuICAgIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdG9wKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZHggLT0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0LmRlc2NlbnQgPSAoaSAtIGJhc2VsaW5lKSArIDY7XG4gICAgb3V0cHV0LmZvbnRTaXplID0gb3V0cHV0LmFzY2VudCArIG91dHB1dC5kZXNjZW50O1xuXG4gICAgQ2FudmFzUG9vbC5yZW1vdmUoY2FudmFzKTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lYXN1cmVUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvdGV4dC9NZWFzdXJlVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dhbWVvYmplY3RzL3RleHQvTWVhc3VyZVRleHQuanMiLCJ2YXIgQ2xhc3MgPSByZXF1aXJlKCcuLi8uLi91dGlscy9DbGFzcycpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XG52YXIgTWVhc3VyZVRleHQgPSByZXF1aXJlKCcuL01lYXN1cmVUZXh0Jyk7XG5cbi8vICBLZXk6IFsgT2JqZWN0IEtleSwgRGVmYXVsdCBWYWx1ZSBdXG5cbnZhciBwcm9wZXJ0eU1hcCA9IHtcbiAgICBmb250OiBbICdmb250JywgJzE2cHggQ291cmllcicgXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFsgJ2JhY2tncm91bmRDb2xvcicsIG51bGwgXSxcbiAgICBmaWxsOiBbICdmaWxsJywgJyNmZmYnIF0sXG4gICAgc3Ryb2tlOiBbICdzdHJva2UnLCAnI2ZmZicgXSxcbiAgICBzdHJva2VUaGlja25lc3M6IFsgJ3N0cm9rZVRoaWNrbmVzcycsIDAgXSxcbiAgICBzaGFkb3dPZmZzZXRYOiBbICdzaGFkb3cub2Zmc2V0WCcsIDAgXSxcbiAgICBzaGFkb3dPZmZzZXRZOiBbICdzaGFkb3cub2Zmc2V0WScsIDAgXSxcbiAgICBzaGFkb3dDb2xvcjogWyAnc2hhZG93LmNvbG9yJywgJyMwMDAnIF0sXG4gICAgc2hhZG93Qmx1cjogWyAnc2hhZG93LmJsdXInLCAwIF0sXG4gICAgc2hhZG93U3Ryb2tlOiBbICdzaGFkb3cuc3Ryb2tlJywgZmFsc2UgXSxcbiAgICBzaGFkb3dGaWxsOiBbICdzaGFkb3cuZmlsbCcsIGZhbHNlIF0sXG4gICAgYWxpZ246IFsgJ2FsaWduJywgJ2xlZnQnIF0sXG4gICAgbWF4TGluZXM6IFsgJ21heExpbmVzJywgMCBdLFxuICAgIGZpeGVkV2lkdGg6IFsgJ2ZpeGVkV2lkdGgnLCBmYWxzZSBdLFxuICAgIGZpeGVkSGVpZ2h0OiBbICdmaXhlZEhlaWdodCcsIGZhbHNlIF0sXG4gICAgcnRsOiBbICdydGwnLCBmYWxzZSBdXG59O1xuXG52YXIgVGV4dFN0eWxlID0gbmV3IENsYXNzKHtcblxuICAgIGluaXRpYWxpemU6XG5cbiAgICBmdW5jdGlvbiBUZXh0U3R5bGUgKHRleHQsIHN0eWxlKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0ZXh0O1xuXG4gICAgICAgIHRoaXMuZm9udDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5zdHJva2U7XG4gICAgICAgIHRoaXMuc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgICB0aGlzLnNoYWRvd09mZnNldFg7XG4gICAgICAgIHRoaXMuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyO1xuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZTtcbiAgICAgICAgdGhpcy5zaGFkb3dGaWxsO1xuICAgICAgICB0aGlzLmFsaWduO1xuICAgICAgICB0aGlzLm1heExpbmVzO1xuICAgICAgICB0aGlzLmZpeGVkV2lkdGg7XG4gICAgICAgIHRoaXMuZml4ZWRIZWlnaHQ7XG4gICAgICAgIHRoaXMucnRsO1xuXG4gICAgICAgIC8vICBTZXQgdG8gZGVmYXVsdHNcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydHlNYXApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gR2V0T2JqZWN0VmFsdWUoc3R5bGUsIHByb3BlcnR5TWFwW2tleV1bMF0sIHRoaXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ldHJpY3MgPSBNZWFzdXJlVGV4dCh0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydHlNYXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHByb3BlcnR5TWFwW2tleV1bMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3luY0ZvbnQ6IGZ1bmN0aW9uIChjYW52YXMsIGNvbnRleHQpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5ydGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhcy5kaXIgPSAncnRsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcblxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICB9LFxuXG4gICAgc3luY1NoYWRvdzogZnVuY3Rpb24gKGNvbnRleHQsIGVuYWJsZWQpXG4gICAge1xuICAgICAgICBpZiAoZW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAwO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChyZWNhbGN1bGF0ZU1ldHJpY3MpXG4gICAge1xuICAgICAgICBpZiAocmVjYWxjdWxhdGVNZXRyaWNzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1ldHJpY3MgPSBNZWFzdXJlVGV4dCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC51cGRhdGVUZXh0KCk7XG4gICAgfSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydHlNYXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IEdldE9iamVjdFZhbHVlKHN0eWxlLCBwcm9wZXJ0eU1hcFtrZXldWzBdLCB0aGlzW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbiAoZm9udClcbiAgICB7XG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRGaXhlZFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdGhpcy5maXhlZFdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZml4ZWRIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKHdpZHRoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRleHQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGV4dC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChjb2xvcilcbiAgICB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgc2V0RmlsbDogZnVuY3Rpb24gKGNvbG9yKVxuICAgIHtcbiAgICAgICAgdGhpcy5maWxsID0gY29sb3I7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgc2V0U3Ryb2tlOiBmdW5jdGlvbiAoY29sb3IsIHRoaWNrbmVzcylcbiAgICB7XG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgUmVzZXQgdGhlIHN0cm9rZSB0byB6ZXJvIChkaXNhYmxpbmcgaXQpXG4gICAgICAgICAgICB0aGlzLnN0cm9rZVRoaWNrbmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpY2tuZXNzID09PSB1bmRlZmluZWQpIHsgdGhpY2tuZXNzID0gdGhpcy5zdHJva2VUaGlja25lc3M7IH1cblxuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBjb2xvcjtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlVGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3c6IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgYmx1ciwgc2hhZG93U3Ryb2tlLCBzaGFkb3dGaWxsKVxuICAgIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSAwOyB9XG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7IGNvbG9yID0gJyMwMDAnOyB9XG4gICAgICAgIGlmIChibHVyID09PSB1bmRlZmluZWQpIHsgYmx1ciA9IDA7IH1cbiAgICAgICAgaWYgKHNoYWRvd1N0cm9rZSA9PT0gdW5kZWZpbmVkKSB7IHNoYWRvd1N0cm9rZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChzaGFkb3dGaWxsID09PSB1bmRlZmluZWQpIHsgc2hhZG93RmlsbCA9IGZhbHNlOyB9XG5cbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRYID0geDtcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcbiAgICAgICAgdGhpcy5zaGFkb3dDb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLnNoYWRvd0JsdXIgPSBibHVyO1xuICAgICAgICB0aGlzLnNoYWRvd1N0cm9rZSA9IHNoYWRvd1N0cm9rZTtcbiAgICAgICAgdGhpcy5zaGFkb3dGaWxsID0gc2hhZG93RmlsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dPZmZzZXQ6IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeyB4ID0gMDsgfVxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG5cbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRYID0geDtcbiAgICAgICAgdGhpcy5zaGFkb3dPZmZzZXRZID0geTtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24gKGNvbG9yKVxuICAgIHtcbiAgICAgICAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHsgY29sb3IgPSAnIzAwMCc7IH1cblxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gY29sb3I7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZG93Qmx1cjogZnVuY3Rpb24gKGJsdXIpXG4gICAge1xuICAgICAgICBpZiAoYmx1ciA9PT0gdW5kZWZpbmVkKSB7IGJsdXIgPSAwOyB9XG5cbiAgICAgICAgdGhpcy5zaGFkb3dCbHVyID0gYmx1cjtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dTdHJva2U6IGZ1bmN0aW9uIChlbmFibGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5zaGFkb3dTdHJva2UgPSBlbmFibGVkO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmYWxzZSk7XG4gICAgfSxcblxuICAgIHNldFNoYWRvd0ZpbGw6IGZ1bmN0aW9uIChlbmFibGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5zaGFkb3dGaWxsID0gZW5hYmxlZDtcblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRBbGlnbjogZnVuY3Rpb24gKGFsaWduKVxuICAgIHtcbiAgICAgICAgaWYgKGFsaWduID09PSB1bmRlZmluZWQpIHsgYWxpZ24gPSAnbGVmdCc7IH1cblxuICAgICAgICB0aGlzLmFsaWduID0gYWxpZ247XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgc2V0TWF4TGluZXM6IGZ1bmN0aW9uIChtYXgpXG4gICAge1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHsgbWF4ID0gMDsgfVxuXG4gICAgICAgIHRoaXMubWF4TGluZXMgPSBtYXg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFN0eWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZW9iamVjdHMvdGV4dC9UZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nYW1lb2JqZWN0cy90ZXh0L1RleHRTdHlsZS5qcyIsInZhciBUZXh0Q2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNyYywgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbntcbiAgICBpZiAodGhpcy5yZW5kZXJNYXNrICE9PSB0aGlzLnJlbmRlckZsYWdzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY3R4ID0gcmVuZGVyZXIuY3VycmVudENvbnRleHQ7XG5cbiAgICAvLyAgQmxlbmQgTW9kZVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHNyYy5ibGVuZE1vZGU7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3NyYy5ibGVuZE1vZGVdO1xuICAgIH1cblxuICAgIC8vICBBbHBoYVxuICAgIGlmIChyZW5kZXJlci5jdXJyZW50QWxwaGEgIT09IHNyYy5hbHBoYSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRBbHBoYSA9IHNyYy5hbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3JjLmFscGhhO1xuICAgIH1cblxuICAgIC8vICBTbW9vdGhpbmdcbiAgICBpZiAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSAhPT0gc3JjLnNjYWxlTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRTY2FsZU1vZGUgPSBzcmMuc2NhbGVNb2RlO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSBzcmMuY2FudmFzO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHNyYy54IC0gY2FtZXJhLnNjcm9sbFgsIHNyYy55IC0gY2FtZXJhLnNjcm9sbFkpO1xuICAgIGN0eC5yb3RhdGUoc3JjLnJvdGF0aW9uKTtcbiAgICBjdHguc2NhbGUoc3JjLnNjYWxlWCwgc3JjLnNjYWxlWSk7XG4gICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGggKiAoc3JjLmZsaXBYID8gMSA6IDApLCBjYW52YXMuaGVpZ2h0ICogKHNyYy5mbGlwWSA/IDEgOiAwKSk7XG4gICAgY3R4LnNjYWxlKHNyYy5mbGlwWCA/IC0xIDogMSwgc3JjLmZsaXBZID8gLTEgOiAxKTtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCAtc3JjLmRpc3BsYXlPcmlnaW5YLCAtc3JjLmRpc3BsYXlPcmlnaW5ZLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRDYW52YXNSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRDYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUZXh0ID0gcmVxdWlyZSgnLi9UZXh0Jyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIFRleHRGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAndGV4dCcsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCB0ZXh0LCBzdHlsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkcmVuLmFkZChuZXcgVGV4dCh0aGlzLnN0YXRlLCB4LCB5LCB0ZXh0LCBzdHlsZSkpO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwgdGV4dCwgc3R5bGUpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQodGhpcy5zdGF0ZSwgeCwgeSwgdGV4dCwgc3R5bGUpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWN0b3J5Q29udGFpbmVyLnJlZ2lzdGVyKFRleHRGYWN0b3J5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dhbWVvYmplY3RzL3RleHQvc3RhdGljL1RleHRGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dEZhY3RvcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlbmRlckNhbnZhczogcmVxdWlyZSgnLi9UZXh0Q2FudmFzUmVuZGVyZXInKSxcbiAgICByZW5kZXJXZWJHTDogcmVxdWlyZSgnLi9UZXh0V2ViR0xSZW5kZXJlcicpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0UmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvdGV4dC9zdGF0aWMvVGV4dFJlbmRlci5qcyIsInZhciBUZXh0V2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3JjLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKVxue1xuICAgIGlmICh0aGlzLnJlbmRlck1hc2sgIT09IHRoaXMucmVuZGVyRmxhZ3MpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChzcmMuZGlydHkpXG4gICAge1xuICAgICAgICB2YXIgdyA9IHNyYy5jYW52YXMud2lkdGg7XG4gICAgICAgIHZhciBoID0gc3JjLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIHZhciByZXNpemUgPSAhKHNyYy5wcmV2V2lkdGggPCB3IHx8IHNyYy5wcmV2SGVpZ2h0IDwgaCk7XG5cbiAgICAgICAgc3JjLmNhbnZhc1RleHR1cmUgPSByZW5kZXJlci51cGxvYWRDYW52YXNUb0dQVShzcmMuY2FudmFzLCBzcmMuY2FudmFzVGV4dHVyZSwgcmVzaXplKTtcbiAgICAgICAgc3JjLnByZXZXaWR0aCA9IHc7XG4gICAgICAgIHNyYy5wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgc3JjLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuc3ByaXRlQmF0Y2guYWRkU3ByaXRlVGV4dHVyZShzcmMsIGNhbWVyYSwgc3JjLmNhbnZhc1RleHR1cmUsIHNyYy5wcmV2V2lkdGgsIHNyYy5wcmV2SGVpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFdlYkdMUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy90ZXh0L3N0YXRpYy9UZXh0V2ViR0xSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMzMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBab25lID0gcmVxdWlyZSgnLi9ab25lJyk7XG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcblxudmFyIFpvbmVGYWN0b3J5ID0ge1xuXG4gICAgS0VZOiAnem9uZScsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab25lKHRoaXMuc3RhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBtYWtlOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZSh0aGlzLnN0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeUNvbnRhaW5lci5yZWdpc3Rlcihab25lRmFjdG9yeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nYW1lb2JqZWN0cy96b25lL1pvbmVGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2FtZW9iamVjdHMvem9uZS9ab25lRmFjdG9yeS5qcyIsInZhciBBcmVhID0gZnVuY3Rpb24gKGNpcmNsZSlcbntcbiAgICByZXR1cm4gKGNpcmNsZS5yYWRpdXMgPiAwKSA/IE1hdGguUEkgKiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cyA6IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENpcmN1bWZlcmVuY2UgPSBmdW5jdGlvbiAoY2lyY2xlKVxue1xuICAgIHJldHVybiAyICogKE1hdGguUEkgKiBjaXJjbGUucmFkaXVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY3VtZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDMzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogUmV0dXJucyBhIFBvaW50IG9iamVjdCBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBDaXJjbGUgYmFzZWQgb24gdGhlIGdpdmVuIGFuZ2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUuY2lyY3VtZmVyZW5jZVBvaW50XG4qIEBwYXJhbSB7UGhhc2VyLkNpcmNsZX0gYSAtIFRoZSBmaXJzdCBDaXJjbGUgb2JqZWN0LlxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucyB0byByZXR1cm4gdGhlIHBvaW50IGZyb20uXG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fSBbb3V0XSAtIEFuIG9wdGlvbmFsIFBvaW50IG9iamVjdCB0byBwdXQgdGhlIHJlc3VsdCBpbiB0by4gSWYgbm9uZSBzcGVjaWZpZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiogQHJldHVybiB7UGhhc2VyLlBvaW50fSBUaGUgUG9pbnQgb2JqZWN0IGhvbGRpbmcgdGhlIHJlc3VsdC5cbiovXG52YXIgQ2lyY3VtZmVyZW5jZVBvaW50ID0gZnVuY3Rpb24gKGNpcmNsZSwgYW5nbGUsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0geyB4OiAwLCB5OiAwIH07IH1cblxuICAgIG91dC54ID0gY2lyY2xlLnggKyAoY2lyY2xlLnJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgb3V0LnkgPSBjaXJjbGUueSArIChjaXJjbGUucmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmN1bWZlcmVuY2VQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NpcmN1bWZlcmVuY2VQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXJjbGUgPSByZXF1aXJlKCcuL0NpcmNsZScpO1xuXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxue1xuICAgIHJldHVybiBuZXcgQ2lyY2xlKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDMzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcbntcbiAgICByZXR1cm4gQ29udGFpbnMoY2lyY2xlLCBwb2ludC54LCBwb2ludC55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9Db250YWluc1BvaW50LmpzIiwidmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xuXG52YXIgQ29udGFpbnNSZWN0ID0gZnVuY3Rpb24gKGNpcmNsZSwgcmVjdClcbntcbiAgICByZXR1cm4gKFxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QueCwgcmVjdC55KSAmJlxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QueSkgJiZcbiAgICAgICAgQ29udGFpbnMoY2lyY2xlLCByZWN0LngsIHJlY3QuYm90dG9tKSAmJlxuICAgICAgICBDb250YWlucyhjaXJjbGUsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vY2lyY2xlL0NvbnRhaW5zUmVjdC5qcyIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxue1xuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLnJhZGl1cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9jaXJjbGUvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDMzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGNpcmNsZSwgdG9Db21wYXJlKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIGNpcmNsZS54ID09PSB0b0NvbXBhcmUueCAmJlxuICAgICAgICBjaXJjbGUueSA9PT0gdG9Db21wYXJlLnkgJiZcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9PT0gdG9Db21wYXJlLnJhZGl1c1xuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XG5cbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoY2lyY2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxuXG4gICAgb3V0LnggPSBjaXJjbGUubGVmdDtcbiAgICBvdXQueSA9IGNpcmNsZS50b3A7XG4gICAgb3V0LndpZHRoID0gY2lyY2xlLmRpYW1ldGVyO1xuICAgIG91dC5oZWlnaHQgPSBjaXJjbGUuZGlhbWV0ZXI7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRCb3VuZHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDM0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2NpcmNsZS9HZXRCb3VuZHMuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGNpcmNsZSwgeCwgeSlcbntcbiAgICBjaXJjbGUueCArPSB4O1xuICAgIGNpcmNsZS55ICs9IHk7XG5cbiAgICByZXR1cm4gY2lyY2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2NpcmNsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAoY2lyY2xlLCBwb2ludClcbntcbiAgICBjaXJjbGUueCArPSBwb2ludC54O1xuICAgIGNpcmNsZS55ICs9IHBvaW50Lnk7XG5cbiAgICByZXR1cm4gY2lyY2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL09mZnNldFBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkNpcmNsZVxuXG52YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi9DaXJjbGUnKTtcblxuQ2lyY2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcbkNpcmNsZS5DaXJjdW1mZXJlbmNlID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlJyk7XG5DaXJjbGUuQ2lyY3VtZmVyZW5jZVBvaW50ID0gcmVxdWlyZSgnLi9DaXJjdW1mZXJlbmNlUG9pbnQnKTtcbkNpcmNsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcbkNpcmNsZS5Db250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcbkNpcmNsZS5Db250YWluc1BvaW50ID0gcmVxdWlyZSgnLi9Db250YWluc1BvaW50Jyk7XG5DaXJjbGUuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcbkNpcmNsZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcbkNpcmNsZS5FcXVhbHMgPSByZXF1aXJlKCcuL0VxdWFscycpO1xuQ2lyY2xlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XG5DaXJjbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcbkNpcmNsZS5PZmZzZXRQb2ludCA9IHJlcXVpcmUoJy4vT2Zmc2V0UG9pbnQnKTtcbkNpcmNsZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vY2lyY2xlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9jaXJjbGUvaW5kZXguanMiLCJ2YXIgQXJlYSA9IGZ1bmN0aW9uIChlbGxpcHNlKVxue1xuICAgIGlmIChlbGxpcHNlLmlzRW1wdHkoKSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vICB1bml0cyBzcXVhcmVkXG4gICAgcmV0dXJuIChlbGxpcHNlLmdldE1ham9yUmFkaXVzKCkgKiBlbGxpcHNlLmdldE1pbm9yUmFkaXVzKCkgKiBNYXRoLlBJKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9BcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVsbGlwc2UgPSByZXF1aXJlKCcuL0VsbGlwc2UnKTtcblxudmFyIENsb25lID0gZnVuY3Rpb24gKHNvdXJjZSlcbntcbiAgICByZXR1cm4gbmV3IEVsbGlwc2Uoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9DbG9uZS5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoZWxsaXBzZSwgcG9pbnQpXG57XG4gICAgcmV0dXJuIENvbnRhaW5zKGVsbGlwc2UsIHBvaW50LngsIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNQb2ludC5qcyIsInZhciBDb250YWlucyA9IHJlcXVpcmUoJy4vQ29udGFpbnMnKTtcblxudmFyIENvbnRhaW5zUmVjdCA9IGZ1bmN0aW9uIChlbGxpcHNlLCByZWN0KVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC55KSAmJlxuICAgICAgICBDb250YWlucyhlbGxpcHNlLCByZWN0LnJpZ2h0LCByZWN0LnkpICYmXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QueCwgcmVjdC5ib3R0b20pICYmXG4gICAgICAgIENvbnRhaW5zKGVsbGlwc2UsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5zUmVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9Db250YWluc1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvQ29udGFpbnNSZWN0LmpzIiwiLyoqXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0VsbGlwc2V9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgQ29weUZyb20gPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KVxue1xuICAgIHJldHVybiBkZXN0LnNldFRvKHNvdXJjZS54LCBzb3VyY2UueSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvQ29weUZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDM0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWxzID0gZnVuY3Rpb24gKGVsbGlwc2UsIHRvQ29tcGFyZSlcbntcbiAgICByZXR1cm4gKFxuICAgICAgICBlbGxpcHNlLnggPT09IHRvQ29tcGFyZS54ICYmXG4gICAgICAgIGVsbGlwc2UueSA9PT0gdG9Db21wYXJlLnkgJiZcbiAgICAgICAgZWxsaXBzZS53aWR0aCA9PT0gdG9Db21wYXJlLndpZHRoICYmXG4gICAgICAgIGVsbGlwc2UuaGVpZ2h0ID09PSB0b0NvbXBhcmUuaGVpZ2h0XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XG5cbnZhciBHZXRCb3VuZHMgPSBmdW5jdGlvbiAoZWxsaXBzZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUmVjdGFuZ2xlKCk7IH1cblxuICAgIG91dC54ID0gZWxsaXBzZS54IC0gZWxsaXBzZS53aWR0aDtcbiAgICBvdXQueSA9IGVsbGlwc2UueSAtIGVsbGlwc2UuaGVpZ2h0O1xuICAgIG91dC53aWR0aCA9IGVsbGlwc2Uud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IGVsbGlwc2UuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Qm91bmRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL0dldEJvdW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vZWxsaXBzZS9HZXRCb3VuZHMuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGVsbGlwc2UsIHgsIHkpXG57XG4gICAgZWxsaXBzZS54ICs9IHg7XG4gICAgZWxsaXBzZS55ICs9IHk7XG5cbiAgICByZXR1cm4gZWxsaXBzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9lbGxpcHNlL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIChlbGxpcHNlLCBwb2ludClcbntcbiAgICBlbGxpcHNlLnggKz0gcG9pbnQueDtcbiAgICBlbGxpcHNlLnkgKz0gcG9pbnQueTtcblxuICAgIHJldHVybiBlbGxpcHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vZWxsaXBzZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5FbGxpcHNlXG5cbnZhciBFbGxpcHNlID0gcmVxdWlyZSgnLi9FbGxpcHNlJyk7XG5cbkVsbGlwc2UuQXJlYSA9IHJlcXVpcmUoJy4vQXJlYScpO1xuRWxsaXBzZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcbkVsbGlwc2UuQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5FbGxpcHNlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcbkVsbGlwc2UuQ29udGFpbnNSZWN0ID0gcmVxdWlyZSgnLi9Db250YWluc1JlY3QnKTtcbkVsbGlwc2UuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XG5FbGxpcHNlLkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XG5FbGxpcHNlLkdldEJvdW5kcyA9IHJlcXVpcmUoJy4vR2V0Qm91bmRzJyk7XG5FbGxpcHNlLk9mZnNldCA9IHJlcXVpcmUoJy4vT2Zmc2V0Jyk7XG5FbGxpcHNlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xuRWxsaXBzZS5SYW5kb20gPSByZXF1aXJlKCcuL1JhbmRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2VsbGlwc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2VsbGlwc2UvaW5kZXguanMiLCJ2YXIgR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XG52YXIgRmluZFQgPSByZXF1aXJlKCcuL0ZpbmRUJyk7XG5cbi8qKlxuKiBDYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgYW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSBjdXJ2ZXMgdGFuZ2VudCBhdCB0aGUgZ2l2ZW4gcGl4ZWwgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlcyBsZW5ndGguXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0QW5nbGVXaXRoRGlzdGFuY2VcbiogQHBhcmFtIHtudW1iZXJ9IFtkaXN0YW5jZT0wXSAtIFRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdG8gZ2V0IHRoZSBhbmdsZSBmcm9tLCBpbiBwaXhlbHMuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlLiBUaGUgdmFsdWUgaXMgaW4gcmFkaWFucy5cbiovXG52YXIgR2V0QW5nbGVXaXRoRGlzdGFuY2UgPSBmdW5jdGlvbiAoY3VydmUsIGRpc3RhbmNlKVxue1xuICAgIGlmIChkaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7IGRpc3RhbmNlID0gMDsgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl92MXksIHRoaXMuX3YxeCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBHZXRBbmdsZShjdXJ2ZSwgRmluZFQoY3VydmUsIGRpc3RhbmNlKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBbmdsZVdpdGhEaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRBbmdsZVdpdGhEaXN0YW5jZS5qcyIsIi8qKlxuKiBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBjdXJ2ZXMgZW50cnkgcG9pbnQuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkhlcm1pdGUjZ2V0RW50cnlUYW5nZW50XG4qIEBwYXJhbSB7UGhhc2VyLlBvaW50fE9iamVjdH0gcG9pbnQgLSBUaGUgUGhhc2VyLlBvaW50IG9iamVjdCwgb3IgYW4gT2JqZWN0IHdpdGggcHVibGljIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIGluIHdoaWNoIHRoZSB0YW5nZW50IHZlY3RvciB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB0aGUgdGFuZ2VudCB2ZWN0b3Igb2YgdGhpcyBIZXJtaXRlIGN1cnZlLlxuKi9cbnZhciBHZXRFbnRyeVRhbmdlbnQgPSBmdW5jdGlvbiAoY3VydmUsIHBvaW50KVxue1xuICAgIHBvaW50LnggPSBjdXJ2ZS5fdjF4O1xuICAgIHBvaW50LnkgPSBjdXJ2ZS5fdjF5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRFbnRyeVRhbmdlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0RW50cnlUYW5nZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi4vcG9pbnQvUG9pbnQnKTtcbnZhciBHZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcbnZhciBGaW5kVCA9IHJlcXVpcmUoJy4vRmluZFQnKTtcblxuLyoqXG4qIEdldCBhIHBvaW50IG9uIHRoZSBjdXJ2ZSB1c2luZyB0aGUgZGlzdGFuY2UsIGluIHBpeGVscywgYWxvbmcgdGhlIGN1cnZlLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2dldFBvaW50V2l0aERpc3RhbmNlXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2Rpc3RhbmNlPTBdIC0gVGhlIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB0byBnZXQgdGhlIHBvaW50IGZyb20sIGdpdmVuIGluIHBpeGVscy5cbiogQHBhcmFtIHtQaGFzZXIuUG9pbnR8T2JqZWN0fSBbcG9pbnRdIC0gQW4gb3B0aW9uYWwgUGhhc2VyLlBvaW50LCBvciBPYmplY3QgY29udGFpbmluZyBwdWJsaWMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgZ2l2ZW4gdGhlIHJlc3VsdGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIE9iamVjdHMgYHhgIGFuZCBgeWAgcHJvcGVydGllcy4gSWYgb21pdHRlZCBhIG5ldyBQaGFzZXIuUG9pbnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4qIEByZXR1cm4ge1BoYXNlci5Qb2ludH0gVGhlIHBvaW50IG9uIHRoZSBsaW5lIGF0IHRoZSBzcGVjaWZpZWQgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgY3VydmUuXG4qL1xudmFyIEdldFBvaW50V2l0aERpc3RhbmNlID0gZnVuY3Rpb24gKGN1cnZlLCBkaXN0YW5jZSwgb3V0KVxue1xuICAgIGlmIChkaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7IGRpc3RhbmNlID0gMDsgfVxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDw9IDApXG4gICAge1xuICAgICAgICBvdXQueCA9IHRoaXMuX3AxeDtcbiAgICAgICAgb3V0LnkgPSB0aGlzLl9wMXk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIEdldFBvaW50KGN1cnZlLCBGaW5kVChjdXJ2ZSwgZGlzdGFuY2UpLCBvdXQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRQb2ludFdpdGhEaXN0YW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9HZXRQb2ludFdpdGhEaXN0YW5jZS5qcyIsIi8qKlxuKiBHZXQgdGhlIFggY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLCB3aGljaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRYXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWCBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXG4qL1xudmFyIEdldFggPSBmdW5jdGlvbiAoY3VydmUsIHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAodCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPiAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciB0MyA9IHQgKiB0MjtcblxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXggKyB0MiAqIGN1cnZlLl9ieCArIHQgKiBjdXJ2ZS5fdjF4ICsgY3VydmUuX3AxeCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WC5qc1xuLy8gbW9kdWxlIGlkID0gMzU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBHZXQgdGhlIFkgY29tcG9uZW50IG9mIGEgcG9pbnQgb24gdGhlIGN1cnZlIGJhc2VkIG9uIHRoZSBgdGAgKHRpbWUpIHZhbHVlLCB3aGljaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cbipcbiogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNnZXRZXG4qIEBwYXJhbSB7bnVtYmVyfSBbdD0wXSAtIFRoZSB0aW1lIHZhbHVlIGFsb25nIHRoZSBjdXJ2ZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgYSBwb2ludC4gVGhpcyBpcyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgY3VydmUgYW5kIDEgdGhlIGVuZC5cbiogQHJldHVybiB7bnVtYmVyfSBUaGUgWSBjb21wb25lbnQgb2YgYSBwb2ludCBvbiB0aGUgY3VydmUgYmFzZWQgb24gdGhlIGB0YCAodGltZSkgdmFsdWUuXG4qL1xudmFyIEdldFkgPSBmdW5jdGlvbiAoY3VydmUsIHQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAodCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPiAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciB0MyA9IHQgKiB0MjtcblxuICAgIHJldHVybiAodDMgKiBjdXJ2ZS5fYXkgKyB0MiAqIGN1cnZlLl9ieSArIHQgKiBjdXJ2ZS5fdjF5ICsgY3VydmUuX3AxeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvR2V0WS5qc1xuLy8gbW9kdWxlIGlkID0gMzU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAYXV0aG9yICAgICAgIFBldGUgQmFyb24gPHBldGVAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBBIGRhdGEgcmVwcmVzZW50YXRpb24gb2YgYSBIZXJtaXRlIEN1cnZlIChzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSlcbiogXG4qIEEgSGVybWl0ZSBjdXJ2ZSBoYXMgYSBzdGFydCBhbmQgZW5kIHBvaW50IGFuZCB0YW5nZW50IHZlY3RvcnMgZm9yIGJvdGggb2YgdGhlbS5cbiogVGhlIGN1cnZlIHdpbGwgYWx3YXlzIHBhc3MgdGhyb3VnaCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIGFuZCB0aGUgc2hhcGUgb2YgaXQgaXMgY29udHJvbGxlZFxuKiBieSB0aGUgbGVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIHRhbmdlbnQgdmVjdG9ycy4gIEF0IHRoZSBjb250cm9sIHBvaW50cyB0aGUgY3VydmUgd2lsbFxuKiBiZSBmYWNpbmcgZXhhY3RseSBpbiB0aGUgdmVjdG9yIGRpcmVjdGlvbi5cbiogXG4qIEFzIHRoZXNlIGN1cnZlcyBjaGFuZ2Ugc3BlZWQgKHNwZWVkID0gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgc2VwYXJhdGVkIGJ5IGFuIGVxdWFsIGNoYW5nZSBpblxuKiAndCcgdmFsdWUgLSBzZWUgSGVybWl0ZS5nZXRQb2ludCkgdGhpcyBjbGFzcyBhdHRlbXB0cyB0byByZWR1Y2UgdGhlIHZhcmlhdGlvbiBieSBwcmUtY2FsY3VsYXRpbmdcbiogdGhlIGBhY2N1cmFjeWAgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmUuIFRoZSBzdHJhaWdodC1saW5lIGRpc3RhbmNlcyB0byB0aGVzZSBwb2ludHMgYXJlIHN0b3JlZFxuKiBpbiB0aGUgcHJpdmF0ZSAncG9pbnRzJyBhcnJheSwgYW5kIHRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCBieSBIZXJtaXRlLmZpbmRUKCkgdG8gY29udmVydCBhIHBpeGVsXG4qIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSBpbnRvIGEgJ3RpbWUnIHZhbHVlLlxuKiBcbiogSGlnaGVyIGBhY2N1cmFjeWAgdmFsdWVzIHdpbGwgcmVzdWx0IGluIG1vcmUgZXZlbiBtb3ZlbWVudCwgYnV0IHJlcXVpcmUgbW9yZSBtZW1vcnkgZm9yIHRoZSBwb2ludHNcbiogbGlzdC4gNSB3b3JrcywgYnV0IDEwIHNlZW1zIHRvIGJlIGFuIGlkZWFsIHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIGN1cnZlcyBmb3VuZCBpbiBtb3N0IGdhbWVzIG9uXG4qIGEgZGVza3RvcCBzY3JlZW4uIElmIHlvdSB1c2UgdmVyeSBsb25nIGN1cnZlcyAobW9yZSB0aGFuIDQwMCBwaXhlbHMpIHlvdSBtYXkgbmVlZCB0byBpbmNyZWFzZVxuKiB0aGlzIHZhbHVlIGZ1cnRoZXIuXG4qXG4qIEBjbGFzcyBQaGFzZXIuSGVybWl0ZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtudW1iZXJ9IHAxeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHAxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHAyeCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUuXG4qIEBwYXJhbSB7bnVtYmVyfSBwMnkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuKiBAcGFyYW0ge251bWJlcn0gdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHYxeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXG4qIEBwYXJhbSB7bnVtYmVyfSB2MnggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGZvciB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHYyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuKiBAcGFyYW0ge251bWJlcn0gW2FjY3VyYWN5PTEwXSBUaGUgYW1vdW50IG9mIHBvaW50cyB0byBwcmUtY2FsY3VsYXRlIG9uIHRoZSBjdXJ2ZS5cbiovXG52YXIgSGVybWl0ZSA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgcDJ4LCBwMnksIHYxeCwgdjF5LCB2MngsIHYyeSwgYWNjdXJhY3kpXG57XG4gICAgaWYgKGFjY3VyYWN5ID09PSB1bmRlZmluZWQpIHsgYWNjdXJhY3kgPSAxMDsgfVxuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX2FjY3VyYWN5IC0gVGhlIGFtb3VudCBvZiBwb2ludHMgdG8gcHJlLWNhbGN1bGF0ZSBvbiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fYWNjdXJhY3kgPSBhY2N1cmFjeTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9wMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fcDF4ID0gcDF4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3AxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMXkgPSBwMXk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMnggPSBwMng7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9wMnkgPSBwMnk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl92MXggPSB2MXg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl92MXkgPSB2MXk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fdjJ4ID0gdjJ4O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3YyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX3YyeSA9IHYyeTtcbiAgICBcbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IF9wb2ludHMgLSBBIGxvY2FsIGFycmF5IG9mIGNhY2hlZCBwb2ludHMuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fcG9pbnRzID0gW107XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlBvaW50fSBfdGVtcDEgLSBBIGxvY2FsIGNhY2hlZCBQb2ludCBvYmplY3QuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fdGVtcDEgPSBuZXcgUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuUG9pbnR9IF90ZW1wMiAtIEEgbG9jYWwgY2FjaGVkIFBvaW50IG9iamVjdC5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl90ZW1wMiA9IG5ldyBQb2ludCgpO1xuXG4gICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xufTtcblxuSGVybWl0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZXJtaXRlO1xuXG5IZXJtaXRlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogUGVyZm9ybXMgdGhlIGN1cnZlIGNhbGN1bGF0aW9ucy5cbiAgICAqXG4gICAgKiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIHlvdSBjaGFuZ2UgYW55IG9mIHRoZSBjdXJ2ZXMgcHVibGljIHByb3BlcnRpZXMsIHN1Y2ggYXMgYEhlcm1pdGUucDF4YCBvciBgSGVybWl0ZS52MnlgLlxuICAgICpcbiAgICAqIElmIHlvdSBhZGp1c3QgYW55IG9mIHRoZSBpbnRlcm5hbCBwcml2YXRlIHZhbHVlcywgdGhlbiBjYWxsIHRoaXMgdG8gdXBkYXRlIHRoZSBwb2ludHMuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuSGVybWl0ZSNyZWNhbGN1bGF0ZVxuICAgICogQHJldHVybiB7UGhhc2VyLkhlcm1pdGV9IFRoaXMgb2JqZWN0LlxuICAgICovXG4gICAgcmVjYWxjdWxhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLl9heCA9ICgyICogdGhpcy5fcDF4IC0gMiAqIHRoaXMuX3AyeCArIHRoaXMuX3YxeCArIHRoaXMuX3YyeCk7XG4gICAgICAgIHRoaXMuX2F5ID0gKDIgKiB0aGlzLl9wMXkgLSAyICogdGhpcy5fcDJ5ICsgdGhpcy5fdjF5ICsgdGhpcy5fdjJ5KTtcbiAgICAgICAgdGhpcy5fYnggPSAoLTMgKiB0aGlzLl9wMXggKyAzICogdGhpcy5fcDJ4IC0gMiAqIHRoaXMuX3YxeCAtIHRoaXMuX3YyeCk7XG4gICAgICAgIHRoaXMuX2J5ID0gKC0zICogdGhpcy5fcDF5ICsgMyAqIHRoaXMuX3AyeSAtIDIgKiB0aGlzLl92MXkgLSB0aGlzLl92MnkpO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVFdmVuUG9pbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQ2FsY3VsYXRlIGEgbnVtYmVyIG9mIHBvaW50cyBhbG9uZyB0aGUgY3VydmUsIGJhc2VkIG9uIGBIZXJtaXRlLmFjY3VyYWN5YCwgYW5kIHN0b3JlcyB0aGVtIGluIHRoZSBwcml2YXRlIGBfcG9pbnRzYCBhcnJheS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5IZXJtaXRlI2NhbGN1bGF0ZUV2ZW5Qb2ludHNcbiAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgY3VydmUgYXBwcm94aW1hdGVkIGFzIHN0cmFpZ2h0IGxpbmUgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHBvaW50cy5cbiAgICAqL1xuICAgIGNhbGN1bGF0ZUV2ZW5Qb2ludHM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgIHRoaXMuX3RlbXAxLnNldFRvKDAsIDApOyAgICAgICAgICAgICAgICAgICAgLy8gIHBudFxuICAgICAgICB0aGlzLl90ZW1wMi5zZXRUbyh0aGlzLl9wMXgsIHRoaXMuX3AxeSk7ICAgIC8vICBsYXN0UG50XG5cbiAgICAgICAgdGhpcy5fcG9pbnRzWzBdID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLl9hY2N1cmFjeTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdldFBvaW50KGkgLyB0aGlzLl9hY2N1cmFjeSwgdGhpcy5fdGVtcDEpO1xuXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSB0aGlzLl90ZW1wMS5kaXN0YW5jZSh0aGlzLl90ZW1wMik7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXSA9IHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdGVtcDIuY29weUZyb20odGhpcy5fdGVtcDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVybWl0ZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjYWNjdXJhY3lcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhY2N1cmFjeSAtIFRoZSBhbW91bnQgb2YgcG9pbnRzIHRvIHByZS1jYWxjdWxhdGUgb24gdGhlIGN1cnZlLlxuICAgICovXG4gICAgYWNjdXJhY3k6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjY3VyYWN5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FjY3VyYWN5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjY3VyYWN5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAbmFtZSBQaGFzZXIuSGVybWl0ZSNwMXhcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwMXggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHAxeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcDF4O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3AxeClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wMXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3AxeVxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHAxeSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgcDF5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AxeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDJ4XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgcDJ4OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMng7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDJ4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AyeCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjcDJ5XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gcDJ5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgcDJ5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wMnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcDJ5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjF4XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgdjF4OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92MXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdjF4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3YxeCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjF5XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjF5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBjdXJ2ZS4gU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgcmVjYWxjdWxhdGUgdGhlIGN1cnZlLlxuICAgICovXG4gICAgdjF5OiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92MXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdjF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3YxeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQG5hbWUgUGhhc2VyLkhlcm1pdGUjdjJ4XG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdjJ4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0YW5nZW50IHZlY3RvciBmb3IgdGhlIGVuZCBvZiB0aGUgY3VydmUuIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIHJlY2FsY3VsYXRlIHRoZSBjdXJ2ZS5cbiAgICAqL1xuICAgIHYyeDoge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjJ4O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3YyeClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92MnggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBuYW1lIFBoYXNlci5IZXJtaXRlI3YyeVxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHYyeSAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgZm9yIHRoZSBlbmQgb2YgdGhlIGN1cnZlLiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCByZWNhbGN1bGF0ZSB0aGUgY3VydmUuXG4gICAgKi9cbiAgICB2Mnk6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyeTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92MnkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdjJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlcm1pdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvSGVybWl0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaGVybWl0ZS9IZXJtaXRlLmpzIiwiLy8gIFBoYXNlci5HZW9tLkhlcm1pdGVcblxudmFyIEhlcm1pdGUgPSByZXF1aXJlKCcuL0hlcm1pdGUnKTtcblxuSGVybWl0ZS5GaW5kVCA9IHJlcXVpcmUoJy4vRmluZFQnKTtcbkhlcm1pdGUuR2V0QW5nbGUgPSByZXF1aXJlKCcuL0dldEFuZ2xlJyk7XG5IZXJtaXRlLkdldEFuZ2xlV2l0aERpc3RhbmNlID0gcmVxdWlyZSgnLi9HZXRBbmdsZVdpdGhEaXN0YW5jZScpO1xuSGVybWl0ZS5HZXRFbnRyeVRhbmdlbnQgPSByZXF1aXJlKCcuL0dldEVudHJ5VGFuZ2VudCcpO1xuSGVybWl0ZS5HZXRQb2ludCA9IHJlcXVpcmUoJy4vR2V0UG9pbnQnKTtcbkhlcm1pdGUuR2V0UG9pbnRXaXRoRGlzdGFuY2UgPSByZXF1aXJlKCcuL0dldFBvaW50V2l0aERpc3RhbmNlJyk7XG5IZXJtaXRlLkdldFggPSByZXF1aXJlKCcuL0dldFgnKTtcbkhlcm1pdGUuR2V0WSA9IHJlcXVpcmUoJy4vR2V0WScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlcm1pdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2hlcm1pdGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2hlcm1pdGUvaW5kZXguanMiLCJ2YXIgRGlzdGFuY2VCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZUJldHdlZW4nKTtcblxudmFyIENpcmNsZVRvQ2lyY2xlID0gZnVuY3Rpb24gKGNpcmNsZUEsIGNpcmNsZUIpXG57XG4gICAgcmV0dXJuIChEaXN0YW5jZUJldHdlZW4oY2lyY2xlQS54LCBjaXJjbGVBLnksIGNpcmNsZUIueCwgY2lyY2xlQi55KSA8PSAoY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVUb0NpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb0NpcmNsZS5qcyIsInZhciBDaXJjbGVUb1JlY3RhbmdsZSA9IGZ1bmN0aW9uIChjaXJjbGUsIHJlY3QpXG57XG4gICAgdmFyIGhhbGZXaWR0aCA9IHJlY3Qud2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgdmFyIGN4ID0gTWF0aC5hYnMoY2lyY2xlLnggLSByZWN0LnggLSBoYWxmV2lkdGgpO1xuICAgIHZhciB4RGlzdCA9IGhhbGZXaWR0aCArIGNpcmNsZS5yYWRpdXM7XG5cbiAgICBpZiAoY3ggPD0gaGFsZldpZHRoIHx8IGN4ID4geERpc3QpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gTWF0aC5hYnMoY2lyY2xlLnkgLSByZWN0LnkgLSBoYWxmSGVpZ2h0KTtcbiAgICB2YXIgeURpc3QgPSBoYWxmSGVpZ2h0ICsgY2lyY2xlLnJhZGl1cztcblxuICAgIGlmIChjeSA8PSBoYWxmSGVpZ2h0IHx8IGN5ID4geURpc3QpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHhDb3JuZXJEaXN0ID0gY3ggLSBoYWxmV2lkdGg7XG4gICAgdmFyIHlDb3JuZXJEaXN0ID0gY3kgLSBoYWxmSGVpZ2h0O1xuICAgIHZhciB4Q29ybmVyRGlzdFNxID0geENvcm5lckRpc3QgKiB4Q29ybmVyRGlzdDtcbiAgICB2YXIgeUNvcm5lckRpc3RTcSA9IHlDb3JuZXJEaXN0ICogeUNvcm5lckRpc3Q7XG4gICAgdmFyIG1heENvcm5lckRpc3RTcSA9IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzO1xuXG4gICAgcmV0dXJuICh4Q29ybmVyRGlzdFNxICsgeUNvcm5lckRpc3RTcSA8PSBtYXhDb3JuZXJEaXN0U3EpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVUb1JlY3RhbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9DaXJjbGVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvUmVjdGFuZ2xlJyk7XG52YXIgUmVjdGFuZ2xlVG9SZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZVRvUmVjdGFuZ2xlJyk7XG5cbnZhciBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdXRwdXQpXG57XG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IG5ldyBSZWN0YW5nbGUoKTsgfVxuXG4gICAgaWYgKFJlY3RhbmdsZVRvUmVjdGFuZ2xlKHJlY3RBLCByZWN0QikpXG4gICAge1xuICAgICAgICBvdXRwdXQueCA9IE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xuICAgICAgICBvdXRwdXQueSA9IE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xuICAgICAgICBvdXRwdXQud2lkdGggPSBNYXRoLm1pbihyZWN0QS5yaWdodCwgcmVjdEIucmlnaHQpIC0gb3V0cHV0Lng7XG4gICAgICAgIG91dHB1dC5oZWlnaHQgPSBNYXRoLm1pbihyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSBvdXRwdXQueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL0dldFJlY3RhbmdsZUludGVyc2VjdGlvbi5qcyIsIi8qKlxuKiBDaGVja3MgZm9yIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBMaW5lIGFuZCBhIFJlY3RhbmdsZSBzaGFwZSwgb3IgYSByZWN0YW5nbGUtbGlrZVxuKiBvYmplY3QsIHdpdGggcHVibGljIGB4YCwgYHlgLCBgcmlnaHRgIGFuZCBgYm90dG9tYCBwcm9wZXJ0aWVzLCBzdWNoIGFzIGEgU3ByaXRlIG9yIEJvZHkuXG4qXG4qIEFuIGludGVyc2VjdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkIGlmOlxuKlxuKiBUaGUgbGluZSBzdGFydHMgd2l0aGluLCBvciBlbmRzIHdpdGhpbiwgdGhlIFJlY3RhbmdsZS5cbiogVGhlIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgNCByZWN0YW5nbGUgZWRnZXMuXG4qXG4qIFRoZSBmb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZnVuY3Rpb24gcmVjdGFuZ2xlcyBhcmUgY29uc2lkZXJlZCAnc29saWQnLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5MaW5lLmludGVyc2VjdHNSZWN0YW5nbGVcbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gbGluZSAtIFRoZSBsaW5lIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aC5cbiogQHBhcmFtIHtQaGFzZXIuUmVjdGFuZ2xlfG9iamVjdH0gcmVjdCAtIFRoZSByZWN0YW5nbGUsIG9yIHJlY3RhbmdsZS1saWtlIG9iamVjdCwgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoLlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBsaW5lIGludGVyc2VjdHMgd2l0aCB0aGUgcmVjdGFuZ2xlIGVkZ2VzLCBvciBzdGFydHMgb3IgZW5kcyB3aXRoaW4gdGhlIHJlY3RhbmdsZS5cbiovXG52YXIgTGluZVRvUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxpbmUsIHJlY3QpXG57XG4gICAgdmFyIHgxID0gbGluZS54MTtcbiAgICB2YXIgeTEgPSBsaW5lLnkyO1xuXG4gICAgdmFyIHgyID0gbGluZS54MjtcbiAgICB2YXIgeTIgPSBsaW5lLnkyO1xuXG4gICAgdmFyIGJ4MSA9IHJlY3QueDtcbiAgICB2YXIgYnkxID0gcmVjdC55O1xuICAgIHZhciBieDIgPSByZWN0LnJpZ2h0O1xuICAgIHZhciBieTIgPSByZWN0LmJvdHRvbTtcblxuICAgIHZhciB0ID0gMDtcblxuICAgIC8vICBJZiB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBsaW5lIGlzIGluc2lkZSB0aGUgcmVjdCB0aGVuIHdlIGFzc3VtZVxuICAgIC8vICBjb2xsaXNpb24sIGFzIHJlY3RzIGFyZSBzb2xpZCBmb3Igb3VyIHVzZS1jYXNlLlxuXG4gICAgaWYgKCh4MSA+PSBieDEgJiYgeDEgPD0gYngyICYmIHkxID49IGJ5MSAmJiB5MSA8PSBieTIpIHx8XG4gICAgICAgICh4MiA+PSBieDEgJiYgeDIgPD0gYngyICYmIHkyID49IGJ5MSAmJiB5MiA8PSBieTIpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHgxIDwgYngxICYmIHgyID49IGJ4MSlcbiAgICB7XG4gICAgICAgIC8vICBMZWZ0IGVkZ2VcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MSAtIHgxKSAvICh4MiAtIHgxKTtcblxuICAgICAgICBpZiAodCA+IGJ5MSAmJiB0IDw9IGJ5MilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoeDEgPiBieDIgJiYgeDIgPD0gYngyKVxuICAgIHtcbiAgICAgICAgLy8gIFJpZ2h0IGVkZ2VcbiAgICAgICAgdCA9IHkxICsgKHkyIC0geTEpICogKGJ4MiAtIHgxKSAvICh4MiAtIHgxKTtcblxuICAgICAgICBpZiAodCA+PSBieTEgJiYgdCA8PSBieTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHkxIDwgYnkxICYmIHkyID49IGJ5MSlcbiAgICB7XG4gICAgICAgIC8vICBUb3AgZWRnZVxuICAgICAgICB0ID0geDEgKyAoeDIgLSB4MSkgKiAoYnkxIC0geTEpIC8gKHkyIC0geTEpO1xuXG4gICAgICAgIGlmICh0ID49IGJ4MSAmJiB0IDw9IGJ4MilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoeTEgPiBieTIgJiYgeTIgPD0gYnkyKVxuICAgIHtcbiAgICAgICAgLy8gIEJvdHRvbSBlZGdlXG4gICAgICAgIHQgPSB4MSArICh4MiAtIHgxKSAqIChieTIgLSB5MSkgLyAoeTIgLSB5MSk7XG5cbiAgICAgICAgaWYgKHQgPj0gYngxICYmIHQgPD0gYngyKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVRvUmVjdGFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL0xpbmVUb1JlY3RhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludFRvTGluZSA9IHJlcXVpcmUoJy4vUG9pbnRUb0xpbmUnKTtcblxudmFyIFBvaW50VG9MaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChwb2ludCwgbGluZSlcbntcbiAgICBpZiAoIVBvaW50VG9MaW5lKHBvaW50LCBsaW5lKSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgeE1pbiA9IE1hdGgubWluKGxpbmUueDEsIGxpbmUueDIpO1xuICAgIHZhciB4TWF4ID0gTWF0aC5tYXgobGluZS54MSwgbGluZS54Mik7XG4gICAgdmFyIHlNaW4gPSBNYXRoLm1pbihsaW5lLnkxLCBsaW5lLnkyKTtcbiAgICB2YXIgeU1heCA9IE1hdGgubWF4KGxpbmUueTEsIGxpbmUueTIpO1xuXG4gICAgcmV0dXJuICgocG9pbnQueCA+PSB4TWluICYmIHBvaW50LnggPD0geE1heCkgJiYgKHBvaW50LnkgPj0geU1pbiAmJiBwb2ludC55IDw9IHlNYXgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb0xpbmVTZWdtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1BvaW50VG9MaW5lU2VnbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9Qb2ludFRvTGluZVNlZ21lbnQuanMiLCJcbnZhciBMaW5lVG9MaW5lID0gcmVxdWlyZSgnLi9MaW5lVG9MaW5lJyk7XG52YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuLi9yZWN0YW5nbGUvQ29udGFpbnMnKTtcbnZhciBDb250YWluc0FycmF5ID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnNBcnJheScpO1xudmFyIERlY29tcG9zZSA9IHJlcXVpcmUoJy4uL3JlY3RhbmdsZS9EZWNvbXBvc2UnKTtcblxudmFyIFJlY3RhbmdsZVRvVHJpYW5nbGUgPSBmdW5jdGlvbiAocmVjdCwgdHJpYW5nbGUpXG57XG4gICAgLy8gIEZpcnN0IHRoZSBjaGVhcGVzdCBvbmVzOlxuXG4gICAgaWYgKFxuICAgICAgICB0cmlhbmdsZS5sZWZ0ID4gcmVjdC5yaWdodCB8fFxuICAgICAgICB0cmlhbmdsZS5yaWdodCA8IHJlY3QubGVmdCB8fFxuICAgICAgICB0cmlhbmdsZS50b3AgPiByZWN0LmJvdHRvbSB8fFxuICAgICAgICB0cmlhbmdsZS5ib3R0b20gPCByZWN0LnRvcClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdHJpQSA9IHRyaWFuZ2xlLmdldExpbmVBKCk7XG4gICAgdmFyIHRyaUIgPSB0cmlhbmdsZS5nZXRMaW5lQigpO1xuICAgIHZhciB0cmlDID0gdHJpYW5nbGUuZ2V0TGluZUMoKTtcblxuICAgIC8vICBBcmUgYW55IG9mIHRoZSB0cmlhbmdsZSBwb2ludHMgd2l0aGluIHRoZSByZWN0YW5nbGU/XG5cbiAgICBpZiAoQ29udGFpbnMocmVjdCwgdHJpQS54MSwgdHJpQS55MSkgfHwgQ29udGFpbnMocmVjdCwgdHJpQS54MiwgdHJpQS55MikpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoQ29udGFpbnMocmVjdCwgdHJpQi54MSwgdHJpQi55MSkgfHwgQ29udGFpbnMocmVjdCwgdHJpQi54MiwgdHJpQi55MikpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoQ29udGFpbnMocmVjdCwgdHJpQy54MSwgdHJpQy55MSkgfHwgQ29udGFpbnMocmVjdCwgdHJpQy54MiwgdHJpQy55MikpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAgQ2hlYXAgdGVzdHMgb3Zlciwgbm93IHRvIHNlZSBpZiBhbnkgb2YgdGhlIGxpbmVzIGludGVyc2VjdCAuLi5cblxuICAgIHZhciByZWN0QSA9IHJlY3QuZ2V0TGluZUEoKTtcbiAgICB2YXIgcmVjdEIgPSByZWN0LmdldExpbmVCKCk7XG4gICAgdmFyIHJlY3RDID0gcmVjdC5nZXRMaW5lQygpO1xuICAgIHZhciByZWN0RCA9IHJlY3QuZ2V0TGluZUQoKTtcblxuICAgIGlmIChMaW5lVG9MaW5lKHRyaUEsIHJlY3RBKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3RCKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3RDKSB8fCBMaW5lVG9MaW5lKHRyaUEsIHJlY3REKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9MaW5lKHRyaUIsIHJlY3RBKSB8fCBMaW5lVG9MaW5lKHRyaUIsIHJlY3RCKSB8fCBMaW5lVG9MaW5lKHRyaUIsIHJlY3RDKSB8fCBMaW5lVG9MaW5lKHRyaUIsIHJlY3REKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9MaW5lKHRyaUMsIHJlY3RBKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3RCKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3RDKSB8fCBMaW5lVG9MaW5lKHRyaUMsIHJlY3REKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vICBOb25lIG9mIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHNvIGFyZSBhbnkgcmVjdGFuZ2xlIHBvaW50cyB3aXRoaW4gdGhlIHRyaWFuZ2xlP1xuXG4gICAgdmFyIHBvaW50cyA9IERlY29tcG9zZShyZWN0KTtcbiAgICB2YXIgd2l0aGluID0gQ29udGFpbnNBcnJheSh0cmlhbmdsZSwgcG9pbnRzLCB0cnVlKTtcblxuICAgIHJldHVybiAod2l0aGluLmxlbmd0aCA+IDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVUb1RyaWFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1JlY3RhbmdsZVRvVHJpYW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9UcmlhbmdsZS5qcyIsInZhciBSZWN0YW5nbGVUb1ZhbHVlcyA9IGZ1bmN0aW9uIChyZWN0LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRvbGVyYW5jZSlcbntcbiAgICBpZiAodG9sZXJhbmNlID09PSB1bmRlZmluZWQpIHsgdG9sZXJhbmNlID0gMDsgfVxuXG4gICAgcmV0dXJuICEoXG4gICAgICAgIGxlZnQgPiByZWN0LnJpZ2h0ICsgdG9sZXJhbmNlIHx8XG4gICAgICAgIHJpZ2h0IDwgcmVjdC5sZWZ0IC0gdG9sZXJhbmNlIHx8XG4gICAgICAgIHRvcCA+IHJlY3QuYm90dG9tICsgdG9sZXJhbmNlIHx8XG4gICAgICAgIGJvdHRvbSA8IHJlY3QudG9wIC0gdG9sZXJhbmNlXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlVG9WYWx1ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2ludGVyc2VjdHMvUmVjdGFuZ2xlVG9WYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBMaW5lVG9DaXJjbGUgPSByZXF1aXJlKCcuL0xpbmVUb0NpcmNsZScpO1xudmFyIENvbnRhaW5zID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvQ29udGFpbnMnKTtcblxudmFyIFRyaWFuZ2xlVG9DaXJjbGUgPSBmdW5jdGlvbiAodHJpYW5nbGUsIGNpcmNsZSlcbntcbiAgICAgLy8gIEZpcnN0IHRoZSBjaGVhcGVzdCBvbmVzOlxuXG4gICAgaWYgKFxuICAgICAgICB0cmlhbmdsZS5sZWZ0ID4gY2lyY2xlLnJpZ2h0IHx8XG4gICAgICAgIHRyaWFuZ2xlLnJpZ2h0IDwgY2lyY2xlLmxlZnQgfHxcbiAgICAgICAgdHJpYW5nbGUudG9wID4gY2lyY2xlLmJvdHRvbSB8fFxuICAgICAgICB0cmlhbmdsZS5ib3R0b20gPCBjaXJjbGUudG9wKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChDb250YWlucyh0cmlhbmdsZSwgY2lyY2xlKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9DaXJjbGUodHJpYW5nbGUuZ2V0TGluZUEoKSwgY2lyY2xlKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9DaXJjbGUodHJpYW5nbGUuZ2V0TGluZUIoKSwgY2lyY2xlKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9DaXJjbGUodHJpYW5nbGUuZ2V0TGluZUMoKSwgY2lyY2xlKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGVUb0NpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9DaXJjbGUuanMiLCJcbnZhciBMaW5lVG9MaW5lID0gcmVxdWlyZSgnLi9MaW5lVG9MaW5lJyk7XG52YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWlucycpO1xuXG52YXIgVHJpYW5nbGVUb0xpbmUgPSBmdW5jdGlvbiAodHJpYW5nbGUsIGxpbmUpXG57XG4gICAgLy8gIElmIHRoZSBUcmlhbmdsZSBjb250YWlucyBlaXRoZXIgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBvZiB0aGUgbGluZSwgaXQgaW50ZXJzZWN0c1xuICAgIGlmIChDb250YWlucyh0cmlhbmdsZSwgbGluZS5nZXRQb2ludEEoKSkgfHwgQ29udGFpbnModHJpYW5nbGUsIGxpbmUuZ2V0UG9pbnRCKCkpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gIE5vdyBjaGVjayB0aGUgbGluZSBhZ2FpbnN0IGVhY2ggbGluZSBvZiB0aGUgVHJpYW5nbGVcbiAgICBpZiAoTGluZVRvTGluZSh0cmlhbmdsZS5nZXRMaW5lQSgpLCBsaW5lKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChMaW5lVG9MaW5lKHRyaWFuZ2xlLmdldExpbmVCKCksIGxpbmUpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKExpbmVUb0xpbmUodHJpYW5nbGUuZ2V0TGluZUMoKSwgbGluZSkpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlVG9MaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9MaW5lLmpzIiwiXG52YXIgTGluZVRvTGluZSA9IHJlcXVpcmUoJy4vTGluZVRvTGluZScpO1xudmFyIENvbnRhaW5zQXJyYXkgPSByZXF1aXJlKCcuLi90cmlhbmdsZS9Db250YWluc0FycmF5Jyk7XG52YXIgRGVjb21wb3NlID0gcmVxdWlyZSgnLi4vdHJpYW5nbGUvRGVjb21wb3NlJyk7XG5cbnZhciBUcmlhbmdsZVRvVHJpYW5nbGUgPSBmdW5jdGlvbiAodHJpYW5nbGVBLCB0cmlhbmdsZUIpXG57XG4gICAgLy8gIEZpcnN0IHRoZSBjaGVhcGVzdCBvbmVzOlxuXG4gICAgaWYgKFxuICAgICAgICB0cmlhbmdsZUEubGVmdCA+IHRyaWFuZ2xlQi5yaWdodCB8fFxuICAgICAgICB0cmlhbmdsZUEucmlnaHQgPCB0cmlhbmdsZUIubGVmdCB8fFxuICAgICAgICB0cmlhbmdsZUEudG9wID4gdHJpYW5nbGVCLmJvdHRvbSB8fFxuICAgICAgICB0cmlhbmdsZUEuYm90dG9tIDwgdHJpYW5nbGVCLnRvcClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGluZUFBID0gdHJpYW5nbGVBLmdldExpbmVBKCk7XG4gICAgdmFyIGxpbmVBQiA9IHRyaWFuZ2xlQS5nZXRMaW5lQigpO1xuICAgIHZhciBsaW5lQUMgPSB0cmlhbmdsZUEuZ2V0TGluZUMoKTtcblxuICAgIHZhciBsaW5lQkEgPSB0cmlhbmdsZUIuZ2V0TGluZUEoKTtcbiAgICB2YXIgbGluZUJCID0gdHJpYW5nbGVCLmdldExpbmVCKCk7XG4gICAgdmFyIGxpbmVCQyA9IHRyaWFuZ2xlQi5nZXRMaW5lQygpO1xuXG4gICAgLy8gIE5vdyBjaGVjayB0aGUgbGluZXMgYWdhaW5zdCBlYWNoIGxpbmUgb2YgVHJpYW5nbGVCXG4gICAgaWYgKExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkEpIHx8IExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkIpIHx8IExpbmVUb0xpbmUobGluZUFBLCBsaW5lQkMpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkEpIHx8IExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkIpIHx8IExpbmVUb0xpbmUobGluZUFCLCBsaW5lQkMpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKExpbmVUb0xpbmUobGluZUFDLCBsaW5lQkEpIHx8IExpbmVUb0xpbmUobGluZUFDLCBsaW5lQkIpIHx8IExpbmVUb0xpbmUobGluZUFDLCBsaW5lQkMpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gIE5vcGUsIHNvIGNoZWNrIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHBvaW50cyBvZiB0cmlhbmdsZUEgYXJlIHdpdGhpbiB0cmlhbmdsZUJcblxuICAgIHZhciBwb2ludHMgPSBEZWNvbXBvc2UodHJpYW5nbGVBKTtcbiAgICB2YXIgd2l0aGluID0gQ29udGFpbnNBcnJheSh0cmlhbmdsZUIsIHBvaW50cywgdHJ1ZSk7XG5cbiAgICBpZiAod2l0aGluLmxlbmd0aCA+IDApXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAgRmluYWxseSBjaGVjayB0byBzZWUgaWYgYW55IG9mIHRoZSBwb2ludHMgb2YgdHJpYW5nbGVCIGFyZSB3aXRoaW4gdHJpYW5nbGVBXG5cbiAgICBwb2ludHMgPSBEZWNvbXBvc2UodHJpYW5nbGVCKTtcbiAgICB3aXRoaW4gPSBDb250YWluc0FycmF5KHRyaWFuZ2xlQSwgcG9pbnRzLCB0cnVlKTtcblxuICAgIGlmICh3aXRoaW4ubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGVUb1RyaWFuZ2xlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9pbnRlcnNlY3RzL1RyaWFuZ2xlVG9UcmlhbmdsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9UcmlhbmdsZVRvVHJpYW5nbGUuanMiLCIvLyAgUGhhc2VyLkdlb20uSW50ZXJzZWN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIENpcmNsZVRvQ2lyY2xlOiByZXF1aXJlKCcuL0NpcmNsZVRvQ2lyY2xlJyksXG4gICAgQ2lyY2xlVG9SZWN0YW5nbGU6IHJlcXVpcmUoJy4vQ2lyY2xlVG9SZWN0YW5nbGUnKSxcbiAgICBHZXRSZWN0YW5nbGVJbnRlcnNlY3Rpb246IHJlcXVpcmUoJy4vR2V0UmVjdGFuZ2xlSW50ZXJzZWN0aW9uJyksXG4gICAgTGluZVRvQ2lyY2xlOiByZXF1aXJlKCcuL0xpbmVUb0NpcmNsZScpLFxuICAgIExpbmVUb0xpbmU6IHJlcXVpcmUoJy4vTGluZVRvTGluZScpLFxuICAgIExpbmVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9MaW5lVG9SZWN0YW5nbGUnKSxcbiAgICBQb2ludFRvTGluZTogcmVxdWlyZSgnLi9Qb2ludFRvTGluZScpLFxuICAgIFBvaW50VG9MaW5lU2VnbWVudDogcmVxdWlyZSgnLi9Qb2ludFRvTGluZVNlZ21lbnQnKSxcbiAgICBSZWN0YW5nbGVUb1JlY3RhbmdsZTogcmVxdWlyZSgnLi9SZWN0YW5nbGVUb1JlY3RhbmdsZScpLFxuICAgIFJlY3RhbmdsZVRvVHJpYW5nbGU6IHJlcXVpcmUoJy4vUmVjdGFuZ2xlVG9UcmlhbmdsZScpLFxuICAgIFJlY3RhbmdsZVRvVmFsdWVzOiByZXF1aXJlKCcuL1JlY3RhbmdsZVRvVmFsdWVzJyksXG4gICAgVHJpYW5nbGVUb0NpcmNsZTogcmVxdWlyZSgnLi9UcmlhbmdsZVRvQ2lyY2xlJyksXG4gICAgVHJpYW5nbGVUb0xpbmU6IHJlcXVpcmUoJy4vVHJpYW5nbGVUb0xpbmUnKSxcbiAgICBUcmlhbmdsZVRvVHJpYW5nbGU6IHJlcXVpcmUoJy4vVHJpYW5nbGVUb1RyaWFuZ2xlJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vaW50ZXJzZWN0cy9pbmRleC5qcyIsIlxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKGxpbmUsIHgsIHkpXG57XG4gICAgdmFyIHR4ID0geCAtICgobGluZS54MSArIGxpbmUueDIpIC8gMik7XG4gICAgdmFyIHR5ID0geSAtICgobGluZS55MSArIGxpbmUueTIpIC8gMik7XG5cbiAgICBsaW5lLngxICs9IHR4O1xuICAgIGxpbmUueTEgKz0gdHk7XG5cbiAgICBsaW5lLngyICs9IHR4O1xuICAgIGxpbmUueTIgKz0gdHk7XG5cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvQ2VudGVyT24uanNcbi8vIG1vZHVsZSBpZCA9IDM3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGluZSA9IHJlcXVpcmUoJy4vTGluZScpO1xuXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxue1xuICAgIHJldHVybiBuZXcgTGluZShzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMzczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9DbG9uZS5qcyIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgTGluZS5cbiogQG1ldGhvZCBQaGFzZXIuTGluZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0xpbmV9IFRoaXMgTGluZSBvYmplY3QuXG4qL1xudmFyIENvcHlGcm9tID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdClcbntcbiAgICByZXR1cm4gZGVzdC5zZXRUbyhzb3VyY2UueDEsIHNvdXJjZS55MSwgc291cmNlLngyLCBzb3VyY2UueTIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAobGluZSwgdG9Db21wYXJlKVxue1xuICAgIHJldHVybiAoXG4gICAgICAgIGxpbmUueDEgPT09IHRvQ29tcGFyZS54MSAmJlxuICAgICAgICBsaW5lLnkxID09PSB0b0NvbXBhcmUueTEgJiZcbiAgICAgICAgbGluZS54MiA9PT0gdG9Db21wYXJlLngyICYmXG4gICAgICAgIGxpbmUueTIgPT09IHRvQ29tcGFyZS55MlxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuLi9wb2ludC9Qb2ludCcpO1xuXG52YXIgR2V0TWlkUG9pbnQgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgb3V0LnggPSAobGluZS54MSArIGxpbmUueDIpIC8gMjtcbiAgICBvdXQueSA9IChsaW5lLnkxICsgbGluZS55MikgLyAyO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0TWlkUG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDM3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvR2V0TWlkUG9pbnQuanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uLy4uL21hdGgvY29uc3QnKTtcbnZhciBBbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4uL3BvaW50L1BvaW50Jyk7XG5cbnZhciBHZXROb3JtYWwgPSBmdW5jdGlvbiAobGluZSwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIGEgPSBBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVO1xuXG4gICAgb3V0LnggPSBNYXRoLmNvcyhhKTtcbiAgICBvdXQueSA9IE1hdGguc2luKGEpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Tm9ybWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0dldE5vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gMzc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9HZXROb3JtYWwuanMiLCJ2YXIgSGVpZ2h0ID0gZnVuY3Rpb24gKGxpbmUpXG57XG4gICAgcmV0dXJuIE1hdGguYWJzKGxpbmUueTEgLSBsaW5lLnkyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGVpZ2h0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL0hlaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMZW5ndGggPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChsaW5lLngyIC0gbGluZS54MSkgKiAobGluZS54MiAtIGxpbmUueDEpICsgKGxpbmUueTIgLSBsaW5lLnkxKSAqIChsaW5lLnkyIC0gbGluZS55MSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZW5ndGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvTGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG52YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XG5cbnZhciBOb3JtYWxYID0gZnVuY3Rpb24gKGxpbmUpXG57XG4gICAgcmV0dXJuIE1hdGguY29zKEFuZ2xlKGxpbmUpIC0gTUFUSF9DT05TVC5UQVUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxYO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL05vcm1hbFguanNcbi8vIG1vZHVsZSBpZCA9IDM4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL2xpbmUvTm9ybWFsWC5qcyIsInZhciBNQVRIX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9jb25zdCcpO1xudmFyIEFuZ2xlID0gcmVxdWlyZSgnLi9BbmdsZScpO1xuXG52YXIgTm9ybWFsWSA9IGZ1bmN0aW9uIChsaW5lKVxue1xuICAgIHJldHVybiBNYXRoLnNpbihBbmdsZShsaW5lKSAtIE1BVEhfQ09OU1QuVEFVKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Ob3JtYWxZLmpzXG4vLyBtb2R1bGUgaWQgPSAzODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL05vcm1hbFkuanMiLCJ2YXIgT2Zmc2V0ID0gZnVuY3Rpb24gKGxpbmUsIHgsIHkpXG57XG4gICAgbGluZS54MSArPSB4O1xuICAgIGxpbmUueTEgKz0geTtcblxuICAgIGxpbmUueDIgKz0geDtcbiAgICBsaW5lLnkyICs9IHk7XG5cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL09mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQZXJwU2xvcGUgPSBmdW5jdGlvbiAobGluZSlcbntcbiAgICByZXR1cm4gLSgobGluZS54MiAtIGxpbmUueDEpIC8gKGxpbmUueTIgLSBsaW5lLnkxKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnBTbG9wZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9QZXJwU2xvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDM4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQW5nbGUgPSByZXF1aXJlKCcuL0FuZ2xlJyk7XG52YXIgTm9ybWFsQW5nbGUgPSByZXF1aXJlKCcuL05vcm1hbEFuZ2xlJyk7XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSByZWZsZWN0ZWQgYW5nbGUgYmV0d2VlbiB0d28gbGluZXMuXG4qIFRoaXMgaXMgdGhlIG91dGdvaW5nIGFuZ2xlIGJhc2VkIG9uIHRoZSBhbmdsZSBvZiBMaW5lIDEgYW5kIHRoZSBub3JtYWxBbmdsZSBvZiBMaW5lIDIuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUucmVmbGVjdFxuKiBAcGFyYW0ge1BoYXNlci5MaW5lfSBhIC0gVGhlIGJhc2UgbGluZS5cbiogQHBhcmFtIHtQaGFzZXIuTGluZX0gYiAtIFRoZSBsaW5lIHRvIGJlIHJlZmxlY3RlZCBmcm9tIHRoZSBiYXNlIGxpbmUuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHJlZmxlY3RlZCBhbmdsZSBpbiByYWRpYW5zLlxuKi9cbnZhciBSZWZsZWN0QW5nbGUgPSBmdW5jdGlvbiAobGluZUEsIGxpbmVCKVxue1xuICAgIHJldHVybiAoMiAqIE5vcm1hbEFuZ2xlKGxpbmVCKSAtIE1hdGguUEkgLSBBbmdsZShsaW5lQSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0QW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUmVmbGVjdEFuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JlZmxlY3RBbmdsZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChsaW5lLCBhbmdsZSlcbntcbiAgICB2YXIgeCA9IChsaW5lLngxICsgbGluZS54MikgLyAyO1xuICAgIHZhciB5ID0gKGxpbmUueTEgKyBsaW5lLnkyKSAvIDI7XG5cbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgeCwgeSwgYW5nbGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL2xpbmUvUm90YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL1JvdGF0ZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxudmFyIFJvdGF0ZUFyb3VuZFBvaW50ID0gZnVuY3Rpb24gKGxpbmUsIHBvaW50LCBhbmdsZSlcbntcbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkobGluZSwgcG9pbnQueCwgcG9pbnQueSwgYW5nbGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmRQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vbGluZS9Sb3RhdGVBcm91bmRQb2ludC5qcyIsInZhciBTZXRUb0FuZ2xlID0gZnVuY3Rpb24gKGxpbmUsIHgsIHksIGFuZ2xlLCBsZW5ndGgpXG57XG4gICAgbGluZS54MSA9IHg7XG4gICAgbGluZS55MSA9IHk7XG5cbiAgICBsaW5lLngyID0geCArIChNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgpO1xuICAgIGxpbmUueTIgPSB5ICsgKE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aCk7XG5cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0VG9BbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9TZXRUb0FuZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAzODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNsb3BlID0gZnVuY3Rpb24gKGxpbmUpXG57XG4gICAgcmV0dXJuIChsaW5lLnkyIC0gbGluZS55MSkgLyAobGluZS54MiAtIGxpbmUueDEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbG9wZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vbGluZS9TbG9wZS5qc1xuLy8gbW9kdWxlIGlkID0gMzg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXaWR0aCA9IGZ1bmN0aW9uIChsaW5lKVxue1xuICAgIHJldHVybiBNYXRoLmFicyhsaW5lLngxIC0gbGluZS54Mik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZHRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL1dpZHRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLkxpbmVcblxudmFyIExpbmUgPSByZXF1aXJlKCcuL0xpbmUnKTtcblxuTGluZS5BbmdsZSA9IHJlcXVpcmUoJy4vQW5nbGUnKTtcbkxpbmUuQ2VudGVyT24gPSByZXF1aXJlKCcuL0NlbnRlck9uJyk7XG5MaW5lLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xuTGluZS5Db3B5RnJvbSA9IHJlcXVpcmUoJy4vQ29weUZyb20nKTtcbkxpbmUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcbkxpbmUuR2V0TWlkUG9pbnQgPSByZXF1aXJlKCcuL0dldE1pZFBvaW50Jyk7XG5MaW5lLkdldE5vcm1hbCA9IHJlcXVpcmUoJy4vR2V0Tm9ybWFsJyk7XG5MaW5lLkdldFBvaW50c09uTGluZSA9IHJlcXVpcmUoJy4vR2V0UG9pbnRzT25MaW5lJyk7XG5MaW5lLkhlaWdodCA9IHJlcXVpcmUoJy4vSGVpZ2h0Jyk7XG5MaW5lLkxlbmd0aCA9IHJlcXVpcmUoJy4vTGVuZ3RoJyk7XG5MaW5lLk5vcm1hbEFuZ2xlID0gcmVxdWlyZSgnLi9Ob3JtYWxBbmdsZScpO1xuTGluZS5Ob3JtYWxYID0gcmVxdWlyZSgnLi9Ob3JtYWxYJyk7XG5MaW5lLk5vcm1hbFkgPSByZXF1aXJlKCcuL05vcm1hbFknKTtcbkxpbmUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcbkxpbmUuUGVycFNsb3BlID0gcmVxdWlyZSgnLi9QZXJwU2xvcGUnKTtcbkxpbmUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcbkxpbmUuUmVmbGVjdEFuZ2xlID0gcmVxdWlyZSgnLi9SZWZsZWN0QW5nbGUnKTtcbkxpbmUuUm90YXRlID0gcmVxdWlyZSgnLi9Sb3RhdGUnKTtcbkxpbmUuUm90YXRlQXJvdW5kUG9pbnQgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFBvaW50Jyk7XG5MaW5lLlJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xuTGluZS5TZXRUb0FuZ2xlID0gcmVxdWlyZSgnLi9TZXRUb0FuZ2xlJyk7XG5MaW5lLlNsb3BlID0gcmVxdWlyZSgnLi9TbG9wZScpO1xuTGluZS5XaWR0aCA9IHJlcXVpcmUoJy4vV2lkdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9saW5lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9saW5lL2luZGV4LmpzIiwidmFyIEFkZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54ICs9IHg7XG4gICAgcG9pbnQueSArPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0FkZC5qc1xuLy8gbW9kdWxlIGlkID0gMzkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhNYXRoLmNlaWwocG9pbnQueCksIE1hdGguY2VpbChwb2ludC55KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDM5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXG57XG4gICAgcmV0dXJuIG5ldyBQb2ludChzb3VyY2UueCwgc291cmNlLnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L0Nsb25lLmpzIiwiLyoqXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxuKi9cbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXG57XG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29weUZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENyb3NzID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCKVxue1xuICAgIHJldHVybiAoKHBvaW50QS54ICogcG9pbnRCLnkpIC0gKHBvaW50QS55ICogcG9pbnRCLngpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0Nyb3NzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpdmlkZSA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSlcbntcbiAgICBwb2ludC54IC89IHg7XG4gICAgcG9pbnQueSAvPSB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXZpZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0RpdmlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMzk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAocG9pbnQsIHRvQ29tcGFyZSlcbntcbiAgICByZXR1cm4gKHBvaW50LnggPT09IHRvQ29tcGFyZS54ICYmIHBvaW50LnkgPT09IHRvQ29tcGFyZS55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9FcXVhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAocG9pbnQpXG57XG4gICAgcmV0dXJuIHBvaW50LnNldFRvKE1hdGguZmxvb3IocG9pbnQueCksIE1hdGguZmxvb3IocG9pbnQueSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDM5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBHZXRDZW50cm9pZCA9IGZ1bmN0aW9uIChwb2ludHMsIG91dClcbntcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gbmV3IFBvaW50KCk7IH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRDZW50cm9pZCBwb2ludHMgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA8IDEpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldENlbnRyb2lkIHBvaW50cyBhcnJheSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPT09IDEpXG4gICAge1xuICAgICAgICBvdXQueCA9IHBvaW50c1swXS54O1xuICAgICAgICBvdXQueSA9IHBvaW50c1swXS55O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBvdXQueCArPSBwb2ludHNbaV0ueDtcbiAgICAgICAgICAgIG91dC55ICs9IHBvaW50c1tpXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LnggLz0gbGVuO1xuICAgICAgICBvdXQueSAvPSBsZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0Q2VudHJvaWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0dldENlbnRyb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9HZXRDZW50cm9pZC5qcyIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxudmFyIEludGVycG9sYXRlID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCB0LCBvdXQpXG57XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgeyB0ID0gMDsgfVxuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgb3V0LnggPSBwb2ludEEueCArICgocG9pbnRCLnggLSBwb2ludEEueCkgKiB0KTtcbiAgICBvdXQueSA9IHBvaW50QS55ICsgKChwb2ludEIueSAtIHBvaW50QS55KSAqIHQpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJwb2xhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L0ludGVycG9sYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxuKiBDb3BpZXMgdGhlIHgsIHkgYW5kIGRpYW1ldGVyIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgQ2lyY2xlLlxuKiBAbWV0aG9kIFBoYXNlci5DaXJjbGUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgQ2lyY2xlIG9iamVjdC5cbiovXG52YXIgSW52ZXJ0ID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCBwb2ludC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW52ZXJ0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9JbnZlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDQwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBOZWdhdGl2ZSA9IGZ1bmN0aW9uIChwb2ludCwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgcmV0dXJuIG91dC5zZXRUbygtcG9pbnQueCwgLXBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZWdhdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvTmVnYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDQwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L05lZ2F0aXZlLmpzIiwidmFyIE5vcm1hbGl6ZVJpZ2h0SGFuZCA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8ocG9pbnQueSAqIC0xLCBwb2ludC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsaXplUmlnaHRIYW5kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Ob3JtYWxpemVSaWdodEhhbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVycCA9IGZ1bmN0aW9uIChwb2ludClcbntcbiAgICByZXR1cm4gcG9pbnQuc2V0VG8oLXBvaW50LnksIHBvaW50LngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9QZXJwLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG52YXIgR2V0TWFnbml0dWRlU3EgPSByZXF1aXJlKCcuL0dldE1hZ25pdHVkZVNxJyk7XG5cbnZhciBQcm9qZWN0ID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IG5ldyBQb2ludCgpOyB9XG5cbiAgICB2YXIgYW10ID0gRG90KHBvaW50QSwgcG9pbnRCKSAvIEdldE1hZ25pdHVkZVNxKHBvaW50Qik7XG5cbiAgICBpZiAoYW10ICE9PSAwKVxuICAgIHtcbiAgICAgICAgb3V0LnggPSBhbXQgKiBwb2ludEIueDtcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9Qcm9qZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2ludC9Qcm9qZWN0LmpzIiwidmFyIERvdCA9IHJlcXVpcmUoJy4vRG90Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cbnZhciBQcm9qZWN0VW5pdCA9IGZ1bmN0aW9uIChwb2ludEEsIHBvaW50Qiwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSBuZXcgUG9pbnQoKTsgfVxuXG4gICAgdmFyIGFtdCA9IERvdChwb2ludEEsIHBvaW50Qik7XG5cbiAgICBpZiAoYW10ICE9PSAwKVxuICAgIHtcbiAgICAgICAgb3V0LnggPSBhbXQgKiBwb2ludEIueDtcbiAgICAgICAgb3V0LnkgPSBhbXQgKiBwb2ludEIueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0VW5pdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvUHJvamVjdFVuaXQuanNcbi8vIG1vZHVsZSBpZCA9IDQwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L1Byb2plY3RVbml0LmpzIiwidmFyIFJQZXJwID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHJldHVybiBwb2ludC5zZXRUbyhwb2ludC55LCAtcG9pbnQueCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJQZXJwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9SUGVycC5qc1xuLy8gbW9kdWxlIGlkID0gNDA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xudmFyIE11bHRpcGx5ID0gcmVxdWlyZSgnLi9NdWx0aXBseScpO1xuXG52YXIgU2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKHBvaW50LCBtYWduaXR1ZGUpXG57XG4gICAgTm9ybWFsaXplKHBvaW50KTtcblxuICAgIHJldHVybiBNdWx0aXBseShwb2ludCwgbWFnbml0dWRlLCBtYWduaXR1ZGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRNYWduaXR1ZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvaW50L1NldE1hZ25pdHVkZS5qc1xuLy8gbW9kdWxlIGlkID0gNDA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcG9pbnQvU2V0TWFnbml0dWRlLmpzIiwidmFyIFN1YnRyYWN0ID0gZnVuY3Rpb24gKHBvaW50LCB4LCB5KVxue1xuICAgIHBvaW50LnggLT0geDtcbiAgICBwb2ludC55IC09IHk7XG5cbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2ludC9TdWJ0cmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBQaGFzZXIuR2VvbS5Qb2ludFxuXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5cblBvaW50LkFkZCA9IHJlcXVpcmUoJy4vQWRkJyk7XG5Qb2ludC5DZWlsID0gcmVxdWlyZSgnLi9DZWlsJyk7XG5Qb2ludC5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcblBvaW50LkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xuUG9pbnQuQ3Jvc3MgPSByZXF1aXJlKCcuL0Nyb3NzJyk7XG5Qb2ludC5EaXZpZGUgPSByZXF1aXJlKCcuL0RpdmlkZScpO1xuUG9pbnQuRG90ID0gcmVxdWlyZSgnLi9Eb3QnKTtcblBvaW50LkVxdWFscyA9IHJlcXVpcmUoJy4vRXF1YWxzJyk7XG5Qb2ludC5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcblBvaW50LkdldENlbnRyb2lkID0gcmVxdWlyZSgnLi9HZXRDZW50cm9pZCcpO1xuUG9pbnQuR2V0TWFnbml0dWRlID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGUnKTtcblBvaW50LkdldE1hZ25pdHVkZVNxID0gcmVxdWlyZSgnLi9HZXRNYWduaXR1ZGVTcScpO1xuUG9pbnQuSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL0ludGVycG9sYXRlJyk7XG5Qb2ludC5JbnZlcnQgPSByZXF1aXJlKCcuL0ludmVydCcpO1xuUG9pbnQuTXVsdGlwbHkgPSByZXF1aXJlKCcuL011bHRpcGx5Jyk7XG5Qb2ludC5OZWdhdGl2ZSA9IHJlcXVpcmUoJy4vTmVnYXRpdmUnKTtcblBvaW50Lk5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vTm9ybWFsaXplJyk7XG5Qb2ludC5Ob3JtYWxpemVSaWdodEhhbmQgPSByZXF1aXJlKCcuL05vcm1hbGl6ZVJpZ2h0SGFuZCcpO1xuUG9pbnQuUGVycCA9IHJlcXVpcmUoJy4vUGVycCcpO1xuUG9pbnQuUHJvamVjdCA9IHJlcXVpcmUoJy4vUHJvamVjdCcpO1xuUG9pbnQuUHJvamVjdFVuaXQgPSByZXF1aXJlKCcuL1Byb2plY3RVbml0Jyk7XG5Qb2ludC5SUGVycCA9IHJlcXVpcmUoJy4vUlBlcnAnKTtcblBvaW50LlNldE1hZ25pdHVkZSA9IHJlcXVpcmUoJy4vU2V0TWFnbml0dWRlJyk7XG5Qb2ludC5TdWJ0cmFjdCA9IHJlcXVpcmUoJy4vU3VidHJhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcG9pbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvaW50L2luZGV4LmpzIiwidmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblxudmFyIENsb25lID0gZnVuY3Rpb24gKHBvbHlnb24pXG57XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvbHlnb24ucG9pbnRzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3BvbHlnb24vQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5cbi8qKlxuKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4qXG4qIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jY29udGFpbnNcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0byB0ZXN0LlxuKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRvIHRlc3QuXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLCBvdGhlcndpc2UgZmFsc2UuXG4qL1xudmFyIENvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocG9seWdvbiwgcG9pbnQpXG57XG4gICAgcmV0dXJuIENvbnRhaW5zKHBvbHlnb24sIHBvaW50LngsIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3BvbHlnb24vQ29udGFpbnNQb2ludC5qcyIsIi8vICAyLjEuMSAoTWFyIDE3LCAyMDE2KVxuXG4vKlxuSVNDIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE2LCBNYXBib3hcblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2VcbndpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2VcbmFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG5GSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTXG5PRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVJcblRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0ZcblRISVMgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcblxuLypcbnZlcnRpY2VzIGlzIGEgZmxhdCBhcnJheSBvZiB2ZXJ0aWNlIGNvb3JkaW5hdGVzIGxpa2UgW3gwLHkwLCB4MSx5MSwgeDIseTIsIC4uLl0uXG5ob2xlcyBpcyBhbiBhcnJheSBvZiBob2xlIGluZGljZXMgaWYgYW55IChlLmcuIFs1LCA4XSBmb3IgYSAxMi12ZXJ0aWNlIGlucHV0IHdvdWxkIG1lYW4gb25lIGhvbGUgd2l0aCB2ZXJ0aWNlcyA14oCTNyBhbmQgYW5vdGhlciB3aXRoIDjigJMxMSkuXG5kaW1lbnNpb25zIGlzIHRoZSBudW1iZXIgb2YgY29vcmRpbmF0ZXMgcGVyIHZlcnRpY2UgaW4gdGhlIGlucHV0IGFycmF5ICgyIGJ5IGRlZmF1bHQpLlxuRWFjaCBncm91cCBvZiB0aHJlZSB2ZXJ0aWNlIGluZGljZXMgaW4gdGhlIHJlc3VsdGluZyBhcnJheSBmb3JtcyBhIHRyaWFuZ2xlLlxuICovXG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIHNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHRaO1xuICAgIH1cblxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHAgPSBlYXIucHJldlo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG0ubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRpY2Ugbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gbnVsbDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0VhcmN1dC5qc1xuLy8gbW9kdWxlIGlkID0gNDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIEdldEFBQkIgPSBmdW5jdGlvbiAocG9seWdvbilcbntcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtbWluWDtcbiAgICB2YXIgbWF4WSA9IC1taW5ZO1xuICAgIHZhciBwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHAgPSBwb2x5Z29uLnBvaW50c1tpXTtcblxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcC54KTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHAueSk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcC55KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBtaW5YLFxuICAgICAgICB5OiBtaW5ZLFxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRBQUJCO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldEFBQkIuanNcbi8vIG1vZHVsZSBpZCA9IDQxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEV4cG9ydCB0aGUgcG9pbnRzIGFzIGFuIGFycmF5IG9mIGZsYXQgbnVtYmVycywgZm9sbG93aW5nIHRoZSBzZXF1ZW5jZSBbIHgseSwgeCx5LCB4LHkgXVxuICpcbiAqIEBtZXRob2QgUGhhc2VyLlBvbHlnb24jdG9OdW1iZXJBcnJheVxuICogQHBhcmFtIHthcnJheX0gW291dHB1dF0gLSBUaGUgYXJyYXkgdG8gYXBwZW5kIHRoZSBwb2ludHMgdG8uIElmIG5vdCBzcGVjaWZpZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbnZhciBHZXROdW1iZXJBcnJheSA9IGZ1bmN0aW9uIChwb2x5Z29uLCBvdXRwdXQpXG57XG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7IG91dHB1dCA9IFtdOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ucG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocG9seWdvbi5wb2ludHNbaV0ueCk7XG4gICAgICAgIG91dHB1dC5wdXNoKHBvbHlnb24ucG9pbnRzW2ldLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE51bWJlckFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL0dldE51bWJlckFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HZW9tLlBvbHlnb25cblxudmFyIFBvbHlnb24gPSByZXF1aXJlKCcuL1BvbHlnb24nKTtcblxuUG9seWdvbi5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcblBvbHlnb24uQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5Qb2x5Z29uLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcblBvbHlnb24uR2V0QUFCQiA9IHJlcXVpcmUoJy4vR2V0QUFCQicpO1xuUG9seWdvbi5HZXROdW1iZXJBcnJheSA9IHJlcXVpcmUoJy4vR2V0TnVtYmVyQXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9wb2x5Z29uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9wb2x5Z29uL2luZGV4LmpzIiwidmFyIEFyZWEgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZXR1cm4gcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gNDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDZWlsID0gZnVuY3Rpb24gKHJlY3QpXG57XG4gICAgcmVjdC54ID0gTWF0aC5jZWlsKHJlY3QueCk7XG4gICAgcmVjdC55ID0gTWF0aC5jZWlsKHJlY3QueSk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDQxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbEFsbCA9IGZ1bmN0aW9uIChyZWN0KVxue1xuICAgIHJlY3QueCA9IE1hdGguY2VpbChyZWN0LngpO1xuICAgIHJlY3QueSA9IE1hdGguY2VpbChyZWN0LnkpO1xuICAgIHJlY3Qud2lkdGggPSBNYXRoLmNlaWwocmVjdC53aWR0aCk7XG4gICAgcmVjdC5oZWlnaHQgPSBNYXRoLmNlaWwocmVjdC5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWxBbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9DZWlsQWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENlbnRlcnMgdGhpcyBSZWN0YW5nbGUgc28gdGhhdCB0aGUgY2VudGVyIGNvb3JkaW5hdGVzIG1hdGNoIHRoZSBnaXZlbiB4IGFuZCB5IHZhbHVlcy5cbipcbiogQG1ldGhvZCBQaGFzZXIuUmVjdGFuZ2xlI2NlbnRlck9uXG4qIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSB0byBwbGFjZSB0aGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgYXQuXG4qIEByZXR1cm4ge1BoYXNlci5SZWN0YW5nbGV9IFRoaXMgUmVjdGFuZ2xlIG9iamVjdFxuKi9cbnZhciBDZW50ZXJPbiA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxue1xuICAgIHJlY3QueCA9IHggLSAocmVjdC53aWR0aCAvIDIpO1xuICAgIHJlY3QueSA9IHkgLSAocmVjdC5oZWlnaHQgLyAyKTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZW50ZXJPbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyk7XG5cbnZhciBDbG9uZSA9IGZ1bmN0aW9uIChzb3VyY2UpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5cbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHJlY3QsIHBvaW50KVxue1xuICAgIHJldHVybiBDb250YWlucyhyZWN0LCBwb2ludC54LCBwb2ludC55KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvbnRhaW5zUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9Db250YWluc1BvaW50LmpzIiwiLy8gIENoZWNrcyBpZiByZWN0QiBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIHJlY3RBXG5cbnZhciBDb250YWluc1JlY3QgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCKVxue1xuICAgIC8vICBWb2x1bWUgY2hlY2sgKGlmIHJlY3RCIHZvbHVtZSA+IHJlY3RBIHRoZW4gcmVjdEEgY2Fubm90IGNvbnRhaW4gaXQpXG4gICAgaWYgKChyZWN0Qi53aWR0aCAqIHJlY3RCLmhlaWdodCkgPiAocmVjdEEud2lkdGggKiByZWN0QS5oZWlnaHQpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIChyZWN0Qi54ID4gcmVjdEEueCAmJiByZWN0Qi54IDwgcmVjdEEucmlnaHQpICYmXG4gICAgICAgIChyZWN0Qi5yaWdodCA+IHJlY3RBLnggJiYgcmVjdEIucmlnaHQgPCByZWN0QS5yaWdodCkgJiZcbiAgICAgICAgKHJlY3RCLnkgPiByZWN0QS55ICYmIHJlY3RCLnkgPCByZWN0QS5ib3R0b20pICYmIFxuICAgICAgICAocmVjdEIuYm90dG9tID4gcmVjdEEueSAmJiByZWN0Qi5ib3R0b20gPCByZWN0QS5ib3R0b20pXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbnNSZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvQ29udGFpbnNSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENvcGllcyB0aGUgeCwgeSBhbmQgZGlhbWV0ZXIgcHJvcGVydGllcyBmcm9tIGFueSBnaXZlbiBvYmplY3QgdG8gdGhpcyBDaXJjbGUuXG4qIEBtZXRob2QgUGhhc2VyLkNpcmNsZSNjb3B5RnJvbVxuKiBAcGFyYW0ge2FueX0gc291cmNlIC0gVGhlIG9iamVjdCB0byBjb3B5IGZyb20uXG4qIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBDaXJjbGUgb2JqZWN0LlxuKi9cbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXG57XG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3B5RnJvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0NvcHlGcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEVxdWFscyA9IGZ1bmN0aW9uIChyZWN0LCB0b0NvbXBhcmUpXG57XG4gICAgcmV0dXJuIChcbiAgICAgICAgcmVjdC54ID09PSB0b0NvbXBhcmUueCAmJlxuICAgICAgICByZWN0LnkgPT09IHRvQ29tcGFyZS55ICYmXG4gICAgICAgIHJlY3Qud2lkdGggPT09IHRvQ29tcGFyZS53aWR0aCAmJlxuICAgICAgICByZWN0LmhlaWdodCA9PT0gdG9Db21wYXJlLmhlaWdodFxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0VxdWFscy5qc1xuLy8gbW9kdWxlIGlkID0gNDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcblxuLy8gIEZpdHMgdGhlIHRhcmdldCByZWN0YW5nbGUgaW50byB0aGUgc291cmNlIHJlY3RhbmdsZS5cbi8vICBQcmVzZXJ2ZXMgYXNwZWN0IHJhdGlvLlxuLy8gIFNjYWxlcyBhbmQgY2VudGVycyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSB0byB0aGUgc291cmNlIHJlY3RhbmdsZVxuXG52YXIgRml0SW5zaWRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxue1xuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XG5cbiAgICBpZiAocmF0aW8gPCBHZXRBc3BlY3RSYXRpbyhzb3VyY2UpKVxuICAgIHtcbiAgICAgICAgLy8gIFRhbGxlciB0aGFuIFdpZGVcbiAgICAgICAgdGFyZ2V0LnNldFNpemUoc291cmNlLmhlaWdodCAqIHJhdGlvLCBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS53aWR0aCAqIHJhdGlvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0LnNldFBvc2l0aW9uKFxuICAgICAgICAoc291cmNlLnJpZ2h0IC8gMikgLSAodGFyZ2V0LndpZHRoIC8gMiksXG4gICAgICAgIChzb3VyY2UuYm90dG9tIC8gMikgLSAodGFyZ2V0LmhlaWdodCAvIDIpXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRml0SW5zaWRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS9yZWN0YW5nbGUvRml0SW5zaWRlLmpzIiwidmFyIEdldEFzcGVjdFJhdGlvID0gcmVxdWlyZSgnLi9HZXRBc3BlY3RSYXRpbycpO1xuXG4vLyAgRml0cyB0aGUgdGFyZ2V0IHJlY3RhbmdsZSBhcm91bmQgdGhlIHNvdXJjZSByZWN0YW5nbGUuXG4vLyAgUHJlc2VydmVzIGFzcGVjdCByYXRpb24uXG4vLyAgU2NhbGVzIGFuZCBjZW50ZXJzIHRoZSB0YXJnZXQgcmVjdGFuZ2xlIHRvIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXG5cbnZhciBGaXRPdXRzaWRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKVxue1xuICAgIHZhciByYXRpbyA9IEdldEFzcGVjdFJhdGlvKHRhcmdldCk7XG5cbiAgICBpZiAocmF0aW8gPiBHZXRBc3BlY3RSYXRpbyhzb3VyY2UpKVxuICAgIHtcbiAgICAgICAgLy8gIFdpZGVyIHRoYW4gVGFsbFxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2UuaGVpZ2h0ICogcmF0aW8sIHNvdXJjZS5oZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyAgVGFsbGVyIHRoYW4gV2lkZVxuICAgICAgICB0YXJnZXQuc2V0U2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS53aWR0aCAqIHJhdGlvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0LnNldFBvc2l0aW9uKFxuICAgICAgICAoc291cmNlLnJpZ2h0IC8gMikgLSB0YXJnZXQud2lkdGggLyAyLFxuICAgICAgICAoc291cmNlLmJvdHRvbSAvIDIpIC0gdGFyZ2V0LmhlaWdodCAvIDJcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaXRPdXRzaWRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRml0T3V0c2lkZS5qc1xuLy8gbW9kdWxlIGlkID0gNDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL0ZpdE91dHNpZGUuanMiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XG4gICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkpO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvRmxvb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3JBbGwgPSBmdW5jdGlvbiAocmVjdClcbntcbiAgICByZWN0LnggPSBNYXRoLmZsb29yKHJlY3QueCk7XG4gICAgcmVjdC55ID0gTWF0aC5mbG9vcihyZWN0LnkpO1xuICAgIHJlY3Qud2lkdGggPSBNYXRoLmZsb29yKHJlY3Qud2lkdGgpO1xuICAgIHJlY3QuaGVpZ2h0ID0gTWF0aC5mbG9vcihyZWN0LmhlaWdodCk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvb3JBbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9GbG9vckFsbC5qc1xuLy8gbW9kdWxlIGlkID0gNDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGUgY2VudGVyIG9mIHRoZSBSZWN0YW5nbGUgb2JqZWN0LCBleHByZXNzZWQgYXMgYSBQb2ludCBvYmplY3QgXG5cbnZhciBHZXRDZW50ZXIgPSBmdW5jdGlvbiAocmVjdCwgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxuXG4gICAgb3V0LnggPSByZWN0LnJpZ2h0IC8gMjtcbiAgICBvdXQueSA9IHJlY3QuYm90dG9tIC8gMjtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldENlbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0dldENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBUaGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCwgZXhwcmVzc2VkIGFzIGEgUG9pbnQgb2JqZWN0IFxuLy8gIHdpdGggdGhlIHZhbHVlcyBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzLlxuXG52YXIgR2V0U2l6ZSA9IGZ1bmN0aW9uIChyZWN0LCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XG5cbiAgICBvdXQueCA9IHJlY3Qud2lkdGg7XG4gICAgb3V0LnkgPSByZWN0LmhlaWdodDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFNpemU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9HZXRTaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIEluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXG4vLyAgVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBzdGF5cyB0aGUgc2FtZSwgYW5kIGl0cyBzaXplIGluY3JlYXNlcyBcbi8vICB0byB0aGUgbGVmdCBhbmQgcmlnaHQgYnkgdGhlIHggdmFsdWUsIGFuZCB0byB0aGUgdG9wIGFuZCB0aGUgYm90dG9tIGJ5IHRoZSB5IHZhbHVlLlxuXG52YXIgSW5mbGF0ZSA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxue1xuICAgIC8vICBHZXQgdGhlIGN1cnJlbnQgY2VudGVyXG4gICAgdmFyIGN4ID0gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKTtcbiAgICB2YXIgY3kgPSByZWN0LnkgKyAocmVjdC5oZWlnaHQgLyAyKTtcblxuICAgIC8vICBJbmZsYXRlXG4gICAgcmVjdC53aWR0aCA9IDIgKiB4O1xuICAgIHJlY3QuaGVpZ2h0ID0gMiAqIHk7XG5cbiAgICByZWN0LnggPSB4IC0gKHJlY3Qud2lkdGggLyAyKTtcbiAgICByZWN0LnkgPSB5IC0gKHJlY3QuaGVpZ2h0IC8gMik7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mbGF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL0luZmxhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgTWVyZ2VzIHRoZSB0YXJnZXQgUmVjdGFuZ2xlIHdpdGggYSBsaXN0IG9mIHBvaW50cy5cbi8vICBUaGUgcG9pbnRzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXMuXG5cbnZhciBNZXJnZVBvaW50cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHBvaW50cylcbntcbiAgICB2YXIgbWluWCA9IHRhcmdldC54O1xuICAgIHZhciBtYXhYID0gdGFyZ2V0LnJpZ2h0O1xuICAgIHZhciBtaW5ZID0gdGFyZ2V0Lnk7XG4gICAgdmFyIG1heFkgPSB0YXJnZXQuYm90dG9tO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcG9pbnRzW2ldLngpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcG9pbnRzW2ldLngpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcG9pbnRzW2ldLnkpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcG9pbnRzW2ldLnkpO1xuICAgIH1cblxuICAgIHRhcmdldC54ID0gbWluWDtcbiAgICB0YXJnZXQueSA9IG1pblk7XG4gICAgdGFyZ2V0LndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VQb2ludHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9NZXJnZVBvaW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBNZXJnZXMgc291cmNlIHJlY3RhbmdsZSBpbnRvIHRhcmdldCByZWN0YW5nbGUgYW5kIHJldHVybnMgdGFyZ2V0XG4vLyAgTmVpdGhlciByZWN0IHNob3VsZCBoYXZlIG5lZ2F0aXZlIHdpZHRocyBvciBoZWlnaHRzXG5cbnZhciBNZXJnZVJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpXG57XG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih0YXJnZXQueCwgc291cmNlLngpO1xuICAgIHZhciBtYXhYID0gTWF0aC5tYXgodGFyZ2V0LnJpZ2h0LCBzb3VyY2UucmlnaHQpO1xuXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih0YXJnZXQueSwgc291cmNlLnkpO1xuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodGFyZ2V0LmJvdHRvbSwgc291cmNlLmJvdHRvbSk7XG5cbiAgICB0YXJnZXQueSA9IG1pblk7XG4gICAgdGFyZ2V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVyZ2VSZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgTWVyZ2VYWSA9IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpXG57XG4gICAgdmFyIG1pblggPSBNYXRoLm1pbih0YXJnZXQueCwgeCk7XG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh0YXJnZXQucmlnaHQsIHgpO1xuXG4gICAgdGFyZ2V0LnggPSBtaW5YO1xuICAgIHRhcmdldC53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbih0YXJnZXQueSwgeSk7XG4gICAgdmFyIG1heFkgPSBNYXRoLm1heCh0YXJnZXQuYm90dG9tLCB5KTtcblxuICAgIHRhcmdldC55ID0gbWluWTtcbiAgICB0YXJnZXQuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXJnZVhZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvTWVyZ2VYWS5qc1xuLy8gbW9kdWxlIGlkID0gNDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPZmZzZXQgPSBmdW5jdGlvbiAocmVjdCwgeCwgeSlcbntcbiAgICByZWN0LnggKz0geDtcbiAgICByZWN0LnkgKz0geTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPZmZzZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiAocmVjdCwgcG9pbnQpXG57XG4gICAgcmVjdC54ICs9IHBvaW50Lng7XG4gICAgcmVjdC55ICs9IHBvaW50Lnk7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2Zmc2V0UG9pbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9PZmZzZXRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPdmVybGFwcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIpXG57XG4gICAgcmV0dXJuIChcbiAgICAgICAgcmVjdEEueCA8IHJlY3RCLnJpZ2h0ICYmIFxuICAgICAgICByZWN0QS5yaWdodCA+IHJlY3RCLnggJiYgXG4gICAgICAgIHJlY3RBLnkgPCByZWN0Qi5ib3R0b20gJiYgXG4gICAgICAgIHJlY3RBLmJvdHRvbSA+IHJlY3RCLnlcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGFwcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vcmVjdGFuZ2xlL092ZXJsYXBzLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1BVEhfQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9tYXRoL2NvbnN0Jyk7XG5cbi8vICBkZWcgPSBkZWdyZWVzICgwLTM2MClcblxudmFyIFBlcmltZXRlclBvaW50ID0gZnVuY3Rpb24gKHJlY3QsIGRlZywgb3V0KVxue1xuICAgIGlmIChvdXQgPT09IHVuZGVmaW5lZCkgeyBvdXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxuXG4gICAgdmFyIHRoZXRhID0gZGVnICogTUFUSF9DT05TVC5ERUdfVE9fUkFEO1xuXG4gICAgd2hpbGUgKHRoZXRhIDwgLU1hdGguUEkpXG4gICAge1xuICAgICAgICB0aGV0YSArPSBNQVRIX0NPTlNULlBJMjtcbiAgICB9XG5cbiAgICB3aGlsZSAodGhldGEgPiBNYXRoLlBJKVxuICAgIHtcbiAgICAgICAgdGhldGEgLT0gTUFUSF9DT05TVC5QSTI7XG4gICAgfVxuXG4gICAgdmFyIHJlY3RBdGFuID0gTWF0aC5hdGFuMihyZWN0LmhlaWdodCwgcmVjdC53aWR0aCk7XG4gICAgdmFyIHRhblRoZXRhID0gTWF0aC50YW4odGhldGEpO1xuICAgIHZhciB0aGV0YUJvdW5kcyA9IE1hdGguUEkgLSByZWN0QXRhbjtcbiAgICB2YXIgcmVnaW9uO1xuICAgIHZhciB4RmFjdG9yID0gMTtcbiAgICB2YXIgeUZhY3RvciA9IDE7XG5cbiAgICBpZiAodGhldGEgPiAtcmVjdEF0YW4gJiYgdGhldGEgPD0gcmVjdEF0YW4pXG4gICAge1xuICAgICAgICByZWdpb24gPSAxO1xuICAgICAgICB5RmFjdG9yID0gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoZXRhID4gcmVjdEF0YW4gJiYgdGhldGEgPD0gdGhldGFCb3VuZHMpXG4gICAge1xuICAgICAgICByZWdpb24gPSAyO1xuICAgICAgICB5RmFjdG9yID0gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoZXRhID4gdGhldGFCb3VuZHMgfHwgdGhldGEgPD0gLXRoZXRhQm91bmRzKVxuICAgIHtcbiAgICAgICAgcmVnaW9uID0gMztcbiAgICAgICAgeEZhY3RvciA9IC0xO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZWdpb24gPSA0O1xuICAgICAgICB4RmFjdG9yID0gLTE7XG4gICAgfVxuXG4gICAgb3V0LnggPSByZWN0LnggKyAocmVjdC53aWR0aCAvIDIpO1xuICAgIG91dC55ID0gcmVjdC55ICsgKHJlY3QuaGVpZ2h0IC8gMik7XG5cbiAgICBpZiAocmVnaW9uID09PSAxIHx8IHJlZ2lvbiA9PT0gMylcbiAgICB7XG4gICAgICAgIG91dC54ICs9IHhGYWN0b3IgKiAocmVjdC53aWR0aCAvIDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIlowXCJcbiAgICAgICAgb3V0LnkgKz0geUZhY3RvciAqIChyZWN0LndpZHRoIC8gMikgKiB0YW5UaGV0YTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgb3V0LnggKz0geEZhY3RvciAqIChyZWN0LmhlaWdodCAvICgyICogdGFuVGhldGEpKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIloxXCJcbiAgICAgICAgb3V0LnkgKz0geUZhY3RvciAqIChyZWN0LmhlaWdodCAvIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmltZXRlclBvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvUGVyaW1ldGVyUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3JlY3RhbmdsZS9QZXJpbWV0ZXJQb2ludC5qcyIsIi8qKlxuKiBTY2FsZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhpcyBSZWN0YW5nbGUgYnkgdGhlIGdpdmVuIGFtb3VudHMuXG4qIFxuKiBAbWV0aG9kIFBoYXNlci5SZWN0YW5nbGUjc2NhbGVcbiogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIHRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlIGJ5LiBBIHZhbHVlIG9mIDAuNSB3b3VsZCByZWR1Y2UgYnkgaGFsZiwgYSB2YWx1ZSBvZiAyIHdvdWxkIGRvdWJsZSB0aGUgd2lkdGgsIGV0Yy5cbiogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlIGJ5LiBBIHZhbHVlIG9mIDAuNSB3b3VsZCByZWR1Y2UgYnkgaGFsZiwgYSB2YWx1ZSBvZiAyIHdvdWxkIGRvdWJsZSB0aGUgaGVpZ2h0LCBldGMuXG4qIEByZXR1cm4ge1BoYXNlci5SZWN0YW5nbGV9IFRoaXMgUmVjdGFuZ2xlIG9iamVjdFxuKi9cbnZhciBTY2FsZSA9IGZ1bmN0aW9uIChyZWN0LCB4LCB5KVxue1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgeSA9IHg7IH1cblxuICAgIHJlY3Qud2lkdGggKj0geDtcbiAgICByZWN0LmhlaWdodCAqPSB5O1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS9yZWN0YW5nbGUvU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxudmFyIFVuaW9uID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3V0cHV0KVxue1xuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgeyBvdXRwdXQgPSBSZWN0YW5nbGUoKTsgfVxuXG4gICAgdmFyIHggPSBNYXRoLm1pbihyZWN0QS54LCByZWN0Qi54KTtcbiAgICB2YXIgeSA9IE1hdGgubWluKHJlY3RBLnksIHJlY3RCLnkpO1xuXG4gICAgcmV0dXJuIG91dHB1dC5zZXQoXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIE1hdGgubWF4KHJlY3RBLnJpZ2h0LCByZWN0Qi5yaWdodCkgLSB4LFxuICAgICAgICBNYXRoLm1heChyZWN0QS5ib3R0b20sIHJlY3RCLmJvdHRvbSkgLSB5XG4gICAgKTtcbiAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9Vbmlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL1VuaW9uLmpzIiwiLy8gIFBoYXNlci5HZW9tLlJlY3RhbmdsZVxuXG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKTtcblxuUmVjdGFuZ2xlLkFyZWEgPSByZXF1aXJlKCcuL0FyZWEnKTtcblJlY3RhbmdsZS5DZWlsID0gcmVxdWlyZSgnLi9DZWlsJyk7XG5SZWN0YW5nbGUuQ2VpbEFsbCA9IHJlcXVpcmUoJy4vQ2VpbEFsbCcpO1xuUmVjdGFuZ2xlLkNlbnRlck9uID0gcmVxdWlyZSgnLi9DZW50ZXJPbicpO1xuUmVjdGFuZ2xlLkNsb25lID0gcmVxdWlyZSgnLi9DbG9uZScpO1xuUmVjdGFuZ2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xuUmVjdGFuZ2xlLkNvbnRhaW5zUG9pbnQgPSByZXF1aXJlKCcuL0NvbnRhaW5zUG9pbnQnKTtcblJlY3RhbmdsZS5Db250YWluc1JlY3QgPSByZXF1aXJlKCcuL0NvbnRhaW5zUmVjdCcpO1xuUmVjdGFuZ2xlLkNvcHlGcm9tID0gcmVxdWlyZSgnLi9Db3B5RnJvbScpO1xuUmVjdGFuZ2xlLkRlY29tcG9zZSA9IHJlcXVpcmUoJy4vRGVjb21wb3NlJyk7XG5SZWN0YW5nbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcblJlY3RhbmdsZS5GaXRJbnNpZGUgPSByZXF1aXJlKCcuL0ZpdEluc2lkZScpO1xuUmVjdGFuZ2xlLkZpdE91dHNpZGUgPSByZXF1aXJlKCcuL0ZpdE91dHNpZGUnKTtcblJlY3RhbmdsZS5GbG9vciA9IHJlcXVpcmUoJy4vRmxvb3InKTtcblJlY3RhbmdsZS5GbG9vckFsbCA9IHJlcXVpcmUoJy4vRmxvb3JBbGwnKTtcblJlY3RhbmdsZS5HZXRBc3BlY3RSYXRpbyA9IHJlcXVpcmUoJy4vR2V0QXNwZWN0UmF0aW8nKTtcblJlY3RhbmdsZS5HZXRDZW50ZXIgPSByZXF1aXJlKCcuL0dldENlbnRlcicpO1xuUmVjdGFuZ2xlLkdldFNpemUgPSByZXF1aXJlKCcuL0dldFNpemUnKTtcblJlY3RhbmdsZS5JbmZsYXRlID0gcmVxdWlyZSgnLi9JbmZsYXRlJyk7XG5SZWN0YW5nbGUuTWFyY2hpbmdBbnRzID0gcmVxdWlyZSgnLi9NYXJjaGluZ0FudHMnKTtcblJlY3RhbmdsZS5NZXJnZVBvaW50cyA9IHJlcXVpcmUoJy4vTWVyZ2VQb2ludHMnKTtcblJlY3RhbmdsZS5NZXJnZVJlY3QgPSByZXF1aXJlKCcuL01lcmdlUmVjdCcpO1xuUmVjdGFuZ2xlLk1lcmdlWFkgPSByZXF1aXJlKCcuL01lcmdlWFknKTtcblJlY3RhbmdsZS5PZmZzZXQgPSByZXF1aXJlKCcuL09mZnNldCcpO1xuUmVjdGFuZ2xlLk9mZnNldFBvaW50ID0gcmVxdWlyZSgnLi9PZmZzZXRQb2ludCcpO1xuUmVjdGFuZ2xlLk92ZXJsYXBzID0gcmVxdWlyZSgnLi9PdmVybGFwcycpO1xuUmVjdGFuZ2xlLlBlcmltZXRlciA9IHJlcXVpcmUoJy4vUGVyaW1ldGVyJyk7XG5SZWN0YW5nbGUuUGVyaW1ldGVyUG9pbnQgPSByZXF1aXJlKCcuL1BlcmltZXRlclBvaW50Jyk7XG5SZWN0YW5nbGUuUmFuZG9tID0gcmVxdWlyZSgnLi9SYW5kb20nKTtcblJlY3RhbmdsZS5TY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcblJlY3RhbmdsZS5VbmlvbiA9IHJlcXVpcmUoJy4vVW5pb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3JlY3RhbmdsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vcmVjdGFuZ2xlL2luZGV4LmpzIiwiLy8gVGhlIDJEIGFyZWEgb2YgYSB0cmlhbmdsZS4gVGhlIGFyZWEgdmFsdWUgaXMgYWx3YXlzIG5vbi1uZWdhdGl2ZS5cblxudmFyIEFyZWEgPSBmdW5jdGlvbiAodHJpYW5nbGUpXG57XG4gICAgdmFyIHgxID0gdHJpYW5nbGUueDE7XG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XG5cbiAgICB2YXIgeDIgPSB0cmlhbmdsZS54MjtcbiAgICB2YXIgeTIgPSB0cmlhbmdsZS55MjtcblxuICAgIHZhciB4MyA9IHRyaWFuZ2xlLngzO1xuICAgIHZhciB5MyA9IHRyaWFuZ2xlLnkzO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKCgoeDMgLSB4MSkgKiAoeTIgLSB5MSkgLSAoeDIgLSB4MSkgKiAoeTMgLSB5MSkpIC8gMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0FyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDQ0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVHJpYW5nbGUgPSByZXF1aXJlKCcuL1RyaWFuZ2xlJyk7XG5cbi8vIEJ1aWxkcyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZS5cbi8vIEluIHRoZSBlcXVpbGF0ZXJhbCB0cmlhbmdsZSwgYWxsIHRoZSBzaWRlcyBhcmUgdGhlIHNhbWUgbGVuZ3RoIChjb25ncnVlbnQpXG4vLyBhbmQgYWxsIHRoZSBhbmdsZXMgYXJlIHRoZSBzYW1lIHNpemUgKGNvbmdydWVudCkuXG5cbi8vICBUaGUgeC95IHNwZWNpZmllcyB0aGUgdG9wLW1pZGRsZSBvZiB0aGUgdHJpYW5nbGUgKHgxL3kxKSBhbmQgbGVuZ3RoXG4vLyAgaXMgdGhlIGxlbmd0aCBvZiBlYWNoIHNpZGVcblxudmFyIEJ1aWxkRXF1aWxhdGVyYWwgPSBmdW5jdGlvbiAoeCwgeSwgbGVuZ3RoKVxue1xuICAgIHZhciBoZWlnaHQgPSBsZW5ndGggKiAoTWF0aC5zcXJ0KDMpIC8gMik7XG5cbiAgICB2YXIgeDEgPSB4O1xuICAgIHZhciB5MSA9IHk7XG5cbiAgICB2YXIgeDIgPSB4ICsgKGxlbmd0aCAvIDIpO1xuICAgIHZhciB5MiA9IHkgKyBoZWlnaHQ7XG5cbiAgICB2YXIgeDMgPSB4IC0gKGxlbmd0aCAvIDIpO1xuICAgIHZhciB5MyA9IHkgKyBoZWlnaHQ7XG5cbiAgICByZXR1cm4gbmV3IFRyaWFuZ2xlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZEVxdWlsYXRlcmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9CdWlsZEVxdWlsYXRlcmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS90cmlhbmdsZS9CdWlsZEVxdWlsYXRlcmFsLmpzIiwidmFyIEVhckN1dCA9IHJlcXVpcmUoJy4uL3BvbHlnb24vRWFyY3V0Jyk7XG52YXIgVHJpYW5nbGUgPSByZXF1aXJlKCcuL1RyaWFuZ2xlJyk7XG5cbnZhciBCdWlsZEZyb21Qb2x5Z29uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVzLCBzY2FsZVgsIHNjYWxlWSwgb3V0KVxue1xuICAgIGlmIChob2xlcyA9PT0gdW5kZWZpbmVkKSB7IGhvbGVzID0gbnVsbDsgfVxuICAgIGlmIChzY2FsZVggPT09IHVuZGVmaW5lZCkgeyBzY2FsZVggPSAxOyB9XG4gICAgaWYgKHNjYWxlWSA9PT0gdW5kZWZpbmVkKSB7IHNjYWxlWSA9IDE7IH1cbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHsgb3V0ID0gW107IH1cblxuICAgIHZhciB0cmlzID0gRWFyQ3V0KGRhdGEsIGhvbGVzKTtcblxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBjO1xuXG4gICAgdmFyIHgxO1xuICAgIHZhciB5MTtcblxuICAgIHZhciB4MjtcbiAgICB2YXIgeTI7XG5cbiAgICB2YXIgeDM7XG4gICAgdmFyIHkzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlzLmxlbmd0aDsgaSArPSAzKVxuICAgIHtcbiAgICAgICAgYSA9IHRyaXNbaV07XG4gICAgICAgIGIgPSB0cmlzW2kgKyAxXTtcbiAgICAgICAgYyA9IHRyaXNbaSArIDJdO1xuXG4gICAgICAgIHgxID0gZGF0YVthICogMl0gKiBzY2FsZVg7XG4gICAgICAgIHkxID0gZGF0YVsoYSAqIDIpICsgMV0gKiBzY2FsZVk7XG5cbiAgICAgICAgeDIgPSBkYXRhW2IgKiAyXSAqIHNjYWxlWDtcbiAgICAgICAgeTIgPSBkYXRhWyhiICogMikgKyAxXSAqIHNjYWxlWTtcblxuICAgICAgICB4MyA9IGRhdGFbYyAqIDJdICogc2NhbGVYO1xuICAgICAgICB5MyA9IGRhdGFbKGMgKiAyKSArIDFdICogc2NhbGVZO1xuXG4gICAgICAgIG91dC5wdXNoKG5ldyBUcmlhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVpbGRGcm9tUG9seWdvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vdHJpYW5nbGUvQnVpbGRGcm9tUG9seWdvbi5qcyIsInZhciBUcmlhbmdsZSA9IHJlcXVpcmUoJy4vVHJpYW5nbGUnKTtcblxuLy8gIEJ1aWxkcyBhIHJpZ2h0IHRyaWFuZ2xlLCB3aXRoIG9uZSA5MCBkZWdyZWUgYW5nbGUgYW5kIHR3byBhY3V0ZSBhbmdsZXNcbi8vICBUaGUgeC95IGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSA5MCBkZWdyZWUgYW5nbGUgKGFuZCB3aWxsIG1hcCB0byB4MS95MSBpbiB0aGUgcmVzdWx0aW5nIFRyaWFuZ2xlKVxuLy8gIHcvaCBjYW4gYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYW5kIHJlcHJlc2VudCB0aGUgbGVuZ3RoIG9mIGVhY2ggc2lkZVxuXG52YXIgQnVpbGRSaWdodCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyAgaGVpZ2h0ID0gd2lkdGg7IH1cblxuICAgIC8vICA5MCBkZWdyZWUgYW5nbGVcbiAgICB2YXIgeDEgPSB4O1xuICAgIHZhciB5MSA9IHk7XG5cbiAgICB2YXIgeDIgPSB4O1xuICAgIHZhciB5MiA9IHkgLSBoZWlnaHQ7XG5cbiAgICB2YXIgeDMgPSB4ICsgd2lkdGg7XG4gICAgdmFyIHkzID0geTtcblxuICAgIHJldHVybiBuZXcgVHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkUmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0J1aWxkUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3RyaWFuZ2xlL0J1aWxkUmlnaHQuanMiLCJ2YXIgQ2VudHJvaWQgPSByZXF1aXJlKCcuL0NlbnRyb2lkJyk7XG52YXIgT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcblxudmFyIENlbnRlck9uID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCB4LCB5LCBjZW50ZXJGdW5jKVxue1xuICAgIGlmIChjZW50ZXJGdW5jID09PSB1bmRlZmluZWQpIHsgY2VudGVyRnVuYyA9IENlbnRyb2lkOyB9XG5cbiAgICAvLyAgR2V0IHRoZSBjZW50ZXIgb2YgdGhlIHRyaWFuZ2xlXG4gICAgdmFyIGNlbnRlciA9IGNlbnRlckZ1bmModHJpYW5nbGUpO1xuXG4gICAgLy8gIERpZmZlcmVuY2VcbiAgICB2YXIgZGlmZlggPSB4IC0gY2VudGVyLng7XG4gICAgdmFyIGRpZmZZID0geSAtIGNlbnRlci55O1xuXG4gICAgcmV0dXJuIE9mZnNldCh0cmlhbmdsZSwgZGlmZlgsIGRpZmZZKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VudGVyT247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0NlbnRlck9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS90cmlhbmdsZS9DZW50ZXJPbi5qcyIsIi8vICBBZGFwdGVkIGZyb20gaHR0cDovL2Jqb3JuaGFycnRlbGwuZ2l0aHViLmlvL2pzdHMvZG9jL2FwaS9qc3RzX2dlb21fVHJpYW5nbGUuanMuaHRtbFxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDJ4MiBtYXRyaXguIFVzZXMgc3RhbmRhcmQgZG91YmxlLXByZWNpc2lvblxuICogYXJpdGhtZXRpYywgc28gaXMgc3VzY2VwdGlibGUgdG8gcm91bmQtb2ZmIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfVxuICogICAgICAgICAgbTAwIHRoZSBbMCwwXSBlbnRyeSBvZiB0aGUgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJ9XG4gKiAgICAgICAgICBtMDEgdGhlIFswLDFdIGVudHJ5IG9mIHRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcn1cbiAqICAgICAgICAgIG0xMCB0aGUgWzEsMF0gZW50cnkgb2YgdGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyfVxuICogICAgICAgICAgbTExIHRoZSBbMSwxXSBlbnRyeSBvZiB0aGUgbWF0cml4LlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgZGV0ZXJtaW5hbnQuXG4gKi9cbmZ1bmN0aW9uIGRldCAobTAwLCBtMDEsIG0xMCwgbTExKVxue1xuICAgIHJldHVybiAobTAwICogbTExKSAtIChtMDEgKiBtMTApO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjaXJjdW1jZW50cmUgb2YgYSB0cmlhbmdsZS4gVGhlIGNpcmN1bWNlbnRyZSBpcyB0aGUgY2VudHJlIG9mXG4gKiB0aGUgY2lyY3VtY2lyY2xlLCB0aGUgc21hbGxlc3QgY2lyY2xlIHdoaWNoIGVuY2xvc2VzIHRoZSB0cmlhbmdsZS4gSXQgaXMgYWxzb1xuICogdGhlIGNvbW1vbiBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgdGhlIHBlcnBlbmRpY3VsYXIgYmlzZWN0b3JzIG9mIHRoZSBzaWRlcyBvZlxuICogdGhlIHRyaWFuZ2xlLCBhbmQgaXMgdGhlIG9ubHkgcG9pbnQgd2hpY2ggaGFzIGVxdWFsIGRpc3RhbmNlIHRvIGFsbCB0aHJlZVxuICogdmVydGljZXMgb2YgdGhlIHRyaWFuZ2xlLlxuICogPHA+XG4gKiBUaGlzIG1ldGhvZCB1c2VzIGFuIGFsZ29yaXRobSBkdWUgdG8gSi5SLlNoZXdjaHVrIHdoaWNoIHVzZXMgbm9ybWFsaXphdGlvbiB0b1xuICogdGhlIG9yaWdpbiB0byBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiBjb21wdXRhdGlvbi4gKFNlZSA8aT5MZWN0dXJlIE5vdGVzIG9uXG4gKiBHZW9tZXRyaWMgUm9idXN0bmVzczwvaT4sIEpvbmF0aGFuIFJpY2hhcmQgU2hld2NodWssIDE5OTkpLlxuICovXG52YXIgQ2lyY3VtQ2VudGVyID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCB9OyB9XG5cbiAgICB2YXIgY3ggPSB0cmlhbmdsZS54MztcbiAgICB2YXIgY3kgPSB0cmlhbmdsZS55MztcblxuICAgIHZhciBheCA9IHRyaWFuZ2xlLngxIC0gY3g7XG4gICAgdmFyIGF5ID0gdHJpYW5nbGUueTEgLSBjeTtcblxuICAgIHZhciBieCA9IHRyaWFuZ2xlLngyIC0gY3g7XG4gICAgdmFyIGJ5ID0gdHJpYW5nbGUueTIgLSBjeTtcblxuICAgIHZhciBkZW5vbSA9IDIgKiBkZXQoYXgsIGF5LCBieCwgYnkpO1xuICAgIHZhciBudW14ID0gZGV0KGF5LCBheCAqIGF4ICsgYXkgKiBheSwgYnksIGJ4ICogYnggKyBieSAqIGJ5KTtcbiAgICB2YXIgbnVteSA9IGRldChheCwgYXggKiBheCArIGF5ICogYXksIGJ4LCBieCAqIGJ4ICsgYnkgKiBieSk7XG5cbiAgICBvdXQueCA9IGN4IC0gbnVteCAvIGRlbm9tO1xuICAgIG91dC55ID0gY3kgKyBudW15IC8gZGVub207XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdW1DZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9nZW9tL3RyaWFuZ2xlL0NpcmN1bUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXV0b28vNTYxNzY5MVxuXG52YXIgQ2lyY3VtQ2lyY2xlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBvdXQpXG57XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7IG91dCA9IHsgeDogMCwgeTogMCwgcmFkaXVzOiAwIH07IH1cblxuICAgIC8vICBBXG4gICAgdmFyIHgxID0gdHJpYW5nbGUueDE7XG4gICAgdmFyIHkxID0gdHJpYW5nbGUueTE7XG5cbiAgICAvLyAgQlxuICAgIHZhciB4MiA9IHRyaWFuZ2xlLngyO1xuICAgIHZhciB5MiA9IHRyaWFuZ2xlLnkyO1xuXG4gICAgLy8gIENcbiAgICB2YXIgeDMgPSB0cmlhbmdsZS54MztcbiAgICB2YXIgeTMgPSB0cmlhbmdsZS55MztcblxuICAgIHZhciBBID0geDIgLSB4MTtcbiAgICB2YXIgQiA9IHkyIC0geTE7XG4gICAgdmFyIEMgPSB4MyAtIHgxO1xuICAgIHZhciBEID0geTMgLSB5MTtcbiAgICB2YXIgRSA9IEEgKiAoeDEgKyB4MikgKyBCICogKHkxICsgeTIpO1xuICAgIHZhciBGID0gQyAqICh4MSArIHgzKSArIEQgKiAoeTEgKyB5Myk7XG4gICAgdmFyIEcgPSAyICogKEEgKiAoeTMgLSB5MikgLSBCICogKHgzIC0geDIpKTtcblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICAvLyAgSWYgdGhlIHBvaW50cyBvZiB0aGUgdHJpYW5nbGUgYXJlIGNvbGxpbmVhciwgdGhlbiBqdXN0IGZpbmQgdGhlXG4gICAgLy8gIGV4dHJlbWVzIGFuZCB1c2UgdGhlIG1pZHBvaW50IGFzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmN1bWNpcmNsZS5cblxuICAgIGlmIChNYXRoLmFicyhHKSA8IDAuMDAwMDAxKVxuICAgIHtcbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbih4MSwgeDIsIHgzKTtcbiAgICAgICAgdmFyIG1pblkgPSBNYXRoLm1pbih5MSwgeTIsIHkzKTtcbiAgICAgICAgZHggPSAoTWF0aC5tYXgoeDEsIHgyLCB4MykgLSBtaW5YKSAqIDAuNTtcbiAgICAgICAgZHkgPSAoTWF0aC5tYXgoeTEsIHkyLCB5MykgLSBtaW5ZKSAqIDAuNTtcblxuICAgICAgICBvdXQueCA9IG1pblggKyBkeDtcbiAgICAgICAgb3V0LnkgPSBtaW5ZICsgZHk7XG4gICAgICAgIG91dC5yYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBvdXQueCA9IChEICogRSAtIEIgKiBGKSAvIEc7XG4gICAgICAgIG91dC55ID0gKEEgKiBGIC0gQyAqIEUpIC8gRztcbiAgICAgICAgZHggPSBvdXQueCAtIHgxO1xuICAgICAgICBkeSA9IG91dC55IC0geTE7XG4gICAgICAgIG91dC5yYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmN1bUNpcmNsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvQ2lyY3VtQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xuXG52YXIgQ2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKVxue1xuICAgIHJldHVybiBuZXcgVHJpYW5nbGUoc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyLCBzb3VyY2UueDMsIHNvdXJjZS55Myk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9DbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gNDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vdHJpYW5nbGUvQ2xvbmUuanMiLCJ2YXIgQ29udGFpbnMgPSByZXF1aXJlKCcuL0NvbnRhaW5zJyk7XG5cbnZhciBDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBwb2ludClcbntcbiAgICByZXR1cm4gQ29udGFpbnModHJpYW5nbGUsIHBvaW50LngsIHBvaW50LnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluc1BvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9Db250YWluc1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2VvbS90cmlhbmdsZS9Db250YWluc1BvaW50LmpzIiwiLyoqXG4qIENvcGllcyB0aGUgeDEsIHkxIC0geDMsIHkzIHByb3BlcnRpZXMgZnJvbSBhbnkgZ2l2ZW4gb2JqZWN0IHRvIHRoaXMgVHJpYW5nbGUuXG4qIEBtZXRob2QgUGhhc2VyLkxpbmUjY29weUZyb21cbiogQHBhcmFtIHthbnl9IHNvdXJjZSAtIFRoZSBvYmplY3QgdG8gY29weSBmcm9tLlxuKiBAcmV0dXJuIHtMaW5lfSBUaGlzIExpbmUgb2JqZWN0LlxuKi9cbnZhciBDb3B5RnJvbSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpXG57XG4gICAgcmV0dXJuIGRlc3Quc2V0VG8oc291cmNlLngxLCBzb3VyY2UueTEsIHNvdXJjZS54Miwgc291cmNlLnkyLCBzb3VyY2UueDMsIHNvdXJjZS55Myk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcHlGcm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9Db3B5RnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gNDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFcXVhbHMgPSBmdW5jdGlvbiAodHJpYW5nbGUsIHRvQ29tcGFyZSlcbntcbiAgICByZXR1cm4gKFxuICAgICAgICB0cmlhbmdsZS54MSA9PT0gdG9Db21wYXJlLngxICYmXG4gICAgICAgIHRyaWFuZ2xlLnkxID09PSB0b0NvbXBhcmUueTEgJiZcbiAgICAgICAgdHJpYW5nbGUueDIgPT09IHRvQ29tcGFyZS54MiAmJlxuICAgICAgICB0cmlhbmdsZS55MiA9PT0gdG9Db21wYXJlLnkyICYmXG4gICAgICAgIHRyaWFuZ2xlLngzID09PSB0b0NvbXBhcmUueDMgJiZcbiAgICAgICAgdHJpYW5nbGUueTMgPT09IHRvQ29tcGFyZS55M1xuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvRXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJvdGF0ZUFyb3VuZFhZID0gcmVxdWlyZSgnLi9Sb3RhdGVBcm91bmRYWScpO1xudmFyIEluQ2VudGVyID0gcmVxdWlyZSgnLi9JbkNlbnRlcicpO1xuXG52YXIgUm90YXRlID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBhbmdsZSlcbntcbiAgICB2YXIgcG9pbnQgPSBJbkNlbnRlcih0cmlhbmdsZSk7XG5cbiAgICByZXR1cm4gUm90YXRlQXJvdW5kWFkodHJpYW5nbGUsIHBvaW50LngsIHBvaW50LnksIGFuZ2xlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3RyaWFuZ2xlL1JvdGF0ZS5qcyIsInZhciBSb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxudmFyIFJvdGF0ZUFyb3VuZFBvaW50ID0gZnVuY3Rpb24gKHRyaWFuZ2xlLCBwb2ludCwgYW5nbGUpXG57XG4gICAgcmV0dXJuIFJvdGF0ZUFyb3VuZFhZKHRyaWFuZ2xlLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUFyb3VuZFBvaW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2VvbS90cmlhbmdsZS9Sb3RhdGVBcm91bmRQb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dlb20vdHJpYW5nbGUvUm90YXRlQXJvdW5kUG9pbnQuanMiLCIvLyAgUGhhc2VyLkdlb20uVHJpYW5nbGVcblxudmFyIFRyaWFuZ2xlID0gcmVxdWlyZSgnLi9UcmlhbmdsZScpO1xuXG5UcmlhbmdsZS5BcmVhID0gcmVxdWlyZSgnLi9BcmVhJyk7XG5UcmlhbmdsZS5CdWlsZEVxdWlsYXRlcmFsID0gcmVxdWlyZSgnLi9CdWlsZEVxdWlsYXRlcmFsJyk7XG5UcmlhbmdsZS5CdWlsZEZyb21Qb2x5Z29uID0gcmVxdWlyZSgnLi9CdWlsZEZyb21Qb2x5Z29uJyk7XG5UcmlhbmdsZS5CdWlsZFJpZ2h0ID0gcmVxdWlyZSgnLi9CdWlsZFJpZ2h0Jyk7XG5UcmlhbmdsZS5DZW50ZXJPbiA9IHJlcXVpcmUoJy4vQ2VudGVyT24nKTtcblRyaWFuZ2xlLkNlbnRyb2lkID0gcmVxdWlyZSgnLi9DZW50cm9pZCcpO1xuVHJpYW5nbGUuQ2lyY3VtQ2VudGVyID0gcmVxdWlyZSgnLi9DaXJjdW1DZW50ZXInKTtcblRyaWFuZ2xlLkNpcmN1bUNpcmNsZSA9IHJlcXVpcmUoJy4vQ2lyY3VtQ2lyY2xlJyk7XG5UcmlhbmdsZS5DbG9uZSA9IHJlcXVpcmUoJy4vQ2xvbmUnKTtcblRyaWFuZ2xlLkNvbnRhaW5zID0gcmVxdWlyZSgnLi9Db250YWlucycpO1xuVHJpYW5nbGUuQ29udGFpbnNBcnJheSA9IHJlcXVpcmUoJy4vQ29udGFpbnNBcnJheScpO1xuVHJpYW5nbGUuQ29udGFpbnNQb2ludCA9IHJlcXVpcmUoJy4vQ29udGFpbnNQb2ludCcpO1xuVHJpYW5nbGUuQ29weUZyb20gPSByZXF1aXJlKCcuL0NvcHlGcm9tJyk7XG5UcmlhbmdsZS5EZWNvbXBvc2UgPSByZXF1aXJlKCcuL0RlY29tcG9zZScpO1xuVHJpYW5nbGUuRXF1YWxzID0gcmVxdWlyZSgnLi9FcXVhbHMnKTtcblRyaWFuZ2xlLkluQ2VudGVyID0gcmVxdWlyZSgnLi9JbkNlbnRlcicpO1xuVHJpYW5nbGUuT2Zmc2V0ID0gcmVxdWlyZSgnLi9PZmZzZXQnKTtcblRyaWFuZ2xlLlJhbmRvbSA9IHJlcXVpcmUoJy4vUmFuZG9tJyk7XG5UcmlhbmdsZS5Sb3RhdGUgPSByZXF1aXJlKCcuL1JvdGF0ZScpO1xuVHJpYW5nbGUuUm90YXRlQXJvdW5kUG9pbnQgPSByZXF1aXJlKCcuL1JvdGF0ZUFyb3VuZFBvaW50Jyk7XG5UcmlhbmdsZS5Sb3RhdGVBcm91bmRYWSA9IHJlcXVpcmUoJy4vUm90YXRlQXJvdW5kWFknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dlb20vdHJpYW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9nZW9tL3RyaWFuZ2xlL2luZGV4LmpzIiwiLyoqXG4qIFRha2VzIHRoZSBhdmVyYWdlIG9mIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycy5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZEF2ZXJhZ2VcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgQXZlcmFnZSA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXZlcmFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvQXZlcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBTdWJ0cmFjdHMgdGhlIGRhcmtlciBvZiB0aGUgdHdvIGNvbnN0aXR1ZW50IGNvbG9ycyBmcm9tIHRoZSBsaWdodGVyLlxuKiBcbiogUGFpbnRpbmcgd2l0aCB3aGl0ZSBpbnZlcnRzIHRoZSBiYWNrZHJvcCBjb2xvcjsgcGFpbnRpbmcgd2l0aCBibGFjayBwcm9kdWNlcyBubyBjaGFuZ2UuIFxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kRGlmZmVyZW5jZVxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBQcm9kdWNlcyBhbiBlZmZlY3Qgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBEaWZmZXJlbmNlIG1vZGUsIGJ1dCBsb3dlciBpbiBjb250cmFzdC4gXG4qIFBhaW50aW5nIHdpdGggd2hpdGUgaW52ZXJ0cyB0aGUgYmFja2Ryb3AgY29sb3I7IHBhaW50aW5nIHdpdGggYmxhY2sgcHJvZHVjZXMgbm8gY2hhbmdlLiBcbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZEV4Y2x1c2lvblxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBFeGNsdXNpb24gPSAgZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIGEgKyBiIC0gMiAqIGEgKiBiIC8gMjU1O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGNsdXNpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0V4Y2x1c2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9SZWZsZWN0Jyk7XG5cbi8qKlxuKiBHbG93IGJsZW5kIG1vZGUuIFRoaXMgbW9kZSBpcyBhIHZhcmlhdGlvbiBvZiByZWZsZWN0IG1vZGUgd2l0aCB0aGUgc291cmNlIGFuZCBiYWNrZHJvcCBjb2xvcnMgc3dhcHBlZC5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZEdsb3dcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgR2xvdyA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiBSZWZsZWN0KGIsIGEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbG93O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9HbG93LmpzIiwidmFyIE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcblxuLyoqXG4qIE11bHRpcGxpZXMgb3Igc2NyZWVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXG4qIFxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGxpZ2h0ZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBsaWdodGVuZWQsIGFzIGlmIGl0IHdlcmUgc2NyZWVuZWQ7IFxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIGhpZ2hsaWdodHMgdG8gYSBzY2VuZS4gXG4qIFxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGRhcmtlciB0aGFuIDAuNSwgdGhlIGJhY2tkcm9wIGlzIGRhcmtlbmVkLCBhcyBpZiBpdCB3ZXJlIG11bHRpcGxpZWQ7IFxuKiB0aGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIHNoYWRvd3MgdG8gYSBzY2VuZS4gXG4qIFxuKiBUaGUgZGVncmVlIG9mIGxpZ2h0ZW5pbmcgb3IgZGFya2VuaW5nIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgY29sb3IgYW5kIDAuNTsgXG4qIGlmIGl0IGlzIGVxdWFsIHRvIDAuNSwgdGhlIGJhY2tkcm9wIGlzIHVuY2hhbmdlZC5cbiogXG4qIFBhaW50aW5nIHdpdGggcHVyZSBibGFjayBvciB3aGl0ZSBwcm9kdWNlcyBwdXJlIGJsYWNrIG9yIHdoaXRlLiBUaGUgZWZmZWN0IGlzIHNpbWlsYXIgdG8gc2hpbmluZyBhIGhhcnNoIHNwb3RsaWdodCBvbiB0aGUgYmFja2Ryb3AuIFxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kSGFyZExpZ2h0XG4qIEBzdGF0aWNcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qL1xudmFyIEhhcmRMaWdodCA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiBPdmVybGF5KGIsIGEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXJkTGlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRMaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2JsZW5kbW9kZXMvSGFyZExpZ2h0LmpzIiwidmFyIFZpdmlkTGlnaHQgPSByZXF1aXJlKCcuL1ZpdmlkTGlnaHQnKTtcblxuLyoqXG4qIFJ1bnMgYmxlbmRWaXZpZExpZ2h0IG9uIHRoZSBzb3VyY2UgYW5kIGJhY2tkcm9wIGNvbG9ycy5cbiogSWYgdGhlIHJlc3VsdGluZyBjb2xvciBpcyAxMjggb3IgbW9yZSwgaXQgcmVjZWl2ZXMgYSB2YWx1ZSBvZiAyNTU7IGlmIGxlc3MgdGhhbiAxMjgsIGEgdmFsdWUgb2YgMC5cbiogVGhlcmVmb3JlLCBhbGwgYmxlbmRlZCBwaXhlbHMgaGF2ZSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjaGFubmVsIHZhbHVlcyBvZiBlaXRoZXIgMCBvciAyNTUuXG4qIFRoaXMgY2hhbmdlcyBhbGwgcGl4ZWxzIHRvIHByaW1hcnkgYWRkaXRpdmUgY29sb3JzIChyZWQsIGdyZWVuLCBvciBibHVlKSwgd2hpdGUsIG9yIGJsYWNrLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kSGFyZE1peFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBIYXJkTWl4ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIChWaXZpZExpZ2h0KGEsIGIpIDwgMTI4KSA/IDAgOiAyNTU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhcmRNaXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRNaXguanNcbi8vIG1vZHVsZSBpZCA9IDQ2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9ibGVuZG1vZGVzL0hhcmRNaXguanMiLCJ2YXIgTGluZWFyQnVybiA9IHJlcXVpcmUoJy4vTGluZWFyQnVybicpO1xudmFyIExpbmVhckRvZGdlID0gcmVxdWlyZSgnLi9MaW5lYXJEb2RnZScpO1xuXG4vKipcbiogVGhpcyBibGVuZCBtb2RlIGNvbWJpbmVzIExpbmVhciBEb2RnZSBhbmQgTGluZWFyIEJ1cm4gKHJlc2NhbGVkIHNvIHRoYXQgbmV1dHJhbCBjb2xvcnMgYmVjb21lIG1pZGRsZSBncmF5KS5cbiogRG9kZ2UgYXBwbGllcyB0byB2YWx1ZXMgb2YgdG9wIGxheWVyIGxpZ2h0ZXIgdGhhbiBtaWRkbGUgZ3JheSwgYW5kIGJ1cm4gdG8gZGFya2VyIHZhbHVlcy5cbiogVGhlIGNhbGN1bGF0aW9uIHNpbXBsaWZpZXMgdG8gdGhlIHN1bSBvZiBib3R0b20gbGF5ZXIgYW5kIHR3aWNlIHRoZSB0b3AgbGF5ZXIsIHN1YnRyYWN0IDEyOC4gVGhlIGNvbnRyYXN0IGRlY3JlYXNlcy5cbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZExpbmVhckxpZ2h0XG4qIEBzdGF0aWNcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qL1xudmFyIExpbmVhckxpZ2h0ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIChiIDwgMTI4KSA/IExpbmVhckJ1cm4oYSwgMiAqIGIpIDogTGluZWFyRG9kZ2UoYSwgKDIgKiAoYiAtIDEyOCkpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyTGlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL0xpbmVhckxpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9MaW5lYXJMaWdodC5qcyIsIi8qKlxuKiBNdWx0aXBsaWVzIHRoZSBiYWNrZHJvcCBhbmQgc291cmNlIGNvbG9yIHZhbHVlcy5cbiogVGhlIHJlc3VsdCBjb2xvciBpcyBhbHdheXMgYXQgbGVhc3QgYXMgZGFyayBhcyBlaXRoZXIgb2YgdGhlIHR3byBjb25zdGl0dWVudFxuKiBjb2xvcnMuIE11bHRpcGx5aW5nIGFueSBjb2xvciB3aXRoIGJsYWNrIHByb2R1Y2VzIGJsYWNrO1xuKiBtdWx0aXBseWluZyB3aXRoIHdoaXRlIGxlYXZlcyB0aGUgb3JpZ2luYWwgY29sb3IgdW5jaGFuZ2VkLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kTXVsdGlwbHlcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgTXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGEgKiBiKSAvIDI1NTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL011bHRpcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIE5lZ2F0aW9uIGJsZW5kIG1vZGUuXG4qXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmROZWdhdGlvblxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBOZWdhdGlvbiA9IGZ1bmN0aW9uIChhLCBiKVxue1xuICAgIHJldHVybiAyNTUgLSBNYXRoLmFicygyNTUgLSBhIC0gYik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZ2F0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9OZWdhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBCbGVuZHMgdGhlIHNvdXJjZSBjb2xvciwgaWdub3JpbmcgdGhlIGJhY2tkcm9wLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kTm9ybWFsXG4qIEBzdGF0aWNcbiogQHBhcmFtIHtpbnRlZ2VyfSBhIC0gVGhlIHNvdXJjZSBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcGFyYW0ge2ludGVnZXJ9IGIgLSBUaGUgYmFja2Ryb3AgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHJldHVybnMge2ludGVnZXJ9IFRoZSBibGVuZGVkIGNvbG9yIHZhbHVlLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qL1xudmFyIE5vcm1hbCA9IGZ1bmN0aW9uIChhKVxue1xuICAgIHJldHVybiBhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL05vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gNDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBQaG9lbml4IGJsZW5kIG1vZGUuIFRoaXMgc3VidHJhY3RzIHRoZSBsaWdodGVyIGNvbG9yIGZyb20gdGhlIGRhcmtlciBjb2xvciwgYW5kIGFkZHMgMjU1LCBnaXZpbmcgYSBicmlnaHQgcmVzdWx0LlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kUGhvZW5peFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBQaG9lbml4ID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGgubWluKGEsIGIpIC0gTWF0aC5tYXgoYSwgYikgKyAyNTU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBob2VuaXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1Bob2VuaXguanNcbi8vIG1vZHVsZSBpZCA9IDQ2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGFya2VuID0gcmVxdWlyZSgnLi9EYXJrZW4nKTtcbnZhciBMaWdodGVuID0gcmVxdWlyZSgnLi9MaWdodGVuJyk7XG5cbi8qKlxuKiBJZiB0aGUgYmFja2Ryb3AgY29sb3IgKGxpZ2h0IHNvdXJjZSkgaXMgbGlnaHRlciB0aGFuIDUwJSwgdGhlIGJsZW5kRGFya2VuIG1vZGUgaXMgdXNlZCwgYW5kIGNvbG9ycyBsaWdodGVyIHRoYW4gdGhlIGJhY2tkcm9wIGNvbG9yIGRvIG5vdCBjaGFuZ2UuXG4qIElmIHRoZSBiYWNrZHJvcCBjb2xvciBpcyBkYXJrZXIgdGhhbiA1MCUgZ3JheSwgY29sb3JzIGxpZ2h0ZXIgdGhhbiB0aGUgYmxlbmQgY29sb3IgYXJlIHJlcGxhY2VkLCBhbmQgY29sb3JzIGRhcmtlciB0aGFuIHRoZSBibGVuZCBjb2xvciBkbyBub3QgY2hhbmdlLlxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLmJsZW5kUGluTGlnaHRcbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgUGluTGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gRGFya2VuKGEsIDIgKiBiKSA6IExpZ2h0ZW4oYSwgKDIgKiAoYiAtIDEyOCkpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGluTGlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9ibGVuZG1vZGVzL1BpbkxpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA0Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvYmxlbmRtb2Rlcy9QaW5MaWdodC5qcyIsIi8qKlxuKiBNdWx0aXBsaWVzIHRoZSBjb21wbGVtZW50cyBvZiB0aGUgYmFja2Ryb3AgYW5kIHNvdXJjZSBjb2xvciB2YWx1ZXMsIHRoZW4gY29tcGxlbWVudHMgdGhlIHJlc3VsdC5cbiogVGhlIHJlc3VsdCBjb2xvciBpcyBhbHdheXMgYXQgbGVhc3QgYXMgbGlnaHQgYXMgZWl0aGVyIG9mIHRoZSB0d28gY29uc3RpdHVlbnQgY29sb3JzLiBcbiogU2NyZWVuaW5nIGFueSBjb2xvciB3aXRoIHdoaXRlIHByb2R1Y2VzIHdoaXRlOyBzY3JlZW5pbmcgd2l0aCBibGFjayBsZWF2ZXMgdGhlIG9yaWdpbmFsIGNvbG9yIHVuY2hhbmdlZC4gXG4qXG4qIEBtZXRob2QgTGF6ZXIuQ29sb3IuYmxlbmRTY3JlZW5cbiogQHN0YXRpY1xuKiBAcGFyYW0ge2ludGVnZXJ9IGEgLSBUaGUgc291cmNlIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEBwYXJhbSB7aW50ZWdlcn0gYiAtIFRoZSBiYWNrZHJvcCBjb2xvciB0byBibGVuZCwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKiBAcmV0dXJucyB7aW50ZWdlcn0gVGhlIGJsZW5kZWQgY29sb3IgdmFsdWUsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiovXG52YXIgU2NyZWVuID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIDI1NSAtICgoKDI1NSAtIGEpICogKDI1NSAtIGIpKSA+PiA4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NyZWVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvYmxlbmRtb2Rlcy9TY3JlZW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogRGFya2VucyBvciBsaWdodGVucyB0aGUgY29sb3JzLCBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZSBjb2xvciB2YWx1ZS4gXG4qIFxuKiBJZiB0aGUgc291cmNlIGNvbG9yIGlzIGxpZ2h0ZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBsaWdodGVuZWQsIGFzIGlmIGl0IHdlcmUgZG9kZ2VkOyBcbiogdGhpcyBpcyB1c2VmdWwgZm9yIGFkZGluZyBoaWdobGlnaHRzIHRvIGEgc2NlbmUuIFxuKiBcbiogSWYgdGhlIHNvdXJjZSBjb2xvciBpcyBkYXJrZXIgdGhhbiAwLjUsIHRoZSBiYWNrZHJvcCBpcyBkYXJrZW5lZCwgYXMgaWYgaXQgd2VyZSBidXJuZWQgaW4uIFxuKiBUaGUgZGVncmVlIG9mIGxpZ2h0ZW5pbmcgb3IgZGFya2VuaW5nIGlzIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgY29sb3IgYW5kIDAuNTsgXG4qIGlmIGl0IGlzIGVxdWFsIHRvIDAuNSwgdGhlIGJhY2tkcm9wIGlzIHVuY2hhbmdlZC5cbiogXG4qIFBhaW50aW5nIHdpdGggcHVyZSBibGFjayBvciB3aGl0ZSBwcm9kdWNlcyBhIGRpc3RpbmN0bHkgZGFya2VyIG9yIGxpZ2h0ZXIgYXJlYSwgYnV0IGRvZXMgbm90IHJlc3VsdCBpbiBwdXJlIGJsYWNrIG9yIHdoaXRlLiBcbiogVGhlIGVmZmVjdCBpcyBzaW1pbGFyIHRvIHNoaW5pbmcgYSBkaWZmdXNlZCBzcG90bGlnaHQgb24gdGhlIGJhY2tkcm9wLiBcbipcbiogQG1ldGhvZCBMYXplci5Db2xvci5ibGVuZFNvZnRMaWdodFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7aW50ZWdlcn0gYSAtIFRoZSBzb3VyY2UgY29sb3IgdG8gYmxlbmQsIGluIHRoZSByYW5nZSAxIHRvIDI1NS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBiIC0gVGhlIGJhY2tkcm9wIGNvbG9yIHRvIGJsZW5kLCBpbiB0aGUgcmFuZ2UgMSB0byAyNTUuXG4qIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgYmxlbmRlZCBjb2xvciB2YWx1ZSwgaW4gdGhlIHJhbmdlIDEgdG8gMjU1LlxuKi9cbnZhciBTb2Z0TGlnaHQgPSBmdW5jdGlvbiAoYSwgYilcbntcbiAgICByZXR1cm4gKGIgPCAxMjgpID8gKDIgKiAoKGEgPj4gMSkgKyA2NCkpICogKGIgLyAyNTUpIDogMjU1IC0gKDIgKiAoMjU1IC0gKChhID4+IDEpICsgNjQpKSAqICgyNTUgLSBiKSAvIDI1NSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvZnRMaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvU29mdExpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gIFBoYXNlci5HcmFwaGljcy5CbGVuZE1vZGVzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQWRkOiByZXF1aXJlKCcuL0FkZCcpLFxuICAgIEF2ZXJhZ2U6IHJlcXVpcmUoJy4vQXZlcmFnZScpLFxuICAgIENvbG9yQnVybjogcmVxdWlyZSgnLi9Db2xvckJ1cm4nKSxcbiAgICBDb2xvckRvZGdlOiByZXF1aXJlKCcuL0NvbG9yRG9kZ2UnKSxcbiAgICBEYXJrZW46IHJlcXVpcmUoJy4vRGFya2VuJyksXG4gICAgRGlmZmVyZW5jZTogcmVxdWlyZSgnLi9EaWZmZXJlbmNlJyksXG4gICAgRXhjbHVzaW9uOiByZXF1aXJlKCcuL0V4Y2x1c2lvbicpLFxuICAgIEdsb3c6IHJlcXVpcmUoJy4vR2xvdycpLFxuICAgIEhhcmRMaWdodDogcmVxdWlyZSgnLi9IYXJkTGlnaHQnKSxcbiAgICBIYXJkTWl4OiByZXF1aXJlKCcuL0hhcmRNaXgnKSxcbiAgICBMaWdodGVuOiByZXF1aXJlKCcuL0xpZ2h0ZW4nKSxcbiAgICBMaW5lYXJCdXJuOiByZXF1aXJlKCcuL0xpbmVhckJ1cm4nKSxcbiAgICBMaW5lYXJEb2RnZTogcmVxdWlyZSgnLi9MaW5lYXJEb2RnZScpLFxuICAgIExpbmVhckxpZ2h0OiByZXF1aXJlKCcuL0xpbmVhckxpZ2h0JyksXG4gICAgTXVsdGlwbHk6IHJlcXVpcmUoJy4vTXVsdGlwbHknKSxcbiAgICBOZWdhdGlvbjogcmVxdWlyZSgnLi9OZWdhdGlvbicpLFxuICAgIE5vcm1hbDogcmVxdWlyZSgnLi9Ob3JtYWwnKSxcbiAgICBPdmVybGF5OiByZXF1aXJlKCcuL092ZXJsYXknKSxcbiAgICBQaG9lbml4OiByZXF1aXJlKCcuL1Bob2VuaXgnKSxcbiAgICBQaW5MaWdodDogcmVxdWlyZSgnLi9QaW5MaWdodCcpLFxuICAgIFJlZmxlY3Q6IHJlcXVpcmUoJy4vUmVmbGVjdCcpLFxuICAgIFNjcmVlbjogcmVxdWlyZSgnLi9TY3JlZW4nKSxcbiAgICBTb2Z0TGlnaHQ6IHJlcXVpcmUoJy4vU29mdExpZ2h0JyksXG4gICAgU3VidHJhY3Q6IHJlcXVpcmUoJy4vU3VidHJhY3QnKSxcbiAgICBWaXZpZExpZ2h0OiByZXF1aXJlKCcuL1ZpdmlkTGlnaHQnKVxuICAgIFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2JsZW5kbW9kZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9ibGVuZG1vZGVzL2luZGV4LmpzIiwidmFyIENvbG9yID0gcmVxdWlyZSgnLi9Db2xvcicpO1xuXG52YXIgQ1NTTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogWyAyNDAsIDI0OCwgMjQ1IF0sXG4gICAgYW50aXF1ZXdoaXRlOiBbIDI1MCwgMjM1LCAyMTUgXSxcbiAgICBhcXVhOiBbIDAsIDI1NSwgMjU1IF0sXG4gICAgYXF1YW1hcmluZTogWyAxMjcsIDI1NSwgMjEyIF0sXG4gICAgYXp1cmU6IFsgMjQwLCAyNTUsIDI1NSBdLFxuICAgIGJlaWdlOiBbIDI0NSwgMjQ1LCAyMjAgXSxcbiAgICBiaXNxdWU6IFsgMjU1LCAyMjgsIDE5NiBdLFxuICAgIGJsYWNrOiBbIDAsIDAsIDAgXSxcbiAgICBibGFuY2hlZGFsbW9uZDogWyAyNTUsIDIzNSwgMjA1IF0sXG4gICAgYmx1ZTogWyAwLCAwLCAyNTUgXSxcbiAgICBibHVldmlvbGV0OiBbIDEzOCwgNDMsIDIyNiBdLFxuICAgIGJyb3duOiBbIDE2NSwgNDIsIDQyIF0sXG4gICAgYnVybHl3b29kOiBbIDIyMiwgMTg0LCAzNSBdLFxuICAgIGNhZGV0Ymx1ZTogWyA5NSwgMTU4LCAxNjAgXSxcbiAgICBjaGFydHJldXNlOiBbIDEyNywgMjU1LCAwIF0sXG4gICAgY2hvY29sYXRlOiBbIDIxMCwgMTA1LCAzMCBdLFxuICAgIGNvcmFsOiBbIDI1NSwgMTI3LCA4MCBdLFxuICAgIGNvcm5mbG93ZXJibHVlOiBbIDEwMCwgMTQ5LCAyMzcgXSxcbiAgICBjb3Juc2lsazogWyAyNTUsIDI0OCwgMjIwIF0sXG4gICAgY3JpbXNvbjogWyAyMjAsIDIwLCA2MCBdLFxuICAgIGRhcmtibHVlOiBbIDAsIDAsIDEzOSBdLFxuICAgIGRhcmtjeWFuOiBbIDAsIDEzOSwgMTM5IF0sXG4gICAgZGFya2dvbGRlbnJvZDogWyAxODQsIDEzNCwgMTEgXSxcbiAgICBkYXJrZ3JheTogWyAxNjksIDE2OSwgMTY5IF0sXG4gICAgZGFya2dyZWVuOiBbIDAsIDEwMCwgMCBdLFxuICAgIGRhcmtncmV5OiBbIDE2OSwgMTY5LCAxNjkgXSxcbiAgICBkYXJra2hha2k6IFsgMTg5LCAxODMsIDEwNyBdLFxuICAgIGRhcmttYWdlbnRhOiBbIDEzOSwgMCwgMTM5IF0sXG4gICAgZGFya29saXZlZ3JlZW46IFsgODUsIDEwNywgNDcgXSxcbiAgICBkYXJrb3JhbmdlOiBbIDI1NSwgMTQwLCAwIF0sXG4gICAgZGFya29yY2hpZDogWyAxNTMsIDUwLCAyMDQgXSxcbiAgICBkYXJrcmVkOiBbIDEzOSwgMCwgMCBdLFxuICAgIGRhcmtzYWxtb246IFsgMjMzLCAxNTAsIDEyMiBdLFxuICAgIGRhcmtzZWFncmVlbjogWyAxNDMsIDE4OCwgMTQzIF0sXG4gICAgZGFya3NsYXRlYmx1ZTogWyA3MiwgNjEsIDEzOSBdLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFsgNDcsIDc5LCA3OSBdLFxuICAgIGRhcmt0dXJxdW9pc2U6IFsgMCwgMjA2LCAyMDkgXSxcbiAgICBkYXJrdmlvbGV0OiBbIDE0OCwgMCwgMjExIF0sXG4gICAgZGVlcHBpbms6IFsgMjU1LCAyMCwgMTQ3IF0sXG4gICAgZGVlcHNreWJsdWU6IFsgMCwgMTkxLCAyNTUgXSxcbiAgICBkaW1ncmF5OiBbIDEwNSwgMTA1LCAxMDUgXSxcbiAgICBkaW1ncmV5OiBbIDEwNSwgMTA1LCAxMDUgXSxcbiAgICBkb2RnZXJibHVlOiBbIDMwLCAxNDQsIDI1NSBdLFxuICAgIGZpcmVicmljazogWyAxNzgsIDM0LCAzNCBdLFxuICAgIGZsb3JhbHdoaXRlOiBbIDI1NSwgMjUwLCAyNDAgXSxcbiAgICBmb3Jlc3RncmVlbjogWyAzNCwgMTM5LCAzNCBdLFxuICAgIGZ1Y2hzaWE6IFsgMjU1LCAwLCAyNTUgXSxcbiAgICBnYWluc2Jvcm86IFsgMjIwLCAyMjAsIDIyMCBdLFxuICAgIGdob3N0d2hpdGU6IFsgMjQ4LCAyNDgsIDI1NSBdLFxuICAgIGdvbGQ6IFsgMjU1LCAyMTUsIDAgXSxcbiAgICBnb2xkZW5yb2Q6IFsgMjE4LCAxNjUsIDMyIF0sXG4gICAgZ3JheTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgZ3JlZW46IFsgMCwgMTI4LCAwIF0sXG4gICAgZ3JlZW55ZWxsb3c6IFsgMTczLCAyNTUsIDQ3IF0sXG4gICAgZ3JleTogWyAxMjgsIDEyOCwgMTI4IF0sXG4gICAgaG9uZXlkZXc6IFsgMjQwLCAyNTUsIDI0MCBdLFxuICAgIGhvdHBpbms6IFsgMjU1LCAxMDUsIDE4MCBdLFxuICAgIGluZGlhbnJlZDogWyAyMDUsIDkyLCA5MiBdLFxuICAgIGluZGlnbzogWyA3NSwgMCwgMTMwIF0sXG4gICAgaXZvcnk6IFsgMjU1LCAyNTUsIDI0MCBdLFxuICAgIGtoYWtpOiBbIDI0MCwgMjMwLCAxNDAgXSxcbiAgICBsYXZlbmRlcjogWyAyMzAsIDIzMCwgMjUwIF0sXG4gICAgbGF2ZW5kZXJibHVzaDogWyAyNTUsIDI0MCwgMjQ1IF0sXG4gICAgbGF3bmdyZWVuOiBbIDEyNCwgMjUyLCAwIF0sXG4gICAgbGVtb25jaGlmZm9uOiBbIDI1NSwgMjUwLCAyMDUgXSxcbiAgICBsaWdodGJsdWU6IFsgMTczLCAyMTYsIDIzMCBdLFxuICAgIGxpZ2h0Y29yYWw6IFsgMjQwLCAxMjgsIDEyOCBdLFxuICAgIGxpZ2h0Y3lhbjogWyAyMjQsIDI1NSwgMjU1IF0sXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsgMjUwLCAyNTAsIDIxMCBdLFxuICAgIGxpZ2h0Z3JheTogWyAyMTEsIDIxMSwgMjExIF0sXG4gICAgbGlnaHRncmVlbjogWyAxNDQsIDIzOCwgMTQ0IF0sXG4gICAgbGlnaHRncmV5OiBbIDIxMSwgMjExLCAyMTEgXSxcbiAgICBsaWdodHBpbms6IFsgMjU1LCAxODIsIDE5MyBdLFxuICAgIGxpZ2h0c2FsbW9uOiBbIDI1NSwgMTYwLCAxMjIgXSxcbiAgICBsaWdodHNlYWdyZWVuOiBbIDMyLCAxNzgsIDE3MCBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjUwIF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsgMTE5LCAxMzYsIDE1MyBdLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBbIDExOSwgMTM2LCAxNTMgXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWyAxNzYsIDE5NiwgMjIyIF0sXG4gICAgbGlnaHR5ZWxsb3c6IFsgMjU1LCAyNTUsIDIyNCBdLFxuICAgIGxpbWU6IFsgMCwgMjU1LCAwIF0sXG4gICAgbGltZWdyZWVuOiBbIDUwLCAyMDUsIDUwIF0sXG4gICAgbGluZW46IFsgMjUwLCAyNDAsIDIzMCBdLFxuICAgIG1hcm9vbjogWyAxMjgsIDAsIDAgXSxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBbIDEwMiwgMjA1LCAxNzAgXSxcbiAgICBtZWRpdW1ibHVlOiBbIDAsIDAsIDIwNSBdLFxuICAgIG1lZGl1bW9yY2hpZDogWyAxODYsIDg1LCAyMTEgXSxcbiAgICBtZWRpdW1wdXJwbGU6IFsgMTQ3LCAxMTIsIDIxOSBdLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbIDYwLCAxNzksIDExMyBdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWyAxMjMsIDEwNCwgMjM4IF0sXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFsgMCwgMjUwLCAxNTQgXSxcbiAgICBtZWRpdW10dXJxdW9pc2U6IFsgNzIsIDIwOSwgMjA0IF0sXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBbIDE5OSwgMjEsIDEzMyBdLFxuICAgIG1pZG5pZ2h0Ymx1ZTogWyAyNSwgMjUsIDExMiBdLFxuICAgIG1pbnRjcmVhbTogWyAyNDUsIDI1NSwgMjUwIF0sXG4gICAgbWlzdHlyb3NlOiBbIDI1NSwgMjI4LCAyMjUgXSxcbiAgICBtb2NjYXNpbjogWyAyNTUsIDIyOCwgMTgxIF0sXG4gICAgbmF2YWpvd2hpdGU6IFsgMjU1LCAyMjIsIDE3MyBdLFxuICAgIG5hdnk6IFsgMCwgMCwgMTI4IF0sXG4gICAgb2xkbGFjZTogWyAyNTMsIDI0NSwgMjMwIF0sXG4gICAgb2xpdmU6IFsgMTI4LCAxMjgsIDAgXSxcbiAgICBvbGl2ZWRyYWI6IFsgMTA3LCAxNDIsIDM1IF0sXG4gICAgb3JhbmdlOiBbIDI1NSwgMTY1LCAwIF0sXG4gICAgb3JhbmdlcmVkOiBbIDI1NSwgNjksIDAgXSxcbiAgICBvcmNoaWQ6IFsgMjE4LCAxMTIsIDIxNCBdLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFsgMjM4LCAyMzIsIDE3MCBdLFxuICAgIHBhbGVncmVlbjogWyAxNTIsIDI1MSwgMTUyIF0sXG4gICAgcGFsZXR1cnF1b2lzZTogWyAxNzUsIDIzOCwgMjM4IF0sXG4gICAgcGFsZXZpb2xldHJlZDogWyAyMTksIDExMiwgMTQ3IF0sXG4gICAgcGFwYXlhd2hpcDogWyAyNTUsIDIzOSwgMjEzIF0sXG4gICAgcGVhY2hwdWZmOiBbIDI1NSwgMjE4LCAxODUgXSxcbiAgICBwZXJ1OiBbIDIwNSwgMTMzLCA2MyBdLFxuICAgIHBpbms6IFsgMjU1LCAxOTIsIDIwMyBdLFxuICAgIHBsdW06IFsgMjIxLCAxNjAsIDIyMSBdLFxuICAgIHBvd2RlcmJsdWU6IFsgMTc2LCAyMjQsIDIzMCBdLFxuICAgIHB1cnBsZTogWyAxMjgsIDAsIDEyOCBdLFxuICAgIHJlYmVjY2FwdXJwbGU6IFsgMTAyLCA1MSwgMTUzIF0sXG4gICAgcmVkOiBbIDI1NSwgMCwgMCBdLFxuICAgIHJvc3licm93bjogWyAxODgsIDE0MywgMTQzIF0sXG4gICAgcm95YWxibHVlOiBbIDY1LCAxMDUsIDIyNSBdLFxuICAgIHNhZGRsZWJyb3duOiBbIDEzOSwgNjksIDE5IF0sXG4gICAgc2FsbW9uOiBbIDI1MCwgMTI4LCAxMTQgXSxcbiAgICBzYW5keWJyb3duOiBbIDI0NCwgMTY0LCA5NiBdLFxuICAgIHNlYWdyZWVuOiBbIDQ2LCAxMzksIDg3IF0sXG4gICAgc2Vhc2hlbGw6IFsgMjU1LCAyNDUsIDIzOCBdLFxuICAgIHNpZW5uYTogWyAxNjAsIDgyLCA0NSBdLFxuICAgIHNpbHZlcjogWyAxOTIsIDE5MiwgMTI5IF0sXG4gICAgc2t5Ymx1ZTogWyAxMzUsIDIwNiwgMjM1IF0sXG4gICAgc2xhdGVibHVlOiBbIDEwNiwgOTAsIDIwNSBdLFxuICAgIHNsYXRlZ3JheTogWyAxMTIsIDEyOCwgMTQ0IF0sXG4gICAgc2xhdGVncmV5OiBbIDExMiwgMTI4LCAxNDQgXSxcbiAgICBzbm93OiBbIDI1NSwgMjUwLCAyNTAgXSxcbiAgICBzcHJpbmdncmVlbjogWyAwLCAyNTUsIDEyNyBdLFxuICAgIHN0ZWVsYmx1ZTogWyA3MCwgMTMwLCAxODAgXSxcbiAgICB0YW46IFsgMjEwLCAxODAsIDE0MCBdLFxuICAgIHRlYWw6IFsgMCwgMTI4LCAxMjggXSxcbiAgICB0aGlzdGxlOiBbIDIxNiwgMTkxLCAyMTYgXSxcbiAgICB0b21hdG86IFsgMjU1LCA5OSwgNzEgXSxcbiAgICB0dXJxdW9pc2U6IFsgNjQsIDIyNCwgMjA4IF0sXG4gICAgdmlvbGV0OiBbIDIzOCwgMTMwLCAyMzggXSxcbiAgICB3aGVhdDogWyAyNDUsIDIyMiwgMTc5IF0sXG4gICAgd2hpdGU6IFsgMjU1LCAyNTUsIDI1NSBdLFxuICAgIHdoaXRlc21va2U6IFsgMjQ1LCAyNDUsIDI0NSBdLFxuICAgIHllbGxvdzogWyAyNTUsIDI1NSwgMCBdLFxuICAgIHllbGxvd2dyZWVuOiBbIDE1NCwgMjA1LCA1MCBdXG59O1xuXG52YXIgQ1NTVG9Db2xvciA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICB2YXIgZW50cnkgPSBDU1NNYXBbbmFtZV07XG5cbiAgICBpZiAoZW50cnkpXG4gICAge1xuICAgICAgICBjb2xvci5zZXRUbyhlbnRyeVswXSwgZW50cnlbMV0sIGVudHJ5WzJdLCAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTVG9Db2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL0NTU1RvQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9DU1NUb0NvbG9yLmpzIiwidmFyIENvbG9yVG9SR0JBID0gZnVuY3Rpb24gKGNvbG9yKVxue1xuICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgIHI6IGNvbG9yID4+IDE2ICYgMHhGRixcbiAgICAgICAgZzogY29sb3IgPj4gOCAmIDB4RkYsXG4gICAgICAgIGI6IGNvbG9yICYgMHhGRixcbiAgICAgICAgYTogMjU1XG4gICAgfTtcblxuICAgIGlmIChjb2xvciA+IDE2Nzc3MjE1KVxuICAgIHtcbiAgICAgICAgb3V0cHV0LmEgPSBjb2xvciA+Pj4gMjQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3JUb1JHQkE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9Db2xvclRvUkdCQS5qc1xuLy8gbW9kdWxlIGlkID0gNDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb2xvciA9IHJlcXVpcmUoJy4vQ29sb3InKTtcbnZhciBIdWVUb0NvbXBvbmVudCA9IHJlcXVpcmUoJy4vSHVlVG9Db21wb25lbnQnKTtcblxudmFyIEhTTFRvQ29sb3IgPSBmdW5jdGlvbiAoaCwgcywgbClcbntcbiAgICAvLyBhY2hyb21hdGljIGJ5IGRlZmF1bHRcbiAgICB2YXIgciA9IGw7XG4gICAgdmFyIGcgPSBsO1xuICAgIHZhciBiID0gbDtcblxuICAgIGlmIChzICE9PSAwKVxuICAgIHtcbiAgICAgICAgdmFyIHEgPSAobCA8IDAuNSkgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuXG4gICAgICAgIHIgPSBIdWVUb0NvbXBvbmVudChwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgICBnID0gSHVlVG9Db21wb25lbnQocCwgcSwgaCk7XG4gICAgICAgIGIgPSBIdWVUb0NvbXBvbmVudChwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xuXG4gICAgcmV0dXJuIGNvbG9yLnNldEdMVG8ociwgZywgYiwgMSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhTTFRvQ29sb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ncmFwaGljcy9jb2xvci9IU0xUb0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvSFNMVG9Db2xvci5qcyIsInZhciBIU1ZUb1JHQiA9IHJlcXVpcmUoJy4vSFNWVG9SR0InKTtcblxuLyoqXG4qIEdldCBIU1YgY29sb3Igd2hlZWwgdmFsdWVzIGluIGFuIGFycmF5IHdoaWNoIHdpbGwgYmUgMzYwIGVsZW1lbnRzIGluIHNpemUuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkNvbG9yLkhTVkNvbG9yV2hlZWxcbiogQHN0YXRpY1xuKiBAcGFyYW0ge251bWJlcn0gW3M9MV0gLSBUaGUgc2F0dXJhdGlvbiwgaW4gdGhlIHJhbmdlIDAgLSAxLlxuKiBAcGFyYW0ge251bWJlcn0gW3Y9MV0gLSBUaGUgdmFsdWUsIGluIHRoZSByYW5nZSAwIC0gMS5cbiogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgMzYwIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhTViBjb2xvciB3aGVlbC5cbiovXG52YXIgSFNWQ29sb3JXaGVlbCA9IGZ1bmN0aW9uIChzLCB2KVxue1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHsgcyA9IDE7IH1cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7IHYgPSAxOyB9XG5cbiAgICB2YXIgY29sb3JzID0gW107XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8PSAzNTk7IGMrKylcbiAgICB7XG4gICAgICAgIGNvbG9ycy5wdXNoKEhTVlRvUkdCKGMgLyAzNTksIHMsIHYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3JzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIU1ZDb2xvcldoZWVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSFNWQ29sb3JXaGVlbC5qc1xuLy8gbW9kdWxlIGlkID0gNDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dyYXBoaWNzL2NvbG9yL0hTVkNvbG9yV2hlZWwuanMiLCJ2YXIgTGluZWFyID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0xpbmVhckludGVycG9sYXRpb24nKTtcblxudmFyIFJHQldpdGhSR0IgPSBmdW5jdGlvbiAocjEsIGcxLCBiMSwgcjIsIGcyLCBiMiwgbGVuZ3RoLCBpbmRleClcbntcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XG5cbiAgICB2YXIgdCA9IGluZGV4IC8gbGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogTGluZWFyKHIxLCByMiwgdCksXG4gICAgICAgIGc6IExpbmVhcihnMSwgZzIsIHQpLFxuICAgICAgICBiOiBMaW5lYXIoYjEsIGIyLCB0KVxuICAgIH07XG59O1xuXG52YXIgQ29sb3JXaXRoQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIGxlbmd0aCwgaW5kZXgpXG57XG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IDEwMDsgfVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxuXG4gICAgcmV0dXJuIFJHQldpdGhSR0IoY29sb3IxLnIsIGNvbG9yMS5nLCBjb2xvcjEuYiwgY29sb3IyLnIsIGNvbG9yMi5nLCBjb2xvcjIuYiwgbGVuZ3RoLCBpbmRleCk7XG59O1xuXG52YXIgQ29sb3JXaXRoUkdCID0gZnVuY3Rpb24gIChjb2xvciwgciwgZywgYiwgbGVuZ3RoLCBpbmRleClcbntcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsgbGVuZ3RoID0gMTAwOyB9XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XG5cbiAgICByZXR1cm4gUkdCV2l0aFJHQihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCByLCBnLCBiLCBsZW5ndGgsIGluZGV4KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBSR0JXaXRoUkdCOiBSR0JXaXRoUkdCLFxuICAgIENvbG9yV2l0aFJHQjogQ29sb3JXaXRoUkdCLFxuICAgIENvbG9yV2l0aENvbG9yOiBDb2xvcldpdGhDb2xvclxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvSW50ZXJwb2xhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9JbnRlcnBvbGF0ZS5qcyIsIi8qKlxuKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWIChodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlKS5cbiogQ29udmVyc2lvbiBmb3J1bWxhIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG4qIEFzc3VtZXMgUkdCIHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gYW5kIHJldHVybnMgaCwgcyBhbmQgdiBpbiB0aGUgc2V0IFswLCAxXS5cbiogQmFzZWQgb24gY29kZSBieSBNaWNoYWVsIEphY2tzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uKVxuKlxuKiBAbWV0aG9kIExhemVyLkNvbG9yLlJHQnRvSFNWXG4qIEBzdGF0aWNcbiogQHBhcmFtIHtudW1iZXJ9IHIgLSBUaGUgcmVkIGNvbG9yIGNvbXBvbmVudCwgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXG4qIEBwYXJhbSB7bnVtYmVyfSBnIC0gVGhlIGdyZWVuIGNvbG9yIGNvbXBvbmVudCwgaW4gdGhlIHJhbmdlIDAgLSAyNTUuXG4qIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIGJsdWUgY29sb3IgY29tcG9uZW50LCBpbiB0aGUgcmFuZ2UgMCAtIDI1NS5cbiogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgaHVlLCBzYXR1cmF0aW9uIGFuZCB2YWx1ZSBzZXQgaW4gdGhlIGgsIHMgYW5kIHYgcHJvcGVydGllcy5cbiovXG52YXIgUkdCVG9IU1YgPSBmdW5jdGlvbiAociwgZywgYilcbntcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcblxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG5cbiAgICAvLyBhY2hyb21hdGljIGJ5IGRlZmF1bHRcbiAgICB2YXIgaCA9IDA7XG4gICAgdmFyIHMgPSAobWF4ID09PSAwKSA/IDAgOiBkIC8gbWF4O1xuICAgIHZhciB2ID0gbWF4O1xuXG4gICAgaWYgKG1heCAhPT0gbWluKVxuICAgIHtcbiAgICAgICAgaWYgKG1heCA9PT0gcilcbiAgICAgICAge1xuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKChnIDwgYikgPyA2IDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF4ID09PSBnKVxuICAgICAgICB7XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1heCA9PT0gYilcbiAgICAgICAge1xuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJHQlRvSFNWO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvUkdCVG9IU1YuanNcbi8vIG1vZHVsZSBpZCA9IDQ3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ29tcG9uZW50VG9IZXggPSByZXF1aXJlKCcuL0NvbXBvbmVudFRvSGV4Jyk7XG5cbnZhciBSR0JUb1N0cmluZyA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBwcmVmaXgpXG57XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gMjU1OyB9XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7IHByZWZpeCA9ICcjJzsgfVxuXG4gICAgaWYgKHByZWZpeCA9PT0gJyMnKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICcjJyArICgoMSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGIpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBDb21wb25lbnRUb0hleChhKSArIENvbXBvbmVudFRvSGV4KHIpICsgQ29tcG9uZW50VG9IZXgoZykgKyBDb21wb25lbnRUb0hleChiKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJHQlRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvUkdCVG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDQ3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9ncmFwaGljcy9jb2xvci9SR0JUb1N0cmluZy5qcyIsInZhciBCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9CZXR3ZWVuJyk7XG5cbnZhciBSYW5kb21SR0IgPSBmdW5jdGlvbiAobWluLCBtYXgpXG57XG4gICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7IG1pbiA9IDA7IH1cbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHsgbWF4ID0gMjU1OyB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByOiBCZXR3ZWVuKG1pbiwgbWF4KSxcbiAgICAgICAgZzogQmV0d2VlbihtaW4sIG1heCksXG4gICAgICAgIGI6IEJldHdlZW4obWluLCBtYXgpXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tUkdCO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ3JhcGhpY3MvY29sb3IvUmFuZG9tUkdCLmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvUmFuZG9tUkdCLmpzIiwiLy8gIFBoYXNlci5HcmFwaGljcy5Db2xvclxuXG52YXIgQ29sb3IgPSByZXF1aXJlKCcuL0NvbG9yJyk7XG5cbkNvbG9yLkNvbG9yVG9SR0JBID0gcmVxdWlyZSgnLi9Db2xvclRvUkdCQScpO1xuQ29sb3IuQ29tcG9uZW50VG9IZXggPSByZXF1aXJlKCcuL0NvbXBvbmVudFRvSGV4Jyk7XG5Db2xvci5DU1NUb0NvbG9yID0gcmVxdWlyZSgnLi9DU1NUb0NvbG9yJyk7XG5Db2xvci5HZXRDb2xvciA9IHJlcXVpcmUoJy4vR2V0Q29sb3InKTtcbkNvbG9yLkdldENvbG9yMzIgPSByZXF1aXJlKCcuL0dldENvbG9yMzInKTtcbkNvbG9yLkhleFN0cmluZ1RvQ29sb3IgPSByZXF1aXJlKCcuL0hleFN0cmluZ1RvQ29sb3InKTtcbkNvbG9yLkhTTFRvQ29sb3IgPSByZXF1aXJlKCcuL0hTTFRvQ29sb3InKTtcbkNvbG9yLkhTVkNvbG9yV2hlZWwgPSByZXF1aXJlKCcuL0hTVkNvbG9yV2hlZWwnKTtcbkNvbG9yLkhTVlRvUkdCID0gcmVxdWlyZSgnLi9IU1ZUb1JHQicpO1xuQ29sb3IuSHVlVG9Db21wb25lbnQgPSByZXF1aXJlKCcuL0h1ZVRvQ29tcG9uZW50Jyk7XG5Db2xvci5JbnRlZ2VyVG9Db2xvciA9IHJlcXVpcmUoJy4vSW50ZWdlclRvQ29sb3InKTtcbkNvbG9yLkludGVnZXJUb1JHQiA9IHJlcXVpcmUoJy4vSW50ZWdlclRvUkdCJyk7XG5Db2xvci5JbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vSW50ZXJwb2xhdGUnKTtcbkNvbG9yLlJhbmRvbVJHQiA9IHJlcXVpcmUoJy4vUmFuZG9tUkdCJyk7XG5Db2xvci5SR0JTdHJpbmdUb0NvbG9yID0gcmVxdWlyZSgnLi9SR0JTdHJpbmdUb0NvbG9yJyk7XG5Db2xvci5SR0JUb0hTViA9IHJlcXVpcmUoJy4vUkdCVG9IU1YnKTtcbkNvbG9yLlJHQlRvU3RyaW5nID0gcmVxdWlyZSgnLi9SR0JUb1N0cmluZycpO1xuQ29sb3IuVmFsdWVUb0NvbG9yID0gcmVxdWlyZSgnLi9WYWx1ZVRvQ29sb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2dyYXBoaWNzL2NvbG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ3JhcGhpY3MvY29sb3IvaW5kZXguanMiLCIvLyAgR2xvYmFsSW5wdXRNYW5hZ2VyXG5cbnZhciBLZXlib2FyZCA9IHJlcXVpcmUoJy4va2V5Ym9hcmQvS2V5Ym9hcmRNYW5hZ2VyJyk7XG5cbnZhciBHbG9iYWxJbnB1dE1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSwgZ2FtZUNvbmZpZylcbntcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgdGhpcy5nYW1lQ29uZmlnID0gZ2FtZUNvbmZpZztcblxuICAgIHRoaXMua2V5Ym9hcmQgPSBuZXcgS2V5Ym9hcmQodGhpcyk7XG59O1xuXG5HbG9iYWxJbnB1dE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2xvYmFsSW5wdXRNYW5hZ2VyO1xuXG5HbG9iYWxJbnB1dE1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgKiBUaGUgQm9vdCBoYW5kbGVyIGlzIGNhbGxlZCBieSBQaGFzZXIuR2FtZSB3aGVuIGl0IGZpcnN0IHN0YXJ0cyB1cC5cbiAgICAqIFRoZSByZW5kZXJlciBpcyBhdmFpbGFibGUgYnkgbm93LlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLklucHV0LktleWJvYXJkTWFuYWdlciNib290XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgYm9vdDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMua2V5Ym9hcmQuYm9vdCgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmtleWJvYXJkLnVwZGF0ZSgpO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbG9iYWxJbnB1dE1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9HbG9iYWxJbnB1dE1hbmFnZXIuanMiLCIvLyAgUmV0dXJuIGJvb2xlYW4gKHRydWUgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBjb21ibywgZmFsc2UgaWYgbm90KVxuXG52YXIgQWR2YW5jZUtleUNvbWJvID0gZnVuY3Rpb24gKGV2ZW50LCBjb21ibylcbntcbiAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgY29tYm8uaW5kZXgrKztcblxuICAgIGlmIChjb21iby5pbmRleCA9PT0gY29tYm8uc2l6ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBjb21iby5jdXJyZW50ID0gY29tYm8ua2V5Q29kZXNbY29tYm8uaW5kZXhdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZHZhbmNlS2V5Q29tYm87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9jb21iby9BZHZhbmNlS2V5Q29tYm8uanNcbi8vIG1vZHVsZSBpZCA9IDQ4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcblxudmFyIEtleUNvbWJvTWF0Y2hFdmVudCA9IGZ1bmN0aW9uIChrZXlDb21ibywga2V5Ym9hcmRFdmVudClcbntcbiAgICBFdmVudC5jYWxsKHRoaXMsICdLRVlfQ09NQk9fTUFUQ0hfRVZFTlQnKTtcblxuICAgIHRoaXMudGFyZ2V0ID0ga2V5Q29tYm87XG5cbiAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xufTtcblxuS2V5Q29tYm9NYXRjaEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcbktleUNvbWJvTWF0Y2hFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlDb21ib01hdGNoRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Q29tYm9NYXRjaEV2ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm9NYXRjaEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvY29tYm8vS2V5Q29tYm9NYXRjaEV2ZW50LmpzIiwidmFyIFJlc2V0S2V5Q29tYm8gPSBmdW5jdGlvbiAoY29tYm8pXG57XG4gICAgY29tYm8uY3VycmVudCA9IGNvbWJvLmtleUNvZGVzWzBdO1xuICAgIGNvbWJvLmluZGV4ID0gMDtcbiAgICBjb21iby50aW1lTGFzdE1hdGNoZWQgPSAwO1xuICAgIGNvbWJvLm1hdGNoZWQgPSBmYWxzZTtcbiAgICBjb21iby50aW1lTWF0Y2hlZCA9IDA7XG5cbiAgICByZXR1cm4gY29tYm87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2V0S2V5Q29tYm87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9jb21iby9SZXNldEtleUNvbWJvLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XG5cbnZhciBLZXlEb3duRXZlbnQgPSBmdW5jdGlvbiAoa2V5Ym9hcmRFdmVudClcbntcbiAgICBFdmVudC5jYWxsKHRoaXMsICdLRVlfRE9XTl9FVkVOVCcpO1xuXG4gICAgdGhpcy5kYXRhID0ga2V5Ym9hcmRFdmVudDtcbn07XG5cbktleURvd25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG5LZXlEb3duRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5RG93bkV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleURvd25FdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlEb3duRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbnB1dC9rZXlib2FyZC9ldmVudHMvS2V5RG93bkV2ZW50LmpzIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXZlbnRzL0V2ZW50Jyk7XG5cbnZhciBLZXlVcEV2ZW50ID0gZnVuY3Rpb24gKGtleWJvYXJkRXZlbnQpXG57XG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnS0VZX1VQX0VWRU5UJyk7XG5cbiAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xufTtcblxuS2V5VXBFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG5LZXlVcEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleVVwRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5VXBFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2V2ZW50cy9LZXlVcEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL0tleVVwRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9ldmVudHMvRXZlbnQnKTtcbnZhciBLZXlDb2RlcyA9IHJlcXVpcmUoJy4vLi4va2V5cy9LZXlDb2RlcycpO1xuXG52YXIgZXZlbnRzID0ge1xuICAgIEtFWV9ET1dOX0VWRU5UOiByZXF1aXJlKCcuL0tleURvd25FdmVudCcpLFxuICAgIEtFWV9VUF9FVkVOVDogcmVxdWlyZSgnLi9LZXlVcEV2ZW50JyksXG4gICAgX1VQOiBbXSxcbiAgICBfRE9XTjogW11cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleUV2ZW50ICh0eXBlKVxue1xuICAgIHZhciBLZXlFdmVudCA9IGZ1bmN0aW9uIChrZXlib2FyZEV2ZW50KVxuICAgIHtcbiAgICAgICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgICAgICB0aGlzLmRhdGEgPSBrZXlib2FyZEV2ZW50O1xuICAgIH07XG5cbiAgICBLZXlFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSk7XG4gICAgS2V5RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5RXZlbnQ7XG5cbiAgICByZXR1cm4gS2V5RXZlbnQ7XG59XG5cbi8vICBJbmplY3QgdGhlIEtleUNvZGUgZXZlbnRzXG5cbmZvciAodmFyIGNvZGUgaW4gS2V5Q29kZXMpXG57XG4gICAgLy8gIFRoZSBLZXkgRG93biBFdmVudCBUeXBlc1xuXG4gICAgdmFyIGRvd25UeXBlID0gJ0tFWV9ET1dOXycgKyBjb2RlO1xuICAgIHZhciB1cFR5cGUgPSAnS0VZX1VQXycgKyBjb2RlO1xuXG4gICAgZXZlbnRzLl9ET1dOW0tleUNvZGVzW2NvZGVdXSA9IGNyZWF0ZUtleUV2ZW50KGRvd25UeXBlKTtcbiAgICBldmVudHMuX1VQW0tleUNvZGVzW2NvZGVdXSA9IGNyZWF0ZUtleUV2ZW50KHVwVHlwZSk7XG5cbiAgICAvLyAgTW9yZSBmcmllbmRseSBhbGlhc2VzIHRvIHRoZSBtYWluIGV2ZW50c1xuICAgIGV2ZW50c1tkb3duVHlwZV0gPSBldmVudHMuX0RPV05bS2V5Q29kZXNbY29kZV1dO1xuICAgIGV2ZW50c1t1cFR5cGVdID0gZXZlbnRzLl9VUFtLZXlDb2Rlc1tjb2RlXV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQvZXZlbnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvZXZlbnRzL2luZGV4LmpzIiwiLy8gIFBoYXNlci5JbnB1dC5LZXlib2FyZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEtleWJvYXJkTWFuYWdlcjogcmVxdWlyZSgnLi9LZXlib2FyZE1hbmFnZXInKSxcblxuICAgIEtleTogcmVxdWlyZSgnLi9rZXlzL0tleScpLFxuICAgIEtleUNvZGVzOiByZXF1aXJlKCcuL2tleXMvS2V5Q29kZXMnKSxcblxuICAgIEtleUNvbWJvOiByZXF1aXJlKCcuL2NvbWJvL0tleUNvbWJvJyksXG5cbiAgICBKdXN0RG93bjogcmVxdWlyZSgnLi9rZXlzL0p1c3REb3duJyksXG4gICAgSnVzdFVwOiByZXF1aXJlKCcuL2tleXMvSnVzdFVwJyksXG4gICAgRG93bkR1cmF0aW9uOiByZXF1aXJlKCcuL2tleXMvRG93bkR1cmF0aW9uJyksXG4gICAgVXBEdXJhdGlvbjogcmVxdWlyZSgnLi9rZXlzL1VwRHVyYXRpb24nKVxuICAgIFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5wdXQva2V5Ym9hcmQvaW5kZXguanMiLCIvKipcbiogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIEtleSB3YXMgcHJlc3NlZCBkb3duIHdpdGhpbiB0aGUgYGR1cmF0aW9uYCB2YWx1ZSBnaXZlbiwgb3IgYGZhbHNlYCBpZiBpdCBlaXRoZXIgaXNuJ3QgZG93bixcbiogb3Igd2FzIHByZXNzZWQgZG93biBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cbiogXG4qIEBtZXRob2QgUGhhc2VyLktleSNkb3duRHVyYXRpb25cbiogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj01MF0gLSBUaGUgZHVyYXRpb24gd2l0aGluIHdoaWNoIHRoZSBrZXkgaXMgY29uc2lkZXJlZCBhcyBiZWluZyBqdXN0IHByZXNzZWQuIEdpdmVuIGluIG1zLlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBrZXkgd2FzIHByZXNzZWQgZG93biB3aXRoaW4gdGhlIGdpdmVuIGR1cmF0aW9uLlxuKi9cbnZhciBEb3duRHVyYXRpb24gPSBmdW5jdGlvbiAoa2V5LCBkdXJhdGlvbilcbntcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgeyBkdXJhdGlvbiA9IDUwOyB9XG5cbiAgICByZXR1cm4gKGtleS5pc0Rvd24gJiYga2V5LmR1cmF0aW9uIDwgZHVyYXRpb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb3duRHVyYXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL0Rvd25EdXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUaGUganVzdERvd24gdmFsdWUgYWxsb3dzIHlvdSB0byB0ZXN0IGlmIHRoaXMgS2V5IGhhcyBqdXN0IGJlZW4gcHJlc3NlZCBkb3duIG9yIG5vdC5cbiogV2hlbiB5b3UgY2hlY2sgdGhpcyB2YWx1ZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIEtleSBpcyBkb3duLCBvdGhlcndpc2UgYGZhbHNlYC5cbiogWW91IGNhbiBvbmx5IGNhbGwganVzdERvd24gb25jZSBwZXIga2V5IHByZXNzLiBJdCB3aWxsIG9ubHkgcmV0dXJuIGB0cnVlYCBvbmNlLCB1bnRpbCB0aGUgS2V5IGlzIHJlbGVhc2VkIGFuZCBwcmVzc2VkIGRvd24gYWdhaW4uXG4qIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3Ugd2FudCB0byBjaGVjayBpZiB0aGlzIGtleSBpcyBkb3duIHdpdGhvdXQgdXNpbmcgYSBTaWduYWwsIHN1Y2ggYXMgaW4gYSBjb3JlIGdhbWUgbG9vcC5cbiogXG4qIEBwcm9wZXJ0eSB7Ym9vbGVhbn0ganVzdERvd25cbiogQG1lbWJlcm9mIFBoYXNlci5LZXlcbiogQGRlZmF1bHQgZmFsc2VcbiovXG5cbnZhciBKdXN0RG93biA9IGZ1bmN0aW9uIChrZXkpXG57XG4gICAgdmFyIGN1cnJlbnQgPSBmYWxzZTtcblxuICAgIGlmIChrZXkuaXNEb3duKVxuICAgIHtcbiAgICAgICAgY3VycmVudCA9IGtleS5fanVzdERvd247XG4gICAgICAgIGtleS5fanVzdERvd24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnVzdERvd247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3REb3duLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRoZSBqdXN0VXAgdmFsdWUgYWxsb3dzIHlvdSB0byB0ZXN0IGlmIHRoaXMgS2V5IGhhcyBqdXN0IGJlZW4gcmVsZWFzZWQgb3Igbm90LlxuKiBXaGVuIHlvdSBjaGVjayB0aGlzIHZhbHVlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgS2V5IGlzIHVwLCBvdGhlcndpc2UgYGZhbHNlYC5cbiogWW91IGNhbiBvbmx5IGNhbGwganVzdFVwIG9uY2UgcGVyIGtleSByZWxlYXNlLiBJdCB3aWxsIG9ubHkgcmV0dXJuIGB0cnVlYCBvbmNlLCB1bnRpbCB0aGUgS2V5IGlzIHByZXNzZWQgZG93biBhbmQgcmVsZWFzZWQgYWdhaW4uXG4qIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3Ugd2FudCB0byBjaGVjayBpZiB0aGlzIGtleSBpcyB1cCB3aXRob3V0IHVzaW5nIGEgU2lnbmFsLCBzdWNoIGFzIGluIGEgY29yZSBnYW1lIGxvb3AuXG4qIFxuKiBAcHJvcGVydHkge2Jvb2xlYW59IGp1c3RVcFxuKiBAbWVtYmVyb2YgUGhhc2VyLktleVxuKiBAZGVmYXVsdCBmYWxzZVxuKi9cblxudmFyIEp1c3RVcCA9IGZ1bmN0aW9uIChrZXkpXG57XG4gICAgdmFyIGN1cnJlbnQgPSBmYWxzZTtcblxuICAgIGlmIChrZXkuaXNEb3duKVxuICAgIHtcbiAgICAgICAgY3VycmVudCA9IGtleS5fanVzdFVwO1xuICAgICAgICBrZXkuX2p1c3RVcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKdXN0VXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL0p1c3RVcC5qc1xuLy8gbW9kdWxlIGlkID0gNDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIFByb2Nlc3NLZXlEb3duID0gZnVuY3Rpb24gKGtleSwgZXZlbnQpXG57XG4gICAga2V5Lm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmIChrZXkucHJldmVudERlZmF1bHQpXG4gICAge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICgha2V5LmVuYWJsZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAga2V5LmFsdEtleSA9IGV2ZW50LmFsdEtleTtcbiAgICBrZXkuY3RybEtleSA9IGV2ZW50LmN0cmxLZXk7XG4gICAga2V5LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAga2V5LmxvY2F0aW9uID0gZXZlbnQubG9jYXRpb247XG5cbiAgICBrZXkuaXNEb3duID0gdHJ1ZTtcbiAgICBrZXkuaXNVcCA9IGZhbHNlO1xuICAgIGtleS50aW1lRG93biA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICBrZXkuZHVyYXRpb24gPSAwO1xuICAgIGtleS5yZXBlYXRzKys7XG5cbiAgICBrZXkuX2p1c3REb3duID0gdHJ1ZTtcbiAgICBrZXkuX2p1c3RVcCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGtleTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc0tleURvd247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbnB1dC9rZXlib2FyZC9rZXlzL1Byb2Nlc3NLZXlEb3duLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgUHJvY2Vzc0tleVVwID0gZnVuY3Rpb24gKGtleSwgZXZlbnQpXG57XG4gICAga2V5Lm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgIGlmIChrZXkucHJldmVudERlZmF1bHQpXG4gICAge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICgha2V5LmVuYWJsZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAga2V5LmlzRG93biA9IGZhbHNlO1xuICAgIGtleS5pc1VwID0gdHJ1ZTtcbiAgICBrZXkudGltZVVwID0gZXZlbnQudGltZVN0YW1wO1xuICAgIGtleS5kdXJhdGlvbiA9IGtleS50aW1lVXAgLSBrZXkudGltZURvd247XG4gICAga2V5LnJlcGVhdHMgPSAwO1xuXG4gICAga2V5Ll9qdXN0RG93biA9IGZhbHNlO1xuICAgIGtleS5fanVzdFVwID0gdHJ1ZTtcblxuICAgIHJldHVybiBrZXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NLZXlVcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2lucHV0L2tleWJvYXJkL2tleXMvUHJvY2Vzc0tleVVwLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFJldHVybnMgYHRydWVgIGlmIHRoZSBLZXkgd2FzIHJlbGVhc2VkIHdpdGhpbiB0aGUgYGR1cmF0aW9uYCB2YWx1ZSBnaXZlbiwgb3IgYGZhbHNlYCBpZiBpdCBlaXRoZXIgaXNuJ3QgdXAsXG4qIG9yIHdhcyByZWxlYXNlZCBsb25nZXIgYWdvIHRoYW4gdGhlbiBnaXZlbiBkdXJhdGlvbi5cbiogXG4qIEBtZXRob2QgUGhhc2VyLktleSN1cER1cmF0aW9uXG4qIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249NTBdIC0gVGhlIGR1cmF0aW9uIHdpdGhpbiB3aGljaCB0aGUga2V5IGlzIGNvbnNpZGVyZWQgYXMgYmVpbmcganVzdCByZWxlYXNlZC4gR2l2ZW4gaW4gbXMuXG4qIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGtleSB3YXMgcmVsZWFzZWQgd2l0aGluIHRoZSBnaXZlbiBkdXJhdGlvbi5cbiovXG52YXIgVXBEdXJhdGlvbiA9IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxue1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7IGR1cmF0aW9uID0gNTA7IH1cblxuICAgIHJldHVybiAoa2V5LmlzVXAgJiYga2V5LmR1cmF0aW9uIDwgZHVyYXRpb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVcER1cmF0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vaW5wdXQva2V5Ym9hcmQva2V5cy9VcER1cmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vc3RydWN0cy9TZXQnKTtcbnZhciBYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vWEhSU2V0dGluZ3MnKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnRzLycpO1xudmFyIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudERpc3BhdGNoZXInKTtcblxudmFyIEJhc2VMb2FkZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vICBUbyBmaW5pc2ggdGhlIGxvYWRlciAuLi5cbiAgICAvLyAgXG4gICAgLy8gIDMpIFByb2dyZXNzIHVwZGF0ZVxuXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICAvLyAgTW92ZSB0byBhICdzZXRVUkwnIG1ldGhvZD9cbiAgICB0aGlzLmJhc2VVUkwgPSAnJztcbiAgICB0aGlzLnBhdGggPSAnJztcblxuICAgIC8vICBSZWFkIGZyb20gR2FtZSAvIFN0YXRlIENvbmZpZ1xuICAgIHRoaXMuZW5hYmxlUGFyYWxsZWwgPSB0cnVlO1xuICAgIHRoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMgPSA0O1xuXG4gICAgLy8gIHhociBzcGVjaWZpYyBnbG9iYWwgc2V0dGluZ3MgKGNhbiBiZSBvdmVycmlkZGVuIG9uIGEgcGVyLWZpbGUgYmFzaXMpXG4gICAgdGhpcy54aHIgPSBYSFJTZXR0aW5ncygpO1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMubGlzdCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmluZmxpZ2h0ID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZmFpbGVkID0gbmV3IFNldCgpO1xuICAgIHRoaXMucXVldWUgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfSURMRTtcbn07XG5cbkJhc2VMb2FkZXIucHJvdG90eXBlLmNvbnRydWN0b3IgPSBCYXNlTG9hZGVyO1xuXG5CYXNlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsZS5wYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICAgIHRoaXMubGlzdC5zZXQoZmlsZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICBJcyB0aGUgTG9hZGVyIGFjdGl2ZWx5IGxvYWRpbmcgKG9yIHByb2Nlc3NpbmcgbG9hZGVkIGZpbGVzKVxuICAgIGlzTG9hZGluZzogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9MT0FESU5HIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfUFJPQ0VTU0lORyk7XG4gICAgfSxcblxuICAgIC8vICBJcyB0aGUgTG9hZGVyIHJlYWR5IHRvIHN0YXJ0IGEgbmV3IGxvYWQ/XG4gICAgaXNSZWFkeTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9JRExFIHx8IHRoaXMuX3N0YXRlID09PSBDT05TVC5MT0FERVJfQ09NUExFVEUgfHwgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9GQUlMRUQpO1xuICAgIH0sXG5cbiAgICBzdGFydDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc3RhdGUuc2V0dGluZ3Mua2V5LCAnLSBCYXNlTG9hZGVyIHN0YXJ0LiBGaWxlcyB0byBsb2FkOicsIHRoaXMubGlzdC5zaXplKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNSZWFkeSgpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChuZXcgRXZlbnQuTE9BREVSX1NUQVJUX0VWRU5UKHRoaXMpKTtcblxuICAgICAgICBpZiAodGhpcy5saXN0LnNpemUgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9MT0FESU5HO1xuXG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmRlYnVnID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcygpO1xuXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVQcm9ncmVzczogZnVuY3Rpb24gKClcbiAgICB7XG5cbiAgICB9LFxuXG4gICAgcHJvY2Vzc0xvYWRRdWV1ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT09PT09PSBCYXNlTG9hZGVyIHByb2Nlc3NMb2FkUXVldWUnKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xpc3Qgc2l6ZScsIHRoaXMubGlzdC5zaXplKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pbmZsaWdodC5zaXplLCAnaXRlbXMgc3RpbGwgaW4gZmxpZ2h0LiBDYW4gbG9hZCBhbm90aGVyJywgKHRoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMgLSB0aGlzLmluZmxpZ2h0LnNpemUpKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubGlzdC5lYWNoKGZ1bmN0aW9uIChmaWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9QRU5ESU5HICYmIF90aGlzLmluZmxpZ2h0LnNpemUgPCBfdGhpcy5tYXhQYXJhbGxlbERvd25sb2FkcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmZsaWdodC5zZXQoZmlsZSk7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0LmRlbGV0ZShmaWxlKTtcblxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5mbGlnaHQuc2l6ZSA9PT0gX3RoaXMubWF4UGFyYWxsZWxEb3dubG9hZHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gIFRlbGxzIHRoZSBTZXQgaXRlcmF0b3IgdG8gYWJvcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vICBwcml2YXRlXG4gICAgbG9hZEZpbGU6IGZ1bmN0aW9uIChmaWxlKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPQURJTkcnLCBmaWxlLmtleSk7XG5cbiAgICAgICAgLy8gIElmIHRoZSBmaWxlIGRvZXNuJ3QgaGF2ZSBpdHMgb3duIGNyb3NzT3JpZ2luIHNldCxcbiAgICAgICAgLy8gIHdlJ2xsIHVzZSB0aGUgTG9hZGVycyAod2hpY2ggaXMgdW5kZWZpbmVkIGJ5IGRlZmF1bHQpXG4gICAgICAgIGlmICghZmlsZS5jcm9zc09yaWdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgICAgIH1cblxuICAgICAgICBmaWxlLmxvYWQodGhpcy5uZXh0RmlsZS5iaW5kKHRoaXMpLCB0aGlzLmJhc2VVUkwpO1xuICAgIH0sXG5cbiAgICBuZXh0RmlsZTogZnVuY3Rpb24gKHByZXZpb3VzRmlsZSwgc3VjY2VzcylcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0FERUQ6JywgcHJldmlvdXNGaWxlLnNyYywgc3VjY2Vzcyk7XG5cbiAgICAgICAgLy8gIE1vdmUgdGhlIGZpbGUgdGhhdCBqdXN0IGxvYWRlZCBmcm9tIHRoZSBpbmZsaWdodCBsaXN0IHRvIHRoZSBxdWV1ZSBvciBmYWlsZWQgU2V0XG5cbiAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUuc2V0KHByZXZpb3VzRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5zZXQocHJldmlvdXNGaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5mbGlnaHQuZGVsZXRlKHByZXZpb3VzRmlsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25leHRGaWxlIC0gc3RpbGwgc29tZXRoaW5nIGluIHRoZSBsaXN0Jyk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NMb2FkUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZmxpZ2h0LnNpemUgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXh0RmlsZSBjYWxsaW5nIGZpbmlzaGVkTG9hZGluZycpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2hlZExvYWRpbmc6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBCYXNlTG9hZGVyLmZpbmlzaGVkTG9hZGluZyBQUk9DRVNTSU5HJywgdGhpcy5xdWV1ZS5zaXplLCAnZmlsZXMnKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9QUk9DRVNTSU5HO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5xdWV1ZS5lYWNoKGZ1bmN0aW9uIChmaWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgQ2FsbGluZyBwcm9jZXNzIG9uICcgKyBmaWxlLmtleSwgJ2NvbG9yOiAjMDAwMDAwOyBiYWNrZ3JvdW5kOiAjZmZmZjAwOycpO1xuXG4gICAgICAgICAgICBmaWxlLm9uUHJvY2VzcyhfdGhpcy5wcm9jZXNzVXBkYXRlLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vICBDYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgRmlsZSB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nXG4gICAgcHJvY2Vzc1VwZGF0ZTogZnVuY3Rpb24gKGZpbGUpXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLT4gcHJvY2Vzc1VwZGF0ZScsIGZpbGUua2V5LCBmaWxlLnN0YXRlKTtcblxuICAgICAgICAvLyAgVGhpcyBmaWxlIGhhcyBmYWlsZWQgdG8gbG9hZCwgc28gbW92ZSBpdCB0byB0aGUgZmFpbGVkIFNldFxuICAgICAgICBpZiAoZmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9FUlJPUkVEKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZC5zZXQoZmlsZSk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlLmxpbmtGaWxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUubGlua0ZpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgSWYgd2UgZ290IGhlcmUsIHRoZW4gdGhlIGZpbGUgbG9hZGVkXG5cbiAgICAgICAgLy8gIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG11bHRpLXBhcnQgZmlsZXNcblxuICAgICAgICBpZiAoZmlsZS5saW5rRmlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZpbGUuc3RhdGUgPT09IENPTlNULkZJTEVfQ09NUExFVEUgJiYgZmlsZS5saW5rRmlsZS5zdGF0ZSA9PT0gQ09OU1QuRklMRV9DT01QTEVURSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgUGFydG5lciBoYXMgbG9hZGVkLCBzbyBhZGQgdGhlbSBib3RoIHRvIFN0b3JhZ2VcblxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoeyB0eXBlOiBmaWxlLmxpbmtUeXBlLCBmaWxlQTogZmlsZSwgZmlsZUI6IGZpbGUubGlua0ZpbGUgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRlbGV0ZShmaWxlLmxpbmtGaWxlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChmaWxlKTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUXVldWUoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlRnJvbVF1ZXVlOiBmdW5jdGlvbiAoZmlsZSlcbiAgICB7XG4gICAgICAgIHRoaXMucXVldWUuZGVsZXRlKGZpbGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLnNpemUgPT09IDAgJiYgdGhpcy5fc3RhdGUgPT09IENPTlNULkxPQURFUl9QUk9DRVNTSU5HKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgV2UndmUgcHJvY2Vzc2VkIGFsbCB0aGUgZmlsZXMgd2UgbG9hZGVkXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NDb21wbGV0ZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc3RhdGUuc2V0dGluZ3Mua2V5LCAnLSBMb2FkZXIgQ29tcGxldGUuIExvYWRlZDonLCB0aGlzLnN0b3JhZ2Uuc2l6ZSwgJ0ZhaWxlZDonLCB0aGlzLmZhaWxlZC5zaXplKTtcblxuICAgICAgICB0aGlzLmxpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbmZsaWdodC5jbGVhcigpO1xuICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0NhbGxiYWNrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDT05TVC5MT0FERVJfQ09NUExFVEU7XG5cbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2gobmV3IEV2ZW50LkxPQURFUl9DT01QTEVURV9FVkVOVCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW5mbGlnaHQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5mYWlsZWQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGwoJ0xPQURFUl9TVEFSVF9FVkVOVCcpO1xuICAgICAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGwoJ0xPQURFUl9DT01QTEVURV9FVkVOVCcpO1xuXG4gICAgICAgIHRoaXMudGFnID0gJyc7XG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSAnJztcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9JRExFO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IENPTlNULkxPQURFUl9ERVNUUk9ZRUQ7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvQmFzZUxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9CYXNlTG9hZGVyLmpzIiwidmFyIEdldFVSTCA9IGZ1bmN0aW9uIChmaWxlLCBiYXNlVVJMKVxue1xuICAgIGlmICghZmlsZS51cmwpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZpbGUudXJsLm1hdGNoKC9eKD86YmxvYjp8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfFxcL1xcLykvKSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmaWxlLnVybDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGJhc2VVUkwgKyBmaWxlLnVybDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFVSTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9HZXRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWVyZ2VYSFJTZXR0aW5ncyA9IHJlcXVpcmUoJy4vTWVyZ2VYSFJTZXR0aW5ncycpO1xuXG52YXIgWEhSTG9hZGVyID0gZnVuY3Rpb24gKGZpbGUsIGdsb2JhbFhIUlNldHRpbmdzKVxue1xuICAgIHZhciBjb25maWcgPSBNZXJnZVhIUlNldHRpbmdzKGdsb2JhbFhIUlNldHRpbmdzLCBmaWxlLnhoclNldHRpbmdzKTtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLnNyYywgY29uZmlnLmFzeW5jLCBjb25maWcudXNlciwgY29uZmlnLnBhc3N3b3JkKTtcblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmaWxlLnhoclNldHRpbmdzLnJlc3BvbnNlVHlwZTtcbiAgICB4aHIudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgaWYgKGNvbmZpZy5oZWFkZXIgJiYgY29uZmlnLmhlYWRlclZhbHVlKVxuICAgIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoY29uZmlnLmhlYWRlciwgY29uZmlnLmhlYWRlclZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpXG4gICAge1xuICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShjb25maWcub3ZlcnJpZGVNaW1lVHlwZSk7XG4gICAgfVxuXG4gICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlcXVlc3QsIHRoZSB4aHIucmVzcG9uc2UgcHJvcGVydHkgd2lsbCBjb250YWluIHRoZSByZXF1ZXN0ZWQgZGF0YSBhcyBhIERPTVN0cmluZywgQXJyYXlCdWZmZXIsIEJsb2IsIG9yIERvY3VtZW50IChkZXBlbmRpbmcgb24gd2hhdCB3YXMgc2V0IGZvciByZXNwb25zZVR5cGUuKVxuXG4gICAgeGhyLm9ubG9hZCA9IGZpbGUub25Mb2FkLmJpbmQoZmlsZSk7XG4gICAgeGhyLm9uZXJyb3IgPSBmaWxlLm9uRXJyb3IuYmluZChmaWxlKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IGZpbGUub25Qcm9ncmVzcy5iaW5kKGZpbGUpO1xuXG4gICAgLy8gIFRoaXMgaXMgdGhlIG9ubHkgc3RhbmRhcmQgbWV0aG9kLCB0aGUgb25lcyBhYm92ZSBhcmUgYnJvd3NlciBhZGRpdGlvbnMgKG1heWJlIG5vdCB1bml2ZXJzYWw/KVxuICAgIC8vIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcblxuICAgIHhoci5zZW5kKCk7XG5cbiAgICByZXR1cm4geGhyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvWEhSTG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL1hIUkxvYWRlci5qcyIsInZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy9FdmVudCcpO1xuXG52YXIgTG9hZGVyQ29tcGxldGVFdmVudCA9IGZ1bmN0aW9uIChsb2FkZXIpXG57XG4gICAgRXZlbnQuY2FsbCh0aGlzLCAnTE9BREVSX0NPTVBMRVRFX0VWRU5UJyk7XG5cbiAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbn07XG5cbkxvYWRlckNvbXBsZXRlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xuTG9hZGVyQ29tcGxldGVFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXJDb21wbGV0ZUV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlckNvbXBsZXRlRXZlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL0xvYWRlckNvbXBsZXRlRXZlbnQuanMiLCJ2YXIgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvRXZlbnQnKTtcblxudmFyIExvYWRlclN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAobG9hZGVyKVxue1xuICAgIEV2ZW50LmNhbGwodGhpcywgJ0xPQURFUl9TVEFSVF9FVkVOVCcpO1xuXG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG59O1xuXG5Mb2FkZXJTdGFydEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtcbkxvYWRlclN0YXJ0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyU3RhcnRFdmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXJTdGFydEV2ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0OTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2V2ZW50cy9Mb2FkZXJTdGFydEV2ZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBMT0FERVJfU1RBUlRfRVZFTlQ6IHJlcXVpcmUoJy4vTG9hZGVyU3RhcnRFdmVudCcpLFxuICAgIExPQURFUl9DT01QTEVURV9FVkVOVDogcmVxdWlyZSgnLi9Mb2FkZXJDb21wbGV0ZUV2ZW50JylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9ldmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZXZlbnRzL2luZGV4LmpzIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuL0pTT05GaWxlLmpzJyk7XG5cbnZhciBBdGxhc0pTT05GaWxlID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgYXRsYXNVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgYXRsYXNYaHJTZXR0aW5ncylcbntcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2VGaWxlKGtleSwgdGV4dHVyZVVSTCwgcGF0aCwgdGV4dHVyZVhoclNldHRpbmdzKTtcbiAgICB2YXIgZGF0YSA9IG5ldyBKU09ORmlsZShrZXksIGF0bGFzVVJMLCBwYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcblxuICAgIC8vICBMaW5rIHRoZW0gdG9nZXRoZXJcbiAgICBpbWFnZS5saW5rRmlsZSA9IGRhdGE7XG4gICAgZGF0YS5saW5rRmlsZSA9IGltYWdlO1xuXG4gICAgLy8gIFNldCB0aGUgdHlwZVxuICAgIGltYWdlLmxpbmtUeXBlID0gJ2F0bGFzanNvbic7XG4gICAgZGF0YS5saW5rVHlwZSA9ICdhdGxhc2pzb24nO1xuXG4gICAgcmV0dXJuIHsgdGV4dHVyZTogaW1hZ2UsIGRhdGE6IGRhdGEgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXRsYXNKU09ORmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQXRsYXNKU09ORmlsZS5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xuXG52YXIgQmluYXJ5RmlsZSA9IGZ1bmN0aW9uIChrZXksIHVybCwgcGF0aCwgeGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgeyBwYXRoID0gJyc7IH1cblxuICAgIGlmICgha2V5KVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIFxcJ0xvYWRlci5iaW5hcnlcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5iaW4nO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAnYmluYXJ5Jywga2V5LCB1cmwsICdhcnJheWJ1ZmZlcicsIHhoclNldHRpbmdzKTtcbn07XG5cbkJpbmFyeUZpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWxlLnByb3RvdHlwZSk7XG5CaW5hcnlGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeUZpbGU7XG5cbkJpbmFyeUZpbGUucHJvdG90eXBlLm9uUHJvY2VzcyA9IGZ1bmN0aW9uIChjYWxsYmFjaylcbntcbiAgICB0aGlzLnN0YXRlID0gQ09OU1QuRklMRV9QUk9DRVNTSU5HO1xuXG4gICAgdGhpcy5kYXRhID0gdGhpcy54aHJMb2FkZXIucmVzcG9uc2U7XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9CaW5hcnlGaWxlLmpzIiwidmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4vSW1hZ2VGaWxlLmpzJyk7XG52YXIgWE1MRmlsZSA9IHJlcXVpcmUoJy4vWE1MRmlsZS5qcycpO1xuXG52YXIgQml0bWFwRm9udEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMLCB4bWxVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncywgeG1sWGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlRmlsZShrZXksIHRleHR1cmVVUkwsIHBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XG4gICAgdmFyIGRhdGEgPSBuZXcgWE1MRmlsZShrZXksIHhtbFVSTCwgcGF0aCwgeG1sWGhyU2V0dGluZ3MpO1xuXG4gICAgLy8gIExpbmsgdGhlbSB0b2dldGhlclxuICAgIGltYWdlLmxpbmtGaWxlID0gZGF0YTtcbiAgICBkYXRhLmxpbmtGaWxlID0gaW1hZ2U7XG5cbiAgICAvLyAgU2V0IHRoZSB0eXBlXG4gICAgaW1hZ2UubGlua1R5cGUgPSAnYml0bWFwZm9udCc7XG4gICAgZGF0YS5saW5rVHlwZSA9ICdiaXRtYXBmb250JztcblxuICAgIHJldHVybiB7IHRleHR1cmU6IGltYWdlLCBkYXRhOiBkYXRhIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcEZvbnRGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9CaXRtYXBGb250RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvQml0bWFwRm9udEZpbGUuanMiLCJcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgRmlsZSA9IHJlcXVpcmUoJy4uL0ZpbGUnKTtcblxudmFyIEdMU0xGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcbntcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxuXG4gICAgaWYgKCFrZXkpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnRleHRcXCcgaW52YWxpZCBrZXkgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoICsga2V5ICsgJy5nbHNsJztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdXJsID0gcGF0aC5jb25jYXQodXJsKTtcbiAgICB9XG5cbiAgICBGaWxlLmNhbGwodGhpcywgJ2dsc2wnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XG59O1xuXG5HTFNMRmlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbGUucHJvdG90eXBlKTtcbkdMU0xGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdMU0xGaWxlO1xuXG5HTFNMRmlsZS5wcm90b3R5cGUub25Qcm9jZXNzID0gZnVuY3Rpb24gKGNhbGxiYWNrKVxue1xuICAgIHRoaXMuc3RhdGUgPSBDT05TVC5GSUxFX1BST0NFU1NJTkc7XG5cbiAgICB0aGlzLmRhdGEgPSB0aGlzLnhockxvYWRlci5yZXNwb25zZVRleHQ7XG5cbiAgICB0aGlzLm9uQ29tcGxldGUoKTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHTFNMRmlsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDUwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL0dMU0xGaWxlLmpzIiwiXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIEZpbGUgPSByZXF1aXJlKCcuLi9GaWxlJyk7XG5cbnZhciBTVkdGaWxlID0gZnVuY3Rpb24gKGtleSwgdXJsLCBwYXRoLCB4aHJTZXR0aW5ncylcbntcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7IHBhdGggPSAnJzsgfVxuXG4gICAgaWYgKCFrZXkpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgXFwnTG9hZGVyLnN2Z1xcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXVybClcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnN2Zyc7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGguY29uY2F0KHVybCk7XG4gICAgfVxuXG4gICAgRmlsZS5jYWxsKHRoaXMsICdzdmcnLCBrZXksIHVybCwgJ3RleHQnLCB4aHJTZXR0aW5ncyk7XG59O1xuXG5TVkdGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xuU1ZHRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkdGaWxlO1xuXG5TVkdGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXG57XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcblxuICAgIHZhciBzdmcgPSBbIHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dCBdO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihzdmcsIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCcgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKVxuICAgIHtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBDT05TVC5GSUxFX0VSUk9SRUQ7XG5cbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcblxuICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciByZXRyeSA9IGZhbHNlO1xuXG4gICAgdGhpcy5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcblxuICAgICAgICBfdGhpcy5vbkNvbXBsZXRlKCk7XG5cbiAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xuICAgIH07XG5cbiAgICB0aGlzLmRhdGEub25lcnJvciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLmRhdGEuc3JjKTtcblxuICAgICAgICAvLyAgU2FmYXJpIDggcmUtdHJ5XG4gICAgICAgIGlmICghcmV0cnkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHJ5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIHVybCA9ICdkYXRhOmltYWdlL3N2Zyt4bWwsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmcuam9pbignJykpO1xuXG4gICAgICAgICAgICBfdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gQ09OU1QuRklMRV9FUlJPUkVEO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhfdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5kYXRhLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0ZpbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL1NWR0ZpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDUwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sb2FkZXIvZmlsZXR5cGVzL1NWR0ZpbGUuanMiLCJ2YXIgSW1hZ2VGaWxlID0gcmVxdWlyZSgnLi9JbWFnZUZpbGUuanMnKTtcblxuLy8gIGNvbmZpZyBjYW4gaW5jbHVkZTogZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmdcblxudmFyIFNwcml0ZVNoZWV0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCBjb25maWcsIHBhdGgsIHhoclNldHRpbmdzKVxue1xuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZUZpbGUoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzLCBjb25maWcpO1xuXG4gICAgLy8gIE92ZXJyaWRlIHRoZSBGaWxlIHR5cGVcbiAgICBpbWFnZS50eXBlID0gJ3Nwcml0ZXNoZWV0JztcblxuICAgIHJldHVybiBpbWFnZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlU2hlZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9sb2FkZXIvZmlsZXR5cGVzL1Nwcml0ZVNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbG9hZGVyL2ZpbGV0eXBlcy9TcHJpdGVTaGVldC5qcyIsIlxudmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbnZhciBGaWxlID0gcmVxdWlyZSgnLi4vRmlsZScpO1xuXG52YXIgVGV4dEZpbGUgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIHBhdGgsIHhoclNldHRpbmdzKVxue1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHsgcGF0aCA9ICcnOyB9XG5cbiAgICBpZiAoIWtleSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyBcXCdMb2FkZXIudGV4dFxcJyBpbnZhbGlkIGtleSBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXVybClcbiAgICB7XG4gICAgICAgIHVybCA9IHBhdGggKyBrZXkgKyAnLnRleHQnO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cmwgPSBwYXRoLmNvbmNhdCh1cmwpO1xuICAgIH1cblxuICAgIEZpbGUuY2FsbCh0aGlzLCAndGV4dCcsIGtleSwgdXJsLCAndGV4dCcsIHhoclNldHRpbmdzKTtcbn07XG5cblRleHRGaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmlsZS5wcm90b3R5cGUpO1xuVGV4dEZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEZpbGU7XG5cblRleHRGaWxlLnByb3RvdHlwZS5vblByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spXG57XG4gICAgdGhpcy5zdGF0ZSA9IENPTlNULkZJTEVfUFJPQ0VTU0lORztcblxuICAgIHRoaXMuZGF0YSA9IHRoaXMueGhyTG9hZGVyLnJlc3BvbnNlVGV4dDtcblxuICAgIHRoaXMub25Db21wbGV0ZSgpO1xuXG4gICAgY2FsbGJhY2sodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRGaWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbG9hZGVyL2ZpbGV0eXBlcy9UZXh0RmlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUuanMiLCJ2YXIgQXZlcmFnZSA9IGZ1bmN0aW9uICh2YWx1ZXMpXG57XG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHN1bSArPSAoK3ZhbHVlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHZhbHVlcy5sZW5ndGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF2ZXJhZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0F2ZXJhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDUwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2VpbFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcbntcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxuXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xuXG4gICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSAqIHApIC8gcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VpbFRvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9DZWlsVG8uanNcbi8vIG1vZHVsZSBpZCA9IDUwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbnZhciBEZWdUb1JhZCA9IGZ1bmN0aW9uIChkZWdyZWVzKVxue1xuICAgIHJldHVybiBkZWdyZWVzICogQ09OU1QuREVHX1RPX1JBRDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVnVG9SYWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL0RlZ1RvUmFkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9EZWdUb1JhZC5qcyIsInZhciBEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBGbG9hdEJldHdlZW4gPSBmdW5jdGlvbiAobWluLCBtYXgpXG57XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb2F0QmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvYXRCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA1MTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZsb29yVG8gPSBmdW5jdGlvbiAodmFsdWUsIHBsYWNlLCBiYXNlKVxue1xuICAgIGlmIChwbGFjZSA9PT0gdW5kZWZpbmVkKSB7IHBsYWNlID0gMDsgfVxuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDEwOyB9XG5cbiAgICB2YXIgcCA9IE1hdGgucG93KGJhc2UsIC1wbGFjZSk7XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSAqIHApIC8gcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvb3JUbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvRmxvb3JUby5qc1xuLy8gbW9kdWxlIGlkID0gNTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIE1heEFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYW1vdW50LCBtYXgpXG57XG4gICAgcmV0dXJuIE1hdGgubWluKHZhbHVlICsgYW1vdW50LCBtYXgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXhBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL01heEFkZC5qc1xuLy8gbW9kdWxlIGlkID0gNTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNaW5TdWIgPSBmdW5jdGlvbiAodmFsdWUsIGFtb3VudCwgbWluKVxue1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAtIGFtb3VudCwgbWluKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWluU3ViO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9NaW5TdWIuanNcbi8vIG1vZHVsZSBpZCA9IDUxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGVyY2VudCA9IGZ1bmN0aW9uIChhLCBiLCBiYXNlKVxue1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHsgYmFzZSA9IDA7IH1cblxuICAgIGlmIChhID4gYiB8fCBiYXNlID4gYilcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIDwgYmFzZSB8fCBiYXNlID4gYSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gKGEgLSBiYXNlKSAvIGI7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJjZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9QZXJjZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuXG52YXIgUmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucylcbntcbiAgICByZXR1cm4gcmFkaWFucyAqIENPTlNULlJBRF9UT19ERUc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhZFRvRGVnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9SYWRUb0RlZy5qc1xuLy8gbW9kdWxlIGlkID0gNTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvUmFkVG9EZWcuanMiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcblxudmFyIFJvdGF0ZSA9IGZ1bmN0aW9uIChwb2ludCwgYW5nbGUpXG57XG4gICAgdmFyIHggPSBwb2ludC54O1xuICAgIHZhciB5ID0gcG9pbnQueTtcblxuICAgIHBvaW50LnggPSAoeCAqIE1hdGguY29zKGFuZ2xlKSkgLSAoeSAqIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgcG9pbnQueSA9ICh4ICogTWF0aC5zaW4oYW5nbGUpKSArICh5ICogTWF0aC5jb3MoYW5nbGUpKTtcblxuICAgIHJldHVybiBwb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9Sb3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgcCA9IFBvaW50IG9yIGFueSBvYmplY3Qgd2l0aCBwdWJsaWMgeC95IHByb3BlcnRpZXNcblxudmFyIFJvdGF0ZUFyb3VuZCA9IGZ1bmN0aW9uIChwb2ludCwgeCwgeSwgYW5nbGUpXG57XG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICB2YXIgdHggPSBwb2ludC54IC0geDtcbiAgICB2YXIgdHkgPSBwb2ludC55IC0geTtcblxuICAgIHBvaW50LnggPSB0eCAqIGMgLSB0eSAqIHMgKyB4O1xuICAgIHBvaW50LnkgPSB0eCAqIHMgKyB0eSAqIGMgKyB5O1xuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVBcm91bmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdGF0ZUFyb3VuZC5qc1xuLy8gbW9kdWxlIGlkID0gNTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSb3VuZFRvID0gZnVuY3Rpb24gKHZhbHVlLCBwbGFjZSwgYmFzZSlcbntcbiAgICBpZiAocGxhY2UgPT09IHVuZGVmaW5lZCkgeyBwbGFjZSA9IDA7IH1cbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7IGJhc2UgPSAxMDsgfVxuXG4gICAgdmFyIHAgPSBNYXRoLnBvdyhiYXNlLCAtcGxhY2UpO1xuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwKSAvIHA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kVG87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1JvdW5kVG8uanNcbi8vIG1vZHVsZSBpZCA9IDUyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBTaW5Db3NUYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIChsZW5ndGgsIHNpbkFtcCwgY29zQW1wLCBmcmVxdWVuY3kpXG57XG4gICAgaWYgKHNpbkFtcCA9PT0gdW5kZWZpbmVkKSB7IHNpbkFtcCA9IDE7IH1cbiAgICBpZiAoY29zQW1wID09PSB1bmRlZmluZWQpIHsgY29zQW1wID0gMTsgfVxuICAgIGlmIChmcmVxdWVuY3kgPT09IHVuZGVmaW5lZCkgeyBmcmVxdWVuY3kgPSAxOyB9XG5cbiAgICBmcmVxdWVuY3kgKj0gTWF0aC5QSSAvIGxlbmd0aDtcblxuICAgIHZhciBjb3MgPSBbXTtcbiAgICB2YXIgc2luID0gW107XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbmd0aDsgYysrKVxuICAgIHtcbiAgICAgICAgY29zQW1wIC09IHNpbkFtcCAqIGZyZXF1ZW5jeTtcbiAgICAgICAgc2luQW1wICs9IGNvc0FtcCAqIGZyZXF1ZW5jeTtcblxuICAgICAgICBjb3NbY10gPSBjb3NBbXA7XG4gICAgICAgIHNpbltjXSA9IHNpbkFtcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaW46IHNpbixcbiAgICAgICAgY29zOiBjb3MsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2luQ29zVGFibGVHZW5lcmF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL1NpbkNvc1RhYmxlR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIENoZWNrcyBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZSBvZiBlYWNoIG90aGVyLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3dpdGhpblxuKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gY2hlY2tcbiogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgc2Vjb25kIG51bWJlciB0byBjaGVja1xuKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIC0gVGhlIHRvbGVyYW5jZS4gQW55dGhpbmcgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIHRoaXMgaXMgY29uc2lkZXJlZCB3aXRoaW4gdGhlIHJhbmdlLlxuKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgaXMgPD0gdG9sZXJhbmNlIG9mIGIuXG4qIEBzZWUge0BsaW5rIFBoYXNlci5NYXRoLmZ1enp5RXF1YWx9XG4qL1xudmFyIFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBiLCB0b2xlcmFuY2UpXG57XG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPD0gdG9sZXJhbmNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2l0aGluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9XaXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDUyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlbiA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcbntcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2Vlbi5qc1xuLy8gbW9kdWxlIGlkID0gNTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxue1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi55IC0gcG9pbnQxLnksIHBvaW50Mi54IC0gcG9pbnQxLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuUG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJldHdlZW5Qb2ludHNZID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKVxue1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Mi54IC0gcG9pbnQxLngsIHBvaW50Mi55IC0gcG9pbnQxLnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXR3ZWVuUG9pbnRzWTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvQmV0d2VlblBvaW50c1kuanNcbi8vIG1vZHVsZSBpZCA9IDUyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQmV0d2VlblkgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeDIgLSB4MSwgeTIgLSB5MSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJldHdlZW5ZO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9hbmdsZS9CZXR3ZWVuWS5qc1xuLy8gbW9kdWxlIGlkID0gNTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBOb3JtYWxpemUgPSByZXF1aXJlKCcuL05vcm1hbGl6ZScpO1xuXG52YXIgUmV2ZXJzZSA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICByZXR1cm4gTm9ybWFsaXplKGFuZ2xlICsgTWF0aC5QSSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldmVyc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2FuZ2xlL1JldmVyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDUyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JldmVyc2UuanMiLCJ2YXIgTUFUSF9DT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuKiBSb3RhdGVzIGN1cnJlbnRBbmdsZSB0b3dhcmRzIHRhcmdldEFuZ2xlLCB0YWtpbmcgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGRpc3RhbmNlLlxuKiBUaGUgbGVycCBhcmd1bWVudCBpcyB0aGUgYW1vdW50IHRvIHJvdGF0ZSBieSBpbiB0aGlzIGNhbGwuXG4qIFxuKiBAbWV0aG9kIFBoYXNlci5NYXRoI3JvdGF0ZVRvQW5nbGVcbiogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRBbmdsZSAtIFRoZSBjdXJyZW50IGFuZ2xlLCBpbiByYWRpYW5zLlxuKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0QW5nbGUgLSBUaGUgdGFyZ2V0IGFuZ2xlIHRvIHJvdGF0ZSB0bywgaW4gcmFkaWFucy5cbiogQHBhcmFtIHtudW1iZXJ9IFtsZXJwPTAuMDVdIC0gVGhlIGxlcnAgdmFsdWUgdG8gYWRkIHRvIHRoZSBjdXJyZW50IGFuZ2xlLlxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhZGp1c3RlZCBhbmdsZS5cbiovXG52YXIgUm90YXRlVG8gPSBmdW5jdGlvbiAoY3VycmVudEFuZ2xlLCB0YXJnZXRBbmdsZSwgbGVycClcbntcbiAgICBpZiAobGVycCA9PT0gdW5kZWZpbmVkKSB7IGxlcnAgPSAwLjA1OyB9XG5cbiAgICBpZiAoY3VycmVudEFuZ2xlID09PSB0YXJnZXRBbmdsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBjdXJyZW50QW5nbGU7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA8PSBsZXJwIHx8IE1hdGguYWJzKHRhcmdldEFuZ2xlIC0gY3VycmVudEFuZ2xlKSA+PSAoTUFUSF9DT05TVC5QSTIgLSBsZXJwKSlcbiAgICB7XG4gICAgICAgIGN1cnJlbnRBbmdsZSA9IHRhcmdldEFuZ2xlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0QW5nbGUgLSBjdXJyZW50QW5nbGUpID4gTWF0aC5QSSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRhcmdldEFuZ2xlIDwgY3VycmVudEFuZ2xlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlICs9IE1BVEhfQ09OU1QuUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldEFuZ2xlIC09IE1BVEhfQ09OU1QuUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldEFuZ2xlID4gY3VycmVudEFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gbGVycDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRBbmdsZSA8IGN1cnJlbnRBbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgY3VycmVudEFuZ2xlIC09IGxlcnA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEFuZ2xlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGVUbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvUm90YXRlVG8uanNcbi8vIG1vZHVsZSBpZCA9IDUyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL1JvdGF0ZVRvLmpzIiwiLyoqXG4qIEdldHMgdGhlIHNob3J0ZXN0IGFuZ2xlIGJldHdlZW4gYGFuZ2xlMWAgYW5kIGBhbmdsZTJgLlxuKiBCb3RoIGFuZ2xlcyBtdXN0IGJlIGluIHRoZSByYW5nZSAtMTgwIHRvIDE4MCwgd2hpY2ggaXMgdGhlIHNhbWUgY2xhbXBlZFxuKiByYW5nZSB0aGF0IGBzcHJpdGUuYW5nbGVgIHVzZXMsIHNvIHlvdSBjYW4gcGFzcyBpbiB0d28gc3ByaXRlIGFuZ2xlcyB0b1xuKiB0aGlzIG1ldGhvZCwgYW5kIGdldCB0aGUgc2hvcnRlc3QgYW5nbGUgYmFjayBiZXR3ZWVuIHRoZSB0d28gb2YgdGhlbS5cbipcbiogVGhlIGFuZ2xlIHJldHVybmVkIHdpbGwgYmUgaW4gdGhlIHNhbWUgcmFuZ2UuIElmIHRoZSByZXR1cm5lZCBhbmdsZSBpc1xuKiBncmVhdGVyIHRoYW4gMCB0aGVuIGl0J3MgYSBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbiwgaWYgPCAwIHRoZW4gaXQnc1xuKiBhIGNsb2Nrd2lzZSByb3RhdGlvbi5cbiogXG4qIEBtZXRob2QgUGhhc2VyLk1hdGgjZ2V0U2hvcnRlc3RBbmdsZVxuKiBAcGFyYW0ge251bWJlcn0gYW5nbGUxIC0gVGhlIGZpcnN0IGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXG4qIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTIgLSBUaGUgc2Vjb25kIGFuZ2xlLiBJbiB0aGUgcmFuZ2UgLTE4MCB0byAxODAuXG4qIEByZXR1cm4ge251bWJlcn0gVGhlIHNob3J0ZXN0IGFuZ2xlLCBpbiBkZWdyZWVzLiBJZiBncmVhdGVyIHRoYW4gemVybyBpdCdzIGEgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24uXG4qL1xudmFyIFNob3J0ZXN0QmV0d2VlbiA9IGZ1bmN0aW9uIChhbmdsZTEsIGFuZ2xlMilcbntcbiAgICB2YXIgZGlmZmVyZW5jZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcblxuICAgIGlmIChkaWZmZXJlbmNlID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigoZGlmZmVyZW5jZSAtICgtMTgwKSkgLyAzNjApO1xuXG4gICAgcmV0dXJuIGRpZmZlcmVuY2UgLSAodGltZXMgKiAzNjApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0ZXN0QmV0d2VlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvU2hvcnRlc3RCZXR3ZWVuLmpzXG4vLyBtb2R1bGUgaWQgPSA1Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBCZXR3ZWVuOiByZXF1aXJlKCcuL0JldHdlZW4nKSxcbiAgICBCZXR3ZWVuWTogcmVxdWlyZSgnLi9CZXR3ZWVuWScpLFxuICAgIEJldHdlZW5Qb2ludHM6IHJlcXVpcmUoJy4vQmV0d2VlblBvaW50cycpLFxuICAgIEJldHdlZW5Qb2ludHNZOiByZXF1aXJlKCcuL0JldHdlZW5Qb2ludHNZJyksXG4gICAgUmV2ZXJzZTogcmVxdWlyZSgnLi9SZXZlcnNlJyksXG4gICAgUm90YXRlVG86IHJlcXVpcmUoJy4vUm90YXRlVG8nKSxcbiAgICBTaG9ydGVzdEJldHdlZW46IHJlcXVpcmUoJy4vU2hvcnRlc3RCZXR3ZWVuJyksXG4gICAgTm9ybWFsaXplOiByZXF1aXJlKCcuL05vcm1hbGl6ZScpLFxuICAgIFdyYXA6IHJlcXVpcmUoJy4vV3JhcCcpLFxuICAgIFdyYXBEZWdyZWVzOiByZXF1aXJlKCcuL1dyYXBEZWdyZWVzJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvYW5nbGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2FuZ2xlL2luZGV4LmpzIiwidmFyIERpc3RhbmNlUG93ZXIgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHBvdylcbntcbiAgICBpZiAocG93ID09PSB1bmRlZmluZWQpIHsgcG93ID0gMjsgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCBwb3cpICsgTWF0aC5wb3coeTIgLSB5MSwgcG93KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlUG93ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Rpc3RhbmNlL0Rpc3RhbmNlUG93ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxue1xuICAgIHZhciBkeCA9IHgxIC0geDI7XG4gICAgdmFyIGR5ID0geTEgLSB5MjtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VTcXVhcmVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9kaXN0YW5jZS9EaXN0YW5jZVNxdWFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEJldHdlZW46IHJlcXVpcmUoJy4vRGlzdGFuY2VCZXR3ZWVuJyksXG4gICAgUG93ZXI6IHJlcXVpcmUoJy4vRGlzdGFuY2VQb3dlcicpLFxuICAgIFNxdWFyZWQ6IHJlcXVpcmUoJy4vRGlzdGFuY2VTcXVhcmVkJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZGlzdGFuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Rpc3RhbmNlL2luZGV4LmpzIiwiZnVuY3Rpb24gSW4gKHYsIG92ZXJzaG9vdClcbntcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxuXG4gICAgcmV0dXJuIHYgKiB2ICogKChvdmVyc2hvb3QgKyAxKSAqIHYgLSBvdmVyc2hvb3QpO1xufVxuXG5mdW5jdGlvbiBPdXQgKHYsIG92ZXJzaG9vdClcbntcbiAgICBpZiAob3ZlcnNob290ID09PSB1bmRlZmluZWQpIHsgb3ZlcnNob290ID0gMS43MDE1ODsgfVxuXG4gICAgcmV0dXJuIC0tdiAqIHYgKiAoKG92ZXJzaG9vdCArIDEpICogdiArIG92ZXJzaG9vdCkgKyAxO1xufVxuXG5mdW5jdGlvbiBJbk91dCAodiwgb3ZlcnNob290KVxue1xuICAgIGlmIChvdmVyc2hvb3QgPT09IHVuZGVmaW5lZCkgeyBvdmVyc2hvb3QgPSAxLjcwMTU4OyB9XG5cbiAgICB2YXIgcyA9IG92ZXJzaG9vdCAqIDEuNTI1O1xuXG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiAodiAqIHYgKiAoKHMgKyAxKSAqIHYgLSBzKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoKHYgLT0gMikgKiB2ICogKChzICsgMSkgKiB2ICsgcykgKyAyKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvQmFjay5qc1xuLy8gbW9kdWxlIGlkID0gNTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHYgPSAxIC0gdjtcblxuICAgIGlmICh2IDwgMSAvIDIuNzUpXG4gICAge1xuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiB2ICogdik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPCAyIC8gMi43NSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2IDwgMi41IC8gMi43NSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxIC0gKDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMSAtICg3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE91dCAodilcbntcbiAgICBpZiAodiA8IDEgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHYgKiB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh2IDwgMiAvIDIuNzUpXG4gICAge1xuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMS41IC8gMi43NSkgKiB2ICsgMC43NTtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA8IDIuNSAvIDIuNzUpXG4gICAge1xuICAgICAgICByZXR1cm4gNy41NjI1ICogKHYgLT0gMi4yNSAvIDIuNzUpICogdiArIDAuOTM3NTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh2IC09IDIuNjI1IC8gMi43NSkgKiB2ICsgMC45ODQzNzU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICB2YXIgcmV2ZXJzZSA9IGZhbHNlO1xuXG4gICAgaWYgKHYgPCAwLjUpXG4gICAge1xuICAgICAgICB2ID0gMSAtICh2ICogMik7XG4gICAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2ID0gKHYgKiAyKSAtIDE7XG4gICAgfVxuXG4gICAgaWYgKHYgPCAxIC8gMi43NSlcbiAgICB7XG4gICAgICAgIHYgPSA3LjU2MjUgKiB2ICogdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA8IDIgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDEuNSAvIDIuNzUpICogdiArIDAuNzU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPCAyLjUgLyAyLjc1KVxuICAgIHtcbiAgICAgICAgdiA9IDcuNTYyNSAqICh2IC09IDIuMjUgLyAyLjc1KSAqIHYgKyAwLjkzNzU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHYgPSA3LjU2MjUgKiAodiAtPSAyLjYyNSAvIDIuNzUpICogdiArIDAuOTg0Mzc1O1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgxIC0gdikgKiAwLjU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiB2ICogMC41ICsgMC41O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBJbjogSW4sXG4gICAgT3V0OiBPdXQsXG4gICAgSW5PdXQ6IEluT3V0XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9Cb3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDUzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodilcbntcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdiAqIHYpO1xufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tdiAqIHYpKTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdiAqIHYpIC0gMSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodiAtPSAyKSAqIHYpICsgMSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL0NpcmN1bGFyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXG57XG4gICAgcmV0dXJuIHYgKiB2ICogdjtcbn1cblxuZnVuY3Rpb24gT3V0ICh2KVxue1xuICAgIHJldHVybiAtLXYgKiB2ICogdiArIDE7XG59XG5cbmZ1bmN0aW9uIEluT3V0ICh2KVxue1xuICAgIGlmICgodiAqPSAyKSA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogdiAqIHYgKiB2O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKyAyKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvQ3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IDUzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBJbiAodiwgYW1wbGl0dWRlLCBwZXJpb2QpXG57XG4gICAgaWYgKGFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IGFtcGxpdHVkZSA9IDAuMTsgfVxuICAgIGlmIChwZXJpb2QgPT09IHVuZGVmaW5lZCkgeyBwZXJpb2QgPSAwLjE7IH1cblxuICAgIGlmICh2ID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPT09IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHMgPSBwZXJpb2QgLyA0O1xuXG4gICAgICAgIGlmIChhbXBsaXR1ZGUgPCAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcyA9IHBlcmlvZCAqIE1hdGguYXNpbigxIC8gYW1wbGl0dWRlKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLShhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBPdXQgKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxue1xuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XG5cbiAgICBpZiAodiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ID09PSAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcblxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcbiAgICAgICAge1xuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAtMTAgKiB2KSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSArIDEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYsIGFtcGxpdHVkZSwgcGVyaW9kKVxue1xuICAgIGlmIChhbXBsaXR1ZGUgPT09IHVuZGVmaW5lZCkgeyBhbXBsaXR1ZGUgPSAwLjE7IH1cbiAgICBpZiAocGVyaW9kID09PSB1bmRlZmluZWQpIHsgcGVyaW9kID0gMC4xOyB9XG5cbiAgICBpZiAodiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ID09PSAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBzID0gcGVyaW9kIC8gNDtcblxuICAgICAgICBpZiAoYW1wbGl0dWRlIDwgMSlcbiAgICAgICAge1xuICAgICAgICAgICAgYW1wbGl0dWRlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHMgPSBwZXJpb2QgKiBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYW1wbGl0dWRlICogTWF0aC5wb3coMiwgMTAgKiAodiAtPSAxKSkgKiBNYXRoLnNpbigodiAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHBlcmlvZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqICh2IC09IDEpKSAqIE1hdGguc2luKCh2IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcGVyaW9kKSAqIDAuNSArIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvRWxhc3RpYy5qc1xuLy8gbW9kdWxlIGlkID0gNTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh2IC0gMSkpIC0gMC4wMDE7XG59XG5cbmZ1bmN0aW9uIE91dCAodilcbntcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHYpO1xufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHYgLSAxKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqICh2IC0gMSkpKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvRXhwby5qc1xuLy8gbW9kdWxlIGlkID0gNTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBMaW5lYXIgRWFzaW5nIChubyB2YXJpYXRpb24pLlxuKlxuKiBAbWV0aG9kIExhemVyLkVhc2luZy5MaW5lYXIjTm9uZVxuKiBAcGFyYW0ge251bWJlcn0gdiAtIFRoZSB2YWx1ZSB0byBiZSB0d2VlbmVkLlxuKiBAcmV0dXJucyB7bnVtYmVyfSB2LlxuKi9cbnZhciBMaW5lYXIgPSBmdW5jdGlvbiAodilcbntcbiAgICByZXR1cm4gdjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvTGluZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXG57XG4gICAgcmV0dXJuIHYgKiB2O1xufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgcmV0dXJuIHYgKiAoMiAtIHYpO1xufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gLTAuNSAqICgtLXYgKiAodiAtIDIpIC0gMSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIEluOiBJbixcbiAgICBPdXQ6IE91dCxcbiAgICBJbk91dDogSW5PdXRcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZWFzaW5nL1F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gNTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIEluICh2KVxue1xuICAgIHJldHVybiB2ICogdiAqIHYgKiB2O1xufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgcmV0dXJuIDEgLSAoLS12ICogdiAqIHYgKiB2KTtcbn1cblxuZnVuY3Rpb24gSW5PdXQgKHYpXG57XG4gICAgaWYgKCh2ICo9IDIpIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAwLjUgKiB2ICogdiAqIHYgKiB2O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gLTAuNSAqICgodiAtPSAyKSAqIHYgKiB2ICogdiAtIDIpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBJbjogSW4sXG4gICAgT3V0OiBPdXQsXG4gICAgSW5PdXQ6IEluT3V0XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9RdWFydGljLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXG57XG4gICAgcmV0dXJuIHYgKiB2ICogdiAqIHYgKiB2O1xufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgcmV0dXJuIC0tdiAqIHYgKiB2ICogdiAqIHYgKyAxO1xufVxuXG5mdW5jdGlvbiBJbk91dCAodilcbntcbiAgICBpZiAoKHYgKj0gMikgPCAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIHYgKiB2ICogdiAqIHYgKiB2O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMC41ICogKCh2IC09IDIpICogdiAqIHYgKiB2ICogdiArIDIpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBJbjogSW4sXG4gICAgT3V0OiBPdXQsXG4gICAgSW5PdXQ6IEluT3V0XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9RdWludGljLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gSW4gKHYpXG57XG4gICAgaWYgKHYgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKHYgKiBNYXRoLlBJIC8gMik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBPdXQgKHYpXG57XG4gICAgaWYgKHYgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4odiAqIE1hdGguUEkgLyAyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEluT3V0ICh2KVxue1xuICAgIGlmICh2ID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgPT09IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIHYpKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgSW46IEluLFxuICAgIE91dDogT3V0LFxuICAgIEluT3V0OiBJbk91dFxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9lYXNpbmcvU2luZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQmFjazogcmVxdWlyZSgnLi9CYWNrJyksXG4gICAgQm91bmNlOiByZXF1aXJlKCcuL0JvdW5jZScpLFxuICAgIENpcmN1bGFyOiByZXF1aXJlKCcuL0NpcmN1bGFyJyksXG4gICAgQ3ViaWM6IHJlcXVpcmUoJy4vQ3ViaWMnKSxcbiAgICBFbGFzdGljOiByZXF1aXJlKCcuL0VsYXN0aWMnKSxcbiAgICBFeHBvOiByZXF1aXJlKCcuL0V4cG8nKSxcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFyJyksXG4gICAgUXVhZHJhdGljOiByZXF1aXJlKCcuL1F1YWRyYXRpYycpLFxuICAgIFF1YXJ0aWM6IHJlcXVpcmUoJy4vUXVhcnRpYycpLFxuICAgIFF1aW50aWM6IHJlcXVpcmUoJy4vUXVpbnRpYycpLFxuICAgIFNpbmU6IHJlcXVpcmUoJy4vU2luZScpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Vhc2luZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvZWFzaW5nL2luZGV4LmpzIiwidmFyIENlaWwgPSBmdW5jdGlvbiAodmFsdWUsIGVwc2lsb24pXG57XG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlIC0gZXBzaWxvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlaWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0NlaWwuanNcbi8vIG1vZHVsZSBpZCA9IDU0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXF1YWwgPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcbntcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cblxuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBlcHNpbG9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDU0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRmxvb3IgPSBmdW5jdGlvbiAoYSwgYiwgZXBzaWxvbilcbntcbiAgICBpZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7IGVwc2lsb24gPSAwLjAwMDE7IH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICsgZXBzaWxvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb29yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9mdXp6eS9GbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gNTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uIChhLCBiLCBlcHNpbG9uKVxue1xuICAgIGlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIHsgZXBzaWxvbiA9IDAuMDAwMTsgfVxuXG4gICAgcmV0dXJuIGEgPiBiIC0gZXBzaWxvbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JlYXRlclRoYW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2Z1enp5L0dyZWF0ZXJUaGFuLmpzXG4vLyBtb2R1bGUgaWQgPSA1NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExlc3NUaGFuID0gZnVuY3Rpb24gKGEsIGIsIGVwc2lsb24pXG57XG4gICAgaWYgKGVwc2lsb24gPT09IHVuZGVmaW5lZCkgeyBlcHNpbG9uID0gMC4wMDAxOyB9XG5cbiAgICByZXR1cm4gYSA8IGIgKyBlcHNpbG9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXNzVGhhbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvTGVzc1RoYW4uanNcbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIENlaWw6IHJlcXVpcmUoJy4vQ2VpbCcpLFxuICAgIEVxdWFsOiByZXF1aXJlKCcuL0VxdWFsJyksXG4gICAgRmxvb3I6IHJlcXVpcmUoJy4vRmxvb3InKSxcbiAgICBHcmVhdGVyVGhhbjogcmVxdWlyZSgnLi9HcmVhdGVyVGhhbicpLFxuICAgIExlc3NUaGFuOiByZXF1aXJlKCcuL0xlc3NUaGFuJylcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvZnV6enkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2Z1enp5L2luZGV4LmpzIiwidmFyIEJlcm5zdGVpbiA9IHJlcXVpcmUoJy4uL0Jlcm5zdGVpbicpO1xuXG52YXIgQmV6aWVySW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2LCBrKVxue1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKylcbiAgICB7XG4gICAgICAgIGIgKz0gTWF0aC5wb3coMSAtIGssIG4gLSBpKSAqIE1hdGgucG93KGssIGkpICogdltpXSAqIEJlcm5zdGVpbihuLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmV6aWVySW50ZXJwb2xhdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvaW50ZXJwb2xhdGlvbi9CZXppZXJJbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0JlemllckludGVycG9sYXRpb24uanMiLCJ2YXIgQ2F0bXVsbFJvbSA9IHJlcXVpcmUoJy4uL0NhdG11bGxSb20nKTtcblxudmFyIENhdG11bGxSb21JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHYsIGspXG57XG4gICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgdmFyIGYgPSBtICogaztcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG5cbiAgICBpZiAodlswXSA9PT0gdlttXSlcbiAgICB7XG4gICAgICAgIGlmIChrIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoZiA9IG0gKiAoMSArIGspKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDYXRtdWxsUm9tKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmIChrIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZbMF0gLSAoQ2F0bXVsbFJvbSh2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrID4gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoQ2F0bXVsbFJvbSh2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENhdG11bGxSb20odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdG11bGxSb21JbnRlcnBvbGF0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbWF0aC9pbnRlcnBvbGF0aW9uL0NhdG11bGxSb21JbnRlcnBvbGF0aW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBCZXppZXI6IHJlcXVpcmUoJy4vQmV6aWVySW50ZXJwb2xhdGlvbicpLFxuICAgIENhdG11bGxSb206IHJlcXVpcmUoJy4vQ2F0bXVsbFJvbUludGVycG9sYXRpb24nKSxcbiAgICBMaW5lYXI6IHJlcXVpcmUoJy4vTGluZWFySW50ZXJwb2xhdGlvbicpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL2ludGVycG9sYXRpb24vaW5kZXguanMiLCIvLyAgVGFrZXMgdmFsdWUgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG93ZXIgb2YgMlxuXG52YXIgR2V0UG93ZXJPZlR3byA9IGZ1bmN0aW9uICh2YWx1ZSlcbntcbiAgICAvLyAgTWF0aC5sb2coMilcbiAgICB2YXIgaW5kZXggPSBNYXRoLmxvZyh2YWx1ZSkgLyAwLjY5MzE0NzE4MDU1OTk0NTM7XG5cbiAgICByZXR1cm4gKDEgPDwgTWF0aC5jZWlsKGluZGV4KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldFBvd2VyT2ZUd287XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3BvdzIvR2V0UG93ZXJPZlR3by5qc1xuLy8gbW9kdWxlIGlkID0gNTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICBJcyB2YWx1ZSBhIHBvd2VyIG9mIDI/XG5cbnZhciBJc1ZhbHVlUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh2YWx1ZSlcbntcbiAgICByZXR1cm4gKHZhbHVlID4gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc1ZhbHVlUG93ZXJPZlR3bztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcG93Mi9Jc1ZhbHVlUG93ZXJPZlR3by5qc1xuLy8gbW9kdWxlIGlkID0gNTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21hdGgvcG93Mi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnQgPSB7XG5cbiAgICBHZXROZXh0OiByZXF1aXJlKCcuL0dldFBvd2VyT2ZUd28nKSxcbiAgICBJc1NpemU6IHJlcXVpcmUoJy4vSXNTaXplUG93ZXJPZlR3bycpLFxuICAgIElzVmFsdWU6IHJlcXVpcmUoJy4vSXNWYWx1ZVBvd2VyT2ZUd28nKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9wb3cyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBjIC0gSW50ZXJuYWwgdmFyLlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBjID0gMTtcblxuLyoqXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBzMCAtIEludGVybmFsIHZhci5cbiogQHByaXZhdGVcbiovXG52YXIgczAgPSAwO1xuXG4vKipcbiogQHByb3BlcnR5IHtudW1iZXJ9IHMxIC0gSW50ZXJuYWwgdmFyLlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBzMSA9IDA7XG5cbi8qKlxuKiBAcHJvcGVydHkge251bWJlcn0gczIgLSBJbnRlcm5hbCB2YXIuXG4qIEBwcml2YXRlXG4qL1xudmFyIHMyID0gMDtcblxuLyoqXG4qIEBwcm9wZXJ0eSB7QXJyYXl9IHNpZ24gLSBJbnRlcm5hbCB2YXIuXG4qIEBwcml2YXRlXG4qL1xudmFyIHNpZ24gPSBbIC0xLCAxIF07XG5cbi8qKlxuKiBQcml2YXRlIHJhbmRvbSBoZWxwZXIuXG4qXG4qIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijcm5kXG4qIEBwcml2YXRlXG4qIEByZXR1cm4ge251bWJlcn1cbiovXG52YXIgcm5kID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuXG4gICAgYyA9IHQgfCAwO1xuICAgIHMwID0gczE7XG4gICAgczEgPSBzMjtcbiAgICBzMiA9IHQgLSBjO1xuXG4gICAgcmV0dXJuIHMyO1xufTtcblxuLyoqXG4qIEludGVybmFsIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBzZWVkIGhhc2guXG4qXG4qIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjaGFzaFxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge2FueX0gZGF0YVxuKiBAcmV0dXJuIHtudW1iZXJ9IGhhc2hlZCB2YWx1ZS5cbiovXG52YXIgaGFzaCA9IGZ1bmN0aW9uIChkYXRhKVxue1xuICAgIHZhciBoLCBpLCBuO1xuICAgIG4gPSAweGVmYzgyNDlkO1xuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIGggKj0gbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7Ly8gMl4zMlxuICAgIH1cblxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOy8vIDJeLTMyXG59O1xuXG5cbnZhciBSYW5kb21EYXRhR2VuZXJhdG9yID0gZnVuY3Rpb24gKHNlZWRzKVxue1xuICAgIGlmIChzZWVkcylcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdChzZWVkcyk7XG4gICAgfVxufTtcblxuUmFuZG9tRGF0YUdlbmVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5kb21EYXRhR2VuZXJhdG9yO1xuXG5SYW5kb21EYXRhR2VuZXJhdG9yLnByb3RvdHlwZSA9IHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uIChzZWVkcylcbiAgICB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VlZHMgPT09ICdzdHJpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlKHNlZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc293KHNlZWRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlc2V0IHRoZSBzZWVkIG9mIHRoZSByYW5kb20gZGF0YSBnZW5lcmF0b3IuXG4gICAgKlxuICAgICogX05vdGVfOiB0aGUgc2VlZCBhcnJheSBpcyBvbmx5IHByb2Nlc3NlZCB1cCB0byB0aGUgZmlyc3QgYHVuZGVmaW5lZGAgKG9yIGBudWxsYCkgdmFsdWUsIHNob3VsZCBzdWNoIGJlIHByZXNlbnQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzb3dcbiAgICAqIEBwYXJhbSB7YW55W119IHNlZWRzIC0gVGhlIGFycmF5IG9mIHNlZWRzOiB0aGUgYHRvU3RyaW5nKClgIG9mIGVhY2ggdmFsdWUgaXMgdXNlZC5cbiAgICAqL1xuICAgIHNvdzogZnVuY3Rpb24gKHNlZWRzKVxuICAgIHtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IHRvIGRlZmF1bHQgc2VlZFxuICAgICAgICBzMCA9IGhhc2goJyAnKTtcbiAgICAgICAgczEgPSBoYXNoKHMwKTtcbiAgICAgICAgczIgPSBoYXNoKHMxKTtcbiAgICAgICAgYyA9IDE7XG5cbiAgICAgICAgaWYgKCFzZWVkcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgYW55IHNlZWRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VlZHMubGVuZ3RoICYmIChzZWVkc1tpXSAhPSBudWxsKTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VlZCA9IHNlZWRzW2ldO1xuXG4gICAgICAgICAgICBzMCAtPSBoYXNoKHNlZWQpO1xuICAgICAgICAgICAgczAgKz0gfn4oczAgPCAwKTtcbiAgICAgICAgICAgIHMxIC09IGhhc2goc2VlZCk7XG4gICAgICAgICAgICBzMSArPSB+fihzMSA8IDApO1xuICAgICAgICAgICAgczIgLT0gaGFzaChzZWVkKTtcbiAgICAgICAgICAgIHMyICs9IH5+KHMyIDwgMCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDJeMzIuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VyXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxuICAgICovXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIDJeMzJcbiAgICAgICAgcmV0dXJuIHJuZCgpICogMHgxMDAwMDAwMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNmcmFjXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICAqL1xuICAgIGZyYWM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAyXi01M1xuICAgICAgICByZXR1cm4gcm5kKCkgKyAocm5kKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gMCBhbmQgMl4zMi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3JlYWxcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAyXjMyLlxuICAgICovXG4gICAgcmVhbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoKSArIHRoaXMuZnJhYygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNpbnRlZ2VySW5SYW5nZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgICovXG4gICAgaW50ZWdlckluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmVhbEluUmFuZ2UoMCwgbWF4IC0gbWluICsgMSkgKyBtaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgbWluIGFuZCBtYXguXG4gICAgKiBUaGlzIG1ldGhvZCBpcyBhbiBhbGlhcyBmb3IgUmFuZG9tRGF0YUdlbmVyYXRvci5pbnRlZ2VySW5SYW5nZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI2JldHdlZW5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAgICAqL1xuICAgIGJldHdlZW46IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXJJblJhbmdlKG1pbiwgbWF4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIHJlYWwgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyZWFsSW5SYW5nZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgICovXG4gICAgcmVhbEluUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWMoKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gcmVhbCBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI25vcm1hbFxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSByZWFsIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLlxuICAgICovXG4gICAgbm9ybWFsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIDEgLSAoMiAqIHRoaXMuZnJhYygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgdmFsaWQgUkZDNDEyMiB2ZXJzaW9uNCBJRCBoZXggc3RyaW5nIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTMwODM2OFxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdXVpZFxuICAgICogQHJldHVybiB7c3RyaW5nfSBBIHZhbGlkIFJGQzQxMjIgdmVyc2lvbjQgSUQgaGV4IHN0cmluZ1xuICAgICovXG4gICAgdXVpZDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBhID0gJyc7XG4gICAgICAgIHZhciBiID0gJyc7XG5cbiAgICAgICAgZm9yIChiID0gYSA9ICcnOyBhKysgPCAzNjsgYiArPX5hICUgNSB8IGEgKiAzJjQgPyAoYV4xNSA/IDhedGhpcy5mcmFjKCkgKiAoYV4yMCA/IDE2IDogNCkgOiA0KS50b1N0cmluZygxNikgOiAnLScpXG4gICAgICAgIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gbWVtYmVyIG9mIGBhcnJheWAuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNwaWNrXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxuICAgICovXG4gICAgcGljazogZnVuY3Rpb24gKGFycmF5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlckluUmFuZ2UoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSBzaWduIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvci5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5SYW5kb21EYXRhR2VuZXJhdG9yI3NpZ25cbiAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgb3IgKzEuXG4gICAgKi9cbiAgICBzaWduOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGljayhzaWduKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIG1lbWJlciBvZiBgYXJyYXlgLCBmYXZvcmluZyB0aGUgZWFybGllciBlbnRyaWVzLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3Ijd2VpZ2h0ZWRQaWNrXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIEFycmF5IHRvIHBpY2sgYSByYW5kb20gbWVtYmVyIG9mLlxuICAgICogQHJldHVybiB7YW55fSBBIHJhbmRvbSBtZW1iZXIgb2YgdGhlIGFycmF5LlxuICAgICovXG4gICAgd2VpZ2h0ZWRQaWNrOiBmdW5jdGlvbiAoYXJyYXkpXG4gICAge1xuICAgICAgICByZXR1cm4gYXJyYXlbfn4oTWF0aC5wb3codGhpcy5mcmFjKCksIDIpICogKGFycmF5Lmxlbmd0aCAtIDEpICsgMC41KV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIHJhbmRvbSB0aW1lc3RhbXAgYmV0d2VlbiBtaW4gYW5kIG1heCwgb3IgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIDIwMDAgYW5kIHRoZSBlbmQgb2YgMjAyMCBpZiBtaW4gYW5kIG1heCBhcmVuJ3Qgc3BlY2lmaWVkLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjdGltZXN0YW1wXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gdGltZXN0YW1wIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgKi9cbiAgICB0aW1lc3RhbXA6IGZ1bmN0aW9uIChtaW4sIG1heClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKG1pbiB8fCA5NDY2ODQ4MDAwMDAsIG1heCB8fCAxNTc3ODYyMDAwMDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgcmFuZG9tIGFuZ2xlIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICpcbiAgICAqIEBtZXRob2QgUGhhc2VyLlJhbmRvbURhdGFHZW5lcmF0b3IjYW5nbGVcbiAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICovXG4gICAgYW5nbGU6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VySW5SYW5nZSgtMTgwLCAxODApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByYW5kb20gcm90YXRpb24gaW4gcmFkaWFucywgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNyb3RhdGlvblxuICAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAtMy4xNDEgYW5kIDMuMTQxXG4gICAgKi9cbiAgICByb3RhdGlvbjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxJblJhbmdlKC0zLjE0MTU5MjY1MzU4OTc5MywgMy4xNDE1OTI2NTM1ODk3OTMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEdldHMgb3IgU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldGFpbiB0aGUgdmFsdWVzXG4gICAgKiB0aGF0IHRoZSBnZW5lcmF0b3IgaXMgdXNpbmcgYmV0d2VlbiBnYW1lcywgaS5lLiBpbiBhIGdhbWUgc2F2ZSBmaWxlLlxuICAgICpcbiAgICAqIFRvIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2l0aCBhIHByZXZpb3VzbHkgc2F2ZWQgc3RhdGUgeW91IGNhbiBwYXNzIGl0IGFzIHRoZVxuICAgICogYHNlZWRgIHZhbHVlIGluIHlvdXIgZ2FtZSBjb25maWcsIG9yIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHkgYWZ0ZXIgUGhhc2VyIGhhcyBib290ZWQuXG4gICAgKlxuICAgICogQ2FsbCB0aGlzIG1ldGhvZCB3aXRoIG5vIHBhcmFtZXRlcnMgdG8gcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICpcbiAgICAqIElmIHByb3ZpZGluZyBhIHN0YXRlIGl0IHNob3VsZCBtYXRjaCB0aGUgc2FtZSBmb3JtYXQgdGhhdCB0aGlzIG1ldGhvZFxuICAgICogcmV0dXJucywgd2hpY2ggaXMgYSBzdHJpbmcgd2l0aCBhIGhlYWRlciBgIXJuZGAgZm9sbG93ZWQgYnkgdGhlIGBjYCxcbiAgICAqIGBzMGAsIGBzMWAgYW5kIGBzMmAgdmFsdWVzIHJlc3BlY3RpdmVseSwgZWFjaCBjb21tYS1kZWxpbWl0ZWQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuUmFuZG9tRGF0YUdlbmVyYXRvciNzdGF0ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV0gLSBHZW5lcmF0b3Igc3RhdGUgdG8gYmUgc2V0LlxuICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxuICAgICovXG4gICAgc3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnICYmIHN0YXRlLm1hdGNoKC9eIXJuZC8pKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgIGMgPSBwYXJzZUZsb2F0KHN0YXRlWzFdKTtcbiAgICAgICAgICAgIHMwID0gcGFyc2VGbG9hdChzdGF0ZVsyXSk7XG4gICAgICAgICAgICBzMSA9IHBhcnNlRmxvYXQoc3RhdGVbM10pO1xuICAgICAgICAgICAgczIgPSBwYXJzZUZsb2F0KHN0YXRlWzRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbICchcm5kJywgYywgczAsIHMxLCBzMiBdLmpvaW4oJywnKTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tRGF0YUdlbmVyYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvcmFuZG9tLWRhdGEtZ2VuZXJhdG9yL1JhbmRvbURhdGFHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDU1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU25hcENlaWwgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5jZWlsKHZhbHVlIC8gZ2FwKTtcblxuICAgIHJldHVybiBzdGFydCArIHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbmFwQ2VpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL21hdGgvc25hcC9TbmFwQ2VpbC5qc1xuLy8gbW9kdWxlIGlkID0gNTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwRmxvb3IgPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5mbG9vcih2YWx1ZSAvIGdhcCk7XG5cbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU25hcEZsb29yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL1NuYXBGbG9vci5qc1xuLy8gbW9kdWxlIGlkID0gNTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTbmFwVG8gPSBmdW5jdGlvbiAodmFsdWUsIGdhcCwgc3RhcnQpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG5cbiAgICBpZiAoZ2FwID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlIC09IHN0YXJ0O1xuICAgIHZhbHVlID0gZ2FwICogTWF0aC5yb3VuZCh2YWx1ZSAvIGdhcCk7XG5cbiAgICByZXR1cm4gc3RhcnQgKyB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU25hcFRvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbWF0aC9zbmFwL1NuYXBUby5qc1xuLy8gbW9kdWxlIGlkID0gNTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQ2VpbDogcmVxdWlyZSgnLi9TbmFwQ2VpbCcpLFxuICAgIEZsb29yOiByZXF1aXJlKCcuL1NuYXBGbG9vcicpLFxuICAgIFRvOiByZXF1aXJlKCcuL1NuYXBUbycpXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9tYXRoL3NuYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tYXRoL3NuYXAvaW5kZXguanMiLCIvKipcbiogVGhlIGBNYXR0ZXIuUXVlcnlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBwZXJmb3JtaW5nIGNvbGxpc2lvbiBxdWVyaWVzLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgUXVlcnlcbiovXG5cbnZhciBRdWVyeSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVjdG9yJyk7XG52YXIgU0FUID0gcmVxdWlyZSgnLi9TQVQnKTtcbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbnZhciBCb2RpZXMgPSByZXF1aXJlKCcuLi9mYWN0b3J5L0JvZGllcycpO1xudmFyIFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvVmVydGljZXMnKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYSByYXkgc2VnbWVudCBhZ2FpbnN0IGEgc2V0IG9mIGJvZGllcyBhbmQgcmV0dXJucyBhbGwgY29sbGlzaW9ucywgcmF5IHdpZHRoIGlzIG9wdGlvbmFsLiBJbnRlcnNlY3Rpb24gcG9pbnRzIGFyZSBub3QgcHJvdmlkZWQuXG4gICAgICogQG1ldGhvZCByYXlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JheVdpZHRoXVxuICAgICAqIEByZXR1cm4ge29iamVjdFtdfSBDb2xsaXNpb25zXG4gICAgICovXG4gICAgUXVlcnkucmF5ID0gZnVuY3Rpb24oYm9kaWVzLCBzdGFydFBvaW50LCBlbmRQb2ludCwgcmF5V2lkdGgpIHtcbiAgICAgICAgcmF5V2lkdGggPSByYXlXaWR0aCB8fCAxZS0xMDA7XG5cbiAgICAgICAgdmFyIHJheUFuZ2xlID0gVmVjdG9yLmFuZ2xlKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSxcbiAgICAgICAgICAgIHJheUxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1YihzdGFydFBvaW50LCBlbmRQb2ludCkpLFxuICAgICAgICAgICAgcmF5WCA9IChlbmRQb2ludC54ICsgc3RhcnRQb2ludC54KSAqIDAuNSxcbiAgICAgICAgICAgIHJheVkgPSAoZW5kUG9pbnQueSArIHN0YXJ0UG9pbnQueSkgKiAwLjUsXG4gICAgICAgICAgICByYXkgPSBCb2RpZXMucmVjdGFuZ2xlKHJheVgsIHJheVksIHJheUxlbmd0aCwgcmF5V2lkdGgsIHsgYW5nbGU6IHJheUFuZ2xlIH0pLFxuICAgICAgICAgICAgY29sbGlzaW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMoYm9keUEuYm91bmRzLCByYXkuYm91bmRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5QS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaiA8IGJvZHlBLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keUEucGFydHNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhwYXJ0LmJvdW5kcywgcmF5LmJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBTQVQuY29sbGlkZXMocGFydCwgcmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uY29sbGlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24uYm9keSA9IGNvbGxpc2lvbi5ib2R5QSA9IGNvbGxpc2lvbi5ib2R5QiA9IGJvZHlBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnMucHVzaChjb2xsaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJvZGllcyB3aG9zZSBib3VuZHMgYXJlIGluc2lkZSAob3Igb3V0c2lkZSBpZiBzZXQpIHRoZSBnaXZlbiBzZXQgb2YgYm91bmRzLCBmcm9tIHRoZSBnaXZlbiBzZXQgb2YgYm9kaWVzLlxuICAgICAqIEBtZXRob2QgcmVnaW9uXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvdXRzaWRlPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge2JvZHlbXX0gVGhlIGJvZGllcyBtYXRjaGluZyB0aGUgcXVlcnlcbiAgICAgKi9cbiAgICBRdWVyeS5yZWdpb24gPSBmdW5jdGlvbihib2RpZXMsIGJvdW5kcywgb3V0c2lkZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIG92ZXJsYXBzID0gQm91bmRzLm92ZXJsYXBzKGJvZHkuYm91bmRzLCBib3VuZHMpO1xuICAgICAgICAgICAgaWYgKChvdmVybGFwcyAmJiAhb3V0c2lkZSkgfHwgKCFvdmVybGFwcyAmJiBvdXRzaWRlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJvZGllcyB3aG9zZSB2ZXJ0aWNlcyBjb250YWluIHRoZSBnaXZlbiBwb2ludCwgZnJvbSB0aGUgZ2l2ZW4gc2V0IG9mIGJvZGllcy5cbiAgICAgKiBAbWV0aG9kIHBvaW50XG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge2JvZHlbXX0gVGhlIGJvZGllcyBtYXRjaGluZyB0aGUgcXVlcnlcbiAgICAgKi9cbiAgICBRdWVyeS5wb2ludCA9IGZ1bmN0aW9uKGJvZGllcywgcG9pbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKEJvdW5kcy5jb250YWlucyhib2R5LmJvdW5kcywgcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHkucGFydHMubGVuZ3RoID09PSAxID8gMCA6IDE7IGogPCBib2R5LnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKHBhcnQuYm91bmRzLCBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFZlcnRpY2VzLmNvbnRhaW5zKHBhcnQudmVydGljZXMsIHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9RdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbGxpc2lvbi9RdWVyeS5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Nb3VzZUNvbnN0cmFpbnRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBtb3VzZSBjb25zdHJhaW50cy5cbiogTW91c2UgY29uc3RyYWludHMgYXJlIHVzZWQgZm9yIGFsbG93aW5nIHVzZXIgaW50ZXJhY3Rpb24sIHByb3ZpZGluZyB0aGUgYWJpbGl0eSB0byBtb3ZlIGJvZGllcyB2aWEgdGhlIG1vdXNlIG9yIHRvdWNoLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgTW91c2VDb25zdHJhaW50XG4qL1xuXG52YXIgTW91c2VDb25zdHJhaW50ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2VDb25zdHJhaW50O1xuXG52YXIgVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xudmFyIFNsZWVwaW5nID0gcmVxdWlyZSgnLi4vY29yZS9TbGVlcGluZycpO1xudmFyIE1vdXNlID0gcmVxdWlyZSgnLi4vY29yZS9Nb3VzZScpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4uL2NvcmUvRXZlbnRzJyk7XG52YXIgRGV0ZWN0b3IgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vRGV0ZWN0b3InKTtcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xudmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1vdXNlIGNvbnN0cmFpbnQuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7TW91c2VDb25zdHJhaW50fSBBIG5ldyBNb3VzZUNvbnN0cmFpbnRcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQuY3JlYXRlID0gZnVuY3Rpb24oZW5naW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb3VzZSA9IChlbmdpbmUgPyBlbmdpbmUubW91c2UgOiBudWxsKSB8fCAob3B0aW9ucyA/IG9wdGlvbnMubW91c2UgOiBudWxsKTtcblxuICAgICAgICBpZiAoIW1vdXNlKSB7XG4gICAgICAgICAgICBpZiAoZW5naW5lICYmIGVuZ2luZS5yZW5kZXIgJiYgZW5naW5lLnJlbmRlci5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICBtb3VzZSA9IE1vdXNlLmNyZWF0ZShlbmdpbmUucmVuZGVyLmNhbnZhcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUob3B0aW9ucy5lbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignTW91c2VDb25zdHJhaW50LmNyZWF0ZTogb3B0aW9ucy5tb3VzZSB3YXMgdW5kZWZpbmVkLCBvcHRpb25zLmVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgbWF5IG5vdCBmdW5jdGlvbiBhcyBleHBlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBDb25zdHJhaW50LmNyZWF0ZSh7IFxuICAgICAgICAgICAgbGFiZWw6ICdNb3VzZSBDb25zdHJhaW50JyxcbiAgICAgICAgICAgIHBvaW50QTogbW91c2UucG9zaXRpb24sXG4gICAgICAgICAgICBwb2ludEI6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgbGVuZ3RoOiAwLjAxLCBcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4xLFxuICAgICAgICAgICAgYW5ndWxhclN0aWZmbmVzczogMSxcbiAgICAgICAgICAgIHJlbmRlcjoge1xuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnIzkwRUU5MCcsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZUNvbnN0cmFpbnQnLFxuICAgICAgICAgICAgbW91c2U6IG1vdXNlLFxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50LFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IDB4MDAwMSxcbiAgICAgICAgICAgICAgICBtYXNrOiAweEZGRkZGRkZGLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdXNlQ29uc3RyYWludCA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEV2ZW50cy5vbihlbmdpbmUsICdiZWZvcmVVcGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZS53b3JsZCk7XG4gICAgICAgICAgICBNb3VzZUNvbnN0cmFpbnQudXBkYXRlKG1vdXNlQ29uc3RyYWludCwgYWxsQm9kaWVzKTtcbiAgICAgICAgICAgIF90cmlnZ2VyRXZlbnRzKG1vdXNlQ29uc3RyYWludCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtb3VzZUNvbnN0cmFpbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIG1vdXNlIGNvbnN0cmFpbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7TW91c2VDb25zdHJhaW50fSBtb3VzZUNvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZSA9IGZ1bmN0aW9uKG1vdXNlQ29uc3RyYWludCwgYm9kaWVzKSB7XG4gICAgICAgIHZhciBtb3VzZSA9IG1vdXNlQ29uc3RyYWludC5tb3VzZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBtb3VzZUNvbnN0cmFpbnQuY29uc3RyYWludCxcbiAgICAgICAgICAgIGJvZHkgPSBtb3VzZUNvbnN0cmFpbnQuYm9keTtcblxuICAgICAgICBpZiAobW91c2UuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYm9keUIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBtb3VzZS5wb3NpdGlvbikgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgRGV0ZWN0b3IuY2FuQ29sbGlkZShib2R5LmNvbGxpc2lvbkZpbHRlciwgbW91c2VDb25zdHJhaW50LmNvbGxpc2lvbkZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBib2R5LnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKHBhcnQudmVydGljZXMsIG1vdXNlLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QSA9IG1vdXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJvZHlCID0gbW91c2VDb25zdHJhaW50LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IHsgeDogbW91c2UucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb24ueCwgeTogbW91c2UucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb24ueSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQiA9IGJvZHkuYW5nbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIobW91c2VDb25zdHJhaW50LCAnc3RhcnRkcmFnJywgeyBtb3VzZTogbW91c2UsIGJvZHk6IGJvZHkgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoY29uc3RyYWludC5ib2R5QiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gbW91c2UucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdHJhaW50LmJvZHlCID0gbW91c2VDb25zdHJhaW50LmJvZHkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdlbmRkcmFnJywgeyBtb3VzZTogbW91c2UsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgbW91c2UgY29uc3RyYWludCBldmVudHMuXG4gICAgICogQG1ldGhvZCBfdHJpZ2dlckV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VDb25zdHJhaW50XG4gICAgICovXG4gICAgdmFyIF90cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24obW91c2VDb25zdHJhaW50KSB7XG4gICAgICAgIHZhciBtb3VzZSA9IG1vdXNlQ29uc3RyYWludC5tb3VzZSxcbiAgICAgICAgICAgIG1vdXNlRXZlbnRzID0gbW91c2Uuc291cmNlRXZlbnRzO1xuXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZW1vdmUpXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZW1vdmUnLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2Vkb3duKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIobW91c2VDb25zdHJhaW50LCAnbW91c2Vkb3duJywgeyBtb3VzZTogbW91c2UgfSk7XG5cbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNldXApXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZXVwJywgeyBtb3VzZTogbW91c2UgfSk7XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIG1vdXNlIHN0YXRlIHJlYWR5IGZvciB0aGUgbmV4dCBzdGVwXG4gICAgICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzKG1vdXNlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaGFzIG1vdmVkIChvciBhIHRvdWNoIG1vdmVzKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxuICAgICpcbiAgICAqIEBldmVudCBtb3VzZW1vdmVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGlzIGRvd24gKG9yIGEgdG91Y2ggaGFzIHN0YXJ0ZWQpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNlZG93blxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgdXAgKG9yIGEgdG91Y2ggaGFzIGVuZGVkKSBkdXJpbmcgdGhlIGxhc3Qgc3RlcFxuICAgICpcbiAgICAqIEBldmVudCBtb3VzZXVwXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyBhIGJvZHlcbiAgICAqXG4gICAgKiBAZXZlbnQgc3RhcnRkcmFnXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7Ym9keX0gZXZlbnQuYm9keSBUaGUgYm9keSBiZWluZyBkcmFnZ2VkXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBlbmRzIGRyYWdnaW5nIGEgYm9keVxuICAgICpcbiAgICAqIEBldmVudCBlbmRkcmFnXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7Ym9keX0gZXZlbnQuYm9keSBUaGUgYm9keSB0aGF0IGhhcyBzdG9wcGVkIGJlaW5nIGRyYWdnZWRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBgTW91c2VgIGluc3RhbmNlIGluIHVzZS4gSWYgbm90IHN1cHBsaWVkIGluIGBNb3VzZUNvbnN0cmFpbnQuY3JlYXRlYCwgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZVxuICAgICAqIEB0eXBlIG1vdXNlXG4gICAgICogQGRlZmF1bHQgbW91c2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBgQm9keWAgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgbW92ZWQgYnkgdGhlIHVzZXIsIG9yIGBudWxsYCBpZiBubyBib2R5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvZHlcbiAgICAgKiBAdHlwZSBib2R5XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBDb25zdHJhaW50YCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIG1vdmUgdGhlIGJvZHkgZHVyaW5nIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGZpbHRlciBwcm9wZXJ0aWVzLlxuICAgICAqIFRoZSBjb2xsaXNpb24gZmlsdGVyIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgd2hpY2ggdHlwZXMgb2YgYm9keSB0aGlzIG1vdXNlIGNvbnN0cmFpbnQgY2FuIGludGVyYWN0IHdpdGguXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9jb25zdHJhaW50L01vdXNlQ29uc3RyYWludC5qc1xuLy8gbW9kdWxlIGlkID0gNTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2NvbnN0cmFpbnQvTW91c2VDb25zdHJhaW50LmpzIiwiLyoqXHJcbiogVGhlIGBNYXR0ZXJgIG1vZHVsZSBpcyB0aGUgdG9wIGxldmVsIG5hbWVzcGFjZS4gSXQgYWxzbyBpbmNsdWRlcyBhIGZ1bmN0aW9uIGZvciBpbnN0YWxsaW5nIHBsdWdpbnMgb24gdG9wIG9mIHRoZSBsaWJyYXJ5LlxyXG4qXHJcbiogQGNsYXNzIE1hdHRlclxyXG4qL1xyXG5cclxudmFyIE1hdHRlciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXR0ZXI7XHJcblxyXG52YXIgUGx1Z2luID0gcmVxdWlyZSgnLi9QbHVnaW4nKTtcclxudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4vQ29tbW9uJyk7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGlicmFyeSBuYW1lLlxyXG4gICAgICogQHByb3BlcnR5IG5hbWVcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLm5hbWUgPSAnbWF0dGVyLWpzJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaWJyYXJ5IHZlcnNpb24uXHJcbiAgICAgKiBAcHJvcGVydHkgdmVyc2lvblxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudmVyc2lvbiA9ICdAQFZFUlNJT05AQCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgcGx1Z2luIGRlcGVuZGVuY2llcyB0byBiZSBpbnN0YWxsZWQuIFRoZXNlIGFyZSBub3JtYWxseSBzZXQgYW5kIGluc3RhbGxlZCB0aHJvdWdoIGBNYXR0ZXIudXNlYC5cclxuICAgICAqIEFsdGVybmF0aXZlbHkgeW91IG1heSBzZXQgYE1hdHRlci51c2VzYCBtYW51YWxseSBhbmQgaW5zdGFsbCB0aGVtIGJ5IGNhbGxpbmcgYFBsdWdpbi51c2UoTWF0dGVyKWAuXHJcbiAgICAgKiBAcHJvcGVydHkgdXNlc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBsdWdpbnMgdGhhdCBoYXZlIGJlZW4gaW5zdGFsbGVkIHRocm91Z2ggYE1hdHRlci5QbHVnaW4uaW5zdGFsbGAuIFJlYWQgb25seS5cclxuICAgICAqIEBwcm9wZXJ0eSB1c2VkXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLnVzZWQgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbGxzIHRoZSBnaXZlbiBwbHVnaW5zIG9uIHRoZSBgTWF0dGVyYCBuYW1lc3BhY2UuXHJcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnQtaGFuZCBmb3IgYFBsdWdpbi51c2VgLCBzZWUgaXQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gb25jZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBjb2RlLCB3aXRoIGFsbCBvZiB0aGUgcGx1Z2lucyB5b3Ugd2lzaCB0byBpbnN0YWxsIGFzIGFyZ3VtZW50cy5cclxuICAgICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB1bmxlc3MgeW91IGludGVuZCB0byBtYW51YWxseSBjb250cm9sIGluc3RhbGxhdGlvbiBvcmRlci5cclxuICAgICAqIEBtZXRob2QgdXNlXHJcbiAgICAgKiBAcGFyYW0gLi4ucGx1Z2luIHtGdW5jdGlvbn0gVGhlIHBsdWdpbihzKSB0byBpbnN0YWxsIG9uIGBiYXNlYCAobXVsdGktYXJndW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgUGx1Z2luLnVzZShNYXR0ZXIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBiZWZvcmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYE1hdHRlcmAuXHJcbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cclxuICAgICAqIEBtZXRob2QgYmVmb3JlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgTWF0dGVyYFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYmVmb3JlIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci5iZWZvcmUgPSBmdW5jdGlvbihwYXRoLCBmdW5jKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXk1hdHRlci4vLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5jaGFpblBhdGhCZWZvcmUoTWF0dGVyLCBwYXRoLCBmdW5jKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYWZ0ZXIgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYE1hdHRlcmAuXHJcbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cclxuICAgICAqIEBtZXRob2QgYWZ0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBNYXR0ZXJgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBhZnRlciB0aGUgb3JpZ2luYWxcclxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIuYWZ0ZXIgPSBmdW5jdGlvbihwYXRoLCBmdW5jKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXk1hdHRlci4vLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5jaGFpblBhdGhBZnRlcihNYXR0ZXIsIHBhdGgsIGZ1bmMpO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2NvcmUvTWF0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvY29yZS9NYXR0ZXIuanMiLCIvKipcbiogVGhlIGBNYXR0ZXIuUnVubmVyYCBtb2R1bGUgaXMgYW4gb3B0aW9uYWwgdXRpbGl0eSB3aGljaCBwcm92aWRlcyBhIGdhbWUgbG9vcCwgXG4qIHRoYXQgaGFuZGxlcyBjb250aW51b3VzbHkgdXBkYXRpbmcgYSBgTWF0dGVyLkVuZ2luZWAgZm9yIHlvdSB3aXRoaW4gYSBicm93c2VyLlxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXG4qIElmIHlvdSBhcmUgdXNpbmcgeW91ciBvd24gZ2FtZSBsb29wIGluc3RlYWQsIHRoZW4geW91IGRvIG5vdCBuZWVkIHRoZSBgTWF0dGVyLlJ1bm5lcmAgbW9kdWxlLlxuKiBJbnN0ZWFkIGp1c3QgY2FsbCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaW4geW91ciBvd24gbG9vcC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFJ1bm5lclxuKi9cblxudmFyIFJ1bm5lciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vRXZlbnRzJyk7XG52YXIgRW5naW5lID0gcmVxdWlyZSgnLi9FbmdpbmUnKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCcuL0NvbW1vbicpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICBcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgIH1cblxuICAgIGlmICghX3JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB2YXIgX2ZyYW1lVGltZW91dDtcblxuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2speyBcbiAgICAgICAgICAgIF9mcmFtZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhDb21tb24ubm93KCkpOyBcbiAgICAgICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX2ZyYW1lVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBSdW5uZXIuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBSdW5uZXIuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBmcHM6IDYwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjogMSxcbiAgICAgICAgICAgIGRlbHRhU2FtcGxlU2l6ZTogNjAsXG4gICAgICAgICAgICBjb3VudGVyVGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZnJhbWVDb3VudGVyOiAwLFxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgIHRpbWVQcmV2OiBudWxsLFxuICAgICAgICAgICAgdGltZVNjYWxlUHJldjogMSxcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgaXNGaXhlZDogZmFsc2UsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJ1bm5lciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJ1bm5lci5kZWx0YSA9IHJ1bm5lci5kZWx0YSB8fCAxMDAwIC8gcnVubmVyLmZwcztcbiAgICAgICAgcnVubmVyLmRlbHRhTWluID0gcnVubmVyLmRlbHRhTWluIHx8IDEwMDAgLyBydW5uZXIuZnBzO1xuICAgICAgICBydW5uZXIuZGVsdGFNYXggPSBydW5uZXIuZGVsdGFNYXggfHwgMTAwMCAvIChydW5uZXIuZnBzICogMC41KTtcbiAgICAgICAgcnVubmVyLmZwcyA9IDEwMDAgLyBydW5uZXIuZGVsdGE7XG5cbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHRpY2tzIGEgYE1hdHRlci5FbmdpbmVgIGJ5IGNhbGxpbmcgYFJ1bm5lci50aWNrYCBvbiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgZXZlbnQuXG4gICAgICogQG1ldGhvZCBydW5cbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgUnVubmVyLnJ1biA9IGZ1bmN0aW9uKHJ1bm5lciwgZW5naW5lKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBydW5uZXIgaWYgZW5naW5lIGlzIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgIGlmICh0eXBlb2YgcnVubmVyLnBvc2l0aW9uSXRlcmF0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVuZ2luZSA9IHJ1bm5lcjtcbiAgICAgICAgICAgIHJ1bm5lciA9IFJ1bm5lci5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIChmdW5jdGlvbiByZW5kZXIodGltZSl7XG4gICAgICAgICAgICBydW5uZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICYmIHJ1bm5lci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgUnVubmVyLnRpY2socnVubmVyLCBlbmdpbmUsIHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZ2FtZSBsb29wIHV0aWxpdHkgdGhhdCB1cGRhdGVzIHRoZSBlbmdpbmUgYW5kIHJlbmRlcmVyIGJ5IG9uZSBzdGVwIChhICd0aWNrJykuXG4gICAgICogRmVhdHVyZXMgZGVsdGEgc21vb3RoaW5nLCB0aW1lIGNvcnJlY3Rpb24gYW5kIGZpeGVkIG9yIGR5bmFtaWMgdGltaW5nLlxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVUaWNrYCwgYHRpY2tgIGFuZCBgYWZ0ZXJUaWNrYCBldmVudHMgb24gdGhlIGVuZ2luZS5cbiAgICAgKiBDb25zaWRlciBqdXN0IGBFbmdpbmUudXBkYXRlKGVuZ2luZSwgZGVsdGEpYCBpZiB5b3UncmUgdXNpbmcgeW91ciBvd24gbG9vcC5cbiAgICAgKiBAbWV0aG9kIHRpY2tcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gICAgICovXG4gICAgUnVubmVyLnRpY2sgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSwgdGltZSkge1xuICAgICAgICB2YXIgdGltaW5nID0gZW5naW5lLnRpbWluZyxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gPSAxLFxuICAgICAgICAgICAgZGVsdGE7XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGV2ZW50IG9iamVjdFxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWluZy50aW1lc3RhbXBcbiAgICAgICAgfTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICdiZWZvcmVUaWNrJywgZXZlbnQpO1xuICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdiZWZvcmVUaWNrJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxuXG4gICAgICAgIGlmIChydW5uZXIuaXNGaXhlZCkge1xuICAgICAgICAgICAgLy8gZml4ZWQgdGltZXN0ZXBcbiAgICAgICAgICAgIGRlbHRhID0gcnVubmVyLmRlbHRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyB0aW1lc3RlcCBiYXNlZCBvbiB3YWxsIGNsb2NrIGJldHdlZW4gY2FsbHNcbiAgICAgICAgICAgIGRlbHRhID0gKHRpbWUgLSBydW5uZXIudGltZVByZXYpIHx8IHJ1bm5lci5kZWx0YTtcbiAgICAgICAgICAgIHJ1bm5lci50aW1lUHJldiA9IHRpbWU7XG5cbiAgICAgICAgICAgIC8vIG9wdGltaXN0aWNhbGx5IGZpbHRlciBkZWx0YSBvdmVyIGEgZmV3IGZyYW1lcywgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgICAgICAgIHJ1bm5lci5kZWx0YUhpc3RvcnkucHVzaChkZWx0YSk7XG4gICAgICAgICAgICBydW5uZXIuZGVsdGFIaXN0b3J5ID0gcnVubmVyLmRlbHRhSGlzdG9yeS5zbGljZSgtcnVubmVyLmRlbHRhU2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICBkZWx0YSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHJ1bm5lci5kZWx0YUhpc3RvcnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBsaW1pdCBkZWx0YVxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IHJ1bm5lci5kZWx0YU1pbiA/IHJ1bm5lci5kZWx0YU1pbiA6IGRlbHRhO1xuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA+IHJ1bm5lci5kZWx0YU1heCA/IHJ1bm5lci5kZWx0YU1heCA6IGRlbHRhO1xuXG4gICAgICAgICAgICAvLyBjb3JyZWN0aW9uIGZvciBkZWx0YVxuICAgICAgICAgICAgY29ycmVjdGlvbiA9IGRlbHRhIC8gcnVubmVyLmRlbHRhO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZW5naW5lIHRpbWluZyBvYmplY3RcbiAgICAgICAgICAgIHJ1bm5lci5kZWx0YSA9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZSBjb3JyZWN0aW9uIGZvciB0aW1lIHNjYWxpbmdcbiAgICAgICAgaWYgKHJ1bm5lci50aW1lU2NhbGVQcmV2ICE9PSAwKVxuICAgICAgICAgICAgY29ycmVjdGlvbiAqPSB0aW1pbmcudGltZVNjYWxlIC8gcnVubmVyLnRpbWVTY2FsZVByZXY7XG5cbiAgICAgICAgaWYgKHRpbWluZy50aW1lU2NhbGUgPT09IDApXG4gICAgICAgICAgICBjb3JyZWN0aW9uID0gMDtcblxuICAgICAgICBydW5uZXIudGltZVNjYWxlUHJldiA9IHRpbWluZy50aW1lU2NhbGU7XG4gICAgICAgIHJ1bm5lci5jb3JyZWN0aW9uID0gY29ycmVjdGlvbjtcblxuICAgICAgICAvLyBmcHMgY291bnRlclxuICAgICAgICBydW5uZXIuZnJhbWVDb3VudGVyICs9IDE7XG4gICAgICAgIGlmICh0aW1lIC0gcnVubmVyLmNvdW50ZXJUaW1lc3RhbXAgPj0gMTAwMCkge1xuICAgICAgICAgICAgcnVubmVyLmZwcyA9IHJ1bm5lci5mcmFtZUNvdW50ZXIgKiAoKHRpbWUgLSBydW5uZXIuY291bnRlclRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb3VudGVyVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZUNvdW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAndGljaycsIGV2ZW50KTtcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAndGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcblxuICAgICAgICAvLyBpZiB3b3JsZCBoYXMgYmVlbiBtb2RpZmllZCwgY2xlYXIgdGhlIHJlbmRlciBzY2VuZSBncmFwaFxuICAgICAgICBpZiAoZW5naW5lLndvcmxkLmlzTW9kaWZpZWQgXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyXG4gICAgICAgICAgICAmJiBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXJcbiAgICAgICAgICAgICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlci5jbGVhcikge1xuICAgICAgICAgICAgZW5naW5lLnJlbmRlci5jb250cm9sbGVyLmNsZWFyKGVuZ2luZS5yZW5kZXIpOyAvLyBAZGVwcmVjYXRlZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVVwZGF0ZScsIGV2ZW50KTtcbiAgICAgICAgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XG5cbiAgICAgICAgLy8gcmVuZGVyXG4gICAgICAgIC8vIEBkZXByZWNhdGVkXG4gICAgICAgIGlmIChlbmdpbmUucmVuZGVyICYmIGVuZ2luZS5yZW5kZXIuY29udHJvbGxlcikge1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpOyAvLyBAZGVwcmVjYXRlZFxuXG4gICAgICAgICAgICBlbmdpbmUucmVuZGVyLmNvbnRyb2xsZXIud29ybGQoZW5naW5lLnJlbmRlcik7XG5cbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2FmdGVyUmVuZGVyJywgZXZlbnQpO1xuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7IC8vIEBkZXByZWNhdGVkXG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihydW5uZXIsICdhZnRlclRpY2snLCBldmVudCk7XG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVGljaycsIGV2ZW50KTsgLy8gQGRlcHJlY2F0ZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5kcyBleGVjdXRpb24gb2YgYFJ1bm5lci5ydW5gIG9uIHRoZSBnaXZlbiBgcnVubmVyYCwgYnkgY2FuY2VsaW5nIHRoZSBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBldmVudCBsb29wLlxuICAgICAqIElmIHlvdSB3aXNoIHRvIG9ubHkgdGVtcG9yYXJpbHkgcGF1c2UgdGhlIGVuZ2luZSwgc2VlIGBlbmdpbmUuZW5hYmxlZGAgaW5zdGVhZC5cbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICovXG4gICAgUnVubmVyLnN0b3AgPSBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lKHJ1bm5lci5mcmFtZVJlcXVlc3RJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgUnVubmVyLnJ1bmAuXG4gICAgICogQG1ldGhvZCBzdGFydFxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgUnVubmVyLnN0YXJ0ID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUpIHtcbiAgICAgICAgUnVubmVyLnJ1bihydW5uZXIsIGVuZ2luZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGF0IHRoZSBzdGFydCBvZiBhIHRpY2ssIGJlZm9yZSBhbnkgdXBkYXRlcyB0byB0aGUgZW5naW5lIG9yIHRpbWluZ1xuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVUaWNrXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciBlbmdpbmUgdGltaW5nIHVwZGF0ZWQsIGJ1dCBqdXN0IGJlZm9yZSB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgdGlja1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYXQgdGhlIGVuZCBvZiBhIHRpY2ssIGFmdGVyIGVuZ2luZSB1cGRhdGUgYW5kIGFmdGVyIHJlbmRlcmluZ1xuICAgICpcbiAgICAqIEBldmVudCBhZnRlclRpY2tcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlVXBkYXRlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhZnRlciB1cGRhdGVcbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJVcGRhdGVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSByZW5kZXJpbmdcbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqIEBkZXByZWNhdGVkXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqIEBkZXByZWNhdGVkXG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHJ1bm5lciBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvb2xlYW5gIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBydW5uZXIgc2hvdWxkIHVzZSBhIGZpeGVkIHRpbWVzdGVwIChvdGhlcndpc2UgaXQgaXMgdmFyaWFibGUpLlxuICAgICAqIElmIHRpbWluZyBpcyBmaXhlZCwgdGhlbiB0aGUgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZCB3aWxsIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGZyYW1lIHJhdGUgKGJ1dCBiZWhhdmlvdXIgd2lsbCBiZSBkZXRlcm1pbmlzdGljKS5cbiAgICAgKiBJZiB0aGUgdGltaW5nIGlzIHZhcmlhYmxlLCB0aGVuIHRoZSBhcHBhcmVudCBzaW11bGF0aW9uIHNwZWVkIHdpbGwgYmUgY29uc3RhbnQgKGFwcHJveGltYXRlbHksIGJ1dCBhdCB0aGUgY29zdCBvZiBkZXRlcm1pbmluaXNtKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc0ZpeGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIHN0ZXAgYmV0d2VlbiB1cGRhdGVzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBJZiBgZW5naW5lLnRpbWluZy5pc0ZpeGVkYCBpcyBzZXQgdG8gYHRydWVgLCB0aGVuIGBkZWx0YWAgaXMgZml4ZWQuXG4gICAgICogSWYgaXQgaXMgYGZhbHNlYCwgdGhlbiBgZGVsdGFgIGNhbiBkeW5hbWljYWxseSBjaGFuZ2UgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkZWx0YVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxuICAgICAqL1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcGh5c2ljcy9tYXR0ZXItanMvY29yZS9SdW5uZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waHlzaWNzL21hdHRlci1qcy9jb3JlL1J1bm5lci5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5Db21wb3NpdGVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyBjb21wb3NpdGUgYm9kaWVzXG4qIHdpdGggY29tbW9ubHkgdXNlZCBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyBzdGFja3MgYW5kIGNoYWlucykuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb21wb3NpdGVzXG4qL1xuXG52YXIgQ29tcG9zaXRlcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZXM7XG5cbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuLi9jb25zdHJhaW50L0NvbnN0cmFpbnQnKTtcbnZhciBDb21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9ib2R5L0JvZHknKTtcbnZhciBCb2RpZXMgPSByZXF1aXJlKCcuL0JvZGllcycpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgYm9kaWVzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrIGluIGEgZ3JpZCBhcnJhbmdlbWVudC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGJvZHkncyBib3VuZHMgdG8gcHJldmVudCBvdmVybGFwcy5cbiAgICAgKiBAbWV0aG9kIHN0YWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLnN0YWNrID0gZnVuY3Rpb24oeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YWNrID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnU3RhY2snIH0pLFxuICAgICAgICAgICAgeCA9IHh4LFxuICAgICAgICAgICAgeSA9IHl5LFxuICAgICAgICAgICAgbGFzdEJvZHksXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgdmFyIG1heEhlaWdodCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBjYWxsYmFjayh4LCB5LCBjb2x1bW4sIHJvdywgbGFzdEJvZHksIGkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUhlaWdodCA9IGJvZHkuYm91bmRzLm1heC55IC0gYm9keS5ib3VuZHMubWluLnksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5V2lkdGggPSBib2R5LmJvdW5kcy5tYXgueCAtIGJvZHkuYm91bmRzLm1pbi54OyBcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGJvZHlIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShib2R5LCB7IHg6IGJvZHlXaWR0aCAqIDAuNSwgeTogYm9keUhlaWdodCAqIDAuNSB9KTtcblxuICAgICAgICAgICAgICAgICAgICB4ID0gYm9keS5ib3VuZHMubWF4LnggKyBjb2x1bW5HYXA7XG5cbiAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoc3RhY2ssIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBjb2x1bW5HYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB5ICs9IG1heEhlaWdodCArIHJvd0dhcDtcbiAgICAgICAgICAgIHggPSB4eDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENoYWlucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUgdG9nZXRoZXIgdXNpbmcgY29uc3RyYWludHMuXG4gICAgICogQG1ldGhvZCBjaGFpblxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldEFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldEJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjaGFpbmVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLmNoYWluID0gZnVuY3Rpb24oY29tcG9zaXRlLCB4T2Zmc2V0QSwgeU9mZnNldEEsIHhPZmZzZXRCLCB5T2Zmc2V0Qiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcztcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaSAtIDFdLFxuICAgICAgICAgICAgICAgIGJvZHlCID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGJvZHlBSGVpZ2h0ID0gYm9keUEuYm91bmRzLm1heC55IC0gYm9keUEuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlBV2lkdGggPSBib2R5QS5ib3VuZHMubWF4LnggLSBib2R5QS5ib3VuZHMubWluLngsIFxuICAgICAgICAgICAgICAgIGJvZHlCSGVpZ2h0ID0gYm9keUIuYm91bmRzLm1heC55IC0gYm9keUIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlCV2lkdGggPSBib2R5Qi5ib3VuZHMubWF4LnggLSBib2R5Qi5ib3VuZHMubWluLng7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcbiAgICAgICAgICAgICAgICBwb2ludEE6IHsgeDogYm9keUFXaWR0aCAqIHhPZmZzZXRBLCB5OiBib2R5QUhlaWdodCAqIHlPZmZzZXRBIH0sXG4gICAgICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxuICAgICAgICAgICAgICAgIHBvaW50QjogeyB4OiBib2R5QldpZHRoICogeE9mZnNldEIsIHk6IGJvZHlCSGVpZ2h0ICogeU9mZnNldEIgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKGNvbnN0cmFpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5sYWJlbCArPSAnIENoYWluJztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGJvZGllcyBpbiB0aGUgY29tcG9zaXRlIHdpdGggY29uc3RyYWludHMgaW4gYSBncmlkIHBhdHRlcm4sIHdpdGggb3B0aW9uYWwgY3Jvc3MgYnJhY2VzLlxuICAgICAqIEBtZXRob2QgbWVzaFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIG1lc2hlZCB0b2dldGhlciB3aXRoIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5tZXNoID0gZnVuY3Rpb24oY29tcG9zaXRlLCBjb2x1bW5zLCByb3dzLCBjcm9zc0JyYWNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBib2RpZXMgPSBjb21wb3NpdGUuYm9kaWVzLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIGJvZHlDO1xuICAgICAgICBcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAxOyBjb2wgPCBjb2x1bW5zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGJvZHlBID0gYm9kaWVzWyhjb2wgLSAxKSArIChyb3cgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBib2R5QTogYm9keUEsIGJvZHlCOiBib2R5QiB9LCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm93ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgY29sdW1uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBib2RpZXNbY29sICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlBLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NCcmFjZSAmJiBjb2wgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QyA9IGJvZGllc1soY29sIC0gMSkgKyAoKHJvdyAtIDEpICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA8IGNvbHVtbnMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QyA9IGJvZGllc1soY29sICsgMSkgKyAoKHJvdyAtIDEpICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5sYWJlbCArPSAnIE1lc2gnO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBib2RpZXMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2sgaW4gYSBweXJhbWlkIGFycmFuZ2VtZW50LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYm9keSdzIGJvdW5kcyB0byBwcmV2ZW50IG92ZXJsYXBzLlxuICAgICAqIEBtZXRob2QgcHlyYW1pZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5weXJhbWlkID0gZnVuY3Rpb24oeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZXMuc3RhY2soeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgZnVuY3Rpb24oeCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsUm93cyA9IE1hdGgubWluKHJvd3MsIE1hdGguY2VpbChjb2x1bW5zIC8gMikpLFxuICAgICAgICAgICAgICAgIGxhc3RCb2R5V2lkdGggPSBsYXN0Qm9keSA/IGxhc3RCb2R5LmJvdW5kcy5tYXgueCAtIGxhc3RCb2R5LmJvdW5kcy5taW4ueCA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyb3cgPiBhY3R1YWxSb3dzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcmV2ZXJzZSByb3cgb3JkZXJcbiAgICAgICAgICAgIHJvdyA9IGFjdHVhbFJvd3MgLSByb3c7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHJvdyxcbiAgICAgICAgICAgICAgICBlbmQgPSBjb2x1bW5zIC0gMSAtIHJvdztcblxuICAgICAgICAgICAgaWYgKGNvbHVtbiA8IHN0YXJ0IHx8IGNvbHVtbiA+IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldHJvYWN0aXZlbHkgZml4IHRoZSBmaXJzdCBib2R5J3MgcG9zaXRpb24sIHNpbmNlIHdpZHRoIHdhcyB1bmtub3duXG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIEJvZHkudHJhbnNsYXRlKGxhc3RCb2R5LCB7IHg6IChjb2x1bW4gKyAoY29sdW1ucyAlIDIgPT09IDEgPyAxIDogLTEpKSAqIGxhc3RCb2R5V2lkdGgsIHk6IDAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gbGFzdEJvZHkgPyBjb2x1bW4gKiBsYXN0Qm9keVdpZHRoIDogMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHh4ICsgeE9mZnNldCArIGNvbHVtbiAqIGNvbHVtbkdhcCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgd2l0aCBhIE5ld3RvbidzIENyYWRsZSBzZXR1cCBvZiBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLlxuICAgICAqIEBtZXRob2QgbmV3dG9uc0NyYWRsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBuZXd0b25zQ3JhZGxlIGJvZHlcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLm5ld3RvbnNDcmFkbGUgPSBmdW5jdGlvbih4eCwgeXksIG51bWJlciwgc2l6ZSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXd0b25zQ3JhZGxlID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnTmV3dG9ucyBDcmFkbGUnIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gMS45LFxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IEJvZGllcy5jaXJjbGUoeHggKyBpICogKHNpemUgKiBzZXBhcmF0aW9uKSwgeXkgKyBsZW5ndGgsIHNpemUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW5lcnRpYTogSW5maW5pdHksIHJlc3RpdHV0aW9uOiAxLCBmcmljdGlvbjogMCwgZnJpY3Rpb25BaXI6IDAuMDAwMSwgc2xvcDogMSB9KSxcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50ID0gQ29uc3RyYWludC5jcmVhdGUoeyBwb2ludEE6IHsgeDogeHggKyBpICogKHNpemUgKiBzZXBhcmF0aW9uKSwgeTogeXkgfSwgYm9keUI6IGNpcmNsZSB9KTtcblxuICAgICAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkobmV3dG9uc0NyYWRsZSwgY2lyY2xlKTtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KG5ld3RvbnNDcmFkbGUsIGNvbnN0cmFpbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld3RvbnNDcmFkbGU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIHdpdGggc2ltcGxlIGNhciBzZXR1cCBvZiBib2RpZXMgYW5kIGNvbnN0cmFpbnRzLlxuICAgICAqIEBtZXRob2QgY2FyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aGVlbFNpemVcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjYXIgYm9keVxuICAgICAqL1xuICAgIENvbXBvc2l0ZXMuY2FyID0gZnVuY3Rpb24oeHgsIHl5LCB3aWR0aCwgaGVpZ2h0LCB3aGVlbFNpemUpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gQm9keS5uZXh0R3JvdXAodHJ1ZSksXG4gICAgICAgICAgICB3aGVlbEJhc2UgPSAtMjAsXG4gICAgICAgICAgICB3aGVlbEFPZmZzZXQgPSAtd2lkdGggKiAwLjUgKyB3aGVlbEJhc2UsXG4gICAgICAgICAgICB3aGVlbEJPZmZzZXQgPSB3aWR0aCAqIDAuNSAtIHdoZWVsQmFzZSxcbiAgICAgICAgICAgIHdoZWVsWU9mZnNldCA9IDA7XG4gICAgXG4gICAgICAgIHZhciBjYXIgPSBDb21wb3NpdGUuY3JlYXRlKHsgbGFiZWw6ICdDYXInIH0pLFxuICAgICAgICAgICAgYm9keSA9IEJvZGllcy50cmFwZXpvaWQoeHgsIHl5LCB3aWR0aCwgaGVpZ2h0LCAwLjMsIHsgXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuMDEsXG4gICAgICAgICAgICAgICAgY2hhbWZlcjoge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDEwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHZhciB3aGVlbEEgPSBCb2RpZXMuY2lyY2xlKHh4ICsgd2hlZWxBT2Zmc2V0LCB5eSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuOCxcbiAgICAgICAgICAgIGRlbnNpdHk6IDAuMDFcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgd2hlZWxCID0gQm9kaWVzLmNpcmNsZSh4eCArIHdoZWVsQk9mZnNldCwgeXkgKyB3aGVlbFlPZmZzZXQsIHdoZWVsU2l6ZSwgeyBcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjgsXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAxXG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIGF4ZWxBID0gQ29uc3RyYWludC5jcmVhdGUoe1xuICAgICAgICAgICAgYm9keUE6IGJvZHksXG4gICAgICAgICAgICBwb2ludEE6IHsgeDogd2hlZWxBT2Zmc2V0LCB5OiB3aGVlbFlPZmZzZXQgfSxcbiAgICAgICAgICAgIGJvZHlCOiB3aGVlbEEsXG4gICAgICAgICAgICBzdGlmZm5lc3M6IDAuMixcbiAgICAgICAgICAgIHJlbmRlcjoge1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXhlbEIgPSBDb25zdHJhaW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBib2R5QTogYm9keSxcbiAgICAgICAgICAgIHBvaW50QTogeyB4OiB3aGVlbEJPZmZzZXQsIHk6IHdoZWVsWU9mZnNldCB9LFxuICAgICAgICAgICAgYm9keUI6IHdoZWVsQixcbiAgICAgICAgICAgIHN0aWZmbmVzczogMC4yLFxuICAgICAgICAgICAgcmVuZGVyOiB7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCBib2R5KTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEEpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjYXIsIHdoZWVsQik7XG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEEpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjYXIsIGF4ZWxCKTtcblxuICAgICAgICByZXR1cm4gY2FyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2ltcGxlIHNvZnQgYm9keSBsaWtlIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHNvZnRCb2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHh4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHl5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnRpY2xlUmFkaXVzXG4gICAgICogQHBhcmFtIHt9IHBhcnRpY2xlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7fSBjb25zdHJhaW50T3B0aW9uc1xuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIHNvZnRCb2R5XG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5zb2Z0Qm9keSA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNyb3NzQnJhY2UsIHBhcnRpY2xlUmFkaXVzLCBwYXJ0aWNsZU9wdGlvbnMsIGNvbnN0cmFpbnRPcHRpb25zKSB7XG4gICAgICAgIHBhcnRpY2xlT3B0aW9ucyA9IENvbW1vbi5leHRlbmQoeyBpbmVydGlhOiBJbmZpbml0eSB9LCBwYXJ0aWNsZU9wdGlvbnMpO1xuICAgICAgICBjb25zdHJhaW50T3B0aW9ucyA9IENvbW1vbi5leHRlbmQoeyBzdGlmZm5lc3M6IDAuNCB9LCBjb25zdHJhaW50T3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHNvZnRCb2R5ID0gQ29tcG9zaXRlcy5zdGFjayh4eCwgeXksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gQm9kaWVzLmNpcmNsZSh4LCB5LCBwYXJ0aWNsZVJhZGl1cywgcGFydGljbGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgQ29tcG9zaXRlcy5tZXNoKHNvZnRCb2R5LCBjb2x1bW5zLCByb3dzLCBjcm9zc0JyYWNlLCBjb25zdHJhaW50T3B0aW9ucyk7XG5cbiAgICAgICAgc29mdEJvZHkubGFiZWwgPSAnU29mdCBCb2R5JztcblxuICAgICAgICByZXR1cm4gc29mdEJvZHk7XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQ29tcG9zaXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2ZhY3RvcnkvQ29tcG9zaXRlcy5qcyIsIi8qKlxuKiBUaGUgYE1hdHRlci5TdmdgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjb252ZXJ0aW5nIFNWRyBpbWFnZXMgaW50byBhbiBhcnJheSBvZiB2ZWN0b3IgcG9pbnRzLlxuKlxuKiBUbyB1c2UgdGhpcyBtb2R1bGUgeW91IGFsc28gbmVlZCB0aGUgU1ZHUGF0aFNlZyBwb2x5ZmlsbDogaHR0cHM6Ly9naXRodWIuY29tL3Byb2dlcnMvcGF0aHNlZ1xuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgU3ZnXG4qL1xuXG52YXIgU3ZnID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU3ZnO1xuXG52YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIFNWRyBwYXRoIGludG8gYW4gYXJyYXkgb2YgdmVjdG9yIHBvaW50cy5cbiAgICAgKiBJZiB0aGUgaW5wdXQgcGF0aCBmb3JtcyBhIGNvbmNhdmUgc2hhcGUsIHlvdSBtdXN0IGRlY29tcG9zZSB0aGUgcmVzdWx0IGludG8gY29udmV4IHBhcnRzIGJlZm9yZSB1c2UuXG4gICAgICogU2VlIGBCb2RpZXMuZnJvbVZlcnRpY2VzYCB3aGljaCBwcm92aWRlcyBzdXBwb3J0IGZvciB0aGlzLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1cHBvcnQgY29tcGxleCBwYXRocyAoc3VjaCBhcyB0aG9zZSB3aXRoIGhvbGVzKS5cbiAgICAgKiBAbWV0aG9kIHBhdGhUb1ZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtTVkdQYXRoRWxlbWVudH0gcGF0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlTGVuZ3RoPTE1XVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcltdfSBwb2ludHNcbiAgICAgKi9cbiAgICBTdmcucGF0aFRvVmVydGljZXMgPSBmdW5jdGlvbihwYXRoLCBzYW1wbGVMZW5ndGgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLnRvcG9seS5qcy9ibG9iL21hc3Rlci9zdmcudG9wb2x5LmpzXG4gICAgICAgIHZhciBpLCBpbCwgdG90YWwsIHBvaW50LCBzZWdtZW50LCBzZWdtZW50cywgXG4gICAgICAgICAgICBzZWdtZW50c1F1ZXVlLCBsYXN0U2VnbWVudCwgXG4gICAgICAgICAgICBsYXN0UG9pbnQsIHNlZ21lbnRJbmRleCwgcG9pbnRzID0gW10sXG4gICAgICAgICAgICBseCwgbHksIGxlbmd0aCA9IDAsIHggPSAwLCB5ID0gMDtcblxuICAgICAgICBzYW1wbGVMZW5ndGggPSBzYW1wbGVMZW5ndGggfHwgMTU7XG5cbiAgICAgICAgdmFyIGFkZFBvaW50ID0gZnVuY3Rpb24ocHgsIHB5LCBwYXRoU2VnVHlwZSkge1xuICAgICAgICAgICAgLy8gYWxsIG9kZC1udW1iZXJlZCBwYXRoIHR5cGVzIGFyZSByZWxhdGl2ZSBleGNlcHQgUEFUSFNFR19DTE9TRVBBVEggKDEpXG4gICAgICAgICAgICB2YXIgaXNSZWxhdGl2ZSA9IHBhdGhTZWdUeXBlICUgMiA9PT0gMSAmJiBwYXRoU2VnVHlwZSA+IDE7XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGxhc3QgcG9pbnQgZG9lc24ndCBlcXVhbCB0aGUgY3VycmVudCBwb2ludCBhZGQgdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgIGlmICghbGFzdFBvaW50IHx8IHB4ICE9IGxhc3RQb2ludC54IHx8IHB5ICE9IGxhc3RQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQb2ludCAmJiBpc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGx4ID0gbGFzdFBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgIGx5ID0gbGFzdFBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBseSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBseCArIHB4LFxuICAgICAgICAgICAgICAgICAgICB5OiBseSArIHB5XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBsYXN0IHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVsYXRpdmUgfHwgIWxhc3RQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgICAgICAgICAgICB4ID0gbHggKyBweDtcbiAgICAgICAgICAgICAgICB5ID0gbHkgKyBweTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRkU2VnbWVudFBvaW50ID0gZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIHNlZ1R5cGUgPSBzZWdtZW50LnBhdGhTZWdUeXBlQXNMZXR0ZXIudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gc2tpcCBwYXRoIGVuZHNcbiAgICAgICAgICAgIGlmIChzZWdUeXBlID09PSAnWicpIFxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gbWFwIHNlZ21lbnQgdG8geCBhbmQgeVxuICAgICAgICAgICAgc3dpdGNoIChzZWdUeXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICB4ID0gc2VnbWVudC54O1xuICAgICAgICAgICAgICAgIHkgPSBzZWdtZW50Lnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICB4ID0gc2VnbWVudC54O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgeSA9IHNlZ21lbnQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkUG9pbnQoeCwgeSwgc2VnbWVudC5wYXRoU2VnVHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZW5zdXJlIHBhdGggaXMgYWJzb2x1dGVcbiAgICAgICAgX3N2Z1BhdGhUb0Fic29sdXRlKHBhdGgpO1xuXG4gICAgICAgIC8vIGdldCB0b3RhbCBsZW5ndGhcbiAgICAgICAgdG90YWwgPSBwYXRoLmdldFRvdGFsTGVuZ3RoKCk7XG5cbiAgICAgICAgLy8gcXVldWUgc2VnbWVudHNcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGgucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtczsgaSArPSAxKVxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChwYXRoLnBhdGhTZWdMaXN0LmdldEl0ZW0oaSkpO1xuXG4gICAgICAgIHNlZ21lbnRzUXVldWUgPSBzZWdtZW50cy5jb25jYXQoKTtcblxuICAgICAgICAvLyBzYW1wbGUgdGhyb3VnaCBwYXRoXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0b3RhbCkge1xuICAgICAgICAgICAgLy8gZ2V0IHNlZ21lbnQgYXQgcG9zaXRpb25cbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IHBhdGguZ2V0UGF0aFNlZ0F0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcblxuICAgICAgICAgICAgLy8gbmV3IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChzZWdtZW50ICE9IGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlZ21lbnRzUXVldWUubGVuZ3RoICYmIHNlZ21lbnRzUXVldWVbMF0gIT0gc2VnbWVudClcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VnbWVudFBvaW50KHNlZ21lbnRzUXVldWUuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBwb2ludHMgaW4gYmV0d2VlbiB3aGVuIGN1cnZpbmdcbiAgICAgICAgICAgIC8vIFRPRE86IGFkYXB0aXZlIHNhbXBsaW5nXG4gICAgICAgICAgICBzd2l0Y2ggKHNlZ21lbnQucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwYXRoLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhZGRQb2ludChwb2ludC54LCBwb2ludC55LCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYnkgc2FtcGxlIHZhbHVlXG4gICAgICAgICAgICBsZW5ndGggKz0gc2FtcGxlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyBzZWdtZW50cyBub3QgcGFzc2VkIGJ5IHNhbXBsaW5nXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gc2VnbWVudHNRdWV1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxuICAgICAgICAgICAgYWRkU2VnbWVudFBvaW50KHNlZ21lbnRzUXVldWVbaV0pO1xuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcblxuICAgIHZhciBfc3ZnUGF0aFRvQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9waHJvZ3oubmV0L2NvbnZlcnQtc3ZnLXBhdGgtdG8tYWxsLWFic29sdXRlLWNvbW1hbmRzXG4gICAgICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBzZWdzID0gcGF0aC5wYXRoU2VnTGlzdCxcbiAgICAgICAgICAgIHggPSAwLCB5ID0gMCwgbGVuID0gc2Vncy5udW1iZXJPZkl0ZW1zO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzLmdldEl0ZW0oaSksXG4gICAgICAgICAgICAgICAgc2VnVHlwZSA9IHNlZy5wYXRoU2VnVHlwZUFzTGV0dGVyO1xuXG4gICAgICAgICAgICBpZiAoL1tNTEhWQ1NRVEFdLy50ZXN0KHNlZ1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSA9IHNlZy55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3gxJyBpbiBzZWcpIHgxID0geCArIHNlZy54MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3gyJyBpbiBzZWcpIHgyID0geCArIHNlZy54MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3kxJyBpbiBzZWcpIHkxID0geSArIHNlZy55MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3kyJyBpbiBzZWcpIHkyID0geSArIHNlZy55MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3gnIGluIHNlZykgeCArPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSArPSBzZWcueTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyh4KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzKHgsIHksIHgxLCB5MSwgeDIsIHkyKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyh4LCB5LCB4MiwgeTIpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh4LCB5LCB4MSwgeTEpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicyh4LCB5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0FyY0Ficyh4LCB5LCBzZWcucjEsIHNlZy5yMiwgc2VnLmFuZ2xlLCBzZWcubGFyZ2VBcmNGbGFnLCBzZWcuc3dlZXBGbGFnKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICB4ID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdUeXBlID09ICdNJyB8fCBzZWdUeXBlID09ICdtJykge1xuICAgICAgICAgICAgICAgIHgwID0geDtcbiAgICAgICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qc1xuLy8gbW9kdWxlIGlkID0gNTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL2dlb21ldHJ5L1N2Zy5qcyIsInZhciBNYXR0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2NvcmUvTWF0dGVyJyk7XHJcblxyXG5NYXR0ZXIuQm9keSA9IHJlcXVpcmUoJy4uL2JvZHkvQm9keScpO1xyXG5NYXR0ZXIuQ29tcG9zaXRlID0gcmVxdWlyZSgnLi4vYm9keS9Db21wb3NpdGUnKTtcclxuTWF0dGVyLldvcmxkID0gcmVxdWlyZSgnLi4vYm9keS9Xb3JsZCcpO1xyXG5cclxuTWF0dGVyLkNvbnRhY3QgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQ29udGFjdCcpO1xyXG5NYXR0ZXIuRGV0ZWN0b3IgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vRGV0ZWN0b3InKTtcclxuTWF0dGVyLkdyaWQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vR3JpZCcpO1xyXG5NYXR0ZXIuUGFpcnMgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUGFpcnMnKTtcclxuTWF0dGVyLlBhaXIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUGFpcicpO1xyXG5NYXR0ZXIuUXVlcnkgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUXVlcnknKTtcclxuTWF0dGVyLlJlc29sdmVyID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1Jlc29sdmVyJyk7XHJcbk1hdHRlci5TQVQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vU0FUJyk7XHJcblxyXG5NYXR0ZXIuQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnQvQ29uc3RyYWludCcpO1xyXG5NYXR0ZXIuTW91c2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludC9Nb3VzZUNvbnN0cmFpbnQnKTtcclxuXHJcbk1hdHRlci5Db21tb24gPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1vbicpO1xyXG5NYXR0ZXIuRW5naW5lID0gcmVxdWlyZSgnLi4vY29yZS9FbmdpbmUnKTtcclxuTWF0dGVyLkV2ZW50cyA9IHJlcXVpcmUoJy4uL2NvcmUvRXZlbnRzJyk7XHJcbk1hdHRlci5Nb3VzZSA9IHJlcXVpcmUoJy4uL2NvcmUvTW91c2UnKTtcclxuTWF0dGVyLlJ1bm5lciA9IHJlcXVpcmUoJy4uL2NvcmUvUnVubmVyJyk7XHJcbk1hdHRlci5TbGVlcGluZyA9IHJlcXVpcmUoJy4uL2NvcmUvU2xlZXBpbmcnKTtcclxuTWF0dGVyLlBsdWdpbiA9IHJlcXVpcmUoJy4uL2NvcmUvUGx1Z2luJyk7XHJcblxyXG4vLyBAaWYgREVCVUdcclxuTWF0dGVyLk1ldHJpY3MgPSByZXF1aXJlKCcuLi9jb3JlL01ldHJpY3MnKTtcclxuLy8gQGVuZGlmXHJcblxyXG5NYXR0ZXIuQm9kaWVzID0gcmVxdWlyZSgnLi4vZmFjdG9yeS9Cb2RpZXMnKTtcclxuTWF0dGVyLkNvbXBvc2l0ZXMgPSByZXF1aXJlKCcuLi9mYWN0b3J5L0NvbXBvc2l0ZXMnKTtcclxuXHJcbk1hdHRlci5BeGVzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQXhlcycpO1xyXG5NYXR0ZXIuQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvbWV0cnkvQm91bmRzJyk7XHJcbk1hdHRlci5TdmcgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9TdmcnKTtcclxuTWF0dGVyLlZlY3RvciA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L1ZlY3RvcicpO1xyXG5NYXR0ZXIuVmVydGljZXMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZXJ0aWNlcycpO1xyXG5cclxuTWF0dGVyLlJlbmRlciA9IHJlcXVpcmUoJy4uL3JlbmRlci9SZW5kZXInKTtcclxuTWF0dGVyLlJlbmRlclBpeGkgPSByZXF1aXJlKCcuLi9yZW5kZXIvUmVuZGVyUGl4aScpO1xyXG5cclxuLy8gYWxpYXNlc1xyXG5cclxuTWF0dGVyLldvcmxkLmFkZCA9IE1hdHRlci5Db21wb3NpdGUuYWRkO1xyXG5NYXR0ZXIuV29ybGQucmVtb3ZlID0gTWF0dGVyLkNvbXBvc2l0ZS5yZW1vdmU7XHJcbk1hdHRlci5Xb3JsZC5hZGRDb21wb3NpdGUgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZENvbXBvc2l0ZTtcclxuTWF0dGVyLldvcmxkLmFkZEJvZHkgPSBNYXR0ZXIuQ29tcG9zaXRlLmFkZEJvZHk7XHJcbk1hdHRlci5Xb3JsZC5hZGRDb25zdHJhaW50ID0gTWF0dGVyLkNvbXBvc2l0ZS5hZGRDb25zdHJhaW50O1xyXG5NYXR0ZXIuV29ybGQuY2xlYXIgPSBNYXR0ZXIuQ29tcG9zaXRlLmNsZWFyO1xyXG5NYXR0ZXIuRW5naW5lLnJ1biA9IE1hdHRlci5SdW5uZXIucnVuO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waHlzaWNzL21hdHRlci1qcy9tb2R1bGUvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BoeXNpY3MvbWF0dGVyLWpzL21vZHVsZS9tYWluLmpzIiwiLyoqXG4qIFRoZSBgTWF0dGVyLlJlbmRlclBpeGlgIG1vZHVsZSBpcyBhbiBleGFtcGxlIHJlbmRlcmVyIHVzaW5nIHBpeGkuanMuXG4qIFNlZSBhbHNvIGBNYXR0ZXIuUmVuZGVyYCBmb3IgYSBjYW52YXMgYmFzZWQgcmVuZGVyZXIuXG4qXG4qIEBjbGFzcyBSZW5kZXJQaXhpXG4qIEBkZXByZWNhdGVkIHRoZSBNYXR0ZXIuUmVuZGVyUGl4aSBtb2R1bGUgd2lsbCBzb29uIGJlIHJlbW92ZWQgZnJvbSB0aGUgTWF0dGVyLmpzIGNvcmUuXG4qIEl0IHdpbGwgbGlrZWx5IGJlIG1vdmVkIHRvIGl0cyBvd24gcmVwb3NpdG9yeSAoYnV0IG1haW50ZW5hbmNlIHdpbGwgYmUgbGltaXRlZCkuXG4qL1xuXG52YXIgUmVuZGVyUGl4aSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclBpeGk7XG5cbnZhciBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbnZhciBDb21wb3NpdGUgPSByZXF1aXJlKCcuLi9ib2R5L0NvbXBvc2l0ZScpO1xudmFyIENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbW9uJyk7XG52YXIgRXZlbnRzID0gcmVxdWlyZSgnLi4vY29yZS9FdmVudHMnKTtcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9WZWN0b3InKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbihjYWxsYmFjayl7IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhDb21tb24ubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xuICAgXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQaXhpLmpzIFdlYkdMIHJlbmRlcmVyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlbmRlclBpeGl9IEEgbmV3IHJlbmRlcmVyXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBSZW5kZXJQaXhpLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgQ29tbW9uLndhcm4oJ1JlbmRlclBpeGkuY3JlYXRlOiBNYXR0ZXIuUmVuZGVyUGl4aSBpcyBkZXByZWNhdGVkIChzZWUgZG9jcyknKTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb250cm9sbGVyOiBSZW5kZXJQaXhpLFxuICAgICAgICAgICAgZW5naW5lOiBudWxsLFxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgY2FudmFzOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICBzcHJpdGVDb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICBwaXhpT3B0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmFmYWZhJyxcbiAgICAgICAgICAgICAgICB3aXJlZnJhbWVCYWNrZ3JvdW5kOiAnIzIyMicsXG4gICAgICAgICAgICAgICAgaGFzQm91bmRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd1NsZWVwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0Jyb2FkcGhhc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCb3VuZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0NvbGxpc2lvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dBeGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93UG9zaXRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QW5nbGVJbmRpY2F0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dJZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dTaGFkb3dzOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW5kZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50ID0gIXJlbmRlci5vcHRpb25zLndpcmVmcmFtZXMgJiYgcmVuZGVyLm9wdGlvbnMuYmFja2dyb3VuZCA9PT0gJ3RyYW5zcGFyZW50JztcblxuICAgICAgICAvLyBpbml0IHBpeGlcbiAgICAgICAgcmVuZGVyLnBpeGlPcHRpb25zID0gcmVuZGVyLnBpeGlPcHRpb25zIHx8IHtcbiAgICAgICAgICAgIHZpZXc6IHJlbmRlci5jYW52YXMsXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlbmRlci5tb3VzZSA9IG9wdGlvbnMubW91c2U7XG4gICAgICAgIHJlbmRlci5lbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcbiAgICAgICAgcmVuZGVyLnJlbmRlcmVyID0gcmVuZGVyLnJlbmRlcmVyIHx8IG5ldyBQSVhJLldlYkdMUmVuZGVyZXIocmVuZGVyLm9wdGlvbnMud2lkdGgsIHJlbmRlci5vcHRpb25zLmhlaWdodCwgcmVuZGVyLnBpeGlPcHRpb25zKTtcbiAgICAgICAgcmVuZGVyLmNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIgfHwgbmV3IFBJWEkuQ29udGFpbmVyKCk7XG4gICAgICAgIHJlbmRlci5zcHJpdGVDb250YWluZXIgPSByZW5kZXIuc3ByaXRlQ29udGFpbmVyIHx8IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICAgICAgICByZW5kZXIuY2FudmFzID0gcmVuZGVyLmNhbnZhcyB8fCByZW5kZXIucmVuZGVyZXIudmlldztcbiAgICAgICAgcmVuZGVyLmJvdW5kcyA9IHJlbmRlci5ib3VuZHMgfHwgeyBcbiAgICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICBtYXg6IHsgXG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogcmVuZGVyLm9wdGlvbnMuaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIEV2ZW50cy5vbihyZW5kZXIuZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBSZW5kZXJQaXhpLmNsZWFyKHJlbmRlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhY2hlc1xuICAgICAgICByZW5kZXIudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgcmVuZGVyLnNwcml0ZXMgPSB7fTtcbiAgICAgICAgcmVuZGVyLnByaW1pdGl2ZXMgPSB7fTtcblxuICAgICAgICAvLyB1c2UgYSBzcHJpdGUgYmF0Y2ggZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIHJlbmRlci5jb250YWluZXIuYWRkQ2hpbGQocmVuZGVyLnNwcml0ZUNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gaW5zZXJ0IGNhbnZhc1xuICAgICAgICBpZiAoQ29tbW9uLmlzRWxlbWVudChyZW5kZXIuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJlbmRlci5lbGVtZW50LmFwcGVuZENoaWxkKHJlbmRlci5jYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ05vIFwicmVuZGVyLmVsZW1lbnRcIiBwYXNzZWQsIFwicmVuZGVyLmNhbnZhc1wiIHdhcyBub3QgaW5zZXJ0ZWQgaW50byBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgbWVudXMgb24gY2FudmFzXG4gICAgICAgIHJlbmRlci5jYW52YXMub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIHJlbmRlci5jYW52YXMub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHVwZGF0ZXMgdGhlIHJlbmRlciBjYW52YXMgb24gdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGV2ZW50LlxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5ydW4gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AodGltZSl7XG4gICAgICAgICAgICByZW5kZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgUmVuZGVyUGl4aS53b3JsZChyZW5kZXIpO1xuICAgICAgICB9KSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXIuZnJhbWVSZXF1ZXN0SWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHNjZW5lIGdyYXBoXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBSZW5kZXJQaXhpLmNsZWFyID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyLFxuICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyID0gcmVuZGVyLnNwcml0ZUNvbnRhaW5lcjtcblxuICAgICAgICAvLyBjbGVhciBzdGFnZSBjb250YWluZXJcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5jaGlsZHJlblswXSkgeyBcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuY2hpbGRyZW5bMF0pOyBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHNwcml0ZSBiYXRjaFxuICAgICAgICB3aGlsZSAoc3ByaXRlQ29udGFpbmVyLmNoaWxkcmVuWzBdKSB7IFxuICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNwcml0ZUNvbnRhaW5lci5jaGlsZHJlblswXSk7IFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnU3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbJ2JnLTAnXTtcblxuICAgICAgICAvLyBjbGVhciBjYWNoZXNcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XG4gICAgICAgIHJlbmRlci5zcHJpdGVzID0ge307XG4gICAgICAgIHJlbmRlci5wcmltaXRpdmVzID0ge307XG5cbiAgICAgICAgLy8gc2V0IGJhY2tncm91bmQgc3ByaXRlXG4gICAgICAgIHJlbmRlci5zcHJpdGVzWydiZy0wJ10gPSBiZ1Nwcml0ZTtcbiAgICAgICAgaWYgKGJnU3ByaXRlKVxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkQXQoYmdTcHJpdGUsIDApO1xuXG4gICAgICAgIC8vIGFkZCBzcHJpdGUgYmF0Y2ggYmFjayBpbnRvIGNvbnRhaW5lclxuICAgICAgICByZW5kZXIuY29udGFpbmVyLmFkZENoaWxkKHJlbmRlci5zcHJpdGVDb250YWluZXIpO1xuXG4gICAgICAgIC8vIHJlc2V0IGJhY2tncm91bmQgc3RhdGVcbiAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gbnVsbDtcblxuICAgICAgICAvLyByZXNldCBib3VuZHMgdHJhbnNmb3Jtc1xuICAgICAgICBjb250YWluZXIuc2NhbGUuc2V0KDEsIDEpO1xuICAgICAgICBjb250YWluZXIucG9zaXRpb24uc2V0KDAsIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBjYW52YXMgXG4gICAgICogQG1ldGhvZCBzZXRCYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtSZW5kZXJQaXhpfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24ocmVuZGVyLCBiYWNrZ3JvdW5kKSB7XG4gICAgICAgIGlmIChyZW5kZXIuY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHZhciBpc0NvbG9yID0gYmFja2dyb3VuZC5pbmRleE9mICYmIGJhY2tncm91bmQuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBiZ1Nwcml0ZSA9IHJlbmRlci5zcHJpdGVzWydiZy0wJ107XG5cbiAgICAgICAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc29saWQgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IENvbW1vbi5jb2xvclRvTnVtYmVyKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgICAgIHJlbmRlci5yZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBiYWNrZ3JvdW5kIHNwcml0ZSBpZiBleGlzdGluZ1xuICAgICAgICAgICAgICAgIGlmIChiZ1Nwcml0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNvbnRhaW5lci5yZW1vdmVDaGlsZChiZ1Nwcml0ZSk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXNlIGJhY2tncm91bmQgc3ByaXRlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICghYmdTcHJpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIGJhY2tncm91bmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJnU3ByaXRlID0gcmVuZGVyLnNwcml0ZXNbJ2JnLTAnXSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYmdTcHJpdGUucG9zaXRpb24ueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJnU3ByaXRlLnBvc2l0aW9uLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIuY29udGFpbmVyLmFkZENoaWxkQXQoYmdTcHJpdGUsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBtZXRob2Qgd29ybGRcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBSZW5kZXJQaXhpLndvcmxkID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICByZW5kZXJlciA9IHJlbmRlci5yZW5kZXJlcixcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlbmRlci5jb250YWluZXIsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcbiAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKHdvcmxkKSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gW10sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIFJlbmRlclBpeGkuc2V0QmFja2dyb3VuZChyZW5kZXIsIG9wdGlvbnMud2lyZWZyYW1lQmFja2dyb3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZW5kZXJQaXhpLnNldEJhY2tncm91bmQocmVuZGVyLCBvcHRpb25zLmJhY2tncm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIGJvdW5kc1xuICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgYm91bmRzU2NhbGVYID0gYm91bmRzV2lkdGggLyByZW5kZXIub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcblxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIC8vIEhpZGUgYm9kaWVzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnZpc2libGUgPSBCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIHJlbmRlci5ib3VuZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGNvbnN0cmFpbnRzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGFsbENvbnN0cmFpbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBV29ybGQgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBjb25zdHJhaW50LnBvaW50QjtcblxuICAgICAgICAgICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSBwb2ludEJXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRBV29ybGQpIHx8IEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEJXb3JsZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgdmlld1xuICAgICAgICAgICAgY29udGFpbmVyLnNjYWxlLnNldCgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wb3NpdGlvbi5zZXQoLXJlbmRlci5ib3VuZHMubWluLnggKiAoMSAvIGJvdW5kc1NjYWxlWCksIC1yZW5kZXIuYm91bmRzLm1pbi55ICogKDEgLyBib3VuZHNTY2FsZVkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYWxsQ29uc3RyYWludHM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgUmVuZGVyUGl4aS5ib2R5KHJlbmRlciwgYm9kaWVzW2ldKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBSZW5kZXJQaXhpLmNvbnN0cmFpbnQocmVuZGVyLCBjb25zdHJhaW50c1tpXSk7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKGNvbnRhaW5lcik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAbWV0aG9kIGNvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBSZW5kZXJQaXhpLmNvbnN0cmFpbnQgPSBmdW5jdGlvbihyZW5kZXIsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICBwb2ludEEgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgIHBvaW50QiA9IGNvbnN0cmFpbnQucG9pbnRCLFxuICAgICAgICAgICAgY29udGFpbmVyID0gcmVuZGVyLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGNvbnN0cmFpbnRSZW5kZXIgPSBjb25zdHJhaW50LnJlbmRlcixcbiAgICAgICAgICAgIHByaW1pdGl2ZUlkID0gJ2MtJyArIGNvbnN0cmFpbnQuaWQsXG4gICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF07XG5cbiAgICAgICAgLy8gaW5pdGlhbGlzZSBjb25zdHJhaW50IHByaW1pdGl2ZSBpZiBub3QgZXhpc3RpbmdcbiAgICAgICAgaWYgKCFwcmltaXRpdmUpXG4gICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF0gPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXG4gICAgICAgIC8vIGRvbid0IHJlbmRlciBpZiBjb25zdHJhaW50IGRvZXMgbm90IGhhdmUgdHdvIGVuZCBwb2ludHNcbiAgICAgICAgaWYgKCFjb25zdHJhaW50UmVuZGVyLnZpc2libGUgfHwgIWNvbnN0cmFpbnQucG9pbnRBIHx8ICFjb25zdHJhaW50LnBvaW50Qikge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdG8gc2NlbmUgZ3JhcGggaWYgbm90IGFscmVhZHkgdGhlcmVcbiAgICAgICAgaWYgKENvbW1vbi5pbmRleE9mKGNvbnRhaW5lci5jaGlsZHJlbiwgcHJpbWl0aXZlKSA9PT0gLTEpXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQocHJpbWl0aXZlKTtcblxuICAgICAgICAvLyByZW5kZXIgdGhlIGNvbnN0cmFpbnQgb24gZXZlcnkgdXBkYXRlLCBzaW5jZSB0aGV5IGNhbiBjaGFuZ2UgZHluYW1pY2FsbHlcbiAgICAgICAgcHJpbWl0aXZlLmNsZWFyKCk7XG4gICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoMCwgMCk7XG4gICAgICAgIHByaW1pdGl2ZS5saW5lU3R5bGUoY29uc3RyYWludFJlbmRlci5saW5lV2lkdGgsIENvbW1vbi5jb2xvclRvTnVtYmVyKGNvbnN0cmFpbnRSZW5kZXIuc3Ryb2tlU3R5bGUpLCAxKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChib2R5QSkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLm1vdmVUbyhib2R5QS5wb3NpdGlvbi54ICsgcG9pbnRBLngsIGJvZHlBLnBvc2l0aW9uLnkgKyBwb2ludEEueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmltaXRpdmUubW92ZVRvKHBvaW50QS54LCBwb2ludEEueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keUIpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5saW5lVG8oYm9keUIucG9zaXRpb24ueCArIHBvaW50Qi54LCBib2R5Qi5wb3NpdGlvbi55ICsgcG9pbnRCLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVUbyhwb2ludEIueCwgcG9pbnRCLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpbWl0aXZlLmVuZEZpbGwoKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQG1ldGhvZCBib2R5XG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVuZGVyUGl4aS5ib2R5ID0gZnVuY3Rpb24ocmVuZGVyLCBib2R5KSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgYm9keVJlbmRlciA9IGJvZHkucmVuZGVyO1xuXG4gICAgICAgIGlmICghYm9keVJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmIChib2R5UmVuZGVyLnNwcml0ZSAmJiBib2R5UmVuZGVyLnNwcml0ZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlSWQgPSAnYi0nICsgYm9keS5pZCxcbiAgICAgICAgICAgICAgICBzcHJpdGUgPSByZW5kZXIuc3ByaXRlc1tzcHJpdGVJZF0sXG4gICAgICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyID0gcmVuZGVyLnNwcml0ZUNvbnRhaW5lcjtcblxuICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBib2R5IHNwcml0ZSBpZiBub3QgZXhpc3RpbmdcbiAgICAgICAgICAgIGlmICghc3ByaXRlKVxuICAgICAgICAgICAgICAgIHNwcml0ZSA9IHJlbmRlci5zcHJpdGVzW3Nwcml0ZUlkXSA9IF9jcmVhdGVCb2R5U3ByaXRlKHJlbmRlciwgYm9keSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0byBzY2VuZSBncmFwaCBpZiBub3QgYWxyZWFkeSB0aGVyZVxuICAgICAgICAgICAgaWYgKENvbW1vbi5pbmRleE9mKHNwcml0ZUNvbnRhaW5lci5jaGlsZHJlbiwgc3ByaXRlKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgc3ByaXRlQ29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBib2R5IHNwcml0ZVxuICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICBzcHJpdGUucG9zaXRpb24ueSA9IGJvZHkucG9zaXRpb24ueTtcbiAgICAgICAgICAgIHNwcml0ZS5yb3RhdGlvbiA9IGJvZHkuYW5nbGU7XG4gICAgICAgICAgICBzcHJpdGUuc2NhbGUueCA9IGJvZHlSZW5kZXIuc3ByaXRlLnhTY2FsZSB8fCAxO1xuICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnkgPSBib2R5UmVuZGVyLnNwcml0ZS55U2NhbGUgfHwgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmltaXRpdmVJZCA9ICdiLScgKyBib2R5LmlkLFxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZSA9IHJlbmRlci5wcmltaXRpdmVzW3ByaW1pdGl2ZUlkXSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSByZW5kZXIuY29udGFpbmVyO1xuXG4gICAgICAgICAgICAvLyBpbml0aWFsaXNlIGJvZHkgcHJpbWl0aXZlIGlmIG5vdCBleGlzdGluZ1xuICAgICAgICAgICAgaWYgKCFwcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUgPSByZW5kZXIucHJpbWl0aXZlc1twcmltaXRpdmVJZF0gPSBfY3JlYXRlQm9keVByaW1pdGl2ZShyZW5kZXIsIGJvZHkpO1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5pbml0aWFsQW5nbGUgPSBib2R5LmFuZ2xlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdG8gc2NlbmUgZ3JhcGggaWYgbm90IGFscmVhZHkgdGhlcmVcbiAgICAgICAgICAgIGlmIChDb21tb24uaW5kZXhPZihjb250YWluZXIuY2hpbGRyZW4sIHByaW1pdGl2ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChwcmltaXRpdmUpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm9keSBwcmltaXRpdmVcbiAgICAgICAgICAgIHByaW1pdGl2ZS5wb3NpdGlvbi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgcHJpbWl0aXZlLnBvc2l0aW9uLnkgPSBib2R5LnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBwcmltaXRpdmUucm90YXRpb24gPSBib2R5LmFuZ2xlIC0gcHJpbWl0aXZlLmluaXRpYWxBbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm9keSBzcHJpdGVcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVCb2R5U3ByaXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBzcHJpdGVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHZhciBfY3JlYXRlQm9keVNwcml0ZSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9keSkge1xuICAgICAgICB2YXIgYm9keVJlbmRlciA9IGJvZHkucmVuZGVyLFxuICAgICAgICAgICAgdGV4dHVyZVBhdGggPSBib2R5UmVuZGVyLnNwcml0ZS50ZXh0dXJlLFxuICAgICAgICAgICAgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgdGV4dHVyZVBhdGgpLFxuICAgICAgICAgICAgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuXG4gICAgICAgIHNwcml0ZS5hbmNob3IueCA9IGJvZHkucmVuZGVyLnNwcml0ZS54T2Zmc2V0O1xuICAgICAgICBzcHJpdGUuYW5jaG9yLnkgPSBib2R5LnJlbmRlci5zcHJpdGUueU9mZnNldDtcblxuICAgICAgICByZXR1cm4gc3ByaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm9keSBwcmltaXRpdmVcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVCb2R5UHJpbWl0aXZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbmRlclBpeGl9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICB2YXIgX2NyZWF0ZUJvZHlQcmltaXRpdmUgPSBmdW5jdGlvbihyZW5kZXIsIGJvZHkpIHtcbiAgICAgICAgdmFyIGJvZHlSZW5kZXIgPSBib2R5LnJlbmRlcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIHByaW1pdGl2ZSA9IG5ldyBQSVhJLkdyYXBoaWNzKCksXG4gICAgICAgICAgICBmaWxsU3R5bGUgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLmZpbGxTdHlsZSksXG4gICAgICAgICAgICBzdHJva2VTdHlsZSA9IENvbW1vbi5jb2xvclRvTnVtYmVyKGJvZHlSZW5kZXIuc3Ryb2tlU3R5bGUpLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGVJbmRpY2F0b3IgPSBDb21tb24uY29sb3JUb051bWJlcihib2R5UmVuZGVyLnN0cm9rZVN0eWxlKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlV2lyZWZyYW1lID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoJyNiYmInKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlV2lyZWZyYW1lSW5kaWNhdG9yID0gQ29tbW9uLmNvbG9yVG9OdW1iZXIoJyNDRDVDNUMnKSxcbiAgICAgICAgICAgIHBhcnQ7XG5cbiAgICAgICAgcHJpbWl0aXZlLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgIGZvciAodmFyIGsgPSBib2R5LnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IGJvZHkucGFydHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoZmlsbFN0eWxlLCAxKTtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKGJvZHlSZW5kZXIubGluZVdpZHRoLCBzdHJva2VTdHlsZSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5iZWdpbkZpbGwoMCwgMCk7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVTdHlsZSgxLCBzdHJva2VTdHlsZVdpcmVmcmFtZSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByaW1pdGl2ZS5tb3ZlVG8ocGFydC52ZXJ0aWNlc1swXS54IC0gYm9keS5wb3NpdGlvbi54LCBwYXJ0LnZlcnRpY2VzWzBdLnkgLSBib2R5LnBvc2l0aW9uLnkpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKHBhcnQudmVydGljZXNbal0ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC52ZXJ0aWNlc1tqXS55IC0gYm9keS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJpbWl0aXZlLmxpbmVUbyhwYXJ0LnZlcnRpY2VzWzBdLnggLSBib2R5LnBvc2l0aW9uLngsIHBhcnQudmVydGljZXNbMF0ueSAtIGJvZHkucG9zaXRpb24ueSk7XG5cbiAgICAgICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XG5cbiAgICAgICAgICAgIC8vIGFuZ2xlIGluZGljYXRvclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0FuZ2xlSW5kaWNhdG9yIHx8IG9wdGlvbnMuc2hvd0F4ZXMpIHtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUuYmVnaW5GaWxsKDAsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKDEsIHN0cm9rZVN0eWxlV2lyZWZyYW1lSW5kaWNhdG9yLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVN0eWxlKDEsIHN0cm9rZVN0eWxlSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubW92ZVRvKHBhcnQucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUubGluZVRvKCgocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIgLSBib2R5LnBvc2l0aW9uLngpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocGFydC52ZXJ0aWNlc1swXS55ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS55KSAvIDIgLSBib2R5LnBvc2l0aW9uLnkpKTtcblxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5lbmRGaWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXF1ZXN0ZWQgdGV4dHVyZSAoYSBQSVhJLlRleHR1cmUpIHZpYSBpdHMgcGF0aFxuICAgICAqIEBtZXRob2QgX2dldFRleHR1cmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVuZGVyUGl4aX0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlUGF0aFxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgdmFyIF9nZXRUZXh0dXJlID0gZnVuY3Rpb24ocmVuZGVyLCBpbWFnZVBhdGgpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXTtcblxuICAgICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgICAgICB0ZXh0dXJlID0gcmVuZGVyLnRleHR1cmVzW2ltYWdlUGF0aF0gPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKGltYWdlUGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BoeXNpY3MvbWF0dGVyLWpzL3JlbmRlci9SZW5kZXJQaXhpLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGh5c2ljcy9tYXR0ZXItanMvcmVuZGVyL1JlbmRlclBpeGkuanMiLCIvKipcbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogQSBwb2x5ZmlsbCBmb3IgQXJyYXkuZm9yRWFjaFxuKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4qL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaClcbntcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pXG4gICAge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5mb3JFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIEEgcG9seWZpbGwgZm9yIEFycmF5LmlzQXJyYXlcbiovXG5pZiAoIUFycmF5LmlzQXJyYXkpXG57XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpXG4gICAge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9BcnJheS5pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogQ29weXJpZ2h0IDIwMTMgQ2hyaXMgV2lsc29uXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLypcblxuVGhpcyBtb25rZXlwYXRjaCBsaWJyYXJ5IGlzIGludGVuZGVkIHRvIGJlIGluY2x1ZGVkIGluIHByb2plY3RzIHRoYXQgYXJlXG53cml0dGVuIHRvIHRoZSBwcm9wZXIgQXVkaW9Db250ZXh0IHNwZWMgKGluc3RlYWQgb2Ygd2Via2l0QXVkaW9Db250ZXh0KSxcbmFuZCB0aGF0IHVzZSB0aGUgbmV3IG5hbWluZyBhbmQgcHJvcGVyIGJpdHMgb2YgdGhlIFdlYiBBdWRpbyBBUEkgKGUuZy5cbnVzaW5nIEJ1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpbnN0ZWFkIG9mIEJ1ZmZlclNvdXJjZU5vZGUubm90ZU9uKCkpLCBidXQgbWF5XG5oYXZlIHRvIHJ1biBvbiBzeXN0ZW1zIHRoYXQgb25seSBzdXBwb3J0IHRoZSBkZXByZWNhdGVkIGJpdHMuXG5cblRoaXMgbGlicmFyeSBzaG91bGQgYmUgaGFybWxlc3MgdG8gaW5jbHVkZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0c1xudW5wcmVmaXhlZCBcIkF1ZGlvQ29udGV4dFwiLCBhbmQvb3IgaWYgaXQgc3VwcG9ydHMgdGhlIG5ldyBuYW1lcy5cblxuVGhlIHBhdGNoZXMgdGhpcyBsaWJyYXJ5IGhhbmRsZXM6XG5pZiB3aW5kb3cuQXVkaW9Db250ZXh0IGlzIHVuc3VwcG9ydGVkLCBpdCB3aWxsIGJlIGFsaWFzZWQgdG8gd2Via2l0QXVkaW9Db250ZXh0KCkuXG5pZiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKSBpcyB1bmltcGxlbWVudGVkLCBpdCB3aWxsIGJlIHJvdXRlZCB0byBub3RlT24oKSBvclxubm90ZUdyYWluT24oKSwgZGVwZW5kaW5nIG9uIHBhcmFtZXRlcnMuXG5cblRoZSBmb2xsb3dpbmcgYWxpYXNlcyBvbmx5IHRha2UgZWZmZWN0IGlmIHRoZSBuZXcgbmFtZXMgYXJlIG5vdCBhbHJlYWR5IGluIHBsYWNlOlxuXG5BdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5BdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlR2Fpbk5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCkgaXMgYWxpYXNlZCB0byBjcmVhdGVEZWxheU5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpIGlzIGFsaWFzZWQgdG8gY3JlYXRlSmF2YVNjcmlwdE5vZGUoKVxuQXVkaW9Db250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZSgpIGlzIGFsaWFzZWQgdG8gY3JlYXRlV2F2ZVRhYmxlKClcbk9zY2lsbGF0b3JOb2RlLnN0YXJ0KCkgaXMgYWxpYXNlZCB0byBub3RlT24oKVxuT3NjaWxsYXRvck5vZGUuc3RvcCgpIGlzIGFsaWFzZWQgdG8gbm90ZU9mZigpXG5Pc2NpbGxhdG9yTm9kZS5zZXRQZXJpb2RpY1dhdmUoKSBpcyBhbGlhc2VkIHRvIHNldFdhdmVUYWJsZSgpXG5BdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSgpIGlzIGFsaWFzZWQgdG8gc2V0VGFyZ2V0VmFsdWVBdFRpbWUoKVxuXG5UaGlzIGxpYnJhcnkgZG9lcyBOT1QgcGF0Y2ggdGhlIGVudW1lcmF0ZWQgdHlwZSBjaGFuZ2VzLCBhcyBpdCBpc1xucmVjb21tZW5kZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gdGhhdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCBib3RoIGludGVnZXJcbmFuZCBzdHJpbmcgdHlwZXMgZm9yIEF1ZGlvUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwsIEF1ZGlvUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsXG5CaXF1YWRGaWx0ZXJOb2RlLnR5cGUgYW5kIE9zY2lsbGF0b3JOb2RlLnR5cGUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZXhwb3J0cywgcGVyZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZml4U2V0VGFyZ2V0KHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbSlcdC8vIGlmIE5ZSSwganVzdCByZXR1cm5cbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXBhcmFtLnNldFRhcmdldEF0VGltZSlcbiAgICAgIHBhcmFtLnNldFRhcmdldEF0VGltZSA9IHBhcmFtLnNldFRhcmdldFZhbHVlQXRUaW1lO1xuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykgJiZcbiAgICAgICF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpKSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdlYmtpdEF1ZGlvQ29udGV4dDtcblxuICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlR2FpbicpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZURlbGF5JykpXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG4gICAgaWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjcmVhdGVTY3JpcHRQcm9jZXNzb3InKSlcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0Tm9kZTtcbiAgICBpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2NyZWF0ZVBlcmlvZGljV2F2ZScpKVxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcblxuXG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmludGVybmFsX2NyZWF0ZUdhaW4oKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmdhaW4pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5O1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBmdW5jdGlvbihtYXhEZWxheVRpbWUpIHtcbiAgICAgIHZhciBub2RlID0gbWF4RGVsYXlUaW1lID8gdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheShtYXhEZWxheVRpbWUpIDogdGhpcy5pbnRlcm5hbF9jcmVhdGVEZWxheSgpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZGVsYXlUaW1lKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbiApIHtcbiAgICAgICAgICBpZiAoIG9mZnNldCB8fCBkdXJhdGlvbiApXG4gICAgICAgICAgICB0aGlzLm5vdGVHcmFpbk9uKCB3aGVuIHx8IDAsIG9mZnNldCwgZHVyYXRpb24gKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm5vdGVPbiggd2hlbiB8fCAwICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uKCB3aGVuLCBvZmZzZXQsIGR1cmF0aW9uICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgZHVyYXRpb24gIT09ICd1bmRlZmluZWQnIClcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0LCBkdXJhdGlvbiApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCwgb2Zmc2V0IHx8IDAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICB0aGlzLm5vdGVPZmYoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiggd2hlbiApIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUucGxheWJhY2tSYXRlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yO1xuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS50aHJlc2hvbGQpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUua25lZSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5yZWR1Y3Rpb24pO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuYXR0YWNrKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXI7XG4gICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuUSk7XG4gICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBpZiAoQXVkaW9Db250ZXh0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSggJ2NyZWF0ZU9zY2lsbGF0b3InICkpIHtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvcjtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKCB3aGVuICkge1xuICAgICAgICAgICAgdGhpcy5ub3RlT24oIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgbm9kZS5zdGFydCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RhcnQoIHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUuc3RvcCkge1xuICAgICAgICAgIG5vZGUuc3RvcCA9IGZ1bmN0aW9uICggd2hlbiApIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZiggd2hlbiB8fCAwICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AgPSBub2RlLnN0b3A7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24oIHdoZW4gKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFsX3N0b3AoIHdoZW4gfHwgMCApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLnNldFBlcmlvZGljV2F2ZSlcbiAgICAgICAgICBub2RlLnNldFBlcmlvZGljV2F2ZSA9IG5vZGUuc2V0V2F2ZVRhYmxlO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5mcmVxdWVuY3kpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCcpICYmXG4gICAgICAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gIH1cblxufSh3aW5kb3cpKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL0F1ZGlvQ29udGV4dE1vbmtleVBhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXG5pZiAoIU1hdGgudHJ1bmMpIHtcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xuICAgIH07XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuKi9cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcblxuICAgIC8qIGpzaGludCBmcmVlemU6IGZhbHNlICovXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gdGhpcyA6IHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSAoZnVuY3Rpb24gRihwcm90bykge1xuICAgICAgICAgICAgICAgIGlmIChwcm90bylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEYpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IHN1cGVybmV3OiB0cnVlICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSh0YXJnZXQucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5pc0FycmF5XG4qL1xuaWYgKCFBcnJheS5pc0FycmF5KVxue1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAoYXJnKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG59XG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBBcnJheS5mb3JFYWNoXG4qIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcbiovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKVxue1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICAgIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiogTG93LWJ1ZGdldCBGbG9hdDMyQXJyYXkga25vY2stb2ZmLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggUDIuanMgaW4gSUU5XG4qIFNvdXJjZTogaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy81OTg4LXBoYXNlci0xMi1pZTkvXG4qIENhbWVyb24gRm9hbGUgKGh0dHA6Ly93d3cua2liaWJ1LmNvbSlcbiovXG5pZiAodHlwZW9mIHdpbmRvdy5VaW50MzJBcnJheSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwib2JqZWN0XCIpXG57XG4gICAgdmFyIENoZWFwQXJyYXkgPSBmdW5jdGlvbih0eXBlKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IEFycmF5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgIHdpbmRvd1t0eXBlXSA9IGZ1bmN0aW9uKGFyZykge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZykgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQXJyYXkuY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gYXJnO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gYXJnW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3dbdHlwZV0ucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHdpbmRvd1t0eXBlXS5jb25zdHJ1Y3RvciA9IHdpbmRvd1t0eXBlXTtcbiAgICB9O1xuXG4gICAgQ2hlYXBBcnJheSgnRmxvYXQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ1VpbnQzMkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ1VpbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ0ludDE2QXJyYXknKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgQ2hlYXBBcnJheSgnQXJyYXlCdWZmZXInKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cbi8qKlxuICogQWxzbyBmaXggZm9yIHRoZSBhYnNlbnQgY29uc29sZSBpbiBJRTlcbiAqL1xuaWYgKCF3aW5kb3cuY29uc29sZSlcbntcbiAgICB3aW5kb3cuY29uc29sZSA9IHt9O1xuICAgIHdpbmRvdy5jb25zb2xlLmxvZyA9IHdpbmRvdy5jb25zb2xlLmFzc2VydCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB3aW5kb3cuY29uc29sZS53YXJuID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xufVxuXG4vKipcbiAqIHBlcmZvcm1hbmNlLm5vd1xuICovXG4oZnVuY3Rpb24oKXtcblxuICBpZiAoXCJwZXJmb3JtYW5jZVwiIGluIHdpbmRvdyA9PSBmYWxzZSkge1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XG4gIH1cbiAgXG4gIERhdGUubm93ID0gKERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHsgIC8vIHRoYW5rcyBJRThcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfSk7XG5cbiAgaWYgKFwibm93XCIgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IGZhbHNlKVxuICB7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgXG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcbiAgICB9XG5cbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9XG4gIH1cblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9GdW5jdGlvbi5iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA1NzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLy8gRVM2IE1hdGgudHJ1bmMgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jXG5pZiAoIU1hdGgudHJ1bmMpIHtcbiAgICBNYXRoLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMoeCkge1xuICAgICAgICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvTWF0aC50cnVuYy5qc1xuLy8gbW9kdWxlIGlkID0gNTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cblxuLyoqXG4qIExvdy1idWRnZXQgRmxvYXQzMkFycmF5IGtub2NrLW9mZiwgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFAyLmpzIGluIElFOVxuKiBTb3VyY2U6IGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvNTk4OC1waGFzZXItMTItaWU5L1xuKiBDYW1lcm9uIEZvYWxlIChodHRwOi8vd3d3LmtpYmlidS5jb20pXG4qL1xuaWYgKHR5cGVvZiB3aW5kb3cuVWludDMyQXJyYXkgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93LlVpbnQzMkFycmF5ICE9PSBcIm9iamVjdFwiKVxue1xuICAgIHZhciBDaGVhcEFycmF5ID0gZnVuY3Rpb24odHlwZSlcbiAgICB7XG4gICAgICAgIHZhciBwcm90byA9IG5ldyBBcnJheSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICB3aW5kb3dbdHlwZV0gPSBmdW5jdGlvbihhcmcpIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEFycmF5LmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGFyZztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBcnJheS5jYWxsKHRoaXMsIGFyZy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93W3R5cGVdLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB3aW5kb3dbdHlwZV0uY29uc3RydWN0b3IgPSB3aW5kb3dbdHlwZV07XG4gICAgfTtcblxuICAgIENoZWFwQXJyYXkoJ0Zsb2F0MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdVaW50MzJBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdVaW50MTZBcnJheScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBDaGVhcEFycmF5KCdJbnQxNkFycmF5Jyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIENoZWFwQXJyYXkoJ0FycmF5QnVmZmVyJyk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL1VpbnQzMkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4gKiBBbHNvIGZpeCBmb3IgdGhlIGFic2VudCBjb25zb2xlIGluIElFOVxuICovXG5pZiAoIXdpbmRvdy5jb25zb2xlKVxue1xuICAgIHdpbmRvdy5jb25zb2xlID0ge307XG4gICAgd2luZG93LmNvbnNvbGUubG9nID0gd2luZG93LmNvbnNvbGUuYXNzZXJ0ID0gZnVuY3Rpb24oKXt9O1xuICAgIHdpbmRvdy5jb25zb2xlLndhcm4gPSB3aW5kb3cuY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbigpe307XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wb2x5ZmlsbHMvY29uc29sZS5qc1xuLy8gbW9kdWxlIGlkID0gNTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuICogcGVyZm9ybWFuY2Uubm93XG4gKi9cbihmdW5jdGlvbigpe1xuXG4gIGlmIChcInBlcmZvcm1hbmNlXCIgaW4gd2luZG93ID09IGZhbHNlKSB7XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgfVxuICBcbiAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyAgLy8gdGhhbmtzIElFOFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9KTtcblxuICBpZiAoXCJub3dcIiBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gZmFsc2UpXG4gIHtcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydFxuICAgIH1cblxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiBub3coKXtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcG9seWZpbGxzL3BlcmZvcm1hbmNlLm5vdy5qc1xuLy8gbW9kdWxlIGlkID0gNTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCIvLyBSZWZlcmVuY2VzOlxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE1Nzk2NzFcbi8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS90cmVlL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XG4vLyBCcm93c2VyaWZ5IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgdXNlIG9mIGBnbG9iYWxgIGFuZCBwYXNzZXMgdGhlXG4vLyBjb3JyZWN0IHJlZmVyZW5jZSBvZiBgZ2xvYmFsYCwgYHNlbGZgLCBhbmQgZmluYWxseSBgd2luZG93YFxuXG4vLyBEYXRlLm5vd1xuaWYgKCEoRGF0ZS5ub3cgJiYgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSkpIHtcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5cbi8vIHBlcmZvcm1hbmNlLm5vd1xuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKCFnbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XG4gICAgfVxuICAgIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG59XG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbn1cblxuaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJ2lzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjYWxsYmFjayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xufVxuXG5pZiAoIWdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xudmFyIERyYXdJbWFnZSA9IHJlcXVpcmUoJy4vdXRpbHMvRHJhd0ltYWdlJyk7XG52YXIgQmxpdEltYWdlID0gcmVxdWlyZSgnLi91dGlscy9CbGl0SW1hZ2UnKTtcbnZhciBHZXRCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi91dGlscy9HZXRCbGVuZE1vZGVzJyk7XG52YXIgR2V0Q29udGV4dCA9IHJlcXVpcmUoJy4uLy4uL2NhbnZhcy9HZXRDb250ZXh0Jyk7XG5cbnZhciBDYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChnYW1lKVxue1xuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBHYW1lLlxuICAgICovXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcblxuICAgIC8vICBOZWVkZWQ/XG4gICAgdGhpcy50eXBlID0gQ09OU1QuQ0FOVkFTO1xuXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuXG4gICAgLy8gIFJlYWQgYWxsIHRoZSBmb2xsb3dpbmcgZnJvbSBnYW1lIGNvbmZpZyAob3IgU3RhdGUgY29uZmlnPylcbiAgICAvLyB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcbiAgICAvLyB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgLy8gdGhpcy5hdXRvUmVzaXplID0gZmFsc2U7XG4gICAgLy8gdGhpcy5zbW9vdGhQcm9wZXJ0eSA9IFBoYXNlci5DYW52YXMuZ2V0U21vb3RoaW5nUHJlZml4KHRoaXMuY29udGV4dCk7XG4gICAgLy8gdGhpcy5yb3VuZFBpeGVscyA9IGZhbHNlO1xuXG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcblxuICAgIHRoaXMuZ2FtZUNhbnZhcyA9IGdhbWUuY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICAgKi9cbiAgICB0aGlzLmdhbWVDb250ZXh0ID0gR2V0Q29udGV4dCh0aGlzLmdhbWVDYW52YXMpO1xuXG4gICAgdGhpcy5nYW1lQ29uZmlnID0gZ2FtZS5jb25maWc7XG5cbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gdGhpcy5nYW1lQ29udGV4dDtcblxuICAgIC8vICBNYXAgdG8gdGhlIHJlcXVpcmVkIGZ1bmN0aW9uXG4gICAgdGhpcy5kcmF3SW1hZ2UgPSBEcmF3SW1hZ2U7XG4gICAgdGhpcy5ibGl0SW1hZ2UgPSBCbGl0SW1hZ2U7XG5cbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBHZXRCbGVuZE1vZGVzKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcbiAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xuXG4gICAgLy8gdGhpcy50aW50TWV0aG9kID0gdGhpcy50aW50V2l0aFBlclBpeGVsO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZW5kZXJlcjtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlID0ge1xuXG4gICAgaW5pdDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcblxuICAgICAgICB0aGlzLmdhbWVDYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmdhbWVDYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nYW1lQ2FudmFzLnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXMpICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuZ2FtZUNhbnZhcy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmICh0aGlzLnNtb290aFByb3BlcnR5KVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICB0aGlzLmdhbWVDb250ZXh0W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHRoaXMuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUik7XG4gICAgICAgIC8vIH1cbiAgICB9LFxuXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAoYmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJsZW5kTW9kZSAhPT0gYmxlbmRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbGVuZE1vZGU7XG4gICAgfSxcblxuICAgIHNldEFscGhhOiBmdW5jdGlvbiAoYWxwaGEpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IGFscGhhKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IGFscGhhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFscGhhO1xuICAgIH0sXG5cbiAgICAvLyAgQ2FsbCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBsb29wXG4gICAgcHJlUmVuZGVyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBzdGFydCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICMwMGZmMDA7Jyk7XG5cbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2FtZUNvbnRleHQ7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdhbWVDb25maWc7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChjb25maWcuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZy50cmFuc3BhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IucmdiYTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBBZGQgUHJlLXJlbmRlciBob29rXG5cbiAgICAgICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBTdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHBhcmFtIHtQaGFzZXIuU3RhdGV9IHN0YXRlIC0gVGhlIFN0YXRlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSAtIFRoZSBjdW11bGF0aXZlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzbid0IGJlZW4gc2ltdWxhdGVkIHlldCwgZGl2aWRlZFxuICAgICAqICAgYnkgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgd2lsbCBiZSBzaW11bGF0ZWQgdGhlIG5leHQgdGltZSB1cGRhdGUoKVxuICAgICAqICAgcnVucy4gVXNlZnVsIGZvciBpbnRlcnBvbGF0aW5nIGZyYW1lcy5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRyZW4sIGludGVycG9sYXRpb25QZXJjZW50YWdlLCBjYW1lcmEpXG4gICAge1xuICAgICAgICB2YXIgdyA9IHN0YXRlLnN5cy53aWR0aDtcbiAgICAgICAgdmFyIGggPSBzdGF0ZS5zeXMuaGVpZ2h0O1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuc3lzLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHN0YXRlLnN5cy5zZXR0aW5ncztcbiAgICAgICAgdmFyIHNjaXNzb3IgPSAoY2FtZXJhLnggIT09IDAgfHwgY2FtZXJhLnkgIT09IDAgfHwgY2FtZXJhLndpZHRoICE9PSBjdHguY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIGxpc3QgPSBjaGlsZHJlbi5saXN0O1xuXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjdHg7XG5cbiAgICAgICAgXG5cbiAgICAgICAgLy8gIElmIHRoZSBhbHBoYSBvciBibGVuZCBtb2RlIGRpZG4ndCBjaGFuZ2Ugc2luY2UgdGhlIGxhc3QgcmVuZGVyLCB0aGVuIGRvbid0IHNldCB0aGVtIGFnYWluIChzYXZlcyAyIG9wcylcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWxwaGEgIT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbHBoYSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSAwO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jbGVhckJlZm9yZVJlbmRlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmF3Q291bnQgKz0gbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHNjaXNzb3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbGlzdC5sZW5ndGg7IGMrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbGlzdFtjXTtcblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyQ2FudmFzKHRoaXMsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAgQ2FsbCB0aGUgU3RhdGUucmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIHN0YXRlLnJlbmRlci5jYWxsKHN0YXRlLCBjdHgsIGludGVycG9sYXRpb25QZXJjZW50YWdlKTtcbiAgICAgICAgXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgaWYgKGNhbWVyYS5fZmFkZUFscGhhID4gMCB8fCBjYW1lcmEuX2ZsYXNoQWxwaGEgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBmYWRlIHJlbmRlcmluZ1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoJyArIChjYW1lcmEuX2ZhZGVSZWQgKiAyNTUpICsgJywnICsgKGNhbWVyYS5fZmFkZUdyZWVuICogMjU1KSArICcsJyArIChjYW1lcmEuX2ZhZGVCbHVlICogMjU1KSArICcpJztcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNhbWVyYS5fZmFkZUFscGhhO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gZmxhc2ggcmVuZGVyaW5nXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgKGNhbWVyYS5fZmxhc2hSZWQgKiAyNTUpICsgJywnICsgKGNhbWVyYS5fZmxhc2hHcmVlbiAqIDI1NSkgKyAnLCcgKyAoY2FtZXJhLl9mbGFzaEJsdWUgKiAyNTUpICsgJyknO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gY2FtZXJhLl9mbGFzaEFscGhhO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNhbWVyYS54LCBjYW1lcmEueSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcblxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFJlc2V0IHRoZSBjYW1lcmEgc2Npc3NvclxuICAgICAgICBpZiAoc2Npc3NvcilcbiAgICAgICAge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gIEJsYXN0IGl0IHRvIHRoZSBHYW1lIENhbnZhcyAoaWYgbmVlZGVkKVxuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdhbWVDb250ZXh0LmRyYXdJbWFnZShzdGF0ZS5zeXMuY2FudmFzLCAwLCAwLCB3LCBoLCBzZXR0aW5ncy54LCBzZXR0aW5ncy55LCB3LCBoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyVjIHJlbmRlciBlbmQgJywgJ2NvbG9yOiAjZmZmZmZmOyBiYWNrZ3JvdW5kOiAjZmYwMDAwOycpO1xuXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdhbWVDb250ZXh0O1xuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgICAgIHRoaXMuY3VycmVudEFscGhhID0gMTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcblxuICAgICAgICAvLyAgQWRkIFBvc3QtcmVuZGVyIGhvb2tcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqIEBwYXJhbSBbcmVtb3ZlZ2FtZUNhbnZhcz10cnVlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyAgQ2FudmFzUG9vbFxuXG4gICAgICAgIHRoaXMuZ2FtZUNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FtZUNvbnRleHQgPSBudWxsO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gNTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIlxuLy8gIE5vIHNjYWxpbmcsIGFuY2hvciwgcm90YXRpb24gb3IgZWZmZWN0cywgbGl0ZXJhbGx5IGRyYXdzIHRoZSBmcmFtZSBkaXJlY3RseSB0byB0aGUgY2FudmFzXG52YXIgQmxpdEltYWdlID0gZnVuY3Rpb24gKGR4LCBkeSwgZnJhbWUsIGNhbWVyYSlcbntcbiAgICB2YXIgY3R4ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgICB2YXIgY2QgPSBmcmFtZS5jYW52YXNEYXRhO1xuXG4gICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgZnJhbWUuc291cmNlLmltYWdlLFxuICAgICAgICBjZC5zeCxcbiAgICAgICAgY2Quc3ksXG4gICAgICAgIGNkLnNXaWR0aCxcbiAgICAgICAgY2Quc0hlaWdodCxcbiAgICAgICAgZHggLSBjYW1lcmEuc2Nyb2xsWCxcbiAgICAgICAgZHkgLSBjYW1lcmEuc2Nyb2xsWSxcbiAgICAgICAgY2QuZFdpZHRoLFxuICAgICAgICBjZC5kSGVpZ2h0XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxpdEltYWdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0JsaXRJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIERyYXdJbWFnZSA9IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcbntcbiAgICB2YXIgY3R4ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XG4gICAgdmFyIGNkID0gZnJhbWUuY2FudmFzRGF0YTtcblxuICAgIC8vICBCbGVuZCBNb2RlXG5cbiAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBzcmMuYmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gc3JjLmJsZW5kTW9kZTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tzcmMuYmxlbmRNb2RlXTtcbiAgICB9XG5cbiAgICAvLyAgQWxwaGFcblxuICAgIGlmICh0aGlzLmN1cnJlbnRBbHBoYSAhPT0gc3JjLmFscGhhKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QWxwaGEgPSBzcmMuYWxwaGE7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHNyYy5hbHBoYTtcbiAgICB9XG5cbiAgICAvLyAgU21vb3RoaW5nXG5cbiAgICBpZiAodGhpcy5jdXJyZW50U2NhbGVNb2RlICE9PSBzcmMuc2NhbGVNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NhbGVNb2RlID0gc3JjLnNjYWxlTW9kZTtcbiAgICAgICAgLy8gY3R4W3RoaXMuc21vb3RoUHJvcGVydHldID0gKHNvdXJjZS5zY2FsZU1vZGUgPT09IFNjYWxlTW9kZXMuTElORUFSKTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSBmcmFtZS54IC0gc3JjLmRpc3BsYXlPcmlnaW5YO1xuICAgIHZhciBkeSA9IGZyYW1lLnkgLSBzcmMuZGlzcGxheU9yaWdpblk7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUoc3JjLnggLSBjYW1lcmEuc2Nyb2xsWCwgc3JjLnkgLSBjYW1lcmEuc2Nyb2xsWSk7XG4gICAgY3R4LnJvdGF0ZShzcmMucm90YXRpb24pO1xuICAgIGN0eC5zY2FsZShzcmMuc2NhbGVYLCBzcmMuc2NhbGVZKTtcbiAgICBjdHguc2NhbGUoc3JjLmZsaXBYID8gLTEgOiAxLCBzcmMuZmxpcFkgPyAtMSA6IDEpO1xuICAgIGN0eC50cmFuc2xhdGUoc3JjLmRXaWR0aCAqIChzcmMuZmxpcFggPyAxIDogMCksIHNyYy5kSGVpZ2h0ICogKHNyYy5mbGlwWSA/IDEgOiAwKSk7XG4gICAgY3R4LmRyYXdJbWFnZShmcmFtZS5zb3VyY2UuaW1hZ2UsIGNkLnN4LCBjZC5zeSwgY2Quc1dpZHRoLCBjZC5zSGVpZ2h0LCBkeCwgZHksIGNkLmRXaWR0aCwgY2QuZEhlaWdodCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhd0ltYWdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0RyYXdJbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb2RlcyA9IHJlcXVpcmUoJy4uLy4uL0JsZW5kTW9kZXMnKTtcbnZhciBDYW52YXNGZWF0dXJlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2RldmljZS9DYW52YXNGZWF0dXJlcycpO1xuXG52YXIgR2V0QmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciB1c2VOZXcgPSBDYW52YXNGZWF0dXJlcy5zdXBwb3J0TmV3QmxlbmRNb2RlcztcblxuICAgIG91dHB1dFttb2Rlcy5OT1JNQUxdID0gJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcbiAgICBvdXRwdXRbbW9kZXMuTVVMVElQTFldID0gKHVzZU5ldykgPyAnbXVsdGlwbHknIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuU0NSRUVOXSA9ICh1c2VOZXcpID8gJ3NjcmVlbicgOiAnc291cmNlLW92ZXInO1xuICAgIG91dHB1dFttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuREFSS0VOXSA9ICh1c2VOZXcpID8gJ2RhcmtlbicgOiAnc291cmNlLW92ZXInO1xuICAgIG91dHB1dFttb2Rlcy5MSUdIVEVOXSA9ICh1c2VOZXcpID8gJ2xpZ2h0ZW4nIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JfQlVSTl0gPSAodXNlTmV3KSA/ICdjb2xvci1idXJuJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgb3V0cHV0W21vZGVzLkhBUkRfTElHSFRdID0gKHVzZU5ldykgPyAnaGFyZC1saWdodCcgOiAnc291cmNlLW92ZXInO1xuICAgIG91dHB1dFttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuRElGRkVSRU5DRV0gPSAodXNlTmV3KSA/ICdkaWZmZXJlbmNlJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgb3V0cHV0W21vZGVzLkVYQ0xVU0lPTl0gPSAodXNlTmV3KSA/ICdleGNsdXNpb24nIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xuICAgIG91dHB1dFttb2Rlcy5TQVRVUkFUSU9OXSA9ICh1c2VOZXcpID8gJ3NhdHVyYXRpb24nIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuQ09MT1JdID0gKHVzZU5ldykgPyAnY29sb3InIDogJ3NvdXJjZS1vdmVyJztcbiAgICBvdXRwdXRbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRCbGVuZE1vZGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvY2FudmFzL3V0aWxzL0dldEJsZW5kTW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDU4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci9jYW52YXMvdXRpbHMvR2V0QmxlbmRNb2Rlcy5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgKEBwaG90b25zdG9ybSlcbiogQGF1dGhvciAgICAgICBGZWxpcGUgQWxmb25zbyAoQGJpdG5lbmZlcilcbiogQGNvcHlyaWdodCAgICAyMDE3IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xudmFyIENyZWF0ZUVtcHR5VGV4dHVyZSA9IHJlcXVpcmUoJy4vdXRpbHMvQ3JlYXRlRW1wdHlUZXh0dXJlJyk7XG52YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3RleHR1cmUvQ3JlYXRlVGV4dHVyZTJESW1hZ2UnKTtcbnZhciBCbGl0dGVyQmF0Y2ggPSByZXF1aXJlKCcuL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2gnKTtcbnZhciBBQVF1YWRCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2hlcy9hYXF1YWQvQUFRdWFkQmF0Y2gnKTtcbnZhciBTcHJpdGVCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2gnKTtcbnZhciBTaGFwZUJhdGNoID0gcmVxdWlyZSgnLi9iYXRjaGVzL3NoYXBlL1NoYXBlQmF0Y2gnKTtcbnZhciBCbGVuZE1vZGVzID0gcmVxdWlyZSgnLi4vQmxlbmRNb2RlcycpO1xuXG52YXIgV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChnYW1lKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG4gICAgdGhpcy50eXBlID0gQ09OU1QuV0VCR0w7XG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcblxuICAgIC8vICAgQWxsIG9mIHRoZXNlIHNldHRpbmdzIHdpbGwgYmUgYWJsZSB0byBiZSBjb250cm9sbGVkIHZpYSB0aGUgR2FtZSBDb25maWdcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG5cbiAgICAgICAgV2ViR0xDb250ZXh0T3B0aW9uczoge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICB0aGlzLm1heFRleHR1cmVzID0gMTtcbiAgICB0aGlzLm11bHRpVGV4dHVyZSA9IGZhbHNlO1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVzID0gW107XG4gICAgdGhpcy5ibGl0dGVyQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuYWFRdWFkQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuc2hhcGVCYXRjaCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlcmVyO1xuXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZygnV2ViR0xSZW5kZXJlci5pbml0Jyk7XG5cbiAgICAgICAgdGhpcy5nbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCd3ZWJnbCcsIHRoaXMuY29uZmlnLldlYkdMQ29udGV4dE9wdGlvbnMpIHx8IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB0aGlzLmNvbmZpZy5XZWJHTENvbnRleHRPcHRpb25zKTtcblxuICAgICAgICBpZiAoIXRoaXMuZ2wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dExvc3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdhbWUuY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICBcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICBnbC5jbGVhckNvbG9yKGNvbG9yLnJlZEdMLCBjb2xvci5ncmVlbkdMLCBjb2xvci5ibHVlR0wsIGNvbG9yLmFscGhhR0wpO1xuXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyAgTWFwIEJsZW5kIE1vZGVzXG5cbiAgICAgICAgdmFyIGFkZCA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEEgXTtcbiAgICAgICAgdmFyIG5vcm1hbCA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTtcbiAgICAgICAgdmFyIG11bHRpcGx5ID0gWyBnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTtcbiAgICAgICAgdmFyIHNjcmVlbiA9IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkUgXTtcblxuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSBbXG4gICAgICAgICAgICBub3JtYWwsIGFkZCwgbXVsdGlwbHksIHNjcmVlbiwgbm9ybWFsLFxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLFxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsLFxuICAgICAgICAgICAgbm9ybWFsLCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsXG4gICAgICAgIF07XG5cbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xuICAgICAgICB0aGlzLmJsaXR0ZXJCYXRjaCA9IHRoaXMuYWRkQmF0Y2gobmV3IEJsaXR0ZXJCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuYWFRdWFkQmF0Y2ggPSB0aGlzLmFkZEJhdGNoKG5ldyBBQVF1YWRCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSB0aGlzLmFkZEJhdGNoKG5ldyBTcHJpdGVCYXRjaCh0aGlzLmdhbWUsIGdsLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuc2hhcGVCYXRjaCA9IHRoaXMuYWRkQmF0Y2gobmV3IFNoYXBlQmF0Y2godGhpcy5nYW1lLCBnbCwgdGhpcykpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUZXh0dXJlMkQ6IGZ1bmN0aW9uIChzb3VyY2UpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIGlmICghc291cmNlLmdsVGV4dHVyZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc291cmNlLmdsVGV4dHVyZSA9IENyZWF0ZVRleHR1cmUyREltYWdlKGdsLCBzb3VyY2UuaW1hZ2UsIGdsLk5FQVJFU1QsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gc291cmNlLmdsVGV4dHVyZTtcbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZTJEOiBmdW5jdGlvbiAodGV4dHVyZTJEKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRleHR1cmUyRCAhPT0gdGV4dHVyZTJEKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZTJEKTtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gdGV4dHVyZTJEO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldEJhdGNoOiBmdW5jdGlvbiAoYmF0Y2gsIHRleHR1cmUyRCwgY2FtZXJhKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlMkQodGV4dHVyZTJEKTtcblxuICAgICAgICBpZiAodGhpcy5iYXRjaCAhPT0gYmF0Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmF0Y2guYmluZCgpO1xuXG4gICAgICAgICAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdhbWUuY29uZmlnLnJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlcztcblxuICAgICAgICB0aGlzLnZpZXcud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggLyByZXMpICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSAodGhpcy5oZWlnaHQgLyByZXMpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc1tpXS5iaW5kKCk7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNbaV0ucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhdGNoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5iYXRjaC5iaW5kKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIENhbGwgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgbG9vcFxuICAgIHByZVJlbmRlcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBObyBwb2ludCByZW5kZXJpbmcgaWYgb3VyIGNvbnRleHQgaGFzIGJlZW4gYmxvd24gdXAhXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRMb3N0KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQWRkIFByZS1yZW5kZXIgaG9va1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2FtZS5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoY29sb3IucmVkR0wsIGNvbG9yLmdyZWVuR0wsIGNvbG9yLmJsdWVHTCwgY29sb3IuYWxwaGFHTCk7XG4gICAgICAgIC8vIFNvbWUgZHJpdmVycyByZXF1aXJlIHRvIGNhbGwgZ2xDbGVhclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlcy5OT1JNQUwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2luZ2xlIFN0YXRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5TdGF0ZX0gc3RhdGUgLSBUaGUgU3RhdGUgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVycG9sYXRpb25QZXJjZW50YWdlIC0gVGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNuJ3QgYmVlbiBzaW11bGF0ZWQgeWV0LCBkaXZpZGVkXG4gICAgICogICBieSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB3aWxsIGJlIHNpbXVsYXRlZCB0aGUgbmV4dCB0aW1lIHVwZGF0ZSgpXG4gICAgICogICBydW5zLiBVc2VmdWwgZm9yIGludGVycG9sYXRpbmcgZnJhbWVzLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKHN0YXRlLCBjaGlsZHJlbiwgaW50ZXJwb2xhdGlvblBlcmNlbnRhZ2UsIGNhbWVyYSlcbiAgICB7XG4gICAgICAgIC8vICBDb3VsZCBtb3ZlIHRvIHRoZSBTdGF0ZSBTeXN0ZW1zIG9yIE1haW5Mb29wXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBzY2lzc29yID0gKGNhbWVyYS54ICE9PSAwIHx8IGNhbWVyYS55ICE9PSAwIHx8IGNhbWVyYS53aWR0aCAhPT0gZ2wuY2FudmFzLndpZHRoIHx8IGNhbWVyYS5oZWlnaHQgIT09IGdsLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmIChzY2lzc29yKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgICAgIGdsLnNjaXNzb3IoY2FtZXJhLngsIChnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0gY2FtZXJhLnkgLSBjYW1lcmEuaGVpZ2h0KSwgY2FtZXJhLndpZHRoLCBjYW1lcmEuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBjb3VsZCBlaXRoZXIgY2xlYXIgY29sb3Igb3IgcmVuZGVyIGEgcXVhZFxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgICB2YXIgbGlzdCA9IGNoaWxkcmVuLmxpc3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgKytpbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAvLyBTZXR0aW5nIGJsZW5kIG1vZGUgaWYgbmVlZGVkICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoO1xuICAgICAgICAgICAgdmFyIG5ld0JsZW5kTW9kZSA9IGNoaWxkLmJsZW5kTW9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gbmV3QmxlbmRNb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaCkgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYmxlbmQgPSB0aGlzLmJsZW5kTW9kZXNbbmV3QmxlbmRNb2RlXTtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGlmIChibGVuZC5sZW5ndGggPiAyKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoYmxlbmRbMF0sIGJsZW5kWzFdLCBibGVuZFsyXSwgYmxlbmRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoYmxlbmRbMF0sIGJsZW5kWzFdKTsgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IG5ld0JsZW5kTW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXdpbmcgY2hpbGRcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcldlYkdMKHRoaXMsIGNoaWxkLCBpbnRlcnBvbGF0aW9uUGVyY2VudGFnZSwgY2FtZXJhKTtcbiAgICAgICAgICAgIGJhdGNoID0gdGhpcy5iYXRjaDtcbiAgICAgICAgICAgIGlmIChiYXRjaCAmJiBiYXRjaC5pc0Z1bGwoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhdGNoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbWVyYS5fZmFkZUFscGhhID4gMCB8fCBjYW1lcmEuX2ZsYXNoQWxwaGEgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYWFRdWFkQmF0Y2ggPSB0aGlzLmFhUXVhZEJhdGNoO1xuICAgICAgICAgICAgYWFRdWFkQmF0Y2guYmluZCgpO1xuICAgICAgICAgICAgLy8gZmFkZSByZW5kZXJpbmdcbiAgICAgICAgICAgIGFhUXVhZEJhdGNoLmFkZChcbiAgICAgICAgICAgICAgICBjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlUmVkLCBcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZhZGVHcmVlbiwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlQmx1ZSwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mYWRlQWxwaGFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBmbGFzaCByZW5kZXJpbmdcbiAgICAgICAgICAgIGFhUXVhZEJhdGNoLmFkZChcbiAgICAgICAgICAgICAgICBjYW1lcmEueCwgY2FtZXJhLnksIGNhbWVyYS53aWR0aCwgY2FtZXJhLmhlaWdodCwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaFJlZCwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEdyZWVuLCBcbiAgICAgICAgICAgICAgICBjYW1lcmEuX2ZsYXNoQmx1ZSwgXG4gICAgICAgICAgICAgICAgY2FtZXJhLl9mbGFzaEFscGhhXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWFRdWFkQmF0Y2guZmx1c2goKTtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2guYmluZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2lzc29yKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXIgbG9vcCAodGlkeSB0aGluZ3MgdXAsIGV0YylcbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAgQWRkIFBvc3QtcmVuZGVyIGhvb2tcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgcmVuZGVyIGVuZCAnLCAnY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQ6ICNmZjAwMDA7Jyk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB9LFxuXG4gICAgY3JlYXRlRkJPOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gKG5ld0JsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2g7XG4gICAgICAgIHZhciBibGVuZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlICE9PSBuZXdCbGVuZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChiYXRjaClcbiAgICAgICAgICAgICAgICBiYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgYmxlbmQgPSB0aGlzLmJsZW5kTW9kZXNbbmV3QmxlbmRNb2RlXTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBpZiAoYmxlbmQubGVuZ3RoID4gMilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShibGVuZFswXSwgYmxlbmRbMV0sIGJsZW5kWzJdLCBibGVuZFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGJsZW5kWzBdLCBibGVuZFsxXSk7ICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2RlID0gbmV3QmxlbmRNb2RlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEJhdGNoOiBmdW5jdGlvbiAoYmF0Y2hJbnN0YW5jZSlcbiAgICB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYmF0Y2hlcy5pbmRleE9mKGJhdGNoSW5zdGFuY2UpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hJbnN0YW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gYmF0Y2hJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdXBsb2FkQ2FudmFzVG9HUFU6IGZ1bmN0aW9uIChzcmNDYW52YXMsIGRzdFRleHR1cmUsIHNob3VsZFVwZGF0ZVJlc291cmNlKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICBpZiAoIWRzdFRleHR1cmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIG9ubHkgY2FsbCB0aGlzIG9uY2UgKi9cbiAgICAgICAgICAgIGRzdFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVSZXNvdXJjZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLyogVXBkYXRlIHJlc291cmNlICovXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkc3RUZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgc3JjQ2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIEFsbG9jYXRlIG9yIFJlYWxsb2NhdGUgcmVzb3VyY2UgKi9cbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGRzdFRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzcmNDYW52YXMpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiB3ZSBtdXN0IHJlYmluZCBvbGQgdGV4dHVyZSAqL1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmN1cnJlbnRUZXh0dXJlMkQpO1xuXG4gICAgICAgIHJldHVybiBkc3RUZXh0dXJlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR0xSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwidmFyIEJpbmRWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9CaW5kVmVydGV4QXJyYXknKTtcbnZhciBDcmVhdGVQcm9ncmFtID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVByb2dyYW0nKTtcbnZhciBDcmVhdGVTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9zaGFkZXIvQ3JlYXRlU2hhZGVyJyk7XG52YXIgQ3JlYXRlQnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0NyZWF0ZUJ1ZmZlcicpO1xudmFyIENyZWF0ZUF0dHJpYkRlc2MgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQ3JlYXRlQXR0cmliRGVzYycpO1xudmFyIEJ1ZmZlcjMyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0J1ZmZlcjMyJyk7XG52YXIgQnVmZmVyMTYgPSByZXF1aXJlKCcuLi8uLi91dGlscy9idWZmZXIvQnVmZmVyMTYnKTtcbnZhciBWZXJ0ZXhBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3Zhby9WZXJ0ZXhBcnJheScpO1xuXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcblxudmFyIEFBUXVhZEJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcbiAgICB0aGlzLm1heFF1YWRzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XG4gICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSBudWxsO1xuXG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcblxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xufTtcblxuQUFRdWFkQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQUFRdWFkQmF0Y2g7XG5cbkFBUXVhZEJhdGNoLnByb3RvdHlwZSA9IHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcbiAgICB7XG5cbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5BQVFVQURfVkVSVEVYX0NPVU5UICogQ09OU1QuTUFYX0FBUVVBRCk7XG4gICAgICAgIHZhciBpbmRleERhdGFCdWZmZXIgPSBuZXcgQnVmZmVyMTYoQ09OU1QuSU5ERVhfU0laRSAqIENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9BQVFVQUQpO1xuICAgICAgICB2YXIgdmVydFNoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCksXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9jb2xvcicsIDQsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpXG4gICAgICAgIF07XG4gICAgICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBWZXJ0ZXhBcnJheShDcmVhdGVCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RSRUFNX0RSQVcsIG51bGwsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpLCBhdHRyaWJBcnJheSk7XG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfdmlld19tYXRyaXgnKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX0FBUVVBRCAqIENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVDtcblxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5ID0gdmVydGV4QXJyYXk7XG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULkFBUVVBRF9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4QnVmZmVyT2JqZWN0KTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhCdWZmZXIpO1xuXG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9LFxuXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKVxuICAgIHtcbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBjaGVjayBpZiB0aGUgYnVmZmVycyBhcmUgZnVsbCBiZWZvcmUgZmx1c2hpbmdcbiAgICAgICAgLy8gdGhpcyBpcyB0byBnaXZlIGZyZWVkb20gb2Ygd2hlbiBzaG91bGQgdGhlIHJlbmRlcmVyIGZsdXNoLiB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG4gICAgICAgIHZhciBmbG9hdEJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZShDT05TVC5BQVFVQURfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVCAqIENPTlNULkFBUVVBRF9WRVJURVhfQ09VTlQpO1xuXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHk7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJlZDtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHg7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHJlZDtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gZ3JlZW47XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGJsdWU7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuXG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IHggKyB3aWR0aDtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geSArIGhlaWdodDtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gcmVkO1xuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBncmVlbjtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYmx1ZTtcbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG5cbiAgICAgICAgZmxvYXRCdWZmZXJbdmVydGV4T2Zmc2V0KytdID0geCArIHdpZHRoO1xuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSB5O1xuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSByZWQ7XG4gICAgICAgIGZsb2F0QnVmZmVyW3ZlcnRleE9mZnNldCsrXSA9IGdyZWVuO1xuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBibHVlO1xuICAgICAgICBmbG9hdEJ1ZmZlclt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCArPSBDT05TVC5BQVFVQURfSU5ERVhfQ09VTlQ7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRVc2VkQnVmZmVyQXNGbG9hdCgpKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5lbGVtZW50Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgdmVydGV4RGF0YUJ1ZmZlci5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbilcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xuICAgICAgICBcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICBcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcbiAgICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBpZiAoZ2wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhBcnJheS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQVF1YWRCYXRjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL0FBUXVhZEJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1ODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9hYXF1YWQvQUFRdWFkQmF0Y2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcbiAgICAndm9pZCBtYWluKCkgeycsXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9GcmFnbWVudFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7JyxcbiAgICAndmFyeWluZyB2ZWM0IHZfY29sb3I7JyxcbiAgICAndm9pZCBtYWluICgpIHsnLFxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxuICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9WZXJ0ZXhTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL0ZyYWdtZW50U2hhZGVyJyk7XG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9WZXJ0ZXhTaGFkZXInKTtcblxudmFyIENPTlNUID0ge1xuXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjNClcbiAgICBWRVJURVhfU0laRTogMjQsXG4gICAgSU5ERVhfU0laRTogMixcbiAgICBBQVFVQURfVkVSVEVYX0NPVU5UOiA0LFxuICAgIEFBUVVBRF9JTkRFWF9DT1VOVDogNixcblxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxuICAgIEFBUVVBRF9WRVJURVhfQ09NUE9ORU5UX0NPVU5UOiA2LFxuICAgIE1BWF9BQVFVQUQ6IDIwMDAsXG5cbiAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVmVydGV4U2hhZGVyLFxuICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZyYWdtZW50U2hhZGVyXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL2FhcXVhZC9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYWFxdWFkL2NvbnN0LmpzIiwiLy8gIENvdWxkIHlvdSBtb3ZlIHRoZXNlIGludG8gc3ViLWZvbGRlcnMgcGxlYXNlLCBpLmUuICd2YW8nLCAnc2hhZGVyJyBldGM/XG5cbnZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XG52YXIgQ3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlcicpO1xudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcbnZhciBCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9CdWZmZXIzMicpO1xudmFyIEJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0J1ZmZlcjE2Jyk7XG52YXIgVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vVmVydGV4QXJyYXknKTtcblxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbnZhciBCbGl0dGVyQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSwgZ2wsIG1hbmFnZXIpXG57XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICB0aGlzLnR5cGUgPSBQSEFTRVJfQ09OU1QuV0VCR0w7XG4gICAgdGhpcy52aWV3ID0gZ2FtZS5jYW52YXM7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLndpZHRoID0gZ2FtZS5jb25maWcud2lkdGggKiBnYW1lLmNvbmZpZy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gZ2FtZS5jb25maWcuaGVpZ2h0ICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmdsQ29udGV4dCA9IGdsO1xuICAgIHRoaXMubWF4UGFydGljbGVzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XG4gICAgdGhpcy5jdXJyZW50VGV4dHVyZTJEID0gbnVsbDtcbiAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IG51bGw7XG5cbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XG59O1xuXG5CbGl0dGVyQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxpdHRlckJhdGNoO1xuXG5CbGl0dGVyQmF0Y2gucHJvdG90eXBlID0ge1xuXG4gICAgaW5pdDogZnVuY3Rpb24gKGdsKVxuICAgIHtcblxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULlBBUlRJQ0xFX1ZFUlRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5QQVJUSUNMRV9JTkRFWF9DT1VOVCAqIENPTlNULk1BWF9QQVJUSUNMRVMpO1xuICAgICAgICB2YXIgdmVydFNoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ1NoYWRlciA9IENyZWF0ZVNoYWRlcihnbCwgQ09OU1QuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBDcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyT2JqZWN0ID0gQ3JlYXRlQnVmZmVyKGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG51bGwsIGluZGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XG4gICAgICAgIHZhciBhdHRyaWJBcnJheSA9IFtcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMCksXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV90ZXhfY29vcmQnLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCA4KSxcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX2FscGhhJywgMSwgZ2wuRkxPQVQsIGZhbHNlLCBDT05TVC5WRVJURVhfU0laRSwgMTYpXG4gICAgICAgIF07XG4gICAgICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBWZXJ0ZXhBcnJheShDcmVhdGVCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RSRUFNX0RSQVcsIG51bGwsIHZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpLCBhdHRyaWJBcnJheSk7XG4gICAgICAgIHZhciB2aWV3TWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfdmlld19tYXRyaXgnKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xuICAgICAgICB2YXIgbWF4ID0gQ09OU1QuTUFYX1BBUlRJQ0xFUyAqIENPTlNULlBBUlRJQ0xFX0lOREVYX0NPVU5UO1xuXG4gICAgICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IHZlcnRleERhdGFCdWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXhEYXRhQnVmZmVyID0gaW5kZXhEYXRhQnVmZmVyO1xuICAgICAgICB0aGlzLnZlcnRTaGFkZXIgPSB2ZXJ0U2hhZGVyO1xuICAgICAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyT2JqZWN0ID0gaW5kZXhCdWZmZXJPYmplY3Q7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXkgPSB2ZXJ0ZXhBcnJheTtcbiAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24gPSB2aWV3TWF0cml4TG9jYXRpb247XG4gICAgICAgIHRoaXMubWF4UGFydGljbGVzID0gbWF4O1xuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlBBUlRJQ0xFX0lOREVYX0NPVU5ULCBpbmRleEIgKz0gQ09OU1QuUEFSVElDTEVfVkVSVEVYX0NPVU5UKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAwXSA9IGluZGV4QiArIDA7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAxXSA9IGluZGV4QiArIDE7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAyXSA9IGluZGV4QiArIDI7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyAzXSA9IGluZGV4QiArIDA7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA0XSA9IGluZGV4QiArIDI7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleEEgKyA1XSA9IGluZGV4QiArIDM7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlck9iamVjdCk7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDAsIGluZGV4QnVmZmVyKTtcblxuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgfSxcblxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVMZW5ndGgoKSA+PSB0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xuICAgIH0sXG5cbiAgICBiaW5kOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyT2JqZWN0KTtcbiAgICAgICAgQmluZFZlcnRleEFycmF5KGdsLCB0aGlzLnZlcnRleEFycmF5KTtcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG5cbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuZWxlbWVudENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgIHZlcnRleERhdGFCdWZmZXIuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRDb3VudCA9IDA7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICAgICAgXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXG4gICAgICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMud2lkdGgsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCwgLTIgLyB0aGlzLmhlaWdodCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAxLFxuICAgICAgICAgICAgICAgIC0xLCAxLCAwLCAwXG4gICAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG5cbiAgICAgICAgaWYgKGdsKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QXJyYXkuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxpdHRlckJhdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0JsaXR0ZXJCYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gNTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9CbGl0dGVyQmF0Y2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9zYW1wbGVyMkQ7JyxcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxuICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfc2FtcGxlcjJELCB2X3RleF9jb29yZCkgKiB2ZWM0KDEuMCwgMS4wLCAxLjAsIHZfYWxwaGEpOycsXG4gICAgJ30nXG5dLmpvaW4oJ1xcbicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9ibGl0dGVyL0ZyYWdtZW50U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhfY29vcmQ7JyxcbiAgICAnYXR0cmlidXRlIGZsb2F0IGFfYWxwaGE7JyxcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxuICAgICd2b2lkIG1haW4gKCkgeycsXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXG4gICAgJyAgIHZfdGV4X2Nvb3JkID0gYV90ZXhfY29vcmQ7JyxcbiAgICAnXHR2X2FscGhhID0gYV9hbHBoYTsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9WZXJ0ZXhTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL0ZyYWdtZW50U2hhZGVyJyk7XG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9WZXJ0ZXhTaGFkZXInKTtcblxudmFyIENPTlNUID0ge1xuXG4gICAgLy8gVkVSVEVYX1NJWkUgPSBzaXplb2YodmVjMikgKyBzaXplb2YodmVjMikgKyBzaXplb2YoZmxvYXQpXG4gICAgVkVSVEVYX1NJWkU6IDIwLFxuICAgIElOREVYX1NJWkU6IDIsXG4gICAgUEFSVElDTEVfVkVSVEVYX0NPVU5UOiA0LFxuICAgIFBBUlRJQ0xFX0lOREVYX0NPVU5UOiA2LFxuXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXG4gICAgUEFSVElDTEVfVkVSVEVYX0NPTVBPTkVOVF9DT1VOVDogNSxcblxuICAgIC8vIENhbid0IGJlIGJpZ2dlciB0aGFuIDEwLDAwMCBzaW5jZSBpbmRleCBhcmUgMTYtYml0XG4gICAgTUFYX1BBUlRJQ0xFUzogMjAwMCxcblxuICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWZXJ0ZXhTaGFkZXIsXG4gICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRnJhZ21lbnRTaGFkZXJcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDT05TVDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvYmxpdHRlci9jb25zdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxuICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcbiAgICAndm9pZCBtYWluKCkgeycsXG4gICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodl9jb2xvci5iZ3IsIHZfYWxwaGEpOycsXG4gICAgJ30nXG5dLmpvaW4oJ1xcbicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9GcmFnbWVudFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XG52YXIgQ3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlcicpO1xudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcbnZhciBCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9CdWZmZXIzMicpO1xudmFyIFZlcnRleEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL1ZlcnRleEFycmF5Jyk7XG52YXIgRWFyY3V0ID0gcmVxdWlyZSgnLi9lYXJjdXQnKTtcblxudmFyIFBIQVNFUl9DT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0Jyk7XG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5cbnZhciBTaGFwZUJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcbiAgICB0aGlzLm1heFZlcnRpY2VzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1NoYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnRlbXBUcmlhbmdsZSA9IFtcbiAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcbiAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcbiAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfSxcbiAgICAgICAge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCByZ2I6IDB4RkZGRkZGLCBhbHBoYTogMS4wfVxuICAgIF07XG5cbiAgICAvLyAgIEFsbCBvZiB0aGVzZSBzZXR0aW5ncyB3aWxsIGJlIGFibGUgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIEdhbWUgQ29uZmlnXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuXG4gICAgICAgIFdlYkdMQ29udGV4dE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuaW5pdCh0aGlzLmdsQ29udGV4dCk7XG5cbn07XG5cblNoYXBlQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCYXRjaDtcblxuU2hhcGVCYXRjaC5wcm90b3R5cGUgPSB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoZ2wpXG4gICAge1xuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIzMihDT05TVC5WRVJURVhfU0laRSAqIENPTlNULk1BWF9WRVJUSUNFUyk7XG4gICAgICAgIHZhciB2ZXJ0U2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5WRVJURVhfU0hBREVSX1NPVVJDRSwgZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnU2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IENyZWF0ZVByb2dyYW0oZ2wsIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpO1xuICAgICAgICB2YXIgYXR0cmliQXJyYXkgPSBbXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9wb3NpdGlvbicsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDApLFxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfY29sb3InLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBDT05TVC5WRVJURVhfU0laRSwgOCksXG4gICAgICAgICAgICBDcmVhdGVBdHRyaWJEZXNjKGdsLCBwcm9ncmFtLCAnYV9hbHBoYScsIDEsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDEyKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgVmVydGV4QXJyYXkoQ3JlYXRlQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUUkVBTV9EUkFXLCBudWxsLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKSwgYXR0cmliQXJyYXkpO1xuICAgICAgICB2YXIgdmlld01hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3ZpZXdfbWF0cml4Jyk7XG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfVkVSVElDRVM7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyID0gdmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5O1xuICAgICAgICB0aGlzLnZpZXdNYXRyaXhMb2NhdGlvbiA9IHZpZXdNYXRyaXhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tYXhWZXJ0aWNlcyA9IG1heDtcbiAgICAgICAgdGhpcy5wb2x5Z29uQ2FjaGUgPSBbXTtcblxuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZ2FtZS5jb25maWcucmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgfSxcblxuICAgIGlzRnVsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy52ZXJ0ZXhEYXRhQnVmZmVyLmdldEJ5dGVMZW5ndGgoKSA+PSB0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUNhcGFjaXR5KCkpO1xuICAgIH0sXG5cbiAgICBiaW5kOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG5cbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgfSxcblxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xuXG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZlcnRleERhdGFCdWZmZXIuZ2V0VXNlZEJ1ZmZlckFzRmxvYXQoKSk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdGhpcy52ZXJ0ZXhDb3VudCk7XG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgICAgIFxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XG4gICAgICAgIFxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KFxuICAgICAgICAgICAgdGhpcy52aWV3TWF0cml4TG9jYXRpb24sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgICAgIDIgLyB0aGlzLndpZHRoLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDAsIC0yIC8gdGhpcy5oZWlnaHQsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMSxcbiAgICAgICAgICAgICAgICAtMSwgMSwgMCwgMFxuICAgICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xDb250ZXh0O1xuXG4gICAgICAgIGlmIChnbClcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydFNoYWRlcik7XG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEFycmF5LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTGluZTogZnVuY3Rpb24gKFxuICAgICAgICAvKiBHcmFwaGljcyBHYW1lIE9iamVjdCBwcm9wZXJ0aWVzICovXG4gICAgICAgIHNyY1gsIHNyY1ksIHNyY1NjYWxlWCwgc3JjU2NhbGVZLCBzcmNSb3RhdGlvbixcbiAgICAgICAgLyogbGluZSBwcm9wZXJ0aWVzICovXG4gICAgICAgIGF4LCBheSwgYngsIGJ5LCBhTGluZVdpZHRoLCBiTGluZVdpZHRoLCBhTGluZUNvbG9yLCBiTGluZUNvbG9yLCBsaW5lQWxwaGEsXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xuICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXG4gICAgKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gNjtcblxuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcbiAgICAgICAgdmFyIGR4ID0gYnggLSBheDtcbiAgICAgICAgdmFyIGR5ID0gYnkgLSBheTtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciBhbDAgPSBhTGluZVdpZHRoICogKGJ5IC0gYXkpIC8gbGVuO1xuICAgICAgICB2YXIgYWwxID0gYUxpbmVXaWR0aCAqIChheCAtIGJ4KSAvIGxlbjtcbiAgICAgICAgdmFyIGJsMCA9IGJMaW5lV2lkdGggKiAoYnkgLSBheSkgLyBsZW47XG4gICAgICAgIHZhciBibDEgPSBiTGluZVdpZHRoICogKGF4IC0gYngpIC8gbGVuO1xuICAgICAgICB2YXIgbHgwID0gYnggLSBibDA7XG4gICAgICAgIHZhciBseTAgPSBieSAtIGJsMTtcbiAgICAgICAgdmFyIGx4MSA9IGF4IC0gYWwwO1xuICAgICAgICB2YXIgbHkxID0gYXkgLSBhbDE7XG4gICAgICAgIHZhciBseDIgPSBieCArIGJsMDtcbiAgICAgICAgdmFyIGx5MiA9IGJ5ICsgYmwxO1xuICAgICAgICB2YXIgbHgzID0gYXggKyBhbDA7XG4gICAgICAgIHZhciBseTMgPSBheSArIGFsMTtcbiAgICAgICAgdmFyIHgwID0gbHgwICogYSArIGx5MCAqIGMgKyBlO1xuICAgICAgICB2YXIgeTAgPSBseDAgKiBiICsgbHkwICogZCArIGY7XG4gICAgICAgIHZhciB4MSA9IGx4MSAqIGEgKyBseTEgKiBjICsgZTtcbiAgICAgICAgdmFyIHkxID0gbHgxICogYiArIGx5MSAqIGQgKyBmO1xuICAgICAgICB2YXIgeDIgPSBseDIgKiBhICsgbHkyICogYyArIGU7XG4gICAgICAgIHZhciB5MiA9IGx4MiAqIGIgKyBseTIgKiBkICsgZjtcbiAgICAgICAgdmFyIHgzID0gbHgzICogYSArIGx5MyAqIGMgKyBlO1xuICAgICAgICB2YXIgeTMgPSBseDMgKiBiICsgbHkzICogZCArIGY7XG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDA7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MDtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGJMaW5lQ29sb3I7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MTtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkxO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYUxpbmVDb2xvcjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgyO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBiTGluZUNvbG9yO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB5MTtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGFMaW5lQ29sb3I7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsaW5lQWxwaGE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB4MztcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHkzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gYUxpbmVDb2xvcjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxpbmVBbHBoYTtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHgyO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0geTI7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBiTGluZUNvbG9yO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4MCwgeTAsIGJMaW5lQ29sb3IsXG4gICAgICAgICAgICB4MSwgeTEsIGFMaW5lQ29sb3IsXG4gICAgICAgICAgICB4MiwgeTIsIGJMaW5lQ29sb3IsXG4gICAgICAgICAgICB4MywgeTMsIGFMaW5lQ29sb3JcbiAgICAgICAgXTtcblxuICAgIH0sXG5cbiAgICBhZGRTdHJva2VQYXRoOiBmdW5jdGlvbiAoXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAvKiBQYXRoIHByb3BlcnRpZXMgKi9cbiAgICAgICAgcGF0aCwgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGxpbmVBbHBoYSxcbiAgICAgICAgLyogdHJhbnNmb3JtICovXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGYsXG4gICAgICAgIC8qIGlzIGxhc3QgY29ubmVjdGlvbiAqL1xuICAgICAgICBpc0xhc3RQYXRoXG4gICAgKSB7XG4gICAgICAgIHZhciBwb2ludDAsIHBvaW50MTtcbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgdmFyIHBvbHlsaW5lcyA9IHRoaXMucG9seWdvbkNhY2hlO1xuICAgICAgICB2YXIgaGFsZkxpbmVXaWR0aCA9IGxpbmVXaWR0aCAqIDAuNTtcbiAgICAgICAgdmFyIGxhc3QsIGN1cnI7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgICAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4T2Zmc2V0O1xuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MjtcbiAgICAgICAgdmFyIGxpbmU7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aEluZGV4ID0gMDsgcGF0aEluZGV4ICsgMSA8IHBhdGhMZW5ndGg7IHBhdGhJbmRleCArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb2ludDAgPSBwYXRoW3BhdGhJbmRleF07XG4gICAgICAgICAgICBwb2ludDEgPSBwYXRoW3BhdGhJbmRleCArIDFdO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuYWRkTGluZShcbiAgICAgICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXG4gICAgICAgICAgICAgICAgcG9pbnQwLngsIHBvaW50MC55LCBcbiAgICAgICAgICAgICAgICBwb2ludDEueCwgcG9pbnQxLnksIFxuICAgICAgICAgICAgICAgIHBvaW50MC53aWR0aCAvIDIsIHBvaW50MS53aWR0aCAvIDIsIFxuICAgICAgICAgICAgICAgIHBvaW50MC5yZ2IsIHBvaW50MS5yZ2IsIGxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9seWxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBSZW5kZXIgam9pbnRzICovXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMSwgcG9seWxpbmVzTGVuZ3RoID0gcG9seWxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4IDwgcG9seWxpbmVzTGVuZ3RoOyArK2luZGV4KVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleENvdW50ICsgNiA+IHRoaXMubWF4VmVydGljZXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0ID0gcG9seWxpbmVzW2luZGV4IC0gMV0gfHwgcG9seWxpbmVzW3BvbHlsaW5lc0xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY3VyciA9IHBvbHlsaW5lc1tpbmRleF07XG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KVxuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMiArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDIgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMCArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDAgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMyArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDMgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBjdXJyWzMgKiAzICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMCArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDAgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAwICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGFzdFszICogMiArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGxhc3RbMyAqIDIgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBsYXN0WzMgKiAyICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gY3VyclszICogMSArIDBdO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGN1cnJbMyAqIDEgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBjdXJyWzMgKiAxICsgMl07XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gbGluZUFscGhhO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDY7XG4gICAgICAgIH1cbiAgICAgICAgcG9seWxpbmVzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIGFkZEZpbGxQYXRoOiBmdW5jdGlvbiAoXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAvKiBQYXRoIHByb3BlcnRpZXMgKi9cbiAgICAgICAgcGF0aCwgZmlsbENvbG9yLCBmaWxsQWxwaGEsXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xuICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXG4gICAgKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgdmFyIHBvbHlnb25DYWNoZSA9IHRoaXMucG9seWdvbkNhY2hlO1xuICAgICAgICB2YXIgcG9seWdvbkluZGV4QXJyYXk7XG4gICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjI7XG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQ7XG4gICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHRoaXMudmVydGV4Q291bnQ7XG4gICAgICAgIHZhciBtYXhWZXJ0aWNlcyA9IHRoaXMubWF4VmVydGljZXM7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgICAgICB2YXIgdmVydGV4QnVmZmVyRjMyID0gdmVydGV4RGF0YUJ1ZmZlci5mbG9hdFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJVMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLnVpbnRWaWV3O1xuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MjtcbiAgICAgICAgdmFyIHR4MCwgdHkwLCB0eDEsIHR5MSwgdHgyLCB0eTI7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aEluZGV4ID0gMDsgcGF0aEluZGV4IDwgbGVuZ3RoOyArK3BhdGhJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnQgPSBwYXRoW3BhdGhJbmRleF07XG4gICAgICAgICAgICBwb2x5Z29uQ2FjaGUucHVzaChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29uSW5kZXhBcnJheSA9IEVhcmN1dChwb2x5Z29uQ2FjaGUpO1xuICAgICAgICBsZW5ndGggPSBwb2x5Z29uSW5kZXhBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdjAgPSBwb2x5Z29uSW5kZXhBcnJheVtpbmRleCArIDBdICogMjtcbiAgICAgICAgICAgIHYxID0gcG9seWdvbkluZGV4QXJyYXlbaW5kZXggKyAxXSAqIDI7XG4gICAgICAgICAgICB2MiA9IHBvbHlnb25JbmRleEFycmF5W2luZGV4ICsgMl0gKiAyO1xuXG4gICAgICAgICAgICBpZiAodmVydGV4Q291bnQgKyAzID4gbWF4VmVydGljZXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgICAgIHZlcnRleENvdW50ICs9IDM7XG5cbiAgICAgICAgICAgIHgwID0gcG9seWdvbkNhY2hlW3YwICsgMF07XG4gICAgICAgICAgICB5MCA9IHBvbHlnb25DYWNoZVt2MCArIDFdO1xuICAgICAgICAgICAgeDEgPSBwb2x5Z29uQ2FjaGVbdjEgKyAwXTtcbiAgICAgICAgICAgIHkxID0gcG9seWdvbkNhY2hlW3YxICsgMV07XG4gICAgICAgICAgICB4MiA9IHBvbHlnb25DYWNoZVt2MiArIDBdO1xuICAgICAgICAgICAgeTIgPSBwb2x5Z29uQ2FjaGVbdjIgKyAxXTtcblxuICAgICAgICAgICAgdHgwID0geDAgKiBhICsgeTAgKiBjICsgZTtcbiAgICAgICAgICAgIHR5MCA9IHgwICogYiArIHkwICogZCArIGY7XG4gICAgICAgICAgICB0eDEgPSB4MSAqIGEgKyB5MSAqIGMgKyBlO1xuICAgICAgICAgICAgdHkxID0geDEgKiBiICsgeTEgKiBkICsgZjtcbiAgICAgICAgICAgIHR4MiA9IHgyICogYSArIHkyICogYyArIGU7XG4gICAgICAgICAgICB0eTIgPSB4MiAqIGIgKyB5MiAqIGQgKyBmO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MDtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgICAgICBwb2x5Z29uQ2FjaGUubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgYWRkRmlsbFJlY3Q6IGZ1bmN0aW9uIChcbiAgICAgICAgLyogR3JhcGhpY3MgR2FtZSBPYmplY3QgcHJvcGVydGllcyAqL1xuICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXG4gICAgICAgIC8qIFJlY3RhbmdsZSBwcm9wZXJ0aWVzICovXG4gICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxuICAgICAgICAvKiB0cmFuc2Zvcm0gKi9cbiAgICAgICAgYSwgYiwgYywgZCwgZSwgZlxuICAgICkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCArIDYgPiB0aGlzLm1heFZlcnRpY2VzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlclUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICB2YXIgdHgwID0geCAqIGEgKyB5ICogYyArIGU7XG4gICAgICAgIHZhciB0eTAgPSB4ICogYiArIHkgKiBkICsgZjtcbiAgICAgICAgdmFyIHR4MSA9IHggKiBhICsgeWggKiBjICsgZTtcbiAgICAgICAgdmFyIHR5MSA9IHggKiBiICsgeWggKiBkICsgZjtcbiAgICAgICAgdmFyIHR4MiA9IHh3ICogYSArIHloICogYyArIGU7XG4gICAgICAgIHZhciB0eTIgPSB4dyAqIGIgKyB5aCAqIGQgKyBmO1xuICAgICAgICB2YXIgdHgzID0geHcgKiBhICsgeSAqIGMgKyBlO1xuICAgICAgICB2YXIgdHkzID0geHcgKiBiICsgeSAqIGQgKyBmO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MTtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MTtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgyO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkyO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgKz0gNjtcbiAgICB9LFxuXG4gICAgYWRkRmlsbFRyaWFuZ2xlOiBmdW5jdGlvbiAoXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGZpbGxDb2xvciwgZmlsbEFscGhhLFxuICAgICAgICAvKiB0cmFuc2Zvcm0gKi9cbiAgICAgICAgYSwgYiwgYywgZCwgZSwgZlxuICAgICkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhDb3VudCArIDMgPiB0aGlzLm1heFZlcnRpY2VzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSB0aGlzLnZlcnRleERhdGFCdWZmZXI7XG4gICAgICAgIHZhciB2ZXJ0ZXhCdWZmZXJGMzIgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmZsb2F0VmlldztcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlclUzMiA9IHZlcnRleERhdGFCdWZmZXIudWludFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgdmFyIHR4MCA9IHgwICogYSArIHkwICogYyArIGU7XG4gICAgICAgIHZhciB0eTAgPSB4MCAqIGIgKyB5MCAqIGQgKyBmO1xuICAgICAgICB2YXIgdHgxID0geDEgKiBhICsgeTEgKiBjICsgZTtcbiAgICAgICAgdmFyIHR5MSA9IHgxICogYiArIHkxICogZCArIGY7XG4gICAgICAgIHZhciB0eDIgPSB4MiAqIGEgKyB5MiAqIGMgKyBlO1xuICAgICAgICB2YXIgdHkyID0geDIgKiBiICsgeTIgKiBkICsgZjtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbENvbG9yO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gZmlsbEFscGhhO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBmaWxsQWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxDb2xvcjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGZpbGxBbHBoYTtcblxuICAgICAgICB0aGlzLnZlcnRleENvdW50ICs9IDM7XG4gICAgfSxcblxuICAgIGFkZFN0cm9rZVRyaWFuZ2xlOiBmdW5jdGlvbiAoXG4gICAgICAgIC8qIEdyYXBoaWNzIEdhbWUgT2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgICAgICAgc3JjWCwgc3JjWSwgc3JjU2NhbGVYLCBzcmNTY2FsZVksIHNyY1JvdGF0aW9uLFxuICAgICAgICAvKiBUcmlhbmdsZSBwcm9wZXJ0aWVzICovXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsXG4gICAgICAgIC8qIHRyYW5zZm9ybSAqL1xuICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXG4gICAgKSB7XG4gICAgICAgIHZhciB0ZW1wVHJpYW5nbGUgPSB0aGlzLnRlbXBUcmlhbmdsZTtcblxuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ueCA9IHgwO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ueSA9IHkwO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbMF0ud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHRlbXBUcmlhbmdsZVswXS5yZ2IgPSBsaW5lQ29sb3I7XG4gICAgICAgIHRlbXBUcmlhbmdsZVswXS5hbHBoYSA9IGxpbmVBbHBoYTtcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnggPSB4MTtcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLnkgPSB5MTtcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzFdLndpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0ucmdiID0gbGluZUNvbG9yO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbMV0uYWxwaGEgPSBsaW5lQWxwaGE7XG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS54ID0geDI7XG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS55ID0geTI7XG4gICAgICAgIHRlbXBUcmlhbmdsZVsyXS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzJdLnJnYiA9IGxpbmVDb2xvcjtcbiAgICAgICAgdGVtcFRyaWFuZ2xlWzJdLmFscGhhID0gbGluZUFscGhhO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ueCA9IHgwO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ueSA9IHkwO1xuICAgICAgICB0ZW1wVHJpYW5nbGVbM10ud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHRlbXBUcmlhbmdsZVszXS5yZ2IgPSBsaW5lQ29sb3I7XG4gICAgICAgIHRlbXBUcmlhbmdsZVszXS5hbHBoYSA9IGxpbmVBbHBoYTtcblxuICAgICAgICB0aGlzLmFkZFN0cm9rZVBhdGgoXG4gICAgICAgICAgICBzcmNYLCBzcmNZLCBzcmNTY2FsZVgsIHNyY1NjYWxlWSwgc3JjUm90YXRpb24sXG4gICAgICAgICAgICB0ZW1wVHJpYW5nbGUsIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsXG4gICAgICAgICAgICBhLCBiLCBjLCBkLCBlLCBmXG4gICAgICAgICk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGFwZUJhdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9TaGFwZUJhdGNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgJ3VuaWZvcm0gbWF0NCB1X3ZpZXdfbWF0cml4OycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAnYXR0cmlidXRlIHZlYzQgYV9jb2xvcjsnLFxuICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbHBoYTsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdl9jb2xvcjsnLFxuICAgICd2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7JyxcbiAgICAndm9pZCBtYWluICgpIHsnLFxuICAgICcgICBnbF9Qb3NpdGlvbiA9IHVfdmlld19tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCwgMS4wKTsnLFxuICAgICcgICB2X2NvbG9yID0gYV9jb2xvcjsnLFxuICAgICcgICB2X2FscGhhID0gYV9hbHBoYTsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvVmVydGV4U2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEZyYWdtZW50U2hhZGVyID0gcmVxdWlyZSgnLi9GcmFnbWVudFNoYWRlcicpO1xudmFyIFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vVmVydGV4U2hhZGVyJyk7XG5cbnZhciBDT05TVCA9IHtcblxuICAgIFZFUlRFWF9TSVpFOiAxNixcblxuICAgIC8vIEhvdyBtYW55IDMyLWJpdCBjb21wb25lbnRzIGRvZXMgdGhlIHZlcnRleCBoYXZlLlxuICAgIFNIQVBFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDQsXG5cbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgdGhhbiAxMCwwMDAgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxuICAgIE1BWF9WRVJUSUNFUzogMTYwMDAsXG5cbiAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVmVydGV4U2hhZGVyLFxuICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZyYWdtZW50U2hhZGVyXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ09OU1Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1OTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zaGFwZS9jb25zdC5qcyIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3JlbmRlcmVyL3dlYmdsL2JhdGNoZXMvc2hhcGUvZWFyY3V0LmpzIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgbjtuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxuLmVhcmN1dD1lKCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBlKG4sdCxyKXtmdW5jdGlvbiB4KHUsZil7aWYoIXRbdV0pe2lmKCFuW3VdKXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZvKXJldHVybiBvKHUsITApO2lmKGkpcmV0dXJuIGkodSwhMCk7dmFyIHY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIit1K1wiJ1wiKTt0aHJvdyB2LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsdn12YXIgbD10W3VdPXtleHBvcnRzOnt9fTtuW3VdWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciB0PW5bdV1bMV1bZV07cmV0dXJuIHgodD90OmUpfSxsLGwuZXhwb3J0cyxlLG4sdCxyKX1yZXR1cm4gdFt1XS5leHBvcnRzfWZvcih2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHU9MDt1PHIubGVuZ3RoO3UrKyl4KHJbdV0pO3JldHVybiB4fSh7MTpbZnVuY3Rpb24oZSxuLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSxuLHQpe3Q9dHx8Mjt2YXIgcj1uJiZuLmxlbmd0aCxpPXI/blswXSp0OmUubGVuZ3RoLGY9eChlLDAsaSx0LCEwKSxvPVtdO2lmKCFmKXJldHVybiBvO3ZhciB2LGwscCxhLGgscyxjO2lmKHImJihmPXkoZSxuLGYsdCkpLGUubGVuZ3RoPjgwKnQpe3Y9cD1lWzBdLGw9YT1lWzFdO2Zvcih2YXIgZD10O2k+ZDtkKz10KWg9ZVtkXSxzPWVbZCsxXSx2PmgmJih2PWgpLGw+cyYmKGw9cyksaD5wJiYocD1oKSxzPmEmJihhPXMpO2M9TWF0aC5tYXgocC12LGEtbCl9cmV0dXJuIHUoZixvLHQsdixsLGMpLG99ZnVuY3Rpb24geChlLG4sdCxyLHgpe3ZhciBpLHU7aWYoeD09PV8oZSxuLHQscik+MClmb3IoaT1uO3Q+aTtpKz1yKXU9RShpLGVbaV0sZVtpKzFdLHUpO2Vsc2UgZm9yKGk9dC1yO2k+PW47aS09cil1PUUoaSxlW2ldLGVbaSsxXSx1KTtyZXR1cm4gdSYmeih1LHUubmV4dCkmJihOKHUpLHU9dS5uZXh0KSx1fWZ1bmN0aW9uIGkoZSxuKXtpZighZSlyZXR1cm4gZTtufHwobj1lKTt2YXIgdCxyPWU7ZG8gaWYodD0hMSxyLnN0ZWluZXJ8fCF6KHIsci5uZXh0KSYmMCE9PWIoci5wcmV2LHIsci5uZXh0KSlyPXIubmV4dDtlbHNle2lmKE4ocikscj1uPXIucHJldixyPT09ci5uZXh0KXJldHVybiBudWxsO3Q9ITB9d2hpbGUodHx8ciE9PW4pO3JldHVybiBufWZ1bmN0aW9uIHUoZSxuLHQscix4LHkscCl7aWYoZSl7IXAmJnkmJnMoZSxyLHgseSk7Zm9yKHZhciBhLGgsYz1lO2UucHJldiE9PWUubmV4dDspaWYoYT1lLnByZXYsaD1lLm5leHQseT9vKGUscix4LHkpOmYoZSkpbi5wdXNoKGEuaS90KSxuLnB1c2goZS5pL3QpLG4ucHVzaChoLmkvdCksTihlKSxlPWgubmV4dCxjPWgubmV4dDtlbHNlIGlmKGU9aCxlPT09Yyl7cD8xPT09cD8oZT12KGUsbix0KSx1KGUsbix0LHIseCx5LDIpKToyPT09cCYmbChlLG4sdCxyLHgseSk6dShpKGUpLG4sdCxyLHgseSwxKTticmVha319fWZ1bmN0aW9uIGYoZSl7dmFyIG49ZS5wcmV2LHQ9ZSxyPWUubmV4dDtpZihiKG4sdCxyKT49MClyZXR1cm4hMTtmb3IodmFyIHg9ZS5uZXh0Lm5leHQ7eCE9PWUucHJldjspe2lmKGcobi54LG4ueSx0LngsdC55LHIueCxyLnkseC54LHgueSkmJmIoeC5wcmV2LHgseC5uZXh0KT49MClyZXR1cm4hMTt4PXgubmV4dH1yZXR1cm4hMH1mdW5jdGlvbiBvKGUsbix0LHIpe3ZhciB4PWUucHJldixpPWUsdT1lLm5leHQ7aWYoYih4LGksdSk+PTApcmV0dXJuITE7Zm9yKHZhciBmPXgueDxpLng/eC54PHUueD94Lng6dS54OmkueDx1Lng/aS54OnUueCxvPXgueTxpLnk/eC55PHUueT94Lnk6dS55OmkueTx1Lnk/aS55OnUueSx2PXgueD5pLng/eC54PnUueD94Lng6dS54OmkueD51Lng/aS54OnUueCxsPXgueT5pLnk/eC55PnUueT94Lnk6dS55OmkueT51Lnk/aS55OnUueSx5PWQoZixvLG4sdCxyKSxwPWQodixsLG4sdCxyKSxhPWUubmV4dFo7YSYmYS56PD1wOyl7aWYoYSE9PWUucHJldiYmYSE9PWUubmV4dCYmZyh4LngseC55LGkueCxpLnksdS54LHUueSxhLngsYS55KSYmYihhLnByZXYsYSxhLm5leHQpPj0wKXJldHVybiExO2E9YS5uZXh0Wn1mb3IoYT1lLnByZXZaO2EmJmEuej49eTspe2lmKGEhPT1lLnByZXYmJmEhPT1lLm5leHQmJmcoeC54LHgueSxpLngsaS55LHUueCx1LnksYS54LGEueSkmJmIoYS5wcmV2LGEsYS5uZXh0KT49MClyZXR1cm4hMTthPWEucHJldlp9cmV0dXJuITB9ZnVuY3Rpb24gdihlLG4sdCl7dmFyIHI9ZTtkb3t2YXIgeD1yLnByZXYsaT1yLm5leHQubmV4dDsheih4LGkpJiZNKHgscixyLm5leHQsaSkmJnEoeCxpKSYmcShpLHgpJiYobi5wdXNoKHguaS90KSxuLnB1c2goci5pL3QpLG4ucHVzaChpLmkvdCksTihyKSxOKHIubmV4dCkscj1lPWkpLHI9ci5uZXh0fXdoaWxlKHIhPT1lKTtyZXR1cm4gcn1mdW5jdGlvbiBsKGUsbix0LHIseCxmKXt2YXIgbz1lO2Rve2Zvcih2YXIgdj1vLm5leHQubmV4dDt2IT09by5wcmV2Oyl7aWYoby5pIT09di5pJiZ3KG8sdikpe3ZhciBsPUQobyx2KTtyZXR1cm4gbz1pKG8sby5uZXh0KSxsPWkobCxsLm5leHQpLHUobyxuLHQscix4LGYpLHZvaWQgdShsLG4sdCxyLHgsZil9dj12Lm5leHR9bz1vLm5leHR9d2hpbGUobyE9PWUpfWZ1bmN0aW9uIHkoZSxuLHQscil7dmFyIHUsZixvLHYsbCx5PVtdO2Zvcih1PTAsZj1uLmxlbmd0aDtmPnU7dSsrKW89blt1XSpyLHY9Zi0xPnU/blt1KzFdKnI6ZS5sZW5ndGgsbD14KGUsbyx2LHIsITEpLGw9PT1sLm5leHQmJihsLnN0ZWluZXI9ITApLHkucHVzaChaKGwpKTtmb3IoeS5zb3J0KHApLHU9MDt1PHkubGVuZ3RoO3UrKylhKHlbdV0sdCksdD1pKHQsdC5uZXh0KTtyZXR1cm4gdH1mdW5jdGlvbiBwKGUsbil7cmV0dXJuIGUueC1uLnh9ZnVuY3Rpb24gYShlLG4pe2lmKG49aChlLG4pKXt2YXIgdD1EKG4sZSk7aSh0LHQubmV4dCl9fWZ1bmN0aW9uIGgoZSxuKXt2YXIgdCxyPW4seD1lLngsaT1lLnksdT0tKDEvMCk7ZG97aWYoaTw9ci55JiZpPj1yLm5leHQueSl7dmFyIGY9ci54KyhpLXIueSkqKHIubmV4dC54LXIueCkvKHIubmV4dC55LXIueSk7aWYoeD49ZiYmZj51KXtpZih1PWYsZj09PXgpe2lmKGk9PT1yLnkpcmV0dXJuIHI7aWYoaT09PXIubmV4dC55KXJldHVybiByLm5leHR9dD1yLng8ci5uZXh0Lng/cjpyLm5leHR9fXI9ci5uZXh0fXdoaWxlKHIhPT1uKTtpZighdClyZXR1cm4gbnVsbDtpZih4PT09dSlyZXR1cm4gdC5wcmV2O3ZhciBvLHY9dCxsPXQueCx5PXQueSxwPTEvMDtmb3Iocj10Lm5leHQ7ciE9PXY7KXg+PXIueCYmci54Pj1sJiZnKHk+aT94OnUsaSxsLHkseT5pP3U6eCxpLHIueCxyLnkpJiYobz1NYXRoLmFicyhpLXIueSkvKHgtci54KSwocD5vfHxvPT09cCYmci54PnQueCkmJnEocixlKSYmKHQ9cixwPW8pKSxyPXIubmV4dDtyZXR1cm4gdH1mdW5jdGlvbiBzKGUsbix0LHIpe3ZhciB4PWU7ZG8gbnVsbD09PXgueiYmKHguej1kKHgueCx4Lnksbix0LHIpKSx4LnByZXZaPXgucHJldix4Lm5leHRaPXgubmV4dCx4PXgubmV4dDt3aGlsZSh4IT09ZSk7eC5wcmV2Wi5uZXh0Wj1udWxsLHgucHJldlo9bnVsbCxjKHgpfWZ1bmN0aW9uIGMoZSl7dmFyIG4sdCxyLHgsaSx1LGYsbyx2PTE7ZG97Zm9yKHQ9ZSxlPW51bGwsaT1udWxsLHU9MDt0Oyl7Zm9yKHUrKyxyPXQsZj0wLG49MDt2Pm4mJihmKysscj1yLm5leHRaLHIpO24rKyk7Zm9yKG89djtmPjB8fG8+MCYmcjspMD09PWY/KHg9cixyPXIubmV4dFosby0tKTowIT09byYmcj90Lno8PXIuej8oeD10LHQ9dC5uZXh0WixmLS0pOih4PXIscj1yLm5leHRaLG8tLSk6KHg9dCx0PXQubmV4dFosZi0tKSxpP2kubmV4dFo9eDplPXgseC5wcmV2Wj1pLGk9eDt0PXJ9aS5uZXh0Wj1udWxsLHYqPTJ9d2hpbGUodT4xKTtyZXR1cm4gZX1mdW5jdGlvbiBkKGUsbix0LHIseCl7cmV0dXJuIGU9MzI3NjcqKGUtdCkveCxuPTMyNzY3KihuLXIpL3gsZT0xNjcxMTkzNSYoZXxlPDw4KSxlPTI1MjY0NTEzNSYoZXxlPDw0KSxlPTg1ODk5MzQ1OSYoZXxlPDwyKSxlPTE0MzE2NTU3NjUmKGV8ZTw8MSksbj0xNjcxMTkzNSYobnxuPDw4KSxuPTI1MjY0NTEzNSYobnxuPDw0KSxuPTg1ODk5MzQ1OSYobnxuPDwyKSxuPTE0MzE2NTU3NjUmKG58bjw8MSksZXxuPDwxfWZ1bmN0aW9uIFooZSl7dmFyIG49ZSx0PWU7ZG8gbi54PHQueCYmKHQ9biksbj1uLm5leHQ7d2hpbGUobiE9PWUpO3JldHVybiB0fWZ1bmN0aW9uIGcoZSxuLHQscix4LGksdSxmKXtyZXR1cm4oeC11KSoobi1mKS0oZS11KSooaS1mKT49MCYmKGUtdSkqKHItZiktKHQtdSkqKG4tZik+PTAmJih0LXUpKihpLWYpLSh4LXUpKihyLWYpPj0wfWZ1bmN0aW9uIHcoZSxuKXtyZXR1cm4gZS5uZXh0LmkhPT1uLmkmJmUucHJldi5pIT09bi5pJiYhbShlLG4pJiZxKGUsbikmJnEobixlKSYmTyhlLG4pfWZ1bmN0aW9uIGIoZSxuLHQpe3JldHVybihuLnktZS55KSoodC54LW4ueCktKG4ueC1lLngpKih0Lnktbi55KX1mdW5jdGlvbiB6KGUsbil7cmV0dXJuIGUueD09PW4ueCYmZS55PT09bi55fWZ1bmN0aW9uIE0oZSxuLHQscil7cmV0dXJuIHooZSxuKSYmeih0LHIpfHx6KGUscikmJnoodCxuKT8hMDpiKGUsbix0KT4wIT1iKGUsbixyKT4wJiZiKHQscixlKT4wIT1iKHQscixuKT4wfWZ1bmN0aW9uIG0oZSxuKXt2YXIgdD1lO2Rve2lmKHQuaSE9PWUuaSYmdC5uZXh0LmkhPT1lLmkmJnQuaSE9PW4uaSYmdC5uZXh0LmkhPT1uLmkmJk0odCx0Lm5leHQsZSxuKSlyZXR1cm4hMDt0PXQubmV4dH13aGlsZSh0IT09ZSk7cmV0dXJuITF9ZnVuY3Rpb24gcShlLG4pe3JldHVybiBiKGUucHJldixlLGUubmV4dCk8MD9iKGUsbixlLm5leHQpPj0wJiZiKGUsZS5wcmV2LG4pPj0wOmIoZSxuLGUucHJldik8MHx8YihlLGUubmV4dCxuKTwwfWZ1bmN0aW9uIE8oZSxuKXt2YXIgdD1lLHI9ITEseD0oZS54K24ueCkvMixpPShlLnkrbi55KS8yO2RvIHQueT5pIT10Lm5leHQueT5pJiZ4PCh0Lm5leHQueC10LngpKihpLXQueSkvKHQubmV4dC55LXQueSkrdC54JiYocj0hciksdD10Lm5leHQ7d2hpbGUodCE9PWUpO3JldHVybiByfWZ1bmN0aW9uIEQoZSxuKXt2YXIgdD1uZXcgVShlLmksZS54LGUueSkscj1uZXcgVShuLmksbi54LG4ueSkseD1lLm5leHQsaT1uLnByZXY7cmV0dXJuIGUubmV4dD1uLG4ucHJldj1lLHQubmV4dD14LHgucHJldj10LHIubmV4dD10LHQucHJldj1yLGkubmV4dD1yLHIucHJldj1pLHJ9ZnVuY3Rpb24gRShlLG4sdCxyKXt2YXIgeD1uZXcgVShlLG4sdCk7cmV0dXJuIHI/KHgubmV4dD1yLm5leHQseC5wcmV2PXIsci5uZXh0LnByZXY9eCxyLm5leHQ9eCk6KHgucHJldj14LHgubmV4dD14KSx4fWZ1bmN0aW9uIE4oZSl7ZS5uZXh0LnByZXY9ZS5wcmV2LGUucHJldi5uZXh0PWUubmV4dCxlLnByZXZaJiYoZS5wcmV2Wi5uZXh0Wj1lLm5leHRaKSxlLm5leHRaJiYoZS5uZXh0Wi5wcmV2Wj1lLnByZXZaKX1mdW5jdGlvbiBVKGUsbix0KXt0aGlzLmk9ZSx0aGlzLng9bix0aGlzLnk9dCx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLno9bnVsbCx0aGlzLnByZXZaPW51bGwsdGhpcy5uZXh0Wj1udWxsLHRoaXMuc3RlaW5lcj0hMX1mdW5jdGlvbiBfKGUsbix0LHIpe2Zvcih2YXIgeD0wLGk9bix1PXQtcjt0Pmk7aSs9cil4Kz0oZVt1XS1lW2ldKSooZVtpKzFdK2VbdSsxXSksdT1pO3JldHVybiB4fW4uZXhwb3J0cz1yLHIuZGV2aWF0aW9uPWZ1bmN0aW9uKGUsbix0LHIpe3ZhciB4PW4mJm4ubGVuZ3RoLGk9eD9uWzBdKnQ6ZS5sZW5ndGgsdT1NYXRoLmFicyhfKGUsMCxpLHQpKTtpZih4KWZvcih2YXIgZj0wLG89bi5sZW5ndGg7bz5mO2YrKyl7dmFyIHY9bltmXSp0LGw9by0xPmY/bltmKzFdKnQ6ZS5sZW5ndGg7dS09TWF0aC5hYnMoXyhlLHYsbCx0KSl9dmFyIHk9MDtmb3IoZj0wO2Y8ci5sZW5ndGg7Zis9Myl7dmFyIHA9cltmXSp0LGE9cltmKzFdKnQsaD1yW2YrMl0qdDt5Kz1NYXRoLmFicygoZVtwXS1lW2hdKSooZVthKzFdLWVbcCsxXSktKGVbcF0tZVthXSkqKGVbaCsxXS1lW3ArMV0pKX1yZXR1cm4gMD09PXUmJjA9PT15PzA6TWF0aC5hYnMoKHktdSkvdSl9LHIuZmxhdHRlbj1mdW5jdGlvbihlKXtmb3IodmFyIG49ZVswXVswXS5sZW5ndGgsdD17dmVydGljZXM6W10saG9sZXM6W10sZGltZW5zaW9uczpufSxyPTAseD0wO3g8ZS5sZW5ndGg7eCsrKXtmb3IodmFyIGk9MDtpPGVbeF0ubGVuZ3RoO2krKylmb3IodmFyIHU9MDtuPnU7dSsrKXQudmVydGljZXMucHVzaChlW3hdW2ldW3VdKTt4PjAmJihyKz1lW3gtMV0ubGVuZ3RoLHQuaG9sZXMucHVzaChyKSl9cmV0dXJuIHR9fSx7fV19LHt9LFsxXSkoMSl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3NoYXBlL2VhcmN1dC5qc1xuLy8gbW9kdWxlIGlkID0gNTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X3NhbXBsZXIyRDsnLFxuICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhfY29vcmQ7JyxcbiAgICAndmFyeWluZyB2ZWMzIHZfY29sb3I7JyxcbiAgICAndmFyeWluZyBmbG9hdCB2X2FscGhhOycsXG4gICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9zYW1wbGVyMkQsIHZfdGV4X2Nvb3JkKSAqIHZlYzQodl9jb2xvciwgdl9hbHBoYSk7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9GcmFnbWVudFNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCaW5kVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vQmluZFZlcnRleEFycmF5Jyk7XG52YXIgQ3JlYXRlUHJvZ3JhbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3NoYWRlci9DcmVhdGVQcm9ncmFtJyk7XG52YXIgQ3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc2hhZGVyL0NyZWF0ZVNoYWRlcicpO1xudmFyIENyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9DcmVhdGVCdWZmZXInKTtcbnZhciBDcmVhdGVBdHRyaWJEZXNjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdmFvL0NyZWF0ZUF0dHJpYkRlc2MnKTtcbnZhciBCdWZmZXIzMiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2J1ZmZlci9CdWZmZXIzMicpO1xudmFyIEJ1ZmZlcjE2ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnVmZmVyL0J1ZmZlcjE2Jyk7XG52YXIgVmVydGV4QXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlscy92YW8vVmVydGV4QXJyYXknKTtcbnZhciBUcmFuc2Zvcm1NYXRyaXggPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb21wb25lbnRzL1RyYW5zZm9ybU1hdHJpeCcpO1xuXG52YXIgUEhBU0VSX0NPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3QnKTtcbnZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcblxudmFyIFNwcml0ZUJhdGNoID0gZnVuY3Rpb24gKGdhbWUsIGdsLCBtYW5hZ2VyKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG4gICAgdGhpcy50eXBlID0gUEhBU0VSX0NPTlNULldFQkdMO1xuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IGdhbWUuY29uZmlnLndpZHRoICogZ2FtZS5jb25maWcucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuY29uZmlnLmhlaWdodCAqIGdhbWUuY29uZmlnLnJlc29sdXRpb247XG4gICAgdGhpcy5nbENvbnRleHQgPSBnbDtcbiAgICB0aGlzLm1heFNwcml0ZXMgPSBudWxsO1xuICAgIHRoaXMudmVydFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMudmVydGV4QXJyYXkgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QgPSBudWxsO1xuICAgIHRoaXMudmVydGV4RGF0YUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5pbmRleERhdGFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUZXh0dXJlMkQgPSBudWxsO1xuICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgLy8gICBBbGwgb2YgdGhlc2Ugc2V0dGluZ3Mgd2lsbCBiZSBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgdmlhIHRoZSBHYW1lIENvbmZpZ1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcblxuICAgICAgICBXZWJHTENvbnRleHRPcHRpb25zOiB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLmluaXQodGhpcy5nbENvbnRleHQpO1xufTtcblxuU3ByaXRlQmF0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlQmF0Y2g7XG5cblNwcml0ZUJhdGNoLnByb3RvdHlwZSA9IHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uIChnbClcbiAgICB7XG5cbiAgICAgICAgdmFyIHZlcnRleERhdGFCdWZmZXIgPSBuZXcgQnVmZmVyMzIoQ09OU1QuVkVSVEVYX1NJWkUgKiBDT05TVC5TUFJJVEVfVkVSVEVYX0NPVU5UICogQ09OU1QuTUFYX1NQUklURVMpO1xuICAgICAgICB2YXIgaW5kZXhEYXRhQnVmZmVyID0gbmV3IEJ1ZmZlcjE2KENPTlNULklOREVYX1NJWkUgKiBDT05TVC5TUFJJVEVfSU5ERVhfQ09VTlQgKiBDT05TVC5NQVhfU1BSSVRFUyk7XG4gICAgICAgIHZhciB2ZXJ0U2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5WRVJURVhfU0hBREVSX1NPVVJDRSwgZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnU2hhZGVyID0gQ3JlYXRlU2hhZGVyKGdsLCBDT05TVC5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IENyZWF0ZVByb2dyYW0oZ2wsIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpO1xuICAgICAgICB2YXIgaW5kZXhCdWZmZXJPYmplY3QgPSBDcmVhdGVCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnbC5TVEFUSUNfRFJBVywgbnVsbCwgaW5kZXhEYXRhQnVmZmVyLmdldEJ5dGVDYXBhY2l0eSgpKTtcbiAgICAgICAgdmFyIGF0dHJpYkFycmF5ID0gW1xuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAwKSxcbiAgICAgICAgICAgIENyZWF0ZUF0dHJpYkRlc2MoZ2wsIHByb2dyYW0sICdhX3RleF9jb29yZCcsIDIsIGdsLkZMT0FULCBmYWxzZSwgQ09OU1QuVkVSVEVYX1NJWkUsIDgpLFxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfY29sb3InLCAzLCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBDT05TVC5WRVJURVhfU0laRSwgMTYpLFxuICAgICAgICAgICAgQ3JlYXRlQXR0cmliRGVzYyhnbCwgcHJvZ3JhbSwgJ2FfYWxwaGEnLCAxLCBnbC5GTE9BVCwgZmFsc2UsIENPTlNULlZFUlRFWF9TSVpFLCAyMClcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IFZlcnRleEFycmF5KENyZWF0ZUJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBnbC5TVFJFQU1fRFJBVywgbnVsbCwgdmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSksIGF0dHJpYkFycmF5KTtcbiAgICAgICAgdmFyIHZpZXdNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV92aWV3X21hdHJpeCcpO1xuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBpbmRleERhdGFCdWZmZXIudWludFZpZXc7XG4gICAgICAgIHZhciBtYXggPSBDT05TVC5NQVhfU1BSSVRFUyAqIENPTlNULlNQUklURV9JTkRFWF9DT1VOVDtcblxuICAgICAgICB0aGlzLnZlcnRleERhdGFCdWZmZXIgPSB2ZXJ0ZXhEYXRhQnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4RGF0YUJ1ZmZlciA9IGluZGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcbiAgICAgICAgdGhpcy5mcmFnU2hhZGVyID0gZnJhZ1NoYWRlcjtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlck9iamVjdCA9IGluZGV4QnVmZmVyT2JqZWN0O1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5ID0gdmVydGV4QXJyYXk7XG4gICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uID0gdmlld01hdHJpeExvY2F0aW9uO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBpbmRleCBidWZmZXIgb25seSBvbmNlXG4gICAgICAgIGZvciAodmFyIGluZGV4QSA9IDAsIGluZGV4QiA9IDA7IGluZGV4QSA8IG1heDsgaW5kZXhBICs9IENPTlNULlNQUklURV9JTkRFWF9DT1VOVCwgaW5kZXhCICs9IENPTlNULlNQUklURV9WRVJURVhfQ09VTlQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDBdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDFdID0gaW5kZXhCICsgMTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDJdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDNdID0gaW5kZXhCICsgMDtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDRdID0gaW5kZXhCICsgMjtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyW2luZGV4QSArIDVdID0gaW5kZXhCICsgMztcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4QnVmZmVyT2JqZWN0KTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgaW5kZXhCdWZmZXIpO1xuXG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nYW1lLmNvbmZpZy5yZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9LFxuXG4gICAgaXNGdWxsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleERhdGFCdWZmZXIuZ2V0Qnl0ZUxlbmd0aCgpID49IHRoaXMudmVydGV4RGF0YUJ1ZmZlci5nZXRCeXRlQ2FwYWNpdHkoKSk7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXJPYmplY3QpO1xuICAgICAgICBCaW5kVmVydGV4QXJyYXkoZ2wsIHRoaXMudmVydGV4QXJyYXkpO1xuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRDb3VudCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhQnVmZmVyID0gdGhpcy52ZXJ0ZXhEYXRhQnVmZmVyO1xuXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0ZXhEYXRhQnVmZmVyLmdldFVzZWRCdWZmZXJBc0Zsb2F0KCkpO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmVsZW1lbnRDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB2ZXJ0ZXhEYXRhQnVmZmVyLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgPSAwO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbENvbnRleHQ7XG4gICAgICAgIFxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHJlc29sdXRpb247XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihcbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeExvY2F0aW9uLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy53aWR0aCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAtMiAvIHRoaXMuaGVpZ2h0LCAwLCAwLFxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIDEsXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDBcbiAgICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsQ29udGV4dDtcblxuICAgICAgICBpZiAoZ2wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRTaGFkZXIpO1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ1NoYWRlcik7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlck9iamVjdCk7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhBcnJheS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFNwcml0ZVRleHR1cmU6IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSwgdGV4dHVyZSwgdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBNYXRyaXggPSB0aGlzLnRlbXBNYXRyaXg7XG4gICAgICAgIHZhciBhbHBoYSA9IDE2Nzc3MjE2O1xuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB3aWR0aCA9IHRleHR1cmVXaWR0aCAqIChzcmMuZmxpcFggPyAtMSA6IDEpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dHVyZUhlaWdodCAqIChzcmMuZmxpcFkgPyAtMSA6IDEpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlWCA9IHNyYy54IC0gY2FtZXJhLnNjcm9sbFg7XG4gICAgICAgIHZhciB0cmFuc2xhdGVZID0gc3JjLnkgLSBjYW1lcmEuc2Nyb2xsWTtcbiAgICAgICAgdmFyIHNjYWxlWCA9IHNyYy5zY2FsZVg7XG4gICAgICAgIHZhciBzY2FsZVkgPSBzcmMuc2NhbGVZO1xuICAgICAgICB2YXIgcm90YXRpb24gPSAtc3JjLnJvdGF0aW9uO1xuICAgICAgICB2YXIgdGVtcE1hdHJpeE1hdHJpeCA9IHRlbXBNYXRyaXgubWF0cml4O1xuICAgICAgICB2YXIgeCA9IC1zcmMuZGlzcGxheU9yaWdpblggKyAoKHRleHR1cmVXaWR0aCkgKiAoc3JjLmZsaXBYID8gMSA6IDAuMCkpO1xuICAgICAgICB2YXIgeSA9IC1zcmMuZGlzcGxheU9yaWdpblkgKyAoKHRleHR1cmVIZWlnaHQpICogKHNyYy5mbGlwWSA/IDEgOiAwLjApKTtcbiAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xuICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICB2YXIgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeC5tYXRyaXg7XG4gICAgICAgIHZhciBtdmEsIG12YiwgbXZjLCBtdmQsIG12ZSwgbXZmLCB0eDAsIHR5MCwgdHgxLCB0eTEsIHR4MiwgdHkyLCB0eDMsIHR5MztcbiAgICAgICAgdmFyIHNyYSwgc3JiLCBzcmMsIHNyZCwgc3JlLCBzcmYsIGNtYSwgY21iLCBjbWMsIGNtZCwgY21lLCBjbWY7XG4gICAgICAgIHZhciBhbHBoYSA9IHNyYy5hbHBoYTtcblxuICAgICAgICB0ZW1wTWF0cml4LmFwcGx5SVRSUyh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVkpO1xuXG4gICAgICAgIHNyYSA9IHRlbXBNYXRyaXhNYXRyaXhbMF07XG4gICAgICAgIHNyYiA9IHRlbXBNYXRyaXhNYXRyaXhbMV07XG4gICAgICAgIHNyYyA9IHRlbXBNYXRyaXhNYXRyaXhbMl07XG4gICAgICAgIHNyZCA9IHRlbXBNYXRyaXhNYXRyaXhbM107XG4gICAgICAgIHNyZSA9IHRlbXBNYXRyaXhNYXRyaXhbNF07XG4gICAgICAgIHNyZiA9IHRlbXBNYXRyaXhNYXRyaXhbNV07XG5cbiAgICAgICAgY21hID0gY2FtZXJhTWF0cml4WzBdO1xuICAgICAgICBjbWIgPSBjYW1lcmFNYXRyaXhbMV07XG4gICAgICAgIGNtYyA9IGNhbWVyYU1hdHJpeFsyXTtcbiAgICAgICAgY21kID0gY2FtZXJhTWF0cml4WzNdO1xuICAgICAgICBjbWUgPSBjYW1lcmFNYXRyaXhbNF07XG4gICAgICAgIGNtZiA9IGNhbWVyYU1hdHJpeFs1XTtcblxuICAgICAgICBtdmEgPSBzcmEgKiBjbWEgKyBzcmIgKiBjbWM7XG4gICAgICAgIG12YiA9IHNyYSAqIGNtYiArIHNyYiAqIGNtZDtcbiAgICAgICAgbXZjID0gc3JjICogY21hICsgc3JkICogY21jO1xuICAgICAgICBtdmQgPSBzcmMgKiBjbWIgKyBzcmQgKiBjbWQ7XG4gICAgICAgIG12ZSA9IHNyZSAqIGNtYSArIHNyZiAqIGNtYyArIGNtZTtcbiAgICAgICAgbXZmID0gc3JlICogY21iICsgc3JmICogY21kICsgY21mOyBcbiAgICAgICAgXG4gICAgICAgIHR4MCA9IHggKiBtdmEgKyB5ICogbXZjICsgbXZlO1xuICAgICAgICB0eTAgPSB4ICogbXZiICsgeSAqIG12ZCArIG12ZjtcbiAgICAgICAgdHgxID0geCAqIG12YSArIHloICogbXZjICsgbXZlO1xuICAgICAgICB0eTEgPSB4ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XG4gICAgICAgIHR4MiA9IHh3ICogbXZhICsgeWggKiBtdmMgKyBtdmU7XG4gICAgICAgIHR5MiA9IHh3ICogbXZiICsgeWggKiBtdmQgKyBtdmY7XG4gICAgICAgIHR4MyA9IHh3ICogbXZhICsgeSAqIG12YyArIG12ZTtcbiAgICAgICAgdHkzID0geHcgKiBtdmIgKyB5ICogbXZkICsgbXZmO1xuXG4gICAgICAgIHRoaXMubWFuYWdlci5zZXRCYXRjaCh0aGlzLCB0ZXh0dXJlLCBjYW1lcmEpO1xuICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhEYXRhQnVmZmVyLmFsbG9jYXRlKDI0KTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q291bnQgKz0gNjtcbiAgICAgICAgXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDA7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTA7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLnRvcExlZnQ7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgxO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkxO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gMDtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci5ib3R0b21MZWZ0O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAxO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IuYm90dG9tUmlnaHQ7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSBhbHBoYTtcblxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkzO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gMTtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IDA7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci50b3BSaWdodDtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuICAgIH0sXG5cbiAgICBhZGRTcHJpdGU6IGZ1bmN0aW9uIChzcmMsIGNhbWVyYSlcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wTWF0cml4ID0gdGhpcy50ZW1wTWF0cml4O1xuICAgICAgICB2YXIgZnJhbWUgPSBzcmMuZnJhbWU7XG4gICAgICAgIHZhciBhbHBoYSA9IDE2Nzc3MjE2O1xuICAgICAgICB2YXIgdmVydGV4RGF0YUJ1ZmZlciA9IHRoaXMudmVydGV4RGF0YUJ1ZmZlcjtcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlckYzMiA9IHZlcnRleERhdGFCdWZmZXIuZmxvYXRWaWV3O1xuICAgICAgICB2YXIgdmVydGV4QnVmZmVyVTMyID0gdmVydGV4RGF0YUJ1ZmZlci51aW50VmlldztcbiAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB1dnMgPSBmcmFtZS51dnM7XG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoICogKHNyYy5mbGlwWCA/IC0xIDogMSk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiAoc3JjLmZsaXBZID8gLTEgOiAxKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBzcmMueCAtIGNhbWVyYS5zY3JvbGxYO1xuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IHNyYy55IC0gY2FtZXJhLnNjcm9sbFk7XG4gICAgICAgIHZhciBzY2FsZVggPSBzcmMuc2NhbGVYO1xuICAgICAgICB2YXIgc2NhbGVZID0gc3JjLnNjYWxlWTtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gLXNyYy5yb3RhdGlvbjtcbiAgICAgICAgdmFyIHRlbXBNYXRyaXhNYXRyaXggPSB0ZW1wTWF0cml4Lm1hdHJpeDtcbiAgICAgICAgdmFyIHggPSAtc3JjLmRpc3BsYXlPcmlnaW5YICsgZnJhbWUueCArICgoZnJhbWUud2lkdGgpICogKHNyYy5mbGlwWCA/IDEgOiAwLjApKTtcbiAgICAgICAgdmFyIHkgPSAtc3JjLmRpc3BsYXlPcmlnaW5ZICsgZnJhbWUueSArICgoZnJhbWUuaGVpZ2h0KSAqIChzcmMuZmxpcFkgPyAxIDogMC4wKSk7XG4gICAgICAgIHZhciB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcbiAgICAgICAgdmFyIGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXgubWF0cml4O1xuICAgICAgICB2YXIgbXZhLCBtdmIsIG12YywgbXZkLCBtdmUsIG12ZiwgdHgwLCB0eTAsIHR4MSwgdHkxLCB0eDIsIHR5MiwgdHgzLCB0eTM7XG4gICAgICAgIHZhciBzcmEsIHNyYiwgc3JjLCBzcmQsIHNyZSwgc3JmLCBjbWEsIGNtYiwgY21jLCBjbWQsIGNtZSwgY21mO1xuICAgICAgICB2YXIgYWxwaGEgPSBzcmMuYWxwaGE7XG5cbiAgICAgICAgdGVtcE1hdHJpeC5hcHBseUlUUlModHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm90YXRpb24sIHNjYWxlWCwgc2NhbGVZKTtcblxuICAgICAgICBzcmEgPSB0ZW1wTWF0cml4TWF0cml4WzBdO1xuICAgICAgICBzcmIgPSB0ZW1wTWF0cml4TWF0cml4WzFdO1xuICAgICAgICBzcmMgPSB0ZW1wTWF0cml4TWF0cml4WzJdO1xuICAgICAgICBzcmQgPSB0ZW1wTWF0cml4TWF0cml4WzNdO1xuICAgICAgICBzcmUgPSB0ZW1wTWF0cml4TWF0cml4WzRdO1xuICAgICAgICBzcmYgPSB0ZW1wTWF0cml4TWF0cml4WzVdO1xuXG4gICAgICAgIGNtYSA9IGNhbWVyYU1hdHJpeFswXTtcbiAgICAgICAgY21iID0gY2FtZXJhTWF0cml4WzFdO1xuICAgICAgICBjbWMgPSBjYW1lcmFNYXRyaXhbMl07XG4gICAgICAgIGNtZCA9IGNhbWVyYU1hdHJpeFszXTtcbiAgICAgICAgY21lID0gY2FtZXJhTWF0cml4WzRdO1xuICAgICAgICBjbWYgPSBjYW1lcmFNYXRyaXhbNV07XG5cbiAgICAgICAgbXZhID0gc3JhICogY21hICsgc3JiICogY21jO1xuICAgICAgICBtdmIgPSBzcmEgKiBjbWIgKyBzcmIgKiBjbWQ7XG4gICAgICAgIG12YyA9IHNyYyAqIGNtYSArIHNyZCAqIGNtYztcbiAgICAgICAgbXZkID0gc3JjICogY21iICsgc3JkICogY21kO1xuICAgICAgICBtdmUgPSBzcmUgKiBjbWEgKyBzcmYgKiBjbWMgKyBjbWU7XG4gICAgICAgIG12ZiA9IHNyZSAqIGNtYiArIHNyZiAqIGNtZCArIGNtZjsgXG4gICAgICAgIFxuICAgICAgICB0eDAgPSB4ICogbXZhICsgeSAqIG12YyArIG12ZTtcbiAgICAgICAgdHkwID0geCAqIG12YiArIHkgKiBtdmQgKyBtdmY7XG4gICAgICAgIHR4MSA9IHggKiBtdmEgKyB5aCAqIG12YyArIG12ZTtcbiAgICAgICAgdHkxID0geCAqIG12YiArIHloICogbXZkICsgbXZmO1xuICAgICAgICB0eDIgPSB4dyAqIG12YSArIHloICogbXZjICsgbXZlO1xuICAgICAgICB0eTIgPSB4dyAqIG12YiArIHloICogbXZkICsgbXZmO1xuICAgICAgICB0eDMgPSB4dyAqIG12YSArIHkgKiBtdmMgKyBtdmU7XG4gICAgICAgIHR5MyA9IHh3ICogbXZiICsgeSAqIG12ZCArIG12ZjtcblxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0QmF0Y2godGhpcywgZnJhbWUudGV4dHVyZS5zb3VyY2VbZnJhbWUuc291cmNlSW5kZXhdLmdsVGV4dHVyZSwgY2FtZXJhKTtcbiAgICAgICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4RGF0YUJ1ZmZlci5hbGxvY2F0ZSgyNCk7XG4gICAgICAgIHRoaXMuZWxlbWVudENvdW50ICs9IDY7XG4gICAgICAgIFxuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHgwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdHkwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLngwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gdXZzLnkwO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJVMzJbdmVydGV4T2Zmc2V0KytdID0gMHhGRkZGRkY7IC8vdmVydGV4Q29sb3IudG9wTGVmdDtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IGFscGhhO1xuXG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB0eTE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueDE7XG4gICAgICAgIHZlcnRleEJ1ZmZlckYzMlt2ZXJ0ZXhPZmZzZXQrK10gPSB1dnMueTE7XG4gICAgICAgIHZlcnRleEJ1ZmZlclUzMlt2ZXJ0ZXhPZmZzZXQrK10gPSAweEZGRkZGRjsgLy92ZXJ0ZXhDb2xvci5ib3R0b21MZWZ0O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MjtcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MjtcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLmJvdHRvbVJpZ2h0O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG5cbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR4MztcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHR5MztcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy54MztcbiAgICAgICAgdmVydGV4QnVmZmVyRjMyW3ZlcnRleE9mZnNldCsrXSA9IHV2cy55MztcbiAgICAgICAgdmVydGV4QnVmZmVyVTMyW3ZlcnRleE9mZnNldCsrXSA9IDB4RkZGRkZGOyAvL3ZlcnRleENvbG9yLnRvcFJpZ2h0O1xuICAgICAgICB2ZXJ0ZXhCdWZmZXJGMzJbdmVydGV4T2Zmc2V0KytdID0gYWxwaGE7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUJhdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvU3ByaXRlQmF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDU5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9TcHJpdGVCYXRjaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAgICd1bmlmb3JtIG1hdDQgdV92aWV3X21hdHJpeDsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4X2Nvb3JkOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7JyxcbiAgICAnYXR0cmlidXRlIGZsb2F0IGFfYWxwaGE7JyxcbiAgICAndmFyeWluZyB2ZWMyIHZfdGV4X2Nvb3JkOycsXG4gICAgJ3ZhcnlpbmcgdmVjMyB2X2NvbG9yOycsXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdl9hbHBoYTsnLFxuICAgICd2b2lkIG1haW4gKCkgeycsXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdV92aWV3X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wLCAxLjApOycsXG4gICAgJyAgIHZfdGV4X2Nvb3JkID0gYV90ZXhfY29vcmQ7JyxcbiAgICAnICAgdl9jb2xvciA9IGFfY29sb3I7JyxcbiAgICAnICAgdl9hbHBoYSA9IGFfYWxwaGE7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9WZXJ0ZXhTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL0ZyYWdtZW50U2hhZGVyJyk7XG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9WZXJ0ZXhTaGFkZXInKTtcblxudmFyIENPTlNUID0ge1xuXG4gICAgLy8gVkVSVEVYX1NJWkUgPSAoc2l6ZW9mKHZlYzIpICogNCkgKyAoc2l6ZW9mKGZsb2F0KSArIHNpemVvZih1aW50MzIpKVxuICAgIFZFUlRFWF9TSVpFOiAyNCxcbiAgICBJTkRFWF9TSVpFOiAyLFxuICAgIFNQUklURV9WRVJURVhfQ09VTlQ6IDQsXG4gICAgU1BSSVRFX0lOREVYX0NPVU5UOiA2LFxuXG4gICAgLy8gSG93IG1hbnkgMzItYml0IGNvbXBvbmVudHMgZG9lcyB0aGUgdmVydGV4IGhhdmUuXG4gICAgU1BSSVRFX1ZFUlRFWF9DT01QT05FTlRfQ09VTlQ6IDYsXG5cbiAgICAvLyBDYW4ndCBiZSBiaWdnZXIgc2luY2UgaW5kZXggYXJlIDE2LWJpdFxuICAgIE1BWF9TUFJJVEVTOiAyMDAwLFxuXG4gICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZlcnRleFNoYWRlcixcbiAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGcmFnbWVudFNoYWRlclxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvYmF0Y2hlcy9zcHJpdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDYwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC9iYXRjaGVzL3Nwcml0ZS9jb25zdC5qcyIsInZhciBTY2FsZU1vZGVzID0gcmVxdWlyZSgnLi4vLi4vU2NhbGVNb2RlcycpO1xuXG52YXIgQ3JlYXRlRW1wdHlUZXh0dXJlID0gZnVuY3Rpb24gKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHRleHR1cmVJbmRleClcbntcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB2YXIgZ2xTY2FsZU1vZGUgPSAoc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUikgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVJbmRleCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAgIC8vICBXZSdsbCByZWFkIGZyb20gdGhpcyB0ZXh0dXJlLCBidXQgaXQgd29uJ3QgaGF2ZSBtaXBtYXBzLCBzbyB0dXJuIHRoZW0gb2ZmOlxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbFNjYWxlTW9kZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsU2NhbGVNb2RlKTtcblxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlRW1wdHlUZXh0dXJlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlRW1wdHlUZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVuZGVyZXIvd2ViZ2wvdXRpbHMvQ3JlYXRlRW1wdHlUZXh0dXJlLmpzIiwidmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9TY2FsZU1vZGVzJyk7XG52YXIgQ3JlYXRlVGV4dHVyZTJESW1hZ2UgPSByZXF1aXJlKCcuL0NyZWF0ZVRleHR1cmUyREltYWdlJyk7XG5cbnZhciBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlID0gZnVuY3Rpb24gKGdsLCBzb3VyY2UpXG57XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmIChzb3VyY2Uuc2NhbGVNb2RlID09PSBTY2FsZU1vZGVzLkxJTkVBUilcbiAgICB7XG4gICAgICAgIGZpbHRlciA9IGdsLkxJTkVBUjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlLnNjYWxlTW9kZSA9PT0gU2NhbGVNb2Rlcy5ORUFSRVNUKVxuICAgIHtcbiAgICAgICAgZmlsdGVyID0gZ2wuTkVBUkVTVDtcbiAgICB9XG5cbiAgICBzb3VyY2UuZ2xUZXh0dXJlID0gQ3JlYXRlVGV4dHVyZTJESW1hZ2UoZ2wsIHNvdXJjZS5pbWFnZSwgZmlsdGVyLCBzb3VyY2UubWlwbWFwTGV2ZWwpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDYwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZW5kZXJlci93ZWJnbC91dGlscy90ZXh0dXJlL0NyZWF0ZVRleHR1cmUyREZyb21Tb3VyY2UuanMiLCJ2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldClcbntcbiAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3JlbmRlcmVyL3dlYmdsL3V0aWxzL3Zhby9BdHRyaWJ1dGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBCZXR3ZWVuID0gcmVxdWlyZSgnLi4vLi4vbWF0aC9CZXR3ZWVuJyk7XG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QvR2V0T2JqZWN0VmFsdWUnKTtcblxuLy8gIFBoYXNlci5Tb3VuZC5EeW5hbWljLkZYXG5cbi8vICBCYXNlZCBvbiBTb3VuZC5qcyBieSBLaXR0eUthdEF0dGFja1xuLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9raXR0eWthdGF0dGFjay9zb3VuZC5qc1xuXG4vLyBmcmVxdWVuY3ksICAgICAgLy9UaGUgc291bmQncyBmZXF1ZW5jeSBwaXRjaCBpbiBIZXJ0elxuLy8gYXR0YWNrLCAgICAgICAgICAgICAgLy9UaGUgdGltZSwgaW4gc2Vjb25kcywgdG8gZmFkZSB0aGUgc291bmQgaW5cbi8vIGRlY2F5LCAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIGZhZGUgdGhlIHNvdW5kIG91dFxuLy8gdHlwZSwgICAgICAgICAgICAgICAgLy93YXZlZm9ybSB0eXBlOiBcInNpbmVcIiwgXCJ0cmlhbmdsZVwiLCBcInNxdWFyZVwiLCBcInNhd3Rvb3RoXCJcbi8vIHZvbHVtZSwgICAgICAgICAvL1RoZSBzb3VuZCdzIG1heGltdW0gdm9sdW1lXG4vLyBwYW5WYWx1ZSwgICAgICAgICAgICAvL1RoZSBzcGVha2VyIHBhbi4gbGVmdDogLTEsIG1pZGRsZTogMCwgcmlnaHQ6IDFcbi8vIHdhaXQsICAgICAgICAgICAgICAgIC8vVGhlIHRpbWUsIGluIHNlY29uZHMsIHRvIHdhaXQgYmVmb3JlIHBsYXlpbmcgdGhlIHNvdW5kXG4vLyBwaXRjaEJlbmQsICAgICAvL1RoZSBudW1iZXIgb2YgSHogaW4gd2hpY2ggdG8gYmVuZCB0aGUgc291bmQncyBwaXRjaCBkb3duXG4vLyByZXZlcnNlLCAgICAgICAgICAgICAvL0lmIGByZXZlcnNlYCBpcyB0cnVlIHRoZSBwaXRjaCB3aWxsIGJlbmQgdXBcbi8vIHJhbmRvbSwgICAgICAgICAvL0EgcmFuZ2UsIGluIEh6LCB3aXRoaW4gd2hpY2ggdG8gcmFuZG9taXplIHRoZSBwaXRjaFxuLy8gZGlzc29uYW5jZSwgICAgICAgICAgLy9BIHZhbHVlIGluIEh6LiBJdCBjcmVhdGVzIDIgZGlzc29uYW50IGZyZXF1ZW5jaWVzIGFib3ZlIGFuZCBiZWxvdyB0aGUgdGFyZ2V0IHBpdGNoXG4vLyBlY2hvLCAgICAgICAgICAgICAgICAvL0FuIGFycmF5OiBbZGVsYXlUaW1lSW5TZWNvbmRzLCBmZWVkYmFja1RpbWVJblNlY29uZHMsIGZpbHRlclZhbHVlSW5Iel1cbi8vIHJldmVyYiwgICAgICAgICAgICAgIC8vQW4gYXJyYXk6IFtkdXJhdGlvbkluU2Vjb25kcywgZGVjYXlSYXRlSW5TZWNvbmRzLCByZXZlcnNlXVxuLy8gdGltZW91dCAgICAgICAgICAgICAgLy9BIG51bWJlciwgaW4gc2Vjb25kcywgd2hpY2ggaXMgdGhlIG1heGltdW0gZHVyYXRpb24gZm9yIHNvdW5kIGVmZmVjdHNcblxudmFyIEZYID0gZnVuY3Rpb24gKGN0eCwgY29uZmlnKVxue1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuXG4gICAgdGhpcy5mcmVxdWVuY3lWYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2ZyZXF1ZW5jeScsIDIwMCk7XG4gICAgdGhpcy5hdHRhY2sgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdhdHRhY2snLCAwKTtcbiAgICB0aGlzLmRlY2F5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZGVjYXknLCAxKTtcbiAgICB0aGlzLnR5cGUgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0eXBlJywgJ3NpbmUnKTtcbiAgICB0aGlzLnZvbHVtZVZhbHVlID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndm9sdW1lJywgMSk7XG4gICAgdGhpcy5wYW5WYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BhbicsIDApO1xuICAgIHRoaXMud2FpdCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3dhaXQnLCAwKTtcbiAgICB0aGlzLnBpdGNoQmVuZEFtb3VudCA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3BpdGNoQmVuZCcsIDApO1xuICAgIHRoaXMucmV2ZXJzZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyc2UnLCBmYWxzZSk7XG4gICAgdGhpcy5yYW5kb21WYWx1ZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JhbmRvbScsIDApO1xuICAgIHRoaXMuZGlzc29uYW5jZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2Rpc3NvbmFuY2UnLCAwKTtcbiAgICB0aGlzLmVjaG8gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdlY2hvJywgZmFsc2UpO1xuICAgIHRoaXMuZWNob0RlbGF5ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZWNoby5kZWxheScsIDApO1xuICAgIHRoaXMuZWNob0ZlZWRiYWNrID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZWNoby5mZWVkYmFjaycsIDApO1xuICAgIHRoaXMuZWNob0ZpbHRlciA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VjaG8uZmlsdGVyJywgMCk7XG4gICAgdGhpcy5yZXZlcmIgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmInLCBmYWxzZSk7XG4gICAgdGhpcy5yZXZlcmJEdXJhdGlvbiA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JldmVyYi5kdXJhdGlvbicsIDApO1xuICAgIHRoaXMucmV2ZXJiRGVjYXkgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIuZGVjYXknLCAwKTtcbiAgICB0aGlzLnJldmVyYlJldmVyc2UgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZXZlcmIucmV2ZXJzZScsIGZhbHNlKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0aW1lb3V0JywgZmFsc2UpO1xuXG4gICAgdGhpcy52b2x1bWUgPSBjdHguY3JlYXRlR2FpbigpO1xuICAgIHRoaXMucGFuID0gKCFjdHguY3JlYXRlU3RlcmVvUGFubmVyKSA/IGN0eC5jcmVhdGVQYW5uZXIoKSA6IGN0eC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcblxuICAgIHRoaXMudm9sdW1lLmNvbm5lY3QodGhpcy5wYW4pO1xuICAgIHRoaXMucGFuLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcblxuICAgIC8vICBTZXQgdGhlIHZhbHVlc1xuXG4gICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XG5cbiAgICBpZiAoIWN0eC5jcmVhdGVTdGVyZW9QYW5uZXIpXG4gICAge1xuICAgICAgICB0aGlzLnBhbi5zZXRQb3NpdGlvbih0aGlzLnBhblZhbHVlLCAwLCAxIC0gTWF0aC5hYnModGhpcy5wYW5WYWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLnBhbi5wYW4udmFsdWUgPSB0aGlzLnBhblZhbHVlO1xuICAgIH1cblxuICAgIC8vICBDcmVhdGUgYW4gb3NjaWxsYXRvciwgZ2FpbiBhbmQgcGFuIG5vZGVzLCBhbmQgY29ubmVjdCB0aGVtIHRvZ2V0aGVyIHRvIHRoZSBkZXN0aW5hdGlvblxuXG4gICAgdmFyIG9zY2lsbGF0b3IgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuXG4gICAgb3NjaWxsYXRvci5jb25uZWN0KHRoaXMudm9sdW1lKTtcbiAgICBvc2NpbGxhdG9yLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAvLyAgT3B0aW9uYWxseSByYW5kb21pemUgdGhlIHBpdGNoIGlmIGByYW5kb21WYWx1ZWAgPiAwLlxuICAgIC8vICBBIHJhbmRvbSBwaXRjaCBpcyBzZWxlY3RlZCB0aGF0J3Mgd2l0aGluIHRoZSByYW5nZSBzcGVjaWZpZWQgYnkgYGZyZXF1ZW5jeVZhbHVlYC5cbiAgICAvLyAgVGhlIHJhbmRvbSBwaXRjaCB3aWxsIGJlIGVpdGhlciBhYm92ZSBvciBiZWxvdyB0aGUgdGFyZ2V0IGZyZXF1ZW5jeS5cblxuICAgIGlmICh0aGlzLnJhbmRvbVZhbHVlID4gMClcbiAgICB7XG4gICAgICAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gQmV0d2VlbihcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5VmFsdWUgLSB0aGlzLnJhbmRvbVZhbHVlIC8gMixcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5VmFsdWUgKyB0aGlzLnJhbmRvbVZhbHVlIC8gMlxuICAgICAgICApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZnJlcXVlbmN5VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gIEFwcGx5IGVmZmVjdHNcblxuICAgIGlmICh0aGlzLmF0dGFjayA+IDApXG4gICAge1xuICAgICAgICB0aGlzLmZhZGVJbih0aGlzLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5mYWRlT3V0KHRoaXMudm9sdW1lKTtcblxuICAgIGlmICh0aGlzLnBpdGNoQmVuZEFtb3VudCA+IDApXG4gICAge1xuICAgICAgICB0aGlzLnBpdGNoQmVuZChvc2NpbGxhdG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lY2hvKVxuICAgIHtcbiAgICAgICAgdGhpcy5hZGRFY2hvKHRoaXMudm9sdW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXZlcmIpXG4gICAge1xuICAgICAgICB0aGlzLmFkZFJldmVyYih0aGlzLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzc29uYW5jZSA+IDApXG4gICAge1xuICAgICAgICB0aGlzLmFkZERpc3NvbmFuY2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXkob3NjaWxsYXRvcik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgb3NjaWxsYXRvci5vbmVuZGVkID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbmVuZGVkJyk7XG4gICAgICAgIF90aGlzLnBhbi5kaXNjb25uZWN0KCk7XG4gICAgICAgIF90aGlzLnZvbHVtZS5kaXNjb25uZWN0KCk7XG4gICAgfTtcbn07XG5cbkZYLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZYO1xuXG5GWC5wcm90b3R5cGUgPSB7XG5cbiAgICBwbGF5OiBmdW5jdGlvbiAob3NjaWxsYXRvcilcbiAgICB7XG4gICAgICAgIG9zY2lsbGF0b3Iuc3RhcnQodGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQpO1xuXG4gICAgICAgIC8vT3NjaWxsYXRvcnMgaGF2ZSB0byBiZSBzdG9wcGVkIG90aGVyd2lzZSB0aGV5IGFjY3VtdWxhdGUgaW4gXG4gICAgICAgIC8vbWVtb3J5IGFuZCB0YXggdGhlIENQVS4gVGhleSdsbCBiZSBzdG9wcGVkIGFmdGVyIGEgZGVmYXVsdFxuICAgICAgICAvL3RpbWVvdXQgb2YgMiBzZWNvbmRzLCB3aGljaCBzaG91bGQgYmUgZW5vdWdoIGZvciBtb3N0IHNvdW5kIFxuICAgICAgICAvL2VmZmVjdHMuIE92ZXJyaWRlIHRoaXMgaW4gdGhlIGBzb3VuZEVmZmVjdGAgcGFyYW1ldGVycyBpZiB5b3VcbiAgICAgICAgLy9uZWVkIGEgbG9uZ2VyIHNvdW5kXG5cbiAgICAgICAgb3NjaWxsYXRvci5zdG9wKHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy53YWl0ICsgMik7XG4gICAgfSxcblxuICAgIGZhZGVJbjogZnVuY3Rpb24gKHZvbHVtZSlcbiAgICB7XG4gICAgICAgIHZvbHVtZS5nYWluLnZhbHVlID0gMDtcblxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XG5cbiAgICAgICAgdm9sdW1lLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy52b2x1bWVWYWx1ZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayk7XG4gICAgfSxcblxuICAgIGZhZGVPdXQ6IGZ1bmN0aW9uICh2b2x1bWUpXG4gICAge1xuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLnZvbHVtZVZhbHVlLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrKTtcblxuICAgICAgICB2b2x1bWUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCArIHRoaXMuYXR0YWNrICsgdGhpcy5kZWNheSk7XG4gICAgfSxcblxuICAgIGFkZFJldmVyYjogZnVuY3Rpb24gKHZvbHVtZSlcbiAgICB7XG4gICAgICAgIHZhciBjb252b2x2ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcblxuICAgICAgICBjb252b2x2ZXIuYnVmZmVyID0gdGhpcy5pbXB1bHNlUmVzcG9uc2UodGhpcy5yZXZlcmJEdXJhdGlvbiwgdGhpcy5yZXZlcmJEZWNheSwgdGhpcy5yZXZlcmJSZXZlcnNlLCB0aGlzLmF1ZGlvQ29udGV4dCk7XG5cbiAgICAgICAgdm9sdW1lLmNvbm5lY3QoY29udm9sdmVyKTtcblxuICAgICAgICBjb252b2x2ZXIuY29ubmVjdCh0aGlzLnBhbik7XG4gICAgfSxcblxuICAgIGFkZEVjaG86IGZ1bmN0aW9uICh2b2x1bWUpXG4gICAge1xuICAgICAgICB2YXIgZmVlZGJhY2sgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZURlbGF5KCk7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblxuICAgICAgICAvLyAgU2V0IHRoZSBub2RlIHZhbHVlc1xuXG4gICAgICAgIGZlZWRiYWNrLmdhaW4udmFsdWUgPSB0aGlzLmVjaG9GZWVkYmFjaztcbiAgICAgICAgZGVsYXkuZGVsYXlUaW1lLnZhbHVlID0gdGhpcy5lY2hvRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWNob0ZpbHRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuZWNob0ZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBDcmVhdGUgdGhlIGRlbGF5IGZlZWRiYWNrIGxvb3AgKHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nKVxuXG4gICAgICAgIGRlbGF5LmNvbm5lY3QoZmVlZGJhY2spO1xuXG4gICAgICAgIGlmICh0aGlzLmVjaG9GaWx0ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZmlsdGVyKTtcbiAgICAgICAgICAgIGZpbHRlci5jb25uZWN0KGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZlZWRiYWNrLmNvbm5lY3QoZGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG9zY2lsbGF0b3Igdm9sdW1lIG5vZGVcblxuICAgICAgICB2b2x1bWUuY29ubmVjdChkZWxheSk7XG5cbiAgICAgICAgLy8gIENvbm5lY3QgdGhlIGRlbGF5IG5vZGUgdG8gdGhlIG1haW4gc291bmQgY2hhaW5zIHBhbiBub2RlLFxuICAgICAgICAvLyAgc28gdGhhdCB0aGUgZWNobyBlZmZlY3QgaXMgZGlyZWN0ZWQgdG8gdGhlIGNvcnJlY3Qgc3BlYWtlclxuXG4gICAgICAgIGRlbGF5LmNvbm5lY3QodGhpcy5wYW4pO1xuICAgIH0sXG5cbiAgICBwaXRjaEJlbmQ6IGZ1bmN0aW9uIChvc2NpbGxhdG9yKVxuICAgIHtcbiAgICAgICAgdmFyIGZyZXF1ZW5jeSA9IG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgSWYgcmV2ZXJzZSBpcyBmYWxzZSwgbWFrZSB0aGUgc291bmQgZHJvcCBpbiBwaXRjaFxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgLSB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIElmIHJldmVyc2UgaXMgdHJ1ZSwgbWFrZSB0aGUgc291bmQgcmlzZSBpbiBwaXRjaFxuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZnJlcXVlbmN5LCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMud2FpdCk7XG4gICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmcmVxdWVuY3kgKyB0aGlzLnBpdGNoQmVuZEFtb3VudCwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLndhaXQgKyB0aGlzLmF0dGFjayArIHRoaXMuZGVjYXkpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgYWRkRGlzc29uYW5jZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBDcmVhdGUgdHdvIG1vcmUgb3NjaWxsYXRvcnMgYW5kIGdhaW4gbm9kZXNcblxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG5cbiAgICAgICAgdmFyIGQxID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgdmFyIGQyID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgdmFyIGQxVm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdmFyIGQyVm9sdW1lID0gY3R4LmNyZWF0ZUdhaW4oKTtcblxuICAgICAgICAvLyAgU2V0IHRoZSB2b2x1bWUgdG8gdGhlIGB2b2x1bWVWYWx1ZWBcbiAgICAgICAgZDFWb2x1bWUuZ2Fpbi52YWx1ZSA9IHRoaXMudm9sdW1lVmFsdWU7XG4gICAgICAgIGQyVm9sdW1lLmdhaW4udmFsdWUgPSB0aGlzLnZvbHVtZVZhbHVlO1xuXG4gICAgICAgIC8vICBDb25uZWN0IHRoZSBvc2NpbGxhdG9ycyB0byB0aGUgZ2FpbiBhbmQgZGVzdGluYXRpb24gbm9kZXNcbiAgICAgICAgZDEuY29ubmVjdChkMVZvbHVtZSk7XG4gICAgICAgIGQyLmNvbm5lY3QoZDJWb2x1bWUpO1xuXG4gICAgICAgIGQxVm9sdW1lLmNvbm5lY3QoY3R4LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgZDJWb2x1bWUuY29ubmVjdChjdHguZGVzdGluYXRpb24pO1xuXG4gICAgICAgIC8vICBTZXQgdGhlIHdhdmVmb3JtIHRvIFwic2F3dG9vdGhcIiBmb3IgYSBoYXJzaCBlZmZlY3RcbiAgICAgICAgZDEudHlwZSA9ICdzYXd0b290aCc7XG4gICAgICAgIGQyLnR5cGUgPSAnc2F3dG9vdGgnO1xuXG4gICAgICAgIC8vICBNYWtlIHRoZSB0d28gb3NjaWxsYXRvcnMgcGxheSBhdCBmcmVxdWVuY2llcyBhYm92ZSBhbmQgYmVsb3cgdGhlIG1haW4gc291bmQncyBmcmVxdWVuY3kuXG4gICAgICAgIC8vICBVc2Ugd2hhdGV2ZXIgdmFsdWUgd2FzIHN1cHBsaWVkIGJ5IHRoZSBgZGlzc29uYW5jZWAgYXJndW1lbnRcbiAgICAgICAgZDEuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSArIHRoaXMuZGlzc29uYW5jZTtcbiAgICAgICAgZDIuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5mcmVxdWVuY3lWYWx1ZSAtIHRoaXMuZGlzc29uYW5jZTtcblxuICAgICAgICAvLyAgRmFkZSBpbiAvIG91dCwgcGl0Y2ggYmVuZCBhbmQgcGxheSB0aGUgb3NjaWxsYXRvcnMgdG8gbWF0Y2ggdGhlIG1haW4gc291bmRcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNrID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDFWb2x1bWUpO1xuICAgICAgICAgICAgdGhpcy5mYWRlSW4oZDJWb2x1bWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGVjYXkgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZhZGVPdXQoZDFWb2x1bWUpO1xuICAgICAgICAgICAgdGhpcy5mYWRlT3V0KGQyVm9sdW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBpdGNoQmVuZEFtb3VudCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQxKTtcbiAgICAgICAgICAgIHRoaXMucGl0Y2hCZW5kKGQyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVjaG8pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWNobyhkMVZvbHVtZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEVjaG8oZDJWb2x1bWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmV2ZXJiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMVZvbHVtZSk7XG4gICAgICAgICAgICB0aGlzLmFkZFJldmVyYihkMlZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsYXkoZDEpO1xuICAgICAgICB0aGlzLnBsYXkoZDIpO1xuICAgIH0sXG5cbiAgICBpbXB1bHNlUmVzcG9uc2U6IGZ1bmN0aW9uIChkdXJhdGlvbiwgZGVjYXksIHJldmVyc2UpXG4gICAge1xuICAgICAgICAvLyAgVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSAqIGR1cmF0aW9uO1xuXG4gICAgICAgIC8vICBDcmVhdGUgYW4gYXVkaW8gYnVmZmVyIChhbiBlbXB0eSBzb3VuZCBjb250YWluZXIpIHRvIHN0b3JlIHRoZSByZXZlcmIgZWZmZWN0LlxuICAgICAgICB2YXIgaW1wdWxzZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBsZW5ndGgsIHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuXG4gICAgICAgIC8vICBVc2UgYGdldENoYW5uZWxEYXRhYCB0byBpbml0aWFsaXplIGVtcHR5IGFycmF5cyB0byBzdG9yZSBzb3VuZCBkYXRhIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMuXG4gICAgICAgIHZhciBsZWZ0ID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW1wdWxzZS5nZXRDaGFubmVsRGF0YSgxKTtcblxuICAgICAgICAvLyAgTG9vcCB0aHJvdWdoIGVhY2ggc2FtcGxlLWZyYW1lIGFuZCBmaWxsIHRoZSBjaGFubmVsIGRhdGEgd2l0aCByYW5kb20gbm9pc2UuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBBcHBseSB0aGUgcmV2ZXJzZSBlZmZlY3QsIGlmIGByZXZlcnNlYCBpcyBgdHJ1ZWAuXG4gICAgICAgICAgICB2YXIgbiA9IChyZXZlcnNlKSA/IGxlbmd0aCAtIGkgOiBpO1xuXG4gICAgICAgICAgICAvLyAgRmlsbCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMgd2l0aCByYW5kb20gd2hpdGUgbm9pc2Ugd2hpY2ggZGVjYXlzIGV4cG9uZW50aWFsbHkuXG4gICAgICAgICAgICBsZWZ0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xuICAgICAgICAgICAgcmlnaHRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIE1hdGgucG93KDEgLSBuIC8gbGVuZ3RoLCBkZWNheSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgUmV0dXJuIHRoZSBgaW1wdWxzZWAuXG4gICAgICAgIHJldHVybiBpbXB1bHNlO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGWDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NvdW5kL2R5bmFtaWMvRlguanNcbi8vIG1vZHVsZSBpZCA9IDYwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zb3VuZC9keW5hbWljL0ZYLmpzIiwiLy8gIFBoYXNlci5Tb3VuZC5EeW5hbWljXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgRlg6IHJlcXVpcmUoJy4vRlgnKVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc291bmQvZHluYW1pYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NvdW5kL2R5bmFtaWMvaW5kZXguanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xudmFyIE5PT1AgPSByZXF1aXJlKCcuLi91dGlscy9OT09QJyk7XG52YXIgU3RhdGUgPSByZXF1aXJlKCcuL1N0YXRlJyk7XG52YXIgU3lzdGVtcyA9IHJlcXVpcmUoJy4vU3lzdGVtcycpO1xudmFyIEdldE9iamVjdFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0L0dldE9iamVjdFZhbHVlJyk7XG52YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpO1xudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL2dlb20vcmVjdGFuZ2xlL1JlY3RhbmdsZScpO1xudmFyIENhbnZhc1Bvb2wgPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzUG9vbCcpO1xudmFyIENhbnZhc0ludGVycG9sYXRpb24gPSByZXF1aXJlKCcuLi9kb20vQ2FudmFzSW50ZXJwb2xhdGlvbicpO1xudmFyIEdldENvbnRleHQgPSByZXF1aXJlKCcuLi9jYW52YXMvR2V0Q29udGV4dCcpO1xuXG4vKipcbiogVGhlIFN0YXRlIE1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcsIHNldHRpbmcgdXAgYW5kIHN3aXRjaGluZyBnYW1lIHN0YXRlcy5cbipcbiogQGNsYXNzIFBoYXNlci5HbG9iYWxTdGF0ZU1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiovXG52YXIgR2xvYmFsU3RhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKGdhbWUsIHN0YXRlQ29uZmlnKVxue1xuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XG5cbiAgICAvLyAgRXZlcnl0aGluZyBrZXB0IGluIGhlcmVcbiAgICB0aGlzLmtleXMgPSB7fTtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuXG4gICAgLy8gIE9ubHkgYWN0aXZlIHN0YXRlcyBhcmUga2VwdCBpbiBoZXJlXG4gICAgdGhpcy5hY3RpdmUgPSBbXTtcblxuICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcblxuICAgIGlmIChzdGF0ZUNvbmZpZylcbiAgICB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlQ29uZmlnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZUNvbmZpZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgVGhlIGkgPT09IDAgcGFydCBqdXN0IHN0YXJ0cyB0aGUgZmlyc3QgU3RhdGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZ1tpXSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiAoaSA9PT0gMCksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGtleTogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUNvbmZpZyxcbiAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuR2xvYmFsU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdsb2JhbFN0YXRlTWFuYWdlcjtcblxuR2xvYmFsU3RhdGVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogVGhlIEJvb3QgaGFuZGxlciBpcyBjYWxsZWQgYnkgUGhhc2VyLkdhbWUgd2hlbiBpdCBmaXJzdCBzdGFydHMgdXAuXG4gICAgKiBUaGUgcmVuZGVyZXIgaXMgYXZhaWxhYmxlIGJ5IG5vdy5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBoYXNlci5HbG9iYWxTdGF0ZU1hbmFnZXIjYm9vdFxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGJvb3Q6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX3BlbmRpbmdbaV07XG5cbiAgICAgICAgICAgIHRoaXMuYWRkKGVudHJ5LmtleSwgZW50cnkuc3RhdGUsIGVudHJ5LmF1dG9TdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgQ2xlYXIgdGhlIHBlbmRpbmcgbGlzdFxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gW107XG4gICAgfSxcblxuICAgIC8vICBwcml2YXRlXG4gICAgZ2V0S2V5OiBmdW5jdGlvbiAoa2V5LCBzdGF0ZUNvbmZpZylcbiAgICB7XG4gICAgICAgIGlmICgha2V5KSB7IGtleSA9ICdkZWZhdWx0JzsgfVxuXG4gICAgICAgIGlmIChzdGF0ZUNvbmZpZyBpbnN0YW5jZW9mIFN0YXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICBrZXkgPSBzdGF0ZUNvbmZpZy5zZXR0aW5ncy5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXRlQ29uZmlnID09PSAnb2JqZWN0JyAmJiBzdGF0ZUNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleSA9IHN0YXRlQ29uZmlnLmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBCeSB0aGlzIHBvaW50IGl0J3MgZWl0aGVyICdkZWZhdWx0JyBvciBleHRyYWN0ZWQgZnJvbSB0aGUgU3RhdGVcblxuICAgICAgICBpZiAodGhpcy5rZXlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBhIFN0YXRlIHdpdGggZHVwbGljYXRlIGtleTogJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQWRkcyBhIG5ldyBTdGF0ZSBpbnRvIHRoZSBHbG9iYWxTdGF0ZU1hbmFnZXIuIFlvdSBtdXN0IGdpdmUgZWFjaCBTdGF0ZSBhIHVuaXF1ZSBrZXkgYnkgd2hpY2ggeW91J2xsIGlkZW50aWZ5IGl0LlxuICAgICogVGhlIFN0YXRlIGNhbiBiZSBlaXRoZXIgYSBQaGFzZXIuU3RhdGUgb2JqZWN0IChvciBhbiBvYmplY3QgdGhhdCBleHRlbmRzIGl0KSwgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCBvciBhIGZ1bmN0aW9uLlxuICAgICogSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiBhIG5ldyBzdGF0ZSBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkIGJ5IGNhbGxpbmcgaXQuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuR2xvYmFsU3RhdGVNYW5hZ2VyI2FkZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEEgdW5pcXVlIGtleSB5b3UgdXNlIHRvIHJlZmVyZW5jZSB0aGlzIHN0YXRlLCBpLmUuIFwiTWFpbk1lbnVcIiwgXCJMZXZlbDFcIi5cbiAgICAqIEBwYXJhbSB7UGhhc2VyLlN0YXRlfG9iamVjdHxmdW5jdGlvbn0gc3RhdGUgIC0gVGhlIHN0YXRlIHlvdSB3YW50IHRvIHN3aXRjaCB0by5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9TdGFydD1mYWxzZV0gIC0gSWYgdHJ1ZSB0aGUgU3RhdGUgd2lsbCBiZSBzdGFydGVkIGltbWVkaWF0ZWx5IGFmdGVyIGFkZGluZyBpdC5cbiAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKGtleSwgc3RhdGVDb25maWcsIGF1dG9TdGFydClcbiAgICB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQgPT09IHVuZGVmaW5lZCkgeyBhdXRvU3RhcnQgPSBmYWxzZTsgfVxuXG4gICAgICAgIC8vICBpZiBub3QgYm9vdGVkLCB0aGVuIHB1dCBzdGF0ZSBpbnRvIGEgaG9sZGluZyBwYXR0ZXJuXG4gICAgICAgIGlmICghdGhpcy5nYW1lLmlzQm9vdGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLl9wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVDb25maWcsXG4gICAgICAgICAgICAgICAgYXV0b1N0YXJ0OiBhdXRvU3RhcnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnR2xvYmFsU3RhdGVNYW5hZ2VyIG5vdCB5ZXQgYm9vdGVkLCBhZGRpbmcgdG8gbGlzdCcsIHRoaXMuX3BlbmRpbmcubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5LCBzdGF0ZUNvbmZpZyk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0dsb2JhbFN0YXRlTWFuYWdlci5hZGQnLCBrZXksIHN0YXRlQ29uZmlnLCBhdXRvU3RhcnQpO1xuXG4gICAgICAgIHZhciBuZXdTdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGVDb25maWcgaW5zdGFuY2VvZiBTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0dsb2JhbFN0YXRlTWFuYWdlci5hZGQgZnJvbSBpbnN0YW5jZTonLCBrZXkpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUluc3RhbmNlKGtleSwgc3RhdGVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZUNvbmZpZyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gb2JqZWN0OicsIGtleSk7XG5cbiAgICAgICAgICAgIHN0YXRlQ29uZmlnLmtleSA9IGtleTtcblxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbU9iamVjdChrZXksIHN0YXRlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhdGVDb25maWcgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIuYWRkIGZyb20gZnVuY3Rpb246Jywga2V5KTtcblxuICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlRnJvbUZ1bmN0aW9uKGtleSwgc3RhdGVDb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5rZXlzW2tleV0gPSBuZXdTdGF0ZTtcblxuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKG5ld1N0YXRlKTtcblxuICAgICAgICBpZiAoYXV0b1N0YXJ0IHx8IG5ld1N0YXRlLnNldHRpbmdzLmFjdGl2ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZS5pc0Jvb3RlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGtleSwgbmV3U3RhdGUpXG4gICAge1xuICAgICAgICBuZXdTdGF0ZS5zZXR0aW5ncy5rZXkgPSBrZXk7XG5cbiAgICAgICAgbmV3U3RhdGUuc3lzLmluaXQodGhpcy5nYW1lKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZVN0YXRlRGlzcGxheShuZXdTdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uIChrZXksIHN0YXRlQ29uZmlnKVxuICAgIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IFN0YXRlKHN0YXRlQ29uZmlnKTtcblxuICAgICAgICBuZXdTdGF0ZS5zeXMuaW5pdCh0aGlzLmdhbWUpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlU3RhdGVEaXNwbGF5KG5ld1N0YXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cENhbGxiYWNrcyhuZXdTdGF0ZSwgc3RhdGVDb25maWcpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24gKGtleSwgc3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBuZXcgc3RhdGUoKTtcblxuICAgICAgICBpZiAobmV3U3RhdGUgaW5zdGFuY2VvZiBTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RhdGVGcm9tSW5zdGFuY2Uoa2V5LCBuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zeXMgPSBuZXcgU3lzdGVtcyhuZXdTdGF0ZSk7XG5cbiAgICAgICAgICAgIG5ld1N0YXRlLnN5cy5pbml0KHRoaXMuZ2FtZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3RhdGVEaXNwbGF5KG5ld1N0YXRlKTtcblxuICAgICAgICAgICAgLy8gIERlZmF1bHQgcmVxdWlyZWQgZnVuY3Rpb25zXG5cbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuaW5pdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pbml0ID0gTk9PUDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5wcmVsb2FkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnByZWxvYWQgPSBOT09QO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5ld1N0YXRlLmNyZWF0ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5jcmVhdGUgPSBOT09QO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5ld1N0YXRlLnNodXRkb3duKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnNodXRkb3duID0gTk9PUDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS51cGRhdGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUudXBkYXRlID0gTk9PUDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5yZW5kZXIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUucmVuZGVyID0gTk9PUDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldHVwQ2FsbGJhY2tzOiBmdW5jdGlvbiAoc3RhdGUsIHN0YXRlQ29uZmlnKVxuICAgIHtcbiAgICAgICAgaWYgKHN0YXRlQ29uZmlnID09PSB1bmRlZmluZWQpIHsgc3RhdGVDb25maWcgPSBzdGF0ZTsgfVxuXG4gICAgICAgIC8vICBFeHRyYWN0IGNhbGxiYWNrcyBvciBzZXQgTk9PUFxuXG4gICAgICAgIHN0YXRlLmluaXQgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ2luaXQnLCBOT09QKTtcbiAgICAgICAgc3RhdGUucHJlbG9hZCA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncHJlbG9hZCcsIE5PT1ApO1xuICAgICAgICBzdGF0ZS5jcmVhdGUgPSBHZXRPYmplY3RWYWx1ZShzdGF0ZUNvbmZpZywgJ2NyZWF0ZScsIE5PT1ApO1xuICAgICAgICBzdGF0ZS5zaHV0ZG93biA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAnc2h1dGRvd24nLCBOT09QKTtcblxuICAgICAgICAvLyAgR2FtZSBMb29wIGxldmVsIGNhbGxiYWNrc1xuXG4gICAgICAgIHN0YXRlLnVwZGF0ZSA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAndXBkYXRlJywgTk9PUCk7XG4gICAgICAgIHN0YXRlLnJlbmRlciA9IEdldE9iamVjdFZhbHVlKHN0YXRlQ29uZmlnLCAncmVuZGVyJywgTk9PUCk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTdGF0ZURpc3BsYXk6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjcmVhdGVTdGF0ZURpc3BsYXknLCBzdGF0ZS5zZXR0aW5ncy5rZXkpO1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHN0YXRlLnN5cy5zZXR0aW5ncztcblxuICAgICAgICAvLyB2YXIgeCA9IHNldHRpbmdzLng7XG4gICAgICAgIC8vIHZhciB5ID0gc2V0dGluZ3MueTtcbiAgICAgICAgdmFyIHdpZHRoID0gc2V0dGluZ3Mud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2FtZS5jb25maWc7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5yZW5kZXJUeXBlID09PSBDT05TVC5DQU5WQVMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJUb1RleHR1cmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbmRlclRvVGV4dHVyZScsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN5cy5jYW52YXMgPSBDYW52YXNQb29sLmNyZWF0ZShzdGF0ZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLmNvbnRleHQgPSBHZXRDb250ZXh0KHN0YXRlLnN5cy5jYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gIFBpeGVsIEFydCBtb2RlP1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcucGl4ZWxBcnQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBDYW52YXNJbnRlcnBvbGF0aW9uLnNldENyaXNwKHN0YXRlLnN5cy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndXNpbmcgZ2FtZSBjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zeXMubWFzayA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLmNhbnZhcyA9IHRoaXMuZ2FtZS5jYW52YXM7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3lzLmNvbnRleHQgPSB0aGlzLmdhbWUuY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHN0YXRlLnN5cy5mYm8gPSB0aGlzLmdhbWUucmVuZGVyZXIuY3JlYXRlRkJPKHN0YXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXNba2V5XTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGVJbmRleDogZnVuY3Rpb24gKHN0YXRlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVTdGF0ZUluZGV4OiBmdW5jdGlvbiAoc3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVbaV0uc3RhdGUgPT09IHN0YXRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5hY3RpdmVbaV0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xuXG4gICAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuc2V0dGluZ3MuYWN0aXZlICYmIHRoaXMuYWN0aXZlLmluZGV4T2Yoc3RhdGUpICE9PSAtMSk7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKVxuICAgIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgeyBkYXRhID0ge307IH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQ6Jywga2V5KTtcbiAgICAgICAgLy8gY29uc29sZS5kaXIoZGF0YSk7XG5cbiAgICAgICAgLy8gIGlmIG5vdCBib290ZWQsIHRoZW4gcHV0IHN0YXRlIGludG8gYSBob2xkaW5nIHBhdHRlcm5cbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuaXNCb290ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdHbG9iYWxTdGF0ZU1hbmFnZXIgbm90IHlldCBib290ZWQsIHNldHRpbmcgYXV0b1N0YXJ0IG9uIHBlbmRpbmcgbGlzdCcpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fcGVuZGluZ1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmF1dG9TdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZShrZXkpO1xuXG4gICAgICAgIGlmIChzdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIEFscmVhZHkgc3RhcnRlZD8gTm90aGluZyBtb3JlIHRvIGRvIGhlcmUgLi4uXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShrZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgICAgc3RhdGUuc2V0dGluZ3MuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBzdGF0ZS5zeXMubG9hZDtcblxuICAgICAgICAgICAgLy8gIEZpbGVzIHBheWxvYWQ/XG4gICAgICAgICAgICBpZiAobG9hZGVyICYmIEFycmF5LmlzQXJyYXkoc3RhdGUuc3lzLnNldHRpbmdzLmZpbGVzKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIucmVzZXQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb2FkZXIubG9hZEFycmF5KHN0YXRlLnN5cy5zZXR0aW5ncy5maWxlcykpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZXIuZXZlbnRzLm9uY2UoJ0xPQURFUl9DT01QTEVURV9FVkVOVCcsIHRoaXMucGF5bG9hZENvbXBsZXRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvb3RTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9vdFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXlsb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGV2ZW50LmxvYWRlci5zdGF0ZTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygncGF5bG9hZENvbXBsZXRlJywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSk7XG5cbiAgICAgICAgdGhpcy5ib290U3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBib290U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdib290U3RhdGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcblxuICAgICAgICBpZiAoc3RhdGUuaW5pdClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuaW5pdC5jYWxsKHN0YXRlLCBzdGF0ZS5zeXMuc2V0dGluZ3MuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9hZGVyID0gc3RhdGUuc3lzLmxvYWQ7XG4gICAgICAgICAgICBcbiAgICAgICAgbG9hZGVyLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLnByZWxvYWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlLnByZWxvYWQodGhpcy5nYW1lKTtcblxuICAgICAgICAgICAgLy8gIElzIHRoZSBsb2FkZXIgZW1wdHk/XG4gICAgICAgICAgICBpZiAobG9hZGVyLmxpc3Quc2l6ZSA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gIFN0YXJ0IHRoZSBsb2FkZXIgZ29pbmcgYXMgd2UgaGF2ZSBzb21ldGhpbmcgaW4gdGhlIHF1ZXVlXG5cbiAgICAgICAgICAgICAgICBsb2FkZXIuZXZlbnRzLm9uY2UoJ0xPQURFUl9DT01QTEVURV9FVkVOVCcsIHRoaXMubG9hZENvbXBsZXRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgbG9hZGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgTm8gcHJlbG9hZD8gVGhlbiB0aGVyZSB3YXMgbm90aGluZyB0byBsb2FkIGVpdGhlclxuICAgICAgICAgICAgdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZXZlbnQubG9hZGVyLnN0YXRlO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2FkQ29tcGxldGUnLCBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5KTtcblxuICAgICAgICB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKHN0YXRlKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZScsIHN0YXRlLnN5cy5zZXR0aW5ncy5rZXkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhzdGF0ZSk7XG5cbiAgICAgICAgLy8gIEluc2VydCBhdCB0aGUgY29ycmVjdCBpbmRleCwgb3IgaXQganVzdCBhbGwgZ29lcyB3cm9uZyA6KVxuXG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRTdGF0ZUluZGV4KHN0YXRlKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlLmluZGV4Jywgc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgaSk7XG5cbiAgICAgICAgdGhpcy5hY3RpdmUucHVzaCh7IGluZGV4OiBpLCBzdGF0ZTogc3RhdGUgfSk7XG5cbiAgICAgICAgLy8gIFNvcnQgdGhlICdhY3RpdmUnIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRleCBwcm9wZXJ0eVxuICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydFN0YXRlcyk7XG5cbiAgICAgICAgc3RhdGUuc3lzLnVwZGF0ZXMucnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuY3JlYXRlLmNhbGwoc3RhdGUsIHN0YXRlLnN5cy5zZXR0aW5ncy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlU3RhdGVJbmRleCh0aGlzLmdldFN0YXRlKGtleSkpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGtleSk7XG5cbiAgICAgICAgICAgIHN0YXRlLnNldHRpbmdzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZS5zb3J0KHRoaXMuc29ydFN0YXRlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc29ydFN0YXRlczogZnVuY3Rpb24gKHN0YXRlQSwgc3RhdGVCKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NvcnRTdGF0ZXMnLCBzdGF0ZUEuc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgc3RhdGVBLmluZGV4LCBzdGF0ZUIuc3RhdGUuc3lzLnNldHRpbmdzLmtleSwgc3RhdGVCLmluZGV4KTtcblxuICAgICAgICAvLyAgU29ydCBkZXNjZW5kaW5nXG4gICAgICAgIGlmIChzdGF0ZUEuaW5kZXggPCBzdGF0ZUIuaW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZUEuaW5kZXggPiBzdGF0ZUIuaW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2xvYmFsU3RhdGVNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvR2xvYmFsU3RhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvR2xvYmFsU3RhdGVNYW5hZ2VyLmpzIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi9jb25zdCcpO1xudmFyIFNjYWxlTW9kZXMgPSByZXF1aXJlKCcuLi9yZW5kZXJlci9TY2FsZU1vZGVzJyk7XG52YXIgR2V0T2JqZWN0VmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QvR2V0T2JqZWN0VmFsdWUnKTtcblxudmFyIFNldHRpbmdzID0ge1xuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoY29uZmlnKVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWcgPSB7IGtleTogY29uZmlnIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBQYXNzIHRoZSAnaGFzT3duUHJvcGVydHknIGNoZWNrc1xuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICBzdGF0dXM6IENPTlNULlBFTkRJTkcsXG5cbiAgICAgICAgICAgIG9wOiBDT05TVC5CT09ULFxuXG4gICAgICAgICAgICBrZXk6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2tleScsICcnKSxcbiAgICAgICAgICAgIGFjdGl2ZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYWN0aXZlJywgZmFsc2UpLFxuICAgICAgICAgICAgdmlzaWJsZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAndmlzaWJsZScsIHRydWUpLFxuXG4gICAgICAgICAgICAvLyAgTG9hZGVyIHBheWxvYWQgYXJyYXlcblxuICAgICAgICAgICAgZGF0YToge30sXG5cbiAgICAgICAgICAgIGZpbGVzOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmaWxlcycsIGZhbHNlKSxcblxuICAgICAgICAgICAgLy8gIC0xIG1lYW5zIHRoZSBTdGF0ZSBNYW5hZ2VyIHdpbGwgc2V0IGl0IHRvIGJlIHRoZSBHYW1lIGRpbWVuc2lvbnNcblxuICAgICAgICAgICAgeDogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAneCcsIDApLFxuICAgICAgICAgICAgeTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAneScsIDApLFxuICAgICAgICAgICAgcm90YXRpb246IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3JvdGF0aW9uJywgMCksXG4gICAgICAgICAgICB3aWR0aDogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnd2lkdGgnLCAtMSksXG4gICAgICAgICAgICBoZWlnaHQ6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2hlaWdodCcsIC0xKSxcblxuICAgICAgICAgICAgLy8gIFN0YXRlIFJlbmRlciBTZXR0aW5ncyAoYXBwbGllcyBvbmx5IHRvIHRoaXMgU3RhdGUpXG5cbiAgICAgICAgICAgIHNjYWxlTW9kZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc2NhbGVNb2RlJywgU2NhbGVNb2Rlcy5ERUZBVUxUKSxcbiAgICAgICAgICAgIHJvdW5kUGl4ZWxzOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyb3VuZFBpeGVscycsIGZhbHNlKSxcblxuICAgICAgICAgICAgZGlydHlSZW5kZXI6IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2RpcnR5UmVuZGVyJywgZmFsc2UpLFxuICAgICAgICAgICAgcmVuZGVyVG9UZXh0dXJlOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdyZW5kZXJUb1RleHR1cmUnLCBmYWxzZSksXG5cbiAgICAgICAgICAgIC8vICBUaGUgZm9sbG93aW5nIG9ubHkgYXBwbHkgaWYgcmVuZGVyVG9UZXh0dXJlIGlzIHRydWVcblxuICAgICAgICAgICAgYXV0b1Jlc2l6ZTogR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnYXV0b1Jlc2l6ZScsIGZhbHNlKSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBHZXRPYmplY3RWYWx1ZShjb25maWcsICd0cmFuc3BhcmVudCcsIGZhbHNlKSxcbiAgICAgICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdjbGVhckJlZm9yZVJlbmRlcicsIHRydWUpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBHZXRPYmplY3RWYWx1ZShjb25maWcsICdiYWNrZ3JvdW5kQ29sb3InLCBmYWxzZSlcblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbiAoY29uZmlnLCBnYW1lQ29uZmlnKVxuICAgIHtcbiAgICAgICAgaWYgKGNvbmZpZy53aWR0aCA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbmZpZy53aWR0aCA9IGdhbWVDb25maWcud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmhlaWdodCA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWlnaHQgPSBnYW1lQ29uZmlnLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL1NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvU2V0dGluZ3MuanMiLCJcbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgUEVORElORzogMCxcbiAgICBJTlNUQUxMRUQ6IDEsXG5cbiAgICBCT09UOiAwLFxuICAgIElOSVQ6IDEsXG4gICAgUFJFTE9BRDogMixcbiAgICBDUkVBVEU6IDMsXG4gICAgVVBEQVRFOiA0LFxuICAgIFJFTkRFUjogNSxcbiAgICBTSFVURE9XTjogNlxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvY29uc3QuanNcbi8vIG1vZHVsZSBpZCA9IDYwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi4vLi4vY2FtZXJhL0NhbWVyYScpO1xuXG52YXIgQ2FtZXJhTWFuYWdlciA9IGZ1bmN0aW9uIChzdGF0ZSlcbntcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICB0aGlzLmNhbWVyYXMgPSBbXTtcbiAgICB0aGlzLmNhbWVyYVBvb2wgPSBbXTtcblxuICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkKCk7XG59O1xuXG5DYW1lcmFNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYU1hbmFnZXI7XG5cbkNhbWVyYU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgYWRkOiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgeCA9IDA7IH1cbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgeyB5ID0gMDsgfVxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IHRoaXMuc3RhdGUuc3lzLndpZHRoOyB9XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkgeyBoZWlnaHQgPSB0aGlzLnN0YXRlLnN5cy5oZWlnaHQ7IH1cblxuICAgICAgICB2YXIgY2FtZXJhID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5jYW1lcmFQb29sLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbWVyYSA9IHRoaXMuY2FtZXJhUG9vbC5wb3AoKTtcbiAgICAgICAgICAgIGNhbWVyYS5zZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbWVyYSA9IG5ldyBDYW1lcmEoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW1lcmEuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goY2FtZXJhKTtcblxuICAgICAgICByZXR1cm4gY2FtZXJhO1xuICAgIH0sXG5cbiAgICBhZGRSZWZlcmVuY2U6IGZ1bmN0aW9uIChjYW1lcmEpXG4gICAge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNhbWVyYXMuaW5kZXhPZihjYW1lcmEpO1xuICAgICAgICB2YXIgcG9vbEluZGV4ID0gdGhpcy5jYW1lcmFQb29sLmluZGV4T2YoY2FtZXJhKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwICYmIHBvb2xJbmRleCA+PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYXMucHVzaChjYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnNsaWNlKHBvb2xJbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gY2FtZXJhO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2FtZXJhKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbWVyYUluZGV4ID0gdGhpcy5jYW1lcmFzLmluZGV4T2YoY2FtZXJhKTtcblxuICAgICAgICBpZiAoY2FtZXJhSW5kZXggPj0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnB1c2godGhpcy5jYW1lcmFzW2NhbWVyYUluZGV4XSk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYXMuc3BsaWNlKGNhbWVyYUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldEFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXMubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFQb29sLnB1c2godGhpcy5jYW1lcmFzLnBvcCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHRpbWVzdGVwKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYXNbaV0udXBkYXRlKHRpbWVzdGVwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIChyZW5kZXJlciwgY2hpbGRyZW4sIGludGVycG9sYXRpb24pXG4gICAge1xuICAgICAgICB2YXIgY2FtZXJhcyA9IHRoaXMuY2FtZXJhcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYW1lcmFzLmxlbmd0aDsgaSA8IGw7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IGNhbWVyYXNbaV07XG5cbiAgICAgICAgICAgIGNhbWVyYS5wcmVSZW5kZXIoKTtcblxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhdGUsIGNoaWxkcmVuLCBpbnRlcnBvbGF0aW9uLCBjYW1lcmEpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubWFpbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2FtZXJhcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNhbWVyYVBvb2wubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhUG9vbFtpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbWVyYXMgPSBbXTtcbiAgICAgICAgdGhpcy5jYW1lcmFQb29sID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYU1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL0NhbWVyYU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0NhbWVyYU1hbmFnZXIuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgRmFjdG9yeUNvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uL2dhbWVvYmplY3RzL0ZhY3RvcnlDb250YWluZXInKTtcblxuLyoqXG4qIFRoZSBHYW1lT2JqZWN0IEZhY3RvcnkgaXMgYSBxdWljayB3YXkgdG8gY3JlYXRlIG1hbnkgY29tbW9uIGdhbWUgb2JqZWN0cy4gVGhlIEZhY3RvcnkgaXMgb3duZWQgYnkgdGhlIFN0YXRlLlxuKlxuKiBAY2xhc3MgUGhhc2VyLkdhbWVPYmplY3QuRmFjdG9yeVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBnYW1lLlxuKi9cbnZhciBHYW1lT2JqZWN0Q3JlYXRvciA9IGZ1bmN0aW9uIChzdGF0ZSlcbntcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICBGYWN0b3J5Q29udGFpbmVyLmxvYWQodGhpcywgZmFsc2UpO1xufTtcblxuR2FtZU9iamVjdENyZWF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2FtZU9iamVjdENyZWF0b3I7XG5cbkdhbWVPYmplY3RDcmVhdG9yLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gdW5kZWZpbmVkO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lT2JqZWN0Q3JlYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvR2FtZU9iamVjdENyZWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDYxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RDcmVhdG9yLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIEZhY3RvcnlDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9nYW1lb2JqZWN0cy9GYWN0b3J5Q29udGFpbmVyJyk7XG5cbi8qKlxuKiBUaGUgR2FtZU9iamVjdCBGYWN0b3J5IGlzIGEgcXVpY2sgd2F5IHRvIGNyZWF0ZSBtYW55IGNvbW1vbiBnYW1lIG9iamVjdHMuIFRoZSBGYWN0b3J5IGlzIG93bmVkIGJ5IHRoZSBTdGF0ZS5cbipcbiogQGNsYXNzIFBoYXNlci5HYW1lT2JqZWN0LkZhY3RvcnlcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZ2FtZS5cbiovXG52YXIgR2FtZU9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiAoc3RhdGUpXG57XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgRmFjdG9yeUNvbnRhaW5lci5sb2FkKHRoaXMsIHRydWUpO1xufTtcblxuR2FtZU9iamVjdEZhY3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2FtZU9iamVjdEZhY3Rvcnk7XG5cbkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZSA9IHtcblxuICAgIGV4aXN0aW5nOiBmdW5jdGlvbiAoY2hpbGQpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jaGlsZHJlbi5hZGQoY2hpbGQpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZU9iamVjdEZhY3Rvcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zdGF0ZS9zeXN0ZW1zL0dhbWVPYmplY3RGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RhdGUvc3lzdGVtcy9HYW1lT2JqZWN0RmFjdG9yeS5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9jb25zdCcpO1xudmFyIEJhc2VMb2FkZXIgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvQmFzZUxvYWRlcicpO1xudmFyIE51bWJlckFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXknKTtcblxudmFyIEltYWdlRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvSW1hZ2VGaWxlJyk7XG52YXIgSlNPTkZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0pTT05GaWxlJyk7XG52YXIgWE1MRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvWE1MRmlsZScpO1xudmFyIEJpbmFyeUZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpbmFyeUZpbGUnKTtcbnZhciBHTFNMRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvR0xTTEZpbGUnKTtcbnZhciBUZXh0RmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvVGV4dEZpbGUnKTtcbnZhciBBdGxhc0pTT05GaWxlID0gcmVxdWlyZSgnLi4vLi4vbG9hZGVyL2ZpbGV0eXBlcy9BdGxhc0pTT05GaWxlJyk7XG52YXIgQml0bWFwRm9udEZpbGUgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL0JpdG1hcEZvbnRGaWxlJyk7XG52YXIgU3ByaXRlU2hlZXQgPSByZXF1aXJlKCcuLi8uLi9sb2FkZXIvZmlsZXR5cGVzL1Nwcml0ZVNoZWV0Jyk7XG52YXIgU1ZHRmlsZSA9IHJlcXVpcmUoJy4uLy4uL2xvYWRlci9maWxldHlwZXMvU1ZHRmlsZScpO1xuXG52YXIgUGFyc2VYTUxCaXRtYXBGb250ID0gcmVxdWlyZSgnLi4vLi4vZ2FtZW9iamVjdHMvYml0bWFwdGV4dC9QYXJzZVhNTEJpdG1hcEZvbnQnKTtcblxudmFyIExvYWRlciA9IGZ1bmN0aW9uIChzdGF0ZSlcbntcbiAgICBCYXNlTG9hZGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlN0YXRlfSBzdGF0ZSAtIFRoZSBTdGF0ZSB0aGF0IG93bnMgdGhpcyBGYWN0b3J5XG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICB0aGlzLl9tdWx0aWxpc3QgPSB7fTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VMb2FkZXIucHJvdG90eXBlKTtcbkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXI7XG5cbkxvYWRlci5wcm90b3R5cGUubG9hZEFycmF5ID0gZnVuY3Rpb24gKGZpbGVzKVxue1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVzKSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZShmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMubGlzdC5zaXplID4gMCk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLmZpbGUgPSBmdW5jdGlvbiAoZmlsZSlcbntcbiAgICB2YXIgZW50cnk7XG5cbiAgICBzd2l0Y2ggKGZpbGUudHlwZSlcbiAgICB7XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdnbHNsJzpcbiAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpc1tmaWxlLnR5cGVdKGZpbGUua2V5LCBmaWxlLnVybCwgZmlsZS54aHJTZXR0aW5ncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzcHJpdGVzaGVldCc6XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuc3ByaXRlc2hlZXQoZmlsZS5rZXksIGZpbGUudXJsLCBmaWxlLmNvbmZpZywgZmlsZS54aHJTZXR0aW5ncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhdGxhcyc6XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuYXRsYXMoZmlsZS5rZXksIGZpbGUudGV4dHVyZVVSTCwgZmlsZS5hdGxhc1VSTCwgZmlsZS50ZXh0dXJlWGhyU2V0dGluZ3MsIGZpbGUuYXRsYXNYaHJTZXR0aW5ncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdiaXRtYXBGb250JzpcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5iaXRtYXBGb250KGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkwsIGZpbGUueG1sVVJMLCBmaWxlLnRleHR1cmVYaHJTZXR0aW5ncywgZmlsZS54bWxYaHJTZXR0aW5ncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtdWx0aWF0bGFzJzpcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5tdWx0aWF0bGFzKGZpbGUua2V5LCBmaWxlLnRleHR1cmVVUkxzLCBmaWxlLmF0bGFzVVJMcywgZmlsZS50ZXh0dXJlWGhyU2V0dGluZ3MsIGZpbGUuYXRsYXNYaHJTZXR0aW5ncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcbntcbiAgICB2YXIgZmlsZSA9IG5ldyBJbWFnZUZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgSlNPTkZpbGUoa2V5LCB1cmwsIHRoaXMucGF0aCwgeGhyU2V0dGluZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuYWRkRmlsZShmaWxlKTtcbn07XG5cbkxvYWRlci5wcm90b3R5cGUueG1sID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcbntcbiAgICB2YXIgZmlsZSA9IG5ldyBYTUxGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChrZXksIHVybCwgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgQmluYXJ5RmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xufTtcblxuTG9hZGVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcbntcbiAgICB2YXIgZmlsZSA9IG5ldyBUZXh0RmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xufTtcblxuTG9hZGVyLnByb3RvdHlwZS5nbHNsID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcbntcbiAgICB2YXIgZmlsZSA9IG5ldyBHTFNMRmlsZShrZXksIHVybCwgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xufTtcblxuLy8gIGNvbmZpZyBjYW4gaW5jbHVkZTogZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBtYXJnaW4sIHNwYWNpbmdcbkxvYWRlci5wcm90b3R5cGUuc3ByaXRlc2hlZXQgPSBmdW5jdGlvbiAoa2V5LCB1cmwsIGNvbmZpZywgeGhyU2V0dGluZ3MpXG57XG4gICAgdmFyIGZpbGUgPSBuZXcgU3ByaXRlU2hlZXQoa2V5LCB1cmwsIGNvbmZpZywgdGhpcy5wYXRoLCB4aHJTZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xufTtcblxuTG9hZGVyLnByb3RvdHlwZS5hdGxhcyA9IGZ1bmN0aW9uIChrZXksIHRleHR1cmVVUkwsIGF0bGFzVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXG57XG4gICAgLy8gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6ICd0ZXh0dXJlJyBhbmQgJ2RhdGEnXG4gICAgdmFyIGZpbGVzID0gbmV3IEF0bGFzSlNPTkZpbGUoa2V5LCB0ZXh0dXJlVVJMLCBhdGxhc1VSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpO1xuXG4gICAgdGhpcy5hZGRGaWxlKGZpbGVzLnRleHR1cmUpO1xuICAgIHRoaXMuYWRkRmlsZShmaWxlcy5kYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTG9hZGVyLnByb3RvdHlwZS5iaXRtYXBGb250ID0gZnVuY3Rpb24gKGtleSwgdGV4dHVyZVVSTCwgeG1sVVJMLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKVxue1xuICAgIC8vICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiAndGV4dHVyZScgYW5kICdkYXRhJ1xuICAgIHZhciBmaWxlcyA9IG5ldyBCaXRtYXBGb250RmlsZShrZXksIHRleHR1cmVVUkwsIHhtbFVSTCwgdGhpcy5wYXRoLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIHhtbFhoclNldHRpbmdzKTtcblxuICAgIHRoaXMuYWRkRmlsZShmaWxlcy50ZXh0dXJlKTtcbiAgICB0aGlzLmFkZEZpbGUoZmlsZXMuZGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkxvYWRlci5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24gKGtleSwgdXJsLCB4aHJTZXR0aW5ncylcbntcbiAgICB2YXIgZmlsZSA9IG5ldyBTVkdGaWxlKGtleSwgdXJsLCB0aGlzLnBhdGgsIHhoclNldHRpbmdzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSk7XG59O1xuXG5Mb2FkZXIucHJvdG90eXBlLm11bHRpYXRsYXMgPSBmdW5jdGlvbiAoa2V5LCB0ZXh0dXJlVVJMcywgYXRsYXNVUkxzLCB0ZXh0dXJlWGhyU2V0dGluZ3MsIGF0bGFzWGhyU2V0dGluZ3MpXG57XG4gICAgaWYgKHR5cGVvZiB0ZXh0dXJlVVJMcyA9PT0gJ251bWJlcicpXG4gICAge1xuICAgICAgICB2YXIgdG90YWwgPSB0ZXh0dXJlVVJMcztcblxuICAgICAgICB0ZXh0dXJlVVJMcyA9IE51bWJlckFycmF5KDAsIHRvdGFsLCBrZXkgKyAnLScsICcucG5nJyk7XG4gICAgICAgIGF0bGFzVVJMcyA9IE51bWJlckFycmF5KDAsIHRvdGFsLCBrZXkgKyAnLScsICcuanNvbicpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dHVyZVVSTHMpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0dXJlVVJMcyA9IFsgdGV4dHVyZVVSTHMgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdGxhc1VSTHMpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhdGxhc1VSTHMgPSBbIGF0bGFzVVJMcyBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpbGU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBtdWx0aUtleTtcblxuICAgIHRoaXMuX211bHRpbGlzdFtrZXldID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dHVyZVVSTHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBtdWx0aUtleSA9ICdfTUFfSU1HXycgKyBrZXkgKyAnXycgKyBpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgZmlsZSA9IG5ldyBJbWFnZUZpbGUobXVsdGlLZXksIHRleHR1cmVVUkxzW2ldLCB0aGlzLnBhdGgsIHRleHR1cmVYaHJTZXR0aW5ncyk7XG5cbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUpO1xuXG4gICAgICAgIHRoaXMuX211bHRpbGlzdFtrZXldLnB1c2gobXVsdGlLZXkpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhdGxhc1VSTHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBtdWx0aUtleSA9ICdfTUFfSlNPTl8nICsga2V5ICsgJ18nICsgaS50b1N0cmluZygpO1xuXG4gICAgICAgIGZpbGUgPSBuZXcgSlNPTkZpbGUobXVsdGlLZXksIGF0bGFzVVJMc1tpXSwgdGhpcy5wYXRoLCBhdGxhc1hoclNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XG5cbiAgICAgICAgdGhpcy5fbXVsdGlsaXN0W2tleV0ucHVzaChtdWx0aUtleSk7XG4gICAgfVxufTtcblxuLy8gIFRoZSBMb2FkZXIgaGFzIGZpbmlzaGVkXG5Mb2FkZXIucHJvdG90eXBlLnByb2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuc3RvcmFnZS5zaXplID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vICBUaGUgZ2xvYmFsIFRleHR1cmUgTWFuYWdlclxuICAgIHZhciBjYWNoZSA9IHRoaXMuc3RhdGUuc3lzLmNhY2hlO1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMuc3RhdGUuc3lzLnRleHR1cmVzO1xuXG4gICAgLy8gIFByb2Nlc3MgbXVsdGlhdGxhcyBncm91cHMgZmlyc3RcblxuICAgIHZhciBmaWxlO1xuICAgIHZhciBmaWxlQTtcbiAgICB2YXIgZmlsZUI7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fbXVsdGlsaXN0KVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMuX211bHRpbGlzdFtrZXldO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuc3RvcmFnZS5nZXQoJ2tleScsIGtleXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS50eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsZXRlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gIERvIHdlIGhhdmUgZXZlcnl0aGluZyBuZWVkZWQ/XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoICsgZGF0YS5sZW5ndGggPT09IGtleXMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgWXVwLCBhZGQgdGhlbSB0byB0aGUgVGV4dHVyZSBNYW5hZ2VyXG5cbiAgICAgICAgICAgIC8vICBJcyB0aGUgZGF0YSBKU09OIEhhc2ggb3IgSlNPTiBBcnJheT9cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0uZnJhbWVzKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRBdGxhc0pTT05BcnJheShrZXksIGltYWdlcywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXNKU09OSGFzaChrZXksIGltYWdlcywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbiAoZmlsZSlcbiAgICB7XG4gICAgICAgIHN3aXRjaCAoZmlsZS50eXBlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhdGxhc2pzb24nOlxuXG4gICAgICAgICAgICAgICAgZmlsZUEgPSBmaWxlLmZpbGVBO1xuICAgICAgICAgICAgICAgIGZpbGVCID0gZmlsZS5maWxlQjtcblxuICAgICAgICAgICAgICAgIGlmIChmaWxlQS50eXBlID09PSAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXMoZmlsZUEua2V5LCBmaWxlQS5kYXRhLCBmaWxlQi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkQXRsYXMoZmlsZUIua2V5LCBmaWxlQi5kYXRhLCBmaWxlQS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JpdG1hcGZvbnQnOlxuXG4gICAgICAgICAgICAgICAgZmlsZUEgPSBmaWxlLmZpbGVBO1xuICAgICAgICAgICAgICAgIGZpbGVCID0gZmlsZS5maWxlQjtcblxuICAgICAgICAgICAgICAgIGlmIChmaWxlQS50eXBlID09PSAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuYml0bWFwRm9udC5hZGQoZmlsZUIua2V5LCBQYXJzZVhNTEJpdG1hcEZvbnQoZmlsZUIuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5hZGRJbWFnZShmaWxlQS5rZXksIGZpbGVBLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5iaXRtYXBGb250LmFkZChmaWxlQS5rZXksIFBhcnNlWE1MQml0bWFwRm9udChmaWxlQS5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLmFkZEltYWdlKGZpbGVCLmtleSwgZmlsZUIuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzcHJpdGVzaGVldCc6XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMuYWRkU3ByaXRlU2hlZXQoZmlsZS5rZXksIGZpbGUuZGF0YSwgZmlsZS5jb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBjYWNoZS5qc29uLmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICAgICAgICBjYWNoZS54bWwuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICBjYWNoZS50ZXh0LmFkZChmaWxlLmtleSwgZmlsZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgICAgICBjYWNoZS5iaW5hcnkuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzb3VuZCc6XG4gICAgICAgICAgICAgICAgY2FjaGUuc291bmQuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdnbHNsJzpcbiAgICAgICAgICAgICAgICBjYWNoZS5zaGFkZXIuYWRkKGZpbGUua2V5LCBmaWxlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9Mb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdGF0ZS9zeXN0ZW1zL0xvYWRlci5qcyIsIi8vICBBIHByb3h5IGNsYXNzIHRvIHRoZSBHbG9iYWwgU3RhdGUgTWFuYWdlclxuXG52YXIgU3RhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlLCBnYW1lKVxue1xuICAgIC8vICBUaGUgU3RhdGUgdGhhdCBvd25zIHRoaXMgU3RhdGVNYW5hZ2VyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgdGhpcy5rZXkgPSBzdGF0ZS5zeXMuc2V0dGluZ3Mua2V5O1xuXG4gICAgLy8gIEdsb2JhbFN0YXRlTWFuYWdlclxuICAgIHRoaXMubWFuYWdlciA9IGdhbWUuc3RhdGU7XG59O1xuXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGVNYW5hZ2VyO1xuXG5TdGF0ZU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgLy8gIFN0YXJ0IHRoaXMgU3RhdGUgKG9yIHRoZSBvbmUgZ2l2ZW4gdmlhIGtleSlcbiAgICBzdGFydDogZnVuY3Rpb24gKGtleSwgZGF0YSlcbiAgICB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgeyBrZXkgPSB0aGlzLmtleTsgfVxuXG4gICAgICAgIHRoaXMubWFuYWdlci5zdGFydChrZXksIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvLyAgUGF1c2UgdGhpcyBTdGF0ZSAob3IgdGhlIG9uZSBnaXZlbiB2aWEga2V5KVxuICAgIHBhdXNlOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7IGtleSA9IHRoaXMua2V5OyB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKGtleSk7XG4gICAgfSxcblxuICAgIC8vICBTdG9wIHRoaXMgU3RhdGUgYW5kIHN0YXJ0IHRoZSBvbmUgZ2l2ZW5cbiAgICBzd2FwOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKHRoaXMua2V5KTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RhcnQoa2V5KTtcbiAgICB9LFxuXG4gICAgbW92ZVVwOiBmdW5jdGlvbiAoKVxuICAgIHtcblxuICAgIH0sXG5cbiAgICBtb3ZlRG93bjogZnVuY3Rpb24gKClcbiAgICB7XG5cbiAgICB9LFxuXG4gICAgYnJpbmdUb1RvcDogZnVuY3Rpb24gKClcbiAgICB7XG5cbiAgICB9LFxuXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKClcbiAgICB7XG5cbiAgICB9LFxuXG4gICAgLy8gIFRPRE9cbiAgICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uIChrZXksIGR1cmF0aW9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnBhdXNlKHRoaXMua2V5KTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RhcnQoa2V5KTtcbiAgICB9LFxuXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gdGhpcy5rZXk7IH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmlzQWN0aXZlKGtleSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0YXRlL3N5c3RlbXMvU3RhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIERpcnR5ISBNYW5hZ2VyXG4qXG4qIEBjbGFzc1xuKi9cbnZhciBVcGRhdGVNYW5hZ2VyID0gZnVuY3Rpb24gKHN0YXRlKVxue1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIHRoaXMubGlzdCA9IFtdO1xuXG4gICAgLy8gdGhpcy5pID0gMTtcblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIFxuICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcbn07XG5cblVwZGF0ZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXBkYXRlTWFuYWdlcjtcblxuVXBkYXRlTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICBzdG9wOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuaSwgJ1VwZGF0ZU1hbmFnZXIuc3RvcCcsIHRoaXMucHJvY2Vzc2VkKTtcblxuICAgICAgICB0aGlzLmxpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAvLyB0aGlzLmkrKztcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGlzdC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5pLCAnVXBkYXRlTWFuYWdlci5zdGFydCcsIGxlbik7XG5cbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBCZWNhdXNlIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgKGFzIGEgY2hpbGQgb2YgYW5vdGhlciBUcmFuc2Zvcm0gdGhhdCB3YXMgdXBkYXRlZClcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RbaV0gJiYgdGhpcy5saXN0W2ldLl9kaXJ0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFtpXS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pXG4gICAge1xuICAgICAgICB0aGlzLmxpc3QucHVzaCh0cmFuc2Zvcm0pO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVcGRhdGVNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3RhdGUvc3lzdGVtcy9VcGRhdGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIGtleXMgb2YgYSBNYXAgY2FuIGJlIGFyYml0cmFyeSB2YWx1ZXMuXG5cbi8qXG52YXIgbWFwID0gbmV3IE1hcChbXG4gICAgWyAxLCAnb25lJyBdLFxuICAgIFsgMiwgJ3R3bycgXSxcbiAgICBbIDMsICd0aHJlZScgXVxuXSk7XG4qL1xuXG52YXIgTWFwID0gZnVuY3Rpb24gKGVsZW1lbnRzKVxue1xuICAgIHRoaXMuZW50cmllcyA9IHt9O1xuXG4gICAgdGhpcy5zaXplID0gMDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGVsZW1lbnRzW2ldWzBdLCBlbGVtZW50c1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG5NYXAucHJvdG90eXBlID0ge1xuXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVudHJpZXMuaGFzT3duUHJvcGVydHkoa2V5KSk7XG4gICAgfSxcblxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZW50cmllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcClcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZW50cmllc1twcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zaXplID0gMDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmVudHJpZXMpO1xuICAgIH0sXG5cbiAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxuICAgICAgICB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbnRyaWVzW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuXG4gICAgZHVtcDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuXG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ01hcCcpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyaWVzKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhrZXksIGVudHJpZXNba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSxcblxuXG4gICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGVudHJpZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhrZXksIGVudHJpZXNba2V5XSkgPT09IGZhbHNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAodmFsdWUpXG4gICAge1xuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW50cmllcylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGVudHJpZXNba2V5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vICBNZXJnZXMgYWxsIG5ldyBrZXlzIGZyb20gdGhlIGdpdmVuIE1hcCBpbnRvIHRoaXMgb25lXG4gICAgLy8gIElmIGl0IGVuY291bnRlcnMgYSBrZXkgdGhhdCBhbHJlYWR5IGV4aXN0cyBpdCB3aWxsIGJlIHNraXBwZWRcbiAgICAvLyAgdW5sZXNzIG92ZXJyaWRlID0gdHJ1ZVxuICAgIG1lcmdlOiBmdW5jdGlvbiAobWFwLCBvdmVycmlkZSlcbiAgICB7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdW5kZWZpbmVkKSB7IG92ZXJyaWRlID0gZmFsc2U7IH1cblxuICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLmVudHJpZXM7XG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXAuZW50cmllcztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAobG9jYWwuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvdmVycmlkZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2NhbFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0cnVjdHMvTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9hcnJheS9RdWlja1NlbGVjdCcpO1xuXG4vKipcbiAqIFJCdXNoIGlzIGEgaGlnaC1wZXJmb3JtYW5jZSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxuICogSXQncyBiYXNlZCBvbiBhbiBvcHRpbWl6ZWQgUi10cmVlIGRhdGEgc3RydWN0dXJlIHdpdGggYnVsayBpbnNlcnRpb24gc3VwcG9ydC5cbiAqXG4gKiBTcGF0aWFsIGluZGV4IGlzIGEgc3BlY2lhbCBkYXRhIHN0cnVjdHVyZSBmb3IgcG9pbnRzIGFuZCByZWN0YW5nbGVzIHRoYXQgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHF1ZXJpZXMgbGlrZVxuICogXCJhbGwgaXRlbXMgd2l0aGluIHRoaXMgYm91bmRpbmcgYm94XCIgdmVyeSBlZmZpY2llbnRseSAoZS5nLiBodW5kcmVkcyBvZiB0aW1lcyBmYXN0ZXIgdGhhbiBsb29waW5nIG92ZXIgYWxsIGl0ZW1zKS5cbiAqL1xuXG5mdW5jdGlvbiByYnVzaCAobWF4RW50cmllcywgZm9ybWF0KVxue1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxucmJ1c2gucHJvdG90eXBlID0ge1xuXG4gICAgYWxsOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveClcbiAgICB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveClcbiAgICB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpXG4gICAge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSlcbiAgICB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKVxuICAgIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpXG4gICAge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdClcbiAgICB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKVxuICAgIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpXG4gICAge1xuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbClcbiAgICB7XG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSlcbiAgICB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pXG4gICAge1xuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKVxuICAgIHtcbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSlcbiAgICB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKVxuICAgIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKVxuICAgIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KVxuICAgIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0gKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbilcbntcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3ggKG5vZGUsIHRvQkJveClcbntcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94IChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKVxue1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYilcbntcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWCAoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkgKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYSAoYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbiAoYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEgKGEsIGIpXG57XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEgKGEsIGIpXG57XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCksXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyAoYSwgYilcbntcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyAoYSwgYilcbntcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZSAoY2hpbGRyZW4pXG57XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdCAoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSlcbntcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3N0cnVjdHMvUlRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDYxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zdHJ1Y3RzL1JUcmVlLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxudmFyIEV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWxzL29iamVjdC9FeHRlbmQnKTtcblxuLyoqXG4qIEEgRnJhbWUgaXMgYSBzZWN0aW9uIG9mIGEgVGV4dHVyZS5cbipcbiogQGNsYXNzIFBoYXNlci5GcmFtZVxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRoaXMgRnJhbWUgYmVsb25ncyB0by5cbiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdW5pcXVlICh3aXRoaW4gdGhlIFRleHR1cmUpIG5hbWUgb2YgdGhpcyBGcmFtZS5cbiogQHBhcmFtIHtudW1iZXJ9IHggLSBYIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxuKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgZnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlLlxuKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXG4qL1xudmFyIEZyYW1lID0gZnVuY3Rpb24gKHRleHR1cmUsIG5hbWUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBUZXh0dXJlIHRoaXMgZnJhbWUgYmVsb25ncyB0by5cbiAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBmcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUuXG4gICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgdGhpcy5zb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICB0aGlzLnNvdXJjZUluZGV4ID0gc291cmNlSW5kZXg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRYIC0gWCBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQgZnJvbS5cbiAgICAqL1xuICAgIHRoaXMuY3V0WCA9IHg7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRZIC0gWSBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQgZnJvbS5cbiAgICAqL1xuICAgIHRoaXMuY3V0WSA9IHk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXRXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgYXJlYSBpbiB0aGUgc291cmNlIGltYWdlIHRvIGN1dC5cbiAgICAqL1xuICAgIHRoaXMuY3V0V2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGN1dEhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGFyZWEgaW4gdGhlIHNvdXJjZSBpbWFnZSB0byBjdXQuXG4gICAgKi9cbiAgICB0aGlzLmN1dEhlaWdodCA9IGhlaWdodDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgWCByZW5kZXJpbmcgb2Zmc2V0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIHRoaXMueCA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIFkgcmVuZGVyaW5nIG9mZnNldCBvZiB0aGlzIEZyYW1lLCB0YWtpbmcgdHJpbSBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICB0aGlzLnkgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgcmVuZGVyaW5nIHdpZHRoIG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJpbmcgaGVpZ2h0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgcmVuZGVyaW5nIHdpZHRoIG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIHRoaXMuY2VudGVyWCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJpbmcgaGVpZ2h0IG9mIHRoaXMgRnJhbWUsIHRha2luZyB0cmltIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIHRoaXMuY2VudGVyWSA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG5cbiAgICAvKipcbiAgICAqIElzIHRoaXMgZnJhbWUgaXMgcm90YXRlZCBvciBub3QgaW4gdGhlIFRleHR1cmU/XG4gICAgKiBSb3RhdGlvbiBhbGxvd3MgeW91IHRvIHVzZSByb3RhdGVkIGZyYW1lcyBpbiB0ZXh0dXJlIGF0bGFzIHBhY2tpbmcuXG4gICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIFNwcml0ZSByb3RhdGlvbi5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdGF0ZWRcbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLnJvdGF0ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogSXMgdGhpcyBhIHRpbGluZyB0ZXh0dXJlPyBBcyB1c2VkIGJ5IHRoZSBsaWtlcyBvZiBhIFRpbGluZ1Nwcml0ZS5cbiAgICAqIFRPRE86IFRyeSBhbmQgcmVtb3ZlIHRoaXMsIGl0IHNob3VsZG4ndCBiZSBoZXJlXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc1RpbGluZ1xuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuaXNUaWxpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRpbnRlZCBwYXJlbnQgaGFzIHVwZGF0ZWQgaXRzIHRleHR1cmUuXG4gICAgKiBUT0RPOiBUcnkgYW5kIHJlbW92ZSB0aGlzLCBpdCBzaG91bGRuJ3QgYmUgaGVyZVxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVxdWlyZXNSZVRpbnRcbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLnJlcXVpcmVzUmVUaW50ID0gZmFsc2U7XG5cbiAgICAvLyAgT3Zlci1yaWRlcyB0aGUgUmVuZGVyZXIgc2V0dGluZz8gLTEgPSB1c2UgUmVuZGVyZXIgU2V0dGluZywgMCA9IE5vIHJvdW5kaW5nLCAxID0gUm91bmRcbiAgICB0aGlzLmF1dG9Sb3VuZCA9IC0xO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgdW4tbW9kaWZpZWQgc291cmNlIGZyYW1lLCB0cmltIGFuZCBVViBkYXRhLlxuICAgICpcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YVxuICAgICovXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBjdXQ6IHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgICBoOiBoZWlnaHQsXG4gICAgICAgICAgICByOiB4ICsgd2lkdGgsXG4gICAgICAgICAgICBiOiB5ICsgaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHRyaW06IGZhbHNlLFxuICAgICAgICBzb3VyY2VTaXplOiB7XG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGg6IGhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGVTb3VyY2VTaXplOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHc6IHdpZHRoLFxuICAgICAgICAgICAgaDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHV2czoge1xuICAgICAgICAgICAgeDA6IDAsXG4gICAgICAgICAgICB5MDogMCxcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgeDM6IDAsXG4gICAgICAgICAgICB5MzogMFxuICAgICAgICB9LFxuICAgICAgICByYWRpdXM6IDAuNSAqIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSxcbiAgICAgICAgZHJhd0ltYWdlOiB7XG4gICAgICAgICAgICBzeDogeCxcbiAgICAgICAgICAgIHN5OiB5LFxuICAgICAgICAgICAgc1dpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIHNIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBkSGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVVWcygpO1xufTtcblxuRnJhbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJhbWU7XG5cbkZyYW1lLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICogSWYgdGhlIGZyYW1lIHdhcyB0cmltbWVkIHdoZW4gYWRkZWQgdG8gdGhlIFRleHR1cmUgQXRsYXMsIHRoaXMgcmVjb3JkcyB0aGUgdHJpbSBhbmQgc291cmNlIGRhdGEuXG4gICAgKlxuICAgICogQG1ldGhvZCBQaGFzZXIuVGV4dHVyZUZyYW1lI3NldFRyaW1cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWxXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZnJhbWUgYmVmb3JlIGJlaW5nIHRyaW1tZWQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFggLSBUaGUgZGVzdGluYXRpb24gWCBwb3NpdGlvbiBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0WSAtIFRoZSBkZXN0aW5hdGlvbiBZIHBvc2l0aW9uIG9mIHRoZSB0cmltbWVkIGZyYW1lIGZvciBkaXNwbGF5LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RXaWR0aCAtIFRoZSBkZXN0aW5hdGlvbiB3aWR0aCBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0SGVpZ2h0IC0gVGhlIGRlc3RpbmF0aW9uIGhlaWdodCBvZiB0aGUgdHJpbW1lZCBmcmFtZSBmb3IgZGlzcGxheS5cbiAgICAqL1xuICAgIHNldFRyaW06IGZ1bmN0aW9uIChhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0LCBkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodClcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgc3MgPSBkYXRhLnNwcml0ZVNvdXJjZVNpemU7XG5cbiAgICAgICAgLy8gIFN0b3JlIGFjdHVhbCB2YWx1ZXNcblxuICAgICAgICBkYXRhLnRyaW0gPSB0cnVlO1xuXG4gICAgICAgIGRhdGEuc291cmNlU2l6ZS53ID0gYWN0dWFsV2lkdGg7XG4gICAgICAgIGRhdGEuc291cmNlU2l6ZS5oID0gYWN0dWFsSGVpZ2h0O1xuXG4gICAgICAgIHNzLnggPSBkZXN0WDtcbiAgICAgICAgc3MueSA9IGRlc3RZO1xuICAgICAgICBzcy53ID0gZGVzdFdpZHRoO1xuICAgICAgICBzcy5oID0gZGVzdEhlaWdodDtcblxuICAgICAgICAvLyAgQWRqdXN0IHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy54ID0gZGVzdFg7XG4gICAgICAgIHRoaXMueSA9IGRlc3RZO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSBkZXN0V2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGVzdEhlaWdodDtcblxuICAgICAgICB0aGlzLmNlbnRlclggPSBNYXRoLmZsb29yKGRlc3RXaWR0aCAvIDIpO1xuICAgICAgICB0aGlzLmNlbnRlclkgPSBNYXRoLmZsb29yKGRlc3RIZWlnaHQgLyAyKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVVWcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICAgICpcbiAgICAqIEBtZXRob2QgdXBkYXRlVVZzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHR3ID0gdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgICAgIHZhciB0aCA9IHRoaXMuc291cmNlLmhlaWdodDtcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMuZGF0YS51dnM7XG4gICAgICAgIFxuICAgICAgICB1dnMueDAgPSB0aGlzLmN1dFggLyB0dztcbiAgICAgICAgdXZzLnkwID0gdGhpcy5jdXRZIC8gdGg7XG5cbiAgICAgICAgdXZzLngxID0gdGhpcy5jdXRYIC8gdHc7XG4gICAgICAgIHV2cy55MSA9ICh0aGlzLmN1dFkgKyB0aGlzLmN1dEhlaWdodCkgLyB0aDtcblxuICAgICAgICB1dnMueDIgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRXaWR0aCkgLyB0dztcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0SGVpZ2h0KSAvIHRoO1xuXG4gICAgICAgIHV2cy54MyA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dFdpZHRoKSAvIHR3O1xuICAgICAgICB1dnMueTMgPSB0aGlzLmN1dFkgLyB0aDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHVwZGF0ZVVWc0ludmVydGVkXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdXBkYXRlVVZzSW52ZXJ0ZWQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgdHcgPSB0aGlzLnNvdXJjZS53aWR0aDtcbiAgICAgICAgdmFyIHRoID0gdGhpcy5zb3VyY2UuaGVpZ2h0O1xuICAgICAgICB2YXIgdXZzID0gdGhpcy5kYXRhLnV2cztcbiAgICAgICAgXG4gICAgICAgIHV2cy54MyA9ICh0aGlzLmN1dFggKyB0aGlzLmN1dEhlaWdodCkgLyB0dztcbiAgICAgICAgdXZzLnkzID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XG5cbiAgICAgICAgdXZzLngyID0gdGhpcy5jdXRYIC8gdHc7ICAgICAgICBcbiAgICAgICAgdXZzLnkyID0gKHRoaXMuY3V0WSArIHRoaXMuY3V0V2lkdGgpIC8gdGg7XG4gICAgICAgIFxuICAgICAgICB1dnMueDEgPSB0aGlzLmN1dFggLyB0dztcbiAgICAgICAgdXZzLnkxID0gdGhpcy5jdXRZIC8gdGg7XG4gICAgICAgIFxuICAgICAgICB1dnMueDAgPSAodGhpcy5jdXRYICsgdGhpcy5jdXRIZWlnaHQpIC8gdHc7XG4gICAgICAgIHV2cy55MCA9IHRoaXMuY3V0WSAvIHRoO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBGcmFtZSh0aGlzLnRleHR1cmUsIHRoaXMubmFtZSwgdGhpcy5zb3VyY2VJbmRleCk7XG5cbiAgICAgICAgY2xvbmUuY3V0WCA9IHRoaXMuY3V0WDtcbiAgICAgICAgY2xvbmUuY3V0WSA9IHRoaXMuY3V0WTtcbiAgICAgICAgY2xvbmUuY3V0V2lkdGggPSB0aGlzLmN1dFdpZHRoO1xuICAgICAgICBjbG9uZS5jdXRIZWlnaHQgPSB0aGlzLmN1dEhlaWdodDtcblxuICAgICAgICBjbG9uZS54ID0gdGhpcy54O1xuICAgICAgICBjbG9uZS55ID0gdGhpcy55O1xuXG4gICAgICAgIGNsb25lLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY2xvbmUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgY2xvbmUuY2VudGVyWCA9IHRoaXMuY2VudGVyWDtcbiAgICAgICAgY2xvbmUuY2VudGVyWSA9IHRoaXMuY2VudGVyWTtcblxuICAgICAgICBjbG9uZS5yb3RhdGVkID0gdGhpcy5yb3RhdGVkO1xuXG4gICAgICAgIGNsb25lLmRhdGEgPSBFeHRlbmQodHJ1ZSwgY2xvbmUuZGF0YSwgdGhpcy5kYXRhKTtcblxuICAgICAgICBjbG9uZS51cGRhdGVVVnMoKTtcblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgIH1cblxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRnJhbWUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAqIFRoZSB3aWR0aCBvZiB0aGUgRnJhbWUgaW4gaXRzIHVuLXRyaW1tZWQsIHVuLXBhZGRlZCBzdGF0ZSwgYXMgcHJlcGFyZWQgaW4gdGhlIGFydCBwYWNrYWdlLFxuICAgICogYmVmb3JlIGJlaW5nIHBhY2tlZC5cbiAgICAqXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JlYWxXaWR0aFxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxXaWR0aFxuICAgICovXG4gICAgcmVhbFdpZHRoOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlU2l6ZS53O1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBGcmFtZSBpbiBpdHMgdW4tdHJpbW1lZCwgdW4tcGFkZGVkIHN0YXRlLCBhcyBwcmVwYXJlZCBpbiB0aGUgYXJ0IHBhY2thZ2UsXG4gICAgKiBiZWZvcmUgYmVpbmcgcGFja2VkLlxuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjcmVhbEhlaWdodFxuICAgICogQHByb3BlcnR5IHthbnl9IHJlYWxIZWlnaHRcbiAgICAqL1xuICAgIHJlYWxIZWlnaHQ6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VTaXplLmg7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFVWc1xuICAgICpcbiAgICAqIEBuYW1lIFBoYXNlci5UZXh0dXJlRnJhbWUjdXZzXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gdXZzXG4gICAgKi9cbiAgICB1dnM6IHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS51dnM7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFRoZSByYWRpdXMgb2YgdGhlIEZyYW1lIChkZXJpdmVkIGZyb20gc3FydCh3ICogdyArIGggKiBoKSAvIDIpXG4gICAgKiBAbmFtZSBQaGFzZXIuVGV4dHVyZUZyYW1lI3JhZGl1c1xuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xuICAgICovXG4gICAgcmFkaXVzOiB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBDYW52YXMgRHJhdyBJbWFnZSBkYXRhXG4gICAgKlxuICAgICogQG5hbWUgUGhhc2VyLlRleHR1cmVGcmFtZSNjYW52YXNEYXRhXG4gICAgKiBAcHJvcGVydHkge09iamVjdH0gY2FudmFzRGF0YVxuICAgICovXG4gICAgY2FudmFzRGF0YToge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmRyYXdJbWFnZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL0ZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA2MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvRnJhbWUuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG52YXIgRnJhbWUgPSByZXF1aXJlKCcuL0ZyYW1lJyk7XG52YXIgVGV4dHVyZVNvdXJjZSA9IHJlcXVpcmUoJy4vVGV4dHVyZVNvdXJjZScpO1xuXG4vKipcbiogQSBUZXh0dXJlIGNvbnNpc3RzIG9mIGEgc291cmNlLCB1c3VhbGx5IGFuIEltYWdlIGZyb20gdGhlIENhY2hlLCBvciBhIENhbnZhcywgYW5kIGEgY29sbGVjdGlvblxuKiBvZiBGcmFtZXMuIFRoZSBGcmFtZXMgcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgYXJlYXMgb2YgdGhlIFRleHR1cmUuIEZvciBleGFtcGxlIGEgdGV4dHVyZSBhdGxhc1xuKiBtYXkgaGF2ZSBtYW55IEZyYW1lcywgb25lIGZvciBlYWNoIGVsZW1lbnQgd2l0aGluIHRoZSBhdGxhcy4gV2hlcmUtYXMgYSBzaW5nbGUgaW1hZ2Ugd291bGQgaGF2ZVxuKiBqdXN0IG9uZSBmcmFtZSwgdGhhdCBlbmNvbXBhc3NlcyB0aGUgd2hvbGUgaW1hZ2UuXG4qXG4qIFRleHR1cmVzIGFyZSBtYW5hZ2VkIGJ5IHRoZSBnbG9iYWwgVGV4dHVyZU1hbmFnZXIuIFRoaXMgaXMgYSBzaW5nbGV0b24gY2xhc3MgdGhhdCBpc1xuKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIGRlbGl2ZXJpbmcgVGV4dHVyZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgRnJhbWVzIHRvIEdhbWUgT2JqZWN0cy5cbipcbiogU3ByaXRlcyBhbmQgb3RoZXIgR2FtZSBPYmplY3RzIGdldCB0aGUgdGV4dHVyZSBkYXRhIHRoZXkgbmVlZCBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZU1vZGVcbiovXG52YXIgVGV4dHVyZSA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBrZXksIHNvdXJjZSlcbntcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAge1xuICAgICAgICBzb3VyY2UgPSBbIHNvdXJjZSBdO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0ga2V5O1xuXG4gICAgLyoqXG4gICAgKiBUaGUgc291cmNlIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRleHR1cmUuXG4gICAgKiBVc3VhbGx5IGFuIEltYWdlLCBidXQgY2FuIGFsc28gYmUgYSBDYW52YXMuXG4gICAgKlxuICAgICogQHByb3BlcnR5IHNvdXJjZVxuICAgICogQHR5cGUgYXJyYXlcbiAgICAqL1xuICAgIHRoaXMuc291cmNlID0gW107XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBmcmFtZXMgLSBGcmFtZXNcbiAgICAqL1xuICAgIHRoaXMuZnJhbWVzID0ge307XG5cbiAgICB0aGlzLmZpcnN0RnJhbWUgPSAnX19CQVNFJztcblxuICAgIHRoaXMuZnJhbWVUb3RhbCA9IDA7XG5cbiAgICAvLyAgTG9hZCB0aGUgU291cmNlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaChuZXcgVGV4dHVyZVNvdXJjZSh0aGlzLCBzb3VyY2VbaV0pKTtcbiAgICB9XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHR1cmU7XG5cblRleHR1cmUucHJvdG90eXBlID0ge1xuXG4gICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB2YXIgZnJhbWUgPSBuZXcgRnJhbWUodGhpcywgbmFtZSwgc291cmNlSW5kZXgsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuZnJhbWVzW25hbWVdID0gZnJhbWU7XG5cbiAgICAgICAgLy8gIFNldCB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIFRleHR1cmUgKG90aGVyIHRoYW4gX19CQVNFKVxuICAgICAgICAvLyAgVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB3ZSBkb24ndCBzcGFtIHRoZSBkaXNwbGF5IHdpdGggZW50aXJlXG4gICAgICAgIC8vICBhdGxhc2VzIG9mIHNwcml0ZSBzaGVldHMsIGJ1dCBpbnN0ZWFkIGp1c3QgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZW1cbiAgICAgICAgLy8gIHNob3VsZCB0aGUgZGV2IGluY29ycmVjdGx5IHNwZWNpZnkgdGhlIGZyYW1lIGluZGV4XG4gICAgICAgIGlmICh0aGlzLmZyYW1lVG90YWwgPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lVG90YWwrKztcblxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWUgPSAodGhpcy5mcmFtZVRvdGFsID09PSAxKSA/ICdfX0JBU0UnIDogdGhpcy5maXJzdEZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFmcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBUZXh0dXJlLmZyYW1lIGZvdW5kIHdpdGggbmFtZSAnICsgbmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1snX19CQVNFJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0U291cmNlSW1hZ2U6IGZ1bmN0aW9uIChuYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsIHx8IHRoaXMuZnJhbWVUb3RhbCA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZSA9ICdfX0JBU0UnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFmcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBUZXh0dXJlLmZyYW1lIGZvdW5kIHdpdGggbmFtZSAnICsgbmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1snX19CQVNFJ10uc291cmNlLmltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lLnNvdXJjZS5pbWFnZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlSW5kZXg6IGZ1bmN0aW9uIChpbmRleClcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zb3VyY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlW2ldLmdsVGV4dHVyZUluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc291cmNlW2ldLmltYWdlLmN1cnJlbnRTcmMsICdpbmRleCA9ICcsIGluZGV4KTtcblxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxuICAgICpcbiAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICBUT0RPXG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9UZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XG52YXIgQ2FudmFzUG9vbCA9IHJlcXVpcmUoJy4uL2RvbS9DYW52YXNQb29sJyk7XG5cbi8qKlxuKiBUZXh0dXJlcyBhcmUgbWFuYWdlZCBieSB0aGUgZ2xvYmFsIFRleHR1cmVNYW5hZ2VyLiBUaGlzIGlzIGEgc2luZ2xldG9uIGNsYXNzIHRoYXQgaXNcbiogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBkZWxpdmVyaW5nIFRleHR1cmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIEZyYW1lcyB0byBHYW1lIE9iamVjdHMuXG4qXG4qIFNwcml0ZXMgYW5kIG90aGVyIEdhbWUgT2JqZWN0cyBnZXQgdGhlIHRleHR1cmUgZGF0YSB0aGV5IG5lZWQgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXG4qXG4qIEFjY2VzcyBpdCB2aWEgYHN0YXRlLnRleHR1cmVzYC5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiovXG52YXIgVGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAoZ2FtZSlcbntcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgdGhpcy5saXN0ID0ge307XG5cbiAgICB0aGlzLmFkZEJhc2U2NCgnX19ERUZBVUxUJywgZ2FtZS5jb25maWcuZGVmYXVsdEltYWdlKTtcbiAgICB0aGlzLmFkZEJhc2U2NCgnX19NSVNTSU5HJywgZ2FtZS5jb25maWcubWlzc2luZ0ltYWdlKTtcbn07XG5cblRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHR1cmVNYW5hZ2VyO1xuXG5UZXh0dXJlTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICBhZGRCYXNlNjQ6IGZ1bmN0aW9uIChrZXksIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IF90aGlzLmNyZWF0ZShrZXksIGltYWdlKTtcbiAgICAgICAgXG4gICAgICAgICAgICBQYXJzZXIuSW1hZ2UodGV4dHVyZSwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcbiAgICB9LFxuXG4gICAgYWRkSW1hZ2U6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xuICAgICAgICBcbiAgICAgICAgUGFyc2VyLkltYWdlKHRleHR1cmUsIDApO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVDYW52YXM6IGZ1bmN0aW9uIChrZXksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkgeyB3aWR0aCA9IDI1NjsgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHsgaGVpZ2h0ID0gMjU2OyB9XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IENhbnZhc1Bvb2wuY3JlYXRlKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbnZhcyhrZXksIGNhbnZhcyk7XG4gICAgfSxcblxuICAgIGFkZENhbnZhczogZnVuY3Rpb24gKGtleSwgc291cmNlKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XG4gICAgICAgIFxuICAgICAgICBQYXJzZXIuQ2FudmFzKHRleHR1cmUsIDApO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICBhZGRBdGxhczogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxuICAgIHtcbiAgICAgICAgLy8gIElzIGl0IGEgSGFzaCBvciBhbiBBcnJheT9cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmZyYW1lcykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkFycmF5KGtleSwgc291cmNlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEF0bGFzSlNPTkhhc2goa2V5LCBzb3VyY2UsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEF0bGFzSlNPTkFycmF5OiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UsIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFBhcnNlci5KU09OQXJyYXkodGV4dHVyZSwgaSwgZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBQYXJzZXIuSlNPTkFycmF5KHRleHR1cmUsIDAsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIGFkZEF0bGFzSlNPTkhhc2g6IGZ1bmN0aW9uIChrZXksIHNvdXJjZSwgZGF0YSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzb3VyY2UpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgUGFyc2VyLkpTT05IYXNoKHRleHR1cmUsIGksIGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgUGFyc2VyLkpTT05IYXNoKHRleHR1cmUsIDAsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFthZGRTcHJpdGVTaGVldCBkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0ga2V5ICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gc291cmNlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gY29uZmlnIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLmZyYW1lV2lkdGggLSBUaGUgZml4ZWQgd2lkdGggb2YgZWFjaCBmcmFtZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5mcmFtZUhlaWdodF0gLSBUaGUgZml4ZWQgaGVpZ2h0IG9mIGVhY2ggZnJhbWUuIElmIG5vdCBzZXQgaXQgd2lsbCB1c2UgdGhlIGZyYW1lV2lkdGggYXMgdGhlIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zdGFydEZyYW1lPTBdIC0gU2tpcCBhIG51bWJlciBvZiBmcmFtZXMuIFVzZWZ1bCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBzcHJpdGUgc2hlZXRzIGluIG9uZSBUZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmVuZEZyYW1lPS0xXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIHRvIGV4dHJhY3QgZnJvbSB0aGUgU3ByaXRlIFNoZWV0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBtZWFucyBcImV4dHJhY3QgYWxsIGZyYW1lc1wiLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1hcmdpbj0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggYSBtYXJnaW4sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnNwYWNpbmc9MF0gLSBJZiB0aGUgZnJhbWVzIGhhdmUgYmVlbiBkcmF3biB3aXRoIHNwYWNpbmcgYmV0d2VlbiB0aGVtLCBzcGVjaWZ5IHRoZSBhbW91bnQgaGVyZS5cbiAgICAgKi9cbiAgICBhZGRTcHJpdGVTaGVldDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBjb25maWcpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlKGtleSwgc291cmNlKTtcblxuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlLnNvdXJjZVswXS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmUuc291cmNlWzBdLmhlaWdodDtcblxuICAgICAgICBQYXJzZXIuU3ByaXRlU2hlZXQodGV4dHVyZSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgY29uZmlnKTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgYWRkU3ByaXRlU2hlZXRGcm9tQXRsYXM6IGZ1bmN0aW9uIChrZXksIGF0bGFzS2V5LCBhdGxhc0ZyYW1lLCBjb25maWcpXG4gICAge1xuICAgICAgICB2YXIgYXRsYXMgPSB0aGlzLmdldChhdGxhc0tleSk7XG4gICAgICAgIHZhciBzaGVldCA9IGF0bGFzLmdldChhdGxhc0ZyYW1lKTtcblxuICAgICAgICBpZiAoc2hlZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGUoa2V5LCBzaGVldC5zb3VyY2UuaW1hZ2UpO1xuXG4gICAgICAgICAgICBQYXJzZXIuU3ByaXRlU2hlZXQodGV4dHVyZSwgMCwgc2hlZXQuY3V0WCwgc2hlZXQuY3V0WSwgc2hlZXQuY3V0V2lkdGgsIHNoZWV0LmN1dEhlaWdodCwgY29uZmlnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkQXRsYXNTdGFybGluZ1hNTDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgaSwgZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBQYXJzZXIuU3RhcmxpbmdYTUwodGV4dHVyZSwgMCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgYWRkQXRsYXNQeXhlbDogZnVuY3Rpb24gKGtleSwgc291cmNlLCBkYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZShrZXksIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQYXJzZXIuUHl4ZWwodGV4dHVyZSwgaSwgZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBQYXJzZXIuUHl4ZWwodGV4dHVyZSwgMCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMsIGtleSwgc291cmNlKTtcblxuICAgICAgICB0aGlzLmxpc3Rba2V5XSA9IHRleHR1cmU7XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIGV4aXN0czogZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5saXN0Lmhhc093blByb3BlcnR5KGtleSkpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHsga2V5ID0gJ19fREVGQVVMVCc7IH1cblxuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RbJ19fTUlTU0lORyddO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsb25lRnJhbWU6IGZ1bmN0aW9uIChrZXksIGZyYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdFtrZXldKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0W2tleV0uZ2V0KGZyYW1lKS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEZyYW1lOiBmdW5jdGlvbiAoa2V5LCBmcmFtZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxpc3Rba2V5XSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtrZXldLmdldChmcmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZTogZnVuY3Rpb24gKGdhbWVPYmplY3QsIGtleSwgZnJhbWUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5saXN0W2tleV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdhbWVPYmplY3QudGV4dHVyZSA9IHRoaXMubGlzdFtrZXldO1xuICAgICAgICAgICAgZ2FtZU9iamVjdC5mcmFtZSA9IGdhbWVPYmplY3QudGV4dHVyZS5nZXQoZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUGFzc2VzIGFsbCBUZXh0dXJlcyB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAgKlxuICAgICogQG1ldGhvZCBlYWNoXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAgKiBAcGFyYW0gey4uLip9IFthcmd1bWVudHNdIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIGFmdGVyIHRoZSBjaGlsZC5cbiAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZylcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gWyBudWxsIF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdGV4dHVyZSBpbiB0aGlzLmxpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB0aGlzLmxpc3RbdGV4dHVyZV07XG5cbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvVGV4dHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9UZXh0dXJlTWFuYWdlci5qcyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG52YXIgU2NhbGVNb2RlcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyL1NjYWxlTW9kZXMnKTtcbnZhciBJc1NpemVQb3dlck9mVHdvID0gcmVxdWlyZSgnLi4vbWF0aC9wb3cyL0lzU2l6ZVBvd2VyT2ZUd28nKTtcbnZhciBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlID0gcmVxdWlyZSgnLi4vcmVuZGVyZXIvd2ViZ2wvdXRpbHMvdGV4dHVyZS9DcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlJyk7XG5cbi8qKlxuKlxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVTb3VyY2VcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiogQHBhcmFtIHtudW1iZXJ9IHNjYWxlTW9kZVxuKi9cbnZhciBUZXh0dXJlU291cmNlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZSlcbntcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgdGhpcy5pbWFnZSA9IHNvdXJjZTtcblxuICAgIHRoaXMuY29tcHJlc3Npb25BbGdvcml0aG0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgUmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkgcmVzb2x1dGlvblxuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgIFxuICAgIC8qKlxuICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0dXJlLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKiBAcmVhZE9ubHlcbiAgICAqL1xuICAgIHRoaXMud2lkdGggPSBzb3VyY2UubmF0dXJhbFdpZHRoIHx8IHNvdXJjZS53aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IHNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZS5oZWlnaHQgfHwgMDtcblxuICAgIC8qKlxuICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZS5cbiAgICAqIE5FQVJFU1Qgb3IgREVGQVVMVFxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSBzY2FsZU1vZGVcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAZGVmYXVsdCBQaGFzZXIuc2NhbGVNb2Rlcy5ERUZBVUxUO1xuICAgICovXG4gICAgdGhpcy5zY2FsZU1vZGUgPSBTY2FsZU1vZGVzLkRFRkFVTFQ7XG5cbiAgICAvKipcbiAgICAqIENvbnRyb2xzIGlmIFJHQiBjaGFubmVscyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSBwcmVtdWx0aXBsaWVkQWxwaGFcbiAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiBhIG1pcG1hcCBvZiB0aGlzIHRleHR1cmUgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkLiBUaGlzIHZhbHVlIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgdGhlIHRleHR1cmUgaXMgdXNlZFxuICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xuICAgICpcbiAgICAqIEBwcm9wZXJ0eSBtaXBtYXBMZXZlbFxuICAgICogQHR5cGUge2ludGVnZXJ9XG4gICAgKi9cbiAgICB0aGlzLm1pcG1hcExldmVsID0gMDtcblxuICAgIC8qKlxuICAgICogQSBCYXNlVGV4dHVyZSBjYW4gYmUgc2V0IHRvIHNraXAgdGhlIHJlbmRlcmluZyBwaGFzZSBpbiB0aGUgV2ViR0wgU3ByaXRlIEJhdGNoLlxuICAgICpcbiAgICAqIFlvdSBtYXkgd2FudCB0byBkbyB0aGlzIGlmIHlvdSBoYXZlIGEgcGFyZW50IFNwcml0ZSB3aXRoIG5vIHZpc2libGUgdGV4dHVyZSAoaS5lLiB1c2VzIHRoZSBpbnRlcm5hbCBgX19kZWZhdWx0YCB0ZXh0dXJlKVxuICAgICogdGhhdCBoYXMgY2hpbGRyZW4gdGhhdCB5b3UgZG8gd2FudCB0byByZW5kZXIsIHdpdGhvdXQgY2F1c2luZyBhIGJhdGNoIGZsdXNoIGluIHRoZSBwcm9jZXNzLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSByZW5kZXJhYmxlXG4gICAgKiBAdHlwZSBCb29sZWFuXG4gICAgKi9cbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgaXNQb3dlck9mMlxuICAgICogQHR5cGUgYm9vbGVhblxuICAgICovXG4gICAgdGhpcy5pc1Bvd2VyT2YyID0gSXNTaXplUG93ZXJPZlR3byh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSBnbFRleHR1cmVcbiAgICAqL1xuICAgIHRoaXMuZ2xUZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogVGhlIG11bHRpIHRleHR1cmUgYmF0Y2hpbmcgaW5kZXggbnVtYmVyLlxuICAgICogQHByb3BlcnR5IGdsVGV4dHVyZUluZGV4XG4gICAgKiBAdHlwZSBOdW1iZXJcbiAgICAqL1xuICAgIHRoaXMuZ2xUZXh0dXJlSW5kZXggPSAwO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgdGltZXN0YW1wIHdoZW4gdGhpcyB0ZXh0dXJlIHdhcyBsYXN0IHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgICogQ2FuIGJlIHVzZWQgdG8gcHVyZ2Ugb3V0ICdkZWFkJyB0ZXh0dXJlcyBmcm9tIEdQVSBtZW1vcnkuXG4gICAgKiBAcHJvcGVydHkgZ2xMYXN0VXNlZFxuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKi9cbiAgICB0aGlzLmdsTGFzdFVzZWQgPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgZ2xEaXJ0eVxuICAgICovXG4gICAgdGhpcy5nbERpcnR5ID0gdHJ1ZTtcblxuICAgIHZhciBnYW1lID0gdGV4dHVyZS5tYW5hZ2VyLmdhbWU7XG5cbiAgICBpZiAoZ2FtZS5jb25maWcucmVuZGVyVHlwZSA9PT0gQ09OU1QuV0VCR0wpXG4gICAge1xuICAgICAgICBDcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKGdhbWUucmVuZGVyZXIuZ2wsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVNvdXJjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL1RleHR1cmVTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDYyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90ZXh0dXJlcy9UZXh0dXJlU291cmNlLmpzIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlIGEgU3ByaXRlIFNoZWV0IGFuZCBleHRyYWN0cyB0aGUgZnJhbWUgZGF0YSBmcm9tIGl0LlxuKlxuKiBAY2xhc3MgUGhhc2VyLlRleHR1cmVQYXJzZXIuSW1hZ2VcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgRnJhbWUgd2l0aGluIHRoZSBUZXh0dXJlIHRoYXQgdGhlIFNwcml0ZSBTaGVldCBpcyBzdG9yZWQgaW4uXG4qIEByZXR1cm4ge1BoYXNlci5GcmFtZURhdGF9IEEgRnJhbWVEYXRhIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJzZWQgZnJhbWVzLlxuKi9cbnZhciBDYW52YXNUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4KVxue1xuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzVGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvQ2FudmFzVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBQYXJzZSBhIFNwcml0ZSBTaGVldCBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkltYWdlXG4qIEBzdGF0aWNcbiogQHBhcmFtIHtQaGFzZXIuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBwYXJlbnQgVGV4dHVyZS5cbiogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIEZyYW1lIHdpdGhpbiB0aGUgVGV4dHVyZSB0aGF0IHRoZSBTcHJpdGUgU2hlZXQgaXMgc3RvcmVkIGluLlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgSW1hZ2VUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4KVxue1xuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICB0ZXh0dXJlLmFkZCgnX19CQVNFJywgc291cmNlSW5kZXgsIDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VUZXh0dXJlUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9JbWFnZVRleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogUGFyc2VzIGEgSlNPTiBBcnJheSBhbmQgZXh0cmFjdHMgdGhlIGZyYW1lIGRhdGEgZnJvbSBpdC5cbipcbiogQGNsYXNzIFBoYXNlci5UZXh0dXJlUGFyc2VyLkpTT05BcnJheVxuKiBAc3RhdGljXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXG4qIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIEpTT04gZGF0YSBmcm9tIHRoZSBUZXh0dXJlIEF0bGFzLiBNdXN0IGJlIGluIEFycmF5IGZvcm1hdC5cbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXG4qL1xudmFyIEpTT05BcnJheVRleHR1cmVQYXJzZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgc291cmNlSW5kZXgsIGpzb24pXG57XG4gICAgLy8gIE1hbGZvcm1lZD9cbiAgICBpZiAoIWpzb25bJ2ZyYW1lcyddKVxuICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIFRleHR1cmUgQXRsYXMgSlNPTiBBcnJheSBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgYXJyYXknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vICBBZGQgaW4gYSBfX0JBU0UgZW50cnkgKGZvciB0aGUgZW50aXJlIGF0bGFzKVxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZVtzb3VyY2VJbmRleF07XG4gICAgdGV4dHVyZS5hZGQoJ19fQkFTRScsIHNvdXJjZUluZGV4LCAwLCAwLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuXG4gICAgLy8gIEJ5IHRoaXMgc3RhZ2UgZnJhbWVzIGlzIGEgZnVsbHkgcGFyc2VkIGFycmF5XG4gICAgdmFyIGZyYW1lcyA9IGpzb25bJ2ZyYW1lcyddO1xuICAgIHZhciBuZXdGcmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHNyYyA9IGZyYW1lc1tpXTtcblxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXG4gICAgICAgIG5ld0ZyYW1lID0gdGV4dHVyZS5hZGQoc3JjLmZpbGVuYW1lLCBzb3VyY2VJbmRleCwgc3JjLmZyYW1lLngsIHNyYy5mcmFtZS55LCBzcmMuZnJhbWUudywgc3JjLmZyYW1lLmgpO1xuXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xuICAgICAgICBpZiAoc3JjLnRyaW1tZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUudyxcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueSxcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjLnJvdGF0ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV3RnJhbWUudXBkYXRlVVZzSW52ZXJ0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OQXJyYXlUZXh0dXJlUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdGV4dHVyZXMvcGFyc2Vycy9KU09OQXJyYXlUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIEBhdXRob3IgICAgICAgUmljaGFyZCBEYXZleSA8cmljaEBwaG90b25zdG9ybS5jb20+XG4qIEBjb3B5cmlnaHQgICAgMjAxNiBQaG90b24gU3Rvcm0gTHRkLlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFBhcnNlcyBhIEpTT04gQXJyYXkgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBKU09OIEhhc2ggZm9ybWF0LlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgSlNPTkhhc2hUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCBqc29uKVxue1xuICAgIC8vICBNYWxmb3JtZWQ/XG4gICAgaWYgKCFqc29uWydmcmFtZXMnXSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBUZXh0dXJlIEF0bGFzIEpTT04gSGFzaCBnaXZlbiwgbWlzc2luZyBcXCdmcmFtZXNcXCcgT2JqZWN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgQWRkIGluIGEgX19CQVNFIGVudHJ5IChmb3IgdGhlIGVudGlyZSBhdGxhcylcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2Vbc291cmNlSW5kZXhdO1xuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcblxuICAgIC8vICBCeSB0aGlzIHN0YWdlIGZyYW1lcyBpcyBhIGZ1bGx5IHBhcnNlZCBPYmplY3RcbiAgICB2YXIgZnJhbWVzID0ganNvblsnZnJhbWVzJ107XG4gICAgdmFyIG5ld0ZyYW1lO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGZyYW1lcylcbiAgICB7XG4gICAgICAgIHZhciBzcmMgPSBmcmFtZXNba2V5XTtcblxuICAgICAgICAvLyAgVGhlIGZyYW1lIHZhbHVlcyBhcmUgdGhlIGV4YWN0IGNvb3JkaW5hdGVzIHRvIGN1dCB0aGUgZnJhbWUgb3V0IG9mIHRoZSBhdGxhcyBmcm9tXG4gICAgICAgIG5ld0ZyYW1lID0gdGV4dHVyZS5hZGQoa2V5LCBzb3VyY2VJbmRleCwgc3JjLmZyYW1lLngsIHNyYy5mcmFtZS55LCBzcmMuZnJhbWUudywgc3JjLmZyYW1lLmgpO1xuXG4gICAgICAgIC8vICBUaGVzZSBhcmUgdGhlIG9yaWdpbmFsIChub24tdHJpbW1lZCkgc3ByaXRlIHZhbHVlc1xuICAgICAgICBpZiAoc3JjLnRyaW1tZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oXG4gICAgICAgICAgICAgICAgc3JjLnNvdXJjZVNpemUudyxcbiAgICAgICAgICAgICAgICBzcmMuc291cmNlU2l6ZS5oLFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLngsXG4gICAgICAgICAgICAgICAgc3JjLnNwcml0ZVNvdXJjZVNpemUueSxcbiAgICAgICAgICAgICAgICBzcmMuc3ByaXRlU291cmNlU2l6ZS53LFxuICAgICAgICAgICAgICAgIHNyYy5zcHJpdGVTb3VyY2VTaXplLmhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjLnJvdGF0ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV3RnJhbWUudXBkYXRlVVZzSW52ZXJ0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OSGFzaFRleHR1cmVQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL0pTT05IYXNoVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbi8qKlxuKiBQYXJzZXMgYSBQeXhlbCBKU09OIEZpbGUgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5KU09OQXJyYXlcbiogQHN0YXRpY1xuKiBAcGFyYW0ge1BoYXNlci5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHBhcmVudCBUZXh0dXJlLlxuKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBKU09OIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBQeXhlbCBKU09OIGZvcm1hdC5cbiogQHJldHVybiB7UGhhc2VyLkZyYW1lRGF0YX0gQSBGcmFtZURhdGEgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBmcmFtZXMuXG4qL1xudmFyIFB5eGVsVGV4dHVyZVBhcnNlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBqc29uKVxue1xuICAgIC8vICBNYWxmb3JtZWQ/IFRoZXJlIGFyZSBhIGZldyBrZXlzIHRvIGNoZWNrIGhlcmUuXG4gICAgdmFyIHNpZ25hdHVyZSA9IFsgJ2xheWVycycsICd0aWxld2lkdGgnLCAndGlsZWhlaWdodCcsICd0aWxlc3dpZGUnLCAndGlsZXNoaWdoJyBdO1xuXG4gICAgc2lnbmF0dXJlLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIGlmICghanNvbltrZXldKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ1BoYXNlci5BbmltYXRpb25QYXJzZXIuSlNPTkRhdGFQeXhlbDogSW52YWxpZCBQeXhlbCBUaWxlbWFwIEpTT04gZ2l2ZW4sIG1pc3NpbmcgXCInICsga2V5ICsgJ1wiIGtleS4nKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGb3IgdGhpcyBwdXJwb3NlLCBJIG9ubHkgY2FyZSBhYm91dCBwYXJzaW5nIHRpbGVtYXBzIHdpdGggYSBzaW5nbGUgbGF5ZXIuXG4gICAgaWYgKGpzb25bJ2xheWVycyddLmxlbmd0aCAhPT0gMSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignUGhhc2VyLkFuaW1hdGlvblBhcnNlci5KU09ORGF0YVB5eGVsOiBUb28gbWFueSBsYXllcnMsIHRoaXMgcGFyc2VyIG9ubHkgc3VwcG9ydHMgZmxhdCBUaWxlbWFwcy4nKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coanNvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XG5cbiAgICB2YXIgdGlsZWhlaWdodCA9IGpzb25bJ3RpbGVoZWlnaHQnXTtcbiAgICB2YXIgdGlsZXdpZHRoID0ganNvblsndGlsZXdpZHRoJ107XG5cbiAgICB2YXIgZnJhbWVzID0ganNvblsnbGF5ZXJzJ11bMF1bJ3RpbGVzJ107XG4gICAgdmFyIG5ld0ZyYW1lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBuZXdGcmFtZSA9IGRhdGEuYWRkRnJhbWUobmV3IFBoYXNlci5GcmFtZShcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBmcmFtZXNbaV0ueCxcbiAgICAgICAgICAgIGZyYW1lc1tpXS55LFxuICAgICAgICAgICAgdGlsZXdpZHRoLFxuICAgICAgICAgICAgdGlsZWhlaWdodCxcbiAgICAgICAgICAgIFwiZnJhbWVfXCIgKyBpICAvLyBObyBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gcHl4ZWwgdGlsZW1hcCBkYXRhLlxuICAgICAgICApKTtcblxuICAgICAgICAvLyBObyB0cmltIGRhdGEgaXMgaW5jbHVkZWQuXG4gICAgICAgIG5ld0ZyYW1lLnNldFRyaW0oZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQeXhlbFRleHR1cmVQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL1B5eGVsVGV4dHVyZVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbiovXG5cbnZhciBHZXRPYmplY3RWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdC9HZXRPYmplY3RWYWx1ZScpO1xuXG4vKipcbiogUGFyc2UgYSBTcHJpdGUgU2hlZXQgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TcHJpdGVTaGVldFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXG4qIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBGcmFtZSB3aXRoaW4gdGhlIFRleHR1cmUgdGhhdCB0aGUgU3ByaXRlIFNoZWV0IGlzIHN0b3JlZCBpbi5cbiogQHBhcmFtIHtudW1iZXJ9IGZyYW1lV2lkdGggLSBUaGUgZml4ZWQgd2lkdGggb2YgZWFjaCBmcmFtZS5cbiogQHBhcmFtIHtudW1iZXJ9IGZyYW1lSGVpZ2h0IC0gVGhlIGZpeGVkIGhlaWdodCBvZiBlYWNoIGZyYW1lLlxuKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0RnJhbWU9MF0gLSBTa2lwIGEgbnVtYmVyIG9mIGZyYW1lcy4gVXNlZnVsIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNwcml0ZSBzaGVldHMgaW4gb25lIFRleHR1cmUuXG4qIEBwYXJhbSB7bnVtYmVyfSBbZW5kRnJhbWU9LTFdIC0gVGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgdG8gZXh0cmFjdCBmcm9tIHRoZSBTcHJpdGUgU2hlZXQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIC0xIG1lYW5zIFwiZXh0cmFjdCBhbGwgZnJhbWVzXCIuXG4qIEBwYXJhbSB7bnVtYmVyfSBbbWFyZ2luPTBdIC0gSWYgdGhlIGZyYW1lcyBoYXZlIGJlZW4gZHJhd24gd2l0aCBhIG1hcmdpbiwgc3BlY2lmeSB0aGUgYW1vdW50IGhlcmUuXG4qIEBwYXJhbSB7bnVtYmVyfSBbc3BhY2luZz0wXSAtIElmIHRoZSBmcmFtZXMgaGF2ZSBiZWVuIGRyYXduIHdpdGggc3BhY2luZyBiZXR3ZWVuIHRoZW0sIHNwZWNpZnkgdGhlIGFtb3VudCBoZXJlLlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHNvdXJjZUluZGV4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb25maWcpXG57XG4gICAgdmFyIGZyYW1lV2lkdGggPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdmcmFtZVdpZHRoJywgbnVsbCk7XG4gICAgdmFyIGZyYW1lSGVpZ2h0ID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnZnJhbWVIZWlnaHQnLCBmcmFtZVdpZHRoKTtcblxuICAgIC8vICBJZiBtaXNzaW5nIHdlIGNhbid0IHByb2NlZWRcbiAgICBpZiAoZnJhbWVXaWR0aCA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZU1hbmFnZXIuU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyOiBJbnZhbGlkIGZyYW1lV2lkdGggZ2l2ZW4uJyk7XG4gICAgfVxuXG4gICAgLy8gIEFkZCBpbiBhIF9fQkFTRSBlbnRyeSAoZm9yIHRoZSBlbnRpcmUgYXRsYXMpXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgIHRleHR1cmUuYWRkKCdfX0JBU0UnLCBzb3VyY2VJbmRleCwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcblxuICAgIHZhciBzdGFydEZyYW1lID0gR2V0T2JqZWN0VmFsdWUoY29uZmlnLCAnc3RhcnRGcmFtZScsIDApO1xuICAgIHZhciBlbmRGcmFtZSA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ2VuZEZyYW1lJywgLTEpO1xuICAgIHZhciBtYXJnaW4gPSBHZXRPYmplY3RWYWx1ZShjb25maWcsICdtYXJnaW4nLCAwKTtcbiAgICB2YXIgc3BhY2luZyA9IEdldE9iamVjdFZhbHVlKGNvbmZpZywgJ3NwYWNpbmcnLCAwKTtcblxuICAgIHZhciByb3cgPSBNYXRoLmZsb29yKCh3aWR0aCAtIG1hcmdpbikgLyAoZnJhbWVXaWR0aCArIHNwYWNpbmcpKTtcbiAgICB2YXIgY29sdW1uID0gTWF0aC5mbG9vcigoaGVpZ2h0IC0gbWFyZ2luKSAvIChmcmFtZUhlaWdodCArIHNwYWNpbmcpKTtcbiAgICB2YXIgdG90YWwgPSByb3cgKiBjb2x1bW47XG5cbiAgICBpZiAoc3RhcnRGcmFtZSA+IHRvdGFsIHx8IHN0YXJ0RnJhbWUgPCAtdG90YWwpXG4gICAge1xuICAgICAgICBzdGFydEZyYW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRGcmFtZSA8IDApXG4gICAge1xuICAgICAgICAvLyAgQWxsb3cgbmVnYXRpdmUgc2tpcGZyYW1lcy5cbiAgICAgICAgc3RhcnRGcmFtZSA9IHRvdGFsICsgc3RhcnRGcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoZW5kRnJhbWUgIT09IC0xKVxuICAgIHtcbiAgICAgICAgdG90YWwgPSBzdGFydEZyYW1lICsgKGVuZEZyYW1lICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIGZ4ID0gbWFyZ2luO1xuICAgIHZhciBmeSA9IG1hcmdpbjtcbiAgICB2YXIgYXggPSAwO1xuICAgIHZhciBheSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICBheCA9IDA7XG4gICAgICAgIGF5ID0gMDtcblxuICAgICAgICB2YXIgdyA9IGZ4ICsgZnJhbWVXaWR0aDtcbiAgICAgICAgdmFyIGggPSBmeSArIGZyYW1lSGVpZ2h0O1xuXG4gICAgICAgIGlmICh3ID4gd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gdyAtIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggPiBoZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF5ID0gaCAtIGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHR1cmUuYWRkKGksIHNvdXJjZUluZGV4LCB4ICsgZngsIHkgKyBmeSwgZnJhbWVXaWR0aCAtIGF4LCBmcmFtZUhlaWdodCAtIGF5KTtcblxuICAgICAgICBmeCArPSBmcmFtZVdpZHRoICsgc3BhY2luZztcblxuICAgICAgICBpZiAoZnggKyBmcmFtZVdpZHRoID4gd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZ4ID0gbWFyZ2luO1xuICAgICAgICAgICAgZnkgKz0gZnJhbWVIZWlnaHQgKyBzcGFjaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvU3ByaXRlU2hlZXRUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvcGFyc2Vycy9TcHJpdGVTaGVldFRleHR1cmVQYXJzZXIuanMiLCIvKipcbiogQGF1dGhvciAgICAgICBSaWNoYXJkIERhdmV5IDxyaWNoQHBob3RvbnN0b3JtLmNvbT5cbiogQGNvcHlyaWdodCAgICAyMDE2IFBob3RvbiBTdG9ybSBMdGQuXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvYmxvYi9tYXN0ZXIvbGljZW5zZS50eHR8TUlUIExpY2Vuc2V9XG4qL1xuXG4vKipcbiogUGFyc2VzIHRoZSBYTUwgYW5kIGV4dHJhY3RzIHRoZSBmcmFtZSBkYXRhIGZyb20gaXQuXG4qXG4qIEBjbGFzcyBQaGFzZXIuVGV4dHVyZVBhcnNlci5TdGFybGluZ1hNTFxuKiBAc3RhdGljXG4qIEBwYXJhbSB7UGhhc2VyLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgcGFyZW50IFRleHR1cmUuXG4qIEBwYXJhbSB7b2JqZWN0fSB4bWwgLSBUaGUgWE1MIGRhdGEgZnJvbSB0aGUgVGV4dHVyZSBBdGxhcy4gTXVzdCBiZSBpbiBTdGFybGluZyBYTUwgZm9ybWF0LlxuKiBAcmV0dXJuIHtQaGFzZXIuRnJhbWVEYXRhfSBBIEZyYW1lRGF0YSBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIGZyYW1lcy5cbiovXG52YXIgU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyID0gZnVuY3Rpb24gKHRleHR1cmUsIHhtbClcbntcbiAgICAvLyAgTWFsZm9ybWVkP1xuICAgIGlmICgheG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUZXh0dXJlQXRsYXMnKSlcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybihcIlBoYXNlci5BbmltYXRpb25QYXJzZXIuWE1MRGF0YTogSW52YWxpZCBUZXh0dXJlIEF0bGFzIFhNTCBnaXZlbiwgbWlzc2luZyA8VGV4dHVyZUF0bGFzPiB0YWdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAgTGV0J3MgY3JlYXRlIHNvbWUgZnJhbWVzIHRoZW5cbiAgICB2YXIgZGF0YSA9IG5ldyBQaGFzZXIuRnJhbWVEYXRhKCk7XG4gICAgdmFyIGZyYW1lcyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU3ViVGV4dHVyZScpO1xuICAgIHZhciBuZXdGcmFtZTtcblxuICAgIHZhciBuYW1lO1xuICAgIHZhciBmcmFtZTtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgd2lkdGg7XG4gICAgdmFyIGhlaWdodDtcbiAgICB2YXIgZnJhbWVYO1xuICAgIHZhciBmcmFtZVk7XG4gICAgdmFyIGZyYW1lV2lkdGg7XG4gICAgdmFyIGZyYW1lSGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIG5hbWUgPSBmcmFtZS5uYW1lLnZhbHVlO1xuICAgICAgICB4ID0gcGFyc2VJbnQoZnJhbWUueC52YWx1ZSwgMTApO1xuICAgICAgICB5ID0gcGFyc2VJbnQoZnJhbWUueS52YWx1ZSwgMTApO1xuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KGZyYW1lLndpZHRoLnZhbHVlLCAxMCk7XG4gICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGZyYW1lLmhlaWdodC52YWx1ZSwgMTApO1xuXG4gICAgICAgIGZyYW1lWCA9IG51bGw7XG4gICAgICAgIGZyYW1lWSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZyYW1lLmZyYW1lWClcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWVYID0gTWF0aC5hYnMocGFyc2VJbnQoZnJhbWUuZnJhbWVYLnZhbHVlLCAxMCkpO1xuICAgICAgICAgICAgZnJhbWVZID0gTWF0aC5hYnMocGFyc2VJbnQoZnJhbWUuZnJhbWVZLnZhbHVlLCAxMCkpO1xuICAgICAgICAgICAgZnJhbWVXaWR0aCA9IHBhcnNlSW50KGZyYW1lLmZyYW1lV2lkdGgudmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0ID0gcGFyc2VJbnQoZnJhbWUuZnJhbWVIZWlnaHQudmFsdWUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZyYW1lID0gZGF0YS5hZGRGcmFtZShuZXcgUGhhc2VyLkZyYW1lKGksIHgsIHksIHdpZHRoLCBoZWlnaHQsIG5hbWUpKTtcblxuICAgICAgICAvLyAgVHJpbW1lZD9cbiAgICAgICAgaWYgKGZyYW1lWCAhPT0gbnVsbCB8fCBmcmFtZVkgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5ld0ZyYW1lLnNldFRyaW0odHJ1ZSwgd2lkdGgsIGhlaWdodCwgZnJhbWVYLCBmcmFtZVksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXJsaW5nWE1MVGV4dHVyZVBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3RleHR1cmVzL3BhcnNlcnMvU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDYW52YXM6IHJlcXVpcmUoJy4vQ2FudmFzVGV4dHVyZVBhcnNlcicpLFxuICAgIEltYWdlOiByZXF1aXJlKCcuL0ltYWdlVGV4dHVyZVBhcnNlcicpLFxuICAgIFNwcml0ZVNoZWV0OiByZXF1aXJlKCcuL1Nwcml0ZVNoZWV0VGV4dHVyZVBhcnNlcicpLFxuICAgIEpTT05BcnJheTogcmVxdWlyZSgnLi9KU09OQXJyYXlUZXh0dXJlUGFyc2VyJyksXG4gICAgSlNPTkhhc2g6IHJlcXVpcmUoJy4vSlNPTkhhc2hUZXh0dXJlUGFyc2VyJyksXG4gICAgU3RhcmxpbmdYTUw6IHJlcXVpcmUoJy4vU3RhcmxpbmdYTUxUZXh0dXJlUGFyc2VyJyksXG4gICAgUHl4ZWw6IHJlcXVpcmUoJy4vUHl4ZWxUZXh0dXJlUGFyc2VyJylcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi90ZXh0dXJlcy9wYXJzZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2Mjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGV4dHVyZXMvcGFyc2Vycy9pbmRleC5qcyIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4vY29uc3QnKTtcblxudmFyIEFsaWduSW5NYXAgPSBbXTtcblxuQWxpZ25Jbk1hcFtDT05TVC5CT1RUT01fQ0VOVEVSXSA9IHJlcXVpcmUoJy4vSW5Cb3R0b21DZW50ZXInKTtcbkFsaWduSW5NYXBbQ09OU1QuQk9UVE9NX0xFRlRdID0gcmVxdWlyZSgnLi9JbkJvdHRvbUxlZnQnKTtcbkFsaWduSW5NYXBbQ09OU1QuQk9UVE9NX1JJR0hUXSA9IHJlcXVpcmUoJy4vSW5Cb3R0b21SaWdodCcpO1xuQWxpZ25Jbk1hcFtDT05TVC5DRU5URVJdID0gcmVxdWlyZSgnLi9JbkNlbnRlcicpO1xuQWxpZ25Jbk1hcFtDT05TVC5MRUZUX0NFTlRFUl0gPSByZXF1aXJlKCcuL0luTGVmdENlbnRlcicpO1xuQWxpZ25Jbk1hcFtDT05TVC5SSUdIVF9DRU5URVJdID0gcmVxdWlyZSgnLi9JblJpZ2h0Q2VudGVyJyk7XG5BbGlnbkluTWFwW0NPTlNULlRPUF9DRU5URVJdID0gcmVxdWlyZSgnLi9JblRvcENlbnRlcicpO1xuQWxpZ25Jbk1hcFtDT05TVC5UT1BfTEVGVF0gPSByZXF1aXJlKCcuL0luVG9wTGVmdCcpO1xuQWxpZ25Jbk1hcFtDT05TVC5UT1BfUklHSFRdID0gcmVxdWlyZSgnLi9JblRvcFJpZ2h0Jyk7XG5cbnZhciBBbGlnbkluID0gZnVuY3Rpb24gKGNoaWxkLCBjb250YWluZXIsIHBvc2l0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIHJldHVybiBBbGlnbkluTWFwW3Bvc2l0aW9uXShjaGlsZCwgY29udGFpbmVyLCBvZmZzZXRYLCBvZmZzZXRZKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWxpZ25JbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL0FsaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDYzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9BbGlnbkluLmpzIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XG5cbnZhciBUb0JvdHRvbUNlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldENlbnRlclgoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChwYXJlbnQpICsgb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21DZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub0JvdHRvbUNlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvQm90dG9tQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XG5cbnZhciBUb0JvdHRvbUxlZnQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xuICAgIFNldFRvcChnYW1lT2JqZWN0LCBHZXRCb3R0b20ocGFyZW50KSArIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvQm90dG9tTGVmdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvQm90dG9tTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gNjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvQm90dG9tTGVmdC5qcyIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xudmFyIFNldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRUb3AnKTtcblxudmFyIFRvQm90dG9tUmlnaHQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldEJvdHRvbShwYXJlbnQpICsgb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9Cb3R0b21SaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvQm90dG9tUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDYzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub0JvdHRvbVJpZ2h0LmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xudmFyIEdldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRCb3R0b20nKTtcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcblxudmFyIFRvTGVmdEJvdHRvbSA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldFJpZ2h0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRCb3R0b20ocGFyZW50KSArIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvTGVmdEJvdHRvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvTGVmdEJvdHRvbS5qcyIsInZhciBHZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldExlZnQnKTtcbnZhciBHZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclknKTtcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xudmFyIFNldENlbnRlclkgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Q2VudGVyWScpO1xuXG52YXIgVG9MZWZ0Q2VudGVyID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XG4gICAgU2V0Q2VudGVyWShnYW1lT2JqZWN0LCBHZXRDZW50ZXJZKHBhcmVudCkgKyBvZmZzZXRZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb0xlZnRDZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub0xlZnRDZW50ZXIuanMiLCJ2YXIgR2V0TGVmdCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRMZWZ0Jyk7XG52YXIgR2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFRvcCcpO1xudmFyIFNldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFJpZ2h0Jyk7XG52YXIgU2V0VG9wID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldFRvcCcpO1xuXG52YXIgVG9MZWZ0VG9wID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0UmlnaHQoZ2FtZU9iamVjdCwgR2V0TGVmdChwYXJlbnQpIC0gb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9MZWZ0VG9wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzXG4vLyBtb2R1bGUgaWQgPSA2MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vVG9MZWZ0VG9wLmpzIiwidmFyIEdldFJpZ2h0ID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldFJpZ2h0Jyk7XG52YXIgR2V0Qm90dG9tID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldEJvdHRvbScpO1xudmFyIFNldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0TGVmdCcpO1xudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcblxudmFyIFRvUmlnaHRCb3R0b20gPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldFJpZ2h0KHBhcmVudCkgKyBvZmZzZXRYKTtcbiAgICBTZXRCb3R0b20oZ2FtZU9iamVjdCwgR2V0Qm90dG9tKHBhcmVudCkgKyBvZmZzZXRZKTtcblxuICAgIHJldHVybiBnYW1lT2JqZWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb1JpZ2h0Qm90dG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYWxpZ24vVG9SaWdodEJvdHRvbS5qc1xuLy8gbW9kdWxlIGlkID0gNjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvUmlnaHRCb3R0b20uanMiLCJ2YXIgR2V0UmlnaHQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0UmlnaHQnKTtcbnZhciBHZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL0dldENlbnRlclknKTtcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcbnZhciBTZXRDZW50ZXJZID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclknKTtcblxudmFyIFRvUmlnaHRUb3AgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldFJpZ2h0KHBhcmVudCkgKyBvZmZzZXRYKTtcbiAgICBTZXRDZW50ZXJZKGdhbWVPYmplY3QsIEdldENlbnRlclkocGFyZW50KSArIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvUmlnaHRUb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub1JpZ2h0Q2VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYWxpZ24vVG9SaWdodENlbnRlci5qcyIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcbnZhciBTZXRUb3AgPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0VG9wJyk7XG5cbnZhciBUb1JpZ2h0VG9wID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHBhcmVudCwgb2Zmc2V0WCwgb2Zmc2V0WSlcbntcbiAgICBpZiAob2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFggPSAwOyB9XG4gICAgaWYgKG9mZnNldFkgPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRZID0gMDsgfVxuXG4gICAgU2V0TGVmdChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XG4gICAgU2V0VG9wKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9SaWdodFRvcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvUmlnaHRUb3AuanNcbi8vIG1vZHVsZSBpZCA9IDYzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub1JpZ2h0VG9wLmpzIiwidmFyIEdldENlbnRlclggPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0Q2VudGVyWCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRDZW50ZXJYID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldENlbnRlclgnKTtcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XG5cbnZhciBUb1RvcENlbnRlciA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0LCBwYXJlbnQsIG9mZnNldFgsIG9mZnNldFkpXG57XG4gICAgaWYgKG9mZnNldFggPT09IHVuZGVmaW5lZCkgeyBvZmZzZXRYID0gMDsgfVxuICAgIGlmIChvZmZzZXRZID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WSA9IDA7IH1cblxuICAgIFNldENlbnRlclgoZ2FtZU9iamVjdCwgR2V0Q2VudGVyWChwYXJlbnQpICsgb2Zmc2V0WCk7XG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BDZW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hbGlnbi9Ub1RvcENlbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvVG9wQ2VudGVyLmpzIiwidmFyIEdldExlZnQgPSByZXF1aXJlKCcuLi9ib3VuZHMvR2V0TGVmdCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRMZWZ0ID0gcmVxdWlyZSgnLi4vYm91bmRzL1NldExlZnQnKTtcbnZhciBTZXRCb3R0b20gPSByZXF1aXJlKCcuLi9ib3VuZHMvU2V0Qm90dG9tJyk7XG5cbnZhciBUb1RvcExlZnQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRMZWZ0KGdhbWVPYmplY3QsIEdldExlZnQocGFyZW50KSAtIG9mZnNldFgpO1xuICAgIFNldEJvdHRvbShnYW1lT2JqZWN0LCBHZXRUb3AocGFyZW50KSAtIG9mZnNldFkpO1xuXG4gICAgcmV0dXJuIGdhbWVPYmplY3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvVG9wTGVmdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvVG9wTGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gNjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FsaWduL1RvVG9wTGVmdC5qcyIsInZhciBHZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRSaWdodCcpO1xudmFyIEdldFRvcCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9HZXRUb3AnKTtcbnZhciBTZXRSaWdodCA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRSaWdodCcpO1xudmFyIFNldEJvdHRvbSA9IHJlcXVpcmUoJy4uL2JvdW5kcy9TZXRCb3R0b20nKTtcblxudmFyIFRvVG9wUmlnaHQgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdCwgcGFyZW50LCBvZmZzZXRYLCBvZmZzZXRZKVxue1xuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WSA9PT0gdW5kZWZpbmVkKSB7IG9mZnNldFkgPSAwOyB9XG5cbiAgICBTZXRSaWdodChnYW1lT2JqZWN0LCBHZXRSaWdodChwYXJlbnQpICsgb2Zmc2V0WCk7XG4gICAgU2V0Qm90dG9tKGdhbWVPYmplY3QsIEdldFRvcChwYXJlbnQpIC0gb2Zmc2V0WSk7XG5cbiAgICByZXR1cm4gZ2FtZU9iamVjdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG9Ub3BSaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FsaWduL1RvVG9wUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDY0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy91dGlscy9hbGlnbi9Ub1RvcFJpZ2h0LmpzIiwiLyoqXG4qIFNuYXBzIGEgdmFsdWUgdG8gdGhlIG5lYXJlc3QgdmFsdWUgaW4gYW4gYXJyYXkuXG4qIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgaW4gdGhlIHJhbmdlIGBbZmlyc3RfdmFsdWUsIGxhc3RfdmFsdWVdYC5cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgc2VhcmNoIHZhbHVlXG4qIEBwYXJhbSB7bnVtYmVyW119IGFyciAtIFRoZSBpbnB1dCBhcnJheSB3aGljaCBfbXVzdF8gYmUgc29ydGVkLlxuKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZWFyZXN0IHZhbHVlIGZvdW5kLlxuKi9cbnZhciBGaW5kQ2xvc2VzdEluU29ydGVkID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSlcbntcbiAgICBpZiAoIWFycmF5Lmxlbmd0aClcbiAgICB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSB8fCB2YWx1ZSA8IGFycmF5WzBdKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cblxuICAgIHZhciBpID0gMTtcblxuICAgIHdoaWxlIChhcnJheVtpXSA8IHZhbHVlKVxuICAgIHtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHZhciBsb3cgPSBhcnJheVtpIC0gMV07XG4gICAgdmFyIGhpZ2ggPSAoaSA8IGFycmF5Lmxlbmd0aCkgPyBhcnJheVtpXSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIHJldHVybiAoKGhpZ2ggLSB2YWx1ZSkgPD0gKHZhbHVlIC0gbG93KSkgPyBoaWdoIDogbG93O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaW5kQ2xvc2VzdEluU29ydGVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvRmluZENsb3Nlc3RJblNvcnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gNjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBGZXRjaCBhIHJhbmRvbSBlbnRyeSBmcm9tIHRoZSBnaXZlbiBhcnJheS5cbipcbiogV2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBhcmUgbm8gYXJyYXkgaXRlbXMgdGhhdCBmYWxsIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggLSBPcHRpb25hbCByZXN0cmljdGlvbiBvbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB5b3Ugd2FudCB0byByYW5kb21seSBzZWxlY3QgZnJvbS5cbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZC5cbiovXG5cbnZhciBHZXRSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydCwgbGVuZ3RoKVxue1xuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgeyBsZW5ndGggPSBhcnJheS5sZW5ndGg7IH1cblxuICAgIHZhciByYW5kb21JbmRleCA9IHN0YXJ0ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKTtcblxuICAgIHJldHVybiAoYXJyYXlbcmFuZG9tSW5kZXhdID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGFycmF5W3JhbmRvbUluZGV4XTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2V0UmFuZG9tRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL2FycmF5L0dldFJhbmRvbUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUm91bmRBd2F5RnJvbVplcm8gPSByZXF1aXJlKCcuLi8uLi9tYXRoL1JvdW5kQXdheUZyb21aZXJvJyk7XG5cbi8qKlxuKiBDcmVhdGUgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tIGBzdGFydGBcbiogdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAgYnkgYWR2YW5jaW5nIGJ5IGBzdGVwYC5cbipcbiogSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYGVuZGAgYSB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4qXG4qIENlcnRhaW4gdmFsdWVzIGZvciBgc3RhcnRgIGFuZCBgZW5kYCAoZWcuIE5hTi91bmRlZmluZWQvbnVsbCkgYXJlIGN1cnJlbnRseSBjb2VyY2VkIHRvIDA7XG4qIGZvciBmb3J3YXJkIGNvbXBhdGliaWxpdHkgbWFrZSBzdXJlIHRvIHBhc3MgaW4gYWN0dWFsIG51bWJlcnMuXG4qXG4qIEBtZXRob2QgUGhhc2VyLkFycmF5VXRpbHMjbnVtYmVyQXJyYXlTdGVwXG4qIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4qIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gLSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgbnVtYmVycy5cbiogQGV4YW1wbGVcbiogTnVtYmVyQXJyYXlTdGVwKDQpO1xuKiAvLyA9PiBbMCwgMSwgMiwgM11cbipcbiogTnVtYmVyQXJyYXlTdGVwKDEsIDUpO1xuKiAvLyA9PiBbMSwgMiwgMywgNF1cbipcbiogTnVtYmVyQXJyYXlTdGVwKDAsIDIwLCA1KTtcbiogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbipcbiogTnVtYmVyQXJyYXlTdGVwKDAsIC00LCAtMSk7XG4qIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuKlxuKiBOdW1iZXJBcnJheVN0ZXAoMSwgNCwgMCk7XG4qIC8vID0+IFsxLCAxLCAxXVxuKlxuKiBOdW1iZXJBcnJheVN0ZXAoMCk7XG4qIC8vID0+IFtdXG4qL1xudmFyIE51bWJlckFycmF5U3RlcCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKVxue1xuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7IHN0YXJ0ID0gMDsgfVxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgeyBlbmQgPSBudWxsOyB9XG4gICAgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgeyBzdGVwID0gMTsgfVxuXG4gICAgaWYgKGVuZCA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgdmFyIHRvdGFsID0gTWF0aC5tYXgoUm91bmRBd2F5RnJvbVplcm8oKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICByZXN1bHQucHVzaChzdGFydCk7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyQXJyYXlTdGVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA2NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvTnVtYmVyQXJyYXlTdGVwLmpzIiwidmFyIFNwbGljZU9uZSA9IHJlcXVpcmUoJy4vU3BsaWNlT25lJyk7XG5cbi8qKlxuKiBSZW1vdmVzIGEgcmFuZG9tIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbipcbiogV2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBhcmUgbm8gYXJyYXkgaXRlbXMgdGhhdCBmYWxsIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlXG4qIG9yIGlmIHRoZXJlIGlzIG5vIGl0ZW0gZm9yIHRoZSByYW5kb21seSBjaG9zZW4gaW5kZXguXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHthbnlbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMuXG4qIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnRJbmRleCAtIE9wdGlvbmFsIG9mZnNldCBvZmYgdGhlIGZyb250IG9mIHRoZSBhcnJheS4gRGVmYXVsdCB2YWx1ZSBpcyAwLCBvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cbiogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggLSBPcHRpb25hbCByZXN0cmljdGlvbiBvbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB5b3Ugd2FudCB0byByYW5kb21seSBzZWxlY3QgZnJvbS5cbiogQHJldHVybiB7b2JqZWN0fSBUaGUgcmFuZG9tIG9iamVjdCB0aGF0IHdhcyByZW1vdmVkLlxuKi9cblxudmFyIFJlbW92ZVJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0LCBsZW5ndGgpXG57XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgc3RhcnQgPSAwOyB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgfVxuXG4gICAgdmFyIHJhbmRvbUluZGV4ID0gc3RhcnQgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpO1xuXG4gICAgcmV0dXJuIFNwbGljZU9uZShhcnJheSwgcmFuZG9tSW5kZXgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdmVSYW5kb21FbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYXJyYXkvUmVtb3ZlUmFuZG9tRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3V0aWxzL2FycmF5L1JlbW92ZVJhbmRvbUVsZW1lbnQuanMiLCIvLyEgc3RhYmxlLmpzIDAuMS42LCBodHRwczovL2dpdGh1Yi5jb20vVHdvLVNjcmVlbi9zdGFibGVcbi8vISDCqSAyMDE3IEFuZ3J5IEJ5dGVzIGFuZCBjb250cmlidXRvcnMuIE1JVCBsaWNlbnNlZC5cblxuKGZ1bmN0aW9uKCkge1xuXG4vLyBBIHN0YWJsZSBhcnJheSBzb3J0LCBiZWNhdXNlIGBBcnJheSNzb3J0KClgIGlzIG5vdCBndWFyYW50ZWVkIHN0YWJsZS5cbi8vIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgbWVyZ2Ugc29ydCwgd2l0aG91dCByZWN1cnNpb24uXG5cbnZhciBzdGFibGUgPSBmdW5jdGlvbihhcnIsIGNvbXApIHtcbiAgICByZXR1cm4gZXhlYyhhcnIuc2xpY2UoKSwgY29tcCk7XG59O1xuXG5zdGFibGUuaW5wbGFjZSA9IGZ1bmN0aW9uKGFyciwgY29tcCkge1xuICAgIHZhciByZXN1bHQgPSBleGVjKGFyciwgY29tcCk7XG5cbiAgICAvLyBUaGlzIHNpbXBseSBjb3BpZXMgYmFjayBpZiB0aGUgcmVzdWx0IGlzbid0IGluIHRoZSBvcmlnaW5hbCBhcnJheSxcbiAgICAvLyB3aGljaCBoYXBwZW5zIG9uIGFuIG9kZCBudW1iZXIgb2YgcGFzc2VzLlxuICAgIGlmIChyZXN1bHQgIT09IGFycikge1xuICAgICAgICBwYXNzKHJlc3VsdCwgbnVsbCwgYXJyLmxlbmd0aCwgYXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLy8gRXhlY3V0ZSB0aGUgc29ydCB1c2luZyB0aGUgaW5wdXQgYXJyYXkgYW5kIGEgc2Vjb25kIGJ1ZmZlciBhcyB3b3JrIHNwYWNlLlxuLy8gUmV0dXJucyBvbmUgb2YgdGhvc2UgdHdvLCBjb250YWluaW5nIHRoZSBmaW5hbCByZXN1bHQuXG5mdW5jdGlvbiBleGVjKGFyciwgY29tcCkge1xuICAgIGlmICh0eXBlb2YoY29tcCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29tcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydC1jaXJjdWl0IHdoZW4gdGhlcmUncyBub3RoaW5nIHRvIHNvcnQuXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgLy8gUmF0aGVyIHRoYW4gZGl2aWRpbmcgaW5wdXQsIHNpbXBseSBpdGVyYXRlIGNodW5rcyBvZiAxLCAyLCA0LCA4LCBldGMuXG4gICAgLy8gQ2h1bmtzIGFyZSB0aGUgc2l6ZSBvZiB0aGUgbGVmdCBvciByaWdodCBoYW5kIGluIG1lcmdlIHNvcnQuXG4gICAgLy8gU3RvcCB3aGVuIHRoZSBsZWZ0LWhhbmQgY292ZXJzIGFsbCBvZiB0aGUgYXJyYXkuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGNoayA9IDE7IGNoayA8IGxlbjsgY2hrICo9IDIpIHtcbiAgICAgICAgcGFzcyhhcnIsIGNvbXAsIGNoaywgYnVmZmVyKTtcblxuICAgICAgICB2YXIgdG1wID0gYXJyO1xuICAgICAgICBhcnIgPSBidWZmZXI7XG4gICAgICAgIGJ1ZmZlciA9IHRtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG4vLyBSdW4gYSBzaW5nbGUgcGFzcyB3aXRoIHRoZSBnaXZlbiBjaHVuayBzaXplLlxudmFyIHBhc3MgPSBmdW5jdGlvbihhcnIsIGNvbXAsIGNoaywgcmVzdWx0KSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIFN0ZXAgc2l6ZSAvIGRvdWJsZSBjaHVuayBzaXplLlxuICAgIHZhciBkYmwgPSBjaGsgKiAyO1xuICAgIC8vIEJvdW5kcyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmtzLlxuICAgIHZhciBsLCByLCBlO1xuICAgIC8vIEl0ZXJhdG9ycyBvdmVyIHRoZSBsZWZ0IGFuZCByaWdodCBjaHVuay5cbiAgICB2YXIgbGksIHJpO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHBhaXJzIG9mIGNodW5rcy5cbiAgICBmb3IgKGwgPSAwOyBsIDwgbGVuOyBsICs9IGRibCkge1xuICAgICAgICByID0gbCArIGNoaztcbiAgICAgICAgZSA9IHIgKyBjaGs7XG4gICAgICAgIGlmIChyID4gbGVuKSByID0gbGVuO1xuICAgICAgICBpZiAoZSA+IGxlbikgZSA9IGxlbjtcblxuICAgICAgICAvLyBJdGVyYXRlIGJvdGggY2h1bmtzIGluIHBhcmFsbGVsLlxuICAgICAgICBsaSA9IGw7XG4gICAgICAgIHJpID0gcjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgdGhlIGNodW5rcy5cbiAgICAgICAgICAgIGlmIChsaSA8IHIgJiYgcmkgPCBlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBmb3IgYSByZWd1bGFyIGBzb3J0KClgIGNvbXBhdGlibGUgY29tcGFyYXRvcixcbiAgICAgICAgICAgICAgICAvLyBidXQgYWxzbyBmb3IgYSBzaW1wbGUgY29tcGFyYXRvciBsaWtlOiBgYSA+IGJgXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAoYXJyW2xpXSwgYXJyW3JpXSkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGFycltsaSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY29tcGFyZSwganVzdCBmbHVzaCB3aGF0J3MgbGVmdC5cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpIDwgcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmkgPCBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBhcnJbcmkrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCb3RoIGl0ZXJhdG9ycyBhcmUgYXQgdGhlIGNodW5rIGVuZHMuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEV4cG9ydCB1c2luZyBDb21tb25KUyBvciB0byB0aGUgd2luZG93LlxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhYmxlO1xufVxuZWxzZSB7XG4gICAgd2luZG93LnN0YWJsZSA9IHN0YWJsZTtcbn1cblxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9hcnJheS9TdGFibGVTb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdXRpbHMvYXJyYXkvU3RhYmxlU29ydC5qcyIsIi8qKlxuKiBUaGUgYW1vdW50IHRoZSBHYW1lIE9iamVjdCBpcyB2aXN1YWxseSBvZmZzZXQgZnJvbSBpdHMgeCBjb29yZGluYXRlLlxuKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB3aWR0aCAqIG9yaWdpbi54YC5cbiogSXQgd2lsbCBvbmx5IGJlID4gMCBpZiBvcmlnaW4ueCBpcyBub3QgZXF1YWwgdG8gemVyby5cbipcbiogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFhcbiogQHJlYWRPbmx5XG4qL1xuXG52YXIgR2V0T2Zmc2V0WCA9IGZ1bmN0aW9uIChnYW1lT2JqZWN0KVxue1xuICAgIHJldHVybiBnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5vcmlnaW5YO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZXRPZmZzZXRYO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vdXRpbHMvYm91bmRzL0dldE9mZnNldFguanNcbi8vIG1vZHVsZSBpZCA9IDY0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogVGhlIGFtb3VudCB0aGUgR2FtZSBPYmplY3QgaXMgdmlzdWFsbHkgb2Zmc2V0IGZyb20gaXRzIHggY29vcmRpbmF0ZS5cbiogVGhpcyBpcyB0aGUgc2FtZSBhcyBgd2lkdGggKiBvcmlnaW4ueGAuXG4qIEl0IHdpbGwgb25seSBiZSA+IDAgaWYgb3JpZ2luLnggaXMgbm90IGVxdWFsIHRvIHplcm8uXG4qXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRYXG4qIEByZWFkT25seVxuKi9cblxudmFyIEdldE9mZnNldFkgPSBmdW5jdGlvbiAoZ2FtZU9iamVjdClcbntcbiAgICByZXR1cm4gZ2FtZU9iamVjdC5oZWlnaHQgKiBnYW1lT2JqZWN0Lm9yaWdpblk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE9mZnNldFk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9ib3VuZHMvR2V0T2Zmc2V0WS5qc1xuLy8gbW9kdWxlIGlkID0gNjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuKiBUYWtlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCBwYWRzIGl0IG91dCwgdG8gdGhlIGxlbmd0aCByZXF1aXJlZCwgdXNpbmcgdGhlIGNoYXJhY3RlclxuKiBzcGVjaWZpZWQuIEZvciBleGFtcGxlIGlmIHlvdSBuZWVkIGEgc3RyaW5nIHRvIGJlIDYgY2hhcmFjdGVycyBsb25nLCB5b3UgY2FuIGNhbGw6XG4qXG4qIGBwYWQoJ2JvYicsIDYsICctJywgMilgXG4qXG4qIFRoaXMgd291bGQgcmV0dXJuOiBgYm9iLS0tYCBhcyBpdCBoYXMgcGFkZGVkIGl0IG91dCB0byA2IGNoYXJhY3RlcnMsIHVzaW5nIHRoZSBgLWAgb24gdGhlIHJpZ2h0LlxuKlxuKiBZb3UgY2FuIGFsc28gdXNlIGl0IHRvIHBhZCBudW1iZXJzICh0aGV5IGFyZSBhbHdheXMgcmV0dXJuZWQgYXMgc3RyaW5ncyk6XG4qIFxuKiBgcGFkKDUxMiwgNiwgJzAnLCAxKWBcbipcbiogV291bGQgcmV0dXJuOiBgMDAwNTEyYCB3aXRoIHRoZSBzdHJpbmcgcGFkZGVkIHRvIHRoZSBsZWZ0LlxuKlxuKiBJZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhIGRpcmVjdGlvbiBpdCdsbCBwYWQgdG8gYm90aCBzaWRlczpcbiogXG4qIGBwYWQoJ2M2NCcsIDcsICcqJylgXG4qXG4qIFdvdWxkIHJldHVybjogYCoqYzY0KipgXG4qXG4qIEBtZXRob2QgUGhhc2VyLlV0aWxzLnBhZFxuKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHRhcmdldCBzdHJpbmcuIGB0b1N0cmluZygpYCB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgc3RyaW5nLCB3aGljaCBtZWFucyB5b3UgY2FuIGFsc28gcGFzcyBpbiBjb21tb24gZGF0YSB0eXBlcyBsaWtlIG51bWJlcnMuXG4qIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBiZSBhZGRlZC5cbiogQHBhcmFtIHtzdHJpbmd9IFtwYWQ9XCIgXCJdIC0gVGhlIHN0cmluZyB0byBwYWQgaXQgb3V0IHdpdGggKGRlZmF1bHRzIHRvIGEgc3BhY2UpLlxuKiBAcGFyYW0ge2ludGVnZXJ9IFtkaXI9M10gLSBUaGUgZGlyZWN0aW9uIGRpciA9IDEgKGxlZnQpLCAyIChyaWdodCksIDMgKGJvdGgpLlxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkZWQgc3RyaW5nLlxuKi9cbnZhciBQYWQgPSBmdW5jdGlvbiAoc3RyLCBsZW4sIHBhZCwgZGlyKVxue1xuICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkgeyB2YXIgbGVuID0gMDsgfVxuICAgIGlmIChwYWQgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFkID0gJyAnOyB9XG4gICAgaWYgKGRpciA9PT0gdW5kZWZpbmVkKSB7IHZhciBkaXIgPSAzOyB9XG5cbiAgICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcblxuICAgIHZhciBwYWRsZW4gPSAwO1xuXG4gICAgaWYgKGxlbiArIDEgPj0gc3RyLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHN3aXRjaCAoZGlyKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc3RyID0gbmV3IEFycmF5KGxlbiArIDEgLSBzdHIubGVuZ3RoKS5qb2luKHBhZCkgKyBzdHI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLmNlaWwoKHBhZGxlbiA9IGxlbiAtIHN0ci5sZW5ndGgpIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBwYWRsZW4gLSByaWdodDtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXcgQXJyYXkobGVmdCsxKS5qb2luKHBhZCkgKyBzdHIgKyBuZXcgQXJyYXkocmlnaHQrMSkuam9pbihwYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArIG5ldyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi91dGlscy9zdHJpbmcvUGFkLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4qIFRha2VzIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldmVyc2VzIGl0LCByZXR1cm5pbmcgdGhlIHJldmVyc2VkIHN0cmluZy5cbiogRm9yIGV4YW1wbGUgaWYgZ2l2ZW4gdGhlIHN0cmluZyBgQXRhcmkgNTIwU1RgIGl0IHdvdWxkIHJldHVybiBgVFMwMjUgaXJhdEFgLlxuKlxuKiBAbWV0aG9kIFBoYXNlci5VdGlscy5yZXZlcnNlU3RyaW5nXG4qIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGJlIHJldmVyc2VkLlxuKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSByZXZlcnNlZCBzdHJpbmcuXG4qL1xudmFyIFJldmVyc2VTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKVxue1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmV2ZXJzZVN0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3V0aWxzL3N0cmluZy9SZXZlcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9yaWNoL0RvY3VtZW50cy9waGFzZXIvdjMvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9waGFzZXIuanMiLCJyZXF1aXJlKCcuL3BvbHlmaWxscycpO1xuXG52YXIgQ09OU1QgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG52YXIgRXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QvRXh0ZW5kJyk7XG5cbi8vICBUaGlzIG9iamVjdCBpcyBleHBvcnRlZCBnbG9iYWxseVxuXG52YXIgUGhhc2VyID0ge1xuXG4gICAgQWN0aW9uczogcmVxdWlyZSgnLi9hY3Rpb25zLycpLFxuXG4gICAgRE9NOiByZXF1aXJlKCcuL2RvbS8nKSxcblxuICAgIEdhbWU6IHJlcXVpcmUoJy4vYm9vdC9HYW1lJyksXG5cbiAgICBFdmVudDogcmVxdWlyZSgnLi9ldmVudHMvRXZlbnQnKSxcbiAgICBFdmVudERpc3BhdGNoZXI6IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50RGlzcGF0Y2hlcicpLFxuXG4gICAgTWF0aDogcmVxdWlyZSgnLi9tYXRoJyksXG5cbiAgICBDb21wb25lbnRzOiByZXF1aXJlKCcuL2NvbXBvbmVudHMnKSxcblxuICAgIEdlb206IHJlcXVpcmUoJy4vZ2VvbScpLFxuXG4gICAgR3JhcGhpY3M6IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKSxcblxuICAgIElucHV0OiByZXF1aXJlKCcuL2lucHV0JyksXG5cbiAgICBHYW1lT2JqZWN0czogcmVxdWlyZSgnLi9nYW1lb2JqZWN0cycpLFxuXG4gICAgU3RhdGU6IHJlcXVpcmUoJy4vc3RhdGUvU3RhdGUnKSxcblxuICAgIExvYWRlcjoge1xuXG4gICAgICAgIEltYWdlRmlsZTogcmVxdWlyZSgnLi9sb2FkZXIvZmlsZXR5cGVzL0ltYWdlRmlsZScpXG5cbiAgICB9LFxuXG4gICAgU291bmQ6IHJlcXVpcmUoJy4vc291bmQnKSxcblxuICAgIFBoeXNpY3M6IHJlcXVpcmUoJy4vcGh5c2ljcycpLFxuXG4gICAgQ2xhc3M6IHJlcXVpcmUoJy4vdXRpbHMvQ2xhc3MnKSxcblxuICAgIFV0aWxzOiB7XG5cbiAgICAgICAgQWxpZ246IHJlcXVpcmUoJy4vdXRpbHMvYWxpZ24vJyksXG4gICAgICAgIEFycmF5OiByZXF1aXJlKCcuL3V0aWxzL2FycmF5LycpLFxuICAgICAgICBCb3VuZHM6IHJlcXVpcmUoJy4vdXRpbHMvYm91bmRzLycpLFxuICAgICAgICBPYmplY3RzOiByZXF1aXJlKCcuL3V0aWxzL29iamVjdC8nKSxcbiAgICAgICAgU3RyaW5nOiByZXF1aXJlKCcuL3V0aWxzL3N0cmluZy8nKVxuXG4gICAgfVxuXG59O1xuXG4vLyAgIE1lcmdlIGluIHRoZSBjb25zdHNcblxuUGhhc2VyID0gRXh0ZW5kKGZhbHNlLCBQaGFzZXIsIENPTlNUKTtcblxuLy8gIEV4cG9ydCBpdFxuXG5tb2R1bGUuZXhwb3J0cyA9IFBoYXNlcjtcblxuZ2xvYmFsLlBoYXNlciA9IFBoYXNlcjtcblxuLypcbiAqIOKAnFNvbWV0aW1lcywgdGhlIGVsZWdhbnQgaW1wbGVtZW50YXRpb24gaXMganVzdCBhIGZ1bmN0aW9uLlxuICogTm90IGEgbWV0aG9kLiBOb3QgYSBjbGFzcy4gTm90IGEgZnJhbWV3b3JrLiBKdXN0IGEgZnVuY3Rpb24u4oCdXG4gKiAtIEpvaG4gQ2FybWFja1xuICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9waGFzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9